begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB eXtensible Host Controller Interface, a.k.a. USB 3.0 controller.  *  * The XHCI 1.0 spec can be found at  * http://www.intel.com/technology/usb/download/xHCI_Specification_for_USB.pdf  * and the USB 3.0 spec at  * http://www.usb.org/developers/docs/usb_30_spec_060910.zip  */
end_comment

begin_comment
comment|/*  * A few words about the design implementation: This driver emulates  * the concept about TDs which is found in EHCI specification. This  * way we avoid too much diveration among USB drivers.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|xhcidebug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/xhci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/xhcireg.h>
end_include

begin_define
define|#
directive|define
name|XHCI_BUS2SC
parameter_list|(
name|bus
parameter_list|)
define|\
value|((struct xhci_softc *)(((uint8_t *)(bus)) - \     ((uint8_t *)&(((struct xhci_softc *)0)->sc_bus))))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|xhcidebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xhciroute
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xhcipolling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xhcidma32
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|xhci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB XHCI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_xhci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|xhcidebug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.xhci.debug"
argument_list|,
operator|&
name|xhcidebug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_xhci
argument_list|,
name|OID_AUTO
argument_list|,
name|xhci_port_route
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|xhciroute
argument_list|,
literal|0
argument_list|,
literal|"Routing bitmap for switching EHCI ports to the XHCI controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.xhci.xhci_port_route"
argument_list|,
operator|&
name|xhciroute
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_xhci
argument_list|,
name|OID_AUTO
argument_list|,
name|use_polling
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|xhcipolling
argument_list|,
literal|0
argument_list|,
literal|"Set to enable software interrupt polling for the XHCI controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.xhci.use_polling"
argument_list|,
operator|&
name|xhcipolling
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_xhci
argument_list|,
name|OID_AUTO
argument_list|,
name|dma32
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|xhcidma32
argument_list|,
literal|0
argument_list|,
literal|"Set to only use 32-bit DMA for the XHCI controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.xhci.dma32"
argument_list|,
operator|&
name|xhcidma32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xhciroute
value|0
end_define

begin_define
define|#
directive|define
name|xhcidma32
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XHCI_INTR_ENDPT
value|1
end_define

begin_struct
struct|struct
name|xhci_std_temp
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_next
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|max_packet_size
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint16_t
name|isoc_delta
decl_stmt|;
name|uint16_t
name|isoc_frame
decl_stmt|;
name|uint8_t
name|shortpkt
decl_stmt|;
name|uint8_t
name|multishort
decl_stmt|;
name|uint8_t
name|last_frame
decl_stmt|;
name|uint8_t
name|trb_type
decl_stmt|;
name|uint8_t
name|direction
decl_stmt|;
name|uint8_t
name|tbc
decl_stmt|;
name|uint8_t
name|tlbpc
decl_stmt|;
name|uint8_t
name|step_td
decl_stmt|;
name|uint8_t
name|do_isoc_sync
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|xhci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xhci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xhci_root_intr
parameter_list|(
name|struct
name|xhci_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xhci_free_device_ext
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|xhci_endpoint_ext
modifier|*
name|xhci_get_endpoint_ext
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|xhci_configure_msg
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|usb_error_t
name|xhci_configure_device
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|xhci_configure_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
parameter_list|,
name|struct
name|xhci_endpoint_ext
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|xhci_configure_mask
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|xhci_cmd_evaluate_ctx
parameter_list|(
name|struct
name|xhci_softc
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xhci_endpoint_doorbell
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xhci_ctx_set_le32
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|xhci_ctx_get_le32
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xhci_ctx_set_le64
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint64_t
modifier|*
name|ptr
parameter_list|,
name|uint64_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|uint64_t
name|xhci_ctx_get_le64
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint64_t
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|usb_bus_methods
name|xhci_bus_methods
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|xhci_dump_trb
parameter_list|(
name|struct
name|xhci_trb
modifier|*
name|trb
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"trb = %p\n"
argument_list|,
name|trb
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"qwTrb0 = 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|le64toh
argument_list|(
name|trb
operator|->
name|qwTrb0
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwTrb2 = 0x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb2
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwTrb3 = 0x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_dump_endpoint
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xhci_endp_ctx
modifier|*
name|pep
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"pep = %p\n"
argument_list|,
name|pep
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwEpCtx0=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|dwEpCtx0
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwEpCtx1=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|dwEpCtx1
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"qwEpCtx2=0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|xhci_ctx_get_le64
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|qwEpCtx2
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwEpCtx4=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|dwEpCtx4
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwEpCtx5=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|dwEpCtx5
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwEpCtx6=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|dwEpCtx6
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwEpCtx7=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pep
operator|->
name|dwEpCtx7
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_dump_device
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xhci_slot_ctx
modifier|*
name|psl
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"psl = %p\n"
argument_list|,
name|psl
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwSctx0=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|psl
operator|->
name|dwSctx0
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwSctx1=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|psl
operator|->
name|dwSctx1
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwSctx2=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|psl
operator|->
name|dwSctx2
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"dwSctx3=0x%08x\n"
argument_list|,
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|psl
operator|->
name|dwSctx3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|uint8_t
name|xhci_use_polling
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
return|return
operator|(
name|xhcipolling
operator|!=
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_iterate_hw_softc
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|usb_bus_mem_sub_cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_hw_root
argument_list|)
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctx_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctx_pg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_dev_ctx_addr
argument_list|)
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|XHCI_MAX_SCRATCHPADS
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|scratch_pc
index|[
name|i
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|scratch_pg
index|[
name|i
index|]
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_ctx_set_le32
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|)
block|{
name|uint32_t
name|offset
decl_stmt|;
comment|/* exploit the fact that our structures are XHCI_PAGE_SIZE aligned */
comment|/* all contexts are initially 32-bytes */
name|offset
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|)
operator|&
operator|(
operator|(
name|XHCI_PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|31U
operator|)
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
name|ptr
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|htole32
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|xhci_ctx_get_le32
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint32_t
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|)
block|{
name|uint32_t
name|offset
decl_stmt|;
comment|/* exploit the fact that our structures are XHCI_PAGE_SIZE aligned */
comment|/* all contexts are initially 32-bytes */
name|offset
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|)
operator|&
operator|(
operator|(
name|XHCI_PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|31U
operator|)
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
name|ptr
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|le32toh
argument_list|(
operator|*
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_ctx_set_le64
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint64_t
modifier|*
name|ptr
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|)
block|{
name|uint32_t
name|offset
decl_stmt|;
comment|/* exploit the fact that our structures are XHCI_PAGE_SIZE aligned */
comment|/* all contexts are initially 32-bytes */
name|offset
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|)
operator|&
operator|(
operator|(
name|XHCI_PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|31U
operator|)
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|uint64_t
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
name|ptr
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|htole64
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|uint64_t
name|xhci_ctx_get_le64
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|uint64_t
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|)
block|{
name|uint32_t
name|offset
decl_stmt|;
comment|/* exploit the fact that our structures are XHCI_PAGE_SIZE aligned */
comment|/* all contexts are initially 32-bytes */
name|offset
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|)
operator|&
operator|(
operator|(
name|XHCI_PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
literal|31U
operator|)
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|uint64_t
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
name|ptr
operator|)
operator|+
name|offset
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|le64toh
argument_list|(
operator|*
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|xhci_reset_command_queue_locked
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|xhci_hw_root
modifier|*
name|phwr
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_LO
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|XHCI_CRCR_LO_CRR
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Command ring running\n"
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|XHCI_CRCR_LO_CS
operator||
name|XHCI_CRCR_LO_CA
operator|)
expr_stmt|;
comment|/* 		 * Try to abort the last command as per section 		 * 4.6.1.2 "Aborting a Command" of the XHCI 		 * specification: 		 */
comment|/* stop and cancel */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_LO
argument_list|,
name|temp
operator||
name|XHCI_CRCR_LO_CS
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_LO
argument_list|,
name|temp
operator||
name|XHCI_CRCR_LO_CA
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_HI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait 250ms */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* check if command ring is still running */
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_LO
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|XHCI_CRCR_LO_CRR
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Comand ring still running\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
block|}
comment|/* reset command ring */
name|sc
operator|->
name|sc_command_ccs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_command_idx
operator|=
literal|0
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* set up command ring control base address */
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|phwr
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|addr
operator|+=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_hw_root
operator|*
operator|)
literal|0
operator|)
operator|->
name|hwr_commands
index|[
literal|0
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CRCR=0x%016llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|phwr
operator|->
name|hwr_commands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|phwr
operator|->
name|hwr_commands
argument_list|)
argument_list|)
expr_stmt|;
name|phwr
operator|->
name|hwr_commands
index|[
name|XHCI_MAX_COMMANDS
operator|-
literal|1
index|]
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_LO
argument_list|,
operator|(
operator|(
name|uint32_t
operator|)
name|addr
operator|)
operator||
name|XHCI_CRCR_LO_RCS
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_HI
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|usb_error_t
name|xhci_start_controller
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|xhci_hw_root
modifier|*
name|phwr
decl_stmt|;
name|struct
name|xhci_dev_ctx_addr
modifier|*
name|pdctxa
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_event_ccs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_event_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_command_ccs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_command_idx
operator|=
literal|0
expr_stmt|;
comment|/* Reset controller */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBCMD
argument_list|,
name|XHCI_CMD_HCRST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBCMD
argument_list|)
operator|&
name|XHCI_CMD_HCRST
operator|)
operator||
operator|(
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|)
operator|&
name|XHCI_STS_CNR
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
block|}
if|if
condition|(
name|temp
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|"Controller "
literal|"reset timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
comment|/* set up number of device slots */
name|DPRINTF
argument_list|(
literal|"CONFIG=0x%08x -> 0x%08x\n"
argument_list|,
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CONFIG
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_noslot
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CONFIG
argument_list|,
name|sc
operator|->
name|sc_noslot
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|)
expr_stmt|;
comment|/* clear interrupts */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disable all device notifications */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_DNCTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up device context base address */
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctx_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|pdctxa
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|memset
argument_list|(
name|pdctxa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pdctxa
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|addr
operator|+=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_dev_ctx_addr
operator|*
operator|)
literal|0
operator|)
operator|->
name|qwSpBufPtr
index|[
literal|0
index|]
expr_stmt|;
comment|/* slot 0 points to the table of scratchpad pointers */
name|pdctxa
operator|->
name|qwBaaDevCtxAddr
index|[
literal|0
index|]
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|sc
operator|->
name|sc_noscratch
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|usb_page_search
name|buf_scp
decl_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|scratch_pc
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_scp
argument_list|)
expr_stmt|;
name|pdctxa
operator|->
name|qwSpBufPtr
index|[
name|i
index|]
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|buf_scp
operator|.
name|physaddr
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_DCBAAP_LO
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_DCBAAP_HI
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_DCBAAP_LO
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_DCBAAP_HI
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up event table size */
name|DPRINTF
argument_list|(
literal|"ERSTSZ=0x%08x -> 0x%08x\n"
argument_list|,
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERSTSZ
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_erst_max
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERSTSZ
argument_list|(
literal|0
argument_list|)
argument_list|,
name|XHCI_ERSTS_SET
argument_list|(
name|sc
operator|->
name|sc_erst_max
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up interrupt rate */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_IMOD
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_imod_default
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|phwr
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|addr
operator|+=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_hw_root
operator|*
operator|)
literal|0
operator|)
operator|->
name|hwr_events
index|[
literal|0
index|]
expr_stmt|;
comment|/* reset hardware root structure */
name|memset
argument_list|(
name|phwr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|phwr
argument_list|)
argument_list|)
expr_stmt|;
name|phwr
operator|->
name|hwr_ring_seg
index|[
literal|0
index|]
operator|.
name|qwEvrsTablePtr
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|phwr
operator|->
name|hwr_ring_seg
index|[
literal|0
index|]
operator|.
name|dwEvrsTableSize
operator|=
name|htole32
argument_list|(
name|XHCI_MAX_EVENTS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"ERDP(0)=0x%016llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERDP_LO
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERDP_HI
argument_list|(
literal|0
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"ERSTBA(0)=0x%016llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERSTBA_LO
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERSTBA_HI
argument_list|(
literal|0
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up interrupter registers */
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_IMAN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator||=
name|XHCI_IMAN_INTR_ENA
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_IMAN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set up command ring control base address */
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|addr
operator|+=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_hw_root
operator|*
operator|)
literal|0
operator|)
operator|->
name|hwr_commands
index|[
literal|0
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CRCR=0x%016llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_LO
argument_list|,
operator|(
operator|(
name|uint32_t
operator|)
name|addr
operator|)
operator||
name|XHCI_CRCR_LO_RCS
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_CRCR_HI
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|phwr
operator|->
name|hwr_commands
index|[
name|XHCI_MAX_COMMANDS
operator|-
literal|1
index|]
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|usb_bus_mem_flush_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|xhci_iterate_hw_softc
argument_list|)
expr_stmt|;
comment|/* Go! */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBCMD
argument_list|,
name|XHCI_CMD_RS
operator||
name|XHCI_CMD_INTE
operator||
name|XHCI_CMD_HSEE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|)
operator|&
name|XHCI_STS_HCH
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
block|}
if|if
condition|(
name|temp
condition|)
block|{
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|"Run timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
comment|/* catch any lost interrupts */
name|xhci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_port_route
operator|!=
name|NULL
condition|)
block|{
comment|/* Route all ports to the XHCI by default */
name|sc
operator|->
name|sc_port_route
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
operator|~
name|xhciroute
argument_list|,
name|xhciroute
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|usb_error_t
name|xhci_halt_controller
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_capa_off
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_oper_off
operator|=
name|XREAD1
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_CAPLENGTH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_runt_off
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_RTSOFF
argument_list|)
operator|&
operator|~
literal|0xF
expr_stmt|;
name|sc
operator|->
name|sc_door_off
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_DBOFF
argument_list|)
operator|&
operator|~
literal|0x3
expr_stmt|;
comment|/* Halt controller */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|)
operator|&
name|XHCI_STS_HCH
expr_stmt|;
if|if
condition|(
name|temp
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|"Controller halt timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|usb_error_t
name|xhci_init
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|self
parameter_list|,
name|uint8_t
name|dma32
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* initialize some bus fields */
name|sc
operator|->
name|sc_bus
operator|.
name|parent
operator|=
name|self
expr_stmt|;
comment|/* set the bus revision */
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USB_REV_3_0
expr_stmt|;
comment|/* set up the bus struct */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|xhci_bus_methods
expr_stmt|;
comment|/* set up devices array */
name|sc
operator|->
name|sc_bus
operator|.
name|devices
operator|=
name|sc
operator|->
name|sc_devices
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|devices_max
operator|=
name|XHCI_MAX_DEVICES
expr_stmt|;
comment|/* set default cycle state in case of early interrupts */
name|sc
operator|->
name|sc_event_ccs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_command_ccs
operator|=
literal|1
expr_stmt|;
comment|/* set up bus space offsets */
name|sc
operator|->
name|sc_capa_off
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_oper_off
operator|=
name|XREAD1
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_CAPLENGTH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_runt_off
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_RTSOFF
argument_list|)
operator|&
operator|~
literal|0x1F
expr_stmt|;
name|sc
operator|->
name|sc_door_off
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_DBOFF
argument_list|)
operator|&
operator|~
literal|0x3
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CAPLENGTH=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_oper_off
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"RUNTIMEOFFSET=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_runt_off
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"DOOROFFSET=0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_door_off
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"xHCI version = 0x%04x\n"
argument_list|,
name|XREAD2
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_HCIVERSION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_PAGESIZE
argument_list|)
operator|&
name|XHCI_PAGESIZE_4K
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|"Controller does "
literal|"not support 4K page size.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_HCSPARAMS0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"HCS0 = 0x%08x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set up context size */
if|if
condition|(
name|XHCI_HCS0_CSZ
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_ctx_is_64_byte
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_ctx_is_64_byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* get DMA bits */
name|sc
operator|->
name|sc_bus
operator|.
name|dma_bits
operator|=
operator|(
name|XHCI_HCS0_AC64
argument_list|(
name|temp
argument_list|)
operator|&&
name|xhcidma32
operator|==
literal|0
operator|&&
name|dma32
operator|==
literal|0
operator|)
condition|?
literal|64
else|:
literal|32
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"%d bytes context size, %d-bit DMA\n"
argument_list|,
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|?
literal|64
else|:
literal|32
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_bus
operator|.
name|dma_bits
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_HCSPARAMS1
argument_list|)
expr_stmt|;
comment|/* get number of device slots */
name|sc
operator|->
name|sc_noport
operator|=
name|XHCI_HCS1_N_PORTS
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_noport
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|"Invalid number "
literal|"of ports: %u\n"
argument_list|,
name|sc
operator|->
name|sc_noport
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_noport
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
name|sc
operator|->
name|sc_noslot
operator|=
name|XHCI_HCS1_DEVSLOT_MAX
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Max slots: %u\n"
argument_list|,
name|sc
operator|->
name|sc_noslot
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_noslot
operator|>
name|XHCI_MAX_DEVICES
condition|)
name|sc
operator|->
name|sc_noslot
operator|=
name|XHCI_MAX_DEVICES
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_HCSPARAMS2
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"HCS2=0x%08x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* get number of scratchpads */
name|sc
operator|->
name|sc_noscratch
operator|=
name|XHCI_HCS2_SPB_MAX
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_noscratch
operator|>
name|XHCI_MAX_SCRATCHPADS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|"XHCI request "
literal|"too many scratchpads\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Max scratch: %u\n"
argument_list|,
name|sc
operator|->
name|sc_noscratch
argument_list|)
expr_stmt|;
comment|/* get event table size */
name|sc
operator|->
name|sc_erst_max
operator|=
literal|1U
operator|<<
name|XHCI_HCS2_ERST_MAX
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_erst_max
operator|>
name|XHCI_MAX_RSEG
condition|)
name|sc
operator|->
name|sc_erst_max
operator|=
name|XHCI_MAX_RSEG
expr_stmt|;
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_HCSPARAMS3
argument_list|)
expr_stmt|;
comment|/* get maximum exit latency */
name|sc
operator|->
name|sc_exit_lat_max
operator|=
name|XHCI_HCS3_U1_DEL
argument_list|(
name|temp
argument_list|)
operator|+
name|XHCI_HCS3_U2_DEL
argument_list|(
name|temp
argument_list|)
operator|+
literal|250
comment|/* us */
expr_stmt|;
comment|/* Check if we should use the default IMOD value. */
if|if
condition|(
name|sc
operator|->
name|sc_imod_default
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_imod_default
operator|=
name|XHCI_IMOD_DEFAULT
expr_stmt|;
comment|/* get all DMA memory */
if|if
condition|(
name|usb_bus_mem_alloc_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_GET_DMA_TAG
argument_list|(
name|self
argument_list|)
argument_list|,
operator|&
name|xhci_iterate_hw_softc
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* set up command queue mutex and condition varible */
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_cv
argument_list|,
literal|"CMDQ"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_sx
argument_list|,
literal|"CMDQ lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_proc_create
argument_list|(
operator|&
name|sc
operator|->
name|sc_config_proc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|self
argument_list|)
argument_list|,
name|USB_PRI_MED
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: Creation of XHCI configure "
literal|"callback process failed.\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|xhci_configure_msg
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
operator|.
name|bus
operator|=
operator|&
name|sc
operator|->
name|sc_bus
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|xhci_configure_msg
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
operator|.
name|bus
operator|=
operator|&
name|sc
operator|->
name|sc_bus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xhci_uninit
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|usb_proc_free
argument_list|(
operator|&
name|sc
operator|->
name|sc_config_proc
argument_list|)
expr_stmt|;
name|usb_bus_mem_free_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|xhci_iterate_hw_softc
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_cv
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_set_hw_power_sleep
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint32_t
name|state
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|USB_HW_POWER_SUSPEND
case|:
name|DPRINTF
argument_list|(
literal|"Stopping the XHCI\n"
argument_list|)
expr_stmt|;
name|xhci_halt_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_HW_POWER_SHUTDOWN
case|:
name|DPRINTF
argument_list|(
literal|"Stopping the XHCI\n"
argument_list|)
expr_stmt|;
name|xhci_halt_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_HW_POWER_RESUME
case|:
name|DPRINTF
argument_list|(
literal|"Starting the XHCI\n"
argument_list|)
expr_stmt|;
name|xhci_start_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_generic_done_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|td_alt_next
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|td
operator|->
name|status
expr_stmt|;
name|len
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"xfer=%p[%u/%u] rem=%u/%u status=%u\n"
argument_list|,
name|xfer
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|xfer
operator|->
name|aframes
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|xfer
operator|->
name|nframes
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|td
operator|->
name|len
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
comment|/* 	         * Verify the status length and 		 * add the length to "frlengths[]": 	         */
if|if
condition|(
name|len
operator|>
name|td
operator|->
name|len
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
literal|"Invalid status length, "
literal|"0x%04x/0x%04x bytes\n"
argument_list|,
name|len
argument_list|,
name|td
operator|->
name|len
argument_list|)
expr_stmt|;
name|status
operator|=
name|XHCI_TRB_ERROR_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|+=
name|td
operator|->
name|len
operator|-
name|len
expr_stmt|;
block|}
comment|/* Check for last transfer */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for transfer error */
if|if
condition|(
name|status
operator|!=
name|XHCI_TRB_ERROR_SHORT_PKT
operator|&&
name|status
operator|!=
name|XHCI_TRB_ERROR_SUCCESS
condition|)
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for short transfer */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* follow alt next */
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
block|}
else|else
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|alt_next
operator|!=
name|td_alt_next
condition|)
block|{
comment|/* this USB frame is complete */
break|break;
block|}
block|}
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
return|return
operator|(
operator|(
name|status
operator|==
name|XHCI_TRB_ERROR_STALL
operator|)
condition|?
name|USB_ERR_STALLED
else|:
operator|(
name|status
operator|!=
name|XHCI_TRB_ERROR_SHORT_PKT
operator|&&
name|status
operator|!=
name|XHCI_TRB_ERROR_SUCCESS
operator|)
condition|?
name|USB_ERR_IOERROR
else|:
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_generic_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
comment|/* reset scanner */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
name|err
operator|=
name|xhci_generic_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|err
operator|=
name|xhci_generic_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
name|err
operator|=
name|xhci_generic_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* transfer is complete */
name|xhci_device_done
argument_list|(
name|xfer
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_activate_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator|&
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
operator|)
condition|)
block|{
comment|/* activate the transfer */
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator||=
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|xhci_endpoint_doorbell
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_skip_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_last
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|td_last
operator|=
name|xfer
operator|->
name|td_transfer_last
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator|&
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
operator|)
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td_last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* copy LINK TRB to current waiting location */
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|qwTrb0
operator|=
name|td_last
operator|->
name|td_trb
index|[
name|td_last
operator|->
name|ntrb
index|]
operator|.
name|qwTrb0
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb2
operator|=
name|td_last
operator|->
name|td_trb
index|[
name|td_last
operator|->
name|ntrb
index|]
operator|.
name|dwTrb2
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator|=
name|td_last
operator|->
name|td_trb
index|[
name|td_last
operator|->
name|ntrb
index|]
operator|.
name|dwTrb3
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|xhci_endpoint_doorbell
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	xhci_check_transfer  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|xhci_check_transfer
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xhci_trb
modifier|*
name|trb
parameter_list|)
block|{
name|int64_t
name|offset
decl_stmt|;
name|uint64_t
name|td_event
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|remainder
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
name|uint8_t
name|halted
decl_stmt|;
name|uint8_t
name|epno
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* decode TRB */
name|td_event
operator|=
name|le64toh
argument_list|(
name|trb
operator|->
name|qwTrb0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb2
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|XHCI_TRB_2_REM_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|status
operator|=
name|XHCI_TRB_2_ERROR_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb3
argument_list|)
expr_stmt|;
name|epno
operator|=
name|XHCI_TRB_3_EP_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|index
operator|=
name|XHCI_TRB_3_SLOT_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* check if error means halted */
name|halted
operator|=
operator|(
name|status
operator|!=
name|XHCI_TRB_ERROR_SHORT_PKT
operator|&&
name|status
operator|!=
name|XHCI_TRB_ERROR_SUCCESS
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"slot=%u epno=%u remainder=%u status=%u\n"
argument_list|,
name|index
argument_list|,
name|epno
argument_list|,
name|remainder
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|sc
operator|->
name|sc_noslot
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Invalid slot.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|epno
operator|==
literal|0
operator|)
operator|||
operator|(
name|epno
operator|>=
name|XHCI_MAX_ENDPOINTS
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Invalid endpoint.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to find the USB transfer that generated the event */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
operator|(
name|XHCI_MAX_TRANSFERS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|pepext
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|endp
index|[
name|epno
index|]
expr_stmt|;
name|xfer
operator|=
name|pepext
operator|->
name|xfer
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
continue|continue;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"Checking if 0x%016llx == (0x%016llx .. 0x%016llx)\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|td_event
argument_list|,
operator|(
name|long
name|long
operator|)
name|td
operator|->
name|td_self
argument_list|,
operator|(
name|long
name|long
operator|)
name|td
operator|->
name|td_self
operator|+
sizeof|sizeof
argument_list|(
name|td
operator|->
name|td_trb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * NOTE: Some XHCI implementations might not trigger 		 * an event on the last LINK TRB so we need to 		 * consider both the last and second last event 		 * address as conditions for a successful transfer. 		 * 		 * NOTE: We assume that the XHCI will only trigger one 		 * event per chain of TRBs. 		 */
name|offset
operator|=
name|td_event
operator|-
name|td
operator|->
name|td_self
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<
operator|(
name|int64_t
operator|)
sizeof|sizeof
argument_list|(
name|td
operator|->
name|td_trb
argument_list|)
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* compute rest of remainder, if any */
for|for
control|(
name|i
operator|=
operator|(
name|offset
operator|/
literal|16
operator|)
operator|+
literal|1
init|;
name|i
operator|<
name|td
operator|->
name|ntrb
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_trb
index|[
name|i
index|]
operator|.
name|dwTrb2
argument_list|)
expr_stmt|;
name|remainder
operator|+=
name|XHCI_TRB_2_BYTES_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"New remainder: %u\n"
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
comment|/* clear isochronous transfer errors */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
if|if
condition|(
name|halted
condition|)
block|{
name|halted
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|XHCI_TRB_ERROR_SUCCESS
expr_stmt|;
name|remainder
operator|=
name|td
operator|->
name|len
expr_stmt|;
block|}
block|}
comment|/* "td->remainder" is verified later */
name|td
operator|->
name|remainder
operator|=
name|remainder
expr_stmt|;
name|td
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 			 * 1) Last transfer descriptor makes the 			 * transfer done 			 */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"TD is last\n"
argument_list|)
expr_stmt|;
name|xhci_generic_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * 2) Any kind of error makes the transfer 			 * done 			 */
if|if
condition|(
name|halted
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"TD has I/O error\n"
argument_list|)
expr_stmt|;
name|xhci_generic_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * 3) If there is no alternate next transfer, 			 * a short packet also makes the transfer done 			 */
if|if
condition|(
name|td
operator|->
name|remainder
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|alt_next
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"short TD has no alternate next\n"
argument_list|)
expr_stmt|;
name|xhci_generic_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"TD has short pkt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* follow the alt next */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
name|xhci_activate_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
name|xhci_skip_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xhci_generic_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * 4) Transfer complete - go to next TD 			 */
name|DPRINTF
argument_list|(
literal|"Following next TD\n"
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
name|xhci_activate_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
comment|/* there should only be one match */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xhci_check_command
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xhci_trb
modifier|*
name|trb
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cmd_addr
operator|==
name|trb
operator|->
name|qwTrb0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Received command event\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cmd_result
index|[
literal|0
index|]
operator|=
name|trb
operator|->
name|dwTrb2
expr_stmt|;
name|sc
operator|->
name|sc_cmd_result
index|[
literal|1
index|]
operator|=
name|trb
operator|->
name|dwTrb3
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_cv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* command match */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xhci_interrupt_poll
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|xhci_hw_root
modifier|*
name|phwr
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
name|event
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|uint8_t
name|k
decl_stmt|;
name|uint8_t
name|t
decl_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|phwr
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* Receive any events */
name|usb_pc_cpu_invalidate
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|)
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|sc_event_idx
expr_stmt|;
name|j
operator|=
name|sc
operator|->
name|sc_event_ccs
expr_stmt|;
name|t
operator|=
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|temp
operator|=
name|le32toh
argument_list|(
name|phwr
operator|->
name|hwr_events
index|[
name|i
index|]
operator|.
name|dwTrb3
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|temp
operator|&
name|XHCI_TRB_3_CYCLE_BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|k
condition|)
break|break;
name|event
operator|=
name|XHCI_TRB_3_TYPE_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
literal|"event[%u] = %u (0x%016llx 0x%08lx 0x%08lx)\n"
argument_list|,
name|i
argument_list|,
name|event
argument_list|,
operator|(
name|long
name|long
operator|)
name|le64toh
argument_list|(
name|phwr
operator|->
name|hwr_events
index|[
name|i
index|]
operator|.
name|qwTrb0
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|phwr
operator|->
name|hwr_events
index|[
name|i
index|]
operator|.
name|dwTrb2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|phwr
operator|->
name|hwr_events
index|[
name|i
index|]
operator|.
name|dwTrb3
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|XHCI_TRB_EVENT_TRANSFER
case|:
name|xhci_check_transfer
argument_list|(
name|sc
argument_list|,
operator|&
name|phwr
operator|->
name|hwr_events
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|XHCI_TRB_EVENT_CMD_COMPLETE
case|:
name|retval
operator||=
name|xhci_check_command
argument_list|(
name|sc
argument_list|,
operator|&
name|phwr
operator|->
name|hwr_events
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unhandled event = %u\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|XHCI_MAX_EVENTS
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|^=
literal|1
expr_stmt|;
comment|/* check for timeout */
if|if
condition|(
operator|!
operator|--
name|t
condition|)
break|break;
block|}
block|}
name|sc
operator|->
name|sc_event_idx
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_event_ccs
operator|=
name|j
expr_stmt|;
comment|/* 	 * NOTE: The Event Ring Dequeue Pointer Register is 64-bit 	 * latched. That means to activate the register we need to 	 * write both the low and high double word of the 64-bit 	 * register. 	 */
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|addr
operator|+=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_hw_root
operator|*
operator|)
literal|0
operator|)
operator|->
name|hwr_events
index|[
name|i
index|]
expr_stmt|;
comment|/* try to clear busy bit */
name|addr
operator||=
name|XHCI_ERDP_LO_BUSY
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERDP_LO
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_ERDP_HI
argument_list|(
literal|0
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_do_command
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|xhci_trb
modifier|*
name|trb
parameter_list|,
name|uint16_t
name|timeout_ms
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|xhci_hw_root
modifier|*
name|phwr
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|uint8_t
name|timeout
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|XHCI_CMD_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get hardware root structure */
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|phwr
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* Queue command */
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|retry
label|:
name|i
operator|=
name|sc
operator|->
name|sc_command_idx
expr_stmt|;
name|j
operator|=
name|sc
operator|->
name|sc_command_ccs
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
literal|"command[%u] = %u (0x%016llx, 0x%08lx, 0x%08lx)\n"
argument_list|,
name|i
argument_list|,
name|XHCI_TRB_3_TYPE_GET
argument_list|(
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb3
argument_list|)
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|le64toh
argument_list|(
name|trb
operator|->
name|qwTrb0
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb3
argument_list|)
argument_list|)
expr_stmt|;
name|phwr
operator|->
name|hwr_commands
index|[
name|i
index|]
operator|.
name|qwTrb0
operator|=
name|trb
operator|->
name|qwTrb0
expr_stmt|;
name|phwr
operator|->
name|hwr_commands
index|[
name|i
index|]
operator|.
name|dwTrb2
operator|=
name|trb
operator|->
name|dwTrb2
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|trb
operator|->
name|dwTrb3
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|temp
operator||=
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
expr_stmt|;
else|else
name|temp
operator|&=
operator|~
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|htole32
argument_list|(
name|XHCI_TRB_3_TC_BIT
argument_list|)
expr_stmt|;
name|phwr
operator|->
name|hwr_commands
index|[
name|i
index|]
operator|.
name|dwTrb3
operator|=
name|temp
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|)
expr_stmt|;
name|addr
operator|=
name|buf_res
operator|.
name|physaddr
expr_stmt|;
name|addr
operator|+=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_hw_root
operator|*
operator|)
literal|0
operator|)
operator|->
name|hwr_commands
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|sc_cmd_addr
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|XHCI_MAX_COMMANDS
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|j
condition|)
block|{
name|temp
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_3_TC_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_LINK
argument_list|)
operator||
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_3_TC_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_LINK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|phwr
operator|->
name|hwr_commands
index|[
name|i
index|]
operator|.
name|dwTrb3
operator|=
name|temp
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|root_pc
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|^=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_command_idx
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_command_ccs
operator|=
name|j
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|door
argument_list|,
name|XHCI_DOORBELL
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|sc
operator|->
name|sc_cmd_cv
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|timeout_ms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * In some error cases event interrupts are not generated. 	 * Poll one time to see if the command has completed. 	 */
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|xhci_interrupt_poll
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Command was completed when polling\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Command timeout!\n"
argument_list|)
expr_stmt|;
comment|/* 		 * After some weeks of continuous operation, it has 		 * been observed that the ASMedia Technology, ASM1042 		 * SuperSpeed USB Host Controller can suddenly stop 		 * accepting commands via the command queue. Try to 		 * first reset the command queue. If that fails do a 		 * host controller reset. 		 */
if|if
condition|(
name|timeout
operator|==
literal|0
operator|&&
name|xhci_reset_command_queue_locked
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|le32toh
argument_list|(
name|trb
operator|->
name|dwTrb3
argument_list|)
expr_stmt|;
comment|/* 			 * Avoid infinite XHCI reset loops if the set 			 * address command fails to respond due to a 			 * non-enumerating device: 			 */
if|if
condition|(
name|XHCI_TRB_3_TYPE_GET
argument_list|(
name|temp
argument_list|)
operator|==
name|XHCI_TRB_TYPE_ADDRESS_DEVICE
operator|&&
operator|(
name|temp
operator|&
name|XHCI_TRB_3_BSR_BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Set address timeout\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeout
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"Controller reset!\n"
argument_list|)
expr_stmt|;
name|usb_bus_reset_async_locked
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|USB_ERR_TIMEOUT
expr_stmt|;
name|trb
operator|->
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|trb
operator|->
name|dwTrb3
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_cmd_result
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|XHCI_TRB_2_ERROR_GET
argument_list|(
name|temp
argument_list|)
operator|!=
name|XHCI_TRB_ERROR_SUCCESS
condition|)
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
name|trb
operator|->
name|dwTrb2
operator|=
name|sc
operator|->
name|sc_cmd_result
index|[
literal|0
index|]
expr_stmt|;
name|trb
operator|->
name|dwTrb3
operator|=
name|sc
operator|->
name|sc_cmd_result
index|[
literal|1
index|]
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static usb_error_t xhci_cmd_nop(struct xhci_softc *sc) { 	struct xhci_trb trb; 	uint32_t temp;  	DPRINTF("\n");  	trb.qwTrb0 = 0; 	trb.dwTrb2 = 0; 	temp = XHCI_TRB_3_TYPE_SET(XHCI_TRB_TYPE_NOOP);  	trb.dwTrb3 = htole32(temp);  	return (xhci_do_command(sc,&trb, 100
comment|/* ms */
end_comment

begin_endif
unit|)); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_enable_slot
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|pslot
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_ENABLE_SLOT
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
name|temp
operator|=
name|le32toh
argument_list|(
name|trb
operator|.
name|dwTrb3
argument_list|)
expr_stmt|;
operator|*
name|pslot
operator|=
name|XHCI_TRB_3_SLOT_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_disable_slot
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_DISABLE_SLOT
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_set_address
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|input_ctx
parameter_list|,
name|uint8_t
name|bsr
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|input_ctx
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_ADDRESS_DEVICE
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsr
condition|)
name|temp
operator||=
name|XHCI_TRB_3_BSR_BIT
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|500
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_set_address
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|,
name|uint16_t
name|address
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_inp
decl_stmt|;
name|struct
name|usb_page_search
name|buf_dev
decl_stmt|;
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|xhci_hw_dev
modifier|*
name|hdev
decl_stmt|;
name|struct
name|xhci_dev_ctx
modifier|*
name|pdev
decl_stmt|;
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint16_t
name|mps
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
comment|/* the root HUB case is not handled here */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|hdev
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdev
operator|->
name|state
condition|)
block|{
case|case
name|XHCI_ST_DEFAULT
case|:
case|case
name|XHCI_ST_ENABLED
case|:
name|hdev
operator|->
name|state
operator|=
name|XHCI_ST_ENABLED
expr_stmt|;
comment|/* set configure mask to slot and EP0 */
name|xhci_configure_mask
argument_list|(
name|udev
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* configure input slot context structure */
name|err
operator|=
name|xhci_configure_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Could not configure device\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* configure input endpoint context structure */
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
name|mps
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|USB_SPEED_HIGH
case|:
name|mps
operator|=
literal|64
expr_stmt|;
break|break;
default|default:
name|mps
operator|=
literal|512
expr_stmt|;
break|break;
block|}
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|udev
argument_list|,
operator|&
name|udev
operator|->
name|ctrl_ep_desc
argument_list|)
expr_stmt|;
comment|/* ensure the control endpoint is setup again */
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|pepext
operator|->
name|trb_halted
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_running
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_configure_endpoint
argument_list|(
name|udev
argument_list|,
operator|&
name|udev
operator|->
name|ctrl_ep_desc
argument_list|,
name|pepext
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|mps
argument_list|,
name|mps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Could not configure default endpoint\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* execute set address command */
name|usbd_get_page
argument_list|(
operator|&
name|hdev
operator|->
name|input_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_inp
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_cmd_set_address
argument_list|(
name|sc
argument_list|,
name|buf_inp
operator|.
name|physaddr
argument_list|,
operator|(
name|address
operator|==
literal|0
operator|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|sc_cmd_result
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_port_route
operator|!=
name|NULL
operator|&&
name|XHCI_TRB_2_ERROR_GET
argument_list|(
name|temp
argument_list|)
operator|==
name|XHCI_TRB_ERROR_PARAMETER
condition|)
block|{
comment|/* LynxPoint XHCI - ports are not switchable */
comment|/* Un-route all ports from the XHCI */
name|sc
operator|->
name|sc_port_route
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|parent
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"Could not set address "
literal|"for slot %u.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* update device address to new value */
name|usbd_get_page
argument_list|(
operator|&
name|hdev
operator|->
name|device_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_dev
argument_list|)
expr_stmt|;
name|pdev
operator|=
name|buf_dev
operator|.
name|buffer
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
operator|&
name|hdev
operator|->
name|device_pc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pdev
operator|->
name|ctx_slot
operator|.
name|dwSctx3
argument_list|)
expr_stmt|;
name|udev
operator|->
name|address
operator|=
name|XHCI_SCTX_3_DEV_ADDR_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* update device state to new value */
if|if
condition|(
name|address
operator|!=
literal|0
condition|)
name|hdev
operator|->
name|state
operator|=
name|XHCI_ST_ADDRESSED
expr_stmt|;
else|else
name|hdev
operator|->
name|state
operator|=
name|XHCI_ST_DEFAULT
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Wrong state for set address.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
break|break;
block|}
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_configure_ep
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|input_ctx
parameter_list|,
name|uint8_t
name|deconfigure
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|input_ctx
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_CONFIGURE_EP
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|deconfigure
condition|)
name|temp
operator||=
name|XHCI_TRB_3_DCEP_BIT
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_evaluate_ctx
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|input_ctx
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|input_ctx
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_EVALUATE_CTX
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_reset_ep
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|preserve
parameter_list|,
name|uint8_t
name|ep_id
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_RESET_EP
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
operator||
name|XHCI_TRB_3_EP_SET
argument_list|(
name|ep_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve
condition|)
name|temp
operator||=
name|XHCI_TRB_3_PRSV_BIT
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_set_tr_dequeue_ptr
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|dequeue_ptr
parameter_list|,
name|uint16_t
name|stream_id
parameter_list|,
name|uint8_t
name|ep_id
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|dequeue_ptr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_2_STREAM_SET
argument_list|(
name|stream_id
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_SET_TR_DEQUEUE
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
operator||
name|XHCI_TRB_3_EP_SET
argument_list|(
name|ep_id
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_stop_ep
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|suspend
parameter_list|,
name|uint8_t
name|ep_id
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_STOP_EP
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
operator||
name|XHCI_TRB_3_EP_SET
argument_list|(
name|ep_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspend
condition|)
name|temp
operator||=
name|XHCI_TRB_3_SUSP_EP_BIT
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_cmd_reset_dev
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|slot_id
parameter_list|)
block|{
name|struct
name|xhci_trb
name|trb
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|trb
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|trb
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_RESET_DEVICE
argument_list|)
operator||
name|XHCI_TRB_3_SLOT_SET
argument_list|(
name|slot_id
argument_list|)
expr_stmt|;
name|trb
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_do_command
argument_list|(
name|sc
argument_list|,
operator|&
name|trb
argument_list|,
literal|100
comment|/* ms */
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	xhci_interrupt - XHCI interrupt handler  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|xhci_interrupt
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|status
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|)
expr_stmt|;
comment|/* acknowledge interrupts, if any */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_USBSTS
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"real interrupt (status=0x%08x)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_IMAN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* force clearing of pending interrupts */
if|if
condition|(
name|temp
operator|&
name|XHCI_IMAN_INTR_PEND
condition|)
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_IMAN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* check for event(s) */
name|xhci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|XHCI_STS_PCD
operator||
name|XHCI_STS_HCH
operator||
name|XHCI_STS_HSE
operator||
name|XHCI_STS_HCE
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|XHCI_STS_PCD
condition|)
block|{
name|xhci_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|XHCI_STS_HCH
condition|)
block|{
name|printf
argument_list|(
literal|"%s: host controller halted\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|XHCI_STS_HSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: host system error\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|XHCI_STS_HCE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: host controller error\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	xhci_timeout - XHCI timeout handler  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|xhci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"xfer=%p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* transfer is transferred */
name|xhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|xhci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_setup_generic_chain_sub
parameter_list|(
name|struct
name|xhci_std_temp
modifier|*
name|temp
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_next
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_alt_next
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_first
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|len_old
decl_stmt|;
name|uint32_t
name|npkt_off
decl_stmt|;
name|uint32_t
name|dword
decl_stmt|;
name|uint8_t
name|shortpkt_old
decl_stmt|;
name|uint8_t
name|precompute
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|shortpkt_old
operator|=
name|temp
operator|->
name|shortpkt
expr_stmt|;
name|len_old
operator|=
name|temp
operator|->
name|len
expr_stmt|;
name|npkt_off
operator|=
literal|0
expr_stmt|;
name|precompute
operator|=
literal|1
expr_stmt|;
name|restart
label|:
name|td
operator|=
name|temp
operator|->
name|td
expr_stmt|;
name|td_next
operator|=
name|td_first
operator|=
name|temp
operator|->
name|td_next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|shortpkt
condition|)
break|break;
comment|/* send a Zero Length Packet, ZLP, last */
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
name|average
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|average
operator|=
name|temp
operator|->
name|average
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|len
operator|<
name|average
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|%
name|temp
operator|->
name|max_packet_size
condition|)
block|{
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
block|}
name|average
operator|=
name|temp
operator|->
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|td_next
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: out of XHCI transfer descriptors!"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* get next TD */
name|td
operator|=
name|td_next
expr_stmt|;
name|td_next
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* check if we are pre-computing */
if|if
condition|(
name|precompute
condition|)
block|{
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
continue|continue;
block|}
comment|/* fill out current TD */
name|td
operator|->
name|len
operator|=
name|average
expr_stmt|;
name|td
operator|->
name|remainder
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
comment|/* reset TRB index */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|trb_type
operator|==
name|XHCI_TRB_TYPE_SETUP_STAGE
condition|)
block|{
comment|/* immediate data */
if|if
condition|(
name|average
operator|>
literal|8
condition|)
name|average
operator|=
literal|8
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|temp
operator|->
name|offset
operator|+
name|buf_offset
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|qwTrb0
argument_list|,
name|average
argument_list|)
expr_stmt|;
name|dword
operator|=
name|XHCI_TRB_2_BYTES_SET
argument_list|(
literal|8
argument_list|)
operator||
name|XHCI_TRB_2_TDSZ_SET
argument_list|(
literal|0
argument_list|)
operator||
name|XHCI_TRB_2_IRQ_SET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|dword
argument_list|)
expr_stmt|;
name|dword
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_SETUP_STAGE
argument_list|)
operator||
name|XHCI_TRB_3_IDT_BIT
operator||
name|XHCI_TRB_3_CYCLE_BIT
expr_stmt|;
comment|/* check wLength */
if|if
condition|(
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|qwTrb0
operator|&
name|htole64
argument_list|(
name|XHCI_TRB_0_WLENGTH_MASK
argument_list|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|qwTrb0
operator|&
name|htole64
argument_list|(
name|XHCI_TRB_0_DIR_IN_MASK
argument_list|)
condition|)
name|dword
operator||=
name|XHCI_TRB_3_TRT_IN
expr_stmt|;
else|else
name|dword
operator||=
name|XHCI_TRB_3_TRT_OUT
expr_stmt|;
block|}
name|td
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|dword
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_trb
argument_list|(
operator|&
name|td
operator|->
name|td_trb
index|[
name|x
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|++
expr_stmt|;
block|}
else|else
do|do
block|{
name|uint32_t
name|npkt
decl_stmt|;
comment|/* fill out buffer pointers */
if|if
condition|(
name|average
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|buf_res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf_res
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usbd_get_page
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|temp
operator|->
name|offset
operator|+
name|buf_offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* get length to end of page */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|average
condition|)
name|buf_res
operator|.
name|length
operator|=
name|average
expr_stmt|;
comment|/* check for maximum length */
if|if
condition|(
name|buf_res
operator|.
name|length
operator|>
name|XHCI_TD_PAGE_SIZE
condition|)
name|buf_res
operator|.
name|length
operator|=
name|XHCI_TD_PAGE_SIZE
expr_stmt|;
name|npkt_off
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
block|}
comment|/* set up npkt */
name|npkt
operator|=
operator|(
name|len_old
operator|-
name|npkt_off
operator|+
name|temp
operator|->
name|max_packet_size
operator|-
literal|1
operator|)
operator|/
name|temp
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|npkt
operator|==
literal|0
condition|)
name|npkt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|npkt
operator|>
literal|31
condition|)
name|npkt
operator|=
literal|31
expr_stmt|;
comment|/* fill out TRB's */
name|td
operator|->
name|td_trb
index|[
name|x
index|]
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|dword
operator|=
name|XHCI_TRB_2_BYTES_SET
argument_list|(
name|buf_res
operator|.
name|length
argument_list|)
operator||
name|XHCI_TRB_2_TDSZ_SET
argument_list|(
name|npkt
argument_list|)
operator||
name|XHCI_TRB_2_IRQ_SET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
name|x
index|]
operator|.
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|dword
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|temp
operator|->
name|trb_type
condition|)
block|{
case|case
name|XHCI_TRB_TYPE_ISOCH
case|:
name|dword
operator|=
name|XHCI_TRB_3_CHAIN_BIT
operator||
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TBC_SET
argument_list|(
name|temp
operator|->
name|tbc
argument_list|)
operator||
name|XHCI_TRB_3_TLBPC_SET
argument_list|(
name|temp
operator|->
name|tlbpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|td_first
condition|)
block|{
name|dword
operator||=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_NORMAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|->
name|do_isoc_sync
operator|!=
literal|0
condition|)
block|{
name|temp
operator|->
name|do_isoc_sync
operator|=
literal|0
expr_stmt|;
comment|/* wait until "isoc_frame" */
name|dword
operator||=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_ISOCH
argument_list|)
operator||
name|XHCI_TRB_3_FRID_SET
argument_list|(
name|temp
operator|->
name|isoc_frame
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* start data transfer at next interval */
name|dword
operator||=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_ISOCH
argument_list|)
operator||
name|XHCI_TRB_3_ISO_SIA_BIT
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|->
name|direction
operator|==
name|UE_DIR_IN
condition|)
name|dword
operator||=
name|XHCI_TRB_3_ISP_BIT
expr_stmt|;
break|break;
case|case
name|XHCI_TRB_TYPE_DATA_STAGE
case|:
name|dword
operator|=
name|XHCI_TRB_3_CHAIN_BIT
operator||
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_DATA_STAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|direction
operator|==
name|UE_DIR_IN
condition|)
name|dword
operator||=
name|XHCI_TRB_3_DIR_IN
operator||
name|XHCI_TRB_3_ISP_BIT
expr_stmt|;
comment|/* 				 * Section 3.2.9 in the XHCI 				 * specification about control 				 * transfers says that we should use a 				 * normal-TRB if there are more TRBs 				 * extending the data-stage 				 * TRB. Update the "trb_type". 				 */
name|temp
operator|->
name|trb_type
operator|=
name|XHCI_TRB_TYPE_NORMAL
expr_stmt|;
break|break;
case|case
name|XHCI_TRB_TYPE_STATUS_STAGE
case|:
name|dword
operator|=
name|XHCI_TRB_3_CHAIN_BIT
operator||
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_STATUS_STAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|direction
operator|==
name|UE_DIR_IN
condition|)
name|dword
operator||=
name|XHCI_TRB_3_DIR_IN
expr_stmt|;
break|break;
default|default:
comment|/* XHCI_TRB_TYPE_NORMAL */
name|dword
operator|=
name|XHCI_TRB_3_CHAIN_BIT
operator||
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|direction
operator|==
name|UE_DIR_IN
condition|)
name|dword
operator||=
name|XHCI_TRB_3_ISP_BIT
expr_stmt|;
break|break;
block|}
name|td
operator|->
name|td_trb
index|[
name|x
index|]
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|dword
argument_list|)
expr_stmt|;
name|average
operator|-=
name|buf_res
operator|.
name|length
expr_stmt|;
name|buf_offset
operator|+=
name|buf_res
operator|.
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_trb
argument_list|(
operator|&
name|td
operator|->
name|td_trb
index|[
name|x
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|average
operator|!=
literal|0
condition|)
do|;
name|td
operator|->
name|td_trb
index|[
name|x
operator|-
literal|1
index|]
operator|.
name|dwTrb3
operator||=
name|htole32
argument_list|(
name|XHCI_TRB_3_IOC_BIT
argument_list|)
expr_stmt|;
comment|/* store number of data TRB's */
name|td
operator|->
name|ntrb
operator|=
name|x
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"NTRB=%u\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* fill out link TRB */
if|if
condition|(
name|td_next
operator|!=
name|NULL
condition|)
block|{
comment|/* link the current TD with the next one */
name|td
operator|->
name|td_trb
index|[
name|x
index|]
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|td_next
operator|->
name|td_self
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"LINK=0x%08llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|td_next
operator|->
name|td_self
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this field will get updated later */
name|DPRINTF
argument_list|(
literal|"NOLINK\n"
argument_list|)
expr_stmt|;
block|}
name|dword
operator|=
name|XHCI_TRB_2_IRQ_SET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
name|x
index|]
operator|.
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|dword
argument_list|)
expr_stmt|;
name|dword
operator|=
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_LINK
argument_list|)
operator||
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_IOC_BIT
operator||
comment|/* 		     * CHAIN-BIT: Ensure that a multi-TRB IN-endpoint 		     * frame only receives a single short packet event 		     * by setting the CHAIN bit in the LINK field. In 		     * addition some XHCI controllers have problems 		     * sending a ZLP unless the CHAIN-BIT is set in 		     * the LINK TRB. 		     */
name|XHCI_TRB_3_CHAIN_BIT
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
name|x
index|]
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|dword
argument_list|)
expr_stmt|;
name|td
operator|->
name|alt_next
operator|=
name|td_alt_next
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_trb
argument_list|(
operator|&
name|td
operator|->
name|td_trb
index|[
name|x
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precompute
condition|)
block|{
name|precompute
operator|=
literal|0
expr_stmt|;
comment|/* set up alt next pointer, if any */
if|if
condition|(
name|temp
operator|->
name|last_frame
condition|)
block|{
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* we use this field internally */
name|td_alt_next
operator|=
name|td_next
expr_stmt|;
block|}
comment|/* restore */
name|temp
operator|->
name|shortpkt
operator|=
name|shortpkt_old
expr_stmt|;
name|temp
operator|->
name|len
operator|=
name|len_old
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Remove cycle bit from the first TRB if we are 	 * stepping them: 	 */
if|if
condition|(
name|temp
operator|->
name|step_td
operator|!=
literal|0
condition|)
block|{
name|td_first
operator|->
name|td_trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator|&=
operator|~
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td_first
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
comment|/* clear TD SIZE to zero, hence this is the last TRB */
comment|/* remove chain bit because this is the last data TRB in the chain */
name|td
operator|->
name|td_trb
index|[
name|td
operator|->
name|ntrb
operator|-
literal|1
index|]
operator|.
name|dwTrb2
operator|&=
operator|~
name|htole32
argument_list|(
name|XHCI_TRB_2_TDSZ_SET
argument_list|(
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_trb
index|[
name|td
operator|->
name|ntrb
operator|-
literal|1
index|]
operator|.
name|dwTrb3
operator|&=
operator|~
name|htole32
argument_list|(
name|XHCI_TRB_3_CHAIN_BIT
argument_list|)
expr_stmt|;
comment|/* remove CHAIN-BIT from last LINK TRB */
name|td
operator|->
name|td_trb
index|[
name|td
operator|->
name|ntrb
index|]
operator|.
name|dwTrb3
operator|&=
operator|~
name|htole32
argument_list|(
name|XHCI_TRB_3_CHAIN_BIT
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|temp
operator|->
name|td
operator|=
name|td
expr_stmt|;
name|temp
operator|->
name|td_next
operator|=
name|td_next
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_setup_generic_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_std_temp
name|temp
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint32_t
name|y
decl_stmt|;
name|uint8_t
name|mult
decl_stmt|;
name|temp
operator|.
name|do_isoc_sync
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|step_td
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|tbc
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|tlbpc
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|average
operator|=
name|xfer
operator|->
name|max_hc_frame_size
expr_stmt|;
name|temp
operator|.
name|max_packet_size
operator|=
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
name|temp
operator|.
name|sc
operator|=
name|XHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|multishort
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|temp
operator|.
name|td
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td_next
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|uint8_t
name|shift
decl_stmt|;
comment|/* compute multiplier for ISOCHRONOUS transfers */
name|mult
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|ecomp
condition|?
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|ecomp
operator|->
name|bmAttributes
operator|&
literal|3
operator|)
else|:
literal|0
expr_stmt|;
comment|/* check for USB 2.0 multiplier */
if|if
condition|(
name|mult
operator|==
literal|0
condition|)
block|{
name|mult
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
index|[
literal|1
index|]
operator|>>
literal|3
operator|)
operator|&
literal|3
expr_stmt|;
block|}
comment|/* range check */
if|if
condition|(
name|mult
operator|>
literal|2
condition|)
name|mult
operator|=
literal|3
expr_stmt|;
else|else
name|mult
operator|++
expr_stmt|;
name|x
operator|=
name|XREAD4
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|runt
argument_list|,
name|XHCI_MFINDEX
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"MFINDEX=0x%08x\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
condition|)
block|{
case|case
name|USB_SPEED_FULL
case|:
name|shift
operator|=
literal|3
expr_stmt|;
name|temp
operator|.
name|isoc_delta
operator|=
literal|8
expr_stmt|;
comment|/* 1ms */
name|x
operator|+=
name|temp
operator|.
name|isoc_delta
operator|-
literal|1
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
name|temp
operator|.
name|isoc_delta
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
name|shift
operator|=
name|usbd_xfer_get_fps_shift
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|temp
operator|.
name|isoc_delta
operator|=
literal|1U
operator|<<
name|shift
expr_stmt|;
name|x
operator|+=
name|temp
operator|.
name|isoc_delta
operator|-
literal|1
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
name|temp
operator|.
name|isoc_delta
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* simple frame load balancing */
name|x
operator|+=
name|xfer
operator|->
name|endpoint
operator|->
name|usb_uframe
expr_stmt|;
break|break;
block|}
name|y
operator|=
name|XHCI_MFINDEX_GET
argument_list|(
name|x
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
name|y
operator|<
operator|(
name|xfer
operator|->
name|nframes
operator|<<
name|shift
operator|)
operator|)
operator|||
operator|(
name|XHCI_MFINDEX_GET
argument_list|(
operator|-
name|y
argument_list|)
operator|>=
operator|(
literal|128
operator|*
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* 			 * If there is data underflow or the pipe 			 * queue is empty we schedule the transfer a 			 * few frames ahead of the current frame 			 * position. Else two isochronous transfers 			 * might overlap. 			 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
name|XHCI_MFINDEX_GET
argument_list|(
name|x
operator|+
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|do_isoc_sync
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* compute isochronous completion time */
name|y
operator|=
name|XHCI_MFINDEX_GET
argument_list|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
operator|(
name|x
operator|&
operator|~
literal|7
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|isoc_time_complete
operator|=
name|usb_isoc_time_expand
argument_list|(
operator|&
name|temp
operator|.
name|sc
operator|->
name|sc_bus
argument_list|,
name|x
operator|/
literal|8
argument_list|)
operator|+
operator|(
name|y
operator|/
literal|8
operator|)
operator|+
operator|(
operator|(
operator|(
name|xfer
operator|->
name|nframes
operator|<<
name|shift
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|isoc_frame
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
expr_stmt|;
name|temp
operator|.
name|trb_type
operator|=
name|XHCI_TRB_TYPE_ISOCH
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|+=
name|xfer
operator|->
name|nframes
operator|<<
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* check if we should prepend a setup message */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
name|temp
operator|.
name|len
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|temp
operator|.
name|trb_type
operator|=
name|XHCI_TRB_TYPE_SETUP_STAGE
expr_stmt|;
name|temp
operator|.
name|direction
operator|=
literal|0
expr_stmt|;
comment|/* check for last frame */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|1
condition|)
block|{
comment|/* no STATUS stage yet, SETUP is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
block|}
name|xhci_setup_generic_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
name|mult
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|isoc_delta
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|isoc_frame
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|trb_type
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|control_did_data
condition|?
name|XHCI_TRB_TYPE_NORMAL
else|:
name|XHCI_TRB_TYPE_DATA_STAGE
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
name|mult
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|isoc_delta
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|isoc_frame
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|trb_type
operator|=
name|XHCI_TRB_TYPE_NORMAL
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* set up page_cache pointer */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
comment|/* set endpoint direction */
name|temp
operator|.
name|direction
operator|=
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* DATA0 / DATA1 message */
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|temp
operator|.
name|step_td
operator|=
operator|(
operator|(
name|xfer
operator|->
name|endpointno
operator|&
name|UE_DIR_IN
operator|)
operator|&&
name|x
operator|!=
literal|0
operator|&&
name|temp
operator|.
name|multishort
operator|==
literal|0
operator|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* no STATUS stage yet, DATA is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temp
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|/* make sure that we send an USB packet */
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|tbc
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|tlbpc
operator|=
name|mult
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|uint8_t
name|tdpc
decl_stmt|;
comment|/* 			 * Isochronous transfers don't have short 			 * packet termination: 			 */
name|temp
operator|.
name|shortpkt
operator|=
literal|1
expr_stmt|;
comment|/* isochronous transfers have a transfer limit */
if|if
condition|(
name|temp
operator|.
name|len
operator|>
name|xfer
operator|->
name|max_frame_size
condition|)
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
comment|/* compute TD packet count */
name|tdpc
operator|=
operator|(
name|temp
operator|.
name|len
operator|+
name|xfer
operator|->
name|max_packet_size
operator|-
literal|1
operator|)
operator|/
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
name|temp
operator|.
name|tbc
operator|=
operator|(
operator|(
name|tdpc
operator|+
name|mult
operator|-
literal|1
operator|)
operator|/
name|mult
operator|)
operator|-
literal|1
expr_stmt|;
name|temp
operator|.
name|tlbpc
operator|=
operator|(
name|tdpc
operator|%
name|mult
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|tlbpc
operator|==
literal|0
condition|)
name|temp
operator|.
name|tlbpc
operator|=
name|mult
operator|-
literal|1
expr_stmt|;
else|else
name|temp
operator|.
name|tlbpc
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* regular data transfer */
name|temp
operator|.
name|shortpkt
operator|=
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
name|xhci_setup_generic_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|temp
operator|.
name|offset
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|x
operator|-
literal|1
index|]
expr_stmt|;
name|temp
operator|.
name|isoc_frame
operator|+=
name|temp
operator|.
name|isoc_delta
expr_stmt|;
block|}
else|else
block|{
comment|/* get next Page Cache pointer */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
block|}
block|}
comment|/* check if we should append a status stage */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* 		 * Send a DATA1 message and invert the current 		 * endpoint direction. 		 */
name|temp
operator|.
name|step_td
operator|=
operator|(
name|xfer
operator|->
name|nframes
operator|!=
literal|0
operator|)
expr_stmt|;
name|temp
operator|.
name|direction
operator|=
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|^
name|UE_DIR_IN
expr_stmt|;
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|trb_type
operator|=
name|XHCI_TRB_TYPE_STATUS_STAGE
expr_stmt|;
name|xhci_setup_generic_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
comment|/* must have at least one frame! */
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"first=%p last=%p\n"
argument_list|,
name|xfer
operator|->
name|td_transfer_first
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_set_slot_pointer
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|index
parameter_list|,
name|uint64_t
name|dev_addr
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|xhci_dev_ctx_addr
modifier|*
name|pdctxa
decl_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctx_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|pdctxa
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"addr[%u]=0x%016llx\n"
argument_list|,
name|index
argument_list|,
operator|(
name|long
name|long
operator|)
name|dev_addr
argument_list|)
expr_stmt|;
name|pdctxa
operator|->
name|qwBaaDevCtxAddr
index|[
name|index
index|]
operator|=
name|htole64
argument_list|(
name|dev_addr
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ctx_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_configure_mask
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint8_t
name|drop
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_page_search
name|buf_inp
decl_stmt|;
name|struct
name|xhci_input_dev_ctx
modifier|*
name|pinp
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_inp
argument_list|)
expr_stmt|;
name|pinp
operator|=
name|buf_inp
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|mask
operator|&=
name|XHCI_INCTX_NON_CTRL_MASK
expr_stmt|;
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_input
operator|.
name|dwInCtx0
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_input
operator|.
name|dwInCtx1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Some hardware requires that we drop the endpoint 		 * context before adding it again: 		 */
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_input
operator|.
name|dwInCtx0
argument_list|,
name|mask
operator|&
name|XHCI_INCTX_NON_CTRL_MASK
argument_list|)
expr_stmt|;
comment|/* Add new endpoint context */
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_input
operator|.
name|dwInCtx1
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* find most significant set bit */
for|for
control|(
name|x
operator|=
literal|31
init|;
name|x
operator|!=
literal|1
condition|;
name|x
operator|--
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|x
operator|)
condition|)
break|break;
block|}
comment|/* adjust */
name|x
operator|--
expr_stmt|;
comment|/* figure out the maximum number of contexts */
if|if
condition|(
name|x
operator|>
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|context_num
condition|)
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|context_num
operator|=
name|x
expr_stmt|;
else|else
name|x
operator|=
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|context_num
expr_stmt|;
comment|/* update number of contexts */
name|temp
operator|=
name|xhci_ctx_get_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
operator|.
name|dwSctx0
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|XHCI_SCTX_0_CTX_NUM_SET
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|temp
operator||=
name|XHCI_SCTX_0_CTX_NUM_SET
argument_list|(
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
operator|.
name|dwSctx0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_configure_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
parameter_list|,
name|uint16_t
name|interval
parameter_list|,
name|uint8_t
name|max_packet_count
parameter_list|,
name|uint8_t
name|mult
parameter_list|,
name|uint8_t
name|fps_shift
parameter_list|,
name|uint16_t
name|max_packet_size
parameter_list|,
name|uint16_t
name|max_frame_size
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_inp
decl_stmt|;
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|xhci_input_dev_ctx
modifier|*
name|pinp
decl_stmt|;
name|uint64_t
name|ring_addr
init|=
name|pepext
operator|->
name|physaddr
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|epno
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_inp
argument_list|)
expr_stmt|;
name|pinp
operator|=
name|buf_inp
operator|.
name|buffer
expr_stmt|;
name|epno
operator|=
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|type
operator|=
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|UE_CONTROL
condition|)
name|epno
operator||=
name|UE_DIR_IN
expr_stmt|;
name|epno
operator|=
name|XHCI_EPNO2EPID
argument_list|(
name|epno
argument_list|)
expr_stmt|;
if|if
condition|(
name|epno
operator|==
literal|0
condition|)
return|return
operator|(
name|USB_ERR_NO_PIPE
operator|)
return|;
comment|/* invalid */
if|if
condition|(
name|max_packet_count
operator|==
literal|0
condition|)
return|return
operator|(
name|USB_ERR_BAD_BUFSIZE
operator|)
return|;
name|max_packet_count
operator|--
expr_stmt|;
if|if
condition|(
name|mult
operator|==
literal|0
condition|)
return|return
operator|(
name|USB_ERR_BAD_BUFSIZE
operator|)
return|;
comment|/* store bMaxPacketSize for control endpoints */
name|pepext
operator|->
name|trb_ep_maxp
operator|=
name|edesc
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pepext
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_EPCTX_0_EPSTATE_SET
argument_list|(
literal|0
argument_list|)
operator||
name|XHCI_EPCTX_0_MAXP_STREAMS_SET
argument_list|(
literal|0
argument_list|)
operator||
name|XHCI_EPCTX_0_LSA_SET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_FULL
case|:
case|case
name|USB_SPEED_LOW
case|:
comment|/* 1ms -> 125us */
name|fps_shift
operator|+=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
if|if
condition|(
name|fps_shift
operator|>
literal|3
condition|)
name|fps_shift
operator|--
expr_stmt|;
name|temp
operator||=
name|XHCI_EPCTX_0_IVAL_SET
argument_list|(
name|fps_shift
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|temp
operator||=
name|XHCI_EPCTX_0_IVAL_SET
argument_list|(
name|fps_shift
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_SUPER
case|:
if|if
condition|(
name|mult
operator|>
literal|3
condition|)
name|mult
operator|=
literal|3
expr_stmt|;
name|temp
operator||=
name|XHCI_EPCTX_0_MULT_SET
argument_list|(
name|mult
operator|-
literal|1
argument_list|)
expr_stmt|;
name|max_packet_count
operator|/=
name|mult
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_ep
index|[
name|epno
operator|-
literal|1
index|]
operator|.
name|dwEpCtx0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_EPCTX_1_HID_SET
argument_list|(
literal|0
argument_list|)
operator||
name|XHCI_EPCTX_1_MAXB_SET
argument_list|(
name|max_packet_count
argument_list|)
operator||
name|XHCI_EPCTX_1_MAXP_SIZE_SET
argument_list|(
name|max_packet_size
argument_list|)
expr_stmt|;
comment|/* 	 * Always enable the "three strikes and you are gone" feature 	 * except for ISOCHRONOUS endpoints. This is suggested by 	 * section 4.3.3 in the XHCI specification about device slot 	 * initialisation. 	 */
if|if
condition|(
name|type
operator|!=
name|UE_ISOCHRONOUS
condition|)
name|temp
operator||=
name|XHCI_EPCTX_1_CERR_SET
argument_list|(
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|temp
operator||=
name|XHCI_EPCTX_1_EPTYPE_SET
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|temp
operator||=
name|XHCI_EPCTX_1_EPTYPE_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_BULK
case|:
name|temp
operator||=
name|XHCI_EPCTX_1_EPTYPE_SET
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|temp
operator||=
name|XHCI_EPCTX_1_EPTYPE_SET
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for IN direction */
if|if
condition|(
name|epno
operator|&
literal|1
condition|)
name|temp
operator||=
name|XHCI_EPCTX_1_EPTYPE_SET
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_ep
index|[
name|epno
operator|-
literal|1
index|]
operator|.
name|dwEpCtx1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ring_addr
operator||=
name|XHCI_EPCTX_2_DCS_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xhci_ctx_set_le64
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_ep
index|[
name|epno
operator|-
literal|1
index|]
operator|.
name|qwEpCtx2
argument_list|,
name|ring_addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
case|case
name|UE_ISOCHRONOUS
case|:
name|temp
operator|=
name|XHCI_EPCTX_4_MAX_ESIT_PAYLOAD_SET
argument_list|(
name|max_frame_size
argument_list|)
operator||
name|XHCI_EPCTX_4_AVG_TRB_LEN_SET
argument_list|(
name|MIN
argument_list|(
name|XHCI_PAGE_SIZE
argument_list|,
name|max_frame_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_CONTROL
case|:
name|temp
operator|=
name|XHCI_EPCTX_4_AVG_TRB_LEN_SET
argument_list|(
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
name|XHCI_EPCTX_4_AVG_TRB_LEN_SET
argument_list|(
name|XHCI_PAGE_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_ep
index|[
name|epno
operator|-
literal|1
index|]
operator|.
name|dwEpCtx4
argument_list|,
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_endpoint
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_ep
index|[
name|epno
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_pc_cpu_flush
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_configure_endpoint_by_xfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|struct
name|usb_endpoint_ss_comp_descriptor
modifier|*
name|ecomp
decl_stmt|;
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
argument_list|)
expr_stmt|;
name|ecomp
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|ecomp
expr_stmt|;
name|pepext
operator|->
name|trb
index|[
literal|0
index|]
operator|.
name|dwTrb3
operator|=
literal|0
expr_stmt|;
comment|/* halt any transfers */
name|usb_pc_cpu_flush
argument_list|(
name|pepext
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|xhci_configure_endpoint
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
argument_list|,
name|pepext
argument_list|,
name|xfer
operator|->
name|interval
argument_list|,
name|xfer
operator|->
name|max_packet_count
argument_list|,
operator|(
name|ecomp
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|ecomp
operator|->
name|bmAttributes
operator|&
literal|3
operator|)
operator|+
literal|1
else|:
literal|1
argument_list|,
name|usbd_xfer_get_fps_shift
argument_list|(
name|xfer
argument_list|)
argument_list|,
name|xfer
operator|->
name|max_packet_size
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_configure_device
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_page_search
name|buf_inp
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pcinp
decl_stmt|;
name|struct
name|xhci_input_dev_ctx
modifier|*
name|pinp
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|hubdev
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|route
decl_stmt|;
name|uint32_t
name|rh_port
decl_stmt|;
name|uint8_t
name|is_hub
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|depth
decl_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"index=%u\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|pcinp
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
expr_stmt|;
name|usbd_get_page
argument_list|(
name|pcinp
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_inp
argument_list|)
expr_stmt|;
name|pinp
operator|=
name|buf_inp
operator|.
name|buffer
expr_stmt|;
name|rh_port
operator|=
literal|0
expr_stmt|;
name|route
operator|=
literal|0
expr_stmt|;
comment|/* figure out route string and root HUB port number */
for|for
control|(
name|hubdev
operator|=
name|udev
init|;
name|hubdev
operator|!=
name|NULL
condition|;
name|hubdev
operator|=
name|hubdev
operator|->
name|parent_hub
control|)
block|{
if|if
condition|(
name|hubdev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
break|break;
name|depth
operator|=
name|hubdev
operator|->
name|parent_hub
operator|->
name|depth
expr_stmt|;
comment|/* 		 * NOTE: HS/FS/LS devices and the SS root HUB can have 		 * more than 15 ports 		 */
name|rh_port
operator|=
name|hubdev
operator|->
name|port_no
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|rh_port
operator|>
literal|15
condition|)
name|rh_port
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|depth
operator|<
literal|6
condition|)
name|route
operator||=
name|rh_port
operator|<<
operator|(
literal|4
operator|*
operator|(
name|depth
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"Route=0x%08x\n"
argument_list|,
name|route
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_SCTX_0_ROUTE_SET
argument_list|(
name|route
argument_list|)
operator||
name|XHCI_SCTX_0_CTX_NUM_SET
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|context_num
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
name|temp
operator||=
name|XHCI_SCTX_0_SPEED_SET
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|parent_hs_hub
operator|!=
name|NULL
operator|&&
name|udev
operator|->
name|parent_hs_hub
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
operator|==
name|UDPROTO_HSHUBMTT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Device inherits MTT\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|XHCI_SCTX_0_MTT_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USB_SPEED_HIGH
case|:
name|temp
operator||=
name|XHCI_SCTX_0_SPEED_SET
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|nports
operator|!=
literal|0
operator|&&
name|udev
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
operator|==
name|UDPROTO_HSHUBMTT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"HUB supports MTT\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|XHCI_SCTX_0_MTT_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USB_SPEED_FULL
case|:
name|temp
operator||=
name|XHCI_SCTX_0_SPEED_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|parent_hs_hub
operator|!=
name|NULL
operator|&&
name|udev
operator|->
name|parent_hs_hub
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
operator|==
name|UDPROTO_HSHUBMTT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Device inherits MTT\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|XHCI_SCTX_0_MTT_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|temp
operator||=
name|XHCI_SCTX_0_SPEED_SET
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
name|is_hub
operator|=
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|nports
operator|!=
literal|0
operator|&&
operator|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_SUPER
operator|||
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
operator|)
expr_stmt|;
if|if
condition|(
name|is_hub
condition|)
name|temp
operator||=
name|XHCI_SCTX_0_HUB_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
operator|.
name|dwSctx0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_SCTX_1_RH_PORT_SET
argument_list|(
name|rh_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_hub
condition|)
block|{
name|temp
operator||=
name|XHCI_SCTX_1_NUM_PORTS_SET
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|nports
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_SUPER
case|:
switch|switch
condition|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
condition|)
block|{
case|case
name|XHCI_ST_ADDRESSED
case|:
case|case
name|XHCI_ST_CONFIGURED
case|:
comment|/* enable power save */
name|temp
operator||=
name|XHCI_SCTX_1_MAX_EL_SET
argument_list|(
name|sc
operator|->
name|sc_exit_lat_max
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* disable power save */
break|break;
block|}
break|break;
default|default:
break|break;
block|}
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
operator|.
name|dwSctx1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XHCI_SCTX_2_IRQ_TARGET_SET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_hub
condition|)
block|{
name|temp
operator||=
name|XHCI_SCTX_2_TT_THINK_TIME_SET
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|tt
argument_list|)
expr_stmt|;
block|}
name|hubdev
operator|=
name|udev
operator|->
name|parent_hs_hub
expr_stmt|;
comment|/* check if we should activate the transaction translator */
switch|switch
condition|(
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_FULL
case|:
case|case
name|USB_SPEED_LOW
case|:
if|if
condition|(
name|hubdev
operator|!=
name|NULL
condition|)
block|{
name|temp
operator||=
name|XHCI_SCTX_2_TT_HUB_SID_SET
argument_list|(
name|hubdev
operator|->
name|controller_slot_id
argument_list|)
expr_stmt|;
name|temp
operator||=
name|XHCI_SCTX_2_TT_PORT_NUM_SET
argument_list|(
name|udev
operator|->
name|hs_port_no
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
operator|.
name|dwSctx2
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* 	 * These fields should be initialized to zero, according to 	 * XHCI section 6.2.2 - slot context: 	 */
name|temp
operator|=
name|XHCI_SCTX_3_DEV_ADDR_SET
argument_list|(
literal|0
argument_list|)
operator||
name|XHCI_SCTX_3_SLOT_STATE_SET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xhci_ctx_set_le32
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
operator|.
name|dwSctx3
argument_list|,
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_device
argument_list|(
name|sc
argument_list|,
operator|&
name|pinp
operator|->
name|ctx_slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_pc_cpu_flush
argument_list|(
name|pcinp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_alloc_device_ext
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_page_search
name|buf_dev
decl_stmt|;
name|struct
name|usb_page_search
name|buf_ep
decl_stmt|;
name|struct
name|xhci_trb
modifier|*
name|trb
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|usb_page
modifier|*
name|pg
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|pc
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|device_pc
expr_stmt|;
name|pg
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|device_pg
expr_stmt|;
comment|/* need to initialize the page cache */
name|pc
operator|->
name|tag_parent
operator|=
name|sc
operator|->
name|sc_bus
operator|.
name|dma_parent_tag
expr_stmt|;
if|if
condition|(
name|usb_pc_alloc_mem
argument_list|(
name|pc
argument_list|,
name|pg
argument_list|,
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|?
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_dev_ctx
argument_list|)
operator|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_dev_ctx
argument_list|)
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_dev
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
expr_stmt|;
name|pg
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pg
expr_stmt|;
comment|/* need to initialize the page cache */
name|pc
operator|->
name|tag_parent
operator|=
name|sc
operator|->
name|sc_bus
operator|.
name|dma_parent_tag
expr_stmt|;
if|if
condition|(
name|usb_pc_alloc_mem
argument_list|(
name|pc
argument_list|,
name|pg
argument_list|,
name|sc
operator|->
name|sc_ctx_is_64_byte
condition|?
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_input_dev_ctx
argument_list|)
operator|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_input_dev_ctx
argument_list|)
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|pc
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|endpoint_pc
expr_stmt|;
name|pg
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|endpoint_pg
expr_stmt|;
comment|/* need to initialize the page cache */
name|pc
operator|->
name|tag_parent
operator|=
name|sc
operator|->
name|sc_bus
operator|.
name|dma_parent_tag
expr_stmt|;
if|if
condition|(
name|usb_pc_alloc_mem
argument_list|(
name|pc
argument_list|,
name|pg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_dev_endpoint_trbs
argument_list|)
argument_list|,
name|XHCI_PAGE_SIZE
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* initialise all endpoint LINK TRBs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|XHCI_MAX_ENDPOINTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* lookup endpoint TRB ring */
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_dev_endpoint_trbs
operator|*
operator|)
literal|0
operator|)
operator|->
name|trb
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf_ep
argument_list|)
expr_stmt|;
comment|/* get TRB pointer */
name|trb
operator|=
name|buf_ep
operator|.
name|buffer
expr_stmt|;
name|trb
operator|+=
name|XHCI_MAX_TRANSFERS
operator|-
literal|1
expr_stmt|;
comment|/* get TRB start address */
name|addr
operator|=
name|buf_ep
operator|.
name|physaddr
expr_stmt|;
comment|/* create LINK TRB */
name|trb
operator|->
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|trb
operator|->
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_2_IRQ_SET
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|trb
operator|->
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_LINK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usb_pc_cpu_flush
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|xhci_set_slot_pointer
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
name|buf_dev
operator|.
name|physaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|xhci_free_device_ext
argument_list|(
name|udev
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_NOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_free_device_ext
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|xhci_set_slot_pointer
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb_pc_free_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|device_pc
argument_list|)
expr_stmt|;
name|usb_pc_free_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
argument_list|)
expr_stmt|;
name|usb_pc_free_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|endpoint_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|xhci_endpoint_ext
modifier|*
name|xhci_get_endpoint_ext
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|usb_page_search
name|buf_ep
decl_stmt|;
name|uint8_t
name|epno
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|epno
operator|=
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
if|if
condition|(
operator|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_CONTROL
condition|)
name|epno
operator||=
name|UE_DIR_IN
expr_stmt|;
name|epno
operator|=
name|XHCI_EPNO2EPID
argument_list|(
name|epno
argument_list|)
expr_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|pc
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|endpoint_pc
expr_stmt|;
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|xhci_dev_endpoint_trbs
operator|*
operator|)
literal|0
operator|)
operator|->
name|trb
index|[
name|epno
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf_ep
argument_list|)
expr_stmt|;
name|pepext
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|endp
index|[
name|epno
index|]
expr_stmt|;
name|pepext
operator|->
name|page_cache
operator|=
name|pc
expr_stmt|;
name|pepext
operator|->
name|trb
operator|=
name|buf_ep
operator|.
name|buffer
expr_stmt|;
name|pepext
operator|->
name|physaddr
operator|=
name|buf_ep
operator|.
name|physaddr
expr_stmt|;
return|return
operator|(
name|pepext
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_endpoint_doorbell
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint8_t
name|epno
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|epno
operator|=
name|xfer
operator|->
name|endpointno
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
name|epno
operator||=
name|UE_DIR_IN
expr_stmt|;
name|epno
operator|=
name|XHCI_EPNO2EPID
argument_list|(
name|epno
argument_list|)
expr_stmt|;
name|index
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|door
argument_list|,
name|XHCI_DOORBELL
argument_list|(
name|index
argument_list|)
argument_list|,
name|epno
operator||
name|XHCI_DB_SID_SET
argument_list|(
comment|/*xfer->stream_id*/
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_transfer_remove
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
operator|=
literal|0
expr_stmt|;
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
argument_list|)
expr_stmt|;
name|pepext
operator|->
name|trb_used
operator|--
expr_stmt|;
name|pepext
operator|->
name|xfer
index|[
name|xfer
operator|->
name|qh_pos
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|pepext
operator|->
name|trb_running
operator|!=
literal|0
condition|)
block|{
name|pepext
operator|->
name|trb_halted
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_running
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_transfer_insert
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_td
modifier|*
name|td_first
decl_stmt|;
name|struct
name|xhci_td
modifier|*
name|td_last
decl_stmt|;
name|struct
name|xhci_trb
modifier|*
name|trb_link
decl_stmt|;
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|inext
decl_stmt|;
name|uint8_t
name|trb_limit
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* check if already inserted */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"Already in schedule\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
argument_list|)
expr_stmt|;
name|td_first
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|td_last
operator|=
name|xfer
operator|->
name|td_transfer_last
expr_stmt|;
name|addr
operator|=
name|pepext
operator|->
name|physaddr
expr_stmt|;
switch|switch
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
case|case
name|UE_INTERRUPT
case|:
comment|/* single buffered */
name|trb_limit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* multi buffered */
name|trb_limit
operator|=
operator|(
name|XHCI_MAX_TRANSFERS
operator|-
literal|2
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pepext
operator|->
name|trb_used
operator|>=
name|trb_limit
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"Too many TDs queued.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_NOMEM
operator|)
return|;
block|}
comment|/* check if bMaxPacketSize changed */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|!=
literal|0
operator|&&
name|pepext
operator|->
name|trb_ep_maxp
operator|!=
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|wMaxPacketSize
index|[
literal|0
index|]
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"Reconfigure control endpoint\n"
argument_list|)
expr_stmt|;
comment|/* force driver to reconfigure endpoint */
name|pepext
operator|->
name|trb_halted
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_running
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check for stopped condition, after putting transfer on interrupt queue */
if|if
condition|(
name|pepext
operator|->
name|trb_running
operator|==
literal|0
condition|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|8
argument_list|,
literal|"Not running\n"
argument_list|)
expr_stmt|;
comment|/* start configuration */
operator|(
name|void
operator|)
name|usb_proc_msignal
argument_list|(
operator|&
name|sc
operator|->
name|sc_config_proc
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pepext
operator|->
name|trb_used
operator|++
expr_stmt|;
comment|/* get current TRB index */
name|i
operator|=
name|pepext
operator|->
name|trb_index
expr_stmt|;
comment|/* get next TRB index */
name|inext
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* the last entry of the ring is a hardcoded link TRB */
if|if
condition|(
name|inext
operator|>=
operator|(
name|XHCI_MAX_TRANSFERS
operator|-
literal|1
operator|)
condition|)
name|inext
operator|=
literal|0
expr_stmt|;
comment|/* compute terminating return address */
name|addr
operator|+=
name|inext
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_trb
argument_list|)
expr_stmt|;
comment|/* compute link TRB pointer */
name|trb_link
operator|=
name|td_last
operator|->
name|td_trb
operator|+
name|td_last
operator|->
name|ntrb
expr_stmt|;
comment|/* update next pointer of last link TRB */
name|trb_link
operator|->
name|qwTrb0
operator|=
name|htole64
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|trb_link
operator|->
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_2_IRQ_SET
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|trb_link
operator|->
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_3_IOC_BIT
operator||
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_LINK
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_trb
argument_list|(
operator|&
name|td_last
operator|->
name|td_trb
index|[
name|td_last
operator|->
name|ntrb
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_pc_cpu_flush
argument_list|(
name|td_last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* write ahead chain end marker */
name|pepext
operator|->
name|trb
index|[
name|inext
index|]
operator|.
name|qwTrb0
operator|=
literal|0
expr_stmt|;
name|pepext
operator|->
name|trb
index|[
name|inext
index|]
operator|.
name|dwTrb2
operator|=
literal|0
expr_stmt|;
name|pepext
operator|->
name|trb
index|[
name|inext
index|]
operator|.
name|dwTrb3
operator|=
literal|0
expr_stmt|;
comment|/* update next pointer of link TRB */
name|pepext
operator|->
name|trb
index|[
name|i
index|]
operator|.
name|qwTrb0
operator|=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|td_first
operator|->
name|td_self
argument_list|)
expr_stmt|;
name|pepext
operator|->
name|trb
index|[
name|i
index|]
operator|.
name|dwTrb2
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_2_IRQ_SET
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|xhci_dump_trb
argument_list|(
operator|&
name|pepext
operator|->
name|trb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usb_pc_cpu_flush
argument_list|(
name|pepext
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* toggle cycle bit which activates the transfer chain */
name|pepext
operator|->
name|trb
index|[
name|i
index|]
operator|.
name|dwTrb3
operator|=
name|htole32
argument_list|(
name|XHCI_TRB_3_CYCLE_BIT
operator||
name|XHCI_TRB_3_TYPE_SET
argument_list|(
name|XHCI_TRB_TYPE_LINK
argument_list|)
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pepext
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"qh_pos = %u\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pepext
operator|->
name|xfer
index|[
name|i
index|]
operator|=
name|xfer
expr_stmt|;
name|xfer
operator|->
name|qh_pos
operator|=
name|i
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_index
operator|=
name|inext
expr_stmt|;
name|xhci_endpoint_doorbell
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_root_intr
parameter_list|(
name|struct
name|xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* clear any old interrupt data */
name|memset
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
comment|/* pick out CHANGE bits from the status register */
if|if
condition|(
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
operator|(
name|XHCI_PS_CSC
operator||
name|XHCI_PS_PEC
operator||
name|XHCI_PS_OCC
operator||
name|XHCI_PS_WRC
operator||
name|XHCI_PS_PRC
operator||
name|XHCI_PS_PLC
operator||
name|XHCI_PS_CEC
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_hub_idata
index|[
name|i
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"port %d changed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|uhub_root_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_hub_idata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	xhci_device_done - XHCI done handler  *  * NOTE: This function can be called two times in a row on  * the same USB transfer. From close and from interrupt.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|xhci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p, endpoint=%p, error=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* remove transfer from HW queue */
name|xhci_transfer_remove
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* dequeue transfer and start next transfer */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * XHCI data transfer support (generic type)  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|xhci_device_generic_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
switch|switch
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_FULL
case|:
break|break;
default|default:
name|usb_hs_bandwidth_alloc
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_generic_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
switch|switch
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_FULL
case|:
break|break;
default|default:
name|usb_hs_bandwidth_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_generic_multi_enter
parameter_list|(
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|enter_xfer
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* check if there is a current transfer */
name|xfer
operator|=
name|ep
operator|->
name|endpoint_q
operator|.
name|curr
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Check if the current transfer is started and then pickup 	 * the next one, if any. Else wait for next start event due to 	 * block on failure feature. 	 */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
condition|)
return|return;
name|xfer
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
operator|.
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * In case of enter we have to consider that the 		 * transfer is queued by the USB core after the enter 		 * method is called. 		 */
name|xfer
operator|=
name|enter_xfer
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
block|}
comment|/* try to multi buffer */
name|xhci_transfer_insert
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_generic_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* set up TD's and QH */
name|xhci_setup_generic_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xhci_device_generic_multi_enter
argument_list|(
name|xfer
operator|->
name|endpoint
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_generic_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* try to insert xfer on HW queue */
name|xhci_transfer_insert
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* try to multi buffer */
name|xhci_device_generic_multi_enter
argument_list|(
name|xfer
operator|->
name|endpoint
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* add transfer last on interrupt queue */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* start timeout, if any */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|!=
literal|0
condition|)
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|xhci_timeout
argument_list|,
name|xfer
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|xhci_device_generic_methods
init|=
block|{
operator|.
name|open
operator|=
name|xhci_device_generic_open
block|,
operator|.
name|close
operator|=
name|xhci_device_generic_close
block|,
operator|.
name|enter
operator|=
name|xhci_device_generic_enter
block|,
operator|.
name|start
operator|=
name|xhci_device_generic_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * xhci root HUB support  *------------------------------------------------------------------------*  * Simulate a hardware HUB by handling all the necessary requests.  *------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|HSETW
parameter_list|(
name|ptr
parameter_list|,
name|val
parameter_list|)
value|ptr = { (uint8_t)(val), (uint8_t)((val)>> 8) }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_descriptor
name|xhci_devd
init|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_devd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE
block|,
comment|/* type */
name|HSETW
argument_list|(
operator|.
name|bcdUSB
argument_list|,
literal|0x0300
argument_list|)
block|,
comment|/* USB version */
operator|.
name|bDeviceClass
operator|=
name|UDCLASS_HUB
block|,
comment|/* class */
operator|.
name|bDeviceSubClass
operator|=
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
operator|.
name|bDeviceProtocol
operator|=
name|UDPROTO_SSHUB
block|,
comment|/* protocol */
operator|.
name|bMaxPacketSize
operator|=
literal|9
block|,
comment|/* max packet size */
name|HSETW
argument_list|(
operator|.
name|idVendor
argument_list|,
literal|0x0000
argument_list|)
block|,
comment|/* vendor */
name|HSETW
argument_list|(
operator|.
name|idProduct
argument_list|,
literal|0x0000
argument_list|)
block|,
comment|/* product */
name|HSETW
argument_list|(
operator|.
name|bcdDevice
argument_list|,
literal|0x0100
argument_list|)
block|,
comment|/* device version */
operator|.
name|iManufacturer
operator|=
literal|1
block|,
operator|.
name|iProduct
operator|=
literal|2
block|,
operator|.
name|iSerialNumber
operator|=
literal|0
block|,
operator|.
name|bNumConfigurations
operator|=
literal|1
block|,
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xhci_bos_desc
name|xhci_bosd
init|=
block|{
operator|.
name|bosd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_bosd
operator|.
name|bosd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_BOS
block|,
name|HSETW
argument_list|(
operator|.
name|wTotalLength
argument_list|,
sizeof|sizeof
argument_list|(
name|xhci_bosd
argument_list|)
argument_list|)
block|,
operator|.
name|bNumDeviceCaps
operator|=
literal|3
block|, 	}
block|,
operator|.
name|usb2extd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_bosd
operator|.
name|usb2extd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
literal|1
block|,
operator|.
name|bDevCapabilityType
operator|=
literal|2
block|,
operator|.
name|bmAttributes
index|[
literal|0
index|]
operator|=
literal|2
block|, 	}
block|,
operator|.
name|usbdcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_bosd
operator|.
name|usbdcd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE_CAPABILITY
block|,
operator|.
name|bDevCapabilityType
operator|=
literal|3
block|,
operator|.
name|bmAttributes
operator|=
literal|0
block|,
comment|/* XXX */
name|HSETW
argument_list|(
operator|.
name|wSpeedsSupported
argument_list|,
literal|0x000C
argument_list|)
block|,
operator|.
name|bFunctionalitySupport
operator|=
literal|8
block|,
operator|.
name|bU1DevExitLat
operator|=
literal|255
block|,
comment|/* dummy - not used */
operator|.
name|wU2DevExitLat
operator|=
block|{
literal|0x00
block|,
literal|0x08
block|}
block|, 	}
block|,
operator|.
name|cidd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_bosd
operator|.
name|cidd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
literal|1
block|,
operator|.
name|bDevCapabilityType
operator|=
literal|4
block|,
operator|.
name|bReserved
operator|=
literal|0
block|,
operator|.
name|bContainerID
operator|=
literal|0
block|,
comment|/* XXX */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xhci_config_desc
name|xhci_confd
init|=
block|{
operator|.
name|confd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_confd
operator|.
name|confd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_CONFIG
block|,
operator|.
name|wTotalLength
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|xhci_confd
argument_list|)
block|,
operator|.
name|bNumInterface
operator|=
literal|1
block|,
operator|.
name|bConfigurationValue
operator|=
literal|1
block|,
operator|.
name|iConfiguration
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
name|UC_SELF_POWERED
block|,
operator|.
name|bMaxPower
operator|=
literal|0
comment|/* max power */
block|}
block|,
operator|.
name|ifcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_confd
operator|.
name|ifcd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
block|,
operator|.
name|bNumEndpoints
operator|=
literal|1
block|,
operator|.
name|bInterfaceClass
operator|=
name|UICLASS_HUB
block|,
operator|.
name|bInterfaceSubClass
operator|=
name|UISUBCLASS_HUB
block|,
operator|.
name|bInterfaceProtocol
operator|=
literal|0
block|, 	}
block|,
operator|.
name|endpd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_confd
operator|.
name|endpd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
block|,
operator|.
name|bEndpointAddress
operator|=
name|UE_DIR_IN
operator||
name|XHCI_INTR_ENDPT
block|,
operator|.
name|bmAttributes
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
literal|2
block|,
comment|/* max 15 ports */
operator|.
name|bInterval
operator|=
literal|255
block|, 	}
block|,
operator|.
name|endpcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_confd
operator|.
name|endpcd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT_SS_COMP
block|,
operator|.
name|bMaxBurst
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
literal|0
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hub_ss_descriptor
name|xhci_hubd
init|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|xhci_hubd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_SS_HUB
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|usb_error_t
name|xhci_roothub_exec
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plength
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_ptr
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* buffer reset */
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_hub_desc
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"type=0x%02x request=0x%02x wLen=0x%04x "
literal|"wValue=0x%04x wIndex=0x%04x\n"
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|,
name|req
operator|->
name|bRequest
argument_list|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
argument_list|,
name|value
argument_list|,
name|index
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|xhci_devd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|xhci_devd
expr_stmt|;
break|break;
case|case
name|UDESC_BOS
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|xhci_bosd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|xhci_bosd
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|xhci_confd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|xhci_confd
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|str_ptr
operator|=
literal|"\001"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Vendor */
name|str_ptr
operator|=
name|sc
operator|->
name|sc_vendor
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|str_ptr
operator|=
literal|"XHCI root HUB"
expr_stmt|;
break|break;
default|default:
name|str_ptr
operator|=
literal|""
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|usb_make_str_desc
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|)
argument_list|,
name|str_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|XHCI_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
literal|1
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_CLEAR_PORT_FEATURE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|XHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|i
operator|=
name|XHCI_PS_PLS_GET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|XHCI_PS_CLEAR
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_C_BH_PORT_RESET
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_WRC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONFIG_ERROR
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_CEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_LINK_STATE
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PLC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_OCC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PRC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_ENABLE
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PED
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|XHCI_PS_PP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_INDICATOR
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|XHCI_PS_PIC_SET
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
comment|/* U3 -> U15 */
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PLS_SET
argument_list|(
literal|0xF
argument_list|)
operator||
name|XHCI_PS_LWS
argument_list|)
expr_stmt|;
block|}
comment|/* wait 20ms for resume sequence to complete */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
comment|/* U0 */
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PLS_SET
argument_list|(
literal|0
argument_list|)
operator||
name|XHCI_PS_LWS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|capa
argument_list|,
name|XHCI_HCSPARAMS0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|=
name|xhci_hubd
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bNbrPorts
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
if|if
condition|(
name|XHCI_HCS0_PPC
argument_list|(
name|v
argument_list|)
condition|)
name|i
operator|=
name|UHD_PWR_INDIVIDUAL
expr_stmt|;
else|else
name|i
operator|=
name|UHD_PWR_GANGED
expr_stmt|;
if|if
condition|(
name|XHCI_HCS0_PIND
argument_list|(
name|v
argument_list|)
condition|)
name|i
operator||=
name|UHD_PORT_IND
expr_stmt|;
name|i
operator||=
name|UHD_OC_INDIVIDUAL
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|wHubCharacteristics
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* see XHCI section 5.4.9: */
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bPwrOn2PwrGood
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|j
operator|++
control|)
block|{
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_PORTSC
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_DR
condition|)
block|{
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|DeviceRemovable
index|[
name|j
operator|/
literal|8
index|]
operator||=
literal|1U
operator|<<
operator|(
name|j
operator|%
literal|8
operator|)
expr_stmt|;
block|}
block|}
name|len
operator|=
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bLength
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|16
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_GET_STATUS i=%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|XHCI_PORTSC
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"port status=0x%08x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|i
operator|=
name|UPS_PORT_LINK_STATE_SET
argument_list|(
name|XHCI_PS_PLS_GET
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XHCI_PS_SPEED_GET
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
name|i
operator||=
name|UPS_HIGH_SPEED
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator||=
name|UPS_LOW_SPEED
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* FULL speed */
break|break;
default|default:
name|i
operator||=
name|UPS_OTHER_SPEED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|v
operator|&
name|XHCI_PS_CCS
condition|)
name|i
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_PED
condition|)
name|i
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_OCA
condition|)
name|i
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_PR
condition|)
name|i
operator||=
name|UPS_RESET
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_PP
condition|)
block|{
comment|/* 			 * The USB 3.0 RH is using the 			 * USB 2.0's power bit 			 */
name|i
operator||=
name|UPS_PORT_POWER
expr_stmt|;
block|}
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortStatus
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_CSC
condition|)
name|i
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_PEC
condition|)
name|i
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_OCC
condition|)
name|i
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_WRC
condition|)
name|i
operator||=
name|UPS_C_BH_PORT_RESET
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_PRC
condition|)
name|i
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_PLC
condition|)
name|i
operator||=
name|UPS_C_PORT_LINK_STATE
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|XHCI_PS_CEC
condition|)
name|i
operator||=
name|UPS_C_PORT_CONFIG_ERROR
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortChange
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|i
operator|=
name|index
operator|>>
literal|8
expr_stmt|;
name|index
operator|&=
literal|0x00FF
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|XHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|XHCI_PS_CLEAR
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_U1_TIMEOUT
case|:
if|if
condition|(
name|XHCI_PS_SPEED_GET
argument_list|(
name|v
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|XHCI_PORTPMSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|XHCI_PM3_U1TO_SET
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
name|v
operator||=
name|XHCI_PM3_U1TO_SET
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_U2_TIMEOUT
case|:
if|if
condition|(
name|XHCI_PS_SPEED_GET
argument_list|(
name|v
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|XHCI_PORTPMSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|XREAD4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|XHCI_PM3_U2TO_SET
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
name|v
operator||=
name|XHCI_PM3_U2TO_SET
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_BH_PORT_RESET
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_WPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_LINK_STATE
case|:
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PLS_SET
argument_list|(
name|i
argument_list|)
operator||
name|XHCI_PS_LWS
argument_list|)
expr_stmt|;
comment|/* 4ms settle time */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|250
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_ENABLE
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port enable %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"suspend port %u (LPM=%u)\n"
argument_list|,
name|index
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|XHCI_PS_SPEED_GET
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|<
literal|1
operator|)
operator|||
operator|(
name|j
operator|>
literal|3
operator|)
condition|)
block|{
comment|/* non-supported speed */
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PLS_SET
argument_list|(
name|i
condition|?
literal|2
comment|/* LPM */
else|:
literal|3
argument_list|)
operator||
name|XHCI_PS_LWS
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"reset port %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port power %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
operator||
name|XHCI_PS_PP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port test %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_INDICATOR
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port indicator %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|XHCI_PS_PIC_SET
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|v
operator||=
name|XHCI_PS_PIC_SET
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|oper
argument_list|,
name|port
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_TT_BUFFER
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_RESET_TT
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_TT_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_STOP_TT
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
operator|*
name|plength
operator|=
name|len
expr_stmt|;
operator|*
name|pptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_xfer_setup
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|usb_page_search
name|page_info
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|xhci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|last_obj
decl_stmt|;
name|uint32_t
name|ntd
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|sc
operator|=
name|XHCI_BUS2SC
argument_list|(
name|parm
operator|->
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|parm
operator|->
name|curr_xfer
expr_stmt|;
comment|/* 	 * The proof for the "ntd" formula is illustrated like this: 	 * 	 * +------------------------------------+ 	 * |                                    | 	 * |         |remainder ->              | 	 * |   +-----+---+                      | 	 * |   | xxx | x | frm 0                | 	 * |   +-----+---++                     | 	 * |   | xxx | xx | frm 1               | 	 * |   +-----+----+                     | 	 * |            ...                     | 	 * +------------------------------------+ 	 * 	 * "xxx" means a completely full USB transfer descriptor 	 * 	 * "x" and "xx" means a short USB packet 	 * 	 * For the remainder of an USB transfer modulo 	 * "max_data_length" we need two USB transfer descriptors. 	 * One to transfer the remaining data and one to finalise with 	 * a zero length packet in case the "force_short_xfer" flag is 	 * set. We only need two USB transfer descriptors in the case 	 * where the transfer length of the first one is a factor of 	 * "max_frame_size". The rest of the needed USB transfer 	 * descriptors is given by the buffer size divided by the 	 * maximum data payload. 	 */
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|16
operator|*
literal|3
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
name|XHCI_TD_PAYLOAD_MAX
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|ntd
operator|=
operator|(
operator|(
literal|1
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
literal|1
comment|/* STATUS */
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
block|}
name|alloc_dma_set
label|:
if|if
condition|(
name|parm
operator|->
name|err
condition|)
return|return;
comment|/* 	 * Allocate queue heads and transfer descriptors 	 */
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xhci_td
argument_list|)
argument_list|,
name|XHCI_TD_ALIGN
argument_list|,
name|ntd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|ntd
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|xhci_td
modifier|*
name|td
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|td
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
name|td
operator|->
name|td_self
operator|=
name|page_info
operator|.
name|physaddr
expr_stmt|;
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|td
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|=
literal|1
expr_stmt|;
goto|goto
name|alloc_dma_set
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_configure_reset_endpoint
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_page_search
name|buf_inp
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pcinp
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|epno
decl_stmt|;
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
argument_list|)
expr_stmt|;
name|udev
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
expr_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|pcinp
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
expr_stmt|;
name|usbd_get_page
argument_list|(
name|pcinp
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_inp
argument_list|)
expr_stmt|;
name|edesc
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
expr_stmt|;
name|epno
operator|=
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
if|if
condition|(
operator|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_CONTROL
condition|)
name|epno
operator||=
name|UE_DIR_IN
expr_stmt|;
name|epno
operator|=
name|XHCI_EPNO2EPID
argument_list|(
name|epno
argument_list|)
expr_stmt|;
if|if
condition|(
name|epno
operator|==
literal|0
condition|)
return|return
operator|(
name|USB_ERR_NO_PIPE
operator|)
return|;
comment|/* invalid */
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* configure endpoint */
name|err
operator|=
name|xhci_configure_endpoint_by_xfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Get the endpoint into the stopped state according to the 	 * endpoint context state diagram in the XHCI specification: 	 */
name|err
operator|=
name|xhci_cmd_stop_ep
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|epno
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|"Could not stop endpoint %u\n"
argument_list|,
name|epno
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_cmd_reset_ep
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|epno
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|"Could not reset endpoint %u\n"
argument_list|,
name|epno
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_cmd_set_tr_dequeue_ptr
argument_list|(
name|sc
argument_list|,
name|pepext
operator|->
name|physaddr
operator||
name|XHCI_EPCTX_2_DCS_SET
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|epno
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|"Could not set dequeue ptr for endpoint %u\n"
argument_list|,
name|epno
argument_list|)
expr_stmt|;
comment|/* 	 * Get the endpoint into the running state according to the 	 * endpoint context state diagram in the XHCI specification: 	 */
name|xhci_configure_mask
argument_list|(
name|udev
argument_list|,
operator|(
literal|1U
operator|<<
name|epno
operator|)
operator||
literal|1U
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_cmd_evaluate_ctx
argument_list|(
name|sc
argument_list|,
name|buf_inp
operator|.
name|physaddr
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|"Could not configure endpoint %u\n"
argument_list|,
name|epno
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_cmd_configure_ep
argument_list|(
name|sc
argument_list|,
name|buf_inp
operator|.
name|physaddr
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|"Could not configure endpoint %u\n"
argument_list|,
name|epno
argument_list|)
expr_stmt|;
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_xfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_start_dma_delay
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
comment|/* put transfer on interrupt queue (again) */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usb_proc_msignal
argument_list|(
operator|&
name|sc
operator|->
name|sc_config_proc
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_configure_msg
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|sc
operator|=
name|XHCI_BUS2SC
argument_list|(
operator|(
operator|(
expr|struct
name|usb_bus_msg
operator|*
operator|)
name|pm
operator|)
operator|->
name|bus
argument_list|)
expr_stmt|;
name|restart
label|:
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pepext
operator|->
name|trb_halted
operator|!=
literal|0
operator|)
operator|||
operator|(
name|pepext
operator|->
name|trb_running
operator|==
literal|0
operator|)
condition|)
block|{
name|uint8_t
name|i
decl_stmt|;
comment|/* clear halted and running */
name|pepext
operator|->
name|trb_halted
operator|=
literal|0
expr_stmt|;
name|pepext
operator|->
name|trb_running
operator|=
literal|0
expr_stmt|;
comment|/* nuke remaining buffered transfers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
operator|(
name|XHCI_MAX_TRANSFERS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * NOTE: We need to use the timeout 				 * error code here else existing 				 * isochronous clients can get 				 * confused: 				 */
if|if
condition|(
name|pepext
operator|->
name|xfer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|xhci_device_done
argument_list|(
name|pepext
operator|->
name|xfer
index|[
name|i
index|]
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * NOTE: The USB transfer cannot vanish in 			 * this state! 			 */
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|xhci_configure_reset_endpoint
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* check if halted is still cleared */
if|if
condition|(
name|pepext
operator|->
name|trb_halted
operator|==
literal|0
condition|)
block|{
name|pepext
operator|->
name|trb_running
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_index
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|did_dma_delay
condition|)
block|{
comment|/* remove transfer from interrupt queue (again) */
name|usbd_transfer_dequeue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* we are finally done */
name|usb_dma_delay_done_cb
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* queue changed - restart */
goto|goto
name|restart
goto|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
comment|/* try to insert xfer on HW queue */
name|xhci_transfer_insert
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* try to multi buffer */
name|xhci_device_generic_multi_enter
argument_list|(
name|xfer
operator|->
name|endpoint
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_ep_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"endpoint=%p, addr=%d, endpt=%d, mode=%d\n"
argument_list|,
name|ep
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|usb_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
block|{
comment|/* root HUB has special endpoint handling */
return|return;
block|}
name|ep
operator|->
name|methods
operator|=
operator|&
name|xhci_device_generic_methods
expr_stmt|;
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|udev
argument_list|,
name|edesc
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|pepext
operator|->
name|trb_halted
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_running
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_ep_uninit
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|xhci_ep_clear_stall
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|xhci_endpoint_ext
modifier|*
name|pepext
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
comment|/* not supported */
return|return;
block|}
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
block|{
comment|/* root HUB has special endpoint handling */
return|return;
block|}
name|pepext
operator|=
name|xhci_get_endpoint_ext
argument_list|(
name|udev
argument_list|,
name|ep
operator|->
name|edesc
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|pepext
operator|->
name|trb_halted
operator|=
literal|1
expr_stmt|;
name|pepext
operator|->
name|trb_running
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|xhci_device_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
comment|/* no init for root HUB */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set invalid default */
name|udev
operator|->
name|controller_slot_id
operator|=
name|sc
operator|->
name|sc_noslot
operator|+
literal|1
expr_stmt|;
comment|/* try to get a new slot ID from the XHCI */
name|err
operator|=
name|xhci_cmd_enable_slot
argument_list|(
name|sc
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|temp
operator|>
name|sc
operator|->
name|sc_noslot
condition|)
block|{
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_BAD_ADDRESS
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|temp
index|]
operator|.
name|state
operator|!=
name|XHCI_ST_DISABLED
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"slot %u already allocated.\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_BAD_ADDRESS
operator|)
return|;
block|}
comment|/* store slot ID for later reference */
name|udev
operator|->
name|controller_slot_id
operator|=
name|temp
expr_stmt|;
comment|/* reset data structure */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|temp
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set mark slot allocated */
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|temp
index|]
operator|.
name|state
operator|=
name|XHCI_ST_ENABLED
expr_stmt|;
name|err
operator|=
name|xhci_alloc_device_ext
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get device into default state */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|xhci_set_address
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_uninit
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
comment|/* no init for root HUB */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
if|if
condition|(
name|index
operator|<=
name|sc
operator|->
name|sc_noslot
condition|)
block|{
name|xhci_cmd_disable_slot
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|=
name|XHCI_ST_DISABLED
expr_stmt|;
comment|/* free device extension */
name|xhci_free_device_ext
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_get_dma_delay
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint32_t
modifier|*
name|pus
parameter_list|)
block|{
comment|/* 	 * Wait until the hardware has finished any possible use of 	 * the transfer descriptor(s) 	 */
operator|*
name|pus
operator|=
literal|2048
expr_stmt|;
comment|/* microseconds */
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_resume
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|p
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* check for root HUB */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* blindly resume all endpoints */
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|!=
name|XHCI_MAX_ENDPOINTS
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|!=
literal|1
comment|/*XHCI_MAX_STREAMS*/
condition|;
name|p
operator|++
control|)
block|{
name|XWRITE4
argument_list|(
name|sc
argument_list|,
name|door
argument_list|,
name|XHCI_DOORBELL
argument_list|(
name|index
argument_list|)
argument_list|,
name|n
operator||
name|XHCI_DB_SID_SET
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_suspend
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* check for root HUB */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* blindly suspend all endpoints */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|!=
name|XHCI_MAX_ENDPOINTS
condition|;
name|n
operator|++
control|)
block|{
name|err
operator|=
name|xhci_cmd_stop_ep
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Failed to suspend endpoint "
literal|"%u on slot %u (ignored).\n"
argument_list|,
name|n
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_set_hw_power
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xhci_device_state_change
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|xhci_softc
modifier|*
name|sc
init|=
name|XHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_page_search
name|buf_inp
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
comment|/* check for root HUB */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|index
operator|=
name|udev
operator|->
name|controller_slot_id
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_get_device_state
argument_list|(
name|udev
argument_list|)
operator|==
name|USB_STATE_CONFIGURED
condition|)
block|{
name|err
operator|=
name|uhub_query_info
argument_list|(
name|udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|nports
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|nports
operator|=
literal|0
expr_stmt|;
block|}
name|XHCI_CMD_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|usb_get_device_state
argument_list|(
name|udev
argument_list|)
condition|)
block|{
case|case
name|USB_STATE_POWERED
case|:
if|if
condition|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|==
name|XHCI_ST_DEFAULT
condition|)
break|break;
comment|/* set default state */
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|=
name|XHCI_ST_DEFAULT
expr_stmt|;
comment|/* reset number of contexts */
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|context_num
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|xhci_cmd_reset_dev
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Device reset failed "
literal|"for slot %u.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USB_STATE_ADDRESSED
case|:
if|if
condition|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|==
name|XHCI_ST_ADDRESSED
condition|)
break|break;
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|=
name|XHCI_ST_ADDRESSED
expr_stmt|;
name|err
operator|=
name|xhci_cmd_configure_ep
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Failed to deconfigure "
literal|"slot %u.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USB_STATE_CONFIGURED
case|:
if|if
condition|(
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|==
name|XHCI_ST_CONFIGURED
condition|)
break|break;
comment|/* set configured state */
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|state
operator|=
name|XHCI_ST_CONFIGURED
expr_stmt|;
comment|/* reset number of contexts */
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|context_num
operator|=
literal|0
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|devs
index|[
name|index
index|]
operator|.
name|input_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_inp
argument_list|)
expr_stmt|;
name|xhci_configure_mask
argument_list|(
name|udev
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|xhci_configure_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Could not configure device "
literal|"at slot %u.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|xhci_cmd_evaluate_ctx
argument_list|(
name|sc
argument_list|,
name|buf_inp
operator|.
name|physaddr
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Could not evaluate device "
literal|"context at slot %u.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|XHCI_CMD_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_bus_methods
name|xhci_bus_methods
init|=
block|{
operator|.
name|endpoint_init
operator|=
name|xhci_ep_init
block|,
operator|.
name|endpoint_uninit
operator|=
name|xhci_ep_uninit
block|,
operator|.
name|xfer_setup
operator|=
name|xhci_xfer_setup
block|,
operator|.
name|xfer_unsetup
operator|=
name|xhci_xfer_unsetup
block|,
operator|.
name|get_dma_delay
operator|=
name|xhci_get_dma_delay
block|,
operator|.
name|device_init
operator|=
name|xhci_device_init
block|,
operator|.
name|device_uninit
operator|=
name|xhci_device_uninit
block|,
operator|.
name|device_resume
operator|=
name|xhci_device_resume
block|,
operator|.
name|device_suspend
operator|=
name|xhci_device_suspend
block|,
operator|.
name|set_hw_power
operator|=
name|xhci_set_hw_power
block|,
operator|.
name|roothub_exec
operator|=
name|xhci_roothub_exec
block|,
operator|.
name|xfer_poll
operator|=
name|xhci_do_poll
block|,
operator|.
name|start_dma_delay
operator|=
name|xhci_start_dma_delay
block|,
operator|.
name|set_address
operator|=
name|xhci_set_address
block|,
operator|.
name|clear_stall
operator|=
name|xhci_ep_clear_stall
block|,
operator|.
name|device_state_change
operator|=
name|xhci_device_state_change
block|,
operator|.
name|set_hw_power_sleep
operator|=
name|xhci_set_hw_power_sleep
block|, }
decl_stmt|;
end_decl_stmt

end_unit

