begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Semihalf  * Copyright (c) 2012 The FreeBSD Foundation  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Portions of this software were developed by Oleksandr Rybalko  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * EHCI driver for Freescale i.MX SoCs which incorporate the USBOH3 controller.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehcireg.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_ccmvar.h>
end_include

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_comment
comment|/*  * Notes on the hardware and related FDT data seen in the wild.  *  * There are two sets of registers in the USBOH3 implementation; documentation  * refers to them as "core" and "non-core" registers.  A set of core register  * exists for each OTG or EHCI device.  There is a single set of non-core  * registers per USBOH3, and they control aspects of operation not directly  * related to the USB specs, such as whether interrupts from each of the core  * devices are able to generate a SoC wakeup event.  *  * In the FreeBSD universe we might be inclined to describe the core and  * non-core registers by using a pair of resource address/size values (two  * entries in the reg property for each core).  However, we have to work with  * existing FDT data (which mostly comes from the linux universe), and the way  * they've chosen to represent this is with an entry for a "usbmisc" device  * whose reg property describes the non-core registers. The way we handle FDT  * data, this means that the resources (memory-mapped register range) for the  * non-core registers belongs to a device other than the echi devices.  *  * At the moment we have no need to access the non-core registers, so all of  * this amounts to documenting what's known.  The following compat strings have  * been seen in existing FDT data:  *   - "fsl,imx25-usbmisc"  *   - "fsl,imx51-usbmisc";  *   - "fsl,imx6q-usbmisc";  *  * In addition to the single usbmisc device, the existing FDT data defines a  * separate device for each of the OTG or EHCI cores within the USBOH3.  Each of  * those devices has a set of core registers described by the reg property.  *  * The core registers for each of the four cores in the USBOH3 are divided into  * two parts: a set of imx-specific registers at an offset of 0 from the  * beginning of the register range, and the standard USB (EHCI or OTG) registers  * at an offset of 0x100 from the beginning of the register range.  The FreeBSD  * way of dealing with this might be to map out two ranges in the reg property,  * but that's not what the alternate universe has done.  To work with existing  * FDT data, we acquire the resource that maps all the core registers, then use  * bus_space_subregion() to create another resource that maps just the standard  * USB registers, which we provide to the standard USB code in the ehci_softc.  *  * The following compat strings have been seen for the OTG and EHCI cores.  The  * FDT compat table in this driver contains all these strings, but as of this  * writing, not all of these SoCs have been tested with the driver.  The fact  * that imx27 is common to all of them gives some hope that the driver will work  * on all these SoCs.  *   - "fsl,imx23-usb", "fsl,imx27-usb";  *   - "fsl,imx25-usb", "fsl,imx27-usb";  *   - "fsl,imx28-usb", "fsl,imx27-usb";  *   - "fsl,imx51-usb", "fsl,imx27-usb";  *   - "fsl,imx53-usb", "fsl,imx27-usb";  *   - "fsl,imx6q-usb", "fsl,imx27-usb";  *  * The FDT data for some SoCs contains the following properties, which we don't  * currently do anything with:  *   - fsl,usbmisc =<&usbmisc 0>;  *   - fsl,usbphy =<&usbphy0>;  *  * Some imx SoCs have FDT data related to USB PHY, some don't.  We have separate  * usbphy drivers where needed; this data is mentioned here just to keep all the  * imx-FDT-usb-related info in one place.  Here are the usbphy compat strings  * known to exist:  *   - "nop-usbphy"  *   - "usb-nop-xceiv";  *   - "fsl,imx23-usbphy"   *   - "fsl,imx28-usbphy", "fsl,imx23-usbphy";  *   - "fsl,imx6q-usbphy", "fsl,imx23-usbphy";  *  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"fsl,imx6q-usb"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx53-usb"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx51-usb"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx28-usb"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx27-usb"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx25-usb"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx23-usb"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each EHCI device in the SoC has some SoC-specific per-device registers at an  * offset of 0, then the standard EHCI registers begin at an offset of 0x100.  */
end_comment

begin_define
define|#
directive|define
name|IMX_EHCI_REG_OFF
value|0x100
end_define

begin_define
define|#
directive|define
name|IMX_EHCI_REG_SIZE
value|0x100
end_define

begin_struct
struct|struct
name|imx_ehci_softc
block|{
name|ehci_softc_t
name|ehci_softc
decl_stmt|;
name|struct
name|resource
modifier|*
name|ehci_mem_res
decl_stmt|;
comment|/* EHCI core regs. */
name|struct
name|resource
modifier|*
name|ehci_irq_res
decl_stmt|;
comment|/* EHCI core IRQ. */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|imx_ehci_post_reset
parameter_list|(
name|struct
name|ehci_softc
modifier|*
name|ehci_softc
parameter_list|)
block|{
name|uint32_t
name|usbmode
decl_stmt|;
comment|/* Force HOST mode */
name|usbmode
operator|=
name|EOREAD4
argument_list|(
name|ehci_softc
argument_list|,
name|EHCI_USBMODE_NOLPM
argument_list|)
expr_stmt|;
name|usbmode
operator|&=
operator|~
name|EHCI_UM_CM
expr_stmt|;
name|usbmode
operator||=
name|EHCI_UM_CM_HOST
expr_stmt|;
name|EOWRITE4
argument_list|(
name|ehci_softc
argument_list|,
name|EHCI_USBMODE_NOLPM
argument_list|,
name|usbmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_ehci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
operator|!=
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Freescale i.MX integrated USB controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_ehci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|imx_ehci_softc
modifier|*
name|sc
decl_stmt|;
name|ehci_softc_t
modifier|*
name|esc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|esc
operator|=
operator|&
name|sc
operator|->
name|ehci_softc
expr_stmt|;
if|if
condition|(
name|esc
operator|->
name|sc_bus
operator|.
name|bdev
operator|!=
name|NULL
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|esc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_DONEINIT
condition|)
name|ehci_detach
argument_list|(
name|esc
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|->
name|sc_intr_hdl
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|esc
operator|->
name|sc_irq_res
argument_list|,
name|esc
operator|->
name|sc_intr_hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ehci_irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|ehci_irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ehci_mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|ehci_mem_res
argument_list|)
expr_stmt|;
name|usb_bus_mem_free_all
argument_list|(
operator|&
name|esc
operator|->
name|sc_bus
argument_list|,
operator|&
name|ehci_iterate_hw_softc
argument_list|)
expr_stmt|;
comment|/* During module unload there are lots of children leftover */
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_ehci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|imx_ehci_softc
modifier|*
name|sc
decl_stmt|;
name|ehci_softc_t
modifier|*
name|esc
decl_stmt|;
name|int
name|err
decl_stmt|,
name|rid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|esc
operator|=
operator|&
name|sc
operator|->
name|ehci_softc
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
comment|/* Allocate bus_space resources. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ehci_mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ehci_mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate memory resources\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ehci_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ehci_irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate IRQ resources\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|esc
operator|->
name|sc_io_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ehci_mem_res
argument_list|)
expr_stmt|;
name|esc
operator|->
name|sc_bus
operator|.
name|parent
operator|=
name|dev
expr_stmt|;
name|esc
operator|->
name|sc_bus
operator|.
name|devices
operator|=
name|esc
operator|->
name|sc_devices
expr_stmt|;
name|esc
operator|->
name|sc_bus
operator|.
name|devices_max
operator|=
name|EHCI_MAX_DEVICES
expr_stmt|;
name|esc
operator|->
name|sc_bus
operator|.
name|dma_bits
operator|=
literal|32
expr_stmt|;
comment|/* allocate all DMA memory */
if|if
condition|(
name|usb_bus_mem_alloc_all
argument_list|(
operator|&
name|esc
operator|->
name|sc_bus
argument_list|,
name|USB_GET_DMA_TAG
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|ehci_iterate_hw_softc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"usb_bus_mem_alloc_all() failed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Set handle to USB related registers subregion used by 	 * generic EHCI driver. 	 */
name|err
operator|=
name|bus_space_subregion
argument_list|(
name|esc
operator|->
name|sc_io_tag
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ehci_mem_res
argument_list|)
argument_list|,
name|IMX_EHCI_REG_OFF
argument_list|,
name|IMX_EHCI_REG_SIZE
argument_list|,
operator|&
name|esc
operator|->
name|sc_io_hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_space_subregion() failed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Setup interrupt handler. */
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|ehci_irq_res
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|ehci_interrupt
argument_list|,
name|esc
argument_list|,
operator|&
name|esc
operator|->
name|sc_intr_hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup IRQ\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Turn on clocks. */
name|imx_ccm_usb_enable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Add USB bus device. */
name|esc
operator|->
name|sc_bus
operator|.
name|bdev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"usbus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|->
name|sc_bus
operator|.
name|bdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not add USB device\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|device_set_ivars
argument_list|(
name|esc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
operator|&
name|esc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|esc
operator|->
name|sc_id_vendor
operator|=
name|USB_VENDOR_FREESCALE
expr_stmt|;
name|strlcpy
argument_list|(
name|esc
operator|->
name|sc_vendor
argument_list|,
literal|"Freescale"
argument_list|,
sizeof|sizeof
argument_list|(
name|esc
operator|->
name|sc_vendor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set flags that affect ehci_init() behavior, and hook our post-reset 	 * code into the standard controller code. 	 */
name|esc
operator|->
name|sc_flags
operator||=
name|EHCI_SCFLG_NORESTERM
operator||
name|EHCI_SCFLG_TT
expr_stmt|;
name|esc
operator|->
name|sc_vendor_post_reset
operator|=
name|imx_ehci_post_reset
expr_stmt|;
name|esc
operator|->
name|sc_vendor_get_port_speed
operator|=
name|ehci_get_port_speed_portsc
expr_stmt|;
name|err
operator|=
name|ehci_init
argument_list|(
name|esc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"USB init failed, usb_err_t=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|esc
operator|->
name|sc_flags
operator||=
name|EHCI_SCFLG_DONEINIT
expr_stmt|;
comment|/* Probe the bus. */
name|err
operator|=
name|device_probe_and_attach
argument_list|(
name|esc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"device_probe_and_attach() failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|imx_ehci_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ehci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|imx_ehci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|imx_ehci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|imx_ehci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ehci_driver
init|=
block|{
literal|"ehci"
block|,
name|ehci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|imx_ehci_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ehci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ehci
argument_list|,
name|simplebus
argument_list|,
name|ehci_driver
argument_list|,
name|ehci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ehci
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

