begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2012 Hans Petter Selasky. All rights reserved.  * Copyright (c) 2010-2011 Aleksandr Rybalko. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This file contains the driver for the DesignWare series USB 2.0 OTG  * Controller.  */
end_comment

begin_comment
comment|/*  * LIMITATION: Drivers must be bound to all OUT endpoints in the  * active configuration for this driver to work properly. Blocking any  * OUT endpoint will block all OUT endpoints including the control  * endpoint. Usually this is not a problem.  */
end_comment

begin_comment
comment|/*  * NOTE: Writing to non-existing registers appears to cause an  * internal reset.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|dwc_otg_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_include
include|#
directive|include
file|<dev/usb/controller/dwc_otg.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/dwc_otgreg.h>
end_include

begin_define
define|#
directive|define
name|DWC_OTG_BUS2SC
parameter_list|(
name|bus
parameter_list|)
define|\
value|((struct dwc_otg_softc *)(((uint8_t *)(bus)) - \     ((uint8_t *)&(((struct dwc_otg_softc *)0)->sc_bus))))
end_define

begin_define
define|#
directive|define
name|DWC_OTG_PC2UDEV
parameter_list|(
name|pc
parameter_list|)
define|\
value|(USB_DMATAG_TO_XROOT((pc)->tag_parent)->udev)
end_define

begin_define
define|#
directive|define
name|DWC_OTG_MSK_GINT_ENABLED
define|\
value|(GINTMSK_ENUMDONEMSK |		\    GINTMSK_USBRSTMSK |			\    GINTMSK_USBSUSPMSK |			\    GINTMSK_IEPINTMSK |			\    GINTMSK_SESSREQINTMSK |		\    GINTMSK_RXFLVLMSK |			\    GINTMSK_HCHINTMSK |			\    GINTMSK_OTGINTMSK |			\    GINTMSK_PRTINTMSK)
end_define

begin_define
define|#
directive|define
name|DWC_OTG_MSK_GINT_THREAD_IRQ
define|\
value|(GINTSTS_USBRST | GINTSTS_ENUMDONE | GINTSTS_PRTINT |	\    GINTSTS_WKUPINT | GINTSTS_USBSUSP | GINTMSK_OTGINTMSK |	\    GINTSTS_SESSREQINT)
end_define

begin_decl_stmt
specifier|static
name|int
name|dwc_otg_use_hsic
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|dwc_otg
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB DWC OTG"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_dwc_otg
argument_list|,
name|OID_AUTO
argument_list|,
name|use_hsic
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|dwc_otg_use_hsic
argument_list|,
literal|0
argument_list|,
literal|"DWC OTG uses HSIC interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|dwc_otg_debug
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_dwc_otg
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|dwc_otg_debug
argument_list|,
literal|0
argument_list|,
literal|"DWC OTG debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DWC_OTG_INTR_ENDPT
value|1
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_bus_methods
name|dwc_otg_bus_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_pipe_methods
name|dwc_otg_device_non_isoc_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_pipe_methods
name|dwc_otg_device_isoc_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_setup_rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_data_rx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_data_tx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_data_tx_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_host_setup_tx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_host_data_tx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dwc_otg_cmd_t
name|dwc_otg_host_data_rx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dwc_otg_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwc_otg_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwc_otg_standard_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwc_otg_root_intr
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwc_otg_interrupt_poll_locked
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwc_otg_host_channel_disable
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Here is a configuration that the chip supports.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hw_ep_profile
name|dwc_otg_ep_profile
index|[
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|max_in_frame_size
operator|=
literal|64
block|,
comment|/* fixed */
operator|.
name|max_out_frame_size
operator|=
literal|64
block|,
comment|/* fixed */
operator|.
name|is_simplex
operator|=
literal|1
block|,
operator|.
name|support_control
operator|=
literal|1
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dwc_otg_get_hw_ep_profile
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
modifier|*
name|ppf
parameter_list|,
name|uint8_t
name|ep_addr
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|DWC_OTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_addr
operator|<
name|sc
operator|->
name|sc_dev_ep_max
condition|)
operator|*
name|ppf
operator|=
operator|&
name|sc
operator|->
name|sc_hw_ep_profile
index|[
name|ep_addr
index|]
operator|.
name|usb
expr_stmt|;
else|else
operator|*
name|ppf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dwc_otg_init_fifo
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|struct
name|dwc_otg_profile
modifier|*
name|pf
decl_stmt|;
name|uint32_t
name|fifo_size
decl_stmt|;
name|uint32_t
name|fifo_regs
decl_stmt|;
name|uint32_t
name|tx_start
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|fifo_size
operator|=
name|sc
operator|->
name|sc_fifo_size
expr_stmt|;
comment|/* 	 * NOTE: Reserved fixed size area at end of RAM, which must 	 * not be allocated to the FIFOs: 	 */
name|fifo_regs
operator|=
literal|4
operator|*
literal|16
expr_stmt|;
if|if
condition|(
name|fifo_size
operator|<
name|fifo_regs
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Too little FIFO\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* subtract FIFO regs from total once */
name|fifo_size
operator|-=
name|fifo_regs
expr_stmt|;
comment|/* split equally for IN and OUT */
name|fifo_size
operator|/=
literal|2
expr_stmt|;
comment|/* align to 4 bytes boundary */
name|fifo_size
operator|&=
operator|~
literal|3
expr_stmt|;
comment|/* set global receive FIFO size */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRXFSIZ
argument_list|,
name|fifo_size
operator|/
literal|4
argument_list|)
expr_stmt|;
name|tx_start
operator|=
name|fifo_size
expr_stmt|;
if|if
condition|(
name|fifo_size
operator|<
literal|64
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Not enough data space for EP0 FIFO.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* disable any leftover host channels */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_host_ch_max
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|==
literal|0
condition|)
continue|continue;
name|dwc_otg_host_channel_disable
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|DWC_MODE_HOST
condition|)
block|{
comment|/* reset active endpoints */
name|sc
operator|->
name|sc_active_rx_ep
operator|=
literal|0
expr_stmt|;
comment|/* split equally for periodic and non-periodic */
name|fifo_size
operator|/=
literal|2
expr_stmt|;
comment|/* align to 4 bytes boundary */
name|fifo_size
operator|&=
operator|~
literal|3
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GNPTXFSIZ
argument_list|,
operator|(
operator|(
name|fifo_size
operator|/
literal|4
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|tx_start
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
name|tx_start
operator|+=
name|fifo_size
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_host_ch_max
condition|;
name|x
operator|++
control|)
block|{
comment|/* disable all host interrupts */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCINTMSK
argument_list|(
name|x
argument_list|)
argument_list|,
name|HCINT_DEFAULT_MASK
argument_list|)
expr_stmt|;
block|}
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPTXFSIZ
argument_list|,
operator|(
operator|(
name|fifo_size
operator|/
literal|4
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|tx_start
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* reset host channel state */
name|memset
argument_list|(
name|sc
operator|->
name|sc_chan_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_chan_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset FIFO TX levels */
name|sc
operator|->
name|sc_tx_cur_p_level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tx_cur_np_level
operator|=
literal|0
expr_stmt|;
comment|/* store maximum periodic and non-periodic FIFO TX size */
name|sc
operator|->
name|sc_tx_max_size
operator|=
name|fifo_size
expr_stmt|;
comment|/* enable all host channel interrupts */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HAINTMSK
argument_list|,
operator|(
literal|1U
operator|<<
name|sc
operator|->
name|sc_host_ch_max
operator|)
operator|-
literal|1U
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|DWC_MODE_DEVICE
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GNPTXFSIZ
argument_list|,
operator|(
literal|0x10
operator|<<
literal|16
operator|)
operator||
operator|(
name|tx_start
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
name|fifo_size
operator|-=
literal|0x40
expr_stmt|;
name|tx_start
operator|+=
literal|0x40
expr_stmt|;
comment|/* setup control endpoint profile */
name|sc
operator|->
name|sc_hw_ep_profile
index|[
literal|0
index|]
operator|.
name|usb
operator|=
name|dwc_otg_ep_profile
index|[
literal|0
index|]
expr_stmt|;
comment|/* reset active endpoints */
name|sc
operator|->
name|sc_active_rx_ep
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_dev_ep_max
condition|;
name|x
operator|++
control|)
block|{
name|pf
operator|=
name|sc
operator|->
name|sc_hw_ep_profile
operator|+
name|x
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|max_out_frame_size
operator|=
literal|1024
operator|*
literal|3
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|is_simplex
operator|=
literal|0
expr_stmt|;
comment|/* assume duplex */
name|pf
operator|->
name|usb
operator|.
name|support_bulk
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|support_interrupt
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|support_isochronous
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|support_out
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|sc
operator|->
name|sc_dev_in_ep_max
condition|)
block|{
name|uint32_t
name|limit
decl_stmt|;
name|limit
operator|=
operator|(
name|x
operator|==
literal|1
operator|)
condition|?
name|DWC_OTG_MAX_TXN
else|:
operator|(
name|DWC_OTG_MAX_TXN
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|fifo_size
operator|>=
name|limit
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTXF
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
operator|(
name|limit
operator|/
literal|4
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|tx_start
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
name|tx_start
operator|+=
name|limit
expr_stmt|;
name|fifo_size
operator|-=
name|limit
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|max_in_frame_size
operator|=
literal|0x200
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|support_in
operator|=
literal|1
expr_stmt|;
name|pf
operator|->
name|max_buffer
operator|=
name|limit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fifo_size
operator|>=
literal|0x80
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTXF
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
operator|(
literal|0x80
operator|/
literal|4
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|tx_start
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
name|tx_start
operator|+=
literal|0x80
expr_stmt|;
name|fifo_size
operator|-=
literal|0x80
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|max_in_frame_size
operator|=
literal|0x40
expr_stmt|;
name|pf
operator|->
name|usb
operator|.
name|support_in
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pf
operator|->
name|usb
operator|.
name|is_simplex
operator|=
literal|1
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTXF
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
literal|0x0
operator|<<
literal|16
operator|)
operator||
operator|(
name|tx_start
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pf
operator|->
name|usb
operator|.
name|is_simplex
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"FIFO%d = IN:%d / OUT:%d\n"
argument_list|,
name|x
argument_list|,
name|pf
operator|->
name|usb
operator|.
name|max_in_frame_size
argument_list|,
name|pf
operator|->
name|usb
operator|.
name|max_out_frame_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reset RX FIFO */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRSTCTL
argument_list|,
name|GRSTCTL_RXFFLSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DWC_MODE_OTG
condition|)
block|{
comment|/* reset all TX FIFOs */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRSTCTL
argument_list|,
name|GRSTCTL_TXFIFO
argument_list|(
literal|0x10
argument_list|)
operator||
name|GRSTCTL_TXFFLSH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reset active endpoints */
name|sc
operator|->
name|sc_active_rx_ep
operator|=
literal|0
expr_stmt|;
comment|/* reset periodic and non-periodic FIFO TX size */
name|sc
operator|->
name|sc_tx_max_size
operator|=
name|fifo_size
expr_stmt|;
comment|/* reset host channel state */
name|memset
argument_list|(
name|sc
operator|->
name|sc_chan_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_chan_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset FIFO TX levels */
name|sc
operator|->
name|sc_tx_cur_p_level
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tx_cur_np_level
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_update_host_frame_interval
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*    * Disabled until further. Assuming that the register is already    * programmed correctly by the boot loader.    */
if|#
directive|if
literal|0
block|uint32_t temp;
comment|/* setup HOST frame interval register, based on existing value */
block|temp = DWC_OTG_READ_4(sc, DOTG_HFIR)& HFIR_FRINT_MASK; 	if (temp>= 10000) 		temp /= 1000; 	else 		temp /= 125;
comment|/* figure out nearest X-tal value */
block|if (temp>= 54) 		temp = 60;
comment|/* MHz */
block|else if (temp>= 39) 		temp = 48;
comment|/* MHz */
block|else 		temp = 30;
comment|/* MHz */
block|if (sc->sc_flags.status_high_speed) 		temp *= 125; 	else 		temp *= 1000;  	DPRINTF("HFIR=0x%08x\n", temp);  	DWC_OTG_WRITE_4(sc, DOTG_HFIR, temp);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_clocks_on
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* TODO - platform specific */
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_clocks_off
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* TODO - platform specific */
name|sc
operator|->
name|sc_flags
operator|.
name|clocks_off
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_pull_up
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
comment|/* pullup D+, if possible */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DCTL_SFTDISCON
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_pull_down
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
comment|/* pulldown D+, if possible */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|d_pulled_up
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DCTL_SFTDISCON
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_enable_sof_irq
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* In device mode we don't use the SOF interrupt */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|!=
literal|0
operator|||
operator|(
name|sc
operator|->
name|sc_irq_mask
operator|&
name|GINTMSK_SOFMSK
operator|)
operator|!=
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_irq_mask
operator||=
name|GINTMSK_SOFMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_resume_irq
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
block|{
comment|/* update status bits */
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
condition|)
block|{
comment|/* 			 * Disable resume interrupt and enable suspend 			 * interrupt: 			 */
name|sc
operator|->
name|sc_irq_mask
operator|&=
operator|~
name|GINTMSK_WKUPINTMSK
expr_stmt|;
name|sc
operator|->
name|sc_irq_mask
operator||=
name|GINTMSK_USBSUSPMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
block|}
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_suspend_irq
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
block|{
comment|/* update status bits */
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
condition|)
block|{
comment|/* 			 * Disable suspend interrupt and enable resume 			 * interrupt: 			 */
name|sc
operator|->
name|sc_irq_mask
operator|&=
operator|~
name|GINTMSK_USBSUSPMSK
expr_stmt|;
name|sc
operator|->
name|sc_irq_mask
operator||=
name|GINTMSK_WKUPINTMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
block|}
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_wakeup_peer
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
return|return;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"Remote wakeup\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
comment|/* enable remote wakeup signalling */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DCTL_RMTWKUPSIG
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Wait 8ms for remote wakeup to complete. */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|125
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DCTL_RMTWKUPSIG
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* enable USB port */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_PCGCCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait 10ms */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* resume port */
name|sc
operator|->
name|sc_hprt_val
operator||=
name|HPRT_PRTRES
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
argument_list|)
expr_stmt|;
comment|/* Wait 100ms for resume signalling to complete. */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* clear suspend and resume */
name|sc
operator|->
name|sc_hprt_val
operator|&=
operator|~
operator|(
name|HPRT_PRTSUSP
operator||
name|HPRT_PRTRES
operator|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
argument_list|)
expr_stmt|;
comment|/* Wait 4ms */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|250
argument_list|)
expr_stmt|;
block|}
comment|/* need to fake resume IRQ */
name|dwc_otg_resume_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_set_address
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"addr=%d\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCFG
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|DCFG_DEVADDR_SET
argument_list|(
literal|0x7F
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DCFG_DEVADDR_SET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCFG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_common_rx_ack
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"RX status clear\n"
argument_list|)
expr_stmt|;
comment|/* enable RX FIFO level interrupt */
name|sc
operator|->
name|sc_irq_mask
operator||=
name|GINTMSK_RXFLVLMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
comment|/* clear cached status */
name|sc
operator|->
name|sc_last_rx_status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_clear_hcint
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|x
parameter_list|)
block|{
name|uint32_t
name|hcint
decl_stmt|;
comment|/* clear all pending interrupts */
name|hcint
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCINT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|hcint
argument_list|)
expr_stmt|;
comment|/* clear buffered interrupts */
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|hcint
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_channel_alloc
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|,
name|uint8_t
name|is_out
parameter_list|)
block|{
name|uint32_t
name|tx_p_size
decl_stmt|;
name|uint32_t
name|tx_np_size
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|channel
operator|<
name|DWC_OTG_MAX_CHANNELS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* already allocated */
comment|/* check if device is suspended */
if|if
condition|(
name|DWC_OTG_PC2UDEV
argument_list|(
name|td
operator|->
name|pc
argument_list|)
operator|->
name|flags
operator|.
name|self_suspended
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* busy - cannot transfer data */
comment|/* compute needed TX FIFO size */
if|if
condition|(
name|is_out
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|tx_p_size
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
name|tx_np_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|&&
name|tx_p_size
operator|>
name|HCSPLT_XACTLEN_BURST
condition|)
name|tx_p_size
operator|=
name|HCSPLT_XACTLEN_BURST
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_tx_cur_p_level
operator|+
name|tx_p_size
operator|)
operator|>
name|sc
operator|->
name|sc_tx_max_size
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Too little FIFO space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* too little FIFO */
block|}
block|}
else|else
block|{
name|tx_p_size
operator|=
literal|0
expr_stmt|;
name|tx_np_size
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|&&
name|tx_np_size
operator|>
name|HCSPLT_XACTLEN_BURST
condition|)
name|tx_np_size
operator|=
name|HCSPLT_XACTLEN_BURST
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_tx_cur_np_level
operator|+
name|tx_np_size
operator|)
operator|>
name|sc
operator|->
name|sc_tx_max_size
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Too little FIFO space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* too little FIFO */
block|}
block|}
block|}
else|else
block|{
comment|/* not a TX transaction */
name|tx_p_size
operator|=
literal|0
expr_stmt|;
name|tx_np_size
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_host_ch_max
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|allocated
operator|!=
literal|0
condition|)
continue|continue;
comment|/* check if channel is still enabled */
if|if
condition|(
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|!=
literal|0
condition|)
continue|continue;
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|allocated
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|tx_p_size
operator|=
name|tx_p_size
expr_stmt|;
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|tx_np_size
operator|=
name|tx_np_size
expr_stmt|;
comment|/* keep track of used TX FIFO, if any */
name|sc
operator|->
name|sc_tx_cur_p_level
operator|+=
name|tx_p_size
expr_stmt|;
name|sc
operator|->
name|sc_tx_cur_np_level
operator|+=
name|tx_np_size
expr_stmt|;
comment|/* clear interrupts */
name|dwc_otg_clear_hcint
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CH=%d HCCHAR=0x%08x "
literal|"HCSPLT=0x%08x\n"
argument_list|,
name|x
argument_list|,
name|td
operator|->
name|hcchar
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
comment|/* set active channel */
name|sc
operator|->
name|sc_active_rx_ep
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
comment|/* set channel */
name|td
operator|->
name|channel
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* allocated */
block|}
comment|/* wait a bit */
name|dwc_otg_enable_sof_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* busy */
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_host_channel_free
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|channel
operator|>=
name|DWC_OTG_MAX_CHANNELS
condition|)
return|return;
comment|/* already freed */
comment|/* free channel */
name|x
operator|=
name|td
operator|->
name|channel
expr_stmt|;
name|td
operator|->
name|channel
operator|=
name|DWC_OTG_MAX_CHANNELS
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CH=%d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* 	 * We need to let programmed host channels run till complete 	 * else the host channel will stop functioning. Assume that 	 * after a fixed given amount of time the host channel is no 	 * longer doing any USB traffic: 	 */
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
comment|/* double buffered */
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|=
name|DWC_OTG_SLOT_IDLE_MAX
expr_stmt|;
block|}
else|else
block|{
comment|/* single buffered */
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|=
name|DWC_OTG_SLOT_IDLE_MIN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
comment|/* ack any pending messages */
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|!=
literal|0
operator|&&
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
operator|==
name|x
condition|)
block|{
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* clear active channel */
name|sc
operator|->
name|sc_active_rx_ep
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_host_dump_rx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
comment|/* dump any pending messages */
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|channel
operator|<
name|DWC_OTG_MAX_CHANNELS
operator|&&
name|td
operator|->
name|channel
operator|==
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
condition|)
block|{
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_setup_tx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
name|__aligned
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|uint32_t
name|hcint
decl_stmt|;
name|uint32_t
name|hcchar
decl_stmt|;
name|uint8_t
name|delta
decl_stmt|;
name|dwc_otg_host_dump_rx
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|channel
operator|<
name|DWC_OTG_MAX_CHANNELS
condition|)
block|{
name|hcint
operator|=
name|sc
operator|->
name|sc_chan_state
index|[
name|td
operator|->
name|channel
index|]
operator|.
name|hcint
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CH=%d ST=%d HCINT=0x%08x HCCHAR=0x%08x HCTSIZ=0x%08x\n"
argument_list|,
name|td
operator|->
name|channel
argument_list|,
name|td
operator|->
name|state
argument_list|,
name|hcint
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|)
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hcint
operator|=
literal|0
expr_stmt|;
goto|goto
name|check_state
goto|;
block|}
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
comment|/* give success bits priority over failure bits */
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_STALL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"CH=%d STALL\n"
argument_list|,
name|td
operator|->
name|channel
argument_list|)
expr_stmt|;
name|td
operator|->
name|error_stall
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ERRORS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"CH=%d ERROR\n"
argument_list|,
name|td
operator|->
name|channel
argument_list|)
expr_stmt|;
name|td
operator|->
name|errcnt
operator|++
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|||
name|td
operator|->
name|errcnt
operator|>=
literal|3
condition|)
block|{
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
block|}
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ERRORS
operator||
name|HCINT_RETRY
operator||
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hcint
operator|&
name|HCINT_ERRORS
operator|)
condition|)
name|td
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
block|}
name|check_state
label|:
switch|switch
condition|(
name|td
operator|->
name|state
condition|)
block|{
case|case
name|DWC_CHAN_ST_START
case|:
goto|goto
name|send_pkt
goto|;
case|case
name|DWC_CHAN_ST_WAIT_ANE
case|:
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
name|td
operator|->
name|offset
operator|+=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_S_ANE
case|:
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
goto|goto
name|send_cpkt
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_C_ANE
case|:
if|if
condition|(
name|hcint
operator|&
name|HCINT_NYET
condition|)
block|{
goto|goto
name|send_cpkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ACK
condition|)
block|{
name|td
operator|->
name|offset
operator|+=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_C_PKT
case|:
goto|goto
name|send_cpkt
goto|;
default|default:
break|break;
block|}
goto|goto
name|busy
goto|;
name|send_pkt
label|:
comment|/* free existing channel, if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|req
argument_list|)
operator|!=
name|td
operator|->
name|remainder
condition|)
block|{
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
name|delta
operator|=
name|td
operator|->
name|tt_start_slot
operator|-
name|sc
operator|->
name|sc_last_frame_num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|==
literal|0
operator|||
name|delta
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|delta
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|-
name|td
operator|->
name|tt_start_slot
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|5
condition|)
block|{
comment|/* missed it */
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
block|}
comment|/* allocate a new channel */
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|hcsplt
operator|&=
operator|~
name|HCSPLT_COMPSPLT
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_S_ANE
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_ANE
expr_stmt|;
block|}
name|usbd_copy_out
argument_list|(
name|td
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|req
argument_list|)
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|HCTSIZ_PID_SETUP
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCSPLT
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
name|hcchar
operator|=
name|td
operator|->
name|hcchar
expr_stmt|;
name|hcchar
operator|&=
operator|~
operator|(
name|HCCHAR_EPDIR_IN
operator||
name|HCCHAR_EPTYPE_MASK
operator|)
expr_stmt|;
name|hcchar
operator||=
name|UE_CONTROL
operator|<<
name|HCCHAR_EPTYPE_SHIFT
expr_stmt|;
comment|/* must enable channel before writing data to FIFO */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
name|hcchar
argument_list|)
expr_stmt|;
comment|/* transfer data into FIFO */
name|bus_space_write_region_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|DOTG_DFIFO
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* wait until next slot before trying complete split */
name|td
operator|->
name|tt_complete_slot
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|+
literal|1
expr_stmt|;
comment|/* store number of bytes transmitted */
name|td
operator|->
name|tx_bytes
operator|=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
expr_stmt|;
goto|goto
name|busy
goto|;
name|send_cpkt
label|:
comment|/* free existing channel, if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|delta
operator|=
name|td
operator|->
name|tt_complete_slot
operator|-
name|sc
operator|->
name|sc_last_frame_num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|==
literal|0
operator|||
name|delta
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|delta
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|-
name|td
operator|->
name|tt_start_slot
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
comment|/* we missed the service interval */
if|if
condition|(
name|td
operator|->
name|ep_type
operator|!=
name|UE_ISOCHRONOUS
condition|)
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
comment|/* allocate a new channel */
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
comment|/* wait until next slot before trying complete split */
name|td
operator|->
name|tt_complete_slot
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|+
literal|1
expr_stmt|;
name|td
operator|->
name|hcsplt
operator||=
name|HCSPLT_COMPSPLT
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_ANE
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
operator|(
name|HCTSIZ_PID_SETUP
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCSPLT
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
name|hcchar
operator|=
name|td
operator|->
name|hcchar
expr_stmt|;
name|hcchar
operator|&=
operator|~
operator|(
name|HCCHAR_EPDIR_IN
operator||
name|HCCHAR_EPTYPE_MASK
operator|)
expr_stmt|;
name|hcchar
operator||=
name|UE_CONTROL
operator|<<
name|HCCHAR_EPTYPE_SHIFT
expr_stmt|;
comment|/* must enable channel before writing data to FIFO */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|td
operator|->
name|channel
argument_list|)
argument_list|,
name|hcchar
argument_list|)
expr_stmt|;
name|busy
label|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* busy */
name|complete
label|:
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_setup_rx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
name|__aligned
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
comment|/* check endpoint status */
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|==
literal|0
condition|)
goto|goto
name|not_complete
goto|;
if|if
condition|(
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|not_complete
goto|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_DPID_MASK
operator|)
operator|!=
name|GRXSTSRD_DPID_DATA0
condition|)
block|{
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_PKTSTS_MASK
operator|)
operator|!=
name|GRXSTSRD_STP_DATA
condition|)
block|{
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"GRXSTSR=0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
comment|/* clear did stall */
name|td
operator|->
name|did_stall
operator|=
literal|0
expr_stmt|;
comment|/* get the packet byte count */
name|count
operator|=
name|GRXSTSRD_BCNT_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
comment|/* verify data length */
if|if
condition|(
name|count
operator|!=
name|td
operator|->
name|remainder
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Invalid SETUP packet "
literal|"length, %d bytes\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
if|if
condition|(
name|count
operator|!=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Unsupported SETUP packet "
literal|"length, %d bytes\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
comment|/* copy in control request */
name|memcpy
argument_list|(
operator|&
name|req
argument_list|,
name|sc
operator|->
name|sc_rx_bounce_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy data into real buffer */
name|usbd_copy_in
argument_list|(
name|td
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|td
operator|->
name|remainder
operator|=
literal|0
expr_stmt|;
comment|/* sneak peek the set address */
if|if
condition|(
operator|(
name|req
operator|.
name|bmRequestType
operator|==
name|UT_WRITE_DEVICE
operator|)
operator|&&
operator|(
name|req
operator|.
name|bRequest
operator|==
name|UR_SET_ADDRESS
operator|)
condition|)
block|{
comment|/* must write address before ZLP */
name|dwc_otg_set_address
argument_list|(
name|sc
argument_list|,
name|req
operator|.
name|wValue
index|[
literal|0
index|]
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
block|}
comment|/* don't send any data by default */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTSIZ
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DXEPTSIZ_SET_NPKT
argument_list|(
literal|0
argument_list|)
operator||
name|DXEPTSIZ_SET_NBYTES
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|sc
operator|->
name|sc_in_ctl
index|[
literal|0
index|]
expr_stmt|;
comment|/* enable IN endpoint */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
operator||
name|DIEPCTL_EPENA
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
operator||
name|DIEPCTL_SNAK
argument_list|)
expr_stmt|;
comment|/* reset IN endpoint buffer */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRSTCTL
argument_list|,
name|GRSTCTL_TXFIFO
argument_list|(
literal|0
argument_list|)
operator||
name|GRSTCTL_TXFFLSH
argument_list|)
expr_stmt|;
comment|/* acknowledge RX status */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
name|not_complete
label|:
comment|/* abort any ongoing transfer, before enabling again */
name|temp
operator|=
name|sc
operator|->
name|sc_out_ctl
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator||=
name|DOEPCTL_EPENA
operator||
name|DOEPCTL_SNAK
expr_stmt|;
comment|/* enable OUT endpoint */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|td
operator|->
name|did_stall
condition|)
block|{
name|td
operator|->
name|did_stall
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"stalling IN and OUT direction\n"
argument_list|)
expr_stmt|;
comment|/* set stall after enabling endpoint */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
operator||
name|DOEPCTL_STALL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|sc
operator|->
name|sc_in_ctl
index|[
literal|0
index|]
expr_stmt|;
comment|/* set stall assuming endpoint is enabled */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
literal|0
argument_list|)
argument_list|,
name|temp
operator||
name|DIEPCTL_STALL
argument_list|)
expr_stmt|;
block|}
comment|/* setup number of buffers to receive */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPTSIZ
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DXEPTSIZ_SET_MULTI
argument_list|(
literal|3
argument_list|)
operator||
name|DXEPTSIZ_SET_NPKT
argument_list|(
literal|1
argument_list|)
operator||
name|DXEPTSIZ_SET_NBYTES
argument_list|(
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_rate_check_interrupt
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint8_t
name|delta
decl_stmt|;
name|delta
operator|=
name|sc
operator|->
name|sc_tmr_val
operator|-
name|td
operator|->
name|tmr_val
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|128
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* busy */
name|td
operator|->
name|tmr_val
operator|=
name|sc
operator|->
name|sc_tmr_val
operator|+
name|td
operator|->
name|tmr_res
expr_stmt|;
comment|/* set toggle, if any */
if|if
condition|(
name|td
operator|->
name|set_toggle
condition|)
block|{
name|td
operator|->
name|set_toggle
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_rate_check
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
comment|/* non TT isochronous traffic */
if|if
condition|(
operator|(
name|td
operator|->
name|tmr_val
operator|!=
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_last_frame_num
operator|&
operator|(
name|td
operator|->
name|tmr_res
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
goto|goto
name|busy
goto|;
block|}
name|td
operator|->
name|tmr_val
operator|=
literal|1
expr_stmt|;
comment|/* executed */
name|td
operator|->
name|toggle
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_INTERRUPT
condition|)
block|{
if|if
condition|(
operator|!
name|td
operator|->
name|tt_scheduled
condition|)
goto|goto
name|busy
goto|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|did_nak
operator|>=
name|DWC_OTG_NAK_MAX
condition|)
block|{
goto|goto
name|busy
goto|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|set_toggle
condition|)
block|{
name|td
operator|->
name|set_toggle
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|busy
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_data_rx_sub
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint32_t
name|count
decl_stmt|;
name|uint8_t
name|channel
decl_stmt|;
comment|/* check endpoint status */
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|==
literal|0
condition|)
goto|goto
name|busy
goto|;
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
name|DWC_OTG_MAX_CHANNELS
condition|)
goto|goto
name|busy
goto|;
if|if
condition|(
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
operator|!=
name|channel
condition|)
goto|goto
name|busy
goto|;
switch|switch
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_PKTSTS_MASK
condition|)
block|{
case|case
name|GRXSTSRH_IN_DATA
case|:
name|DPRINTF
argument_list|(
literal|"DATA ST=%d STATUS=0x%08x\n"
argument_list|,
operator|(
name|int
operator|)
name|td
operator|->
name|state
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_chan_state
index|[
name|channel
index|]
operator|.
name|hcint
operator|&
name|HCINT_SOFTWARE_ONLY
condition|)
block|{
comment|/* 			 * When using SPLIT transactions on interrupt 			 * endpoints, sometimes data occurs twice. 			 */
name|DPRINTF
argument_list|(
literal|"Data already received\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* get the packet byte count */
name|count
operator|=
name|GRXSTSRD_BCNT_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
comment|/* check for isochronous transfer or high-speed bandwidth endpoint */
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
operator|||
name|td
operator|->
name|max_packet_count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_DPID_MASK
operator|)
operator|!=
name|GRXSTSRD_DPID_DATA0
condition|)
block|{
name|td
operator|->
name|tt_xactpos
operator|=
name|HCSPLT_XACTPOS_MIDDLE
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|tt_xactpos
operator|=
name|HCSPLT_XACTPOS_BEGIN
expr_stmt|;
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|<
name|td
operator|->
name|max_packet_size
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|got_short
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|td
operator|->
name|toggle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|!=
name|td
operator|->
name|max_packet_size
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|td
operator|->
name|max_packet_size
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|got_short
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
block|}
name|td
operator|->
name|toggle
operator|^=
literal|1
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
block|}
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|>
name|td
operator|->
name|remainder
condition|)
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
name|usbd_copy_in
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_rx_bounce_buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
name|sc
operator|->
name|sc_chan_state
index|[
name|channel
index|]
operator|.
name|hcint
operator||=
name|HCINT_SOFTWARE_ONLY
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|busy
label|:
return|return
operator|(
literal|0
operator|)
return|;
name|complete
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_data_rx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint32_t
name|hcint
decl_stmt|;
name|uint32_t
name|hcchar
decl_stmt|;
name|uint8_t
name|delta
decl_stmt|;
name|uint8_t
name|channel
decl_stmt|;
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|<
name|DWC_OTG_MAX_CHANNELS
condition|)
block|{
name|hcint
operator|=
name|sc
operator|->
name|sc_chan_state
index|[
name|channel
index|]
operator|.
name|hcint
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CH=%d ST=%d HCINT=0x%08x HCCHAR=0x%08x HCTSIZ=0x%08x\n"
argument_list|,
name|channel
argument_list|,
name|td
operator|->
name|state
argument_list|,
name|hcint
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check interrupt bits */
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
comment|/* give success bits priority over failure bits */
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_STALL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"CH=%d STALL\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|td
operator|->
name|error_stall
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ERRORS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"CH=%d ERROR\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|td
operator|->
name|errcnt
operator|++
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|||
name|td
operator|->
name|errcnt
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|ep_type
operator|!=
name|UE_ISOCHRONOUS
condition|)
block|{
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
block|}
block|}
comment|/* check channels for data, if any */
if|if
condition|(
name|dwc_otg_host_data_rx_sub
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
condition|)
goto|goto
name|complete
goto|;
comment|/* refresh interrupt status */
name|hcint
operator|=
name|sc
operator|->
name|sc_chan_state
index|[
name|channel
index|]
operator|.
name|hcint
expr_stmt|;
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ERRORS
operator||
name|HCINT_RETRY
operator||
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hcint
operator|&
name|HCINT_ERRORS
operator|)
condition|)
name|td
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|hcint
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|td
operator|->
name|state
condition|)
block|{
case|case
name|DWC_CHAN_ST_START
case|:
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
goto|goto
name|receive_spkt
goto|;
else|else
goto|goto
name|receive_pkt
goto|;
case|case
name|DWC_CHAN_ST_WAIT_ANE
case|:
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_INTERRUPT
condition|)
block|{
comment|/* 				 * The USB specification does not 				 * mandate a particular data toggle 				 * value for USB INTERRUPT 				 * transfers. Switch the data toggle 				 * value to receive the packet 				 * correctly: 				 */
if|if
condition|(
name|hcint
operator|&
name|HCINT_DATATGLERR
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Retrying packet due to "
literal|"data toggle error\n"
argument_list|)
expr_stmt|;
name|td
operator|->
name|toggle
operator|^=
literal|1
expr_stmt|;
goto|goto
name|receive_pkt
goto|;
block|}
block|}
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
goto|goto
name|receive_spkt
goto|;
else|else
goto|goto
name|receive_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_NYET
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
comment|/* try again */
goto|goto
name|receive_pkt
goto|;
block|}
else|else
block|{
comment|/* not a valid token for IN endpoints */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ACK
condition|)
block|{
comment|/* wait for data - ACK arrived first */
if|if
condition|(
operator|!
operator|(
name|hcint
operator|&
name|HCINT_SOFTWARE_ONLY
operator|)
condition|)
goto|goto
name|busy
goto|;
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
comment|/* check if we are complete */
if|if
condition|(
operator|(
name|td
operator|->
name|remainder
operator|==
literal|0
operator|)
operator|||
operator|(
name|td
operator|->
name|tt_xactpos
operator|==
name|HCSPLT_XACTPOS_BEGIN
operator|)
condition|)
block|{
goto|goto
name|complete
goto|;
block|}
comment|/* get another packet */
goto|goto
name|receive_pkt
goto|;
block|}
else|else
block|{
comment|/* check if we are complete */
if|if
condition|(
operator|(
name|td
operator|->
name|remainder
operator|==
literal|0
operator|)
operator|||
operator|(
name|td
operator|->
name|got_short
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
goto|goto
name|complete
goto|;
comment|/* 					 * Else need to receive a zero length 					 * packet. 					 */
block|}
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
goto|goto
name|receive_spkt
goto|;
else|else
goto|goto
name|receive_pkt
goto|;
block|}
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_S_ANE
case|:
comment|/* 		 * NOTE: The DWC OTG hardware provides a fake ACK in 		 * case of interrupt and isochronous transfers: 		 */
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|receive_spkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_NYET
condition|)
block|{
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|receive_spkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ACK
condition|)
block|{
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
goto|goto
name|receive_pkt
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_C_PKT
case|:
goto|goto
name|receive_pkt
goto|;
default|default:
break|break;
block|}
goto|goto
name|busy
goto|;
name|receive_pkt
label|:
comment|/* free existing channel, if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
name|delta
operator|=
name|td
operator|->
name|tt_complete_slot
operator|-
name|sc
operator|->
name|sc_last_frame_num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|==
literal|0
operator|||
name|delta
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|delta
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|-
name|td
operator|->
name|tt_start_slot
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|ep_type
operator|!=
name|UE_ISOCHRONOUS
condition|)
block|{
comment|/* we missed the service interval */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|complete
goto|;
block|}
comment|/* complete split */
name|td
operator|->
name|hcsplt
operator||=
name|HCSPLT_COMPSPLT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|tt_xactpos
operator|==
name|HCSPLT_XACTPOS_BEGIN
operator|&&
name|dwc_otg_host_rate_check
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
comment|/* allocate a new channel */
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
comment|/* set toggle, if any */
if|if
condition|(
name|td
operator|->
name|set_toggle
condition|)
block|{
name|td
operator|->
name|set_toggle
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_ANE
expr_stmt|;
comment|/* receive one packet */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|td
operator|->
name|max_packet_size
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|td
operator|->
name|toggle
condition|?
operator|(
name|HCTSIZ_PID_DATA1
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
else|:
operator|(
name|HCTSIZ_PID_DATA0
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCSPLT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
name|hcchar
operator|=
name|td
operator|->
name|hcchar
expr_stmt|;
name|hcchar
operator||=
name|HCCHAR_EPDIR_IN
expr_stmt|;
comment|/* receive complete split ASAP */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_frame_num
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|hcchar
operator||=
name|HCCHAR_ODDFRM
expr_stmt|;
else|else
name|hcchar
operator|&=
operator|~
name|HCCHAR_ODDFRM
expr_stmt|;
comment|/* must enable channel before data can be received */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|channel
argument_list|)
argument_list|,
name|hcchar
argument_list|)
expr_stmt|;
comment|/* wait until next slot before trying complete split */
name|td
operator|->
name|tt_complete_slot
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|+
literal|1
expr_stmt|;
goto|goto
name|busy
goto|;
name|receive_spkt
label|:
comment|/* free existing channel(s), if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|delta
operator|=
name|td
operator|->
name|tt_start_slot
operator|-
name|sc
operator|->
name|sc_last_frame_num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|==
literal|0
operator|||
name|delta
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|delta
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|-
name|td
operator|->
name|tt_start_slot
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|5
condition|)
block|{
comment|/* missed it */
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
comment|/* allocate a new channel */
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
name|td
operator|->
name|hcsplt
operator|&=
operator|~
name|HCSPLT_COMPSPLT
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_S_ANE
expr_stmt|;
comment|/* receive one packet */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|HCTSIZ_PID_DATA0
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCSPLT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
comment|/* send after next SOF event */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_frame_num
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|td
operator|->
name|hcchar
operator||=
name|HCCHAR_ODDFRM
expr_stmt|;
else|else
name|td
operator|->
name|hcchar
operator|&=
operator|~
name|HCCHAR_ODDFRM
expr_stmt|;
name|hcchar
operator|=
name|td
operator|->
name|hcchar
expr_stmt|;
name|hcchar
operator||=
name|HCCHAR_EPDIR_IN
expr_stmt|;
comment|/* wait until next slot before trying complete split */
name|td
operator|->
name|tt_complete_slot
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|+
literal|1
expr_stmt|;
comment|/* must enable channel before data can be received */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|channel
argument_list|)
argument_list|,
name|hcchar
argument_list|)
expr_stmt|;
name|busy
label|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* busy */
name|complete
label|:
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_data_rx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|uint8_t
name|got_short
decl_stmt|;
name|got_short
operator|=
literal|0
expr_stmt|;
comment|/* check endpoint status */
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|==
literal|0
condition|)
goto|goto
name|not_complete
goto|;
if|if
condition|(
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
operator|!=
name|td
operator|->
name|ep_no
condition|)
goto|goto
name|not_complete
goto|;
comment|/* check for SETUP packet */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_PKTSTS_MASK
operator|)
operator|==
name|GRXSTSRD_STP_DATA
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We are actually complete and have 			 * received the next SETUP 			 */
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"faking complete\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
comment|/* 		 * USB Host Aborted the transfer. 		 */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_PKTSTS_MASK
operator|)
operator|!=
name|GRXSTSRD_OUT_DATA
condition|)
block|{
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
comment|/* get the packet byte count */
name|count
operator|=
name|GRXSTSRD_BCNT_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|!=
name|td
operator|->
name|max_packet_size
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|td
operator|->
name|max_packet_size
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|got_short
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are complete */
block|}
block|}
comment|/* verify the packet byte count */
if|if
condition|(
name|count
operator|>
name|td
operator|->
name|remainder
condition|)
block|{
comment|/* invalid USB packet */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are complete */
block|}
name|usbd_copy_in
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_rx_bounce_buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
comment|/* release FIFO */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* check if we are complete */
if|if
condition|(
operator|(
name|td
operator|->
name|remainder
operator|==
literal|0
operator|)
operator|||
name|got_short
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
block|{
comment|/* we are complete */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else need to receive a zero length packet */
block|}
name|not_complete
label|:
name|temp
operator|=
name|sc
operator|->
name|sc_out_ctl
index|[
name|td
operator|->
name|ep_no
index|]
expr_stmt|;
name|temp
operator||=
name|DOEPCTL_EPENA
operator||
name|DOEPCTL_CNAK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPCTL
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* enable SETUP and transfer complete interrupt */
if|if
condition|(
name|td
operator|->
name|ep_no
operator|==
literal|0
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPTSIZ
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DXEPTSIZ_SET_NPKT
argument_list|(
literal|1
argument_list|)
operator||
name|DXEPTSIZ_SET_NBYTES
argument_list|(
name|td
operator|->
name|max_packet_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* allow reception of multiple packets */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPTSIZ
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|DXEPTSIZ_SET_MULTI
argument_list|(
literal|1
argument_list|)
operator||
name|DXEPTSIZ_SET_NPKT
argument_list|(
literal|4
argument_list|)
operator||
name|DXEPTSIZ_SET_NBYTES
argument_list|(
literal|4
operator|*
operator|(
operator|(
name|td
operator|->
name|max_packet_size
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_host_data_tx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint32_t
name|count
decl_stmt|;
name|uint32_t
name|hcint
decl_stmt|;
name|uint32_t
name|hcchar
decl_stmt|;
name|uint8_t
name|delta
decl_stmt|;
name|uint8_t
name|channel
decl_stmt|;
name|dwc_otg_host_dump_rx
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
if|if
condition|(
name|channel
operator|<
name|DWC_OTG_MAX_CHANNELS
condition|)
block|{
name|hcint
operator|=
name|sc
operator|->
name|sc_chan_state
index|[
name|channel
index|]
operator|.
name|hcint
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"CH=%d ST=%d HCINT=0x%08x HCCHAR=0x%08x HCTSIZ=0x%08x\n"
argument_list|,
name|channel
argument_list|,
name|td
operator|->
name|state
argument_list|,
name|hcint
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
comment|/* give success bits priority over failure bits */
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_STALL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"CH=%d STALL\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|td
operator|->
name|error_stall
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ERRORS
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"CH=%d ERROR\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|td
operator|->
name|errcnt
operator|++
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|||
name|td
operator|->
name|errcnt
operator|>=
literal|3
condition|)
block|{
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
block|}
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ERRORS
operator||
name|HCINT_RETRY
operator||
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hcint
operator|&
name|HCINT_ERRORS
operator|)
condition|)
name|td
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|hcint
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|td
operator|->
name|state
condition|)
block|{
case|case
name|DWC_CHAN_ST_START
case|:
goto|goto
name|send_pkt
goto|;
case|case
name|DWC_CHAN_ST_WAIT_ANE
case|:
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
name|td
operator|->
name|offset
operator|+=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|toggle
operator|^=
literal|1
expr_stmt|;
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
comment|/* check remainder */
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
goto|goto
name|complete
goto|;
comment|/* 				 * Else we need to transmit a short 				 * packet: 				 */
block|}
goto|goto
name|send_pkt
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_S_ANE
case|:
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_ACK
operator||
name|HCINT_NYET
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_cpkt
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_C_ANE
case|:
if|if
condition|(
name|hcint
operator|&
name|HCINT_NYET
condition|)
block|{
goto|goto
name|send_cpkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
operator|(
name|HCINT_RETRY
operator||
name|HCINT_ERRORS
operator|)
condition|)
block|{
name|td
operator|->
name|did_nak
operator|++
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
goto|goto
name|send_pkt
goto|;
block|}
elseif|else
if|if
condition|(
name|hcint
operator|&
name|HCINT_ACK
condition|)
block|{
name|td
operator|->
name|offset
operator|+=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|toggle
operator|^=
literal|1
expr_stmt|;
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
comment|/* check remainder */
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
goto|goto
name|complete
goto|;
comment|/* else we need to transmit a short packet */
block|}
goto|goto
name|send_pkt
goto|;
block|}
break|break;
case|case
name|DWC_CHAN_ST_WAIT_C_PKT
case|:
goto|goto
name|send_cpkt
goto|;
case|case
name|DWC_CHAN_ST_TX_WAIT_ISOC
case|:
comment|/* Check if isochronous OUT traffic is complete */
if|if
condition|(
operator|(
name|hcint
operator|&
name|HCINT_HCH_DONE_MASK
operator|)
operator|==
literal|0
condition|)
break|break;
name|td
operator|->
name|offset
operator|+=
name|td
operator|->
name|tx_bytes
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|td
operator|->
name|tx_bytes
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|||
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
goto|goto
name|complete
goto|;
comment|/* check for next packet */
if|if
condition|(
name|td
operator|->
name|max_packet_count
operator|>
literal|1
condition|)
name|td
operator|->
name|tt_xactpos
operator|++
expr_stmt|;
comment|/* free existing channel, if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_TX_PKT_ISOC
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|DWC_CHAN_ST_TX_PKT_ISOC
case|:
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
goto|goto
name|send_isoc_pkt
goto|;
default|default:
break|break;
block|}
goto|goto
name|busy
goto|;
name|send_pkt
label|:
comment|/* free existing channel(s), if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
name|delta
operator|=
name|td
operator|->
name|tt_start_slot
operator|-
name|sc
operator|->
name|sc_last_frame_num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|==
literal|0
operator|||
name|delta
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|delta
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|-
name|td
operator|->
name|tt_start_slot
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|5
condition|)
block|{
comment|/* missed it */
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|dwc_otg_host_rate_check
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
comment|/* allocate a new channel */
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_START
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
comment|/* set toggle, if any */
if|if
condition|(
name|td
operator|->
name|set_toggle
condition|)
block|{
name|td
operator|->
name|set_toggle
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|send_isoc_pkt
label|:
comment|/* Isochronous OUT transfers don't have any ACKs */
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_TX_WAIT_ISOC
expr_stmt|;
name|td
operator|->
name|hcsplt
operator|&=
operator|~
name|HCSPLT_COMPSPLT
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
comment|/* get maximum transfer length */
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|HCSPLT_XACTLEN_BURST
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"TT overflow\n"
argument_list|)
expr_stmt|;
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
comment|/* Update transaction position */
name|td
operator|->
name|hcsplt
operator|&=
operator|~
name|HCSPLT_XACTPOS_MASK
expr_stmt|;
name|td
operator|->
name|hcsplt
operator||=
operator|(
name|HCSPLT_XACTPOS_ALL
operator|<<
name|HCSPLT_XACTPOS_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send one packet at a time */
name|count
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|remainder
operator|<
name|count
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|!=
literal|0
condition|)
block|{
name|td
operator|->
name|hcsplt
operator|&=
operator|~
name|HCSPLT_COMPSPLT
expr_stmt|;
comment|/* Wait for ACK/NAK/ERR from TT */
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_S_ANE
expr_stmt|;
comment|/* send one packet at a time */
name|count
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|remainder
operator|<
name|count
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Wait for ACK/NAK/STALL from device */
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_ANE
expr_stmt|;
comment|/* send one packet at a time */
name|count
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|remainder
operator|<
name|count
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
block|}
block|}
comment|/* check for High-Speed multi-packets */
if|if
condition|(
operator|(
name|td
operator|->
name|hcsplt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|td
operator|->
name|max_packet_count
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|npkt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|remainder
operator|>=
operator|(
literal|3
operator|*
name|td
operator|->
name|max_packet_size
operator|)
condition|)
name|td
operator|->
name|npkt
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|td
operator|->
name|remainder
operator|>=
operator|(
literal|2
operator|*
name|td
operator|->
name|max_packet_size
operator|)
condition|)
name|td
operator|->
name|npkt
operator|=
literal|2
expr_stmt|;
else|else
name|td
operator|->
name|npkt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|npkt
operator|>
name|td
operator|->
name|max_packet_count
condition|)
name|td
operator|->
name|npkt
operator|=
name|td
operator|->
name|max_packet_count
expr_stmt|;
name|td
operator|->
name|tt_xactpos
operator|=
literal|1
expr_stmt|;
comment|/* overload */
block|}
if|if
condition|(
name|td
operator|->
name|tt_xactpos
operator|==
name|td
operator|->
name|npkt
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|npkt
operator|==
literal|1
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|count
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|HCTSIZ_PID_DATA0
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|npkt
operator|==
literal|2
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|count
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|HCTSIZ_PID_DATA1
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|count
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|HCTSIZ_PID_DATA2
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|npkt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|count
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|HCTSIZ_PID_MDATA
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TODO: HCTSIZ_DOPNG */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|count
operator|<<
name|HCTSIZ_XFERSIZE_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|HCTSIZ_PKTCNT_SHIFT
operator|)
operator||
operator|(
name|td
operator|->
name|toggle
condition|?
operator|(
name|HCTSIZ_PID_DATA1
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
else|:
operator|(
name|HCTSIZ_PID_DATA0
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCSPLT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
name|hcchar
operator|=
name|td
operator|->
name|hcchar
expr_stmt|;
name|hcchar
operator|&=
operator|~
name|HCCHAR_EPDIR_IN
expr_stmt|;
comment|/* send after next SOF event */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_frame_num
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|hcchar
operator||=
name|HCCHAR_ODDFRM
expr_stmt|;
else|else
name|hcchar
operator|&=
operator|~
name|HCCHAR_ODDFRM
expr_stmt|;
comment|/* must enable before writing data to FIFO */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|channel
argument_list|)
argument_list|,
name|hcchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* clear topmost word before copy */
name|sc
operator|->
name|sc_tx_bounce_buffer
index|[
operator|(
name|count
operator|-
literal|1
operator|)
operator|/
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* copy out data */
name|usbd_copy_out
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_tx_bounce_buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* transfer data into FIFO */
name|bus_space_write_region_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|DOTG_DFIFO
argument_list|(
name|channel
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_tx_bounce_buffer
argument_list|,
operator|(
name|count
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* store number of bytes transmitted */
name|td
operator|->
name|tx_bytes
operator|=
name|count
expr_stmt|;
goto|goto
name|busy
goto|;
name|send_cpkt
label|:
comment|/* free existing channel, if any */
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|delta
operator|=
name|td
operator|->
name|tt_complete_slot
operator|-
name|sc
operator|->
name|sc_last_frame_num
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|==
literal|0
operator|||
name|delta
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|delta
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|-
name|td
operator|->
name|tt_start_slot
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|DWC_OTG_TT_SLOT_MAX
condition|)
block|{
comment|/* we missed the service interval */
if|if
condition|(
name|td
operator|->
name|ep_type
operator|!=
name|UE_ISOCHRONOUS
condition|)
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
comment|/* allocate a new channel */
if|if
condition|(
name|dwc_otg_host_channel_alloc
argument_list|(
name|sc
argument_list|,
name|td
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_PKT
expr_stmt|;
goto|goto
name|busy
goto|;
block|}
name|channel
operator|=
name|td
operator|->
name|channel
expr_stmt|;
name|td
operator|->
name|hcsplt
operator||=
name|HCSPLT_COMPSPLT
expr_stmt|;
name|td
operator|->
name|state
operator|=
name|DWC_CHAN_ST_WAIT_C_ANE
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCTSIZ
argument_list|(
name|channel
argument_list|)
argument_list|,
operator|(
name|HCTSIZ_PID_DATA0
operator|<<
name|HCTSIZ_PID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCSPLT
argument_list|(
name|channel
argument_list|)
argument_list|,
name|td
operator|->
name|hcsplt
argument_list|)
expr_stmt|;
name|hcchar
operator|=
name|td
operator|->
name|hcchar
expr_stmt|;
name|hcchar
operator|&=
operator|~
name|HCCHAR_EPDIR_IN
expr_stmt|;
comment|/* receive complete split ASAP */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_last_frame_num
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|hcchar
operator||=
name|HCCHAR_ODDFRM
expr_stmt|;
else|else
name|hcchar
operator|&=
operator|~
name|HCCHAR_ODDFRM
expr_stmt|;
comment|/* must enable channel before data can be received */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|channel
argument_list|)
argument_list|,
name|hcchar
argument_list|)
expr_stmt|;
comment|/* wait until next slot before trying complete split */
name|td
operator|->
name|tt_complete_slot
operator|=
name|sc
operator|->
name|sc_last_frame_num
operator|+
literal|1
expr_stmt|;
name|busy
label|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* busy */
name|complete
label|:
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_data_tx
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint32_t
name|max_buffer
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|uint32_t
name|fifo_left
decl_stmt|;
name|uint32_t
name|mpkt
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|to
decl_stmt|;
name|to
operator|=
literal|3
expr_stmt|;
comment|/* don't loop forever! */
name|max_buffer
operator|=
name|sc
operator|->
name|sc_hw_ep_profile
index|[
name|td
operator|->
name|ep_no
index|]
operator|.
name|max_buffer
expr_stmt|;
name|repeat
label|:
comment|/* check for for endpoint 0 data */
name|temp
operator|=
name|sc
operator|->
name|sc_last_rx_status
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|ep_no
operator|==
literal|0
operator|)
operator|&&
operator|(
name|temp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|temp
operator|&
name|GRXSTSRD_PKTSTS_MASK
operator|)
operator|!=
name|GRXSTSRD_STP_DATA
condition|)
block|{
comment|/* dump data - wrong direction */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The current transfer was cancelled 			 * by the USB Host: 			 */
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
block|}
block|}
comment|/* fill in more TX data, if possible */
if|if
condition|(
name|td
operator|->
name|tx_bytes
operator|!=
literal|0
condition|)
block|{
name|uint16_t
name|cpkt
decl_stmt|;
comment|/* check if packets have been transferred */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTSIZ
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get current packet number */
name|cpkt
operator|=
name|DXEPTSIZ_GET_NPKT
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpkt
operator|>=
name|td
operator|->
name|npkt
condition|)
block|{
name|fifo_left
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_buffer
operator|!=
literal|0
condition|)
block|{
name|fifo_left
operator|=
operator|(
name|td
operator|->
name|npkt
operator|-
name|cpkt
operator|)
operator|*
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|fifo_left
operator|>
name|max_buffer
condition|)
name|fifo_left
operator|=
name|max_buffer
expr_stmt|;
block|}
else|else
block|{
name|fifo_left
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
block|}
block|}
name|count
operator|=
name|td
operator|->
name|tx_bytes
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|fifo_left
condition|)
name|count
operator|=
name|fifo_left
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* clear topmost word before copy */
name|sc
operator|->
name|sc_tx_bounce_buffer
index|[
operator|(
name|count
operator|-
literal|1
operator|)
operator|/
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* copy out data */
name|usbd_copy_out
argument_list|(
name|td
operator|->
name|pc
argument_list|,
name|td
operator|->
name|offset
argument_list|,
name|sc
operator|->
name|sc_tx_bounce_buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* transfer data into FIFO */
name|bus_space_write_region_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|DOTG_DFIFO
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_tx_bounce_buffer
argument_list|,
operator|(
name|count
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|td
operator|->
name|tx_bytes
operator|-=
name|count
expr_stmt|;
name|td
operator|->
name|remainder
operator|-=
name|count
expr_stmt|;
name|td
operator|->
name|offset
operator|+=
name|count
expr_stmt|;
name|td
operator|->
name|npkt
operator|=
name|cpkt
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|tx_bytes
operator|!=
literal|0
condition|)
goto|goto
name|not_complete
goto|;
comment|/* check remainder */
if|if
condition|(
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
comment|/* else we need to transmit a short packet */
block|}
block|}
if|if
condition|(
operator|!
name|to
operator|--
condition|)
goto|goto
name|not_complete
goto|;
comment|/* check if not all packets have been transferred */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTSIZ
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DXEPTSIZ_GET_NPKT
argument_list|(
name|temp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"busy ep=%d npkt=%d DIEPTSIZ=0x%08x "
literal|"DIEPCTL=0x%08x\n"
argument_list|,
name|td
operator|->
name|ep_no
argument_list|,
name|DXEPTSIZ_GET_NPKT
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"rem=%u ep=%d\n"
argument_list|,
name|td
operator|->
name|remainder
argument_list|,
name|td
operator|->
name|ep_no
argument_list|)
expr_stmt|;
comment|/* try to optimise by sending more data */
if|if
condition|(
operator|(
name|max_buffer
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|td
operator|->
name|max_packet_size
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* send multiple packets at the same time */
name|mpkt
operator|=
name|max_buffer
operator|/
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|mpkt
operator|>
literal|0x3FE
condition|)
name|mpkt
operator|=
literal|0x3FE
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0x7FFFFF
condition|)
name|count
operator|=
literal|0x7FFFFF
operator|-
operator|(
literal|0x7FFFFF
operator|%
name|td
operator|->
name|max_packet_size
operator|)
expr_stmt|;
name|td
operator|->
name|npkt
operator|=
name|count
operator|/
name|td
operator|->
name|max_packet_size
expr_stmt|;
comment|/* 		 * NOTE: We could use 0x3FE instead of "mpkt" in the 		 * check below to get more throughput, but then we 		 * have a dependency towards non-generic chip features 		 * to disable the TX-FIFO-EMPTY interrupts on a per 		 * endpoint basis. Increase the maximum buffer size of 		 * the IN endpoint to increase the performance. 		 */
if|if
condition|(
name|td
operator|->
name|npkt
operator|>
name|mpkt
condition|)
block|{
name|td
operator|->
name|npkt
operator|=
name|mpkt
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|max_packet_size
operator|*
name|mpkt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
operator|(
name|count
operator|%
name|td
operator|->
name|max_packet_size
operator|)
condition|)
block|{
comment|/* we are transmitting a short packet */
name|td
operator|->
name|npkt
operator|++
expr_stmt|;
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* send one packet at a time */
name|mpkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|remainder
operator|<
name|count
condition|)
block|{
comment|/* we have a short packet */
name|td
operator|->
name|short_pkt
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
block|}
name|td
operator|->
name|npkt
operator|=
literal|1
expr_stmt|;
block|}
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTSIZ
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|DXEPTSIZ_SET_MULTI
argument_list|(
literal|1
argument_list|)
operator||
name|DXEPTSIZ_SET_NPKT
argument_list|(
name|td
operator|->
name|npkt
argument_list|)
operator||
name|DXEPTSIZ_SET_NBYTES
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make room for buffering */
name|td
operator|->
name|npkt
operator|+=
name|mpkt
expr_stmt|;
name|temp
operator|=
name|sc
operator|->
name|sc_in_ctl
index|[
name|td
operator|->
name|ep_no
index|]
expr_stmt|;
comment|/* must enable before writing data to FIFO */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|,
name|temp
operator||
name|DIEPCTL_EPENA
operator||
name|DIEPCTL_CNAK
argument_list|)
expr_stmt|;
name|td
operator|->
name|tx_bytes
operator|=
name|count
expr_stmt|;
comment|/* check remainder */
if|if
condition|(
name|td
operator|->
name|tx_bytes
operator|==
literal|0
operator|&&
name|td
operator|->
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|short_pkt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* complete */
comment|/* else we need to transmit a short packet */
block|}
goto|goto
name|repeat
goto|;
name|not_complete
label|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_data_tx_sync
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dwc_otg_td
modifier|*
name|td
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
comment|/* 	 * If all packets are transferred we are complete: 	 */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTSIZ
argument_list|(
name|td
operator|->
name|ep_no
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check that all packets have been transferred */
if|if
condition|(
name|DXEPTSIZ_GET_NPKT
argument_list|(
name|temp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"busy ep=%d\n"
argument_list|,
name|td
operator|->
name|ep_no
argument_list|)
expr_stmt|;
goto|goto
name|not_complete
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|not_complete
label|:
comment|/* we only want to know if there is a SETUP packet or free IN packet */
name|temp
operator|=
name|sc
operator|->
name|sc_last_rx_status
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|ep_no
operator|==
literal|0
operator|)
operator|&&
operator|(
name|temp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|temp
operator|&
name|GRXSTSRD_PKTSTS_MASK
operator|)
operator|==
name|GRXSTSRD_STP_DATA
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"faking complete\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Race condition: We are complete! 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* dump data - wrong direction */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not complete */
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_xfer_do_fifo
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|uint8_t
name|toggle
decl_stmt|;
name|uint8_t
name|tmr_val
decl_stmt|;
name|uint8_t
name|tmr_res
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
call|(
name|td
operator|->
name|func
call|)
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
condition|)
block|{
comment|/* operation in progress */
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|td
operator|->
name|error_any
condition|)
block|{
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|remainder
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We had a short transfer. If there is no alternate 			 * next, stop processing ! 			 */
if|if
condition|(
operator|!
name|td
operator|->
name|alt_next
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* 		 * Fetch the next transfer descriptor and transfer 		 * some flags to the next transfer descriptor 		 */
name|tmr_res
operator|=
name|td
operator|->
name|tmr_res
expr_stmt|;
name|tmr_val
operator|=
name|td
operator|->
name|tmr_val
expr_stmt|;
name|toggle
operator|=
name|td
operator|->
name|toggle
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
name|toggle
expr_stmt|;
comment|/* transfer toggle */
name|td
operator|->
name|tmr_res
operator|=
name|tmr_res
expr_stmt|;
name|td
operator|->
name|tmr_val
operator|=
name|tmr_val
expr_stmt|;
block|}
return|return;
name|done
label|:
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_xfer_complete
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_xfer_do_complete_locked
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
comment|/* compute all actual lengths */
name|dwc_otg_standard_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_timer
parameter_list|(
name|void
modifier|*
name|_sc
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|_sc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* increment timer value */
name|sc
operator|->
name|sc_tmr_val
operator|++
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
block|{
comment|/* reset NAK counter */
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* enable SOF interrupt, which will poll jobs */
name|dwc_otg_enable_sof_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_timer_active
condition|)
block|{
comment|/* restart timer */
name|usb_callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|,
name|hz
operator|/
operator|(
literal|1000
operator|/
name|DWC_OTG_HOST_TIMER_RATE
operator|)
argument_list|,
operator|&
name|dwc_otg_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_timer_start
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_timer_active
operator|!=
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_timer_active
operator|=
literal|1
expr_stmt|;
comment|/* restart timer */
name|usb_callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|,
name|hz
operator|/
operator|(
literal|1000
operator|/
name|DWC_OTG_HOST_TIMER_RATE
operator|)
argument_list|,
operator|&
name|dwc_otg_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_timer_stop
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_timer_active
operator|==
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_timer_active
operator|=
literal|0
expr_stmt|;
comment|/* stop timer */
name|usb_callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_host_channel_disable
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|x
parameter_list|)
block|{
name|uint32_t
name|hcchar
decl_stmt|;
name|hcchar
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable host channel, if any */
if|if
condition|(
name|hcchar
operator|&
operator|(
name|HCCHAR_CHENA
operator||
name|HCCHAR_CHDIS
operator|)
condition|)
block|{
comment|/* disable channel */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCCHAR
argument_list|(
name|x
argument_list|)
argument_list|,
name|HCCHAR_CHENA
operator||
name|HCCHAR_CHDIS
argument_list|)
expr_stmt|;
comment|/* wait for chip to get its brains in order */
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|=
literal|2
expr_stmt|;
block|}
comment|/* release TX FIFO usage, if any */
name|sc
operator|->
name|sc_tx_cur_p_level
operator|-=
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|tx_p_size
expr_stmt|;
name|sc
operator|->
name|sc_tx_cur_np_level
operator|-=
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|tx_np_size
expr_stmt|;
comment|/* don't release TX FIFO usage twice */
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|tx_p_size
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|tx_np_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|dwc_otg_compute_isoc_rx_tt_slot
parameter_list|(
name|struct
name|dwc_otg_tt_info
modifier|*
name|pinfo
parameter_list|)
block|{
if|if
condition|(
name|pinfo
operator|->
name|slot_index
operator|<
name|DWC_OTG_TT_SLOT_MAX
condition|)
name|pinfo
operator|->
name|slot_index
operator|++
expr_stmt|;
return|return
operator|(
name|pinfo
operator|->
name|slot_index
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|dwc_otg_update_host_transfer_schedule_locked
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|usb_xfer
argument_list|)
name|head
expr_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer_next
decl_stmt|;
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|uint16_t
name|slot
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HFNUM
argument_list|)
operator|&
name|DWC_OTG_FRAME_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_last_frame_num
operator|==
name|temp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_last_frame_num
operator|=
name|temp
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_host_ch_max
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|==
literal|0
condition|)
continue|continue;
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|wait_sof
operator|)
operator|==
literal|0
condition|)
name|dwc_otg_host_channel_disable
argument_list|(
name|sc
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* reset the schedule */
name|memset
argument_list|(
name|sc
operator|->
name|sc_tt_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tt_info
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_ISOCHRONOUS
condition|)
continue|continue;
comment|/* check for IN direction */
if|if
condition|(
operator|(
name|td
operator|->
name|hcchar
operator|&
name|HCCHAR_EPDIR_IN
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* execute more frames */
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|==
literal|0
operator|||
name|td
operator|->
name|tt_scheduled
operator|!=
literal|0
condition|)
continue|continue;
comment|/* compute slot */
name|slot
operator|=
name|dwc_otg_compute_isoc_rx_tt_slot
argument_list|(
name|sc
operator|->
name|sc_tt_info
operator|+
name|td
operator|->
name|tt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|>
literal|3
condition|)
block|{
comment|/*  				 * Not enough time to get complete 				 * split executed. 				 */
continue|continue;
block|}
comment|/* Delayed start */
name|td
operator|->
name|tt_start_slot
operator|=
name|temp
operator|+
name|slot
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_ISOCHRONOUS
condition|)
continue|continue;
comment|/* check for OUT direction */
if|if
condition|(
operator|(
name|td
operator|->
name|hcchar
operator|&
name|HCCHAR_EPDIR_IN
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* execute more frames */
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|==
literal|0
operator|||
name|td
operator|->
name|tt_scheduled
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Start ASAP */
name|td
operator|->
name|tt_start_slot
operator|=
name|temp
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_INTERRUPT
condition|)
continue|continue;
if|if
condition|(
name|td
operator|->
name|tt_scheduled
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dwc_otg_host_rate_check_interrupt
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* start ASAP */
name|td
operator|->
name|tt_start_slot
operator|=
name|temp
expr_stmt|;
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_CONTROL
operator|||
name|td
operator|->
name|did_nak
operator|>=
name|DWC_OTG_NAK_MAX
condition|)
block|{
continue|continue;
block|}
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|==
literal|0
operator|||
name|td
operator|->
name|tt_scheduled
operator|!=
literal|0
condition|)
continue|continue;
comment|/* start ASAP */
name|td
operator|->
name|tt_start_slot
operator|=
name|temp
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|temp
operator|&
literal|7
operator|)
operator|<
literal|6
condition|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_BULK
operator|||
name|td
operator|->
name|did_nak
operator|>=
name|DWC_OTG_NAK_MAX
condition|)
block|{
continue|continue;
block|}
name|sc
operator|->
name|sc_needsof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|hcsplt
operator|==
literal|0
operator|||
name|td
operator|->
name|tt_scheduled
operator|!=
literal|0
condition|)
continue|continue;
comment|/* start ASAP */
name|td
operator|->
name|tt_start_slot
operator|=
name|temp
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|1
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put TT transfers in execution order at the end */
name|TAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
operator|&
name|head
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
comment|/* move all TT transfers in front, keeping the current order */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|hcsplt
operator|==
literal|0
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
name|TAILQ_CONCAT
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
operator|&
name|head
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
comment|/* put non-TT BULK transfers last */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|,
argument|xfer_next
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|hcsplt
operator|!=
literal|0
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_BULK
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
name|TAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|intr_q
operator|.
name|head
argument_list|,
operator|&
name|head
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
literal|"SOF interrupt #%d, needsof=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|temp
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_needsof
argument_list|)
expr_stmt|;
comment|/* update SOF IRQ mask */
if|if
condition|(
name|sc
operator|->
name|sc_irq_mask
operator|&
name|GINTMSK_SOFMSK
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_needsof
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_irq_mask
operator|&=
operator|~
name|GINTMSK_SOFMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_needsof
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_irq_mask
operator||=
name|GINTMSK_SOFMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* clear need SOF flag */
name|sc
operator|->
name|sc_needsof
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_interrupt_poll_locked
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|got_rx_status
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|repeat
label|:
comment|/* get all channel interrupts */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_host_ch_max
condition|;
name|x
operator|++
control|)
block|{
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCINT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
name|HCINT_SOFTWARE_ONLY
expr_stmt|;
name|sc
operator|->
name|sc_chan_state
index|[
name|x
index|]
operator|.
name|hcint
operator||=
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|GINTSTS_RXFLVL
condition|)
block|{
comment|/* pop current status */
name|sc
operator|->
name|sc_last_rx_status
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRXSTSPD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|!=
literal|0
condition|)
block|{
name|uint8_t
name|ep_no
decl_stmt|;
name|temp
operator|=
name|sc
operator|->
name|sc_last_rx_status
operator|&
name|GRXSTSRD_PKTSTS_MASK
expr_stmt|;
comment|/* non-data messages we simply skip */
if|if
condition|(
name|temp
operator|!=
name|GRXSTSRD_STP_DATA
operator|&&
name|temp
operator|!=
name|GRXSTSRD_OUT_DATA
condition|)
block|{
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|temp
operator|=
name|GRXSTSRD_BCNT_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
name|ep_no
operator|=
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
comment|/* receive data, if any */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Reading %d bytes from ep %d\n"
argument_list|,
name|temp
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
name|bus_space_read_region_4
argument_list|(
name|sc
operator|->
name|sc_io_tag
argument_list|,
name|sc
operator|->
name|sc_io_hdl
argument_list|,
name|DOTG_DFIFO
argument_list|(
name|ep_no
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_rx_bounce_buffer
argument_list|,
operator|(
name|temp
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should dump the data */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_active_rx_ep
operator|&
operator|(
literal|1U
operator|<<
name|ep_no
operator|)
operator|)
condition|)
block|{
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|got_rx_status
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"RX status = 0x%08x: ch=%d pid=%d bytes=%d sts=%d\n"
argument_list|,
name|sc
operator|->
name|sc_last_rx_status
argument_list|,
name|ep_no
argument_list|,
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|>>
literal|15
operator|)
operator|&
literal|3
argument_list|,
name|GRXSTSRD_BCNT_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
argument_list|,
operator|(
name|sc
operator|->
name|sc_last_rx_status
operator|>>
literal|17
operator|)
operator|&
literal|15
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|got_rx_status
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint8_t
name|ep_no
decl_stmt|;
name|ep_no
operator|=
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
expr_stmt|;
comment|/* check if we should dump the data */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_active_rx_ep
operator|&
operator|(
literal|1U
operator|<<
name|ep_no
operator|)
operator|)
condition|)
block|{
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|got_rx_status
operator|=
literal|1
expr_stmt|;
block|}
comment|/* execute FIFOs */
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
name|dwc_otg_xfer_do_fifo
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_rx_status
condition|)
block|{
comment|/* check if data was consumed */
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|==
literal|0
condition|)
goto|goto
name|repeat
goto|;
comment|/* disable RX FIFO level interrupt */
name|sc
operator|->
name|sc_irq_mask
operator|&=
operator|~
name|GINTMSK_RXFLVLMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_xfer_complete
operator|==
literal|0
condition|)
block|{
comment|/* update host transfer schedule, so that new transfers can be issued */
if|if
condition|(
name|dwc_otg_update_host_transfer_schedule_locked
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|repeat
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_interrupt_complete_locked
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|repeat
label|:
comment|/* scan for completion events */
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|dwc_otg_xfer_do_complete_locked
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
condition|)
goto|goto
name|repeat
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_vbus_interrupt
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|is_on
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"vbus = %u\n"
argument_list|,
name|is_on
argument_list|)
expr_stmt|;
comment|/* 	 * If the USB host mode is forced, then assume VBUS is always 	 * present else rely on the input to this function: 	 */
if|if
condition|(
operator|(
name|is_on
operator|!=
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_HOST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|=
literal|1
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|dwc_otg_filter_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|retval
init|=
name|FILTER_HANDLED
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* read and clear interrupt status */
name|status
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTSTS
argument_list|)
expr_stmt|;
comment|/* clear interrupts we are handling here */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTSTS
argument_list|,
name|status
operator|&
operator|~
name|DWC_OTG_MSK_GINT_THREAD_IRQ
argument_list|)
expr_stmt|;
comment|/* check for USB state change interrupts */
if|if
condition|(
operator|(
name|status
operator|&
name|DWC_OTG_MSK_GINT_THREAD_IRQ
operator|)
operator|!=
literal|0
condition|)
name|retval
operator|=
name|FILTER_SCHEDULE_THREAD
expr_stmt|;
comment|/* clear all IN endpoint interrupts */
if|if
condition|(
name|status
operator|&
name|GINTSTS_IEPINT
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_dev_in_ep_max
condition|;
name|x
operator|++
control|)
block|{
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPINT
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|DIEPMSK_XFERCOMPLMSK
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|DIEPMSK_XFERCOMPLMSK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* poll FIFOs, if any */
name|dwc_otg_interrupt_poll_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfer_complete
operator|!=
literal|0
condition|)
name|retval
operator|=
name|FILTER_SCHEDULE_THREAD
expr_stmt|;
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dwc_otg_interrupt
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* read and clear interrupt status */
name|status
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTSTS
argument_list|)
expr_stmt|;
comment|/* clear interrupts we are handling here */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTSTS
argument_list|,
name|status
operator|&
name|DWC_OTG_MSK_GINT_THREAD_IRQ
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|14
argument_list|,
literal|"GINTSTS=0x%08x HAINT=0x%08x HFNUM=0x%08x\n"
argument_list|,
name|status
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HAINT
argument_list|)
argument_list|,
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HFNUM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|GINTSTS_USBRST
condition|)
block|{
comment|/* set correct state */
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
comment|/* Disable SOF interrupt */
name|sc
operator|->
name|sc_irq_mask
operator|&=
operator|~
name|GINTMSK_SOFMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* check for any bus state change interrupts */
if|if
condition|(
name|status
operator|&
name|GINTSTS_ENUMDONE
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"end of reset\n"
argument_list|)
expr_stmt|;
comment|/* set correct state */
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_low_speed
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|1
expr_stmt|;
comment|/* reset FIFOs */
operator|(
name|void
operator|)
name|dwc_otg_init_fifo
argument_list|(
name|sc
argument_list|,
name|DWC_MODE_DEVICE
argument_list|)
expr_stmt|;
comment|/* reset function address */
name|dwc_otg_set_address
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* figure out enumeration speed */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|DSTS_ENUMSPD_GET
argument_list|(
name|temp
argument_list|)
operator|==
name|DSTS_ENUMSPD_HI
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Disable resume and SOF interrupt, and enable 		 * suspend and RX frame interrupt: 		 */
name|sc
operator|->
name|sc_irq_mask
operator|&=
operator|~
operator|(
name|GINTMSK_WKUPINTMSK
operator||
name|GINTMSK_SOFMSK
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_irq_mask
operator||=
name|GINTMSK_USBSUSPMSK
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|GINTSTS_PRTINT
condition|)
block|{
name|uint32_t
name|hprt
decl_stmt|;
name|hprt
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|)
expr_stmt|;
comment|/* clear change bits */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
operator|(
name|hprt
operator|&
operator|(
name|HPRT_PRTPWR
operator||
name|HPRT_PRTENCHNG
operator||
name|HPRT_PRTCONNDET
operator||
name|HPRT_PRTOVRCURRCHNG
operator|)
operator|)
operator||
name|sc
operator|->
name|sc_hprt_val
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|12
argument_list|,
literal|"GINTSTS=0x%08x, HPRT=0x%08x\n"
argument_list|,
name|status
argument_list|,
name|hprt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTCONNSTS
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTENCHNG
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|change_enabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTENA
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTOVRCURRCHNG
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|change_over_current
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTOVRCURRACT
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|port_over_current
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|port_over_current
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTPWR
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|hprt
operator|&
name|HPRT_PRTSPD_MASK
operator|)
operator|>>
name|HPRT_PRTSPD_SHIFT
operator|)
operator|==
name|HPRT_PRTSPD_LOW
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|status_low_speed
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|status_low_speed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|hprt
operator|&
name|HPRT_PRTSPD_MASK
operator|)
operator|>>
name|HPRT_PRTSPD_SHIFT
operator|)
operator|==
name|HPRT_PRTSPD_HIGH
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTCONNDET
condition|)
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hprt
operator|&
name|HPRT_PRTSUSP
condition|)
name|dwc_otg_suspend_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|dwc_otg_resume_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* complete root HUB interrupt endpoint */
name|dwc_otg_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* update host frame interval */
name|dwc_otg_update_host_frame_interval
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If resume and suspend is set at the same time we interpret 	 * that like RESUME. Resume is set when there is at least 3 	 * milliseconds of inactivity on the USB BUS. 	 */
if|if
condition|(
name|status
operator|&
name|GINTSTS_WKUPINT
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"resume interrupt\n"
argument_list|)
expr_stmt|;
name|dwc_otg_resume_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|GINTSTS_USBSUSP
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"suspend interrupt\n"
argument_list|)
expr_stmt|;
name|dwc_otg_suspend_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* check VBUS */
if|if
condition|(
name|status
operator|&
operator|(
name|GINTSTS_USBSUSP
operator||
name|GINTSTS_USBRST
operator||
name|GINTMSK_OTGINTMSK
operator||
name|GINTSTS_SESSREQINT
operator|)
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GOTGCTL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"GOTGCTL=0x%08x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|dwc_otg_vbus_interrupt
argument_list|(
name|sc
argument_list|,
operator|(
name|temp
operator|&
operator|(
name|GOTGCTL_ASESVLD
operator||
name|GOTGCTL_BSESVLD
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_xfer_complete
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_xfer_complete
operator|=
literal|0
expr_stmt|;
comment|/* complete FIFOs, if any */
name|dwc_otg_interrupt_complete_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|==
literal|0
condition|)
block|{
comment|/* update host transfer schedule, so that new transfers can be issued */
if|if
condition|(
name|dwc_otg_update_host_transfer_schedule_locked
argument_list|(
name|sc
argument_list|)
condition|)
name|dwc_otg_interrupt_poll_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_setup_standard_chain_sub
parameter_list|(
name|struct
name|dwc_otg_std_temp
modifier|*
name|temp
parameter_list|)
block|{
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
comment|/* get current Transfer Descriptor */
name|td
operator|=
name|temp
operator|->
name|td_next
expr_stmt|;
name|temp
operator|->
name|td
operator|=
name|td
expr_stmt|;
comment|/* prepare for next TD */
name|temp
operator|->
name|td_next
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* fill out the Transfer Descriptor */
name|td
operator|->
name|func
operator|=
name|temp
operator|->
name|func
expr_stmt|;
name|td
operator|->
name|pc
operator|=
name|temp
operator|->
name|pc
expr_stmt|;
name|td
operator|->
name|offset
operator|=
name|temp
operator|->
name|offset
expr_stmt|;
name|td
operator|->
name|remainder
operator|=
name|temp
operator|->
name|len
expr_stmt|;
name|td
operator|->
name|tx_bytes
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|error_any
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|error_stall
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|npkt
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|did_stall
operator|=
name|temp
operator|->
name|did_stall
expr_stmt|;
name|td
operator|->
name|short_pkt
operator|=
name|temp
operator|->
name|short_pkt
expr_stmt|;
name|td
operator|->
name|alt_next
operator|=
name|temp
operator|->
name|setup_alt_next
expr_stmt|;
name|td
operator|->
name|set_toggle
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|got_short
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|channel
operator|=
name|DWC_OTG_MAX_CHANNELS
expr_stmt|;
name|td
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|errcnt
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tt_scheduled
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tt_xactpos
operator|=
name|HCSPLT_XACTPOS_BEGIN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_setup_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|dwc_otg_std_temp
name|temp
decl_stmt|;
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint8_t
name|need_sync
decl_stmt|;
name|uint8_t
name|is_host
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"addr=%d endpt=%d sumlen=%d speed=%d\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|,
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
literal|0
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
comment|/* setup temp */
name|temp
operator|.
name|pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td_next
operator|=
name|xfer
operator|->
name|td_start
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
expr_stmt|;
name|temp
operator|.
name|did_stall
operator|=
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_stall
expr_stmt|;
name|is_host
operator|=
operator|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
operator|)
expr_stmt|;
comment|/* check if we should prepend a setup message */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
if|if
condition|(
name|is_host
condition|)
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_host_setup_tx
expr_stmt|;
else|else
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_setup_rx
expr_stmt|;
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|short_pkt
operator|=
name|temp
operator|.
name|len
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for last frame */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|1
condition|)
block|{
comment|/* no STATUS stage yet, SETUP is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
name|dwc_otg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|endpointno
operator|&
name|UE_DIR_IN
condition|)
block|{
if|if
condition|(
name|is_host
condition|)
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_host_data_rx
expr_stmt|;
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_tx
expr_stmt|;
name|need_sync
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_host
condition|)
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_host_data_tx
expr_stmt|;
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_rx
expr_stmt|;
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* setup "pc" pointer */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
block|}
else|else
block|{
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* DATA0 / DATA1 message */
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temp
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|/* make sure that we send an USB packet */
name|temp
operator|.
name|short_pkt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regular data transfer */
name|temp
operator|.
name|short_pkt
operator|=
operator|(
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|dwc_otg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|temp
operator|.
name|offset
operator|+=
name|temp
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* get next Page Cache pointer */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* always setup a valid "pc" pointer for status and sync */
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|short_pkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
comment|/* check if we need to sync */
if|if
condition|(
name|need_sync
condition|)
block|{
comment|/* we need a SYNC point after TX */
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_tx_sync
expr_stmt|;
name|dwc_otg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should append a status stage */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* 			 * Send a DATA1 message and invert the current 			 * endpoint direction. 			 */
if|if
condition|(
name|xfer
operator|->
name|endpointno
operator|&
name|UE_DIR_IN
condition|)
block|{
if|if
condition|(
name|is_host
condition|)
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_host_data_tx
expr_stmt|;
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_rx
expr_stmt|;
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_host
condition|)
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_host_data_rx
expr_stmt|;
name|need_sync
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_tx
expr_stmt|;
name|need_sync
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dwc_otg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* data toggle should be DATA1 */
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
name|td
operator|->
name|set_toggle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_sync
condition|)
block|{
comment|/* we need a SYNC point after TX */
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_tx_sync
expr_stmt|;
name|dwc_otg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* check if we need to sync */
if|if
condition|(
name|need_sync
condition|)
block|{
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|short_pkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
comment|/* we need a SYNC point after TX */
name|temp
operator|.
name|func
operator|=
operator|&
name|dwc_otg_data_tx_sync
expr_stmt|;
name|dwc_otg_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* must have at least one frame! */
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td
expr_stmt|;
if|if
condition|(
name|is_host
condition|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|hcchar
decl_stmt|;
name|uint32_t
name|hcsplt
decl_stmt|;
name|sc
operator|=
name|DWC_OTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* get first again */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|td
operator|->
name|toggle
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|hcchar
operator|=
operator|(
name|xfer
operator|->
name|address
operator|<<
name|HCCHAR_DEVADDR_SHIFT
operator|)
operator||
operator|(
operator|(
name|xfer
operator|->
name|endpointno
operator|&
name|UE_ADDR
operator|)
operator|<<
name|HCCHAR_EPNUM_SHIFT
operator|)
operator||
operator|(
name|xfer
operator|->
name|max_packet_size
operator|<<
name|HCCHAR_MPS_SHIFT
operator|)
operator||
name|HCCHAR_CHENA
expr_stmt|;
comment|/* 		 * We are not always able to meet the timing 		 * requirements of the USB interrupt endpoint's 		 * complete split token, when doing transfers going 		 * via a transaction translator. Use the CONTROL 		 * transfer type instead of the INTERRUPT transfer 		 * type in general, as a means to workaround 		 * that. This trick should work for both FULL and LOW 		 * speed USB traffic going through a TT. For non-TT 		 * traffic it works aswell. The reason for using 		 * CONTROL type instead of BULK is that some TTs might 		 * reject LOW speed BULK traffic. 		 */
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_INTERRUPT
condition|)
name|hcchar
operator||=
operator|(
name|UE_CONTROL
operator|<<
name|HCCHAR_EPTYPE_SHIFT
operator|)
expr_stmt|;
else|else
name|hcchar
operator||=
operator|(
name|td
operator|->
name|ep_type
operator|<<
name|HCCHAR_EPTYPE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
operator|==
name|USB_SPEED_LOW
condition|)
name|hcchar
operator||=
name|HCCHAR_LSPDDEV
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|hcchar
operator||=
name|HCCHAR_EPDIR_IN
expr_stmt|;
switch|switch
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_FULL
case|:
case|case
name|USB_SPEED_LOW
case|:
comment|/* check if root HUB port is running High Speed */
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|parent_hs_hub
operator|!=
name|NULL
condition|)
block|{
name|hcsplt
operator|=
name|HCSPLT_SPLTENA
operator||
operator|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|hs_port_no
operator|<<
name|HCSPLT_PRTADDR_SHIFT
operator|)
operator||
operator|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|hs_hub_addr
operator|<<
name|HCSPLT_HUBADDR_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hcsplt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_INTERRUPT
condition|)
block|{
name|uint32_t
name|ival
decl_stmt|;
name|ival
operator|=
name|xfer
operator|->
name|interval
operator|/
name|DWC_OTG_HOST_TIMER_RATE
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
name|ival
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ival
operator|>
literal|127
condition|)
name|ival
operator|=
literal|127
expr_stmt|;
name|td
operator|->
name|tmr_val
operator|=
name|sc
operator|->
name|sc_tmr_val
operator|+
name|ival
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
name|ival
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|USB_SPEED_HIGH
case|:
name|hcsplt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_INTERRUPT
condition|)
block|{
name|uint32_t
name|ival
decl_stmt|;
if|#
directive|if
literal|0
block|hcchar |= ((xfer->max_packet_count& 3)<< HCCHAR_MC_SHIFT);
endif|#
directive|endif
name|ival
operator|=
name|xfer
operator|->
name|interval
operator|/
name|DWC_OTG_HOST_TIMER_RATE
expr_stmt|;
if|if
condition|(
name|ival
operator|==
literal|0
condition|)
name|ival
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ival
operator|>
literal|127
condition|)
name|ival
operator|=
literal|127
expr_stmt|;
name|td
operator|->
name|tmr_val
operator|=
name|sc
operator|->
name|sc_tmr_val
operator|+
name|ival
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
name|ival
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|ep_type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|hcchar
operator||=
operator|(
operator|(
name|xfer
operator|->
name|max_packet_count
operator|&
literal|3
operator|)
operator|<<
name|HCCHAR_MC_SHIFT
operator|)
expr_stmt|;
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
literal|1
operator|<<
name|usbd_xfer_get_fps_shift
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|hcsplt
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tmr_val
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|tmr_res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* store configuration in all TD's */
while|while
condition|(
literal|1
condition|)
block|{
name|td
operator|->
name|hcchar
operator|=
name|hcchar
expr_stmt|;
name|td
operator|->
name|hcsplt
operator|=
name|hcsplt
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
break|break;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"xfer=%p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* transfer is transferred */
name|dwc_otg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_start_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|xroot
decl_stmt|;
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Poll one time in device mode, which will turn on the 	 * endpoint interrupts. Else wait for SOF interrupt in host 	 * mode. 	 */
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|!=
literal|0
condition|)
block|{
name|dwc_otg_xfer_do_fifo
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwc_otg_xfer_do_complete_locked
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* put transfer on interrupt queue */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* start timeout, if any */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|!=
literal|0
condition|)
block|{
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|dwc_otg_timeout
argument_list|,
name|xfer
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* enable SOF interrupt, if any */
name|dwc_otg_enable_sof_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|ep_type
operator|!=
name|UE_BULK
condition|)
goto|goto
name|done
goto|;
name|xroot
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
comment|/* 	 * Optimise the ping-pong effect by waking up other BULK 	 * transfers belonging to the same device group: 	 */
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|->
name|ep_type
operator|!=
name|UE_BULK
operator|||
name|xfer
operator|->
name|xroot
operator|!=
name|xroot
condition|)
continue|continue;
comment|/* reset NAK counter */
name|td
operator|->
name|did_nak
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_root_intr
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* set port bit */
name|sc
operator|->
name|sc_hub_idata
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* we only have one port */
name|uhub_root_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_hub_idata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|dwc_otg_standard_done_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|usb_error_t
name|error
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
do|do
block|{
name|len
operator|=
name|td
operator|->
name|remainder
expr_stmt|;
comment|/* store last data toggle */
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
operator|=
name|td
operator|->
name|toggle
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* 			 * Verify the length and subtract 			 * the remainder from "frlengths[]": 			 */
if|if
condition|(
name|len
operator|>
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
condition|)
block|{
name|td
operator|->
name|error_any
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|-=
name|len
expr_stmt|;
block|}
block|}
comment|/* Check for transfer error */
if|if
condition|(
name|td
operator|->
name|error_any
condition|)
block|{
comment|/* the transfer is finished */
name|error
operator|=
operator|(
name|td
operator|->
name|error_stall
condition|?
name|USB_ERR_STALLED
else|:
name|USB_ERR_IOERROR
operator|)
expr_stmt|;
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for short transfer */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
comment|/* follow alt next */
if|if
condition|(
name|td
operator|->
name|alt_next
condition|)
block|{
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
else|else
block|{
name|td
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* this USB frame is complete */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_standard_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
comment|/* reset scanner */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|err
operator|=
name|dwc_otg_standard_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
while|while
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|err
operator|=
name|dwc_otg_standard_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|err
operator|=
name|dwc_otg_standard_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|dwc_otg_device_done
argument_list|(
name|xfer
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	dwc_otg_device_done  *  * NOTE: this function can be called more than one time on the  * same USB transfer!  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|dwc_otg_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"xfer=%p, endpoint=%p, error=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* Interrupts are cleared by the interrupt handler */
block|}
else|else
block|{
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|dwc_otg_host_channel_free
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* dequeue transfer and start next transfer */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_xfer_stall
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|dwc_otg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_STALLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_set_stall
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|,
name|uint8_t
modifier|*
name|did_stall
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint8_t
name|ep_no
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* check mode */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* not supported */
return|return;
block|}
name|sc
operator|=
name|DWC_OTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* get endpoint address */
name|ep_no
operator|=
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"endpoint=0x%x\n"
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_no
operator|&
name|UE_DIR_IN
condition|)
block|{
name|reg
operator|=
name|DOTG_DIEPCTL
argument_list|(
name|ep_no
operator|&
name|UE_ADDR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|sc
operator|->
name|sc_in_ctl
index|[
name|ep_no
operator|&
name|UE_ADDR
index|]
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|DOTG_DOEPCTL
argument_list|(
name|ep_no
operator|&
name|UE_ADDR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|sc
operator|->
name|sc_out_ctl
index|[
name|ep_no
operator|&
name|UE_ADDR
index|]
expr_stmt|;
block|}
comment|/* disable and stall endpoint */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|temp
operator||
name|DOEPCTL_EPDIS
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|temp
operator||
name|DOEPCTL_STALL
argument_list|)
expr_stmt|;
comment|/* clear active OUT ep */
if|if
condition|(
operator|!
operator|(
name|ep_no
operator|&
name|UE_DIR_IN
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_active_rx_ep
operator|&=
operator|~
operator|(
literal|1U
operator|<<
operator|(
name|ep_no
operator|&
name|UE_ADDR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_last_rx_status
operator|!=
literal|0
operator|&&
operator|(
name|ep_no
operator|&
name|UE_ADDR
operator|)
operator|==
name|GRXSTSRD_CHNUM_GET
argument_list|(
name|sc
operator|->
name|sc_last_rx_status
argument_list|)
condition|)
block|{
comment|/* dump data */
name|dwc_otg_common_rx_ack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* poll interrupt */
name|dwc_otg_interrupt_poll_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwc_otg_interrupt_complete_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_clear_stall_sub_locked
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mps
parameter_list|,
name|uint8_t
name|ep_no
parameter_list|,
name|uint8_t
name|ep_type
parameter_list|,
name|uint8_t
name|ep_dir
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
if|if
condition|(
name|ep_type
operator|==
name|UE_CONTROL
condition|)
block|{
comment|/* clearing stall is not needed */
return|return;
block|}
if|if
condition|(
name|ep_dir
condition|)
block|{
name|reg
operator|=
name|DOTG_DIEPCTL
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|DOTG_DOEPCTL
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active_rx_ep
operator||=
operator|(
literal|1U
operator|<<
name|ep_no
operator|)
expr_stmt|;
block|}
comment|/* round up and mask away the multiplier count */
name|mps
operator|=
operator|(
name|mps
operator|+
literal|3
operator|)
operator|&
literal|0x7FC
expr_stmt|;
if|if
condition|(
name|ep_type
operator|==
name|UE_BULK
condition|)
block|{
name|temp
operator|=
name|DIEPCTL_EPTYPE_SET
argument_list|(
name|DIEPCTL_EPTYPE_BULK
argument_list|)
operator||
name|DIEPCTL_USBACTEP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep_type
operator|==
name|UE_INTERRUPT
condition|)
block|{
name|temp
operator|=
name|DIEPCTL_EPTYPE_SET
argument_list|(
name|DIEPCTL_EPTYPE_INTERRUPT
argument_list|)
operator||
name|DIEPCTL_USBACTEP
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|DIEPCTL_EPTYPE_SET
argument_list|(
name|DIEPCTL_EPTYPE_ISOC
argument_list|)
operator||
name|DIEPCTL_USBACTEP
expr_stmt|;
block|}
name|temp
operator||=
name|DIEPCTL_MPS_SET
argument_list|(
name|mps
argument_list|)
expr_stmt|;
name|temp
operator||=
name|DIEPCTL_TXFNUM_SET
argument_list|(
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_dir
condition|)
name|sc
operator|->
name|sc_in_ctl
index|[
name|ep_no
index|]
operator|=
name|temp
expr_stmt|;
else|else
name|sc
operator|->
name|sc_out_ctl
index|[
name|ep_no
index|]
operator|=
name|temp
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|temp
operator||
name|DOEPCTL_EPDIS
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|temp
operator||
name|DOEPCTL_SETD0PID
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|temp
operator||
name|DIEPCTL_SNAK
argument_list|)
expr_stmt|;
comment|/* we only reset the transmit FIFO */
if|if
condition|(
name|ep_dir
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRSTCTL
argument_list|,
name|GRSTCTL_TXFIFO
argument_list|(
name|ep_no
argument_list|)
operator||
name|GRSTCTL_TXFFLSH
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPTSIZ
argument_list|(
name|ep_no
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* poll interrupt */
name|dwc_otg_interrupt_poll_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwc_otg_interrupt_complete_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_clear_stall
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"endpoint=%p\n"
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|udev
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* check mode */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* not supported */
return|return;
block|}
comment|/* get softc */
name|sc
operator|=
name|DWC_OTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* get endpoint descriptor */
name|ed
operator|=
name|ep
operator|->
name|edesc
expr_stmt|;
comment|/* reset endpoint */
name|dwc_otg_clear_stall_sub_locked
argument_list|(
name|sc
argument_list|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|,
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|)
argument_list|,
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
argument_list|,
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_state_change
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
comment|/* check mode */
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* not supported */
return|return;
block|}
comment|/* get softc */
name|sc
operator|=
name|DWC_OTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* deactivate all other endpoint but the control endpoint */
if|if
condition|(
name|udev
operator|->
name|state
operator|==
name|USB_STATE_CONFIGURED
operator|||
name|udev
operator|->
name|state
operator|==
name|USB_STATE_ADDRESSED
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_dev_ep_max
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
name|sc
operator|->
name|sc_dev_in_ep_max
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
name|x
argument_list|)
argument_list|,
name|DIEPCTL_EPDIS
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPCTL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPCTL
argument_list|(
name|x
argument_list|)
argument_list|,
name|DOEPCTL_EPDIS
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPCTL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dwc_otg_init
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
comment|/* set up the bus structure */
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USB_REV_2_0
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|dwc_otg_bus_methods
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* turn on clocks */
name|dwc_otg_clocks_on
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GSNPSID
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Version = 0x%08x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* disconnect */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|DCTL_SFTDISCON
argument_list|)
expr_stmt|;
comment|/* wait for host to detect disconnect */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|32
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GRSTCTL
argument_list|,
name|GRSTCTL_CSFTRST
argument_list|)
expr_stmt|;
comment|/* wait a little bit for block to reset */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|128
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_mode
condition|)
block|{
case|case
name|DWC_MODE_DEVICE
case|:
name|temp
operator|=
name|GUSBCFG_FORCEDEVMODE
expr_stmt|;
break|break;
case|case
name|DWC_MODE_HOST
case|:
name|temp
operator|=
name|GUSBCFG_FORCEHOSTMODE
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* select HSIC or non-HSIC mode */
if|if
condition|(
name|dwc_otg_use_hsic
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GUSBCFG
argument_list|,
name|GUSBCFG_PHYIF
operator||
name|GUSBCFG_TRD_TIM_SET
argument_list|(
literal|5
argument_list|)
operator||
name|temp
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GOTGCTL
argument_list|,
literal|0x000000EC
argument_list|)
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GLPMCFG
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GLPMCFG
argument_list|,
name|temp
operator|&
operator|~
name|GLPMCFG_HSIC_CONN
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GLPMCFG
argument_list|,
name|temp
operator||
name|GLPMCFG_HSIC_CONN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GUSBCFG
argument_list|,
name|GUSBCFG_ULPI_UTMI_SEL
operator||
name|GUSBCFG_TRD_TIM_SET
argument_list|(
literal|5
argument_list|)
operator||
name|temp
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GOTGCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GLPMCFG
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GLPMCFG
argument_list|,
name|temp
operator|&
operator|~
name|GLPMCFG_HSIC_CONN
argument_list|)
expr_stmt|;
block|}
comment|/* clear global nak */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|DCTL_CGOUTNAK
operator||
name|DCTL_CGNPINNAK
argument_list|)
expr_stmt|;
comment|/* disable USB port */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_PCGCCTL
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* wait 10ms */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* enable USB port */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_PCGCCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait 10ms */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* pull up D+ */
name|dwc_otg_pull_up
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GHWCFG3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fifo_size
operator|=
literal|4
operator|*
name|GHWCFG3_DFIFODEPTH_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GHWCFG2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev_ep_max
operator|=
name|GHWCFG2_NUMDEVEPS_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dev_ep_max
operator|>
name|DWC_OTG_MAX_ENDPOINTS
condition|)
name|sc
operator|->
name|sc_dev_ep_max
operator|=
name|DWC_OTG_MAX_ENDPOINTS
expr_stmt|;
name|sc
operator|->
name|sc_host_ch_max
operator|=
name|GHWCFG2_NUMHSTCHNL_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_host_ch_max
operator|>
name|DWC_OTG_MAX_CHANNELS
condition|)
name|sc
operator|->
name|sc_host_ch_max
operator|=
name|DWC_OTG_MAX_CHANNELS
expr_stmt|;
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GHWCFG4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev_in_ep_max
operator|=
name|GHWCFG4_NUM_IN_EP_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Total FIFO size = %d bytes, Device EPs = %d/%d Host CHs = %d\n"
argument_list|,
name|sc
operator|->
name|sc_fifo_size
argument_list|,
name|sc
operator|->
name|sc_dev_ep_max
argument_list|,
name|sc
operator|->
name|sc_dev_in_ep_max
argument_list|,
name|sc
operator|->
name|sc_host_ch_max
argument_list|)
expr_stmt|;
comment|/* setup FIFO */
if|if
condition|(
name|dwc_otg_init_fifo
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_mode
argument_list|)
condition|)
block|{
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* enable interrupts */
name|sc
operator|->
name|sc_irq_mask
operator|=
name|DWC_OTG_MSK_GINT_ENABLED
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GINTMSK
argument_list|,
name|sc
operator|->
name|sc_irq_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_OTG
operator|||
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_DEVICE
condition|)
block|{
comment|/* enable all endpoint interrupts */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GHWCFG2
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|GHWCFG2_MPI
condition|)
block|{
name|uint8_t
name|x
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"Multi Process Interrupts\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_dev_in_ep_max
condition|;
name|x
operator|++
control|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPEACHINTMSK
argument_list|(
name|x
argument_list|)
argument_list|,
name|DIEPMSK_XFERCOMPLMSK
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPEACHINTMSK
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DEACHINTMSK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DIEPMSK
argument_list|,
name|DIEPMSK_XFERCOMPLMSK
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DOEPMSK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DAINTMSK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_OTG
operator|||
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_HOST
condition|)
block|{
comment|/* setup clocks */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCFG
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|HCFG_FSLSSUPP
operator||
name|HCFG_FSLSPCLKSEL_MASK
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
literal|1
operator|<<
name|HCFG_FSLSPCLKSEL_SHIFT
operator|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HCFG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* only enable global IRQ */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GAHBCFG
argument_list|,
name|GAHBCFG_GLBLINTRMSK
argument_list|)
expr_stmt|;
comment|/* turn off clocks */
name|dwc_otg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* read initial VBUS state */
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GOTGCTL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"GOTCTL=0x%08x\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|dwc_otg_vbus_interrupt
argument_list|(
name|sc
argument_list|,
operator|(
name|temp
operator|&
operator|(
name|GOTGCTL_ASESVLD
operator||
name|GOTGCTL_BSESVLD
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* catch any lost interrupts */
name|dwc_otg_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
name|void
name|dwc_otg_uninit
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* stop host timer */
name|dwc_otg_timer_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set disconnect */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DCTL
argument_list|,
name|DCTL_SFTDISCON
argument_list|)
expr_stmt|;
comment|/* turn off global IRQ */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_GAHBCFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|1
expr_stmt|;
name|dwc_otg_pull_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwc_otg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|usb_callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_suspend
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_resume
parameter_list|(
name|struct
name|dwc_otg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|USB_BUS_SPIN_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|dwc_otg_interrupt_poll_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwc_otg_interrupt_complete_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|==
literal|0
condition|)
block|{
comment|/* update host transfer schedule, so that new transfers can be issued */
if|if
condition|(
name|dwc_otg_update_host_transfer_schedule_locked
argument_list|(
name|sc
argument_list|)
condition|)
name|dwc_otg_interrupt_poll_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|USB_BUS_SPIN_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * DWC OTG bulk support  * DWC OTG control support  * DWC OTG interrupt support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|dwc_otg_device_non_isoc_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_non_isoc_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|dwc_otg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_non_isoc_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_non_isoc_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* setup TDs */
name|dwc_otg_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|dwc_otg_start_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_pipe_methods
name|dwc_otg_device_non_isoc_methods
init|=
block|{
operator|.
name|open
operator|=
name|dwc_otg_device_non_isoc_open
block|,
operator|.
name|close
operator|=
name|dwc_otg_device_non_isoc_close
block|,
operator|.
name|enter
operator|=
name|dwc_otg_device_non_isoc_enter
block|,
operator|.
name|start
operator|=
name|dwc_otg_device_non_isoc_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * DWC OTG full speed isochronous support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|dwc_otg_device_isoc_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_isoc_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|dwc_otg_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_isoc_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_isoc_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|msframes
decl_stmt|;
name|uint32_t
name|framenum
decl_stmt|;
name|uint8_t
name|shift
init|=
name|usbd_xfer_get_fps_shift
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"xfer=%p next=%d nframes=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_HOST
condition|)
block|{
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HFNUM
argument_list|)
expr_stmt|;
comment|/* get the current frame index */
name|framenum
operator|=
operator|(
name|temp
operator|&
name|HFNUM_FRNUM_MASK
operator|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|DWC_OTG_READ_4
argument_list|(
name|sc
argument_list|,
name|DOTG_DSTS
argument_list|)
expr_stmt|;
comment|/* get the current frame index */
name|framenum
operator|=
name|DSTS_SOFFN_GET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|parent_hs_hub
operator|!=
name|NULL
condition|)
name|framenum
operator|/=
literal|8
expr_stmt|;
name|framenum
operator|&=
name|DWC_OTG_FRAME_MASK
expr_stmt|;
comment|/* 	 * Compute number of milliseconds worth of data traffic for 	 * this USB transfer: 	 */
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
name|msframes
operator|=
operator|(
operator|(
name|xfer
operator|->
name|nframes
operator|<<
name|shift
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
else|else
name|msframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
comment|/* 	 * check if the frame index is within the window where the frames 	 * will be inserted 	 */
name|temp
operator|=
operator|(
name|framenum
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|)
operator|&
name|DWC_OTG_FRAME_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
operator|<
name|msframes
operator|)
condition|)
block|{
comment|/* 		 * If there is data underflow or the pipe queue is 		 * empty we schedule the transfer a few frames ahead 		 * of the current frame position. Else two isochronous 		 * transfers might overlap. 		 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|framenum
operator|+
literal|3
operator|)
operator|&
name|DWC_OTG_FRAME_MASK
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * compute how many milliseconds the insertion is ahead of the 	 * current frame position: 	 */
name|temp
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|framenum
operator|)
operator|&
name|DWC_OTG_FRAME_MASK
expr_stmt|;
comment|/* 	 * pre-compute when the isochronous transfer will be finished: 	 */
name|xfer
operator|->
name|isoc_time_complete
operator|=
name|usb_isoc_time_expand
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|framenum
argument_list|)
operator|+
name|temp
operator|+
name|msframes
expr_stmt|;
comment|/* setup TDs */
name|dwc_otg_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* compute frame number for next insertion */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|+=
name|msframes
expr_stmt|;
comment|/* start TD chain */
name|dwc_otg_start_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_pipe_methods
name|dwc_otg_device_isoc_methods
init|=
block|{
operator|.
name|open
operator|=
name|dwc_otg_device_isoc_open
block|,
operator|.
name|close
operator|=
name|dwc_otg_device_isoc_close
block|,
operator|.
name|enter
operator|=
name|dwc_otg_device_isoc_enter
block|,
operator|.
name|start
operator|=
name|dwc_otg_device_isoc_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * DWC OTG root control support  *------------------------------------------------------------------------*  * Simulate a hardware HUB by handling all the necessary requests.  *------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_descriptor
name|dwc_otg_devd
init|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE
block|,
operator|.
name|bcdUSB
operator|=
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
operator|.
name|bDeviceClass
operator|=
name|UDCLASS_HUB
block|,
operator|.
name|bDeviceSubClass
operator|=
name|UDSUBCLASS_HUB
block|,
operator|.
name|bDeviceProtocol
operator|=
name|UDPROTO_HSHUBSTT
block|,
operator|.
name|bMaxPacketSize
operator|=
literal|64
block|,
operator|.
name|bcdDevice
operator|=
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
operator|.
name|iManufacturer
operator|=
literal|1
block|,
operator|.
name|iProduct
operator|=
literal|2
block|,
operator|.
name|bNumConfigurations
operator|=
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|dwc_otg_config_desc
name|dwc_otg_confd
init|=
block|{
operator|.
name|confd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_CONFIG
block|,
operator|.
name|wTotalLength
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_confd
argument_list|)
block|,
operator|.
name|bNumInterface
operator|=
literal|1
block|,
operator|.
name|bConfigurationValue
operator|=
literal|1
block|,
operator|.
name|iConfiguration
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
name|UC_SELF_POWERED
block|,
operator|.
name|bMaxPower
operator|=
literal|0
block|, 	}
block|,
operator|.
name|ifcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_interface_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
block|,
operator|.
name|bNumEndpoints
operator|=
literal|1
block|,
operator|.
name|bInterfaceClass
operator|=
name|UICLASS_HUB
block|,
operator|.
name|bInterfaceSubClass
operator|=
name|UISUBCLASS_HUB
block|,
operator|.
name|bInterfaceProtocol
operator|=
literal|0
block|, 	}
block|,
operator|.
name|endpd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_endpoint_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
block|,
operator|.
name|bEndpointAddress
operator|=
operator|(
name|UE_DIR_IN
operator||
name|DWC_OTG_INTR_ENDPT
operator|)
block|,
operator|.
name|bmAttributes
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
literal|8
block|,
operator|.
name|bInterval
operator|=
literal|255
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HSETW
parameter_list|(
name|ptr
parameter_list|,
name|val
parameter_list|)
value|ptr = { (uint8_t)(val), (uint8_t)((val)>> 8) }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hub_descriptor_min
name|dwc_otg_hubd
init|=
block|{
operator|.
name|bDescLength
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_hubd
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_HUB
block|,
operator|.
name|bNbrPorts
operator|=
literal|1
block|,
name|HSETW
argument_list|(
operator|.
name|wHubCharacteristics
argument_list|,
operator|(
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
operator|)
argument_list|)
block|,
operator|.
name|bPwrOn2PwrGood
operator|=
literal|50
block|,
operator|.
name|bHubContrCurrent
operator|=
literal|0
block|,
operator|.
name|DeviceRemovable
operator|=
block|{
literal|0
block|}
block|,
comment|/* port is removable */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STRING_VENDOR
define|\
value|"D\0W\0C\0O\0T\0G"
end_define

begin_define
define|#
directive|define
name|STRING_PRODUCT
define|\
value|"O\0T\0G\0 \0R\0o\0o\0t\0 \0H\0U\0B"
end_define

begin_expr_stmt
name|USB_MAKE_STRING_DESC
argument_list|(
name|STRING_VENDOR
argument_list|,
name|dwc_otg_vendor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|USB_MAKE_STRING_DESC
argument_list|(
name|STRING_PRODUCT
argument_list|,
name|dwc_otg_product
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|usb_error_t
name|dwc_otg_roothub_exec
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plength
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* buffer reset */
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_hub_temp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
comment|/* demultiplex the control request */
switch|switch
condition|(
name|req
operator|->
name|bmRequestType
condition|)
block|{
case|case
name|UT_READ_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_DESCRIPTOR
case|:
goto|goto
name|tr_handle_get_descriptor
goto|;
case|case
name|UR_GET_CONFIG
case|:
goto|goto
name|tr_handle_get_config
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_SET_ADDRESS
case|:
goto|goto
name|tr_handle_set_address
goto|;
case|case
name|UR_SET_CONFIG
case|:
goto|goto
name|tr_handle_set_config
goto|;
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
case|case
name|UR_SET_DESCRIPTOR
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
case|case
name|UR_SET_FEATURE
case|:
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_ENDPOINT
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_CLEAR_FEATURE
case|:
switch|switch
condition|(
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
condition|)
block|{
case|case
name|UF_ENDPOINT_HALT
case|:
goto|goto
name|tr_handle_clear_halt
goto|;
case|case
name|UF_DEVICE_REMOTE_WAKEUP
case|:
goto|goto
name|tr_handle_clear_wakeup
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UR_SET_FEATURE
case|:
switch|switch
condition|(
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
condition|)
block|{
case|case
name|UF_ENDPOINT_HALT
case|:
goto|goto
name|tr_handle_set_halt
goto|;
case|case
name|UF_DEVICE_REMOTE_WAKEUP
case|:
goto|goto
name|tr_handle_set_wakeup
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UR_SYNCH_FRAME
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_ENDPOINT
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_ep_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_INTERFACE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_SET_INTERFACE
case|:
goto|goto
name|tr_handle_set_interface
goto|;
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_valid
goto|;
comment|/* nop */
case|case
name|UR_SET_FEATURE
case|:
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_INTERFACE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_INTERFACE
case|:
goto|goto
name|tr_handle_get_interface
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_iface_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_CLASS_INTERFACE
case|:
case|case
name|UT_WRITE_VENDOR_INTERFACE
case|:
comment|/* XXX forward */
break|break;
case|case
name|UT_READ_CLASS_INTERFACE
case|:
case|case
name|UT_READ_VENDOR_INTERFACE
case|:
comment|/* XXX forward */
break|break;
case|case
name|UT_WRITE_CLASS_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_valid
goto|;
case|case
name|UR_SET_DESCRIPTOR
case|:
case|case
name|UR_SET_FEATURE
case|:
break|break;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_WRITE_CLASS_OTHER
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_CLEAR_FEATURE
case|:
goto|goto
name|tr_handle_clear_port_feature
goto|;
case|case
name|UR_SET_FEATURE
case|:
goto|goto
name|tr_handle_set_port_feature
goto|;
case|case
name|UR_CLEAR_TT_BUFFER
case|:
case|case
name|UR_RESET_TT
case|:
case|case
name|UR_STOP_TT
case|:
goto|goto
name|tr_valid
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_CLASS_OTHER
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_TT_STATE
case|:
goto|goto
name|tr_handle_get_tt_state
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_port_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
case|case
name|UT_READ_CLASS_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_DESCRIPTOR
case|:
goto|goto
name|tr_handle_get_class_descriptor
goto|;
case|case
name|UR_GET_STATUS
case|:
goto|goto
name|tr_handle_get_class_status
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
break|break;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_descriptor
label|:
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_devd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|dwc_otg_devd
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_confd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|dwc_otg_confd
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_STRING
case|:
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|usb_string_lang_en
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|usb_string_lang_en
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
literal|1
case|:
comment|/* Vendor */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_vendor
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|dwc_otg_vendor
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
literal|2
case|:
comment|/* Product */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_product
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|dwc_otg_product
expr_stmt|;
goto|goto
name|tr_valid
goto|;
default|default:
break|break;
block|}
break|break;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
goto|goto
name|tr_stalled
goto|;
name|tr_handle_get_config
label|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_status
label|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_address
label|:
if|if
condition|(
name|value
operator|&
literal|0xFF00
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|sc
operator|->
name|sc_rt_addr
operator|=
name|value
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_config
label|:
if|if
condition|(
name|value
operator|>=
literal|2
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_interface
label|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_tt_state
label|:
name|tr_handle_get_class_status
label|:
name|tr_handle_get_iface_status
label|:
name|tr_handle_get_ep_status
label|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|wValue
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_halt
label|:
name|tr_handle_set_interface
label|:
name|tr_handle_set_wakeup
label|:
name|tr_handle_clear_wakeup
label|:
name|tr_handle_clear_halt
label|:
goto|goto
name|tr_valid
goto|;
name|tr_handle_clear_port_feature
label|:
if|if
condition|(
name|index
operator|!=
literal|1
condition|)
goto|goto
name|tr_stalled
goto|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_CLEAR_PORT_FEATURE on port %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_SUSPEND
case|:
name|dwc_otg_wakeup_peer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_ENABLE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|==
literal|0
condition|)
block|{
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
operator||
name|HPRT_PRTENA
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|change_reset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|change_enabled
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|change_over_current
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
case|case
name|UHF_PORT_INDICATOR
case|:
comment|/* nops */
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_HOST
operator|||
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_OTG
condition|)
block|{
name|sc
operator|->
name|sc_hprt_val
operator|=
literal|0
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|HPRT_PRTENA
argument_list|)
expr_stmt|;
block|}
name|dwc_otg_pull_down
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dwc_otg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
comment|/* clear connect change flag */
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|tr_valid
goto|;
name|tr_handle_set_port_feature
label|:
if|if
condition|(
name|index
operator|!=
literal|1
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_SET_PORT_FEATURE\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|==
literal|0
condition|)
block|{
comment|/* set suspend BIT */
name|sc
operator|->
name|sc_hprt_val
operator||=
name|HPRT_PRTSUSP
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
argument_list|)
expr_stmt|;
comment|/* generate HUB suspend event */
name|dwc_otg_suspend_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UHF_PORT_RESET
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"PORT RESET\n"
argument_list|)
expr_stmt|;
comment|/* enable PORT reset */
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
operator||
name|HPRT_PRTRST
argument_list|)
expr_stmt|;
comment|/* Wait 62.5ms for reset to complete */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|16
argument_list|)
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
argument_list|)
expr_stmt|;
comment|/* Wait 62.5ms for reset to complete */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|16
argument_list|)
expr_stmt|;
comment|/* reset FIFOs */
operator|(
name|void
operator|)
name|dwc_otg_init_fifo
argument_list|(
name|sc
argument_list|,
name|DWC_MODE_HOST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|.
name|change_reset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
block|}
break|break;
case|case
name|UHF_PORT_TEST
case|:
case|case
name|UHF_PORT_INDICATOR
case|:
comment|/* nops */
break|break;
case|case
name|UHF_PORT_POWER
case|:
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_HOST
operator|||
name|sc
operator|->
name|sc_mode
operator|==
name|DWC_MODE_OTG
condition|)
block|{
name|sc
operator|->
name|sc_hprt_val
operator||=
name|HPRT_PRTPWR
expr_stmt|;
name|DWC_OTG_WRITE_4
argument_list|(
name|sc
argument_list|,
name|DOTG_HPRT
argument_list|,
name|sc
operator|->
name|sc_hprt_val
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_port_status
label|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_GET_PORT_STATUS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|!=
literal|1
condition|)
goto|goto
name|tr_stalled
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
condition|)
name|dwc_otg_clocks_on
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|dwc_otg_clocks_off
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Select Device Side Mode */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_device_mode
condition|)
block|{
name|value
operator|=
name|UPS_PORT_MODE_DEVICE
expr_stmt|;
name|dwc_otg_timer_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|dwc_otg_timer_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_high_speed
condition|)
name|value
operator||=
name|UPS_HIGH_SPEED
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_low_speed
condition|)
name|value
operator||=
name|UPS_LOW_SPEED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|port_powered
condition|)
name|value
operator||=
name|UPS_PORT_POWER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|port_enabled
condition|)
name|value
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|port_over_current
condition|)
name|value
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_vbus
operator|&&
name|sc
operator|->
name|sc_flags
operator|.
name|status_bus_reset
condition|)
name|value
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|status_suspend
condition|)
name|value
operator||=
name|UPS_SUSPEND
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|ps
operator|.
name|wPortStatus
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|change_connect
condition|)
name|value
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|change_suspend
condition|)
name|value
operator||=
name|UPS_C_SUSPEND
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|change_reset
condition|)
name|value
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|.
name|change_over_current
condition|)
name|value
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|ps
operator|.
name|wPortChange
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_temp
operator|.
name|ps
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_handle_get_class_descriptor
label|:
if|if
condition|(
name|value
operator|&
literal|0xFF
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|dwc_otg_hubd
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dwc_otg_hubd
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_stalled
label|:
name|err
operator|=
name|USB_ERR_STALLED
expr_stmt|;
name|tr_valid
label|:
name|done
label|:
operator|*
name|plength
operator|=
name|len
expr_stmt|;
operator|*
name|pptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_xfer_setup
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|last_obj
decl_stmt|;
name|uint32_t
name|ntd
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint8_t
name|ep_no
decl_stmt|;
name|uint8_t
name|ep_type
decl_stmt|;
name|xfer
operator|=
name|parm
operator|->
name|curr_xfer
expr_stmt|;
comment|/* 	 * NOTE: This driver does not use any of the parameters that 	 * are computed from the following values. Just set some 	 * reasonable dummies: 	 */
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x500
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|3
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
literal|3
operator|*
literal|0x500
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* 	 * compute maximum number of TDs 	 */
name|ep_type
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
name|ep_type
operator|==
name|UE_CONTROL
condition|)
block|{
name|ntd
operator|=
name|xfer
operator|->
name|nframes
operator|+
literal|1
comment|/* STATUS */
operator|+
literal|1
comment|/* SYNC 1 */
operator|+
literal|1
comment|/* SYNC 2 */
operator|+
literal|1
comment|/* SYNC 3 */
expr_stmt|;
block|}
else|else
block|{
name|ntd
operator|=
name|xfer
operator|->
name|nframes
operator|+
literal|1
comment|/* SYNC */
expr_stmt|;
block|}
comment|/* 	 * check if "usbd_transfer_setup_sub" set an error 	 */
if|if
condition|(
name|parm
operator|->
name|err
condition|)
return|return;
comment|/* 	 * allocate transfer descriptors 	 */
name|last_obj
operator|=
name|NULL
expr_stmt|;
name|ep_no
operator|=
name|xfer
operator|->
name|endpointno
operator|&
name|UE_ADDR
expr_stmt|;
comment|/* 	 * Check for a valid endpoint profile in USB device mode: 	 */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
decl_stmt|;
name|dwc_otg_get_hw_ep_profile
argument_list|(
name|parm
operator|->
name|udev
argument_list|,
operator|&
name|pf
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
return|return;
block|}
block|}
comment|/* align data */
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|ntd
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|dwc_otg_td
modifier|*
name|td
decl_stmt|;
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
name|td
operator|=
name|USB_ADD_BYTES
argument_list|(
name|parm
operator|->
name|buf
argument_list|,
name|parm
operator|->
name|size
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* compute shared bandwidth resource index for TT */
if|if
condition|(
name|parm
operator|->
name|udev
operator|->
name|parent_hs_hub
operator|!=
name|NULL
operator|&&
name|parm
operator|->
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_HIGH
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|udev
operator|->
name|parent_hs_hub
operator|->
name|ddesc
operator|.
name|bDeviceProtocol
operator|==
name|UDPROTO_HSHUBMTT
condition|)
name|td
operator|->
name|tt_index
operator|=
name|parm
operator|->
name|udev
operator|->
name|device_index
expr_stmt|;
else|else
name|td
operator|->
name|tt_index
operator|=
name|parm
operator|->
name|udev
operator|->
name|parent_hs_hub
operator|->
name|device_index
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|tt_index
operator|=
name|parm
operator|->
name|udev
operator|->
name|device_index
expr_stmt|;
block|}
comment|/* init TD */
name|td
operator|->
name|max_packet_size
operator|=
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
name|td
operator|->
name|max_packet_count
operator|=
name|xfer
operator|->
name|max_packet_count
expr_stmt|;
name|td
operator|->
name|ep_no
operator|=
name|ep_no
expr_stmt|;
name|td
operator|->
name|ep_type
operator|=
name|ep_type
expr_stmt|;
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
block|}
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|td
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|td_start
index|[
literal|0
index|]
operator|=
name|last_obj
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_xfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_ep_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"endpoint=%p, addr=%d, endpt=%d, mode=%d (%d,%d)\n"
argument_list|,
name|ep
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|usb_mode
argument_list|,
name|sc
operator|->
name|sc_rt_addr
argument_list|,
name|udev
operator|->
name|device_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|device_index
operator|!=
name|sc
operator|->
name|sc_rt_addr
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
if|if
condition|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_FULL
operator|&&
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_HIGH
condition|)
block|{
comment|/* not supported */
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
if|if
condition|(
operator|(
name|UGETW
argument_list|(
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
operator|>>
literal|11
operator|)
operator|&
literal|3
condition|)
block|{
comment|/* high bandwidth endpoint - not tested */
name|DPRINTF
argument_list|(
literal|"High Bandwidth Endpoint - not tested\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|UE_ISOCHRONOUS
condition|)
name|ep
operator|->
name|methods
operator|=
operator|&
name|dwc_otg_device_isoc_methods
expr_stmt|;
else|else
name|ep
operator|->
name|methods
operator|=
operator|&
name|dwc_otg_device_non_isoc_methods
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_set_hw_power_sleep
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint32_t
name|state
parameter_list|)
block|{
name|struct
name|dwc_otg_softc
modifier|*
name|sc
init|=
name|DWC_OTG_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|USB_HW_POWER_SUSPEND
case|:
name|dwc_otg_suspend
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_HW_POWER_SHUTDOWN
case|:
name|dwc_otg_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_HW_POWER_RESUME
case|:
name|dwc_otg_resume
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_get_dma_delay
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint32_t
modifier|*
name|pus
parameter_list|)
block|{
comment|/* DMA delay - wait until any use of memory is finished */
operator|*
name|pus
operator|=
operator|(
literal|2125
operator|)
expr_stmt|;
comment|/* microseconds */
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_resume
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* poll all transfers again to restart resumed ones */
name|dwc_otg_do_poll
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwc_otg_device_suspend
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_bus_methods
name|dwc_otg_bus_methods
init|=
block|{
operator|.
name|endpoint_init
operator|=
operator|&
name|dwc_otg_ep_init
block|,
operator|.
name|xfer_setup
operator|=
operator|&
name|dwc_otg_xfer_setup
block|,
operator|.
name|xfer_unsetup
operator|=
operator|&
name|dwc_otg_xfer_unsetup
block|,
operator|.
name|get_hw_ep_profile
operator|=
operator|&
name|dwc_otg_get_hw_ep_profile
block|,
operator|.
name|xfer_stall
operator|=
operator|&
name|dwc_otg_xfer_stall
block|,
operator|.
name|set_stall
operator|=
operator|&
name|dwc_otg_set_stall
block|,
operator|.
name|clear_stall
operator|=
operator|&
name|dwc_otg_clear_stall
block|,
operator|.
name|roothub_exec
operator|=
operator|&
name|dwc_otg_roothub_exec
block|,
operator|.
name|xfer_poll
operator|=
operator|&
name|dwc_otg_do_poll
block|,
operator|.
name|device_state_change
operator|=
operator|&
name|dwc_otg_device_state_change
block|,
operator|.
name|set_hw_power_sleep
operator|=
operator|&
name|dwc_otg_set_hw_power_sleep
block|,
operator|.
name|get_dma_delay
operator|=
operator|&
name|dwc_otg_get_dma_delay
block|,
operator|.
name|device_resume
operator|=
operator|&
name|dwc_otg_device_resume
block|,
operator|.
name|device_suspend
operator|=
operator|&
name|dwc_otg_device_suspend
block|, }
decl_stmt|;
end_decl_stmt

end_unit

