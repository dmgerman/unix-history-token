begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  * Copyright (c) 1998 The NetBSD Foundation, Inc. All rights reserved.  * Copyright (c) 1998 Lennart Augustsson. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * USB Universal Host Controller driver.  * Handles e.g. PIIX3 and PIIX4.  *  * UHCI spec: http://developer.intel.com/design/USB/UHCI11D.htm  * USB spec:  http://www.usb.org/developers/docs/usbspec.zip  * PIIXn spec: ftp://download.intel.com/design/intarch/datashts/29055002.pdf  *             ftp://download.intel.com/design/intarch/datashts/29056201.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|uhcidebug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/uhci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/uhcireg.h>
end_include

begin_define
define|#
directive|define
name|alt_next
value|next
end_define

begin_define
define|#
directive|define
name|UHCI_BUS2SC
parameter_list|(
name|bus
parameter_list|)
define|\
value|((uhci_softc_t *)(((uint8_t *)(bus)) - \     ((uint8_t *)&(((uhci_softc_t *)0)->sc_bus))))
end_define

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_decl_stmt
specifier|static
name|int
name|uhcidebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uhcinoloop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uhci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB uhci"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uhci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uhcidebug
argument_list|,
literal|0
argument_list|,
literal|"uhci debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uhci
argument_list|,
name|OID_AUTO
argument_list|,
name|loop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uhcinoloop
argument_list|,
literal|0
argument_list|,
literal|"uhci noloop"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|uhci_dumpregs
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_dump_tds
parameter_list|(
name|uhci_td_t
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UBARR
parameter_list|(
name|sc
parameter_list|)
value|bus_space_barrier((sc)->sc_io_tag, (sc)->sc_io_hdl, 0, (sc)->sc_io_size, \ 			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
end_define

begin_define
define|#
directive|define
name|UWRITE1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { UBARR(sc); bus_space_write_1((sc)->sc_io_tag, (sc)->sc_io_hdl, (r), (x)); \  } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|UWRITE2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { UBARR(sc); bus_space_write_2((sc)->sc_io_tag, (sc)->sc_io_hdl, (r), (x)); \  } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|UWRITE4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|)
define|\
value|do { UBARR(sc); bus_space_write_4((sc)->sc_io_tag, (sc)->sc_io_hdl, (r), (x)); \  } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|UREAD1
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(UBARR(sc), bus_space_read_1((sc)->sc_io_tag, (sc)->sc_io_hdl, (r)))
end_define

begin_define
define|#
directive|define
name|UREAD2
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(UBARR(sc), bus_space_read_2((sc)->sc_io_tag, (sc)->sc_io_hdl, (r)))
end_define

begin_define
define|#
directive|define
name|UREAD4
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|(UBARR(sc), bus_space_read_4((sc)->sc_io_tag, (sc)->sc_io_hdl, (r)))
end_define

begin_define
define|#
directive|define
name|UHCICMD
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|)
value|UWRITE2(sc, UHCI_CMD, cmd)
end_define

begin_define
define|#
directive|define
name|UHCISTS
parameter_list|(
name|sc
parameter_list|)
value|UREAD2(sc, UHCI_STS)
end_define

begin_define
define|#
directive|define
name|UHCI_RESET_TIMEOUT
value|100
end_define

begin_comment
comment|/* ms, reset timeout */
end_comment

begin_define
define|#
directive|define
name|UHCI_INTR_ENDPT
value|1
end_define

begin_struct
struct|struct
name|uhci_mem_layout
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|usb_page_search
name|fix_res
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|buf_pc
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|fix_pc
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint16_t
name|max_frame_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uhci_std_temp
block|{
name|struct
name|uhci_mem_layout
name|ml
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_next
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|td_status
decl_stmt|;
name|uint32_t
name|td_token
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint16_t
name|max_frame_size
decl_stmt|;
name|uint8_t
name|shortpkt
decl_stmt|;
name|uint8_t
name|setup_alt_next
decl_stmt|;
name|uint8_t
name|last_frame
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|usb_bus_methods
name|uhci_bus_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|uhci_device_bulk_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|uhci_device_ctrl_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|uhci_device_intr_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|uhci_device_isoc_methods
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint8_t
name|uhci_restart
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_transfer_intr_enqueue
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|uhci_check_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uhci_root_intr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|uhci_iterate_hw_softc
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|usb_bus_mem_sub_cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|UHCI_FRAMELIST_COUNT
argument_list|,
name|UHCI_FRAMELIST_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ls_ctl_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ls_ctl_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|,
name|UHCI_QH_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|fs_ctl_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|fs_ctl_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|,
name|UHCI_QH_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|,
name|UHCI_QH_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|last_qh_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|last_qh_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|,
name|UHCI_QH_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|last_td_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|last_td_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_td_t
argument_list|)
argument_list|,
name|UHCI_TD_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|UHCI_VFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_start_pc
operator|+
name|i
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_start_pg
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_td_t
argument_list|)
argument_list|,
name|UHCI_TD_ALIGN
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|UHCI_IFRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|i
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pg
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|,
name|UHCI_QH_ALIGN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_mem_layout_init
parameter_list|(
name|struct
name|uhci_mem_layout
modifier|*
name|ml
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ml
operator|->
name|buf_pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|ml
operator|->
name|fix_pc
operator|=
name|xfer
operator|->
name|buf_fixup
expr_stmt|;
name|ml
operator|->
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|ml
operator|->
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_mem_layout_fixup
parameter_list|(
name|struct
name|uhci_mem_layout
modifier|*
name|ml
parameter_list|,
name|struct
name|uhci_td
modifier|*
name|td
parameter_list|)
block|{
name|usbd_get_page
argument_list|(
name|ml
operator|->
name|buf_pc
argument_list|,
name|ml
operator|->
name|buf_offset
argument_list|,
operator|&
name|ml
operator|->
name|buf_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml
operator|->
name|buf_res
operator|.
name|length
operator|<
name|td
operator|->
name|len
condition|)
block|{
comment|/* need to do a fixup */
name|usbd_get_page
argument_list|(
name|ml
operator|->
name|fix_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|ml
operator|->
name|fix_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_buffer
operator|=
name|htole32
argument_list|(
name|ml
operator|->
name|fix_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
comment|/* 	         * The UHCI driver cannot handle 	         * page crossings, so a fixup is 	         * needed: 	         * 	         *  +----+----+ - - - 	         *  | YYY|Y   | 	         *  +----+----+ - - - 	         *     \    \ 	         *      \    \ 	         *       +----+ 	         *       |YYYY|  (fixup) 	         *       +----+ 	         */
if|if
condition|(
operator|(
name|td
operator|->
name|td_token
operator|&
name|htole32
argument_list|(
name|UHCI_TD_PID
argument_list|)
operator|)
operator|==
name|htole32
argument_list|(
name|UHCI_TD_PID_IN
argument_list|)
condition|)
block|{
name|td
operator|->
name|fix_pc
operator|=
name|ml
operator|->
name|fix_pc
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|ml
operator|->
name|fix_pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|fix_pc
operator|=
name|NULL
expr_stmt|;
comment|/* copy data to fixup location */
name|usbd_copy_out
argument_list|(
name|ml
operator|->
name|buf_pc
argument_list|,
name|ml
operator|->
name|buf_offset
argument_list|,
name|ml
operator|->
name|fix_res
operator|.
name|buffer
argument_list|,
name|td
operator|->
name|len
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|ml
operator|->
name|fix_pc
argument_list|)
expr_stmt|;
block|}
comment|/* prepare next fixup */
name|ml
operator|->
name|fix_pc
operator|++
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_buffer
operator|=
name|htole32
argument_list|(
name|ml
operator|->
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|td
operator|->
name|fix_pc
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* prepare next data location */
name|ml
operator|->
name|buf_offset
operator|+=
name|td
operator|->
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return values:  * 0: Success  * Else: Failure  */
end_comment

begin_function
specifier|static
name|uint8_t
name|uhci_restart
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|&
name|UHCI_CMD_RS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Already started\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Restarting\n"
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* Reload fresh base address */
name|UWRITE4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Assume 64 byte packets at frame end and start HC controller: 	 */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
operator|(
name|UHCI_CMD_MAXP
operator||
name|UHCI_CMD_RS
operator|)
argument_list|)
expr_stmt|;
comment|/* wait 10 milliseconds */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* check that controller has started */
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"Failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uhci_reset
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|n
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"resetting the HC\n"
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* global reset */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_GRESET
argument_list|)
expr_stmt|;
comment|/* wait */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_BUS_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* terminate all transfers */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
comment|/* the reset bit goes low when the controller is done */
name|n
operator|=
name|UHCI_RESET_TIMEOUT
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* wait one millisecond */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
operator|&
name|UHCI_CMD_HCRESET
operator|)
condition|)
block|{
goto|goto
name|done_1
goto|;
block|}
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"controller did not reset\n"
argument_list|)
expr_stmt|;
name|done_1
label|:
name|n
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* wait one millisecond */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
comment|/* check if HC is stopped */
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_HCH
condition|)
block|{
goto|goto
name|done_2
goto|;
block|}
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"controller did not stop\n"
argument_list|)
expr_stmt|;
name|done_2
label|:
comment|/* reload the configuration */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|,
name|sc
operator|->
name|sc_saved_frnum
argument_list|)
expr_stmt|;
name|UWRITE1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|,
name|sc
operator|->
name|sc_saved_sof
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* stop root interrupt */
name|usb_callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_root_intr
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_start
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"enabling\n"
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|,
operator|(
name|UHCI_INTR_TOCRCIE
operator||
name|UHCI_INTR_RIE
operator||
name|UHCI_INTR_IOCE
operator||
name|UHCI_INTR_SPIE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhci_restart
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"cannot start HC controller\n"
argument_list|)
expr_stmt|;
block|}
comment|/* start root interrupt */
name|uhci_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|uhci_qh
modifier|*
name|uhci_init_qh
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|uhci_qh
modifier|*
name|qh
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|qh
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|qh
operator|->
name|qh_self
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
operator||
name|htole32
argument_list|(
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|qh
operator|->
name|page_cache
operator|=
name|pc
expr_stmt|;
return|return
operator|(
name|qh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|uhci_td
modifier|*
name|uhci_init_td
parameter_list|(
name|struct
name|usb_page_cache
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|struct
name|uhci_td
modifier|*
name|td
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
name|td
operator|->
name|td_self
operator|=
name|htole32
argument_list|(
name|buf_res
operator|.
name|physaddr
argument_list|)
operator||
name|htole32
argument_list|(
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
name|td
operator|->
name|page_cache
operator|=
name|pc
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
end_function

begin_function
name|usb_error_t
name|uhci_init
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|bit
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint16_t
name|y
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_root_intr
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
block|{
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_saved_sof
operator|=
literal|0x40
expr_stmt|;
comment|/* default value */
name|sc
operator|->
name|sc_saved_frnum
operator|=
literal|0
expr_stmt|;
comment|/* default frame number */
comment|/* 	 * Setup QH's 	 */
name|sc
operator|->
name|sc_ls_ctl_p_last
operator|=
name|uhci_init_qh
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|ls_ctl_start_pc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fs_ctl_p_last
operator|=
name|uhci_init_qh
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|fs_ctl_start_pc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bulk_p_last
operator|=
name|uhci_init_qh
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|bulk_start_pc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|sc->sc_reclaim_qh_p = 	    sc->sc_fs_ctl_p_last;
else|#
directive|else
comment|/* setup reclaim looping point */
name|sc
operator|->
name|sc_reclaim_qh_p
operator|=
name|sc
operator|->
name|sc_bulk_p_last
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_last_qh_p
operator|=
name|uhci_init_qh
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|last_qh_pc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_last_td_p
operator|=
name|uhci_init_td
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|last_td_pc
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|UHCI_VFRAMELIST_COUNT
condition|;
name|x
operator|++
control|)
block|{
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|x
index|]
operator|=
name|uhci_init_td
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_start_pc
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|UHCI_IFRAMELIST_COUNT
condition|;
name|x
operator|++
control|)
block|{
name|sc
operator|->
name|sc_intr_p_last
index|[
name|x
index|]
operator|=
name|uhci_init_qh
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * the QHs are arranged to give poll intervals that are 	 * powers of 2 times 1ms 	 */
name|bit
operator|=
name|UHCI_IFRAMELIST_COUNT
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|x
operator|=
name|bit
expr_stmt|;
while|while
condition|(
name|x
operator|&
name|bit
condition|)
block|{
name|uhci_qh_t
modifier|*
name|qh_x
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh_y
decl_stmt|;
name|y
operator|=
operator|(
name|x
operator|^
name|bit
operator|)
operator||
operator|(
name|bit
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* 			 * the next QH has half the poll interval 			 */
name|qh_x
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|x
index|]
expr_stmt|;
name|qh_y
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|y
index|]
expr_stmt|;
name|qh_x
operator|->
name|h_next
operator|=
name|NULL
expr_stmt|;
name|qh_x
operator|->
name|qh_h_next
operator|=
name|qh_y
operator|->
name|qh_self
expr_stmt|;
name|qh_x
operator|->
name|e_next
operator|=
name|NULL
expr_stmt|;
name|qh_x
operator|->
name|qh_e_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|uhci_qh_t
modifier|*
name|qh_ls
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh_intr
decl_stmt|;
name|qh_ls
operator|=
name|sc
operator|->
name|sc_ls_ctl_p_last
expr_stmt|;
name|qh_intr
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
literal|0
index|]
expr_stmt|;
comment|/* start QH for interrupt traffic */
name|qh_intr
operator|->
name|h_next
operator|=
name|qh_ls
expr_stmt|;
name|qh_intr
operator|->
name|qh_h_next
operator|=
name|qh_ls
operator|->
name|qh_self
expr_stmt|;
name|qh_intr
operator|->
name|e_next
operator|=
literal|0
expr_stmt|;
name|qh_intr
operator|->
name|qh_e_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|UHCI_VFRAMELIST_COUNT
condition|;
name|x
operator|++
control|)
block|{
name|uhci_td_t
modifier|*
name|td_x
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh_intr
decl_stmt|;
name|td_x
operator|=
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|x
index|]
expr_stmt|;
name|qh_intr
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|x
operator||
operator|(
name|UHCI_IFRAMELIST_COUNT
operator|/
literal|2
operator|)
index|]
expr_stmt|;
comment|/* start TD for isochronous traffic */
name|td_x
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|td_x
operator|->
name|td_next
operator|=
name|qh_intr
operator|->
name|qh_self
expr_stmt|;
name|td_x
operator|->
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_IOS
argument_list|)
expr_stmt|;
name|td_x
operator|->
name|td_token
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|td_x
operator|->
name|td_buffer
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|uhci_qh_t
modifier|*
name|qh_ls
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh_fs
decl_stmt|;
name|qh_ls
operator|=
name|sc
operator|->
name|sc_ls_ctl_p_last
expr_stmt|;
name|qh_fs
operator|=
name|sc
operator|->
name|sc_fs_ctl_p_last
expr_stmt|;
comment|/* start QH where low speed control traffic will be queued */
name|qh_ls
operator|->
name|h_next
operator|=
name|qh_fs
expr_stmt|;
name|qh_ls
operator|->
name|qh_h_next
operator|=
name|qh_fs
operator|->
name|qh_self
expr_stmt|;
name|qh_ls
operator|->
name|e_next
operator|=
literal|0
expr_stmt|;
name|qh_ls
operator|->
name|qh_e_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|uhci_qh_t
modifier|*
name|qh_ctl
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh_blk
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh_lst
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_lst
decl_stmt|;
name|qh_ctl
operator|=
name|sc
operator|->
name|sc_fs_ctl_p_last
expr_stmt|;
name|qh_blk
operator|=
name|sc
operator|->
name|sc_bulk_p_last
expr_stmt|;
comment|/* start QH where full speed control traffic will be queued */
name|qh_ctl
operator|->
name|h_next
operator|=
name|qh_blk
expr_stmt|;
name|qh_ctl
operator|->
name|qh_h_next
operator|=
name|qh_blk
operator|->
name|qh_self
expr_stmt|;
name|qh_ctl
operator|->
name|e_next
operator|=
literal|0
expr_stmt|;
name|qh_ctl
operator|->
name|qh_e_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|qh_lst
operator|=
name|sc
operator|->
name|sc_last_qh_p
expr_stmt|;
comment|/* start QH where bulk traffic will be queued */
name|qh_blk
operator|->
name|h_next
operator|=
name|qh_lst
expr_stmt|;
name|qh_blk
operator|->
name|qh_h_next
operator|=
name|qh_lst
operator|->
name|qh_self
expr_stmt|;
name|qh_blk
operator|->
name|e_next
operator|=
literal|0
expr_stmt|;
name|qh_blk
operator|->
name|qh_e_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|td_lst
operator|=
name|sc
operator|->
name|sc_last_td_p
expr_stmt|;
comment|/* end QH which is used for looping the QHs */
name|qh_lst
operator|->
name|h_next
operator|=
literal|0
expr_stmt|;
name|qh_lst
operator|->
name|qh_h_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
comment|/* end of QH chain */
name|qh_lst
operator|->
name|e_next
operator|=
name|td_lst
expr_stmt|;
name|qh_lst
operator|->
name|qh_e_next
operator|=
name|td_lst
operator|->
name|td_self
expr_stmt|;
comment|/* 		 * end TD which hangs from the last QH, to avoid a bug in the PIIX 		 * that makes it run berserk otherwise 		 */
name|td_lst
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|td_lst
operator|->
name|td_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|td_lst
operator|->
name|td_status
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* inactive */
name|td_lst
operator|->
name|td_token
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|td_lst
operator|->
name|td_buffer
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|uint32_t
modifier|*
name|pframes
decl_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|pframes
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* 		 * Setup UHCI framelist 		 * 		 * Execution order: 		 * 		 * pframes -> full speed isochronous -> interrupt QH's -> low 		 * speed control -> full speed control -> bulk transfers 		 * 		 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|UHCI_FRAMELIST_COUNT
condition|;
name|x
operator|++
control|)
block|{
name|pframes
index|[
name|x
index|]
operator|=
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|x
operator|%
name|UHCI_VFRAMELIST_COUNT
index|]
operator|->
name|td_self
expr_stmt|;
block|}
block|}
comment|/* flush all cache into memory */
name|usb_bus_mem_flush_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|uhci_iterate_hw_softc
argument_list|)
expr_stmt|;
comment|/* set up the bus struct */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|uhci_bus_methods
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* reset the controller */
name|uhci_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* start the controller */
name|uhci_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* catch lost interrupts */
name|uhci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NOTE: suspend/resume is called from  * interrupt context and cannot sleep!  */
end_comment

begin_function
name|void
name|uhci_suspend
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
block|{
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* save some state if BIOS doesn't */
name|sc
operator|->
name|sc_saved_frnum
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_saved_sof
operator|=
name|UREAD1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|)
expr_stmt|;
comment|/* stop the controller */
name|uhci_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* enter global suspend */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_EGSM
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_WAIT
argument_list|)
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uhci_resume
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* reset the controller */
name|uhci_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* force global resume */
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_FGR
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_DELAY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and start traffic again */
name|uhci_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|2
condition|)
block|{
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* catch lost interrupts */
name|uhci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function
specifier|static
name|void
name|uhci_dumpregs
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
literal|"flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_INTR
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
argument_list|,
name|UREAD4
argument_list|(
name|sc
argument_list|,
name|UHCI_FLBASEADDR
argument_list|)
argument_list|,
name|UREAD1
argument_list|(
name|sc
argument_list|,
name|UHCI_SOF
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|uhci_dump_td
parameter_list|(
name|uhci_td_t
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|td_next
decl_stmt|;
name|uint32_t
name|td_status
decl_stmt|;
name|uint32_t
name|td_token
decl_stmt|;
name|uint8_t
name|temp
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|p
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|td_next
operator|=
name|le32toh
argument_list|(
name|p
operator|->
name|td_next
argument_list|)
expr_stmt|;
name|td_status
operator|=
name|le32toh
argument_list|(
name|p
operator|->
name|td_status
argument_list|)
expr_stmt|;
name|td_token
operator|=
name|le32toh
argument_list|(
name|p
operator|->
name|td_token
argument_list|)
expr_stmt|;
comment|/* 	 * Check whether the link pointer in this TD marks the link pointer 	 * as end of queue: 	 */
name|temp
operator|=
operator|(
operator|(
name|td_next
operator|&
name|UHCI_PTR_T
operator|)
operator|||
operator|(
name|td_next
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"TD(%p) at 0x%08x = link=0x%08x status=0x%08x "
literal|"token=0x%08x buffer=0x%08x\n"
argument_list|,
name|p
argument_list|,
name|le32toh
argument_list|(
name|p
operator|->
name|td_self
argument_list|)
argument_list|,
name|td_next
argument_list|,
name|td_status
argument_list|,
name|td_token
argument_list|,
name|le32toh
argument_list|(
name|p
operator|->
name|td_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TD(%p) td_next=%s%s%s td_status=%s%s%s%s%s%s%s%s%s%s%s, errcnt=%d, actlen=%d pid=%02x,"
literal|"addr=%d,endpt=%d,D=%d,maxlen=%d\n"
argument_list|,
name|p
argument_list|,
operator|(
name|td_next
operator|&
literal|1
operator|)
condition|?
literal|"-T"
else|:
literal|""
argument_list|,
operator|(
name|td_next
operator|&
literal|2
operator|)
condition|?
literal|"-Q"
else|:
literal|""
argument_list|,
operator|(
name|td_next
operator|&
literal|4
operator|)
condition|?
literal|"-VF"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_BITSTUFF
operator|)
condition|?
literal|"-BITSTUFF"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_CRCTO
operator|)
condition|?
literal|"-CRCTO"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_NAK
operator|)
condition|?
literal|"-NAK"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_BABBLE
operator|)
condition|?
literal|"-BABBLE"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_DBUFFER
operator|)
condition|?
literal|"-DBUFFER"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_STALLED
operator|)
condition|?
literal|"-STALLED"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_ACTIVE
operator|)
condition|?
literal|"-ACTIVE"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_IOC
operator|)
condition|?
literal|"-IOC"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_IOS
operator|)
condition|?
literal|"-IOS"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_LS
operator|)
condition|?
literal|"-LS"
else|:
literal|""
argument_list|,
operator|(
name|td_status
operator|&
name|UHCI_TD_SPD
operator|)
condition|?
literal|"-SPD"
else|:
literal|""
argument_list|,
name|UHCI_TD_GET_ERRCNT
argument_list|(
name|td_status
argument_list|)
argument_list|,
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|td_status
argument_list|)
argument_list|,
name|UHCI_TD_GET_PID
argument_list|(
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_DEVADDR
argument_list|(
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_ENDPT
argument_list|(
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_DT
argument_list|(
name|td_token
argument_list|)
argument_list|,
name|UHCI_TD_GET_MAXLEN
argument_list|(
name|td_token
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|uhci_dump_qh
parameter_list|(
name|uhci_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uint8_t
name|temp
decl_stmt|;
name|uint32_t
name|qh_h_next
decl_stmt|;
name|uint32_t
name|qh_e_next
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|sqh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|qh_h_next
operator|=
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh_h_next
argument_list|)
expr_stmt|;
name|qh_e_next
operator|=
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh_e_next
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"QH(%p) at 0x%08x: h_next=0x%08x e_next=0x%08x\n"
argument_list|,
name|sqh
argument_list|,
name|le32toh
argument_list|(
name|sqh
operator|->
name|qh_self
argument_list|)
argument_list|,
name|qh_h_next
argument_list|,
name|qh_e_next
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
operator|(
operator|(
operator|(
name|sqh
operator|->
name|h_next
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|qh_h_next
operator|&
name|UHCI_PTR_T
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
operator|(
operator|(
name|sqh
operator|->
name|e_next
operator|!=
name|NULL
operator|)
operator|&&
operator|!
operator|(
name|qh_e_next
operator|&
name|UHCI_PTR_T
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_dump_all
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sc
operator|->
name|sc_ls_ctl_p_last
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sc
operator|->
name|sc_fs_ctl_p_last
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
name|uhci_dump_qh
argument_list|(
name|sc
operator|->
name|sc_last_qh_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_dump_qhs
parameter_list|(
name|uhci_qh_t
modifier|*
name|sqh
parameter_list|)
block|{
name|uint8_t
name|temp
decl_stmt|;
name|temp
operator|=
name|uhci_dump_qh
argument_list|(
name|sqh
argument_list|)
expr_stmt|;
comment|/* 	 * uhci_dump_qhs displays all the QHs and TDs from the given QH 	 * onwards Traverses sideways first, then down. 	 * 	 * QH1 QH2 No QH TD2.1 TD2.2 TD1.1 etc. 	 * 	 * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1. 	 */
if|if
condition|(
name|temp
operator|&
literal|1
condition|)
name|uhci_dump_qhs
argument_list|(
name|sqh
operator|->
name|h_next
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|"No QH\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
literal|2
condition|)
name|uhci_dump_tds
argument_list|(
name|sqh
operator|->
name|e_next
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|"No TD\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_dump_tds
parameter_list|(
name|uhci_td_t
modifier|*
name|td
parameter_list|)
block|{
for|for
control|(
init|;
name|td
operator|!=
name|NULL
condition|;
name|td
operator|=
name|td
operator|->
name|obj_next
control|)
block|{
if|if
condition|(
name|uhci_dump_td
argument_list|(
name|td
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Let the last QH loop back to the full speed control transfer QH.  * This is what intel calls "bandwidth reclamation" and improves  * USB performance a lot for some devices.  * If we are already looping, just count it.  */
end_comment

begin_function
specifier|static
name|void
name|uhci_add_loop
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uhci_qh
modifier|*
name|qh_lst
decl_stmt|;
name|struct
name|uhci_qh
modifier|*
name|qh_rec
decl_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcinoloop
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|++
operator|(
name|sc
operator|->
name|sc_loops
operator|)
operator|==
literal|1
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"add\n"
argument_list|)
expr_stmt|;
name|qh_lst
operator|=
name|sc
operator|->
name|sc_last_qh_p
expr_stmt|;
name|qh_rec
operator|=
name|sc
operator|->
name|sc_reclaim_qh_p
expr_stmt|;
comment|/* NOTE: we don't loop back the soft pointer */
name|qh_lst
operator|->
name|qh_h_next
operator|=
name|qh_rec
operator|->
name|qh_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|qh_lst
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_rem_loop
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uhci_qh
modifier|*
name|qh_lst
decl_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcinoloop
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|--
operator|(
name|sc
operator|->
name|sc_loops
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"remove\n"
argument_list|)
expr_stmt|;
name|qh_lst
operator|=
name|sc
operator|->
name|sc_last_qh_p
expr_stmt|;
name|qh_lst
operator|->
name|qh_h_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|qh_lst
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_transfer_intr_enqueue
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* check for early completion */
if|if
condition|(
name|uhci_check_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* put transfer on interrupt queue */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* start timeout, if any */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|!=
literal|0
condition|)
block|{
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|uhci_timeout
argument_list|,
name|xfer
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|UHCI_APPEND_TD
parameter_list|(
name|std
parameter_list|,
name|last
parameter_list|)
value|(last) = _uhci_append_td(std,last)
end_define

begin_function
specifier|static
name|uhci_td_t
modifier|*
name|_uhci_append_td
parameter_list|(
name|uhci_td_t
modifier|*
name|std
parameter_list|,
name|uhci_td_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p to %p\n"
argument_list|,
name|std
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
name|std
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|std
operator|->
name|td_next
operator|=
name|last
operator|->
name|td_next
expr_stmt|;
name|std
operator|->
name|prev
operator|=
name|last
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 	 * the last->next->prev is never followed: std->next->prev = std; 	 */
name|last
operator|->
name|next
operator|=
name|std
expr_stmt|;
name|last
operator|->
name|td_next
operator|=
name|std
operator|->
name|td_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|std
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|UHCI_APPEND_QH
parameter_list|(
name|sqh
parameter_list|,
name|last
parameter_list|)
value|(last) = _uhci_append_qh(sqh,last)
end_define

begin_function
specifier|static
name|uhci_qh_t
modifier|*
name|_uhci_append_qh
parameter_list|(
name|uhci_qh_t
modifier|*
name|sqh
parameter_list|,
name|uhci_qh_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p to %p\n"
argument_list|,
name|sqh
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|h_prev
operator|!=
name|NULL
condition|)
block|{
comment|/* should not happen */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"QH already linked!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|last
operator|)
return|;
block|}
comment|/* (sc->sc_bus.mtx) must be locked */
name|sqh
operator|->
name|h_next
operator|=
name|last
operator|->
name|h_next
expr_stmt|;
name|sqh
operator|->
name|qh_h_next
operator|=
name|last
operator|->
name|qh_h_next
expr_stmt|;
name|sqh
operator|->
name|h_prev
operator|=
name|last
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 	 * The "last->h_next->h_prev" is never followed: 	 * 	 * "sqh->h_next->h_prev" = sqh; 	 */
name|last
operator|->
name|h_next
operator|=
name|sqh
expr_stmt|;
name|last
operator|->
name|qh_h_next
operator|=
name|sqh
operator|->
name|qh_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|sqh
operator|)
return|;
block|}
end_function

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|UHCI_REMOVE_TD
parameter_list|(
name|std
parameter_list|,
name|last
parameter_list|)
value|(last) = _uhci_remove_td(std,last)
end_define

begin_function
specifier|static
name|uhci_td_t
modifier|*
name|_uhci_remove_td
parameter_list|(
name|uhci_td_t
modifier|*
name|std
parameter_list|,
name|uhci_td_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p from %p\n"
argument_list|,
name|std
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
name|std
operator|->
name|prev
operator|->
name|next
operator|=
name|std
operator|->
name|next
expr_stmt|;
name|std
operator|->
name|prev
operator|->
name|td_next
operator|=
name|std
operator|->
name|td_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|prev
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|next
condition|)
block|{
name|std
operator|->
name|next
operator|->
name|prev
operator|=
name|std
operator|->
name|prev
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|next
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|last
operator|==
name|std
operator|)
condition|?
name|std
operator|->
name|prev
else|:
name|last
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|UHCI_REMOVE_QH
parameter_list|(
name|sqh
parameter_list|,
name|last
parameter_list|)
value|(last) = _uhci_remove_qh(sqh,last)
end_define

begin_function
specifier|static
name|uhci_qh_t
modifier|*
name|_uhci_remove_qh
parameter_list|(
name|uhci_qh_t
modifier|*
name|sqh
parameter_list|,
name|uhci_qh_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p from %p\n"
argument_list|,
name|sqh
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
comment|/* only remove if not removed from a queue */
if|if
condition|(
name|sqh
operator|->
name|h_prev
condition|)
block|{
name|sqh
operator|->
name|h_prev
operator|->
name|h_next
operator|=
name|sqh
operator|->
name|h_next
expr_stmt|;
name|sqh
operator|->
name|h_prev
operator|->
name|qh_h_next
operator|=
name|sqh
operator|->
name|qh_h_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|h_prev
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|h_next
condition|)
block|{
name|sqh
operator|->
name|h_next
operator|->
name|h_prev
operator|=
name|sqh
operator|->
name|h_prev
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|h_next
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
operator|(
operator|(
name|last
operator|==
name|sqh
operator|)
condition|?
name|sqh
operator|->
name|h_prev
else|:
name|last
operator|)
expr_stmt|;
name|sqh
operator|->
name|h_prev
operator|=
literal|0
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_isoc_done
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_search
name|res
decl_stmt|;
name|uint32_t
name|nframes
init|=
name|xfer
operator|->
name|nframes
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|offset
init|=
literal|0
decl_stmt|;
name|uint32_t
modifier|*
name|plen
init|=
name|xfer
operator|->
name|frlengths
decl_stmt|;
name|uint16_t
name|len
init|=
literal|0
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
init|=
name|xfer
operator|->
name|td_transfer_first
decl_stmt|;
name|uhci_td_t
modifier|*
modifier|*
name|pp_last
init|=
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
comment|/* sync any DMA memory before doing fixups */
name|usb_bdma_post_sync
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp_last
operator|>=
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|UHCI_VFRAMELIST_COUNT
index|]
condition|)
block|{
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
literal|0
index|]
expr_stmt|;
block|}
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"isoc TD\n"
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_status
argument_list|)
expr_stmt|;
name|len
operator|=
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|*
name|plen
condition|)
block|{
name|len
operator|=
operator|*
name|plen
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|fix_pc
condition|)
block|{
name|usbd_get_page
argument_list|(
name|td
operator|->
name|fix_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
comment|/* copy data from fixup location to real location */
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|fix_pc
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|offset
argument_list|,
name|res
operator|.
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
operator|*
name|plen
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
comment|/* remove TD from schedule */
name|UHCI_REMOVE_TD
argument_list|(
name|td
argument_list|,
operator|*
name|pp_last
argument_list|)
expr_stmt|;
name|pp_last
operator|++
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|uhci_non_isoc_done_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_search
name|res
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|token
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|td_alt_next
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_status
argument_list|)
expr_stmt|;
name|token
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_token
argument_list|)
expr_stmt|;
comment|/* 	         * Verify the status and add 	         * up the actual length: 	         */
name|len
operator|=
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|td
operator|->
name|len
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
literal|"Invalid status length, "
literal|"0x%04x/0x%04x bytes\n"
argument_list|,
name|len
argument_list|,
name|td
operator|->
name|len
argument_list|)
expr_stmt|;
name|status
operator||=
name|UHCI_TD_STALLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
operator|)
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|fix_pc
condition|)
block|{
name|usbd_get_page
argument_list|(
name|td
operator|->
name|fix_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
comment|/* 				 * copy data from fixup location to real 				 * location 				 */
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|fix_pc
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
operator|+
name|xfer
operator|->
name|aframes
argument_list|,
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
argument_list|,
name|res
operator|.
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* update actual length */
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Check for last transfer */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_TD_STALLED
condition|)
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for short transfer */
if|if
condition|(
name|len
operator|!=
name|td
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
comment|/* follow alt next */
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
block|}
else|else
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|alt_next
operator|!=
name|td_alt_next
condition|)
block|{
comment|/* this USB frame is complete */
break|break;
block|}
block|}
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
comment|/* update data toggle */
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
operator|=
operator|(
name|token
operator|&
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|status
operator|&
name|UHCI_TD_ERROR
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"error, addr=%d, endpt=0x%02x, frame=0x%02x "
literal|"status=%s%s%s%s%s%s%s%s%s%s%s\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|xfer
operator|->
name|endpointno
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_BITSTUFF
operator|)
condition|?
literal|"[BITSTUFF]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_CRCTO
operator|)
condition|?
literal|"[CRCTO]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_NAK
operator|)
condition|?
literal|"[NAK]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_BABBLE
operator|)
condition|?
literal|"[BABBLE]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_DBUFFER
operator|)
condition|?
literal|"[DBUFFER]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_STALLED
operator|)
condition|?
literal|"[STALLED]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_ACTIVE
operator|)
condition|?
literal|"[ACTIVE]"
else|:
literal|"[NOT_ACTIVE]"
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_IOC
operator|)
condition|?
literal|"[IOC]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_IOS
operator|)
condition|?
literal|"[IOS]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_LS
operator|)
condition|?
literal|"[LS]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|UHCI_TD_SPD
operator|)
condition|?
literal|"[SPD]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|status
operator|&
name|UHCI_TD_STALLED
operator|)
condition|?
name|USB_ERR_STALLED
else|:
name|USB_ERR_NORMAL_COMPLETION
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_non_isoc_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|10
condition|)
block|{
name|uhci_dump_tds
argument_list|(
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sync any DMA memory before doing fixups */
name|usb_bdma_post_sync
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* reset scanner */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|err
operator|=
name|uhci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
while|while
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|err
operator|=
name|uhci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|err
operator|=
name|uhci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhci_check_transfer_sub  *  * The main purpose of this function is to update the data-toggle  * in case it is wrong.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uhci_check_transfer_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|td_token
decl_stmt|;
name|uint32_t
name|td_self
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|td_token
operator|=
name|td
operator|->
name|obj_next
operator|->
name|td_token
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|td_self
operator|=
name|td
operator|->
name|td_self
expr_stmt|;
name|td_alt_next
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
goto|goto
name|skip
goto|;
comment|/* don't touch the DT value! */
if|if
condition|(
operator|!
operator|(
operator|(
name|td
operator|->
name|td_token
operator|^
name|td_token
operator|)
operator|&
name|htole32
argument_list|(
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|skip
goto|;
comment|/* data toggle has correct value */
comment|/* 	 * The data toggle is wrong and we need to toggle it ! 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|td
operator|->
name|td_token
operator|^=
name|htole32
argument_list|(
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
comment|/* last transfer */
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|alt_next
operator|!=
name|td_alt_next
condition|)
block|{
comment|/* next frame */
break|break;
block|}
block|}
name|skip
label|:
comment|/* update the QH */
name|qh
operator|->
name|qh_e_next
operator|=
name|td_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p following alt next\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhci_check_transfer  *  * Return values:  *    0: USB transfer is not finished  * Else: USB transfer is finished  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|uhci_check_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|token
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"xfer=%p checking transfer\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|==
operator|&
name|uhci_device_isoc_methods
condition|)
block|{
comment|/* isochronous transfer */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_last
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_status
argument_list|)
expr_stmt|;
comment|/* check also if the first is complete */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator||=
name|le32toh
argument_list|(
name|td
operator|->
name|td_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|UHCI_TD_ACTIVE
operator|)
condition|)
block|{
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
expr_stmt|;
goto|goto
name|transferred
goto|;
block|}
block|}
else|else
block|{
comment|/* non-isochronous transfer */
comment|/* 		 * check whether there is an error somewhere 		 * in the middle, or whether there was a short 		 * packet (SPD and not ACTIVE) 		 */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_status
argument_list|)
expr_stmt|;
name|token
operator|=
name|le32toh
argument_list|(
name|td
operator|->
name|td_token
argument_list|)
expr_stmt|;
comment|/* 			 * if there is an active TD the transfer isn't done 			 */
if|if
condition|(
name|status
operator|&
name|UHCI_TD_ACTIVE
condition|)
block|{
comment|/* update cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * last transfer descriptor makes the transfer done 			 */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
break|break;
block|}
comment|/* 			 * any kind of error makes the transfer done 			 */
if|if
condition|(
name|status
operator|&
name|UHCI_TD_STALLED
condition|)
block|{
break|break;
block|}
comment|/* 			 * check if we reached the last packet 			 * or if there is a short packet: 			 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_next
operator|==
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
operator|)
operator|||
operator|(
name|UHCI_TD_GET_ACTLEN
argument_list|(
name|status
argument_list|)
operator|<
name|td
operator|->
name|len
operator|)
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
comment|/* follow alt next */
if|if
condition|(
name|td
operator|->
name|alt_next
condition|)
block|{
comment|/* update cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|uhci_check_transfer_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* transfer is done */
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|uhci_non_isoc_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|transferred
goto|;
block|}
name|done
label|:
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p is still active\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|transferred
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_interrupt_poll
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|repeat
label|:
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
comment|/* 		 * check if transfer is transferred 		 */
if|if
condition|(
name|uhci_check_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
comment|/* queue has been modified */
goto|goto
name|repeat
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	uhci_interrupt - UHCI interrupt handler  *  * NOTE: Do not access "sc->sc_bus.bdev" inside the interrupt handler,  * hence the interrupt handler will be setup before "sc->sc_bus.bdev"  * is present !  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|uhci_interrupt
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"real interrupt\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|15
condition|)
block|{
name|uhci_dumpregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|)
operator|&
name|UHCI_STS_ALLINTRS
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* the interrupt was not for us */
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|UHCI_STS_RD
operator||
name|UHCI_STS_HSE
operator||
name|UHCI_STS_HCPE
operator||
name|UHCI_STS_HCH
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|UHCI_STS_RD
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
name|printf
argument_list|(
literal|"%s: resume detect\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: host system error\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCPE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: host controller process error\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|UHCI_STS_HCH
condition|)
block|{
comment|/* no acknowledge needed */
name|DPRINTF
argument_list|(
literal|"%s: host controller halted\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|0
condition|)
block|{
name|uhci_dump_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* get acknowledge bits */
name|status
operator|&=
operator|(
name|UHCI_STS_USBINT
operator||
name|UHCI_STS_USBEI
operator||
name|UHCI_STS_RD
operator||
name|UHCI_STS_HSE
operator||
name|UHCI_STS_HCPE
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* nothing to acknowledge */
goto|goto
name|done
goto|;
block|}
comment|/* acknowledge interrupts */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|UHCI_STS
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* poll all the USB transfers */
name|uhci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called when a request does not complete  */
end_comment

begin_function
specifier|static
name|void
name|uhci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"xfer=%p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* transfer is transferred */
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|uhci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_setup_standard_chain_sub
parameter_list|(
name|struct
name|uhci_std_temp
modifier|*
name|temp
parameter_list|)
block|{
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_next
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|len_old
decl_stmt|;
name|uint8_t
name|shortpkt_old
decl_stmt|;
name|uint8_t
name|precompute
decl_stmt|;
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
name|shortpkt_old
operator|=
name|temp
operator|->
name|shortpkt
expr_stmt|;
name|len_old
operator|=
name|temp
operator|->
name|len
expr_stmt|;
name|precompute
operator|=
literal|1
expr_stmt|;
comment|/* software is used to detect short incoming transfers */
if|if
condition|(
operator|(
name|temp
operator|->
name|td_token
operator|&
name|htole32
argument_list|(
name|UHCI_TD_PID
argument_list|)
operator|)
operator|==
name|htole32
argument_list|(
name|UHCI_TD_PID_IN
argument_list|)
condition|)
block|{
name|temp
operator|->
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SPD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|->
name|td_status
operator|&=
operator|~
name|htole32
argument_list|(
name|UHCI_TD_SPD
argument_list|)
expr_stmt|;
block|}
name|temp
operator|->
name|ml
operator|.
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|restart
label|:
name|temp
operator|->
name|td_token
operator|&=
operator|~
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
name|temp
operator|->
name|average
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|=
name|temp
operator|->
name|td
expr_stmt|;
name|td_next
operator|=
name|temp
operator|->
name|td_next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|shortpkt
condition|)
block|{
break|break;
block|}
comment|/* send a Zero Length Packet, ZLP, last */
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|average
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|average
operator|=
name|temp
operator|->
name|average
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|len
operator|<
name|average
condition|)
block|{
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|td_token
operator|&=
operator|~
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
name|temp
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|average
operator|=
name|temp
operator|->
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|td_next
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s: out of UHCI transfer descriptors!"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* get next TD */
name|td
operator|=
name|td_next
expr_stmt|;
name|td_next
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* check if we are pre-computing */
if|if
condition|(
name|precompute
condition|)
block|{
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
continue|continue;
block|}
comment|/* fill out current TD */
name|td
operator|->
name|td_status
operator|=
name|temp
operator|->
name|td_status
expr_stmt|;
name|td
operator|->
name|td_token
operator|=
name|temp
operator|->
name|td_token
expr_stmt|;
comment|/* update data toggle */
name|temp
operator|->
name|td_token
operator|^=
name|htole32
argument_list|(
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|average
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_buffer
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|fix_pc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
name|td
operator|->
name|len
operator|=
name|average
expr_stmt|;
comment|/* fill out buffer pointer and do fixup, if any */
name|uhci_mem_layout_fixup
argument_list|(
operator|&
name|temp
operator|->
name|ml
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|alt_next
operator|=
name|td_alt_next
expr_stmt|;
if|if
condition|(
operator|(
name|td_next
operator|==
name|td_alt_next
operator|)
operator|&&
name|temp
operator|->
name|setup_alt_next
condition|)
block|{
comment|/* we need to receive these frames one by one ! */
name|td
operator|->
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|td_next
condition|)
block|{
comment|/* link the current TD with the next one */
name|td
operator|->
name|td_next
operator|=
name|td_next
operator|->
name|td_self
expr_stmt|;
block|}
block|}
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precompute
condition|)
block|{
name|precompute
operator|=
literal|0
expr_stmt|;
comment|/* setup alt next pointer, if any */
if|if
condition|(
name|temp
operator|->
name|last_frame
condition|)
block|{
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* we use this field internally */
name|td_alt_next
operator|=
name|td_next
expr_stmt|;
block|}
comment|/* restore */
name|temp
operator|->
name|shortpkt
operator|=
name|shortpkt_old
expr_stmt|;
name|temp
operator|->
name|len
operator|=
name|len_old
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|temp
operator|->
name|td
operator|=
name|td
expr_stmt|;
name|temp
operator|->
name|td_next
operator|=
name|td_next
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uhci_td_t
modifier|*
name|uhci_setup_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_std_temp
name|temp
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"addr=%d endpt=%d sumlen=%d speed=%d\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|,
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|average
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
name|temp
operator|.
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|temp
operator|.
name|td
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td_next
operator|=
name|td
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
expr_stmt|;
name|uhci_mem_layout_init
argument_list|(
operator|&
name|temp
operator|.
name|ml
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|temp
operator|.
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_ZERO_ACTLEN
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|3
argument_list|)
operator||
name|UHCI_TD_ACTIVE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|temp
operator|.
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_LS
argument_list|)
expr_stmt|;
block|}
name|temp
operator|.
name|td_token
operator|=
name|htole32
argument_list|(
name|UHCI_TD_SET_ENDPT
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator||
name|UHCI_TD_SET_DEVADDR
argument_list|(
name|xfer
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
condition|)
block|{
comment|/* DATA1 is next */
name|temp
operator|.
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should prepend a setup message */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|temp
operator|.
name|td_token
operator|&=
name|htole32
argument_list|(
name|UHCI_TD_SET_DEVADDR
argument_list|(
literal|0x7F
argument_list|)
operator||
name|UHCI_TD_SET_ENDPT
argument_list|(
literal|0xF
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_PID_SETUP
operator||
name|UHCI_TD_SET_DT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|ml
operator|.
name|buf_pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
name|temp
operator|.
name|len
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for last frame */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|1
condition|)
block|{
comment|/* no STATUS stage yet, SETUP is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|uhci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* DATA0 / DATA1 message */
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|temp
operator|.
name|ml
operator|.
name|buf_pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* no STATUS stage yet, DATA is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Keep previous data toggle, 		 * device address and endpoint number: 		 */
name|temp
operator|.
name|td_token
operator|&=
name|htole32
argument_list|(
name|UHCI_TD_SET_DEVADDR
argument_list|(
literal|0x7F
argument_list|)
operator||
name|UHCI_TD_SET_ENDPT
argument_list|(
literal|0xF
argument_list|)
operator||
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|/* make sure that we send an USB packet */
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regular data transfer */
name|temp
operator|.
name|shortpkt
operator|=
operator|(
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
comment|/* set endpoint direction */
name|temp
operator|.
name|td_token
operator||=
operator|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
operator|)
condition|?
name|htole32
argument_list|(
name|UHCI_TD_PID_IN
argument_list|)
else|:
name|htole32
argument_list|(
name|UHCI_TD_PID_OUT
argument_list|)
expr_stmt|;
name|uhci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should append a status stage */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* 		 * send a DATA1 message and reverse the current endpoint 		 * direction 		 */
name|temp
operator|.
name|td_token
operator|&=
name|htole32
argument_list|(
name|UHCI_TD_SET_DEVADDR
argument_list|(
literal|0x7F
argument_list|)
operator||
name|UHCI_TD_SET_ENDPT
argument_list|(
literal|0xF
argument_list|)
operator||
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|td_token
operator||=
operator|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_OUT
operator|)
condition|?
name|htole32
argument_list|(
name|UHCI_TD_PID_IN
operator||
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
else|:
name|htole32
argument_list|(
name|UHCI_TD_PID_OUT
operator||
name|UHCI_TD_SET_DT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|ml
operator|.
name|buf_pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
name|uhci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
comment|/* Ensure that last TD is terminating: */
name|td
operator|->
name|td_next
operator|=
name|htole32
argument_list|(
name|UHCI_PTR_T
argument_list|)
expr_stmt|;
comment|/* set interrupt bit */
name|td
operator|->
name|td_status
operator||=
name|htole32
argument_list|(
name|UHCI_TD_IOC
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* must have at least one frame! */
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"nexttog=%d; data before transfer:\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
argument_list|)
expr_stmt|;
name|uhci_dump_tds
argument_list|(
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|xfer
operator|->
name|td_transfer_first
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NOTE: "done" can be run two times in a row,  * from close and from interrupt  */
end_comment

begin_function
specifier|static
name|void
name|uhci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|usb_pipe_methods
modifier|*
name|methods
init|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p, endpoint=%p, error=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|qh
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
operator|=
literal|0
expr_stmt|;
name|uhci_rem_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_bulk_methods
condition|)
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_ctrl_methods
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_ls_ctl_p_last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_fs_ctl_p_last
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_intr_methods
condition|)
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Only finish isochronous transfers once 	 * which will update "xfer->frlengths". 	 */
if|if
condition|(
name|xfer
operator|->
name|td_transfer_first
operator|&&
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_isoc_methods
condition|)
block|{
name|uhci_isoc_done
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|td_transfer_first
operator|=
name|NULL
expr_stmt|;
name|xfer
operator|->
name|td_transfer_last
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* dequeue transfer and start next transfer */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * uhci bulk support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uhci_device_bulk_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_bulk_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_bulk_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_bulk_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
comment|/* setup TD's */
name|td
operator|=
name|uhci_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* setup QH */
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|qh
operator|->
name|e_next
operator|=
name|td
expr_stmt|;
name|qh
operator|->
name|qh_e_next
operator|=
name|td
operator|->
name|td_self
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
name|uhci_add_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|usb_pc_cpu_flush
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
comment|/* put transfer on interrupt queue */
name|uhci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|uhci_device_bulk_methods
init|=
block|{
operator|.
name|open
operator|=
name|uhci_device_bulk_open
block|,
operator|.
name|close
operator|=
name|uhci_device_bulk_close
block|,
operator|.
name|enter
operator|=
name|uhci_device_bulk_enter
block|,
operator|.
name|start
operator|=
name|uhci_device_bulk_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * uhci control support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uhci_device_ctrl_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_ctrl_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_ctrl_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_ctrl_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
comment|/* setup TD's */
name|td
operator|=
name|uhci_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* setup QH */
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|qh
operator|->
name|e_next
operator|=
name|td
expr_stmt|;
name|qh
operator|->
name|qh_e_next
operator|=
name|td
operator|->
name|td_self
expr_stmt|;
comment|/* 	 * NOTE: some devices choke on bandwidth- reclamation for control 	 * transfers 	 */
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_ls_ctl_p_last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_fs_ctl_p_last
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|usb_pc_cpu_flush
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
comment|/* put transfer on interrupt queue */
name|uhci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|uhci_device_ctrl_methods
init|=
block|{
operator|.
name|open
operator|=
name|uhci_device_ctrl_open
block|,
operator|.
name|close
operator|=
name|uhci_device_ctrl_close
block|,
operator|.
name|enter
operator|=
name|uhci_device_ctrl_enter
block|,
operator|.
name|start
operator|=
name|uhci_device_ctrl_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * uhci interrupt support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uhci_device_intr_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint16_t
name|best
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
name|UHCI_IFRAMELIST_COUNT
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|interval
operator|>=
name|bit
condition|)
block|{
name|x
operator|=
name|bit
expr_stmt|;
name|best
operator|=
name|bit
expr_stmt|;
while|while
condition|(
name|x
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_intr_stat
index|[
name|x
index|]
operator|<
name|sc
operator|->
name|sc_intr_stat
index|[
name|best
index|]
condition|)
block|{
name|best
operator|=
name|x
expr_stmt|;
block|}
name|x
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_intr_stat
index|[
name|best
index|]
operator|++
expr_stmt|;
name|xfer
operator|->
name|qh_pos
operator|=
name|best
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"best=%d interval=%d\n"
argument_list|,
name|best
argument_list|,
name|xfer
operator|->
name|interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_intr_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_intr_stat
index|[
name|xfer
operator|->
name|qh_pos
index|]
operator|--
expr_stmt|;
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_intr_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_intr_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
comment|/* setup TD's */
name|td
operator|=
name|uhci_setup_standard_chain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* setup QH */
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|qh
operator|->
name|e_next
operator|=
name|td
expr_stmt|;
name|qh
operator|->
name|qh_e_next
operator|=
name|td
operator|->
name|td_self
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
comment|/* enter QHs into the controller data structures */
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usb_pc_cpu_flush
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
comment|/* put transfer on interrupt queue */
name|uhci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|uhci_device_intr_methods
init|=
block|{
operator|.
name|open
operator|=
name|uhci_device_intr_open
block|,
operator|.
name|close
operator|=
name|uhci_device_intr_close
block|,
operator|.
name|enter
operator|=
name|uhci_device_intr_enter
block|,
operator|.
name|start
operator|=
name|uhci_device_intr_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * uhci isochronous support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uhci_device_isoc_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|td_token
decl_stmt|;
name|uint8_t
name|ds
decl_stmt|;
name|td_token
operator|=
operator|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
operator|)
condition|?
name|UHCI_TD_IN
argument_list|(
literal|0
argument_list|,
name|xfer
operator|->
name|endpointno
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
literal|0
argument_list|)
else|:
name|UHCI_TD_OUT
argument_list|(
literal|0
argument_list|,
name|xfer
operator|->
name|endpointno
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|td_token
operator|=
name|htole32
argument_list|(
name|td_token
argument_list|)
expr_stmt|;
comment|/* initialize all TD's */
for|for
control|(
name|ds
operator|=
literal|0
init|;
name|ds
operator|!=
literal|2
condition|;
name|ds
operator|++
control|)
block|{
for|for
control|(
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|ds
index|]
init|;
name|td
condition|;
name|td
operator|=
name|td
operator|->
name|obj_next
control|)
block|{
comment|/* mark TD as inactive */
name|td
operator|->
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_IOS
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_token
operator|=
name|td_token
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_isoc_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uhci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_isoc_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|uhci_mem_layout
name|ml
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
modifier|*
name|plen
decl_stmt|;
if|#
directive|if
name|USB_DEBUG
name|uint8_t
name|once
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|uhci_td_t
modifier|*
name|td_last
init|=
name|NULL
decl_stmt|;
name|uhci_td_t
modifier|*
modifier|*
name|pp_last
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"xfer=%p next=%d nframes=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_FRNUM
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|nframes
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|)
operator|&
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
name|temp
operator|<
name|xfer
operator|->
name|nframes
operator|)
condition|)
block|{
comment|/* 		 * If there is data underflow or the pipe queue is empty we 		 * schedule the transfer a few frames ahead of the current 		 * frame position. Else two isochronous transfers might 		 * overlap. 		 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|nframes
operator|+
literal|3
operator|)
operator|&
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * compute how many milliseconds the insertion is ahead of the 	 * current frame position: 	 */
name|temp
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|nframes
operator|)
operator|&
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * pre-compute when the isochronous transfer will be finished: 	 */
name|xfer
operator|->
name|isoc_time_complete
operator|=
name|usb_isoc_time_expand
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|nframes
argument_list|)
operator|+
name|temp
operator|+
name|xfer
operator|->
name|nframes
expr_stmt|;
comment|/* get the real number of frames */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|uhci_mem_layout_init
argument_list|(
operator|&
name|ml
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|plen
operator|=
name|xfer
operator|->
name|frlengths
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
index|]
expr_stmt|;
comment|/* store starting position */
name|xfer
operator|->
name|qh_pos
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp_last
operator|>=
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
name|UHCI_VFRAMELIST_COUNT
index|]
condition|)
block|{
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|plen
operator|>
name|xfer
operator|->
name|max_frame_size
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|once
condition|)
block|{
name|once
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: frame length(%d) exceeds %d "
literal|"bytes (frame truncated)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|plen
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|plen
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
block|}
comment|/* reuse td_token from last transfer */
name|td
operator|->
name|td_token
operator|&=
name|htole32
argument_list|(
operator|~
name|UHCI_TD_MAXLEN_MASK
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_token
operator||=
name|htole32
argument_list|(
name|UHCI_TD_SET_MAXLEN
argument_list|(
operator|*
name|plen
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|len
operator|=
operator|*
name|plen
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|len
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Do not call "uhci_mem_layout_fixup()" when the 			 * length is zero! 			 */
name|td
operator|->
name|td_buffer
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|fix_pc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* fill out buffer pointer and do fixup, if any */
name|uhci_mem_layout_fixup
argument_list|(
operator|&
name|ml
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* update status */
if|if
condition|(
name|nframes
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_ZERO_ACTLEN
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|0
argument_list|)
operator||
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOS
operator||
name|UHCI_TD_IOC
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_status
operator|=
name|htole32
argument_list|(
name|UHCI_TD_ZERO_ACTLEN
argument_list|(
name|UHCI_TD_SET_ERRCNT
argument_list|(
literal|0
argument_list|)
operator||
name|UHCI_TD_ACTIVE
operator||
name|UHCI_TD_IOS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|uhcidebug
operator|>
literal|5
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"TD %d\n"
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
name|uhci_dump_td
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* insert TD into schedule */
name|UHCI_APPEND_TD
argument_list|(
name|td
argument_list|,
operator|*
name|pp_last
argument_list|)
expr_stmt|;
name|pp_last
operator|++
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|td_last
operator|=
name|td
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td_last
expr_stmt|;
comment|/* update isoc_next */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|pp_last
operator|-
operator|&
name|sc
operator|->
name|sc_isoc_p_last
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|UHCI_VFRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_isoc_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* put transfer on interrupt queue */
name|uhci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|uhci_device_isoc_methods
init|=
block|{
operator|.
name|open
operator|=
name|uhci_device_isoc_open
block|,
operator|.
name|close
operator|=
name|uhci_device_isoc_close
block|,
operator|.
name|enter
operator|=
name|uhci_device_isoc_enter
block|,
operator|.
name|start
operator|=
name|uhci_device_isoc_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * uhci root control support  *------------------------------------------------------------------------*  * Simulate a hardware hub by handling all the necessary requests.  *------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_descriptor
name|uhci_devd
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_descriptor
argument_list|)
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_FSHUB
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uhci_config_desc
name|uhci_confd
init|=
block|{
operator|.
name|confd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_CONFIG
block|,
operator|.
name|wTotalLength
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|uhci_confd
argument_list|)
block|,
operator|.
name|bNumInterface
operator|=
literal|1
block|,
operator|.
name|bConfigurationValue
operator|=
literal|1
block|,
operator|.
name|iConfiguration
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
name|UC_SELF_POWERED
block|,
operator|.
name|bMaxPower
operator|=
literal|0
comment|/* max power */
block|}
block|,
operator|.
name|ifcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_interface_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
block|,
operator|.
name|bNumEndpoints
operator|=
literal|1
block|,
operator|.
name|bInterfaceClass
operator|=
name|UICLASS_HUB
block|,
operator|.
name|bInterfaceSubClass
operator|=
name|UISUBCLASS_HUB
block|,
operator|.
name|bInterfaceProtocol
operator|=
name|UIPROTO_FSHUB
block|, 	}
block|,
operator|.
name|endpd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_endpoint_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
block|,
operator|.
name|bEndpointAddress
operator|=
name|UE_DIR_IN
operator||
name|UHCI_INTR_ENDPT
block|,
operator|.
name|bmAttributes
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
literal|8
block|,
comment|/* max packet (63 ports) */
operator|.
name|bInterval
operator|=
literal|255
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hub_descriptor_min
name|uhci_hubd_piix
init|=
block|{
sizeof|sizeof
argument_list|(
name|uhci_hubd_piix
argument_list|)
block|,
name|UDESC_HUB
block|,
literal|2
block|,
block|{
name|UHD_PWR_NO_SWITCH
operator||
name|UHD_OC_INDIVIDUAL
block|,
literal|0
block|}
block|,
literal|50
block|,
comment|/* power on to power good */
literal|0
block|,
block|{
literal|0x00
block|}
block|,
comment|/* both ports are removable */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The USB hub protocol requires that SET_FEATURE(PORT_RESET) also  * enables the port, and also states that SET_FEATURE(PORT_ENABLE)  * should not be used by the USB subsystem.  As we cannot issue a  * SET_FEATURE(PORT_ENABLE) externally, we must ensure that the port  * will be enabled as part of the reset.  *  * On the VT83C572, the port cannot be successfully enabled until the  * outstanding "port enable change" and "connection status change"  * events have been reset.  */
end_comment

begin_function
specifier|static
name|usb_error_t
name|uhci_portreset
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|uint16_t
name|port
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint8_t
name|lim
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
comment|/* 	 * Before we do anything, turn on SOF messages on the USB 	 * BUS. Some USB devices do not cope without them! 	 */
name|uhci_restart
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"uhci port %d reset, status0 = 0x%04x\n"
argument_list|,
name|index
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|)
expr_stmt|;
comment|/*  	 * This delay needs to be exactly 100us, else some USB devices 	 * fail to attach! 	 */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"uhci port %d reset, status1 = 0x%04x\n"
argument_list|,
name|index
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
for|for
control|(
name|lim
operator|=
literal|0
init|;
name|lim
operator|<
literal|12
condition|;
name|lim
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_PORT_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"uhci port %d iteration %u, status = 0x%04x\n"
argument_list|,
name|index
argument_list|,
name|lim
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
name|UHCI_PORTSC_CCS
operator|)
condition|)
block|{
comment|/* 			 * No device is connected (or was disconnected 			 * during reset).  Consider the port reset. 			 * The delay must be long enough to ensure on 			 * the initial iteration that the device 			 * connection will have been registered.  50ms 			 * appears to be sufficient, but 20ms is not. 			 */
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"uhci port %d loop %u, device detached\n"
argument_list|,
name|index
argument_list|,
name|lim
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|x
operator|&
operator|(
name|UHCI_PORTSC_POEDC
operator||
name|UHCI_PORTSC_CSC
operator|)
condition|)
block|{
comment|/* 			 * Port enabled changed and/or connection 			 * status changed were set.  Reset either or 			 * both raised flags (by writing a 1 to that 			 * bit), and wait again for state to settle. 			 */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|URWMASK
argument_list|(
name|x
argument_list|)
operator||
operator|(
name|x
operator|&
operator|(
name|UHCI_PORTSC_POEDC
operator||
name|UHCI_PORTSC_CSC
operator|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_PE
condition|)
block|{
comment|/* port is enabled */
goto|goto
name|done
goto|;
block|}
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|URWMASK
argument_list|(
name|x
argument_list|)
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"uhci port %d reset timed out\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_TIMEOUT
operator|)
return|;
name|done
label|:
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"uhci port %d reset, status2 = 0x%04x\n"
argument_list|,
name|index
argument_list|,
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isreset
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|uhci_roothub_exec
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plength
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_ptr
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint16_t
name|port
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|uint16_t
name|change
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* buffer reset */
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"type=0x%02x request=0x%02x wLen=0x%04x "
literal|"wValue=0x%04x wIndex=0x%04x\n"
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|,
name|req
operator|->
name|bRequest
argument_list|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
argument_list|,
name|value
argument_list|,
name|index
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uhci_devd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|uhci_devd
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uhci_confd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|uhci_confd
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|str_ptr
operator|=
literal|"\001"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Vendor */
name|str_ptr
operator|=
name|sc
operator|->
name|sc_vendor
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|str_ptr
operator|=
literal|"UHCI root HUB"
expr_stmt|;
break|break;
default|default:
name|str_ptr
operator|=
literal|""
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|usb_make_str_desc
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|)
argument_list|,
name|str_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|UHCI_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|value
operator|!=
literal|1
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
literal|"UR_CLEAR_PORT_FEATURE "
literal|"port=%d feature=%d\n"
argument_list|,
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
operator|(
name|UHCI_PORTSC_SUSP
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator|&
operator|~
name|UHCI_PORTSC_PR
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_POEDC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_OCIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_isreset
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|USB_ERR_NORMAL_COMPLETION
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|sc
operator|->
name|sc_isresumed
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_POWER
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_BUS_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
name|UHCI_PORTSC_LS
operator|)
operator|>>
name|UHCI_PORTSC_LS_SHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uhci_hubd_piix
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|uhci_hubd_piix
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|16
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|x
operator|=
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|status
operator|=
name|change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CCS
condition|)
name|status
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_CSC
condition|)
name|change
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_PE
condition|)
name|status
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_POEDC
condition|)
name|change
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCI
condition|)
name|status
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_OCIC
condition|)
name|change
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_LSDA
condition|)
name|status
operator||=
name|UPS_LOW_SPEED
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|UHCI_PORTSC_PE
operator|)
operator|&&
operator|(
name|x
operator|&
name|UHCI_PORTSC_RD
operator|)
condition|)
block|{
comment|/* need to do a write back */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|URWMASK
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait 20ms for resume sequence to complete */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
comment|/* clear suspend and resume detect */
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|URWMASK
argument_list|(
name|x
argument_list|)
operator|&
operator|~
operator|(
name|UHCI_PORTSC_RD
operator||
name|UHCI_PORTSC_SUSP
operator|)
argument_list|)
expr_stmt|;
comment|/* wait a little bit */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|500
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_isresumed
operator||=
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|&
name|UHCI_PORTSC_SUSP
condition|)
block|{
name|status
operator||=
name|UPS_SUSPEND
expr_stmt|;
block|}
name|status
operator||=
name|UPS_PORT_POWER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isresumed
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
name|change
operator||=
name|UPS_C_SUSPEND
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isreset
condition|)
name|change
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortStatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortChange
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|port
operator|=
name|UHCI_PORTSC1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
literal|2
condition|)
name|port
operator|=
name|UHCI_PORTSC2
expr_stmt|;
else|else
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|x
operator|=
name|URWMASK
argument_list|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|UWRITE2
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|x
operator||
name|UHCI_PORTSC_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|err
operator|=
name|uhci_portreset
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UHF_PORT_POWER
case|:
comment|/* pretend we turned on power */
name|err
operator|=
name|USB_ERR_NORMAL_COMPLETION
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UHF_C_PORT_CONNECTION
case|:
case|case
name|UHF_C_PORT_ENABLE
case|:
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_CONNECTION
case|:
case|case
name|UHF_PORT_OVER_CURRENT
case|:
case|case
name|UHF_PORT_LOW_SPEED
case|:
case|case
name|UHF_C_PORT_SUSPEND
case|:
case|case
name|UHF_C_PORT_RESET
case|:
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
operator|*
name|plength
operator|=
name|len
expr_stmt|;
operator|*
name|pptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is executed periodically and simulates interrupts from  * the root controller interrupt pipe for port status change:  */
end_comment

begin_function
specifier|static
name|void
name|uhci_root_intr
parameter_list|(
name|uhci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|21
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hub_idata
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC1
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator||
name|UHCI_PORTSC_RD
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_hub_idata
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|UREAD2
argument_list|(
name|sc
argument_list|,
name|UHCI_PORTSC2
argument_list|)
operator|&
operator|(
name|UHCI_PORTSC_CSC
operator||
name|UHCI_PORTSC_OCIC
operator||
name|UHCI_PORTSC_RD
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_hub_idata
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
block|}
comment|/* restart timer */
name|usb_callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_root_intr
argument_list|,
name|hz
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|uhci_root_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hub_idata
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|uhub_root_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_hub_idata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_xfer_setup
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|usb_page_search
name|page_info
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uhci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|last_obj
decl_stmt|;
name|uint32_t
name|ntd
decl_stmt|;
name|uint32_t
name|nqh
decl_stmt|;
name|uint32_t
name|nfixup
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint16_t
name|align
decl_stmt|;
name|sc
operator|=
name|UHCI_BUS2SC
argument_list|(
name|parm
operator|->
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|parm
operator|->
name|curr_xfer
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x500
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
literal|0x500
expr_stmt|;
comment|/* 	 * compute ntd and nqh 	 */
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_ctrl_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_no_post_sync
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* see EHCI HC driver for proof of "ntd" formula */
name|nqh
operator|=
literal|1
expr_stmt|;
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
literal|1
comment|/* STATUS */
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_bulk_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_no_post_sync
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_intr_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_no_post_sync
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
name|ntd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_isoc_methods
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_no_post_sync
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|0
expr_stmt|;
name|ntd
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
else|else
block|{
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|0
expr_stmt|;
name|ntd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|parm
operator|->
name|err
condition|)
block|{
return|return;
block|}
comment|/* 	 * NOTE: the UHCI controller requires that 	 * every packet must be contiguous on 	 * the same USB memory page ! 	 */
name|nfixup
operator|=
operator|(
name|parm
operator|->
name|bufsize
operator|/
name|USB_PAGE_SIZE
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Compute a suitable power of two alignment 	 * for our "max_frame_size" fixup buffer(s): 	 */
name|align
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|align
condition|)
block|{
name|align
operator|>>=
literal|1
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* check for power of two */
if|if
condition|(
operator|!
operator|(
name|xfer
operator|->
name|max_frame_size
operator|&
operator|(
name|xfer
operator|->
name|max_frame_size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
block|}
comment|/* 	 * We don't allow alignments of 	 * less than 8 bytes: 	 * 	 * NOTE: Allocating using an aligment 	 * of 1 byte has special meaning! 	 */
if|if
condition|(
name|n
operator|<
literal|3
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
block|}
name|align
operator|=
operator|(
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|,
name|align
argument_list|,
name|nfixup
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
name|xfer
operator|->
name|buf_fixup
operator|=
name|pc
expr_stmt|;
name|alloc_dma_set
label|:
if|if
condition|(
name|parm
operator|->
name|err
condition|)
block|{
return|return;
block|}
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_td_t
argument_list|)
argument_list|,
name|UHCI_TD_ALIGN
argument_list|,
name|ntd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|ntd
condition|;
name|n
operator|++
control|)
block|{
name|uhci_td_t
modifier|*
name|td
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|td
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
if|if
condition|(
operator|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_bulk_methods
operator|)
operator|||
operator|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_ctrl_methods
operator|)
operator|||
operator|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|uhci_device_intr_methods
operator|)
condition|)
block|{
comment|/* set depth first bit */
name|td
operator|->
name|td_self
operator|=
name|htole32
argument_list|(
name|page_info
operator|.
name|physaddr
operator||
name|UHCI_PTR_TD
operator||
name|UHCI_PTR_VF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_self
operator|=
name|htole32
argument_list|(
name|page_info
operator|.
name|physaddr
operator||
name|UHCI_PTR_TD
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|td
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|uhci_qh_t
argument_list|)
argument_list|,
name|UHCI_QH_ALIGN
argument_list|,
name|nqh
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nqh
condition|;
name|n
operator|++
control|)
block|{
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|qh
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init QH */
name|qh
operator|->
name|qh_self
operator|=
name|htole32
argument_list|(
name|page_info
operator|.
name|physaddr
operator||
name|UHCI_PTR_QH
argument_list|)
expr_stmt|;
name|qh
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|qh
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|qh
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|=
literal|1
expr_stmt|;
goto|goto
name|alloc_dma_set
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_ep_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|uhci_softc_t
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"endpoint=%p, addr=%d, endpt=%d, mode=%d (%d)\n"
argument_list|,
name|ep
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|usb_mode
argument_list|,
name|sc
operator|->
name|sc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
comment|/* not supported */
return|return;
block|}
if|if
condition|(
name|udev
operator|->
name|device_index
operator|!=
name|sc
operator|->
name|sc_addr
condition|)
block|{
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|uhci_device_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|uhci_device_intr_methods
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|uhci_device_isoc_methods
expr_stmt|;
block|}
break|break;
case|case
name|UE_BULK
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_LOW
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|uhci_device_bulk_methods
expr_stmt|;
block|}
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_xfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_get_dma_delay
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint32_t
modifier|*
name|pus
parameter_list|)
block|{
comment|/* 	 * Wait until hardware has finished any possible use of the 	 * transfer descriptor(s) and QH 	 */
operator|*
name|pus
operator|=
operator|(
literal|1125
operator|)
expr_stmt|;
comment|/* microseconds */
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_resume
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|==
name|udev
condition|)
block|{
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_bulk_methods
condition|)
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
name|uhci_add_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_ctrl_methods
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_ls_ctl_p_last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_fs_ctl_p_last
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_intr_methods
condition|)
block|{
name|UHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_device_suspend
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|uhci_qh_t
modifier|*
name|qh
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|==
name|udev
condition|)
block|{
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|bandwidth_reclaimed
operator|=
literal|0
expr_stmt|;
name|uhci_rem_loop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_bulk_methods
condition|)
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_bulk_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_ctrl_methods
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_ls_ctl_p_last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_fs_ctl_p_last
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|uhci_device_intr_methods
condition|)
block|{
name|UHCI_REMOVE_QH
argument_list|(
name|qh
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uhci_set_hw_power
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|struct
name|uhci_softc
modifier|*
name|sc
init|=
name|UHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bus
operator|->
name|hw_power_state
expr_stmt|;
comment|/* 	 * WARNING: Some FULL speed USB devices require periodic SOF 	 * messages! If any USB devices are connected through the 	 * UHCI, power save will be disabled! 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|USB_HW_POWER_CONTROL
operator||
name|USB_HW_POWER_NON_ROOT_HUB
operator||
name|USB_HW_POWER_BULK
operator||
name|USB_HW_POWER_INTERRUPT
operator||
name|USB_HW_POWER_ISOC
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Some USB transfer is "
literal|"active on unit %u.\n"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|uhci_restart
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"Power save on unit %u.\n"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|UHCICMD
argument_list|(
name|sc
argument_list|,
name|UHCI_CMD_MAXP
argument_list|)
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_bus_methods
name|uhci_bus_methods
init|=
block|{
operator|.
name|endpoint_init
operator|=
name|uhci_ep_init
block|,
operator|.
name|xfer_setup
operator|=
name|uhci_xfer_setup
block|,
operator|.
name|xfer_unsetup
operator|=
name|uhci_xfer_unsetup
block|,
operator|.
name|get_dma_delay
operator|=
name|uhci_get_dma_delay
block|,
operator|.
name|device_resume
operator|=
name|uhci_device_resume
block|,
operator|.
name|device_suspend
operator|=
name|uhci_device_suspend
block|,
operator|.
name|set_hw_power
operator|=
name|uhci_set_hw_power
block|,
operator|.
name|roothub_exec
operator|=
name|uhci_roothub_exec
block|,
operator|.
name|xfer_poll
operator|=
name|uhci_do_poll
block|, }
decl_stmt|;
end_decl_stmt

end_unit

