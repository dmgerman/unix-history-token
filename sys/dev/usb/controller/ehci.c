begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  * Copyright (c) 2004 The NetBSD Foundation, Inc. All rights reserved.  * Copyright (c) 2004 Lennart Augustsson. All rights reserved.  * Copyright (c) 2004 Charles M. Hannum. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB Enhanced Host Controller Driver, a.k.a. USB 2.0 controller.  *  * The EHCI 0.96 spec can be found at  * http://developer.intel.com/technology/usb/download/ehci-r096.pdf  * The EHCI 1.0 spec can be found at  * http://developer.intel.com/technology/usb/download/ehci-r10.pdf  * and the USB 2.0 spec at  * http://www.usb.org/developers/docs/usb_20.zip  *  */
end_comment

begin_comment
comment|/*  * TODO:   * 1) command failures are not recovered correctly  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|ehcidebug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehcireg.h>
end_include

begin_define
define|#
directive|define
name|EHCI_BUS2SC
parameter_list|(
name|bus
parameter_list|)
define|\
value|((ehci_softc_t *)(((uint8_t *)(bus)) - \     ((uint8_t *)&(((ehci_softc_t *)0)->sc_bus))))
end_define

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_decl_stmt
specifier|static
name|int
name|ehcidebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ehcinohighspeed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|ehci
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB ehci"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ehci
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ehcidebug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_ehci
argument_list|,
name|OID_AUTO
argument_list|,
name|no_hs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ehcinohighspeed
argument_list|,
literal|0
argument_list|,
literal|"Disable High Speed USB"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ehci_dump_regs
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_dump_sqh
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_qh_t
modifier|*
name|sqh
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EHCI_INTR_ENDPT
value|1
end_define

begin_decl_stmt
specifier|extern
name|struct
name|usb_bus_methods
name|ehci_bus_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ehci_device_bulk_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ehci_device_ctrl_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ehci_device_intr_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ehci_device_isoc_fs_methods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|usb_pipe_methods
name|ehci_device_isoc_hs_methods
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ehci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|usb_error_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ehci_check_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_poll_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ehci_root_intr
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|ehci_std_temp
block|{
name|ehci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td_next
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|qtd_status
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint16_t
name|max_frame_size
decl_stmt|;
name|uint8_t
name|shortpkt
decl_stmt|;
name|uint8_t
name|auto_data_toggle
decl_stmt|;
name|uint8_t
name|setup_alt_next
decl_stmt|;
name|uint8_t
name|last_frame
decl_stmt|;
name|uint8_t
name|can_use_next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|ehci_iterate_hw_softc
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|usb_bus_mem_sub_cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|EHCI_FRAMELIST_COUNT
argument_list|,
name|EHCI_FRAMELIST_ALIGN
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|bus
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|async_start_pc
argument_list|,
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|async_start_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_qh_t
argument_list|)
argument_list|,
name|EHCI_QH_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|EHCI_VIRTUAL_FRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|i
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pg
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_qh_t
argument_list|)
argument_list|,
name|EHCI_QH_ALIGN
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|EHCI_VIRTUAL_FRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_hs_start_pc
operator|+
name|i
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_hs_start_pg
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_itd_t
argument_list|)
argument_list|,
name|EHCI_ITD_ALIGN
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|EHCI_VIRTUAL_FRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|cb
argument_list|(
name|bus
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_fs_start_pc
operator|+
name|i
argument_list|,
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_fs_start_pg
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_sitd_t
argument_list|)
argument_list|,
name|EHCI_SITD_ALIGN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|usb_error_t
name|ehci_reset
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|hcr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EHCI_CMD_HCRESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator|&
name|EHCI_CMD_HCRESET
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|EHCI_SCFLG_SETMODE
operator||
name|EHCI_SCFLG_BIGEMMIO
operator|)
condition|)
block|{
comment|/* 				 * Force USBMODE as requested.  Controllers 				 * may have multiple operating modes. 				 */
name|uint32_t
name|usbmode
init|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBMODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_SETMODE
condition|)
block|{
name|usbmode
operator|=
operator|(
name|usbmode
operator|&
operator|~
name|EHCI_UM_CM
operator|)
operator||
name|EHCI_UM_CM_HOST
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"set host controller mode\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_BIGEMMIO
condition|)
block|{
name|usbmode
operator|=
operator|(
name|usbmode
operator|&
operator|~
name|EHCI_UM_ES
operator|)
operator||
name|EHCI_UM_ES_BE
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"set big-endian mode\n"
argument_list|)
expr_stmt|;
block|}
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBMODE
argument_list|,
name|usbmode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"reset timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|ehci_hcreset
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|hcr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Halt controller */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
name|hcr
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|hcr
condition|)
comment|/*                  * Fall through and try reset anyway even though                  * Table 2-9 in the EHCI spec says this will result                  * in undefined behavior.                  */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"stop timeout\n"
argument_list|)
expr_stmt|;
return|return
name|ehci_reset
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
name|usb_error_t
name|ehci_init
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|uint32_t
name|version
decl_stmt|;
name|uint32_t
name|sparams
decl_stmt|;
name|uint32_t
name|cparams
decl_stmt|;
name|uint32_t
name|hcr
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint16_t
name|y
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_poll
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|2
condition|)
block|{
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_offs
operator|=
name|EREAD1
argument_list|(
name|sc
argument_list|,
name|EHCI_CAPLENGTH
argument_list|)
expr_stmt|;
name|version
operator|=
name|EREAD2
argument_list|(
name|sc
argument_list|,
name|EHCI_HCIVERSION
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"EHCI version %x.%x\n"
argument_list|,
name|version
operator|>>
literal|8
argument_list|,
name|version
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sparams
operator|=
name|EREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCSPARAMS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"sparams=0x%x\n"
argument_list|,
name|sparams
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_noport
operator|=
name|EHCI_HCS_N_PORTS
argument_list|(
name|sparams
argument_list|)
expr_stmt|;
name|cparams
operator|=
name|EREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCCPARAMS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"cparams=0x%x\n"
argument_list|,
name|cparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|EHCI_HCC_64BIT
argument_list|(
name|cparams
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"HCC uses 64-bit structures\n"
argument_list|)
expr_stmt|;
comment|/* MUST clear segment register if 64 bit capable */
name|EWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_CTRLDSSEGMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bus
operator|.
name|usbrev
operator|=
name|USB_REV_2_0
expr_stmt|;
comment|/* Reset the controller */
name|DPRINTF
argument_list|(
literal|"%s: resetting\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ehci_hcreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"reset timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * use current frame-list-size selection 0: 1024*4 bytes 1:  512*4 	 * bytes 2:  256*4 bytes 3:      unknown 	 */
if|if
condition|(
name|EHCI_CMD_FLS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
argument_list|)
operator|==
literal|3
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"invalid frame-list-size\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
comment|/* set up the bus struct */
name|sc
operator|->
name|sc_bus
operator|.
name|methods
operator|=
operator|&
name|ehci_bus_methods
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator|=
name|EHCI_NORMAL_INTRS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_VIRTUAL_FRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
name|usbd_get_page
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|qh
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* initialize page cache pointer */
name|qh
operator|->
name|page_cache
operator|=
name|sc
operator|->
name|sc_hw
operator|.
name|intr_start_pc
operator|+
name|i
expr_stmt|;
comment|/* store a pointer to queue head */
name|sc
operator|->
name|sc_intr_p_last
index|[
name|i
index|]
operator|=
name|qh
expr_stmt|;
name|qh
operator|->
name|qh_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
operator||
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_endp
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_HIGH
argument_list|)
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_endphub
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_QH_SET_MULT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_curqtd
operator|=
literal|0
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_status
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_QTD_HALTED
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * the QHs are arranged to give poll intervals that are 	 * powers of 2 times 1ms 	 */
name|bit
operator|=
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|x
operator|=
name|bit
expr_stmt|;
while|while
condition|(
name|x
operator|&
name|bit
condition|)
block|{
name|ehci_qh_t
modifier|*
name|qh_x
decl_stmt|;
name|ehci_qh_t
modifier|*
name|qh_y
decl_stmt|;
name|y
operator|=
operator|(
name|x
operator|^
name|bit
operator|)
operator||
operator|(
name|bit
operator|/
literal|2
operator|)
expr_stmt|;
name|qh_x
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|x
index|]
expr_stmt|;
name|qh_y
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|y
index|]
expr_stmt|;
comment|/* 			 * the next QH has half the poll interval 			 */
name|qh_x
operator|->
name|qh_link
operator|=
name|qh_y
operator|->
name|qh_self
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|1
condition|)
block|{
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
name|qh
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
literal|0
index|]
expr_stmt|;
comment|/* the last (1ms) QH terminates */
name|qh
operator|->
name|qh_link
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_VIRTUAL_FRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|ehci_sitd_t
modifier|*
name|sitd
decl_stmt|;
name|ehci_itd_t
modifier|*
name|itd
decl_stmt|;
name|usbd_get_page
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_fs_start_pc
operator|+
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|sitd
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* initialize page cache pointer */
name|sitd
operator|->
name|page_cache
operator|=
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_fs_start_pc
operator|+
name|i
expr_stmt|;
comment|/* store a pointer to the transfer descriptor */
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
name|i
index|]
operator|=
name|sitd
expr_stmt|;
comment|/* initialize full speed isochronous */
name|sitd
operator|->
name|sitd_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
operator||
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_SITD
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|sitd_back
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|sitd
operator|->
name|sitd_next
operator|=
name|sc
operator|->
name|sc_intr_p_last
index|[
name|i
operator||
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|/
literal|2
operator|)
index|]
operator|->
name|qh_self
expr_stmt|;
name|usbd_get_page
argument_list|(
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_hs_start_pc
operator|+
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|itd
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* initialize page cache pointer */
name|itd
operator|->
name|page_cache
operator|=
name|sc
operator|->
name|sc_hw
operator|.
name|isoc_hs_start_pc
operator|+
name|i
expr_stmt|;
comment|/* store a pointer to the transfer descriptor */
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|i
index|]
operator|=
name|itd
expr_stmt|;
comment|/* initialize high speed isochronous */
name|itd
operator|->
name|itd_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
operator||
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_ITD
argument_list|)
expr_stmt|;
name|itd
operator|->
name|itd_next
operator|=
name|sitd
operator|->
name|sitd_self
expr_stmt|;
block|}
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|uint32_t
modifier|*
name|pframes
decl_stmt|;
name|pframes
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* 		 * execution order: 		 * pframes -> high speed isochronous -> 		 *    full speed isochronous -> interrupt QH's 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EHCI_FRAMELIST_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|pframes
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|i
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
index|]
operator|->
name|itd_self
expr_stmt|;
block|}
block|}
comment|/* setup sync list pointer */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PERIODICLISTBASE
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|async_start_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
name|qh
operator|=
name|buf_res
operator|.
name|buffer
expr_stmt|;
comment|/* initialize page cache pointer */
name|qh
operator|->
name|page_cache
operator|=
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|async_start_pc
expr_stmt|;
comment|/* store a pointer to the queue head */
name|sc
operator|->
name|sc_async_p_last
operator|=
name|qh
expr_stmt|;
comment|/* init dummy QH that starts the async list */
name|qh
operator|->
name|qh_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
operator||
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
comment|/* fill the QH */
name|qh
operator|->
name|qh_endp
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_HIGH
argument_list|)
operator||
name|EHCI_QH_HRECL
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_endphub
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_QH_SET_MULT
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_link
operator|=
name|qh
operator|->
name|qh_self
expr_stmt|;
name|qh
operator|->
name|qh_curqtd
operator|=
literal|0
expr_stmt|;
comment|/* fill the overlay qTD */
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_status
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_QTD_HALTED
argument_list|)
expr_stmt|;
block|}
comment|/* flush all cache into memory */
name|usb_bus_mem_flush_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
operator|&
name|ehci_iterate_hw_softc
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
condition|)
block|{
name|ehci_dump_sqh
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_async_p_last
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* setup async list pointer */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_ASYNCLISTADDR
argument_list|,
name|buf_res
operator|.
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
comment|/* turn on controller */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|EHCI_CMD_ITC_1
operator||
comment|/* 1 microframes interrupt delay */
operator|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
operator|&
name|EHCI_CMD_FLS_M
operator|)
operator||
name|EHCI_CMD_ASE
operator||
name|EHCI_CMD_PSE
operator||
name|EHCI_CMD_RS
argument_list|)
expr_stmt|;
comment|/* Take over port ownership */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_CONFIGFLAG
argument_list|,
name|EHCI_CONF_CF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
operator|!
name|hcr
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"run timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_IOERROR
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* catch any lost interrupts */
name|ehci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * shut down the controller when the system is going down  */
end_comment

begin_function
name|void
name|ehci_detach
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|usb_callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|)
expr_stmt|;
name|usb_callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_poll
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehci_hcreset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"reset failed!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX let stray task complete */
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|usb_callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|)
expr_stmt|;
name|usb_callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_poll
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_suspend
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|cmd
decl_stmt|;
name|uint32_t
name|hcr
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PO
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PE
operator|)
operator|==
name|EHCI_PS_PE
operator|)
condition|)
block|{
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|,
name|cmd
operator||
name|EHCI_PS_SUSP
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|sc
operator|->
name|sc_cmd
operator|&
operator|~
operator|(
name|EHCI_CMD_ASE
operator||
name|EHCI_CMD_PSE
operator|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
operator|(
name|EHCI_STS_ASS
operator||
name|EHCI_STS_PSS
operator|)
expr_stmt|;
if|if
condition|(
name|hcr
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hcr
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"reset timeout\n"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|&=
operator|~
name|EHCI_CMD_RS
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
name|hcr
operator|==
name|EHCI_STS_HCH
condition|)
block|{
break|break;
block|}
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hcr
operator|!=
name|EHCI_STS_HCH
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"config timeout\n"
argument_list|)
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_resume
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|uint32_t
name|cmd
decl_stmt|;
name|uint32_t
name|hcr
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
comment|/* restore things in case the bios doesn't */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_CTRLDSSEGMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|pframes_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PERIODICLISTBASE
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|usbd_get_page
argument_list|(
operator|&
name|sc
operator|->
name|sc_hw
operator|.
name|async_start_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_ASYNCLISTADDR
argument_list|,
name|buf_res
operator|.
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|hcr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PO
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|&
name|EHCI_PS_SUSP
operator|)
operator|==
name|EHCI_PS_SUSP
operator|)
condition|)
block|{
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|,
name|cmd
operator||
name|EHCI_PS_FPR
argument_list|)
expr_stmt|;
name|hcr
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hcr
condition|)
block|{
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_WAIT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cmd
operator|&
name|EHCI_PS_PO
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|&
name|EHCI_PS_SUSP
operator|)
operator|==
name|EHCI_PS_SUSP
operator|)
condition|)
block|{
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|,
name|cmd
operator|&
operator|~
name|EHCI_PS_FPR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|sc
operator|->
name|sc_cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hcr
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
operator|&
name|EHCI_STS_HCH
expr_stmt|;
if|if
condition|(
name|hcr
operator|!=
name|EHCI_STS_HCH
condition|)
block|{
break|break;
block|}
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hcr
operator|==
name|EHCI_STS_HCH
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"config timeout\n"
argument_list|)
expr_stmt|;
block|}
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_RESUME_WAIT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* catch any lost interrupts */
name|ehci_do_poll
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ehci_shutdown
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"stopping the HC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehci_hcreset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"reset failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|USB_DEBUG
end_if

begin_function
specifier|static
name|void
name|ehci_dump_regs
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd=0x%08x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_1
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_2
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_4
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_4\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_8
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_8\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_16
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_16\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_32
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_32\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ITC_64
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ITC_64\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ASPME
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ASPME\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ASPMC
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ASPMC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_LHCR
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_LHCR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_IAAD
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_IAAD\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_ASE
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_ASE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_PSE
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_PSE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_FLS_M
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_FLS_M\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_HCRESET
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_HCRESET\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_CMD_RS
condition|)
name|printf
argument_list|(
literal|" EHCI_CMD_RS\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sts=0x%08x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_ASS
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_ASS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_PSS
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_PSS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_REC
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_REC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_HCH
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_HCH\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_IAA
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_IAA\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_HSE
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_HSE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_FLR
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_FLR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_PCD
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_PCD\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_ERRINT
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_ERRINT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|EHCI_STS_INT
condition|)
name|printf
argument_list|(
literal|" EHCI_STS_INT\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ien=0x%08x\n"
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n"
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_FRINDEX
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_CTRLDSSEGMENT
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PERIODICLISTBASE
argument_list|)
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_ASYNCLISTADDR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|sc
operator|->
name|sc_noport
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"port %d status=0x%08x\n"
argument_list|,
name|i
argument_list|,
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_link
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|link
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|link
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x"
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|&
name|EHCI_LINK_TERMINATE
condition|)
name|printf
argument_list|(
literal|"<T>"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
switch|switch
condition|(
name|EHCI_LINK_TYPE
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
name|EHCI_LINK_ITD
case|:
name|printf
argument_list|(
literal|"ITD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHCI_LINK_QH
case|:
name|printf
argument_list|(
literal|"QH"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHCI_LINK_SITD
case|:
name|printf
argument_list|(
literal|"SITD"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHCI_LINK_FSTN
case|:
name|printf
argument_list|(
literal|"FSTN"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_qtd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_qtd_t
modifier|*
name|qtd
parameter_list|)
block|{
name|uint32_t
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"  next="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|sc
argument_list|,
name|qtd
operator|->
name|qtd_next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" altnext="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|sc
argument_list|,
name|qtd
operator|->
name|qtd_altnext
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qtd
operator|->
name|qtd_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  status=0x%08x: toggle=%d bytes=0x%x ioc=%d c_page=0x%x\n"
argument_list|,
name|s
argument_list|,
name|EHCI_QTD_GET_TOGGLE
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_BYTES
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_IOC
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_C_PAGE
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cerr=%d pid=%d stat=%s%s%s%s%s%s%s%s\n"
argument_list|,
name|EHCI_QTD_GET_CERR
argument_list|(
name|s
argument_list|)
argument_list|,
name|EHCI_QTD_GET_PID
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_ACTIVE
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|"NOT_ACTIVE"
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_HALTED
operator|)
condition|?
literal|"-HALTED"
else|:
literal|""
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_BUFERR
operator|)
condition|?
literal|"-BUFERR"
else|:
literal|""
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_BABBLE
operator|)
condition|?
literal|"-BABBLE"
else|:
literal|""
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_XACTERR
operator|)
condition|?
literal|"-XACTERR"
else|:
literal|""
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_MISSEDMICRO
operator|)
condition|?
literal|"-MISSED"
else|:
literal|""
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_SPLITXSTATE
operator|)
condition|?
literal|"-SPLIT"
else|:
literal|""
argument_list|,
operator|(
name|s
operator|&
name|EHCI_QTD_PINGSTATE
operator|)
condition|?
literal|"-PING"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|5
condition|;
name|s
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  buffer[%d]=0x%08x\n"
argument_list|,
name|s
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qtd
operator|->
name|qtd_buffer
index|[
name|s
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|5
condition|;
name|s
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  buffer_hi[%d]=0x%08x\n"
argument_list|,
name|s
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qtd
operator|->
name|qtd_buffer_hi
index|[
name|s
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ehci_dump_sqtd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_qtd_t
modifier|*
name|sqtd
parameter_list|)
block|{
name|uint8_t
name|temp
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|sqtd
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"QTD(%p) at 0x%08x:\n"
argument_list|,
name|sqtd
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sqtd
operator|->
name|qtd_self
argument_list|)
argument_list|)
expr_stmt|;
name|ehci_dump_qtd
argument_list|(
name|sc
argument_list|,
name|sqtd
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|sqtd
operator|->
name|qtd_next
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_sqtds
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_qtd_t
modifier|*
name|sqtd
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
name|stop
decl_stmt|;
name|stop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sqtd
operator|&&
operator|(
name|i
operator|<
literal|20
operator|)
operator|&&
operator|!
name|stop
condition|;
name|sqtd
operator|=
name|sqtd
operator|->
name|obj_next
operator|,
name|i
operator|++
control|)
block|{
name|stop
operator|=
name|ehci_dump_sqtd
argument_list|(
name|sc
argument_list|,
name|sqtd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sqtd
condition|)
block|{
name|printf
argument_list|(
literal|"dump aborted, too many TDs\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_sqh
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_qh_t
modifier|*
name|qh
parameter_list|)
block|{
name|uint32_t
name|endp
decl_stmt|;
name|uint32_t
name|endphub
decl_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"QH(%p) at 0x%08x:\n"
argument_list|,
name|qh
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_self
argument_list|)
operator|&
operator|~
literal|0x1F
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  link="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|endp
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_endp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  endp=0x%08x\n"
argument_list|,
name|endp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n"
argument_list|,
name|EHCI_QH_GET_ADDR
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_INACT
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_ENDPT
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_EPS
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_DTC
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_HRECL
argument_list|(
name|endp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    mpl=0x%x ctl=%d nrl=%d\n"
argument_list|,
name|EHCI_QH_GET_MPL
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_CTL
argument_list|(
name|endp
argument_list|)
argument_list|,
name|EHCI_QH_GET_NRL
argument_list|(
name|endp
argument_list|)
argument_list|)
expr_stmt|;
name|endphub
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_endphub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  endphub=0x%08x\n"
argument_list|,
name|endphub
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n"
argument_list|,
name|EHCI_QH_GET_SMASK
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_CMASK
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_HUBA
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_PORT
argument_list|(
name|endphub
argument_list|)
argument_list|,
name|EHCI_QH_GET_MULT
argument_list|(
name|endphub
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  curqtd="
argument_list|)
expr_stmt|;
name|ehci_dump_link
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_curqtd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Overlay qTD:\n"
argument_list|)
expr_stmt|;
name|ehci_dump_qtd
argument_list|(
name|sc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|qh
operator|->
name|qh_qtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_sitd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_sitd_t
modifier|*
name|sitd
parameter_list|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|sitd
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SITD(%p) at 0x%08x\n"
argument_list|,
name|sitd
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_self
argument_list|)
operator|&
operator|~
literal|0x1F
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" next=0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_next
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" portaddr=0x%08x dir=%s addr=%d endpt=0x%x port=0x%x huba=0x%x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_portaddr
argument_list|)
argument_list|,
operator|(
name|sitd
operator|->
name|sitd_portaddr
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_SITD_SET_DIR_IN
argument_list|)
operator|)
condition|?
literal|"in"
else|:
literal|"out"
argument_list|,
name|EHCI_SITD_GET_ADDR
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_portaddr
argument_list|)
argument_list|)
argument_list|,
name|EHCI_SITD_GET_ENDPT
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_portaddr
argument_list|)
argument_list|)
argument_list|,
name|EHCI_SITD_GET_PORT
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_portaddr
argument_list|)
argument_list|)
argument_list|,
name|EHCI_SITD_GET_HUBA
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_portaddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" mask=0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_mask
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status=0x%08x<%s> len=0x%x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_status
argument_list|)
argument_list|,
operator|(
name|sitd
operator|->
name|sitd_status
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_SITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|,
name|EHCI_SITD_GET_LEN
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_status
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" back=0x%08x, bp=0x%08x,0x%08x,0x%08x,0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_back
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_bp
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_bp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_bp_hi
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|sitd
operator|->
name|sitd_bp_hi
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_itd
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|ehci_itd_t
modifier|*
name|itd
parameter_list|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|itd
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ITD(%p) at 0x%08x\n"
argument_list|,
name|itd
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_self
argument_list|)
operator|&
operator|~
literal|0x1F
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" next=0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_next
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[0]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|0
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[1]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|1
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[2]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|2
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|2
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[3]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|3
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|3
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[4]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|4
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|4
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[5]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|5
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|5
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[6]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|6
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|6
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status[7]=0x%08x;<%s>\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_status
index|[
literal|7
index|]
argument_list|)
argument_list|,
operator|(
name|itd
operator|->
name|itd_status
index|[
literal|7
index|]
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|?
literal|"ACTIVE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bp[0]=0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  addr=0x%02x; endpt=0x%01x\n"
argument_list|,
name|EHCI_ITD_GET_ADDR
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
name|EHCI_ITD_GET_ENDPT
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bp[1]=0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dir=%s; mpl=0x%02x\n"
argument_list|,
operator|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|1
index|]
argument_list|)
operator|&
name|EHCI_ITD_SET_DIR_IN
operator|)
condition|?
literal|"in"
else|:
literal|"out"
argument_list|,
name|EHCI_ITD_GET_MPL
argument_list|(
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bp[2..6]=0x%08x,0x%08x,0x%08x,0x%08x,0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bp_hi=0x%08x,0x%08x,0x%08x,0x%08x,\n"
literal|"       0x%08x,0x%08x,0x%08x\n"
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|4
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|5
index|]
argument_list|)
argument_list|,
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|itd
operator|->
name|itd_bp_hi
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_dump_isoc
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ehci_itd_t
modifier|*
name|itd
decl_stmt|;
name|ehci_sitd_t
modifier|*
name|sitd
decl_stmt|;
name|uint16_t
name|max
init|=
literal|1000
decl_stmt|;
name|uint16_t
name|pos
decl_stmt|;
name|pos
operator|=
operator|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_FRINDEX
argument_list|)
operator|/
literal|8
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: isochronous dump from frame 0x%03x:\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|itd
operator|=
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|pos
index|]
expr_stmt|;
name|sitd
operator|=
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
name|pos
index|]
expr_stmt|;
while|while
condition|(
name|itd
operator|&&
name|max
operator|&&
name|max
operator|--
condition|)
block|{
name|ehci_dump_itd
argument_list|(
name|sc
argument_list|,
name|itd
argument_list|)
expr_stmt|;
name|itd
operator|=
name|itd
operator|->
name|prev
expr_stmt|;
block|}
while|while
condition|(
name|sitd
operator|&&
name|max
operator|&&
name|max
operator|--
condition|)
block|{
name|ehci_dump_sitd
argument_list|(
name|sc
argument_list|,
name|sitd
argument_list|)
expr_stmt|;
name|sitd
operator|=
name|sitd
operator|->
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ehci_transfer_intr_enqueue
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* check for early completion */
if|if
condition|(
name|ehci_check_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* put transfer on interrupt queue */
name|usbd_transfer_enqueue
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|intr_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* start timeout, if any */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|!=
literal|0
condition|)
block|{
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|ehci_timeout
argument_list|,
name|xfer
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|EHCI_APPEND_FS_TD
parameter_list|(
name|std
parameter_list|,
name|last
parameter_list|)
value|(last) = _ehci_append_fs_td(std,last)
end_define

begin_function
specifier|static
name|ehci_sitd_t
modifier|*
name|_ehci_append_fs_td
parameter_list|(
name|ehci_sitd_t
modifier|*
name|std
parameter_list|,
name|ehci_sitd_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p to %p\n"
argument_list|,
name|std
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
name|std
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|std
operator|->
name|sitd_next
operator|=
name|last
operator|->
name|sitd_next
expr_stmt|;
name|std
operator|->
name|prev
operator|=
name|last
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 	 * the last->next->prev is never followed: std->next->prev = std; 	 */
name|last
operator|->
name|next
operator|=
name|std
expr_stmt|;
name|last
operator|->
name|sitd_next
operator|=
name|std
operator|->
name|sitd_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|std
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EHCI_APPEND_HS_TD
parameter_list|(
name|std
parameter_list|,
name|last
parameter_list|)
value|(last) = _ehci_append_hs_td(std,last)
end_define

begin_function
specifier|static
name|ehci_itd_t
modifier|*
name|_ehci_append_hs_td
parameter_list|(
name|ehci_itd_t
modifier|*
name|std
parameter_list|,
name|ehci_itd_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p to %p\n"
argument_list|,
name|std
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
name|std
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|std
operator|->
name|itd_next
operator|=
name|last
operator|->
name|itd_next
expr_stmt|;
name|std
operator|->
name|prev
operator|=
name|last
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 	 * the last->next->prev is never followed: std->next->prev = std; 	 */
name|last
operator|->
name|next
operator|=
name|std
expr_stmt|;
name|last
operator|->
name|itd_next
operator|=
name|std
operator|->
name|itd_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|std
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EHCI_APPEND_QH
parameter_list|(
name|sqh
parameter_list|,
name|last
parameter_list|)
value|(last) = _ehci_append_qh(sqh,last)
end_define

begin_function
specifier|static
name|ehci_qh_t
modifier|*
name|_ehci_append_qh
parameter_list|(
name|ehci_qh_t
modifier|*
name|sqh
parameter_list|,
name|ehci_qh_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p to %p\n"
argument_list|,
name|sqh
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
comment|/* should not happen */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"QH already linked!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|last
operator|)
return|;
block|}
comment|/* (sc->sc_bus.mtx) must be locked */
name|sqh
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|sqh
operator|->
name|qh_link
operator|=
name|last
operator|->
name|qh_link
expr_stmt|;
name|sqh
operator|->
name|prev
operator|=
name|last
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* 	 * the last->next->prev is never followed: sqh->next->prev = sqh; 	 */
name|last
operator|->
name|next
operator|=
name|sqh
expr_stmt|;
name|last
operator|->
name|qh_link
operator|=
name|sqh
operator|->
name|qh_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|last
operator|->
name|page_cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|sqh
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EHCI_REMOVE_FS_TD
parameter_list|(
name|std
parameter_list|,
name|last
parameter_list|)
value|(last) = _ehci_remove_fs_td(std,last)
end_define

begin_function
specifier|static
name|ehci_sitd_t
modifier|*
name|_ehci_remove_fs_td
parameter_list|(
name|ehci_sitd_t
modifier|*
name|std
parameter_list|,
name|ehci_sitd_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p from %p\n"
argument_list|,
name|std
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
name|std
operator|->
name|prev
operator|->
name|next
operator|=
name|std
operator|->
name|next
expr_stmt|;
name|std
operator|->
name|prev
operator|->
name|sitd_next
operator|=
name|std
operator|->
name|sitd_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|prev
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|next
condition|)
block|{
name|std
operator|->
name|next
operator|->
name|prev
operator|=
name|std
operator|->
name|prev
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|next
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|last
operator|==
name|std
operator|)
condition|?
name|std
operator|->
name|prev
else|:
name|last
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EHCI_REMOVE_HS_TD
parameter_list|(
name|std
parameter_list|,
name|last
parameter_list|)
value|(last) = _ehci_remove_hs_td(std,last)
end_define

begin_function
specifier|static
name|ehci_itd_t
modifier|*
name|_ehci_remove_hs_td
parameter_list|(
name|ehci_itd_t
modifier|*
name|std
parameter_list|,
name|ehci_itd_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p from %p\n"
argument_list|,
name|std
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
name|std
operator|->
name|prev
operator|->
name|next
operator|=
name|std
operator|->
name|next
expr_stmt|;
name|std
operator|->
name|prev
operator|->
name|itd_next
operator|=
name|std
operator|->
name|itd_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|prev
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|->
name|next
condition|)
block|{
name|std
operator|->
name|next
operator|->
name|prev
operator|=
name|std
operator|->
name|prev
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|std
operator|->
name|next
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|last
operator|==
name|std
operator|)
condition|?
name|std
operator|->
name|prev
else|:
name|last
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EHCI_REMOVE_QH
parameter_list|(
name|sqh
parameter_list|,
name|last
parameter_list|)
value|(last) = _ehci_remove_qh(sqh,last)
end_define

begin_function
specifier|static
name|ehci_qh_t
modifier|*
name|_ehci_remove_qh
parameter_list|(
name|ehci_qh_t
modifier|*
name|sqh
parameter_list|,
name|ehci_qh_t
modifier|*
name|last
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"%p from %p\n"
argument_list|,
name|sqh
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* (sc->sc_bus.mtx) must be locked */
comment|/* only remove if not removed from a queue */
if|if
condition|(
name|sqh
operator|->
name|prev
condition|)
block|{
name|sqh
operator|->
name|prev
operator|->
name|next
operator|=
name|sqh
operator|->
name|next
expr_stmt|;
name|sqh
operator|->
name|prev
operator|->
name|qh_link
operator|=
name|sqh
operator|->
name|qh_link
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|prev
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqh
operator|->
name|next
condition|)
block|{
name|sqh
operator|->
name|next
operator|->
name|prev
operator|=
name|sqh
operator|->
name|prev
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|next
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
operator|(
operator|(
name|last
operator|==
name|sqh
operator|)
condition|?
name|sqh
operator|->
name|prev
else|:
name|last
operator|)
expr_stmt|;
name|sqh
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|sqh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|ehci_non_isoc_done_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|td_alt_next
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|td
operator|->
name|qtd_status
argument_list|)
expr_stmt|;
name|len
operator|=
name|EHCI_QTD_GET_BYTES
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* 	         * Verify the status length and 		 * add the length to "frlengths[]": 	         */
if|if
condition|(
name|len
operator|>
name|td
operator|->
name|len
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
literal|"Invalid status length, "
literal|"0x%04x/0x%04x bytes\n"
argument_list|,
name|len
argument_list|,
name|td
operator|->
name|len
argument_list|)
expr_stmt|;
name|status
operator||=
name|EHCI_QTD_HALTED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|xfer
operator|->
name|frlengths
index|[
name|xfer
operator|->
name|aframes
index|]
operator|+=
name|td
operator|->
name|len
operator|-
name|len
expr_stmt|;
block|}
comment|/* Check for last transfer */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for transfer error */
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_HALTED
condition|)
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check for short transfer */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
comment|/* follow alt next */
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
block|}
else|else
block|{
comment|/* the transfer is finished */
name|td
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|alt_next
operator|!=
name|td_alt_next
condition|)
block|{
comment|/* this USB frame is complete */
break|break;
block|}
block|}
comment|/* update transfer cache */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_STATERRS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"error, addr=%d, endpt=0x%02x, frame=0x%02x"
literal|"status=%s%s%s%s%s%s%s%s\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|xfer
operator|->
name|endpointno
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_ACTIVE
operator|)
condition|?
literal|"[ACTIVE]"
else|:
literal|"[NOT_ACTIVE]"
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_HALTED
operator|)
condition|?
literal|"[HALTED]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_BUFERR
operator|)
condition|?
literal|"[BUFERR]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_BABBLE
operator|)
condition|?
literal|"[BABBLE]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_XACTERR
operator|)
condition|?
literal|"[XACTERR]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_MISSEDMICRO
operator|)
condition|?
literal|"[MISSED]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_SPLITXSTATE
operator|)
condition|?
literal|"[SPLIT]"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|EHCI_QTD_PINGSTATE
operator|)
condition|?
literal|"[PING]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|(
name|status
operator|&
name|EHCI_QTD_HALTED
operator|)
condition|?
name|USB_ERR_STALLED
else|:
name|USB_ERR_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_non_isoc_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|usb_error_t
name|err
init|=
literal|0
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|10
condition|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|sc
argument_list|,
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* extract data toggle directly from the QH's overlay area */
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_status
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
operator|=
operator|(
name|status
operator|&
name|EHCI_QTD_TOGGLE_MASK
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* reset scanner */
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|err
operator|=
name|ehci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
while|while
condition|(
name|xfer
operator|->
name|aframes
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
name|err
operator|=
name|ehci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|err
operator|=
name|ehci_non_isoc_done_sub
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ehci_check_transfer  *  * Return values:  *    0: USB transfer is not finished  * Else: USB transfer is finished  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|ehci_check_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_pipe_methods
modifier|*
name|methods
init|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p checking transfer\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_isoc_fs_methods
condition|)
block|{
name|ehci_sitd_t
modifier|*
name|td
decl_stmt|;
comment|/* isochronous full speed transfer */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_last
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|td
operator|->
name|sitd_status
argument_list|)
expr_stmt|;
comment|/* also check if first is complete */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator||=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|td
operator|->
name|sitd_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|EHCI_SITD_ACTIVE
operator|)
condition|)
block|{
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
expr_stmt|;
goto|goto
name|transferred
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_isoc_hs_methods
condition|)
block|{
name|ehci_itd_t
modifier|*
name|td
decl_stmt|;
comment|/* isochronous high speed transfer */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_last
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|td
operator|->
name|itd_status
index|[
literal|0
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|1
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|2
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|3
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|4
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|5
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|6
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|7
index|]
expr_stmt|;
comment|/* also check first transfer */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator||=
name|td
operator|->
name|itd_status
index|[
literal|0
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|1
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|2
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|3
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|4
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|5
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|6
index|]
operator||
name|td
operator|->
name|itd_status
index|[
literal|7
index|]
expr_stmt|;
comment|/* if no transactions are active we continue */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
expr_stmt|;
goto|goto
name|transferred
goto|;
block|}
block|}
else|else
block|{
name|ehci_qtd_t
modifier|*
name|td
decl_stmt|;
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
comment|/* non-isochronous transfer */
comment|/* 		 * check whether there is an error somewhere in the middle, 		 * or whether there was a short packet (SPD and not ACTIVE) 		 */
name|td
operator|=
name|xfer
operator|->
name|td_transfer_cache
expr_stmt|;
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|usb_pc_cpu_invalidate
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_ACTIVE
condition|)
block|{
comment|/* transfer is pending */
goto|goto
name|done
goto|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|td
operator|->
name|qtd_status
argument_list|)
expr_stmt|;
comment|/* 			 * Check if there is an active TD which 			 * indicates that the transfer isn't done. 			 */
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_ACTIVE
condition|)
block|{
comment|/* update cache */
if|if
condition|(
name|xfer
operator|->
name|td_transfer_cache
operator|!=
name|td
condition|)
block|{
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
if|if
condition|(
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_next
operator|&
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
condition|)
block|{
comment|/* XXX - manually advance to next frame */
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|td
operator|->
name|qtd_self
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 			 * last transfer descriptor makes the transfer done 			 */
if|if
condition|(
operator|(
operator|(
name|void
operator|*
operator|)
name|td
operator|)
operator|==
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
break|break;
block|}
comment|/* 			 * any kind of error makes the transfer done 			 */
if|if
condition|(
name|status
operator|&
name|EHCI_QTD_HALTED
condition|)
block|{
break|break;
block|}
comment|/* 			 * if there is no alternate next transfer, a short 			 * packet also makes the transfer done 			 */
if|if
condition|(
name|EHCI_QTD_GET_BYTES
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
condition|)
block|{
comment|/* follow alt next */
if|if
condition|(
name|td
operator|->
name|alt_next
condition|)
block|{
name|td
operator|=
name|td
operator|->
name|alt_next
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* transfer is done */
break|break;
block|}
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|ehci_non_isoc_done
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|transferred
goto|;
block|}
name|done
label|:
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p is still active\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|transferred
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_pcd_enable
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eintrs
operator||=
name|EHCI_STS_PCD
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
comment|/* acknowledge any PCD interrupt */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|,
name|EHCI_STS_PCD
argument_list|)
expr_stmt|;
name|ehci_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_interrupt_poll
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|repeat
label|:
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
comment|/* 		 * check if transfer is transferred 		 */
if|if
condition|(
name|ehci_check_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
comment|/* queue has been modified */
goto|goto
name|repeat
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Some EHCI chips from VIA / ATI seem to trigger interrupts before  * writing back the qTD status, or miss signalling occasionally under  * heavy load.  If the host machine is too fast, we can miss  * transaction completion - when we scan the active list the  * transaction still seems to be active. This generally exhibits  * itself as a umass stall that never recovers.  *  * We work around this behaviour by setting up this callback after any  * softintr that completes with transactions still pending, giving us  * another chance to check for completion after the writeback has  * taken place.  */
end_comment

begin_function
specifier|static
name|void
name|ehci_poll_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ehci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	ehci_interrupt - EHCI interrupt handler  *  * NOTE: Do not access "sc->sc_bus.bdev" inside the interrupt handler,  * hence the interrupt handler will be setup before "sc->sc_bus.bdev"  * is present !  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|ehci_interrupt
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"real interrupt\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|15
condition|)
block|{
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|EHCI_STS_INTRS
argument_list|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* the interrupt was not for us */
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|sc
operator|->
name|sc_eintrs
operator|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBSTS
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* acknowledge */
name|status
operator|&=
name|sc
operator|->
name|sc_eintrs
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|EHCI_STS_HSE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unrecoverable error, "
literal|"controller halted\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
name|ehci_dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ehci_dump_isoc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|EHCI_STS_PCD
condition|)
block|{
comment|/* 		 * Disable PCD interrupt for now, because it will be 		 * on until the port has been reset. 		 */
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|EHCI_STS_PCD
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|ehci_root_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* do not allow RHSC interrupts> 1 per second */
name|usb_callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_pcd
argument_list|,
name|hz
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ehci_pcd_enable
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|status
operator|&=
operator|~
operator|(
name|EHCI_STS_INT
operator||
name|EHCI_STS_ERRINT
operator||
name|EHCI_STS_PCD
operator||
name|EHCI_STS_IAA
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* block unprocessed interrupts */
name|sc
operator|->
name|sc_eintrs
operator|&=
operator|~
name|status
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
name|sc
operator|->
name|sc_eintrs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: blocking interrupts 0x%x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* poll all the USB transfers */
name|ehci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_LOSTINTRBUG
condition|)
block|{
name|usb_callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tmo_poll
argument_list|,
name|hz
operator|/
literal|128
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ehci_poll_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called when a request does not complete  */
end_comment

begin_function
specifier|static
name|void
name|ehci_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"xfer=%p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* transfer is transferred */
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_do_poll
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|ehci_interrupt_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_setup_standard_chain_sub
parameter_list|(
name|struct
name|ehci_std_temp
modifier|*
name|temp
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td_next
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td_alt_next
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint32_t
name|average
decl_stmt|;
name|uint32_t
name|len_old
decl_stmt|;
name|uint32_t
name|terminate
decl_stmt|;
name|uint8_t
name|shortpkt_old
decl_stmt|;
name|uint8_t
name|precompute
decl_stmt|;
name|terminate
operator|=
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|shortpkt_old
operator|=
name|temp
operator|->
name|shortpkt
expr_stmt|;
name|len_old
operator|=
name|temp
operator|->
name|len
expr_stmt|;
name|precompute
operator|=
literal|1
expr_stmt|;
name|restart
label|:
name|td
operator|=
name|temp
operator|->
name|td
expr_stmt|;
name|td_next
operator|=
name|temp
operator|->
name|td_next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|shortpkt
condition|)
block|{
break|break;
block|}
comment|/* send a Zero Length Packet, ZLP, last */
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
name|average
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|average
operator|=
name|temp
operator|->
name|average
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|len
operator|<
name|average
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|len
operator|%
name|temp
operator|->
name|max_frame_size
condition|)
block|{
name|temp
operator|->
name|shortpkt
operator|=
literal|1
expr_stmt|;
block|}
name|average
operator|=
name|temp
operator|->
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|td_next
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s: out of EHCI transfer descriptors!"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* get next TD */
name|td
operator|=
name|td_next
expr_stmt|;
name|td_next
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
comment|/* check if we are pre-computing */
if|if
condition|(
name|precompute
condition|)
block|{
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
continue|continue;
block|}
comment|/* fill out current TD */
name|td
operator|->
name|qtd_status
operator|=
name|temp
operator|->
name|qtd_status
operator||
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|EHCI_QTD_IOC
operator||
name|EHCI_QTD_SET_BYTES
argument_list|(
name|average
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|average
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|auto_data_toggle
operator|==
literal|0
condition|)
block|{
comment|/* update data toggle, ZLP case */
name|temp
operator|->
name|qtd_status
operator|^=
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|EHCI_QTD_TOGGLE_MASK
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|qtd_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|qtd_buffer_hi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|qtd_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|qtd_buffer_hi
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|temp
operator|->
name|auto_data_toggle
operator|==
literal|0
condition|)
block|{
comment|/* update data toggle */
if|if
condition|(
operator|(
operator|(
name|average
operator|+
name|temp
operator|->
name|max_frame_size
operator|-
literal|1
operator|)
operator|/
name|temp
operator|->
name|max_frame_size
operator|)
operator|&
literal|1
condition|)
block|{
name|temp
operator|->
name|qtd_status
operator|^=
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|EHCI_QTD_TOGGLE_MASK
argument_list|)
expr_stmt|;
block|}
block|}
name|td
operator|->
name|len
operator|=
name|average
expr_stmt|;
comment|/* update remaining length */
name|temp
operator|->
name|len
operator|-=
name|average
expr_stmt|;
comment|/* fill out buffer pointers */
name|usbd_get_page
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|buf_offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_buffer
index|[
literal|0
index|]
operator|=
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_buffer_hi
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|average
operator|>
name|EHCI_PAGE_SIZE
condition|)
block|{
name|average
operator|-=
name|EHCI_PAGE_SIZE
expr_stmt|;
name|buf_offset
operator|+=
name|EHCI_PAGE_SIZE
expr_stmt|;
name|usbd_get_page
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|buf_offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_buffer
index|[
name|x
index|]
operator|=
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
operator|&
operator|(
operator|~
literal|0xFFF
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_buffer_hi
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
comment|/* 			 * NOTE: The "average" variable is never zero after 			 * exiting the loop above ! 			 * 			 * NOTE: We have to subtract one from the offset to 			 * ensure that we are computing the physical address 			 * of a valid page ! 			 */
name|buf_offset
operator|+=
name|average
expr_stmt|;
name|usbd_get_page
argument_list|(
name|temp
operator|->
name|pc
argument_list|,
name|buf_offset
operator|-
literal|1
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_buffer
index|[
name|x
index|]
operator|=
name|htohc32
argument_list|(
name|temp
operator|->
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
operator|&
operator|(
operator|~
literal|0xFFF
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_buffer_hi
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|->
name|can_use_next
condition|)
block|{
if|if
condition|(
name|td_next
condition|)
block|{
comment|/* link the current TD with the next one */
name|td
operator|->
name|qtd_next
operator|=
name|td_next
operator|->
name|qtd_self
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * BUG WARNING: The EHCI HW can use the 			 * qtd_next field instead of qtd_altnext when 			 * a short packet is received! We work this 			 * around in software by not queueing more 			 * than one job/TD at a time! 			 */
name|td
operator|->
name|qtd_next
operator|=
name|terminate
expr_stmt|;
block|}
name|td
operator|->
name|qtd_altnext
operator|=
name|terminate
expr_stmt|;
name|td
operator|->
name|alt_next
operator|=
name|td_alt_next
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precompute
condition|)
block|{
name|precompute
operator|=
literal|0
expr_stmt|;
comment|/* setup alt next pointer, if any */
if|if
condition|(
name|temp
operator|->
name|last_frame
condition|)
block|{
name|td_alt_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* we use this field internally */
name|td_alt_next
operator|=
name|td_next
expr_stmt|;
block|}
comment|/* restore */
name|temp
operator|->
name|shortpkt
operator|=
name|shortpkt_old
expr_stmt|;
name|temp
operator|->
name|len
operator|=
name|len_old
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|temp
operator|->
name|td
operator|=
name|td
expr_stmt|;
name|temp
operator|->
name|td_next
operator|=
name|td_next
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_setup_standard_chain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|ehci_qh_t
modifier|*
modifier|*
name|qh_last
parameter_list|)
block|{
name|struct
name|ehci_std_temp
name|temp
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
name|ehci_qtd_t
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|qh_endp
decl_stmt|;
name|uint32_t
name|qh_endphub
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"addr=%d endpt=%d sumlen=%d speed=%d\n"
argument_list|,
name|xfer
operator|->
name|address
argument_list|,
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|,
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|average
operator|=
name|xfer
operator|->
name|max_hc_frame_size
expr_stmt|;
name|temp
operator|.
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
name|temp
operator|.
name|sc
operator|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|xfer
operator|->
name|td_transfer_cache
operator|=
name|td
expr_stmt|;
name|temp
operator|.
name|td
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|td_next
operator|=
name|td
expr_stmt|;
name|temp
operator|.
name|qtd_status
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
expr_stmt|;
name|temp
operator|.
name|can_use_next
operator|=
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|||
operator|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_OUT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
condition|)
block|{
comment|/* DATA1 is next */
name|temp
operator|.
name|qtd_status
operator||=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|temp
operator|.
name|auto_data_toggle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|.
name|auto_data_toggle
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
operator|!=
name|USB_SPEED_HIGH
condition|)
block|{
comment|/* max 3 retries */
name|temp
operator|.
name|qtd_status
operator||=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should prepend a setup message */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
name|temp
operator|.
name|qtd_status
operator|&=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|qtd_status
operator||=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|EHCI_QTD_PID_SETUP
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
literal|0
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
name|temp
operator|.
name|len
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for last frame */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|1
condition|)
block|{
comment|/* no STATUS stage yet, SETUP is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ehci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|)
block|{
comment|/* DATA0 / DATA1 message */
name|temp
operator|.
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|xfer
operator|->
name|frbuffers
operator|+
name|x
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* no STATUS stage yet, DATA is last */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* keep previous data toggle and error count */
name|temp
operator|.
name|qtd_status
operator|&=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|len
operator|==
literal|0
condition|)
block|{
comment|/* make sure that we send an USB packet */
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regular data transfer */
name|temp
operator|.
name|shortpkt
operator|=
operator|(
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
comment|/* set endpoint direction */
name|temp
operator|.
name|qtd_status
operator||=
operator|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
operator|)
condition|?
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|EHCI_QTD_PID_IN
argument_list|)
argument_list|)
else|:
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|EHCI_QTD_PID_OUT
argument_list|)
argument_list|)
expr_stmt|;
name|ehci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* check if we should append a status stage */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|&&
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* 		 * Send a DATA1 message and invert the current endpoint 		 * direction. 		 */
name|temp
operator|.
name|qtd_status
operator|&=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_SET_CERR
argument_list|(
literal|3
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|qtd_status
operator||=
operator|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_OUT
operator|)
condition|?
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|EHCI_QTD_PID_IN
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
argument_list|)
else|:
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_ACTIVE
operator||
name|EHCI_QTD_SET_PID
argument_list|(
name|EHCI_QTD_PID_OUT
argument_list|)
operator||
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|pc
operator|=
name|NULL
expr_stmt|;
name|temp
operator|.
name|shortpkt
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|last_frame
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|setup_alt_next
operator|=
literal|0
expr_stmt|;
name|ehci_setup_standard_chain_sub
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|td
operator|=
name|temp
operator|.
name|td
expr_stmt|;
comment|/* the last TD terminates the transfer: */
name|td
operator|->
name|qtd_next
operator|=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|td
operator|->
name|qtd_altnext
operator|=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
comment|/* must have at least one frame! */
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"nexttog=%d; data before transfer:\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
name|qh
operator|=
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
comment|/* the "qh_link" field is filled when the QH is added */
name|qh_endp
operator|=
operator|(
name|EHCI_QH_SET_ADDR
argument_list|(
name|xfer
operator|->
name|address
argument_list|)
operator||
name|EHCI_QH_SET_ENDPT
argument_list|(
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|)
operator||
name|EHCI_QH_SET_MPL
argument_list|(
name|xfer
operator|->
name|max_packet_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|qh_endp
operator||=
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_HIGH
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|!=
operator|&
name|ehci_device_intr_methods
condition|)
name|qh_endp
operator||=
name|EHCI_QH_SET_NRL
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|usbd_get_speed
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|)
operator|==
name|USB_SPEED_FULL
condition|)
block|{
name|qh_endp
operator||=
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_FULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qh_endp
operator||=
name|EHCI_QH_SET_EPS
argument_list|(
name|EHCI_QH_SPEED_LOW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_ctrl_methods
condition|)
block|{
name|qh_endp
operator||=
name|EHCI_QH_CTL
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|!=
operator|&
name|ehci_device_intr_methods
condition|)
block|{
comment|/* Only try one time per microframe! */
name|qh_endp
operator||=
name|EHCI_QH_SET_NRL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temp
operator|.
name|auto_data_toggle
operator|==
literal|0
condition|)
block|{
comment|/* software computes the data toggle */
name|qh_endp
operator||=
name|EHCI_QH_DTC
expr_stmt|;
block|}
name|qh
operator|->
name|qh_endp
operator|=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|qh_endp
argument_list|)
expr_stmt|;
name|qh_endphub
operator|=
operator|(
name|EHCI_QH_SET_MULT
argument_list|(
name|xfer
operator|->
name|max_packet_count
operator|&
literal|3
argument_list|)
operator||
name|EHCI_QH_SET_CMASK
argument_list|(
name|xfer
operator|->
name|endpoint
operator|->
name|usb_cmask
argument_list|)
operator||
name|EHCI_QH_SET_SMASK
argument_list|(
name|xfer
operator|->
name|endpoint
operator|->
name|usb_smask
argument_list|)
operator||
name|EHCI_QH_SET_HUBA
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|hs_hub_addr
argument_list|)
operator||
name|EHCI_QH_SET_PORT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|hs_port_no
argument_list|)
operator|)
expr_stmt|;
name|qh
operator|->
name|qh_endphub
operator|=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|qh_endphub
argument_list|)
expr_stmt|;
name|qh
operator|->
name|qh_curqtd
operator|=
literal|0
expr_stmt|;
comment|/* fill the overlay qTD */
if|if
condition|(
name|temp
operator|.
name|auto_data_toggle
operator|&&
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
condition|)
block|{
comment|/* DATA1 is next */
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_status
operator|=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_QTD_SET_TOGGLE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_status
operator|=
literal|0
expr_stmt|;
block|}
name|td
operator|=
name|xfer
operator|->
name|td_transfer_first
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_next
operator|=
name|td
operator|->
name|qtd_self
expr_stmt|;
name|qh
operator|->
name|qh_qtd
operator|.
name|qtd_altnext
operator|=
name|htohc32
argument_list|(
name|temp
operator|.
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|qh
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|flags
operator|.
name|self_suspended
operator|==
literal|0
condition|)
block|{
name|EHCI_APPEND_QH
argument_list|(
name|qh
argument_list|,
operator|*
name|qh_last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_root_intr
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|m
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* clear any old interrupt data */
name|memset
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set bits */
name|m
operator|=
operator|(
name|sc
operator|->
name|sc_noport
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
comment|/* pick out CHANGE bits from the status register */
if|if
condition|(
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
name|EHCI_PS_CLEAR
condition|)
block|{
name|sc
operator|->
name|sc_hub_idata
index|[
name|i
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"port %d changed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|uhub_root_intr
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|sc
operator|->
name|sc_hub_idata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_idata
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_isoc_fs_done
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uint32_t
name|nframes
init|=
name|xfer
operator|->
name|nframes
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
modifier|*
name|plen
init|=
name|xfer
operator|->
name|frlengths
decl_stmt|;
name|uint16_t
name|len
init|=
literal|0
decl_stmt|;
name|ehci_sitd_t
modifier|*
name|td
init|=
name|xfer
operator|->
name|td_transfer_first
decl_stmt|;
name|ehci_sitd_t
modifier|*
modifier|*
name|pp_last
init|=
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp_last
operator|>=
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
name|EHCI_VIRTUAL_FRAMELIST_COUNT
index|]
condition|)
block|{
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
literal|0
index|]
expr_stmt|;
block|}
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|15
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"isoc FS-TD\n"
argument_list|)
expr_stmt|;
name|ehci_dump_sitd
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|td
operator|->
name|sitd_status
argument_list|)
expr_stmt|;
name|len
operator|=
name|EHCI_SITD_GET_LEN
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"status=0x%08x, rem=%u\n"
argument_list|,
name|status
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|plen
operator|>=
name|len
condition|)
block|{
name|len
operator|=
operator|*
name|plen
operator|-
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|plen
operator|=
name|len
expr_stmt|;
comment|/* remove FS-TD from schedule */
name|EHCI_REMOVE_FS_TD
argument_list|(
name|td
argument_list|,
operator|*
name|pp_last
argument_list|)
expr_stmt|;
name|pp_last
operator|++
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|xfer
operator|->
name|aframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_isoc_hs_done
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|uint32_t
name|nframes
init|=
name|xfer
operator|->
name|nframes
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
modifier|*
name|plen
init|=
name|xfer
operator|->
name|frlengths
decl_stmt|;
name|uint16_t
name|len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|td_no
init|=
literal|0
decl_stmt|;
name|ehci_itd_t
modifier|*
name|td
init|=
name|xfer
operator|->
name|td_transfer_first
decl_stmt|;
name|ehci_itd_t
modifier|*
modifier|*
name|pp_last
init|=
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|13
argument_list|,
literal|"xfer=%p endpoint=%p transfer done\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
while|while
condition|(
name|nframes
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp_last
operator|>=
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|EHCI_VIRTUAL_FRAMELIST_COUNT
index|]
condition|)
block|{
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
literal|0
index|]
expr_stmt|;
block|}
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|15
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"isoc HS-TD\n"
argument_list|)
expr_stmt|;
name|ehci_dump_itd
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|usb_pc_cpu_invalidate
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
name|status
operator|=
name|hc32toh
argument_list|(
name|sc
argument_list|,
name|td
operator|->
name|itd_status
index|[
name|td_no
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|EHCI_ITD_GET_LEN
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"status=0x%08x, len=%u\n"
argument_list|,
name|status
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|usb_smask
operator|&
operator|(
literal|1
operator|<<
name|td_no
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|plen
operator|>=
name|len
condition|)
block|{
comment|/* 				 * The length is valid. NOTE: The 				 * complete length is written back 				 * into the status field, and not the 				 * remainder like with other transfer 				 * descriptor types. 				 */
block|}
else|else
block|{
comment|/* Invalid length - truncate */
name|len
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|plen
operator|=
name|len
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|nframes
operator|--
expr_stmt|;
block|}
name|td_no
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|td_no
operator|==
literal|8
operator|)
operator|||
operator|(
name|nframes
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* remove HS-TD from schedule */
name|EHCI_REMOVE_HS_TD
argument_list|(
name|td
argument_list|,
operator|*
name|pp_last
argument_list|)
expr_stmt|;
name|pp_last
operator|++
expr_stmt|;
name|td_no
operator|=
literal|0
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|aframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE: "done" can be run two times in a row,  * from close and from interrupt  */
end_comment

begin_function
specifier|static
name|void
name|ehci_device_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|usb_pipe_methods
modifier|*
name|methods
init|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p, endpoint=%p, error=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|methods
operator|==
operator|&
name|ehci_device_bulk_methods
operator|)
operator|||
operator|(
name|methods
operator|==
operator|&
name|ehci_device_ctrl_methods
operator|)
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"nexttog=%d; data after transfer:\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|toggle_next
argument_list|)
expr_stmt|;
name|ehci_dump_sqtds
argument_list|(
name|sc
argument_list|,
name|xfer
operator|->
name|td_transfer_first
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|EHCI_REMOVE_QH
argument_list|(
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
argument_list|,
name|sc
operator|->
name|sc_async_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_intr_methods
condition|)
block|{
name|EHCI_REMOVE_QH
argument_list|(
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Only finish isochronous transfers once which will update 	 * "xfer->frlengths". 	 */
if|if
condition|(
name|xfer
operator|->
name|td_transfer_first
operator|&&
name|xfer
operator|->
name|td_transfer_last
condition|)
block|{
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_isoc_fs_methods
condition|)
block|{
name|ehci_isoc_fs_done
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_isoc_hs_methods
condition|)
block|{
name|ehci_isoc_hs_done
argument_list|(
name|sc
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|->
name|td_transfer_first
operator|=
name|NULL
expr_stmt|;
name|xfer
operator|->
name|td_transfer_last
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* dequeue transfer and start next transfer */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * ehci bulk support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ehci_device_bulk_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_bulk_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_bulk_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_bulk_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
comment|/* setup TD's and QH */
name|ehci_setup_standard_chain
argument_list|(
name|xfer
argument_list|,
operator|&
name|sc
operator|->
name|sc_async_p_last
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|ehci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* XXX Performance quirk: Some Host Controllers have a too low 	 * interrupt rate. Issue an IAAD to stimulate the Host 	 * Controller after queueing the BULK transfer. 	 */
name|temp
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|&
name|EHCI_CMD_IAAD
operator|)
condition|)
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|temp
operator||
name|EHCI_CMD_IAAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ehci_device_bulk_methods
init|=
block|{
operator|.
name|open
operator|=
name|ehci_device_bulk_open
block|,
operator|.
name|close
operator|=
name|ehci_device_bulk_close
block|,
operator|.
name|enter
operator|=
name|ehci_device_bulk_enter
block|,
operator|.
name|start
operator|=
name|ehci_device_bulk_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ehci control support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ehci_device_ctrl_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_ctrl_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_ctrl_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_ctrl_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
comment|/* setup TD's and QH */
name|ehci_setup_standard_chain
argument_list|(
name|xfer
argument_list|,
operator|&
name|sc
operator|->
name|sc_async_p_last
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|ehci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ehci_device_ctrl_methods
init|=
block|{
operator|.
name|open
operator|=
name|ehci_device_ctrl_open
block|,
operator|.
name|close
operator|=
name|ehci_device_ctrl_close
block|,
operator|.
name|enter
operator|=
name|ehci_device_ctrl_enter
block|,
operator|.
name|start
operator|=
name|ehci_device_ctrl_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ehci interrupt support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ehci_device_intr_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|uint16_t
name|best
decl_stmt|;
name|uint16_t
name|bit
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|usb_hs_bandwidth_alloc
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* 	 * Find the best QH position corresponding to the given interval: 	 */
name|best
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|interval
operator|>=
name|bit
condition|)
block|{
name|x
operator|=
name|bit
expr_stmt|;
name|best
operator|=
name|bit
expr_stmt|;
while|while
condition|(
name|x
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_intr_stat
index|[
name|x
index|]
operator|<
name|sc
operator|->
name|sc_intr_stat
index|[
name|best
index|]
condition|)
block|{
name|best
operator|=
name|x
expr_stmt|;
block|}
name|x
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_intr_stat
index|[
name|best
index|]
operator|++
expr_stmt|;
name|xfer
operator|->
name|qh_pos
operator|=
name|best
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"best=%d interval=%d\n"
argument_list|,
name|best
argument_list|,
name|xfer
operator|->
name|interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_intr_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_intr_stat
index|[
name|xfer
operator|->
name|qh_pos
index|]
operator|--
expr_stmt|;
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
comment|/* bandwidth must be freed after device done */
name|usb_hs_bandwidth_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_intr_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_intr_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
comment|/* setup TD's and QH */
name|ehci_setup_standard_chain
argument_list|(
name|xfer
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
comment|/* put transfer on interrupt queue */
name|ehci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ehci_device_intr_methods
init|=
block|{
operator|.
name|open
operator|=
name|ehci_device_intr_open
block|,
operator|.
name|close
operator|=
name|ehci_device_intr_close
block|,
operator|.
name|enter
operator|=
name|ehci_device_intr_enter
block|,
operator|.
name|start
operator|=
name|ehci_device_intr_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ehci full speed isochronous support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ehci_device_isoc_fs_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ehci_sitd_t
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|sitd_portaddr
decl_stmt|;
name|uint8_t
name|ds
decl_stmt|;
name|sitd_portaddr
operator|=
name|EHCI_SITD_SET_ADDR
argument_list|(
name|xfer
operator|->
name|address
argument_list|)
operator||
name|EHCI_SITD_SET_ENDPT
argument_list|(
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|)
operator||
name|EHCI_SITD_SET_HUBA
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|hs_hub_addr
argument_list|)
operator||
name|EHCI_SITD_SET_PORT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|hs_port_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
name|sitd_portaddr
operator||=
name|EHCI_SITD_SET_DIR_IN
expr_stmt|;
block|}
name|sitd_portaddr
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|sitd_portaddr
argument_list|)
expr_stmt|;
comment|/* initialize all TD's */
for|for
control|(
name|ds
operator|=
literal|0
init|;
name|ds
operator|!=
literal|2
condition|;
name|ds
operator|++
control|)
block|{
for|for
control|(
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|ds
index|]
init|;
name|td
condition|;
name|td
operator|=
name|td
operator|->
name|obj_next
control|)
block|{
name|td
operator|->
name|sitd_portaddr
operator|=
name|sitd_portaddr
expr_stmt|;
comment|/* 			 * TODO: make some kind of automatic 			 * SMASK/CMASK selection based on micro-frame 			 * usage 			 * 			 * micro-frame usage (8 microframes per 1ms) 			 */
name|td
operator|->
name|sitd_back
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_LINK_TERMINATE
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_fs_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_fs_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss_start
decl_stmt|;
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss_end
decl_stmt|;
name|struct
name|usb_fs_isoc_schedule
modifier|*
name|fss
decl_stmt|;
name|ehci_sitd_t
modifier|*
name|td
decl_stmt|;
name|ehci_sitd_t
modifier|*
name|td_last
init|=
name|NULL
decl_stmt|;
name|ehci_sitd_t
modifier|*
modifier|*
name|pp_last
decl_stmt|;
name|uint32_t
modifier|*
name|plen
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|sitd_mask
decl_stmt|;
name|uint16_t
name|tlen
decl_stmt|;
name|uint8_t
name|sa
decl_stmt|;
name|uint8_t
name|sb
decl_stmt|;
name|uint8_t
name|error
decl_stmt|;
if|#
directive|if
name|USB_DEBUG
name|uint8_t
name|once
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"xfer=%p next=%d nframes=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
comment|/* get the current frame index */
name|nframes
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_FRINDEX
argument_list|)
operator|/
literal|8
expr_stmt|;
comment|/* 	 * check if the frame index is within the window where the frames 	 * will be inserted 	 */
name|buf_offset
operator|=
operator|(
name|nframes
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
name|buf_offset
operator|<
name|xfer
operator|->
name|nframes
operator|)
condition|)
block|{
comment|/* 		 * If there is data underflow or the pipe queue is empty we 		 * schedule the transfer a few frames ahead of the current 		 * frame position. Else two isochronous transfers might 		 * overlap. 		 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|nframes
operator|+
literal|3
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * compute how many milliseconds the insertion is ahead of the 	 * current frame position: 	 */
name|buf_offset
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|nframes
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * pre-compute when the isochronous transfer will be finished: 	 */
name|xfer
operator|->
name|isoc_time_complete
operator|=
name|usbd_fs_isoc_schedule_isoc_time_expand
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
argument_list|,
operator|&
name|fss_start
argument_list|,
operator|&
name|fss_end
argument_list|,
name|nframes
argument_list|)
operator|+
name|buf_offset
operator|+
name|xfer
operator|->
name|nframes
expr_stmt|;
comment|/* get the real number of frames */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|plen
operator|=
name|xfer
operator|->
name|frlengths
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
index|]
expr_stmt|;
comment|/* store starting position */
name|xfer
operator|->
name|qh_pos
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
expr_stmt|;
name|fss
operator|=
name|fss_start
operator|+
operator|(
name|xfer
operator|->
name|qh_pos
operator|%
name|USB_ISOC_TIME_MAX
operator|)
expr_stmt|;
while|while
condition|(
name|nframes
operator|--
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp_last
operator|>=
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
name|EHCI_VIRTUAL_FRAMELIST_COUNT
index|]
condition|)
block|{
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|fss
operator|>=
name|fss_end
condition|)
block|{
name|fss
operator|=
name|fss_start
expr_stmt|;
block|}
comment|/* reuse sitd_portaddr and sitd_back from last transfer */
if|if
condition|(
operator|*
name|plen
operator|>
name|xfer
operator|->
name|max_frame_size
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|once
condition|)
block|{
name|once
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: frame length(%d) exceeds %d "
literal|"bytes (frame truncated)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|plen
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|plen
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
block|}
comment|/* 		 * We currently don't care if the ISOCHRONOUS schedule is 		 * full! 		 */
name|error
operator|=
name|usbd_fs_isoc_schedule_alloc
argument_list|(
name|fss
argument_list|,
operator|&
name|sa
argument_list|,
operator|*
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * The FULL speed schedule is FULL! Set length 			 * to zero. 			 */
operator|*
name|plen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|plen
condition|)
block|{
comment|/* 			 * only call "usbd_get_page()" when we have a 			 * non-zero length 			 */
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|buf_offset
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|td
operator|->
name|sitd_bp
index|[
literal|0
index|]
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|buf_res
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|buf_offset
operator|+=
operator|*
name|plen
expr_stmt|;
comment|/* 			 * NOTE: We need to subtract one from the offset so 			 * that we are on a valid page! 			 */
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|buf_offset
operator|-
literal|1
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
name|temp
operator|=
name|buf_res
operator|.
name|physaddr
operator|&
operator|~
literal|0xFFF
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|sitd_bp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_OUT
condition|)
block|{
name|tlen
operator|=
operator|*
name|plen
expr_stmt|;
if|if
condition|(
name|tlen
operator|<=
literal|188
condition|)
block|{
name|temp
operator||=
literal|1
expr_stmt|;
comment|/* T-count = 1, TP = ALL */
name|tlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tlen
operator|+=
literal|187
expr_stmt|;
name|tlen
operator|/=
literal|188
expr_stmt|;
name|temp
operator||=
name|tlen
expr_stmt|;
comment|/* T-count = [1..6] */
name|temp
operator||=
literal|8
expr_stmt|;
comment|/* TP = Begin */
block|}
name|tlen
operator|+=
name|sa
expr_stmt|;
if|if
condition|(
name|tlen
operator|>=
literal|8
condition|)
block|{
name|sb
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|(
literal|1
operator|<<
name|tlen
operator|)
expr_stmt|;
block|}
name|sa
operator|=
operator|(
literal|1
operator|<<
name|sa
operator|)
expr_stmt|;
name|sa
operator|=
operator|(
name|sb
operator|-
name|sa
operator|)
operator|&
literal|0x3F
expr_stmt|;
name|sb
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|(
operator|-
operator|(
literal|4
operator|<<
name|sa
operator|)
operator|)
operator|&
literal|0xFE
expr_stmt|;
name|sa
operator|=
operator|(
literal|1
operator|<<
name|sa
operator|)
operator|&
literal|0x3F
expr_stmt|;
block|}
name|sitd_mask
operator|=
operator|(
name|EHCI_SITD_SET_SMASK
argument_list|(
name|sa
argument_list|)
operator||
name|EHCI_SITD_SET_CMASK
argument_list|(
name|sb
argument_list|)
operator|)
expr_stmt|;
name|td
operator|->
name|sitd_bp
index|[
literal|1
index|]
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|td
operator|->
name|sitd_mask
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|sitd_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|nframes
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|sitd_status
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_SITD_IOC
operator||
name|EHCI_SITD_ACTIVE
operator||
name|EHCI_SITD_SET_LEN
argument_list|(
operator|*
name|plen
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|sitd_status
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_SITD_ACTIVE
operator||
name|EHCI_SITD_SET_LEN
argument_list|(
operator|*
name|plen
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|15
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"FS-TD %d\n"
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
name|ehci_dump_sitd
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* insert TD into schedule */
name|EHCI_APPEND_FS_TD
argument_list|(
name|td
argument_list|,
operator|*
name|pp_last
argument_list|)
expr_stmt|;
name|pp_last
operator|++
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|fss
operator|++
expr_stmt|;
name|td_last
operator|=
name|td
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td_last
expr_stmt|;
comment|/* update isoc_next */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|pp_last
operator|-
operator|&
name|sc
operator|->
name|sc_isoc_fs_p_last
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_fs_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* put transfer on interrupt queue */
name|ehci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ehci_device_isoc_fs_methods
init|=
block|{
operator|.
name|open
operator|=
name|ehci_device_isoc_fs_open
block|,
operator|.
name|close
operator|=
name|ehci_device_isoc_fs_close
block|,
operator|.
name|enter
operator|=
name|ehci_device_isoc_fs_enter
block|,
operator|.
name|start
operator|=
name|ehci_device_isoc_fs_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ehci high speed isochronous support  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ehci_device_isoc_hs_open
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ehci_itd_t
modifier|*
name|td
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint8_t
name|ds
decl_stmt|;
name|usb_hs_bandwidth_alloc
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* initialize all TD's */
for|for
control|(
name|ds
operator|=
literal|0
init|;
name|ds
operator|!=
literal|2
condition|;
name|ds
operator|++
control|)
block|{
for|for
control|(
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|ds
index|]
init|;
name|td
condition|;
name|td
operator|=
name|td
operator|->
name|obj_next
control|)
block|{
comment|/* set TD inactive */
name|td
operator|->
name|itd_status
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set endpoint and address */
name|td
operator|->
name|itd_bp
index|[
literal|0
index|]
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_SET_ADDR
argument_list|(
name|xfer
operator|->
name|address
argument_list|)
operator||
name|EHCI_ITD_SET_ENDPT
argument_list|(
name|UE_GET_ADDR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|EHCI_ITD_SET_MPL
argument_list|(
name|xfer
operator|->
name|max_packet_size
operator|&
literal|0x7FF
argument_list|)
expr_stmt|;
comment|/* set direction */
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|xfer
operator|->
name|endpointno
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
name|temp
operator||=
name|EHCI_ITD_SET_DIR_IN
expr_stmt|;
block|}
comment|/* set maximum packet size */
name|td
operator|->
name|itd_bp
index|[
literal|1
index|]
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set transfer multiplier */
name|td
operator|->
name|itd_bp
index|[
literal|2
index|]
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|xfer
operator|->
name|max_packet_count
operator|&
literal|3
argument_list|)
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_hs_close
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|ehci_device_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
comment|/* bandwidth must be freed after device done */
name|usb_hs_bandwidth_free
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_hs_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_page_search
name|buf_res
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
decl_stmt|;
name|ehci_itd_t
modifier|*
name|td
decl_stmt|;
name|ehci_itd_t
modifier|*
name|td_last
init|=
name|NULL
decl_stmt|;
name|ehci_itd_t
modifier|*
modifier|*
name|pp_last
decl_stmt|;
name|bus_size_t
name|page_addr
decl_stmt|;
name|uint32_t
modifier|*
name|plen
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint32_t
name|buf_offset
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|itd_offset
index|[
literal|8
operator|+
literal|1
index|]
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|td_no
decl_stmt|;
name|uint8_t
name|page_no
decl_stmt|;
if|#
directive|if
name|USB_DEBUG
name|uint8_t
name|once
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"xfer=%p next=%d nframes=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
comment|/* get the current frame index */
name|nframes
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_FRINDEX
argument_list|)
operator|/
literal|8
expr_stmt|;
comment|/* 	 * check if the frame index is within the window where the frames 	 * will be inserted 	 */
name|buf_offset
operator|=
operator|(
name|nframes
operator|-
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|==
literal|0
operator|)
operator|||
operator|(
name|buf_offset
operator|<
operator|(
operator|(
name|xfer
operator|->
name|nframes
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If there is data underflow or the pipe queue is empty we 		 * schedule the transfer a few frames ahead of the current 		 * frame position. Else two isochronous transfers might 		 * overlap. 		 */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|nframes
operator|+
literal|3
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|1
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"start next=%d\n"
argument_list|,
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * compute how many milliseconds the insertion is ahead of the 	 * current frame position: 	 */
name|buf_offset
operator|=
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|-
name|nframes
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * pre-compute when the isochronous transfer will be finished: 	 */
name|xfer
operator|->
name|isoc_time_complete
operator|=
name|usb_isoc_time_expand
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|nframes
argument_list|)
operator|+
name|buf_offset
operator|+
operator|(
operator|(
name|xfer
operator|->
name|nframes
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* get the real number of frames */
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|buf_offset
operator|=
literal|0
expr_stmt|;
name|td_no
operator|=
literal|0
expr_stmt|;
name|plen
operator|=
name|xfer
operator|->
name|frlengths
expr_stmt|;
comment|/* toggle the DMA set we are using */
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|^=
literal|1
expr_stmt|;
comment|/* get next DMA set */
name|td
operator|=
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
expr_stmt|;
name|xfer
operator|->
name|td_transfer_first
operator|=
name|td
expr_stmt|;
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
index|]
expr_stmt|;
comment|/* store starting position */
name|xfer
operator|->
name|qh_pos
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
expr_stmt|;
while|while
condition|(
name|nframes
condition|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"%s:%d: out of TD's\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp_last
operator|>=
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
name|EHCI_VIRTUAL_FRAMELIST_COUNT
index|]
condition|)
block|{
name|pp_last
operator|=
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* range check */
if|if
condition|(
operator|*
name|plen
operator|>
name|xfer
operator|->
name|max_frame_size
condition|)
block|{
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|once
condition|)
block|{
name|once
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s: frame length(%d) exceeds %d bytes "
literal|"(frame truncated)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|plen
argument_list|,
name|xfer
operator|->
name|max_frame_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|plen
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|usb_smask
operator|&
operator|(
literal|1
operator|<<
name|td_no
operator|)
condition|)
block|{
name|status
operator|=
operator|(
name|EHCI_ITD_SET_LEN
argument_list|(
operator|*
name|plen
argument_list|)
operator||
name|EHCI_ITD_ACTIVE
operator||
name|EHCI_ITD_SET_PG
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
name|td_no
index|]
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|itd_offset
index|[
name|td_no
index|]
operator|=
name|buf_offset
expr_stmt|;
name|buf_offset
operator|+=
operator|*
name|plen
expr_stmt|;
name|plen
operator|++
expr_stmt|;
name|nframes
operator|--
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|itd_status
index|[
name|td_no
index|]
operator|=
literal|0
expr_stmt|;
comment|/* not active */
name|itd_offset
index|[
name|td_no
index|]
operator|=
name|buf_offset
expr_stmt|;
block|}
name|td_no
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|td_no
operator|==
literal|8
operator|)
operator|||
operator|(
name|nframes
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* the rest of the transfers are not active, if any */
for|for
control|(
name|x
operator|=
name|td_no
init|;
name|x
operator|!=
literal|8
condition|;
name|x
operator|++
control|)
block|{
name|td
operator|->
name|itd_status
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
comment|/* not active */
block|}
comment|/* check if there is any data to be transferred */
if|if
condition|(
name|itd_offset
index|[
literal|0
index|]
operator|!=
name|buf_offset
condition|)
block|{
name|page_no
operator|=
literal|0
expr_stmt|;
name|itd_offset
index|[
name|td_no
index|]
operator|=
name|buf_offset
expr_stmt|;
comment|/* get first page offset */
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|itd_offset
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
comment|/* get page address */
name|page_addr
operator|=
name|buf_res
operator|.
name|physaddr
operator|&
operator|~
literal|0xFFF
expr_stmt|;
comment|/* update page address */
name|td
operator|->
name|itd_bp
index|[
literal|0
index|]
operator|&=
name|htohc32
argument_list|(
name|sc
argument_list|,
literal|0xFFF
argument_list|)
expr_stmt|;
name|td
operator|->
name|itd_bp
index|[
literal|0
index|]
operator||=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|page_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|td_no
condition|;
name|x
operator|++
control|)
block|{
comment|/* set page number and page offset */
name|status
operator|=
operator|(
name|EHCI_ITD_SET_PG
argument_list|(
name|page_no
argument_list|)
operator||
operator|(
name|buf_res
operator|.
name|physaddr
operator|&
literal|0xFFF
operator|)
operator|)
expr_stmt|;
name|td
operator|->
name|itd_status
index|[
name|x
index|]
operator||=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* get next page offset */
if|if
condition|(
name|itd_offset
index|[
name|x
operator|+
literal|1
index|]
operator|==
name|buf_offset
condition|)
block|{
comment|/* 						 * We subtract one so that 						 * we don't go off the last 						 * page! 						 */
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|buf_offset
operator|-
literal|1
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usbd_get_page
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|itd_offset
index|[
name|x
operator|+
literal|1
index|]
argument_list|,
operator|&
name|buf_res
argument_list|)
expr_stmt|;
block|}
comment|/* check if we need a new page */
if|if
condition|(
operator|(
name|buf_res
operator|.
name|physaddr
operator|^
name|page_addr
operator|)
operator|&
operator|~
literal|0xFFF
condition|)
block|{
comment|/* new page needed */
name|page_addr
operator|=
name|buf_res
operator|.
name|physaddr
operator|&
operator|~
literal|0xFFF
expr_stmt|;
if|if
condition|(
name|page_no
operator|==
literal|6
condition|)
block|{
name|panic
argument_list|(
literal|"%s: too many pages\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|page_no
operator|++
expr_stmt|;
comment|/* update page address */
name|td
operator|->
name|itd_bp
index|[
name|page_no
index|]
operator|&=
name|htohc32
argument_list|(
name|sc
argument_list|,
literal|0xFFF
argument_list|)
expr_stmt|;
name|td
operator|->
name|itd_bp
index|[
name|page_no
index|]
operator||=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|page_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set IOC bit if we are complete */
if|if
condition|(
name|nframes
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|itd_status
index|[
name|td_no
operator|-
literal|1
index|]
operator||=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|EHCI_ITD_IOC
argument_list|)
expr_stmt|;
block|}
name|usb_pc_cpu_flush
argument_list|(
name|td
operator|->
name|page_cache
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcidebug
operator|>
literal|15
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"HS-TD %d\n"
argument_list|,
name|nframes
argument_list|)
expr_stmt|;
name|ehci_dump_itd
argument_list|(
name|sc
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* insert TD into schedule */
name|EHCI_APPEND_HS_TD
argument_list|(
name|td
argument_list|,
operator|*
name|pp_last
argument_list|)
expr_stmt|;
name|pp_last
operator|++
expr_stmt|;
name|td_no
operator|=
literal|0
expr_stmt|;
name|td_last
operator|=
name|td
expr_stmt|;
name|td
operator|=
name|td
operator|->
name|obj_next
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|td_transfer_last
operator|=
name|td_last
expr_stmt|;
comment|/* update isoc_next */
name|xfer
operator|->
name|endpoint
operator|->
name|isoc_next
operator|=
operator|(
name|pp_last
operator|-
operator|&
name|sc
operator|->
name|sc_isoc_hs_p_last
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|EHCI_VIRTUAL_FRAMELIST_COUNT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_isoc_hs_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* put transfer on interrupt queue */
name|ehci_transfer_intr_enqueue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_pipe_methods
name|ehci_device_isoc_hs_methods
init|=
block|{
operator|.
name|open
operator|=
name|ehci_device_isoc_hs_open
block|,
operator|.
name|close
operator|=
name|ehci_device_isoc_hs_close
block|,
operator|.
name|enter
operator|=
name|ehci_device_isoc_hs_enter
block|,
operator|.
name|start
operator|=
name|ehci_device_isoc_hs_start
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  * ehci root control support  *------------------------------------------------------------------------*  * Simulate a hardware hub by handling all the necessary requests.  *------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_descriptor
name|ehci_devd
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_descriptor
argument_list|)
block|,
name|UDESC_DEVICE
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_HSHUBSTT
block|,
comment|/* protocol */
literal|64
block|,
comment|/* max packet */
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0x00
block|,
literal|0x01
block|}
block|,
comment|/* device id */
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* string indicies */
literal|1
comment|/* # of configurations */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_device_qualifier
name|ehci_odevd
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_qualifier
argument_list|)
block|,
name|UDESC_DEVICE_QUALIFIER
block|,
comment|/* type */
block|{
literal|0x00
block|,
literal|0x02
block|}
block|,
comment|/* USB version */
name|UDCLASS_HUB
block|,
comment|/* class */
name|UDSUBCLASS_HUB
block|,
comment|/* subclass */
name|UDPROTO_FSHUB
block|,
comment|/* protocol */
literal|0
block|,
comment|/* max packet */
literal|0
block|,
comment|/* # of configurations */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ehci_config_desc
name|ehci_confd
init|=
block|{
operator|.
name|confd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_CONFIG
block|,
operator|.
name|wTotalLength
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ehci_confd
argument_list|)
block|,
operator|.
name|bNumInterface
operator|=
literal|1
block|,
operator|.
name|bConfigurationValue
operator|=
literal|1
block|,
operator|.
name|iConfiguration
operator|=
literal|0
block|,
operator|.
name|bmAttributes
operator|=
name|UC_SELF_POWERED
block|,
operator|.
name|bMaxPower
operator|=
literal|0
comment|/* max power */
block|}
block|,
operator|.
name|ifcd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_interface_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
block|,
operator|.
name|bNumEndpoints
operator|=
literal|1
block|,
operator|.
name|bInterfaceClass
operator|=
name|UICLASS_HUB
block|,
operator|.
name|bInterfaceSubClass
operator|=
name|UISUBCLASS_HUB
block|,
operator|.
name|bInterfaceProtocol
operator|=
name|UIPROTO_HSHUBSTT
block|,
literal|0
block|}
block|,
operator|.
name|endpd
operator|=
block|{
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_endpoint_descriptor
argument_list|)
block|,
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
block|,
operator|.
name|bEndpointAddress
operator|=
name|UE_DIR_IN
operator||
name|EHCI_INTR_ENDPT
block|,
operator|.
name|bmAttributes
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
literal|8
block|,
comment|/* max packet (63 ports) */
operator|.
name|bInterval
operator|=
literal|255
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_hub_descriptor
name|ehci_hubd
init|=
block|{
literal|0
block|,
comment|/* dynamic length */
name|UDESC_HUB
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ehci_disown
parameter_list|(
name|ehci_softc_t
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|index
parameter_list|,
name|uint8_t
name|lowspeed
parameter_list|)
block|{
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"index=%d lowspeed=%d\n"
argument_list|,
name|index
argument_list|,
name|lowspeed
argument_list|)
expr_stmt|;
name|port
operator|=
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|EHCI_PS_CLEAR
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|ehci_roothub_exec
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pptr
parameter_list|,
name|uint16_t
modifier|*
name|plength
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_ptr
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|uint8_t
name|l
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* buffer reset */
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_hub_desc
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wValue
argument_list|)
expr_stmt|;
name|index
operator|=
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"type=0x%02x request=0x%02x wLen=0x%04x "
literal|"wValue=0x%04x wIndex=0x%04x\n"
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|,
name|req
operator|->
name|bRequest
argument_list|,
name|UGETW
argument_list|(
name|req
operator|->
name|wLength
argument_list|)
argument_list|,
name|value
argument_list|,
name|index
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) | ((y)<< 8))
switch|switch
condition|(
name|C
argument_list|(
name|req
operator|->
name|bRequest
argument_list|,
name|req
operator|->
name|bmRequestType
argument_list|)
condition|)
block|{
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
comment|/* 		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops 		 * for the integrated root hub. 		 */
break|break;
case|case
name|C
argument_list|(
name|UR_GET_CONFIG
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_conf
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
switch|switch
condition|(
name|value
operator|>>
literal|8
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ehci_devd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|ehci_devd
expr_stmt|;
break|break;
comment|/* 			 * We can't really operate at another speed, 			 * but the specification says we need this 			 * descriptor: 			 */
case|case
name|UDESC_DEVICE_QUALIFIER
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ehci_odevd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|ehci_odevd
expr_stmt|;
break|break;
case|case
name|UDESC_CONFIG
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ehci_confd
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|ehci_confd
expr_stmt|;
break|break;
case|case
name|UDESC_STRING
case|:
switch|switch
condition|(
name|value
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0
case|:
comment|/* Language table */
name|str_ptr
operator|=
literal|"\001"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Vendor */
name|str_ptr
operator|=
name|sc
operator|->
name|sc_vendor
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Product */
name|str_ptr
operator|=
literal|"EHCI root HUB"
expr_stmt|;
break|break;
default|default:
name|str_ptr
operator|=
literal|""
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|usb_make_str_desc
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|)
argument_list|,
name|str_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_INTERFACE
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
name|UDS_SELF_POWERED
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_ENDPOINT
argument_list|)
case|:
name|len
operator|=
literal|2
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|stat
operator|.
name|wStatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_ADDRESS
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
name|value
operator|>=
name|EHCI_MAX_DEVICES
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_addr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_CONFIG
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|value
operator|!=
literal|1
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|sc_conf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_DEVICE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_INTERFACE
argument_list|,
name|UT_WRITE_INTERFACE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SYNCH_FRAME
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|)
case|:
break|break;
comment|/* Hub requests */
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"UR_CLEAR_PORT_FEATURE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|EHCI_PS_CLEAR
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
if|if
condition|(
operator|(
name|v
operator|&
name|EHCI_PS_SUSP
operator|)
operator|&&
operator|(
operator|!
operator|(
name|v
operator|&
name|EHCI_PS_FPR
operator|)
operator|)
condition|)
block|{
comment|/* 				 * waking up a High Speed device is rather 				 * complicated if 				 */
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_FPR
argument_list|)
expr_stmt|;
block|}
comment|/* wait 20ms for resume sequence to complete */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
operator|(
name|EHCI_PS_SUSP
operator||
name|EHCI_PS_FPR
operator||
operator|(
literal|3
operator|<<
literal|10
operator|)
comment|/* High Speed */
operator|)
argument_list|)
expr_stmt|;
comment|/* 4ms settle time */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|hz
operator|/
literal|250
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_PP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"clear port test "
literal|"%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_INDICATOR
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"clear port ind "
literal|"%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator|&
operator|~
name|EHCI_PS_PIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_CONNECTION
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_CSC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_ENABLE
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_SUSPEND
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_OVER_CURRENT
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_OCC
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_C_PORT_RESET
case|:
name|sc
operator|->
name|sc_isreset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_GET_DESCRIPTOR
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCSPARAMS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|=
name|ehci_hubd
expr_stmt|;
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bNbrPorts
operator|=
name|sc
operator|->
name|sc_noport
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|wHubCharacteristics
argument_list|,
operator|(
name|EHCI_HCS_PPC
argument_list|(
name|v
argument_list|)
condition|?
name|UHD_PWR_INDIVIDUAL
else|:
name|UHD_PWR_NO_SWITCH
operator|)
operator||
operator|(
name|EHCI_HCS_P_INDICATOR
argument_list|(
name|EREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_HCSPARAMS
argument_list|)
argument_list|)
condition|?
name|UHD_PORT_IND
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX can't find out? */
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bPwrOn2PwrGood
operator|=
literal|200
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|sc
operator|->
name|sc_noport
condition|;
name|l
operator|++
control|)
block|{
comment|/* XXX can't find out? */
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|DeviceRemovable
index|[
name|l
operator|/
literal|8
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|l
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bDescLength
operator|=
literal|8
operator|+
operator|(
operator|(
name|sc
operator|->
name|sc_noport
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|len
operator|=
name|sc
operator|->
name|sc_hub_desc
operator|.
name|hubd
operator|.
name|bDescLength
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_DEVICE
argument_list|)
case|:
name|len
operator|=
literal|16
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_GET_STATUS
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"get port status i=%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
literal|"port status=0x%04x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|EHCI_SCFLG_FORCESPEED
operator||
name|EHCI_SCFLG_TT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|&
literal|0xc000000
operator|)
operator|==
literal|0x8000000
condition|)
name|i
operator|=
name|UPS_HIGH_SPEED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|v
operator|&
literal|0xc000000
operator|)
operator|==
literal|0x4000000
condition|)
name|i
operator|=
name|UPS_LOW_SPEED
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|UPS_HIGH_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|EHCI_PS_CS
condition|)
name|i
operator||=
name|UPS_CURRENT_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PE
condition|)
name|i
operator||=
name|UPS_PORT_ENABLED
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|EHCI_PS_SUSP
operator|)
operator|&&
operator|!
operator|(
name|v
operator|&
name|EHCI_PS_FPR
operator|)
condition|)
name|i
operator||=
name|UPS_SUSPEND
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_OCA
condition|)
name|i
operator||=
name|UPS_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PR
condition|)
name|i
operator||=
name|UPS_RESET
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PP
condition|)
name|i
operator||=
name|UPS_PORT_POWER
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortStatus
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_CSC
condition|)
name|i
operator||=
name|UPS_C_CONNECT_STATUS
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PEC
condition|)
name|i
operator||=
name|UPS_C_PORT_ENABLED
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_OCC
condition|)
name|i
operator||=
name|UPS_C_OVERCURRENT_INDICATOR
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_FPR
condition|)
name|i
operator||=
name|UPS_C_SUSPEND
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_isreset
condition|)
name|i
operator||=
name|UPS_C_PORT_RESET
expr_stmt|;
name|USETW
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
operator|.
name|wPortChange
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hub_desc
operator|.
name|ps
argument_list|)
expr_stmt|;
break|break;
case|case
name|C
argument_list|(
name|UR_SET_DESCRIPTOR
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_DEVICE
argument_list|)
case|:
break|break;
case|case
name|C
argument_list|(
name|UR_SET_FEATURE
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
if|if
condition|(
operator|(
name|index
operator|<
literal|1
operator|)
operator|||
operator|(
name|index
operator|>
name|sc
operator|->
name|sc_noport
operator|)
condition|)
block|{
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|EHCI_PORTSC
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
operator|&
operator|~
name|EHCI_PS_CLEAR
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|UHF_PORT_ENABLE
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PE
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_SUSPEND
case|:
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_SUSP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_RESET
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"reset port %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|ehcinohighspeed
condition|)
block|{
comment|/* 				 * Connect USB device to companion 				 * controller. 				 */
name|ehci_disown
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|EHCI_PS_IS_LOWSPEED
argument_list|(
name|v
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_TT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Low speed device, give up ownership. */
name|ehci_disown
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Start reset sequence. */
name|v
operator|&=
operator|~
operator|(
name|EHCI_PS_PE
operator||
name|EHCI_PS_PR
operator|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PR
argument_list|)
expr_stmt|;
comment|/* Wait for reset to complete. */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|USB_PORT_ROOT_RESET_DELAY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Terminate reset sequence. */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_NORESTERM
operator|)
condition|)
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Wait for HC to complete reset. */
name|usb_pause_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
operator|.
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|EHCI_PORT_RESET_COMPLETE
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"ehci after reset, status=0x%08x\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|EHCI_PS_PR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"port reset timeout\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|USB_ERR_TIMEOUT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|v
operator|&
name|EHCI_PS_PE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|EHCI_SCFLG_TT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Not a high speed device, give up ownership.*/
name|ehci_disown
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_isreset
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"ehci port %d reset, status = 0x%08x\n"
argument_list|,
name|index
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_POWER
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port power %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PP
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_TEST
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port test %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHF_PORT_INDICATOR
case|:
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"set port ind %d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|v
operator||
name|EHCI_PS_PIC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|C
argument_list|(
name|UR_CLEAR_TT_BUFFER
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_RESET_TT
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_GET_TT_STATE
argument_list|,
name|UT_READ_CLASS_OTHER
argument_list|)
case|:
case|case
name|C
argument_list|(
name|UR_STOP_TT
argument_list|,
name|UT_WRITE_CLASS_OTHER
argument_list|)
case|:
break|break;
default|default:
name|err
operator|=
name|USB_ERR_IOERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
operator|*
name|plength
operator|=
name|len
expr_stmt|;
operator|*
name|pptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_xfer_setup
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
name|struct
name|usb_page_search
name|page_info
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|last_obj
decl_stmt|;
name|uint32_t
name|nqtd
decl_stmt|;
name|uint32_t
name|nqh
decl_stmt|;
name|uint32_t
name|nsitd
decl_stmt|;
name|uint32_t
name|nitd
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|sc
operator|=
name|EHCI_BUS2SC
argument_list|(
name|parm
operator|->
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|parm
operator|->
name|curr_xfer
expr_stmt|;
name|nqtd
operator|=
literal|0
expr_stmt|;
name|nqh
operator|=
literal|0
expr_stmt|;
name|nsitd
operator|=
literal|0
expr_stmt|;
name|nitd
operator|=
literal|0
expr_stmt|;
comment|/* 	 * compute maximum number of some structures 	 */
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ehci_device_ctrl_methods
condition|)
block|{
comment|/* 		 * The proof for the "nqtd" formula is illustrated like 		 * this: 		 * 		 * +------------------------------------+ 		 * |                                    | 		 * |         |remainder ->              | 		 * |   +-----+---+                      | 		 * |   | xxx | x | frm 0                | 		 * |   +-----+---++                     | 		 * |   | xxx | xx | frm 1               | 		 * |   +-----+----+                     | 		 * |            ...                     | 		 * +------------------------------------+ 		 * 		 * "xxx" means a completely full USB transfer descriptor 		 * 		 * "x" and "xx" means a short USB packet 		 * 		 * For the remainder of an USB transfer modulo 		 * "max_data_length" we need two USB transfer descriptors. 		 * One to transfer the remaining data and one to finalise 		 * with a zero length packet in case the "force_short_xfer" 		 * flag is set. We only need two USB transfer descriptors in 		 * the case where the transfer length of the first one is a 		 * factor of "max_frame_size". The rest of the needed USB 		 * transfer descriptors is given by the buffer size divided 		 * by the maximum data payload. 		 */
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
name|EHCI_QTD_PAYLOAD_MAX
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
name|nqtd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
literal|1
comment|/* STATUS */
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ehci_device_bulk_methods
condition|)
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
name|EHCI_QTD_PAYLOAD_MAX
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
name|nqtd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ehci_device_intr_methods
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
name|USB_FS_BYTES_PER_HS_UFRAME
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
name|USB_FS_BYTES_PER_HS_UFRAME
operator|/
literal|8
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
block|}
name|parm
operator|->
name|hc_max_frame_size
operator|=
name|EHCI_QTD_PAYLOAD_MAX
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nqh
operator|=
literal|1
expr_stmt|;
name|nqtd
operator|=
operator|(
operator|(
literal|2
operator|*
name|xfer
operator|->
name|nframes
operator|)
operator|+
operator|(
name|xfer
operator|->
name|max_data_length
operator|/
name|xfer
operator|->
name|max_hc_frame_size
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ehci_device_isoc_fs_methods
condition|)
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x3FF
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
literal|0x3FF
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nsitd
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm
operator|->
name|methods
operator|==
operator|&
name|ehci_device_isoc_hs_methods
condition|)
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|3
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
literal|0xC00
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|nitd
operator|=
operator|(
operator|(
name|xfer
operator|->
name|nframes
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|<<
name|usbd_xfer_get_fps_shift
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parm
operator|->
name|hc_max_packet_size
operator|=
literal|0x400
expr_stmt|;
name|parm
operator|->
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|hc_max_frame_size
operator|=
literal|0x400
expr_stmt|;
name|usbd_transfer_setup_sub
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
name|alloc_dma_set
label|:
if|if
condition|(
name|parm
operator|->
name|err
condition|)
block|{
return|return;
block|}
comment|/* 	 * Allocate queue heads and transfer descriptors 	 */
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_itd_t
argument_list|)
argument_list|,
name|EHCI_ITD_ALIGN
argument_list|,
name|nitd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nitd
condition|;
name|n
operator|++
control|)
block|{
name|ehci_itd_t
modifier|*
name|td
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|td
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
name|td
operator|->
name|itd_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|page_info
operator|.
name|physaddr
operator||
name|EHCI_LINK_ITD
argument_list|)
expr_stmt|;
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|td
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_sitd_t
argument_list|)
argument_list|,
name|EHCI_SITD_ALIGN
argument_list|,
name|nsitd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nsitd
condition|;
name|n
operator|++
control|)
block|{
name|ehci_sitd_t
modifier|*
name|td
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|td
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
name|td
operator|->
name|sitd_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|page_info
operator|.
name|physaddr
operator||
name|EHCI_LINK_SITD
argument_list|)
expr_stmt|;
name|td
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|td
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|td
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_qtd_t
argument_list|)
argument_list|,
name|EHCI_QTD_ALIGN
argument_list|,
name|nqtd
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nqtd
condition|;
name|n
operator|++
control|)
block|{
name|ehci_qtd_t
modifier|*
name|qtd
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|qtd
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init TD */
name|qtd
operator|->
name|qtd_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|page_info
operator|.
name|physaddr
argument_list|)
expr_stmt|;
name|qtd
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|qtd
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|qtd
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|td_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
name|last_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup_sub_malloc
argument_list|(
name|parm
argument_list|,
operator|&
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|ehci_qh_t
argument_list|)
argument_list|,
name|EHCI_QH_ALIGN
argument_list|,
name|nqh
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nqh
condition|;
name|n
operator|++
control|)
block|{
name|ehci_qh_t
modifier|*
name|qh
decl_stmt|;
name|usbd_get_page
argument_list|(
name|pc
operator|+
name|n
argument_list|,
literal|0
argument_list|,
operator|&
name|page_info
argument_list|)
expr_stmt|;
name|qh
operator|=
name|page_info
operator|.
name|buffer
expr_stmt|;
comment|/* init QH */
name|qh
operator|->
name|qh_self
operator|=
name|htohc32
argument_list|(
name|sc
argument_list|,
name|page_info
operator|.
name|physaddr
operator||
name|EHCI_LINK_QH
argument_list|)
expr_stmt|;
name|qh
operator|->
name|obj_next
operator|=
name|last_obj
expr_stmt|;
name|qh
operator|->
name|page_cache
operator|=
name|pc
operator|+
name|n
expr_stmt|;
name|last_obj
operator|=
name|qh
expr_stmt|;
name|usb_pc_cpu_flush
argument_list|(
name|pc
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
operator|=
name|last_obj
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
operator|=
literal|1
expr_stmt|;
goto|goto
name|alloc_dma_set
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_xfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_ep_init
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"endpoint=%p, addr=%d, endpt=%d, mode=%d (%d)\n"
argument_list|,
name|ep
argument_list|,
name|udev
operator|->
name|address
argument_list|,
name|edesc
operator|->
name|bEndpointAddress
argument_list|,
name|udev
operator|->
name|flags
operator|.
name|usb_mode
argument_list|,
name|sc
operator|->
name|sc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
comment|/* not supported */
return|return;
block|}
if|if
condition|(
name|udev
operator|->
name|device_index
operator|!=
name|sc
operator|->
name|sc_addr
condition|)
block|{
if|if
condition|(
operator|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_HIGH
operator|)
operator|&&
operator|(
operator|(
name|udev
operator|->
name|hs_hub_addr
operator|==
literal|0
operator|)
operator|||
operator|(
name|udev
operator|->
name|hs_port_no
operator|==
literal|0
operator|)
operator|||
operator|(
name|udev
operator|->
name|parent_hs_hub
operator|==
name|NULL
operator|)
operator|||
operator|(
name|udev
operator|->
name|parent_hs_hub
operator|->
name|hub
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
comment|/* We need a transaction translator */
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
condition|)
block|{
case|case
name|UE_CONTROL
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|ehci_device_ctrl_methods
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
name|ep
operator|->
name|methods
operator|=
operator|&
name|ehci_device_intr_methods
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|ehci_device_isoc_hs_methods
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|ehci_device_isoc_fs_methods
expr_stmt|;
block|}
break|break;
case|case
name|UE_BULK
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_LOW
condition|)
block|{
name|ep
operator|->
name|methods
operator|=
operator|&
name|ehci_device_bulk_methods
expr_stmt|;
block|}
break|break;
default|default:
comment|/* do nothing */
break|break;
block|}
block|}
name|done
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_get_dma_delay
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|,
name|uint32_t
modifier|*
name|pus
parameter_list|)
block|{
comment|/* 	 * Wait until the hardware has finished any possible use of 	 * the transfer descriptor(s) and QH 	 */
operator|*
name|pus
operator|=
operator|(
literal|188
operator|)
expr_stmt|;
comment|/* microseconds */
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_resume
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|==
name|udev
condition|)
block|{
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
if|if
condition|(
operator|(
name|methods
operator|==
operator|&
name|ehci_device_bulk_methods
operator|)
operator|||
operator|(
name|methods
operator|==
operator|&
name|ehci_device_ctrl_methods
operator|)
condition|)
block|{
name|EHCI_APPEND_QH
argument_list|(
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
argument_list|,
name|sc
operator|->
name|sc_async_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_intr_methods
condition|)
block|{
name|EHCI_APPEND_QH
argument_list|(
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_device_suspend
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_pipe_methods
modifier|*
name|methods
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|xfer
argument_list|,
argument|&sc->sc_bus.intr_q.head
argument_list|,
argument|wait_entry
argument_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|==
name|udev
condition|)
block|{
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
if|if
condition|(
operator|(
name|methods
operator|==
operator|&
name|ehci_device_bulk_methods
operator|)
operator|||
operator|(
name|methods
operator|==
operator|&
name|ehci_device_ctrl_methods
operator|)
condition|)
block|{
name|EHCI_REMOVE_QH
argument_list|(
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
argument_list|,
name|sc
operator|->
name|sc_async_p_last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|==
operator|&
name|ehci_device_intr_methods
condition|)
block|{
name|EHCI_REMOVE_QH
argument_list|(
name|xfer
operator|->
name|qh_start
index|[
name|xfer
operator|->
name|flags_int
operator|.
name|curr_dma_set
index|]
argument_list|,
name|sc
operator|->
name|sc_intr_p_last
index|[
name|xfer
operator|->
name|qh_pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ehci_set_hw_power
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|ehci_softc_t
modifier|*
name|sc
init|=
name|EHCI_BUS2SC
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bus
operator|->
name|hw_power_state
expr_stmt|;
name|temp
operator|=
name|EOREAD4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
name|EHCI_CMD_ASE
operator||
name|EHCI_CMD_PSE
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|USB_HW_POWER_CONTROL
operator||
name|USB_HW_POWER_BULK
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Async is active\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|EHCI_CMD_ASE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|USB_HW_POWER_INTERRUPT
operator||
name|USB_HW_POWER_ISOC
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Periodic is active\n"
argument_list|)
expr_stmt|;
name|temp
operator||=
name|EHCI_CMD_PSE
expr_stmt|;
block|}
name|EOWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBCMD
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|struct
name|usb_bus_methods
name|ehci_bus_methods
init|=
block|{
operator|.
name|endpoint_init
operator|=
name|ehci_ep_init
block|,
operator|.
name|xfer_setup
operator|=
name|ehci_xfer_setup
block|,
operator|.
name|xfer_unsetup
operator|=
name|ehci_xfer_unsetup
block|,
operator|.
name|get_dma_delay
operator|=
name|ehci_get_dma_delay
block|,
operator|.
name|device_resume
operator|=
name|ehci_device_resume
block|,
operator|.
name|device_suspend
operator|=
name|ehci_device_suspend
block|,
operator|.
name|set_hw_power
operator|=
name|ehci_set_hw_power
block|,
operator|.
name|roothub_exec
operator|=
name|ehci_roothub_exec
block|,
operator|.
name|xfer_poll
operator|=
name|ehci_do_poll
block|, }
decl_stmt|;
end_decl_stmt

end_unit

