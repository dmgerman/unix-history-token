begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_struct
struct|struct
name|usb_std_packet_size
block|{
struct|struct
block|{
name|uint16_t
name|min
decl_stmt|;
comment|/* inclusive */
name|uint16_t
name|max
decl_stmt|;
comment|/* inclusive */
block|}
name|range
struct|;
name|uint16_t
name|fixed
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|usb_callback_t
name|usb_request_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|usb_control_ep_cfg
index|[
name|USB_DEFAULT_XFER_MAX
index|]
init|=
block|{
comment|/* This transfer is used for generic control endpoint transfers */
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control endpoint */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
name|USB_EP0_BUFSIZE
block|,
comment|/* bytes */
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|usb_request_callback
block|,
operator|.
name|usb_mode
operator|=
name|USB_MODE_DUAL
block|,
comment|/* both modes */
block|}
block|,
comment|/* This transfer is used for generic clear stall only */
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
block|,
operator|.
name|callback
operator|=
operator|&
name|usb_do_clear_stall_callback
block|,
operator|.
name|timeout
operator|=
literal|1000
block|,
comment|/* 1 second */
operator|.
name|interval
operator|=
literal|50
block|,
comment|/* 50ms */
operator|.
name|usb_mode
operator|=
name|USB_MODE_HOST
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|usbd_update_max_frame_size
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_transfer_unsetup_sub
parameter_list|(
name|struct
name|usb_xfer_root
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_control_transfer_init
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbd_setup_ctrl_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_callback_proc
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_callback_ss_done_defer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_callback_wrapper
parameter_list|(
name|struct
name|usb_xfer_queue
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_dma_delay_done_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_transfer_start_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|usbd_callback_wrapper_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_get_std_packet_size
parameter_list|(
name|struct
name|usb_std_packet_size
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|enum
name|usb_dev_speed
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_request_callback  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_request_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
name|usb_handle_request_callback
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|usbd_do_request_callback
argument_list|(
name|xfer
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_update_max_frame_size  *  * This function updates the maximum frame size, hence high speed USB  * can transfer multiple consecutive packets.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_update_max_frame_size
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* compute maximum frame size */
if|if
condition|(
name|xfer
operator|->
name|max_packet_count
operator|==
literal|2
condition|)
block|{
name|xfer
operator|->
name|max_frame_size
operator|=
literal|2
operator|*
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|max_packet_count
operator|==
literal|3
condition|)
block|{
name|xfer
operator|->
name|max_frame_size
operator|=
literal|3
operator|*
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|max_frame_size
operator|=
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_get_dma_delay  *  * The following function is called when we need to  * synchronize with DMA hardware.  *  * Returns:  *    0: no DMA delay required  * Else: milliseconds of DMA delay  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_timeout_t
name|usbd_get_dma_delay
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|bus
parameter_list|)
block|{
name|uint32_t
name|temp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bus
operator|->
name|methods
operator|->
name|get_dma_delay
condition|)
block|{
call|(
name|bus
operator|->
name|methods
operator|->
name|get_dma_delay
call|)
argument_list|(
name|bus
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* 		 * Round up and convert to milliseconds. Note that we use 		 * 1024 milliseconds per second. to save a division. 		 */
name|temp
operator|+=
literal|0x3FF
expr_stmt|;
name|temp
operator|/=
literal|0x400
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_setup_sub_malloc  *  * This function will allocate one or more DMA'able memory chunks  * according to "size", "align" and "count" arguments. "ppc" is  * pointed to a linear array of USB page caches afterwards.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USB_HAVE_BUSDMA
end_if

begin_function
name|uint8_t
name|usbd_transfer_setup_sub_malloc
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|,
name|struct
name|usb_page_cache
modifier|*
modifier|*
name|ppc
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|usb_size_t
name|align
parameter_list|,
name|usb_size_t
name|count
parameter_list|)
block|{
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|struct
name|usb_page
modifier|*
name|pg
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|usb_size_t
name|n_dma_pc
decl_stmt|;
name|usb_size_t
name|n_obj
decl_stmt|;
name|usb_size_t
name|x
decl_stmt|;
name|usb_size_t
name|y
decl_stmt|;
name|usb_size_t
name|r
decl_stmt|;
name|usb_size_t
name|z
decl_stmt|;
name|USB_ASSERT
argument_list|(
name|align
operator|>
literal|1
argument_list|,
operator|(
literal|"Invalid alignment, 0x%08x!\n"
operator|,
name|align
operator|)
argument_list|)
expr_stmt|;
name|USB_ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|,
operator|(
literal|"Invalid size = 0!\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to allocate */
block|}
comment|/* 	 * Make sure that the size is aligned properly. 	 */
name|size
operator|=
operator|-
operator|(
operator|(
operator|-
name|size
operator|)
operator|&
operator|(
operator|-
name|align
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Try multi-allocation chunks to reduce the number of DMA 	 * allocations, hence DMA allocations are slow. 	 */
if|if
condition|(
name|size
operator|>=
name|PAGE_SIZE
condition|)
block|{
name|n_dma_pc
operator|=
name|count
expr_stmt|;
name|n_obj
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* compute number of objects per page */
name|n_obj
operator|=
operator|(
name|PAGE_SIZE
operator|/
name|size
operator|)
expr_stmt|;
comment|/* 		 * Compute number of DMA chunks, rounded up 		 * to nearest one: 		 */
name|n_dma_pc
operator|=
operator|(
operator|(
name|count
operator|+
name|n_obj
operator|-
literal|1
operator|)
operator|/
name|n_obj
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|parm
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* for the future */
name|parm
operator|->
name|dma_page_ptr
operator|+=
name|n_dma_pc
expr_stmt|;
name|parm
operator|->
name|dma_page_cache_ptr
operator|+=
name|n_dma_pc
expr_stmt|;
name|parm
operator|->
name|dma_page_ptr
operator|+=
name|count
expr_stmt|;
name|parm
operator|->
name|xfer_page_cache_ptr
operator|+=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|n_dma_pc
condition|;
name|x
operator|++
control|)
block|{
comment|/* need to initialize the page cache */
name|parm
operator|->
name|dma_page_cache_ptr
index|[
name|x
index|]
operator|.
name|tag_parent
operator|=
operator|&
name|parm
operator|->
name|curr_xfer
operator|->
name|xroot
operator|->
name|dma_parent_tag
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|count
condition|;
name|x
operator|++
control|)
block|{
comment|/* need to initialize the page cache */
name|parm
operator|->
name|xfer_page_cache_ptr
index|[
name|x
index|]
operator|.
name|tag_parent
operator|=
operator|&
name|parm
operator|->
name|curr_xfer
operator|->
name|xroot
operator|->
name|dma_parent_tag
expr_stmt|;
block|}
if|if
condition|(
name|ppc
condition|)
block|{
operator|*
name|ppc
operator|=
name|parm
operator|->
name|xfer_page_cache_ptr
expr_stmt|;
block|}
name|r
operator|=
name|count
expr_stmt|;
comment|/* set remainder count */
name|z
operator|=
name|n_obj
operator|*
name|size
expr_stmt|;
comment|/* set allocation size */
name|pc
operator|=
name|parm
operator|->
name|xfer_page_cache_ptr
expr_stmt|;
name|pg
operator|=
name|parm
operator|->
name|dma_page_ptr
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|n_dma_pc
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|r
operator|<
name|n_obj
condition|)
block|{
comment|/* compute last remainder */
name|z
operator|=
name|r
operator|*
name|size
expr_stmt|;
name|n_obj
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|usb_pc_alloc_mem
argument_list|(
name|parm
operator|->
name|dma_page_cache_ptr
argument_list|,
name|pg
argument_list|,
name|z
argument_list|,
name|align
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
comment|/* Set beginning of current buffer */
name|buf
operator|=
name|parm
operator|->
name|dma_page_cache_ptr
operator|->
name|buffer
expr_stmt|;
comment|/* Make room for one DMA page cache and one page */
name|parm
operator|->
name|dma_page_cache_ptr
operator|++
expr_stmt|;
name|pg
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
operator|(
name|y
operator|!=
name|n_obj
operator|)
condition|;
name|y
operator|++
operator|,
name|r
operator|--
operator|,
name|pc
operator|++
operator|,
name|pg
operator|++
control|)
block|{
comment|/* Load sub-chunk into DMA */
if|if
condition|(
name|usb_pc_dmamap_create
argument_list|(
name|pc
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
name|pc
operator|->
name|buffer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|y
operator|*
name|size
argument_list|)
expr_stmt|;
name|pc
operator|->
name|page_start
operator|=
name|pg
expr_stmt|;
name|mtx_lock
argument_list|(
name|pc
operator|->
name|tag_parent
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb_pc_load_mem
argument_list|(
name|pc
argument_list|,
name|size
argument_list|,
literal|1
comment|/* synchronous */
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
name|pc
operator|->
name|tag_parent
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
name|mtx_unlock
argument_list|(
name|pc
operator|->
name|tag_parent
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|parm
operator|->
name|xfer_page_cache_ptr
operator|=
name|pc
expr_stmt|;
name|parm
operator|->
name|dma_page_ptr
operator|=
name|pg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_setup_sub - transfer setup subroutine  *  * This function must be called from the "xfer_setup" callback of the  * USB Host or Device controller driver when setting up an USB  * transfer. This function will setup correct packet sizes, buffer  * sizes, flags and more, that are stored in the "usb_xfer"  * structure.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_setup_sub
parameter_list|(
name|struct
name|usb_setup_params
modifier|*
name|parm
parameter_list|)
block|{
enum|enum
block|{
name|REQ_SIZE
init|=
literal|8
block|,
name|MIN_PKT
init|=
literal|8
block|, 	}
enum|;
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|parm
operator|->
name|curr_xfer
decl_stmt|;
specifier|const
name|struct
name|usb_config
modifier|*
name|setup
init|=
name|parm
operator|->
name|curr_setup
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|edesc
decl_stmt|;
name|struct
name|usb_std_packet_size
name|std_size
decl_stmt|;
name|usb_frcount_t
name|n_frlengths
decl_stmt|;
name|usb_frcount_t
name|n_frbuffers
decl_stmt|;
name|usb_frcount_t
name|x
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|uint8_t
name|zmps
decl_stmt|;
comment|/* 	 * Sanity check. The following parameters must be initialized before 	 * calling this function. 	 */
if|if
condition|(
operator|(
name|parm
operator|->
name|hc_max_packet_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|parm
operator|->
name|hc_max_packet_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|parm
operator|->
name|hc_max_frame_size
operator|==
literal|0
operator|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|edesc
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
expr_stmt|;
name|type
operator|=
operator|(
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
name|xfer
operator|->
name|flags
operator|=
name|setup
operator|->
name|flags
expr_stmt|;
name|xfer
operator|->
name|nframes
operator|=
name|setup
operator|->
name|frames
expr_stmt|;
name|xfer
operator|->
name|timeout
operator|=
name|setup
operator|->
name|timeout
expr_stmt|;
name|xfer
operator|->
name|callback
operator|=
name|setup
operator|->
name|callback
expr_stmt|;
name|xfer
operator|->
name|interval
operator|=
name|setup
operator|->
name|interval
expr_stmt|;
name|xfer
operator|->
name|endpointno
operator|=
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|xfer
operator|->
name|max_packet_size
operator|=
name|UGETW
argument_list|(
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|max_packet_count
operator|=
literal|1
expr_stmt|;
comment|/* make a shadow copy: */
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|=
name|parm
operator|->
name|udev
operator|->
name|flags
operator|.
name|usb_mode
expr_stmt|;
name|parm
operator|->
name|bufsize
operator|=
name|setup
operator|->
name|bufsize
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|speed
operator|==
name|USB_SPEED_HIGH
condition|)
block|{
name|xfer
operator|->
name|max_packet_count
operator|+=
operator|(
name|xfer
operator|->
name|max_packet_size
operator|>>
literal|11
operator|)
operator|&
literal|3
expr_stmt|;
name|xfer
operator|->
name|max_packet_size
operator|&=
literal|0x7FF
expr_stmt|;
block|}
comment|/* range check "max_packet_count" */
if|if
condition|(
name|xfer
operator|->
name|max_packet_count
operator|>
name|parm
operator|->
name|hc_max_packet_count
condition|)
block|{
name|xfer
operator|->
name|max_packet_count
operator|=
name|parm
operator|->
name|hc_max_packet_count
expr_stmt|;
block|}
comment|/* filter "wMaxPacketSize" according to HC capabilities */
if|if
condition|(
operator|(
name|xfer
operator|->
name|max_packet_size
operator|>
name|parm
operator|->
name|hc_max_packet_size
operator|)
operator|||
operator|(
name|xfer
operator|->
name|max_packet_size
operator|==
literal|0
operator|)
condition|)
block|{
name|xfer
operator|->
name|max_packet_size
operator|=
name|parm
operator|->
name|hc_max_packet_size
expr_stmt|;
block|}
comment|/* filter "wMaxPacketSize" according to standard sizes */
name|usbd_get_std_packet_size
argument_list|(
operator|&
name|std_size
argument_list|,
name|type
argument_list|,
name|parm
operator|->
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|std_size
operator|.
name|range
operator|.
name|min
operator|||
name|std_size
operator|.
name|range
operator|.
name|max
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|max_packet_size
operator|<
name|std_size
operator|.
name|range
operator|.
name|min
condition|)
block|{
name|xfer
operator|->
name|max_packet_size
operator|=
name|std_size
operator|.
name|range
operator|.
name|min
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|max_packet_size
operator|>
name|std_size
operator|.
name|range
operator|.
name|max
condition|)
block|{
name|xfer
operator|->
name|max_packet_size
operator|=
name|std_size
operator|.
name|range
operator|.
name|max
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|xfer
operator|->
name|max_packet_size
operator|>=
name|std_size
operator|.
name|fixed
index|[
literal|3
index|]
condition|)
block|{
name|xfer
operator|->
name|max_packet_size
operator|=
name|std_size
operator|.
name|fixed
index|[
literal|3
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|max_packet_size
operator|>=
name|std_size
operator|.
name|fixed
index|[
literal|2
index|]
condition|)
block|{
name|xfer
operator|->
name|max_packet_size
operator|=
name|std_size
operator|.
name|fixed
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|max_packet_size
operator|>=
name|std_size
operator|.
name|fixed
index|[
literal|1
index|]
condition|)
block|{
name|xfer
operator|->
name|max_packet_size
operator|=
name|std_size
operator|.
name|fixed
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* only one possibility left */
name|xfer
operator|->
name|max_packet_size
operator|=
name|std_size
operator|.
name|fixed
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/* compute "max_frame_size" */
name|usbd_update_max_frame_size
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* check interrupt interval and transfer pre-delay */
if|if
condition|(
name|type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|uint16_t
name|frame_limit
decl_stmt|;
name|xfer
operator|->
name|interval
operator|=
literal|0
expr_stmt|;
comment|/* not used, must be zero */
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
operator|=
literal|1
expr_stmt|;
comment|/* set flag */
if|if
condition|(
name|xfer
operator|->
name|timeout
operator|==
literal|0
condition|)
block|{
comment|/* 			 * set a default timeout in 			 * case something goes wrong! 			 */
name|xfer
operator|->
name|timeout
operator|=
literal|1000
operator|/
literal|4
expr_stmt|;
block|}
switch|switch
condition|(
name|parm
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
name|frame_limit
operator|=
name|USB_MAX_FS_ISOC_FRAMES_PER_XFER
expr_stmt|;
name|xfer
operator|->
name|fps_shift
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|frame_limit
operator|=
name|USB_MAX_HS_ISOC_FRAMES_PER_XFER
expr_stmt|;
name|xfer
operator|->
name|fps_shift
operator|=
name|edesc
operator|->
name|bInterval
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|fps_shift
operator|>
literal|0
condition|)
name|xfer
operator|->
name|fps_shift
operator|--
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|fps_shift
operator|>
literal|3
condition|)
name|xfer
operator|->
name|fps_shift
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|>
name|frame_limit
condition|)
block|{
comment|/* 			 * this is not going to work 			 * cross hardware 			 */
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|0
condition|)
block|{
comment|/* 			 * this is not a valid value 			 */
name|parm
operator|->
name|err
operator|=
name|USB_ERR_ZERO_NFRAMES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * if a value is specified use that else check the endpoint 		 * descriptor 		 */
if|if
condition|(
name|xfer
operator|->
name|interval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|UE_INTERRUPT
condition|)
block|{
name|xfer
operator|->
name|interval
operator|=
name|edesc
operator|->
name|bInterval
expr_stmt|;
switch|switch
condition|(
name|parm
operator|->
name|speed
condition|)
block|{
case|case
name|USB_SPEED_SUPER
case|:
case|case
name|USB_SPEED_VARIABLE
case|:
comment|/* 125us -> 1ms */
if|if
condition|(
name|xfer
operator|->
name|interval
operator|<
literal|4
condition|)
name|xfer
operator|->
name|interval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|xfer
operator|->
name|interval
operator|>
literal|16
condition|)
name|xfer
operator|->
name|interval
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
else|else
name|xfer
operator|->
name|interval
operator|=
operator|(
literal|1
operator|<<
operator|(
name|xfer
operator|->
name|interval
operator|-
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|USB_SPEED_HIGH
case|:
comment|/* 125us -> 1ms */
name|xfer
operator|->
name|interval
operator|/=
literal|8
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|xfer
operator|->
name|interval
operator|==
literal|0
condition|)
block|{
comment|/* 					 * One millisecond is the smallest 					 * interval we support: 					 */
name|xfer
operator|->
name|interval
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * NOTE: we do not allow "max_packet_size" or "max_frame_size" 	 * to be equal to zero when setting up USB transfers, hence 	 * this leads to alot of extra code in the USB kernel. 	 */
if|if
condition|(
operator|(
name|xfer
operator|->
name|max_frame_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|xfer
operator|->
name|max_packet_size
operator|==
literal|0
operator|)
condition|)
block|{
name|zmps
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|parm
operator|->
name|bufsize
operator|<=
name|MIN_PKT
operator|)
operator|&&
operator|(
name|type
operator|!=
name|UE_CONTROL
operator|)
operator|&&
operator|(
name|type
operator|!=
name|UE_BULK
operator|)
condition|)
block|{
comment|/* workaround */
name|xfer
operator|->
name|max_packet_size
operator|=
name|MIN_PKT
expr_stmt|;
name|xfer
operator|->
name|max_packet_count
operator|=
literal|1
expr_stmt|;
name|parm
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
comment|/* automatic setup length */
name|usbd_update_max_frame_size
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_ZERO_MAXP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|zmps
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * check if we should setup a default 	 * length: 	 */
if|if
condition|(
name|parm
operator|->
name|bufsize
operator|==
literal|0
condition|)
block|{
name|parm
operator|->
name|bufsize
operator|=
name|xfer
operator|->
name|max_frame_size
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|parm
operator|->
name|bufsize
operator|*=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
block|}
comment|/* 	 * check if we are about to setup a proxy 	 * type of buffer: 	 */
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|proxy_buffer
condition|)
block|{
comment|/* round bufsize up */
name|parm
operator|->
name|bufsize
operator|+=
operator|(
name|xfer
operator|->
name|max_frame_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|bufsize
operator|<
name|xfer
operator|->
name|max_frame_size
condition|)
block|{
comment|/* length wrapped around */
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* subtract remainder */
name|parm
operator|->
name|bufsize
operator|-=
operator|(
name|parm
operator|->
name|bufsize
operator|%
name|xfer
operator|->
name|max_frame_size
operator|)
expr_stmt|;
comment|/* add length of USB device request structure, if any */
if|if
condition|(
name|type
operator|==
name|UE_CONTROL
condition|)
block|{
name|parm
operator|->
name|bufsize
operator|+=
name|REQ_SIZE
expr_stmt|;
comment|/* SETUP message */
block|}
block|}
name|xfer
operator|->
name|max_data_length
operator|=
name|parm
operator|->
name|bufsize
expr_stmt|;
comment|/* Setup "n_frlengths" and "n_frbuffers" */
if|if
condition|(
name|type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|n_frlengths
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|n_frbuffers
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|UE_CONTROL
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|bufsize
operator|<=
name|REQ_SIZE
condition|)
block|{
comment|/* 					 * there will never be any data 					 * stage 					 */
name|xfer
operator|->
name|nframes
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|nframes
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|0
condition|)
block|{
name|xfer
operator|->
name|nframes
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|n_frlengths
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
name|n_frbuffers
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
comment|/* 	 * check if we have room for the 	 * USB device request structure: 	 */
if|if
condition|(
name|type
operator|==
name|UE_CONTROL
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|max_data_length
operator|<
name|REQ_SIZE
condition|)
block|{
comment|/* length wrapped around or too small bufsize */
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|xfer
operator|->
name|max_data_length
operator|-=
name|REQ_SIZE
expr_stmt|;
block|}
comment|/* setup "frlengths" */
name|xfer
operator|->
name|frlengths
operator|=
name|parm
operator|->
name|xfer_length_ptr
expr_stmt|;
name|parm
operator|->
name|xfer_length_ptr
operator|+=
name|n_frlengths
expr_stmt|;
comment|/* setup "frbuffers" */
name|xfer
operator|->
name|frbuffers
operator|=
name|parm
operator|->
name|xfer_page_cache_ptr
expr_stmt|;
name|parm
operator|->
name|xfer_page_cache_ptr
operator|+=
name|n_frbuffers
expr_stmt|;
comment|/* initialize max frame count */
name|xfer
operator|->
name|max_frame_count
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
comment|/* 	 * check if we need to setup 	 * a local buffer: 	 */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
condition|)
block|{
comment|/* align data */
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
name|xfer
operator|->
name|local_buffer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|parm
operator|->
name|buf
argument_list|,
name|parm
operator|->
name|size
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_offset
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|UE_CONTROL
operator|)
operator|&&
operator|(
name|n_frbuffers
operator|>
literal|1
operator|)
condition|)
block|{
name|usbd_xfer_set_frame_offset
argument_list|(
name|xfer
argument_list|,
name|REQ_SIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
name|parm
operator|->
name|bufsize
expr_stmt|;
comment|/* align data again */
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|->
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * Compute maximum buffer size 	 */
if|if
condition|(
name|parm
operator|->
name|bufsize_max
operator|<
name|parm
operator|->
name|bufsize
condition|)
block|{
name|parm
operator|->
name|bufsize_max
operator|=
name|parm
operator|->
name|bufsize
expr_stmt|;
block|}
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
condition|)
block|{
comment|/* 		 * Setup "dma_page_ptr". 		 * 		 * Proof for formula below: 		 * 		 * Assume there are three USB frames having length "a", "b" and 		 * "c". These USB frames will at maximum need "z" 		 * "usb_page" structures. "z" is given by: 		 * 		 * z = ((a / USB_PAGE_SIZE) + 2) + ((b / USB_PAGE_SIZE) + 2) + 		 * ((c / USB_PAGE_SIZE) + 2); 		 * 		 * Constraining "a", "b" and "c" like this: 		 * 		 * (a + b + c)<= parm->bufsize 		 * 		 * We know that: 		 * 		 * z<= ((parm->bufsize / USB_PAGE_SIZE) + (3*2)); 		 * 		 * Here is the general formula: 		 */
name|xfer
operator|->
name|dma_page_ptr
operator|=
name|parm
operator|->
name|dma_page_ptr
expr_stmt|;
name|parm
operator|->
name|dma_page_ptr
operator|+=
operator|(
literal|2
operator|*
name|n_frbuffers
operator|)
expr_stmt|;
name|parm
operator|->
name|dma_page_ptr
operator|+=
operator|(
name|parm
operator|->
name|bufsize
operator|/
name|USB_PAGE_SIZE
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|zmps
condition|)
block|{
comment|/* correct maximum data length */
name|xfer
operator|->
name|max_data_length
operator|=
literal|0
expr_stmt|;
block|}
comment|/* subtract USB frame remainder from "hc_max_frame_size" */
name|xfer
operator|->
name|max_hc_frame_size
operator|=
operator|(
name|parm
operator|->
name|hc_max_frame_size
operator|-
operator|(
name|parm
operator|->
name|hc_max_frame_size
operator|%
name|xfer
operator|->
name|max_frame_size
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|max_hc_frame_size
operator|==
literal|0
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* initialize frame buffers */
if|if
condition|(
name|parm
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|n_frbuffers
condition|;
name|x
operator|++
control|)
block|{
name|xfer
operator|->
name|frbuffers
index|[
name|x
index|]
operator|.
name|tag_parent
operator|=
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|dma_parent_tag
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|&&
operator|(
name|parm
operator|->
name|bufsize_max
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|usb_pc_dmamap_create
argument_list|(
name|xfer
operator|->
name|frbuffers
operator|+
name|x
argument_list|,
name|parm
operator|->
name|bufsize_max
argument_list|)
condition|)
block|{
name|parm
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
name|done
label|:
if|if
condition|(
name|parm
operator|->
name|err
condition|)
block|{
comment|/* 		 * Set some dummy values so that we avoid division by zero: 		 */
name|xfer
operator|->
name|max_hc_frame_size
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|max_frame_size
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|max_packet_size
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|max_data_length
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|nframes
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|max_frame_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_setup - setup an array of USB transfers  *  * NOTE: You must always call "usbd_transfer_unsetup" after calling  * "usbd_transfer_setup" if success was returned.  *  * The idea is that the USB device driver should pre-allocate all its  * transfers by one call to this function.  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usbd_transfer_setup
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ifaces
parameter_list|,
name|struct
name|usb_xfer
modifier|*
modifier|*
name|ppxfer
parameter_list|,
specifier|const
name|struct
name|usb_config
modifier|*
name|setup_start
parameter_list|,
name|uint16_t
name|n_setup
parameter_list|,
name|void
modifier|*
name|priv_sc
parameter_list|,
name|struct
name|mtx
modifier|*
name|xfer_mtx
parameter_list|)
block|{
name|struct
name|usb_xfer
name|dummy
decl_stmt|;
name|struct
name|usb_setup_params
name|parm
decl_stmt|;
specifier|const
name|struct
name|usb_config
modifier|*
name|setup_end
init|=
name|setup_start
operator|+
name|n_setup
decl_stmt|;
specifier|const
name|struct
name|usb_config
modifier|*
name|setup
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|n
decl_stmt|;
name|uint16_t
name|refcount
decl_stmt|;
name|parm
operator|.
name|err
operator|=
literal|0
expr_stmt|;
name|refcount
operator|=
literal|0
expr_stmt|;
name|info
operator|=
name|NULL
expr_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"usbd_transfer_setup can sleep!"
argument_list|)
expr_stmt|;
comment|/* do some checking first */
if|if
condition|(
name|n_setup
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"setup array has zero length!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
if|if
condition|(
name|ifaces
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"ifaces array is NULL!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
if|if
condition|(
name|xfer_mtx
operator|==
name|NULL
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"using global lock\n"
argument_list|)
expr_stmt|;
name|xfer_mtx
operator|=
operator|&
name|Giant
expr_stmt|;
block|}
comment|/* sanity checks */
for|for
control|(
name|setup
operator|=
name|setup_start
operator|,
name|n
operator|=
literal|0
init|;
name|setup
operator|!=
name|setup_end
condition|;
name|setup
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
name|setup
operator|->
name|bufsize
operator|==
operator|(
name|usb_frlength_t
operator|)
operator|-
literal|1
condition|)
block|{
name|parm
operator|.
name|err
operator|=
name|USB_ERR_BAD_BUFSIZE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"invalid bufsize\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setup
operator|->
name|callback
operator|==
name|NULL
condition|)
block|{
name|parm
operator|.
name|err
operator|=
name|USB_ERR_NO_CALLBACK
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"no callback\n"
argument_list|)
expr_stmt|;
block|}
name|ppxfer
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|parm
operator|.
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|bzero
argument_list|(
operator|&
name|parm
argument_list|,
sizeof|sizeof
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|.
name|udev
operator|=
name|udev
expr_stmt|;
name|parm
operator|.
name|speed
operator|=
name|usbd_get_speed
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|parm
operator|.
name|hc_max_packet_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parm
operator|.
name|speed
operator|>=
name|USB_SPEED_MAX
condition|)
block|{
name|parm
operator|.
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* setup all transfers */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|buf
condition|)
block|{
comment|/* 			 * Initialize the "usb_xfer_root" structure, 			 * which is common for all our USB transfers. 			 */
name|info
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|->
name|memory_base
operator|=
name|buf
expr_stmt|;
name|info
operator|->
name|memory_size
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
name|info
operator|->
name|dma_page_cache_start
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|info
operator|->
name|dma_page_cache_end
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|xfer_page_cache_start
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|info
operator|->
name|xfer_page_cache_end
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|info
operator|->
name|cv_drain
argument_list|,
literal|"WDRAIN"
argument_list|)
expr_stmt|;
name|info
operator|->
name|xfer_mtx
operator|=
name|xfer_mtx
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
name|usb_dma_tag_setup
argument_list|(
operator|&
name|info
operator|->
name|dma_parent_tag
argument_list|,
name|parm
operator|.
name|dma_tag_p
argument_list|,
name|udev
operator|->
name|bus
operator|->
name|dma_parent_tag
index|[
literal|0
index|]
operator|.
name|tag
argument_list|,
name|xfer_mtx
argument_list|,
operator|&
name|usb_bdma_done_event
argument_list|,
literal|32
argument_list|,
name|parm
operator|.
name|dma_tag_max
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|bus
operator|=
name|udev
operator|->
name|bus
expr_stmt|;
name|info
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|info
operator|->
name|done_q
operator|.
name|head
argument_list|)
expr_stmt|;
name|info
operator|->
name|done_q
operator|.
name|command
operator|=
operator|&
name|usbd_callback_wrapper
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
name|TAILQ_INIT
argument_list|(
operator|&
name|info
operator|->
name|dma_q
operator|.
name|head
argument_list|)
expr_stmt|;
name|info
operator|->
name|dma_q
operator|.
name|command
operator|=
operator|&
name|usb_bdma_work_loop
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|done_m
index|[
literal|0
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|usb_callback_proc
expr_stmt|;
name|info
operator|->
name|done_m
index|[
literal|0
index|]
operator|.
name|xroot
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|done_m
index|[
literal|1
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|usb_callback_proc
expr_stmt|;
name|info
operator|->
name|done_m
index|[
literal|1
index|]
operator|.
name|xroot
operator|=
name|info
expr_stmt|;
comment|/*  			 * In device side mode control endpoint 			 * requests need to run from a separate 			 * context, else there is a chance of 			 * deadlock! 			 */
if|if
condition|(
name|setup_start
operator|==
name|usb_control_ep_cfg
condition|)
name|info
operator|->
name|done_p
operator|=
operator|&
name|udev
operator|->
name|bus
operator|->
name|control_xfer_proc
expr_stmt|;
elseif|else
if|if
condition|(
name|xfer_mtx
operator|==
operator|&
name|Giant
condition|)
name|info
operator|->
name|done_p
operator|=
operator|&
name|udev
operator|->
name|bus
operator|->
name|giant_callback_proc
expr_stmt|;
else|else
name|info
operator|->
name|done_p
operator|=
operator|&
name|udev
operator|->
name|bus
operator|->
name|non_giant_callback_proc
expr_stmt|;
block|}
comment|/* reset sizes */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|parm
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
sizeof|sizeof
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|setup
operator|=
name|setup_start
operator|,
name|n
operator|=
literal|0
init|;
name|setup
operator|!=
name|setup_end
condition|;
name|setup
operator|++
operator|,
name|n
operator|++
control|)
block|{
comment|/* skip USB transfers without callbacks: */
if|if
condition|(
name|setup
operator|->
name|callback
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* see if there is a matching endpoint */
name|ep
operator|=
name|usbd_get_endpoint
argument_list|(
name|udev
argument_list|,
name|ifaces
index|[
name|setup
operator|->
name|if_index
index|]
argument_list|,
name|setup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ep
operator|->
name|methods
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|setup
operator|->
name|flags
operator|.
name|no_pipe_ok
condition|)
continue|continue;
if|if
condition|(
operator|(
name|setup
operator|->
name|usb_mode
operator|!=
name|USB_MODE_DUAL
operator|)
operator|&&
operator|(
name|setup
operator|->
name|usb_mode
operator|!=
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|)
condition|)
continue|continue;
name|parm
operator|.
name|err
operator|=
name|USB_ERR_NO_PIPE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* align data properly */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* store current setup pointer */
name|parm
operator|.
name|curr_setup
operator|=
name|setup
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
comment|/* 				 * Common initialization of the 				 * "usb_xfer" structure. 				 */
name|xfer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|address
operator|=
name|udev
operator|->
name|address
expr_stmt|;
name|xfer
operator|->
name|priv_sc
operator|=
name|priv_sc
expr_stmt|;
name|xfer
operator|->
name|xroot
operator|=
name|info
expr_stmt|;
name|usb_callout_init_mtx
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|,
operator|&
name|udev
operator|->
name|bus
operator|->
name|bus_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Setup a dummy xfer, hence we are 				 * writing to the "usb_xfer" 				 * structure pointed to by "xfer" 				 * before we have allocated any 				 * memory: 				 */
name|xfer
operator|=
operator|&
name|dummy
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|refcount
operator|++
expr_stmt|;
block|}
comment|/* set transfer endpoint pointer */
name|xfer
operator|->
name|endpoint
operator|=
name|ep
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
sizeof|sizeof
argument_list|(
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|parm
operator|.
name|methods
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|methods
expr_stmt|;
name|parm
operator|.
name|curr_xfer
operator|=
name|xfer
expr_stmt|;
comment|/* 			 * Call the Host or Device controller transfer 			 * setup routine: 			 */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|xfer_setup
call|)
argument_list|(
operator|&
name|parm
argument_list|)
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|parm
operator|.
name|err
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|buf
condition|)
block|{
comment|/* 				 * Increment the endpoint refcount. This 				 * basically prevents setting a new 				 * configuration and alternate setting 				 * when USB transfers are in use on 				 * the given interface. Search the USB 				 * code for "endpoint->refcount_alloc" if you 				 * want more information. 				 */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|refcount_alloc
operator|>=
name|USB_EP_REF_MAX
condition|)
name|parm
operator|.
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|refcount_alloc
operator|++
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|endpoint
operator|->
name|refcount_alloc
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"usbd_transfer_setup(): Refcount wrapped to zero\n"
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* 				 * Whenever we set ppxfer[] then we 				 * also need to increment the 				 * "setup_refcount": 				 */
name|info
operator|->
name|setup_refcount
operator|++
expr_stmt|;
comment|/* 				 * Transfer is successfully setup and 				 * can be used: 				 */
name|ppxfer
index|[
name|n
index|]
operator|=
name|xfer
expr_stmt|;
block|}
comment|/* check for error */
if|if
condition|(
name|parm
operator|.
name|err
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|buf
operator|||
name|parm
operator|.
name|err
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* no transfers - nothing to do ! */
goto|goto
name|done
goto|;
block|}
comment|/* align data properly */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* store offset temporarily */
name|parm
operator|.
name|size
index|[
literal|1
index|]
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * The number of DMA tags required depends on 		 * the number of endpoints. The current estimate 		 * for maximum number of DMA tags per endpoint 		 * is two. 		 */
name|parm
operator|.
name|dma_tag_max
operator|+=
literal|2
operator|*
name|MIN
argument_list|(
name|n_setup
argument_list|,
name|USB_EP_MAX
argument_list|)
expr_stmt|;
comment|/* 		 * DMA tags for QH, TD, Data and more. 		 */
name|parm
operator|.
name|dma_tag_max
operator|+=
literal|8
expr_stmt|;
name|parm
operator|.
name|dma_tag_p
operator|+=
name|parm
operator|.
name|dma_tag_max
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|parm
operator|.
name|dma_tag_p
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
comment|/* align data properly */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* store offset temporarily */
name|parm
operator|.
name|size
index|[
literal|3
index|]
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|parm
operator|.
name|dma_page_ptr
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
comment|/* align data properly */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* store offset temporarily */
name|parm
operator|.
name|size
index|[
literal|4
index|]
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|parm
operator|.
name|dma_page_cache_ptr
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
comment|/* store end offset temporarily */
name|parm
operator|.
name|size
index|[
literal|5
index|]
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|parm
operator|.
name|xfer_page_cache_ptr
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
comment|/* store end offset temporarily */
name|parm
operator|.
name|size
index|[
literal|2
index|]
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
comment|/* align data properly */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|6
index|]
operator|=
name|parm
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|parm
operator|.
name|xfer_length_ptr
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
comment|/* align data properly */
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|+=
operator|(
operator|(
operator|-
name|parm
operator|.
name|size
index|[
literal|0
index|]
operator|)
operator|&
operator|(
name|USB_HOST_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* allocate zeroed memory */
name|buf
operator|=
name|malloc
argument_list|(
name|parm
operator|.
name|size
index|[
literal|0
index|]
argument_list|,
name|M_USB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|parm
operator|.
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"cannot allocate memory block for "
literal|"configuration (%d bytes)\n"
argument_list|,
name|parm
operator|.
name|size
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|parm
operator|.
name|dma_tag_p
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|parm
operator|.
name|dma_page_ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|parm
operator|.
name|dma_page_cache_ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|parm
operator|.
name|xfer_page_cache_ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|parm
operator|.
name|xfer_length_ptr
operator|=
name|USB_ADD_BYTES
argument_list|(
name|buf
argument_list|,
name|parm
operator|.
name|size
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|buf
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|setup_refcount
operator|==
literal|0
condition|)
block|{
comment|/* 			 * "usbd_transfer_unsetup_sub" will unlock 			 * the bus mutex before returning ! 			 */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* something went wrong */
name|usbd_transfer_unsetup_sub
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parm
operator|.
name|err
condition|)
block|{
name|usbd_transfer_unsetup
argument_list|(
name|ppxfer
argument_list|,
name|n_setup
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|parm
operator|.
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_unsetup_sub - factored out code  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_transfer_unsetup_sub
parameter_list|(
name|struct
name|usb_xfer_root
modifier|*
name|info
parameter_list|,
name|uint8_t
name|needs_delay
parameter_list|)
block|{
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|info
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* wait for any outstanding DMA operations */
if|if
condition|(
name|needs_delay
condition|)
block|{
name|usb_timeout_t
name|temp
decl_stmt|;
name|temp
operator|=
name|usbd_get_dma_delay
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
operator|&
name|info
operator|->
name|bus
operator|->
name|bus_mtx
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* make sure that our done messages are not queued anywhere */
name|usb_proc_mwait
argument_list|(
name|info
operator|->
name|done_p
argument_list|,
operator|&
name|info
operator|->
name|done_m
index|[
literal|0
index|]
argument_list|,
operator|&
name|info
operator|->
name|done_m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
comment|/* free DMA'able memory, if any */
name|pc
operator|=
name|info
operator|->
name|dma_page_cache_start
expr_stmt|;
while|while
condition|(
name|pc
operator|!=
name|info
operator|->
name|dma_page_cache_end
condition|)
block|{
name|usb_pc_free_mem
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
comment|/* free DMA maps in all "xfer->frbuffers" */
name|pc
operator|=
name|info
operator|->
name|xfer_page_cache_start
expr_stmt|;
while|while
condition|(
name|pc
operator|!=
name|info
operator|->
name|xfer_page_cache_end
condition|)
block|{
name|usb_pc_dmamap_destroy
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
comment|/* free all DMA tags */
name|usb_dma_tag_unsetup
argument_list|(
operator|&
name|info
operator|->
name|dma_parent_tag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cv_destroy
argument_list|(
operator|&
name|info
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
comment|/* 	 * free the "memory_base" last, hence the "info" structure is 	 * contained within the "memory_base"! 	 */
name|free
argument_list|(
name|info
operator|->
name|memory_base
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_unsetup - unsetup/free an array of USB transfers  *  * NOTE: All USB transfers in progress will get called back passing  * the error code "USB_ERR_CANCELLED" before this function  * returns.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_unsetup
parameter_list|(
name|struct
name|usb_xfer
modifier|*
modifier|*
name|pxfer
parameter_list|,
name|uint16_t
name|n_setup
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|uint8_t
name|needs_delay
init|=
literal|0
decl_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"usbd_transfer_unsetup can sleep!"
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_setup
operator|--
condition|)
block|{
name|xfer
operator|=
name|pxfer
index|[
name|n_setup
index|]
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
continue|continue;
name|info
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
name|USB_XFER_LOCK
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* 		 * HINT: when you start/stop a transfer, it might be a 		 * good idea to directly use the "pxfer[]" structure: 		 * 		 * usbd_transfer_start(sc->pxfer[0]); 		 * usbd_transfer_stop(sc->pxfer[0]); 		 * 		 * That way, if your code has many parts that will not 		 * stop running under the same lock, in other words 		 * "xfer_mtx", the usbd_transfer_start and 		 * usbd_transfer_stop functions will simply return 		 * when they detect a NULL pointer argument. 		 * 		 * To avoid any races we clear the "pxfer[]" pointer 		 * while holding the private mutex of the driver: 		 */
name|pxfer
index|[
name|n_setup
index|]
operator|=
name|NULL
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|USB_XFER_UNLOCK
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|usbd_transfer_drain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
condition|)
name|needs_delay
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * NOTE: default endpoint does not have an 		 * interface, even if endpoint->iface_index == 0 		 */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|endpoint
operator|->
name|refcount_alloc
operator|--
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usb_callout_drain
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|USB_ASSERT
argument_list|(
name|info
operator|->
name|setup_refcount
operator|!=
literal|0
argument_list|,
operator|(
literal|"Invalid setup "
literal|"reference count!\n"
operator|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|setup_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|setup_refcount
operator|==
literal|0
condition|)
block|{
name|usbd_transfer_unsetup_sub
argument_list|(
name|info
argument_list|,
name|needs_delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_control_transfer_init - factored out code  *  * In USB Device Mode we have to wait for the SETUP packet which  * containst the "struct usb_device_request" structure, before we can  * transfer any data. In USB Host Mode we already have the SETUP  * packet at the moment the USB transfer is started. This leads us to  * having to setup the USB transfer at two different places in  * time. This function just contains factored out control transfer  * initialisation code, so that we don't duplicate the code.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_control_transfer_init
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
comment|/* copy out the USB request header */
name|usbd_copy_out
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* setup remainder */
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
operator|=
name|UGETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|)
expr_stmt|;
comment|/* copy direction to endpoint variable */
name|xfer
operator|->
name|endpointno
operator|&=
operator|~
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
expr_stmt|;
name|xfer
operator|->
name|endpointno
operator||=
operator|(
name|req
operator|.
name|bmRequestType
operator|&
name|UT_READ
operator|)
condition|?
name|UE_DIR_IN
else|:
name|UE_DIR_OUT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_setup_ctrl_transfer  *  * This function handles initialisation of control transfers. Control  * transfers are special in that regard that they can both transmit  * and receive data.  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usbd_setup_ctrl_transfer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|usb_frlength_t
name|len
decl_stmt|;
comment|/* Check for control endpoint stall */
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|stall_pipe
operator|&&
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
comment|/* the control transfer is no longer active */
name|xfer
operator|->
name|flags_int
operator|.
name|control_stall
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* don't stall control transfer by default */
name|xfer
operator|->
name|flags_int
operator|.
name|control_stall
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check for invalid number of frames */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|>
literal|2
condition|)
block|{
comment|/* 		 * If you need to split a control transfer, you 		 * have to do one part at a time. Only with 		 * non-control transfers you can do multiple 		 * parts a time. 		 */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Too many frames: %u\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/*          * Check if there is a control          * transfer in progress:          */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
condition|)
block|{
comment|/* clear send header flag */
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
operator|=
literal|0
expr_stmt|;
comment|/* setup control transfer */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
name|usbd_control_transfer_init
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get data length */
name|len
operator|=
name|xfer
operator|->
name|sumlen
expr_stmt|;
block|}
else|else
block|{
comment|/* the size of the SETUP structure is hardcoded ! */
if|if
condition|(
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Wrong framelength %u != %zu\n"
argument_list|,
name|xfer
operator|->
name|frlengths
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check USB mode */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* check number of frames */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|!=
literal|1
condition|)
block|{
comment|/* 			         * We need to receive the setup 			         * message first so that we know the 			         * data direction! 			         */
name|DPRINTF
argument_list|(
literal|"Misconfigured transfer\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * Set a dummy "control_rem" value.  This 			 * variable will be overwritten later by a 			 * call to "usbd_control_transfer_init()" ! 			 */
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
operator|=
literal|0xFFFF
expr_stmt|;
block|}
else|else
block|{
comment|/* setup "endpoint" and "control_rem" */
name|usbd_control_transfer_init
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
comment|/* set transfer-header flag */
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
operator|=
literal|1
expr_stmt|;
comment|/* get data length */
name|len
operator|=
operator|(
name|xfer
operator|->
name|sumlen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* check if there is a length mismatch */
if|if
condition|(
name|len
operator|>
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Length (%d) greater than "
literal|"remaining length (%d)!\n"
argument_list|,
name|len
argument_list|,
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* check if we are doing a short transfer */
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|len
operator|!=
name|xfer
operator|->
name|max_data_length
operator|)
operator|&&
operator|(
name|len
operator|!=
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|nframes
operator|!=
literal|1
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Short control transfer without "
literal|"force_short_xfer set!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
operator|-=
name|len
expr_stmt|;
block|}
comment|/* the status part is executed when "control_act" is 0 */
if|if
condition|(
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_rem
operator|>
literal|0
operator|)
operator|||
operator|(
name|xfer
operator|->
name|flags
operator|.
name|manual_status
operator|)
condition|)
block|{
comment|/* don't execute the STATUS stage yet */
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
operator|=
literal|1
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|nframes
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* 		         * This is not a valid operation! 		         */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Invalid parameter "
literal|"combination\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
comment|/* time to execute the STATUS stage */
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|error
label|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_submit - start USB hardware for the given transfer  *  * This function should only be called from the USB callback.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_submit
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
name|usb_frcount_t
name|x
decl_stmt|;
name|info
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
name|bus
operator|=
name|info
operator|->
name|bus
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"xfer=%p, endpoint=%p, nframes=%d, dir=%s\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|,
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_DEBUG
if|if
condition|(
name|USB_DEBUG_VAR
operator|>
literal|0
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usb_dump_endpoint
argument_list|(
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|bus
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* Only open the USB transfer once! */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|open
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|open
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"open\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
call|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|->
name|open
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
comment|/* set "transferring" flag */
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|USB_HAVE_POWERD
comment|/* increment power reference */
name|usbd_transfer_power_ref
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check if the transfer is waiting on a queue, most 	 * frequently the "done_q": 	 */
if|if
condition|(
name|xfer
operator|->
name|wait_queue
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_dequeue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
block|}
comment|/* clear "did_dma_delay" flag */
name|xfer
operator|->
name|flags_int
operator|.
name|did_dma_delay
operator|=
literal|0
expr_stmt|;
comment|/* clear "did_close" flag */
name|xfer
operator|->
name|flags_int
operator|.
name|did_close
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
comment|/* clear "bdma_setup" flag */
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_setup
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* by default we cannot cancel any USB transfer immediately */
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|=
literal|0
expr_stmt|;
comment|/* clear lengths and frame counts by default */
name|xfer
operator|->
name|sumlen
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|actlen
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|aframes
operator|=
literal|0
expr_stmt|;
comment|/* clear any previous errors */
name|xfer
operator|->
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Check if the device is still alive */
if|if
condition|(
name|info
operator|->
name|udev
operator|->
name|state
operator|<
name|USB_STATE_POWERED
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* 		 * Must return cancelled error code else 		 * device drivers can hang. 		 */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_CANCELLED
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* sanity check */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|stall_pipe
condition|)
block|{
comment|/* 			 * Special case - want to stall without transferring 			 * any data: 			 */
name|DPRINTF
argument_list|(
literal|"xfer=%p nframes=0: stall "
literal|"or clear stall!\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|=
literal|1
expr_stmt|;
comment|/* start the transfer */
name|usb_command_wrapper
argument_list|(
operator|&
name|xfer
operator|->
name|endpoint
operator|->
name|endpoint_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_INVAL
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* compute total transfer length */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|xfer
operator|->
name|nframes
condition|;
name|x
operator|++
control|)
block|{
name|xfer
operator|->
name|sumlen
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|sumlen
operator|<
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
condition|)
block|{
comment|/* length wrapped around */
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_INVAL
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* clear some internal flags */
name|xfer
operator|->
name|flags_int
operator|.
name|short_xfer_ok
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|=
literal|0
expr_stmt|;
comment|/* check if this is a control transfer */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|usbd_setup_ctrl_transfer
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
name|USB_ERR_STALLED
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Setup filtered version of some transfer flags, 	 * in case of data read direction 	 */
if|if
condition|(
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|short_frames_ok
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|short_xfer_ok
operator|=
literal|1
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|short_xfer_ok
condition|)
block|{
name|xfer
operator|->
name|flags_int
operator|.
name|short_xfer_ok
operator|=
literal|1
expr_stmt|;
comment|/* check for control transfer */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* 				 * 1) Control transfers do not support 				 * reception of multiple short USB 				 * frames in host mode and device side 				 * mode, with exception of: 				 * 				 * 2) Due to sometimes buggy device 				 * side firmware we need to do a 				 * STATUS stage in case of short 				 * control transfers in USB host mode. 				 * The STATUS stage then becomes the 				 * "alt_next" to the DATA stage. 				 */
name|xfer
operator|->
name|flags_int
operator|.
name|short_frames_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check if BUS-DMA support is enabled and try to load virtual 	 * buffers into DMA, if any: 	 */
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
condition|)
block|{
comment|/* insert the USB transfer last in the BUS-DMA queue */
name|usb_command_wrapper
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|dma_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Enter the USB transfer into the Host Controller or 	 * Device Controller schedule: 	 */
name|usbd_pipe_enter
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_pipe_enter - factored out code  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_pipe_enter
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|ep
operator|=
name|xfer
operator|->
name|endpoint
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"enter\n"
argument_list|)
expr_stmt|;
comment|/* enter the transfer */
call|(
name|ep
operator|->
name|methods
operator|->
name|enter
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|=
literal|1
expr_stmt|;
comment|/* check for transfer error */
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
comment|/* some error has happened */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* start the transfer */
name|usb_command_wrapper
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_start - start an USB transfer  *  * NOTE: Calling this function more than one time will only  *       result in a single transfer start, until the USB transfer  *       completes.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_start
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* transfer is gone */
return|return;
block|}
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* mark the USB transfer started */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|started
condition|)
block|{
comment|/* lock the BUS lock to avoid races updating flags_int */
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|started
operator|=
literal|1
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
comment|/* check if the USB transfer callback is already transferring */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
condition|)
block|{
return|return;
block|}
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* call the USB transfer callback */
name|usbd_callback_ss_done_defer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_stop - stop an USB transfer  *  * NOTE: Calling this function more than one time will only  *       result in a single transfer stop.  * NOTE: When this function returns it is not safe to free nor  *       reuse any DMA buffers. See "usbd_transfer_drain()".  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_stop
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* transfer is gone */
return|return;
block|}
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* check if the USB transfer was ever opened */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|open
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|started
condition|)
block|{
comment|/* nothing to do except clearing the "started" flag */
comment|/* lock the BUS lock to avoid races updating flags_int */
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|started
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* try to stop the current USB transfer */
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* override any previous error */
name|xfer
operator|->
name|error
operator|=
name|USB_ERR_CANCELLED
expr_stmt|;
comment|/* 	 * Clear "open" and "started" when both private and USB lock 	 * is locked so that we don't get a race updating "flags_int" 	 */
name|xfer
operator|->
name|flags_int
operator|.
name|open
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|started
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check if we can cancel the USB transfer immediately. 	 */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|did_close
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"close\n"
argument_list|)
expr_stmt|;
comment|/* 			 * The following will lead to an USB_ERR_CANCELLED 			 * error code being passed to the USB callback. 			 */
call|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|->
name|close
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* only close once */
name|xfer
operator|->
name|flags_int
operator|.
name|did_close
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* need to wait for the next done callback */
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"close\n"
argument_list|)
expr_stmt|;
comment|/* close here and now */
call|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|->
name|close
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
comment|/* 		 * Any additional DMA delay is done by 		 * "usbd_transfer_unsetup()". 		 */
comment|/* 		 * Special case. Check if we need to restart a blocked 		 * endpoint. 		 */
name|ep
operator|=
name|xfer
operator|->
name|endpoint
expr_stmt|;
comment|/* 		 * If the current USB transfer is completing we need 		 * to start the next one: 		 */
if|if
condition|(
name|ep
operator|->
name|endpoint_q
operator|.
name|curr
operator|==
name|xfer
condition|)
block|{
name|usb_command_wrapper
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_pending  *  * This function will check if an USB transfer is pending which is a  * little bit complicated!  * Return values:  * 0: Not pending  * 1: Pending: The USB transfer will receive a callback in the future.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usbd_transfer_pending
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|struct
name|usb_xfer_queue
modifier|*
name|pq
decl_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* transfer is gone */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
condition|)
block|{
comment|/* trivial case */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|wait_queue
condition|)
block|{
comment|/* we are waiting on a queue somewhere */
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|info
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
name|pq
operator|=
operator|&
name|info
operator|->
name|done_q
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|curr
operator|==
name|xfer
condition|)
block|{
comment|/* we are currently scheduled for callback */
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* we are not pending */
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_drain  *  * This function will stop the USB transfer and wait for any  * additional BUS-DMA and HW-DMA operations to complete. Buffers that  * are loaded into DMA can safely be freed or reused after that this  * function has returned.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_drain
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"usbd_transfer_drain can sleep!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* transfer is gone */
return|return;
block|}
if|if
condition|(
name|xfer
operator|->
name|xroot
operator|->
name|xfer_mtx
operator|!=
operator|&
name|Giant
condition|)
block|{
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
name|USB_XFER_LOCK
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
while|while
condition|(
name|usbd_transfer_pending
argument_list|(
name|xfer
argument_list|)
operator|||
name|xfer
operator|->
name|flags_int
operator|.
name|doing_callback
condition|)
block|{
comment|/*  		 * It is allowed that the callback can drop its 		 * transfer mutex. In that case checking only 		 * "usbd_transfer_pending()" is not enough to tell if 		 * the USB transfer is fully drained. We also need to 		 * check the internal "doing_callback" flag. 		 */
name|xfer
operator|->
name|flags_int
operator|.
name|draining
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Wait until the current outstanding USB 		 * transfer is complete ! 		 */
name|cv_wait
argument_list|(
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|cv_drain
argument_list|,
name|xfer
operator|->
name|xroot
operator|->
name|xfer_mtx
argument_list|)
expr_stmt|;
block|}
name|USB_XFER_UNLOCK
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|usb_page_cache
modifier|*
name|usbd_xfer_get_frame
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frcount_t
name|frindex
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|frindex
operator|<
name|xfer
operator|->
name|max_frame_count
argument_list|,
operator|(
literal|"frame index overflow"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
name|frindex
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_xfer_get_fps_shift  *  * The following function is only useful for isochronous transfers. It  * returns how many times the frame execution rate has been shifted  * down.  *  * Return value:  * Success: 0..3  * Failure: 0  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usbd_xfer_get_fps_shift
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|fps_shift
operator|)
return|;
block|}
end_function

begin_function
name|usb_frlength_t
name|usbd_xfer_frame_len
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frcount_t
name|frindex
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|frindex
operator|<
name|xfer
operator|->
name|max_frame_count
argument_list|,
operator|(
literal|"frame index overflow"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|xfer
operator|->
name|frlengths
index|[
name|frindex
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_xfer_set_frame_data  *  * This function sets the pointer of the buffer that should  * loaded directly into DMA for the given USB frame. Passing "ptr"  * equal to NULL while the corresponding "frlength" is greater  * than zero gives undefined results!  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_xfer_set_frame_data
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frcount_t
name|frindex
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|frindex
operator|<
name|xfer
operator|->
name|max_frame_count
argument_list|,
operator|(
literal|"frame index overflow"
operator|)
argument_list|)
expr_stmt|;
comment|/* set virtual address to load and length */
name|xfer
operator|->
name|frbuffers
index|[
name|frindex
index|]
operator|.
name|buffer
operator|=
name|ptr
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|frindex
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_frame_data
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frcount_t
name|frindex
parameter_list|,
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|frindex
operator|<
name|xfer
operator|->
name|max_frame_count
argument_list|,
operator|(
literal|"frame index overflow"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|=
name|xfer
operator|->
name|frbuffers
index|[
name|frindex
index|]
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|frindex
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_status
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
modifier|*
name|actlen
parameter_list|,
name|int
modifier|*
name|sumlen
parameter_list|,
name|int
modifier|*
name|aframes
parameter_list|,
name|int
modifier|*
name|nframes
parameter_list|)
block|{
if|if
condition|(
name|actlen
operator|!=
name|NULL
condition|)
operator|*
name|actlen
operator|=
name|xfer
operator|->
name|actlen
expr_stmt|;
if|if
condition|(
name|sumlen
operator|!=
name|NULL
condition|)
operator|*
name|sumlen
operator|=
name|xfer
operator|->
name|sumlen
expr_stmt|;
if|if
condition|(
name|aframes
operator|!=
name|NULL
condition|)
operator|*
name|aframes
operator|=
name|xfer
operator|->
name|aframes
expr_stmt|;
if|if
condition|(
name|nframes
operator|!=
name|NULL
condition|)
operator|*
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_xfer_set_frame_offset  *  * This function sets the frame data buffer offset relative to the beginning  * of the USB DMA buffer allocated for this USB transfer.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_xfer_set_frame_offset
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frlength_t
name|offset
parameter_list|,
name|usb_frcount_t
name|frindex
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
argument_list|,
operator|(
literal|"Cannot offset data frame "
literal|"when the USB buffer is external!\n"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|frindex
operator|<
name|xfer
operator|->
name|max_frame_count
argument_list|,
operator|(
literal|"frame index overflow"
operator|)
argument_list|)
expr_stmt|;
comment|/* set virtual address to load */
name|xfer
operator|->
name|frbuffers
index|[
name|frindex
index|]
operator|.
name|buffer
operator|=
name|USB_ADD_BYTES
argument_list|(
name|xfer
operator|->
name|local_buffer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_set_interval
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|xfer
operator|->
name|interval
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_set_timeout
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|xfer
operator|->
name|timeout
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_set_frames
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frcount_t
name|n
parameter_list|)
block|{
name|xfer
operator|->
name|nframes
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|usb_frcount_t
name|usbd_xfer_max_frames
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|max_frame_count
operator|)
return|;
block|}
end_function

begin_function
name|usb_frlength_t
name|usbd_xfer_max_len
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|max_data_length
operator|)
return|;
block|}
end_function

begin_function
name|usb_frlength_t
name|usbd_xfer_max_framelen
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|max_frame_size
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_set_frame_len
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_frcount_t
name|frindex
parameter_list|,
name|usb_frlength_t
name|len
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|frindex
operator|<
name|xfer
operator|->
name|max_frame_count
argument_list|,
operator|(
literal|"frame index overflow"
operator|)
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|frlengths
index|[
name|frindex
index|]
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_callback_proc - factored out code  *  * This function performs USB callbacks.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_callback_proc
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|_pm
parameter_list|)
block|{
name|struct
name|usb_done_msg
modifier|*
name|pm
init|=
operator|(
name|void
operator|*
operator|)
name|_pm
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
init|=
name|pm
operator|->
name|xroot
decl_stmt|;
comment|/* Change locking order */
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * We exploit the fact that the mutex is the same for all 	 * callbacks that will be called from this thread: 	 */
name|mtx_lock
argument_list|(
name|info
operator|->
name|xfer_mtx
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* Continue where we lost track */
name|usb_command_wrapper
argument_list|(
operator|&
name|info
operator|->
name|done_q
argument_list|,
name|info
operator|->
name|done_q
operator|.
name|curr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|info
operator|->
name|xfer_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_callback_ss_done_defer  *  * This function will defer the start, stop and done callback to the  * correct thread.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_callback_ss_done_defer
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_xfer_root
modifier|*
name|info
init|=
name|xfer
operator|->
name|xroot
decl_stmt|;
name|struct
name|usb_xfer_queue
modifier|*
name|pq
init|=
operator|&
name|info
operator|->
name|done_q
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|curr
operator|!=
name|xfer
condition|)
block|{
name|usbd_transfer_enqueue
argument_list|(
name|pq
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pq
operator|->
name|recurse_1
condition|)
block|{
comment|/* 	         * We have to postpone the callback due to the fact we 	         * will have a Lock Order Reversal, LOR, if we try to 	         * proceed ! 	         */
if|if
condition|(
name|usb_proc_msignal
argument_list|(
name|info
operator|->
name|done_p
argument_list|,
operator|&
name|info
operator|->
name|done_m
index|[
literal|0
index|]
argument_list|,
operator|&
name|info
operator|->
name|done_m
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
block|}
else|else
block|{
comment|/* clear second recurse flag */
name|pq
operator|->
name|recurse_2
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_callback_wrapper  *  * This is a wrapper for USB callbacks. This wrapper does some  * auto-magic things like figuring out if we can call the callback  * directly from the current context or if we need to wakeup the  * interrupt process.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_callback_wrapper
parameter_list|(
name|struct
name|usb_xfer_queue
modifier|*
name|pq
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|pq
operator|->
name|curr
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
init|=
name|xfer
operator|->
name|xroot
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|info
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_owned
argument_list|(
name|info
operator|->
name|xfer_mtx
argument_list|)
condition|)
block|{
comment|/* 	       	 * Cases that end up here: 		 * 		 * 5) HW interrupt done callback or other source. 		 */
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"case 5\n"
argument_list|)
expr_stmt|;
comment|/* 	         * We have to postpone the callback due to the fact we 	         * will have a Lock Order Reversal, LOR, if we try to 	         * proceed ! 	         */
if|if
condition|(
name|usb_proc_msignal
argument_list|(
name|info
operator|->
name|done_p
argument_list|,
operator|&
name|info
operator|->
name|done_m
index|[
literal|0
index|]
argument_list|,
operator|&
name|info
operator|->
name|done_m
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* ignore */
block|}
return|return;
block|}
comment|/* 	 * Cases that end up here: 	 * 	 * 1) We are starting a transfer 	 * 2) We are prematurely calling back a transfer 	 * 3) We are stopping a transfer 	 * 4) We are doing an ordinary callback 	 */
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"case 1-4\n"
argument_list|)
expr_stmt|;
comment|/* get next USB transfer in the queue */
name|info
operator|->
name|done_q
operator|.
name|curr
operator|=
name|NULL
expr_stmt|;
comment|/* set flag in case of drain */
name|xfer
operator|->
name|flags_int
operator|.
name|doing_callback
operator|=
literal|1
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|info
operator|->
name|bus
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* set correct USB state for callback */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
condition|)
block|{
name|xfer
operator|->
name|usb_state
operator|=
name|USB_ST_SETUP
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|started
condition|)
block|{
comment|/* we got stopped before we even got started */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|usbd_callback_wrapper_sub
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
comment|/* the callback has been deferred */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
name|USB_HAVE_POWERD
comment|/* decrement power reference */
name|usbd_transfer_power_ref
argument_list|(
name|xfer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
name|xfer
operator|->
name|usb_state
operator|=
name|USB_ST_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|/* set transferred state */
name|xfer
operator|->
name|usb_state
operator|=
name|USB_ST_TRANSFERRED
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
comment|/* sync DMA memory, if any */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_enable
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|bdma_no_post_sync
operator|)
condition|)
block|{
name|usb_bdma_post_sync
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* call processing routine */
call|(
name|xfer
operator|->
name|callback
call|)
argument_list|(
name|xfer
argument_list|,
name|xfer
operator|->
name|error
argument_list|)
expr_stmt|;
comment|/* pickup the USB mutex again */
name|USB_BUS_LOCK
argument_list|(
name|info
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we got started after that we got cancelled, but 	 * before we managed to do the callback. 	 */
if|if
condition|(
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|open
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|started
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|usb_state
operator|==
name|USB_ST_ERROR
operator|)
condition|)
block|{
comment|/* clear flag in case of drain */
name|xfer
operator|->
name|flags_int
operator|.
name|doing_callback
operator|=
literal|0
expr_stmt|;
comment|/* try to loop, but not recursivly */
name|usb_command_wrapper
argument_list|(
operator|&
name|info
operator|->
name|done_q
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
comment|/* clear flag in case of drain */
name|xfer
operator|->
name|flags_int
operator|.
name|doing_callback
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check if we are draining. 	 */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|draining
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
operator|)
condition|)
block|{
comment|/* "usbd_transfer_drain()" is waiting for end of transfer */
name|xfer
operator|->
name|flags_int
operator|.
name|draining
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|info
operator|->
name|cv_drain
argument_list|)
expr_stmt|;
block|}
comment|/* do the next callback, if any */
name|usb_command_wrapper
argument_list|(
operator|&
name|info
operator|->
name|done_q
argument_list|,
name|info
operator|->
name|done_q
operator|.
name|curr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_dma_delay_done_cb  *  * This function is called when the DMA delay has been exectuded, and  * will make sure that the callback is called to complete the USB  * transfer. This code path is ususally only used when there is an USB  * error like USB_ERR_CANCELLED.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_dma_delay_done_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"Completed %p\n"
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
comment|/* queue callback for execution, again */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_dequeue  *  *  - This function is used to remove an USB transfer from a USB  *  transfer queue.  *  *  - This function can be called multiple times in a row.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_dequeue
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_xfer_queue
modifier|*
name|pq
decl_stmt|;
name|pq
operator|=
name|xfer
operator|->
name|wait_queue
expr_stmt|;
if|if
condition|(
name|pq
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pq
operator|->
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|wait_queue
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_enqueue  *  *  - This function is used to insert an USB transfer into a USB *  *  transfer queue.  *  *  - This function can be called multiple times in a row.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_enqueue
parameter_list|(
name|struct
name|usb_xfer_queue
modifier|*
name|pq
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
comment|/* 	 * Insert the USB transfer into the queue, if it is not 	 * already on a USB transfer queue: 	 */
if|if
condition|(
name|xfer
operator|->
name|wait_queue
operator|==
name|NULL
condition|)
block|{
name|xfer
operator|->
name|wait_queue
operator|=
name|pq
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pq
operator|->
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_done  *  *  - This function is used to remove an USB transfer from the busdma,  *  pipe or interrupt queue.  *  *  - This function is used to queue the USB transfer on the done  *  queue.  *  *  - This function is used to stop any USB transfer timeouts.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_done
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"err=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not transferring then just return. 	 * This can happen during transfer cancel. 	 */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|transferring
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"not transferring\n"
argument_list|)
expr_stmt|;
comment|/* end of control transfer, if any */
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* only set transfer error if not already set */
if|if
condition|(
operator|!
name|xfer
operator|->
name|error
condition|)
block|{
name|xfer
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
comment|/* stop any callouts */
name|usb_callout_stop
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
comment|/* 	 * If we are waiting on a queue, just remove the USB transfer 	 * from the queue, if any. We should have the required locks 	 * locked to do the remove when this function is called. 	 */
name|usbd_transfer_dequeue
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|mtx_owned
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|xfer_mtx
argument_list|)
condition|)
block|{
name|struct
name|usb_xfer_queue
modifier|*
name|pq
decl_stmt|;
comment|/* 		 * If the private USB lock is not locked, then we assume 		 * that the BUS-DMA load stage has been passed: 		 */
name|pq
operator|=
operator|&
name|xfer
operator|->
name|xroot
operator|->
name|dma_q
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|curr
operator|==
name|xfer
condition|)
block|{
comment|/* start the next BUS-DMA load, if any */
name|usb_command_wrapper
argument_list|(
name|pq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* keep some statistics */
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|stats_err
operator|.
name|uds_requests
index|[
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|xroot
operator|->
name|bus
operator|->
name|stats_ok
operator|.
name|uds_requests
index|[
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
index|]
operator|++
expr_stmt|;
block|}
comment|/* call the USB transfer callback */
name|usbd_callback_ss_done_defer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_start_cb  *  * This function is called to start the USB transfer when  * "xfer->interval" is greater than zero, and and the endpoint type is  * BULK or CONTROL.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usbd_transfer_start_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
init|=
name|arg
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep
init|=
name|xfer
operator|->
name|endpoint
decl_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
comment|/* start the transfer */
call|(
name|ep
operator|->
name|methods
operator|->
name|start
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|=
literal|1
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
comment|/* some error has happened */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_xfer_set_stall  *  * This function is used to set the stall flag outside the  * callback. This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_xfer_set_stall
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* tearing down */
return|return;
block|}
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* avoid any races by locking the USB mutex */
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags
operator|.
name|stall_pipe
operator|=
literal|1
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|usbd_xfer_is_stalled
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|endpoint
operator|->
name|is_stalled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_clear_stall  *  * This function is used to clear the stall flag outside the  * callback. This function is NULL safe.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_clear_stall
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
comment|/* tearing down */
return|return;
block|}
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* avoid any races by locking the USB mutex */
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags
operator|.
name|stall_pipe
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_pipe_start  *  * This function is used to add an USB transfer to the pipe transfer list.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_pipe_start
parameter_list|(
name|struct
name|usb_xfer_queue
modifier|*
name|pq
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|xfer
operator|=
name|pq
operator|->
name|curr
expr_stmt|;
name|ep
operator|=
name|xfer
operator|->
name|endpoint
expr_stmt|;
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If the endpoint is already stalled we do nothing ! 	 */
if|if
condition|(
name|ep
operator|->
name|is_stalled
condition|)
block|{
return|return;
block|}
comment|/* 	 * Check if we are supposed to stall the endpoint: 	 */
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|stall_pipe
condition|)
block|{
comment|/* clear stall command */
name|xfer
operator|->
name|flags
operator|.
name|stall_pipe
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Only stall BULK and INTERRUPT endpoints. 		 */
name|type
operator|=
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|UE_BULK
operator|)
operator|||
operator|(
name|type
operator|==
name|UE_INTERRUPT
operator|)
condition|)
block|{
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
decl_stmt|;
name|uint8_t
name|did_stall
decl_stmt|;
name|info
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
name|udev
operator|=
name|info
operator|->
name|udev
expr_stmt|;
name|did_stall
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|set_stall
call|)
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|ep
argument_list|,
operator|&
name|did_stall
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udev
operator|->
name|default_xfer
index|[
literal|1
index|]
condition|)
block|{
name|info
operator|=
name|udev
operator|->
name|default_xfer
index|[
literal|1
index|]
operator|->
name|xroot
expr_stmt|;
name|usb_proc_msignal
argument_list|(
operator|&
name|info
operator|->
name|bus
operator|->
name|non_giant_callback_proc
argument_list|,
operator|&
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|udev
operator|->
name|cs_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* should not happen */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"No stall handler!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Check if we should stall. Some USB hardware 			 * handles set- and clear-stall in hardware. 			 */
if|if
condition|(
name|did_stall
condition|)
block|{
comment|/* 				 * The transfer will be continued when 				 * the clear-stall control endpoint 				 * message is received. 				 */
name|ep
operator|->
name|is_stalled
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* Set or clear stall complete - special case */
if|if
condition|(
name|xfer
operator|->
name|nframes
operator|==
literal|0
condition|)
block|{
comment|/* we are complete */
name|xfer
operator|->
name|aframes
operator|=
literal|0
expr_stmt|;
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Handled cases: 	 * 	 * 1) Start the first transfer queued. 	 * 	 * 2) Re-start the current USB transfer. 	 */
comment|/* 	 * Check if there should be any 	 * pre transfer start delay: 	 */
if|if
condition|(
name|xfer
operator|->
name|interval
operator|>
literal|0
condition|)
block|{
name|type
operator|=
operator|(
name|ep
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|UE_BULK
operator|)
operator|||
operator|(
name|type
operator|==
name|UE_CONTROL
operator|)
condition|)
block|{
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|usbd_transfer_start_cb
argument_list|,
name|xfer
operator|->
name|interval
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
comment|/* start USB transfer */
call|(
name|ep
operator|->
name|methods
operator|->
name|start
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|=
literal|1
expr_stmt|;
comment|/* check for error */
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
comment|/* some error has happened */
name|usbd_transfer_done
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_timeout_ms  *  * This function is used to setup a timeout on the given USB  * transfer. If the timeout has been deferred the callback given by  * "cb" will get called after "ms" milliseconds.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_timeout_ms
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|usb_timeout_t
name|ms
parameter_list|)
block|{
name|USB_BUS_LOCK_ASSERT
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* defer delay */
name|usb_callout_reset
argument_list|(
operator|&
name|xfer
operator|->
name|timeout_handle
argument_list|,
name|USB_MS_TO_TICKS
argument_list|(
name|ms
argument_list|)
argument_list|,
name|cb
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_callback_wrapper_sub  *  *  - This function will update variables in an USB transfer after  *  that the USB transfer is complete.  *  *  - This function is used to start the next USB transfer on the  *  ep transfer queue, if any.  *  * NOTE: In some special cases the USB transfer will not be removed from  * the pipe queue, but remain first. To enforce USB transfer removal call  * this function passing the error code "USB_ERR_CANCELLED".  *  * Return values:  * 0: Success.  * Else: The callback has been deferred.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usbd_callback_wrapper_sub
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|usb_frcount_t
name|x
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|open
operator|)
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|did_close
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"close\n"
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
call|(
name|xfer
operator|->
name|endpoint
operator|->
name|methods
operator|->
name|close
call|)
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* only close once */
name|xfer
operator|->
name|flags_int
operator|.
name|did_close
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* wait for new callback */
block|}
comment|/* 	 * If we have a non-hardware induced error we 	 * need to do the DMA delay! 	 */
if|if
condition|(
operator|(
operator|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
operator|)
operator|||
operator|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_TIMEOUT
operator|)
operator|)
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|did_dma_delay
operator|)
condition|)
block|{
name|usb_timeout_t
name|temp
decl_stmt|;
comment|/* only delay once */
name|xfer
operator|->
name|flags_int
operator|.
name|did_dma_delay
operator|=
literal|1
expr_stmt|;
comment|/* we can not cancel this delay */
name|xfer
operator|->
name|flags_int
operator|.
name|can_cancel_immed
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|usbd_get_dma_delay
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"DMA delay, %u ms, "
literal|"on %p\n"
argument_list|,
name|temp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|usbd_transfer_timeout_ms
argument_list|(
name|xfer
argument_list|,
operator|&
name|usb_dma_delay_done_cb
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* wait for new callback */
block|}
block|}
comment|/* check actual number of frames */
if|if
condition|(
name|xfer
operator|->
name|aframes
operator|>
name|xfer
operator|->
name|nframes
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s: actual number of frames, %d, is "
literal|"greater than initial number of frames, %d!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just set some valid value */
name|xfer
operator|->
name|aframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
block|}
block|}
comment|/* compute actual length */
name|xfer
operator|->
name|actlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|xfer
operator|->
name|aframes
condition|;
name|x
operator|++
control|)
block|{
name|xfer
operator|->
name|actlen
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
block|}
comment|/* 	 * Frames that were not transferred get zero actual length in 	 * case the USB device driver does not check the actual number 	 * of frames transferred, "xfer->aframes": 	 */
for|for
control|(
init|;
name|x
operator|<
name|xfer
operator|->
name|nframes
condition|;
name|x
operator|++
control|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* check actual length */
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|>
name|xfer
operator|->
name|sumlen
condition|)
block|{
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s: actual length, %d, is greater than "
literal|"initial length, %d!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just set some valid value */
name|xfer
operator|->
name|actlen
operator|=
name|xfer
operator|->
name|sumlen
expr_stmt|;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"xfer=%p endpoint=%p sts=%d alen=%d, slen=%d, afrm=%d, nfrm=%d\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|,
name|xfer
operator|->
name|error
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|,
name|xfer
operator|->
name|sumlen
argument_list|,
name|xfer
operator|->
name|aframes
argument_list|,
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
condition|)
block|{
comment|/* end of control transfer, if any */
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
operator|=
literal|0
expr_stmt|;
comment|/* check if we should block the execution queue */
if|if
condition|(
operator|(
name|xfer
operator|->
name|error
operator|!=
name|USB_ERR_CANCELLED
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|flags
operator|.
name|pipe_bof
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p: Block On Failure "
literal|"on endpoint=%p\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* check for short transfers */
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|<
name|xfer
operator|->
name|sumlen
condition|)
block|{
comment|/* end of control transfer, if any */
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|short_xfer_ok
condition|)
block|{
name|xfer
operator|->
name|error
operator|=
name|USB_ERR_SHORT_XFER
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|pipe_bof
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
literal|"xfer=%p: Block On Failure on "
literal|"Short Transfer on endpoint %p.\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * Check if we are in the middle of a 			 * control transfer: 			 */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_act
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"xfer=%p: Control transfer "
literal|"active on endpoint=%p\n"
argument_list|,
name|xfer
argument_list|,
name|xfer
operator|->
name|endpoint
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|ep
operator|=
name|xfer
operator|->
name|endpoint
expr_stmt|;
comment|/* 	 * If the current USB transfer is completing we need to start the 	 * next one: 	 */
name|USB_BUS_LOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|endpoint_q
operator|.
name|curr
operator|==
name|xfer
condition|)
block|{
name|usb_command_wrapper
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|endpoint_q
operator|.
name|curr
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|ep
operator|->
name|endpoint_q
operator|.
name|head
argument_list|)
condition|)
block|{
comment|/* there is another USB transfer waiting */
block|}
else|else
block|{
comment|/* this is the last USB transfer */
comment|/* clear isochronous sync flag */
name|xfer
operator|->
name|endpoint
operator|->
name|is_synced
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|USB_BUS_UNLOCK
argument_list|(
name|xfer
operator|->
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_command_wrapper  *  * This function is used to execute commands non-recursivly on an USB  * transfer.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_command_wrapper
parameter_list|(
name|struct
name|usb_xfer_queue
modifier|*
name|pq
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
if|if
condition|(
name|xfer
condition|)
block|{
comment|/* 		 * If the transfer is not already processing, 		 * queue it! 		 */
if|if
condition|(
name|pq
operator|->
name|curr
operator|!=
name|xfer
condition|)
block|{
name|usbd_transfer_enqueue
argument_list|(
name|pq
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|curr
operator|!=
name|NULL
condition|)
block|{
comment|/* something is already processing */
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"busy %p\n"
argument_list|,
name|pq
operator|->
name|curr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
comment|/* Get next element in queue */
name|pq
operator|->
name|curr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pq
operator|->
name|recurse_1
condition|)
block|{
do|do
block|{
comment|/* set both recurse flags */
name|pq
operator|->
name|recurse_1
operator|=
literal|1
expr_stmt|;
name|pq
operator|->
name|recurse_2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|curr
operator|==
name|NULL
condition|)
block|{
name|xfer
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pq
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pq
operator|->
name|head
argument_list|,
name|xfer
argument_list|,
name|wait_entry
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|wait_queue
operator|=
name|NULL
expr_stmt|;
name|pq
operator|->
name|curr
operator|=
name|xfer
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"cb %p (enter)\n"
argument_list|,
name|pq
operator|->
name|curr
argument_list|)
expr_stmt|;
call|(
name|pq
operator|->
name|command
call|)
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"cb %p (leave)\n"
argument_list|,
name|pq
operator|->
name|curr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|pq
operator|->
name|recurse_2
condition|)
do|;
comment|/* clear first recurse flag */
name|pq
operator|->
name|recurse_1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* clear second recurse flag */
name|pq
operator|->
name|recurse_2
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_default_transfer_setup  *  * This function is used to setup the default USB control endpoint  * transfer.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_default_transfer_setup
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|uint8_t
name|no_resetup
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
comment|/* check for root HUB */
if|if
condition|(
name|udev
operator|->
name|parent_hub
operator|==
name|NULL
condition|)
return|return;
name|repeat
label|:
name|xfer
operator|=
name|udev
operator|->
name|default_xfer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|xfer
condition|)
block|{
name|USB_XFER_LOCK
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|no_resetup
operator|=
operator|(
operator|(
name|xfer
operator|->
name|address
operator|==
name|udev
operator|->
name|address
operator|)
operator|&&
operator|(
name|udev
operator|->
name|default_ep_desc
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|==
name|udev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|flags
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
if|if
condition|(
name|no_resetup
condition|)
block|{
comment|/* 				 * NOTE: checking "xfer->address" and 				 * starting the USB transfer must be 				 * atomic! 				 */
name|usbd_transfer_start
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
name|USB_XFER_UNLOCK
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|no_resetup
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|no_resetup
condition|)
block|{
comment|/* 	         * All parameters are exactly the same like before. 	         * Just return. 	         */
return|return;
block|}
comment|/* 	 * Update wMaxPacketSize for the default control endpoint: 	 */
name|udev
operator|->
name|default_ep_desc
operator|.
name|wMaxPacketSize
index|[
literal|0
index|]
operator|=
name|udev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
expr_stmt|;
comment|/* 	 * Unsetup any existing USB transfer: 	 */
name|usbd_transfer_unsetup
argument_list|(
name|udev
operator|->
name|default_xfer
argument_list|,
name|USB_DEFAULT_XFER_MAX
argument_list|)
expr_stmt|;
comment|/* 	 * Try to setup a new USB transfer for the 	 * default control endpoint: 	 */
name|iface_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|iface_index
argument_list|,
name|udev
operator|->
name|default_xfer
argument_list|,
name|usb_control_ep_cfg
argument_list|,
name|USB_DEFAULT_XFER_MAX
argument_list|,
name|NULL
argument_list|,
name|udev
operator|->
name|default_mtx
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not setup default "
literal|"USB transfer!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|repeat
goto|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_clear_data_toggle - factored out code  *  * NOTE: the intention of this function is not to reset the hardware  * data toggle.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_clear_data_toggle
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_endpoint
modifier|*
name|ep
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"udev=%p endpoint=%p\n"
argument_list|,
name|udev
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|ep
operator|->
name|toggle_next
operator|=
literal|0
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_clear_stall_callback - factored out clear stall callback  *  * Input parameters:  *  xfer1: Clear Stall Control Transfer  *  xfer2: Stalled USB Transfer  *  * This function is NULL safe.  *  * Return values:  *   0: In progress  *   Else: Finished  *  * Clear stall config example:  *  * static const struct usb_config my_clearstall =  {  *	.type = UE_CONTROL,  *	.endpoint = 0,  *	.direction = UE_DIR_ANY,  *	.interval = 50, //50 milliseconds  *	.bufsize = sizeof(struct usb_device_request),  *	.timeout = 1000, //1.000 seconds  *	.callback =&my_clear_stall_callback, // **  *	.usb_mode = USB_MODE_HOST,  * };  *  * ** "my_clear_stall_callback" calls "usbd_clear_stall_callback"  * passing the correct parameters.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|uint8_t
name|usbd_clear_stall_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer1
parameter_list|,
name|struct
name|usb_xfer
modifier|*
name|xfer2
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
if|if
condition|(
name|xfer2
operator|==
name|NULL
condition|)
block|{
comment|/* looks like we are tearing down */
name|DPRINTF
argument_list|(
literal|"NULL input parameter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer1
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|USB_XFER_LOCK_ASSERT
argument_list|(
name|xfer2
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer1
argument_list|)
condition|)
block|{
case|case
name|USB_ST_SETUP
case|:
comment|/* 		 * pre-clear the data toggle to DATA0 ("umass.c" and 		 * "ata-usb.c" depends on this) 		 */
name|usbd_clear_data_toggle
argument_list|(
name|xfer2
operator|->
name|xroot
operator|->
name|udev
argument_list|,
name|xfer2
operator|->
name|endpoint
argument_list|)
expr_stmt|;
comment|/* setup a clear-stall packet */
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_ENDPOINT
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_CLEAR_FEATURE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UF_ENDPOINT_HALT
argument_list|)
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|0
index|]
operator|=
name|xfer2
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|req
operator|.
name|wIndex
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * "usbd_transfer_setup_sub()" will ensure that 		 * we have sufficient room in the buffer for 		 * the request structure! 		 */
comment|/* copy in the transfer */
name|usbd_copy_in
argument_list|(
name|xfer1
operator|->
name|frbuffers
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set length */
name|xfer1
operator|->
name|frlengths
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|xfer1
operator|->
name|nframes
operator|=
literal|1
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|USB_ST_TRANSFERRED
case|:
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|xfer1
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Clear Stall Finished */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_transfer_poll  *  * The following function gets called from the USB keyboard driver and  * UMASS when the system has paniced.  *  * NOTE: It is currently not possible to resume normal operation on  * the USB controller which has been polled, due to clearing of the  * "up_dsleep" and "up_msleep" flags.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usbd_transfer_poll
parameter_list|(
name|struct
name|usb_xfer
modifier|*
modifier|*
name|ppxfer
parameter_list|,
name|uint16_t
name|max
parameter_list|)
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|xroot
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|struct
name|usb_proc_msg
modifier|*
name|pm
decl_stmt|;
name|uint16_t
name|n
decl_stmt|;
name|uint16_t
name|drop_bus
decl_stmt|;
name|uint16_t
name|drop_xfer
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|max
condition|;
name|n
operator|++
control|)
block|{
comment|/* Extra checks to avoid panic */
name|xfer
operator|=
name|ppxfer
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no USB transfer */
name|xroot
operator|=
name|xfer
operator|->
name|xroot
expr_stmt|;
if|if
condition|(
name|xroot
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no USB root */
name|udev
operator|=
name|xroot
operator|->
name|udev
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no USB device */
if|if
condition|(
name|udev
operator|->
name|bus
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no BUS structure */
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no BUS methods */
if|if
condition|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|xfer_poll
operator|==
name|NULL
condition|)
continue|continue;
comment|/* no poll method */
comment|/* make sure that the BUS mutex is not locked */
name|drop_bus
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mtx_owned
argument_list|(
operator|&
name|xroot
operator|->
name|udev
operator|->
name|bus
operator|->
name|bus_mtx
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xroot
operator|->
name|udev
operator|->
name|bus
operator|->
name|bus_mtx
argument_list|)
expr_stmt|;
name|drop_bus
operator|++
expr_stmt|;
block|}
comment|/* make sure that the transfer mutex is not locked */
name|drop_xfer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mtx_owned
argument_list|(
name|xroot
operator|->
name|xfer_mtx
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
name|xroot
operator|->
name|xfer_mtx
argument_list|)
expr_stmt|;
name|drop_xfer
operator|++
expr_stmt|;
block|}
comment|/* Make sure cv_signal() and cv_broadcast() is not called */
name|udev
operator|->
name|bus
operator|->
name|control_xfer_proc
operator|.
name|up_msleep
operator|=
literal|0
expr_stmt|;
name|udev
operator|->
name|bus
operator|->
name|explore_proc
operator|.
name|up_msleep
operator|=
literal|0
expr_stmt|;
name|udev
operator|->
name|bus
operator|->
name|giant_callback_proc
operator|.
name|up_msleep
operator|=
literal|0
expr_stmt|;
name|udev
operator|->
name|bus
operator|->
name|non_giant_callback_proc
operator|.
name|up_msleep
operator|=
literal|0
expr_stmt|;
comment|/* poll USB hardware */
call|(
name|udev
operator|->
name|bus
operator|->
name|methods
operator|->
name|xfer_poll
call|)
argument_list|(
name|udev
operator|->
name|bus
argument_list|)
expr_stmt|;
name|USB_BUS_LOCK
argument_list|(
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* check for clear stall */
if|if
condition|(
name|udev
operator|->
name|default_xfer
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* poll clear stall start */
name|pm
operator|=
operator|&
name|udev
operator|->
name|cs_msg
index|[
literal|0
index|]
operator|.
name|hdr
expr_stmt|;
call|(
name|pm
operator|->
name|pm_callback
call|)
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* poll clear stall done thread */
name|pm
operator|=
operator|&
name|udev
operator|->
name|default_xfer
index|[
literal|1
index|]
operator|->
name|xroot
operator|->
name|done_m
index|[
literal|0
index|]
operator|.
name|hdr
expr_stmt|;
call|(
name|pm
operator|->
name|pm_callback
call|)
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
comment|/* poll done thread */
name|pm
operator|=
operator|&
name|xroot
operator|->
name|done_m
index|[
literal|0
index|]
operator|.
name|hdr
expr_stmt|;
call|(
name|pm
operator|->
name|pm_callback
call|)
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|USB_BUS_UNLOCK
argument_list|(
name|xroot
operator|->
name|bus
argument_list|)
expr_stmt|;
comment|/* restore transfer mutex */
while|while
condition|(
name|drop_xfer
operator|--
condition|)
name|mtx_lock
argument_list|(
name|xroot
operator|->
name|xfer_mtx
argument_list|)
expr_stmt|;
comment|/* restore BUS mutex */
while|while
condition|(
name|drop_bus
operator|--
condition|)
name|mtx_lock
argument_list|(
operator|&
name|xroot
operator|->
name|udev
operator|->
name|bus
operator|->
name|bus_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_get_std_packet_size
parameter_list|(
name|struct
name|usb_std_packet_size
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|enum
name|usb_dev_speed
name|speed
parameter_list|)
block|{
specifier|static
specifier|const
name|uint16_t
name|intr_range_max
index|[
name|USB_SPEED_MAX
index|]
init|=
block|{
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|8
block|,
index|[
name|USB_SPEED_FULL
index|]
operator|=
literal|64
block|,
index|[
name|USB_SPEED_HIGH
index|]
operator|=
literal|1024
block|,
index|[
name|USB_SPEED_VARIABLE
index|]
operator|=
literal|1024
block|,
index|[
name|USB_SPEED_SUPER
index|]
operator|=
literal|1024
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|isoc_range_max
index|[
name|USB_SPEED_MAX
index|]
init|=
block|{
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|0
block|,
comment|/* invalid */
index|[
name|USB_SPEED_FULL
index|]
operator|=
literal|1023
block|,
index|[
name|USB_SPEED_HIGH
index|]
operator|=
literal|1024
block|,
index|[
name|USB_SPEED_VARIABLE
index|]
operator|=
literal|3584
block|,
index|[
name|USB_SPEED_SUPER
index|]
operator|=
literal|1024
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|control_min
index|[
name|USB_SPEED_MAX
index|]
init|=
block|{
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|8
block|,
index|[
name|USB_SPEED_FULL
index|]
operator|=
literal|8
block|,
index|[
name|USB_SPEED_HIGH
index|]
operator|=
literal|64
block|,
index|[
name|USB_SPEED_VARIABLE
index|]
operator|=
literal|512
block|,
index|[
name|USB_SPEED_SUPER
index|]
operator|=
literal|512
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|uint16_t
name|bulk_min
index|[
name|USB_SPEED_MAX
index|]
init|=
block|{
index|[
name|USB_SPEED_LOW
index|]
operator|=
literal|0
block|,
comment|/* not supported */
index|[
name|USB_SPEED_FULL
index|]
operator|=
literal|8
block|,
index|[
name|USB_SPEED_HIGH
index|]
operator|=
literal|512
block|,
index|[
name|USB_SPEED_VARIABLE
index|]
operator|=
literal|512
block|,
index|[
name|USB_SPEED_SUPER
index|]
operator|=
literal|1024
block|, 	}
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UE_INTERRUPT
case|:
name|ptr
operator|->
name|range
operator|.
name|max
operator|=
name|intr_range_max
index|[
name|speed
index|]
expr_stmt|;
break|break;
case|case
name|UE_ISOCHRONOUS
case|:
name|ptr
operator|->
name|range
operator|.
name|max
operator|=
name|isoc_range_max
index|[
name|speed
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|type
operator|==
name|UE_BULK
condition|)
name|temp
operator|=
name|bulk_min
index|[
name|speed
index|]
expr_stmt|;
else|else
comment|/* UE_CONTROL */
name|temp
operator|=
name|control_min
index|[
name|speed
index|]
expr_stmt|;
comment|/* default is fixed */
name|ptr
operator|->
name|fixed
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
name|ptr
operator|->
name|fixed
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
name|ptr
operator|->
name|fixed
index|[
literal|2
index|]
operator|=
name|temp
expr_stmt|;
name|ptr
operator|->
name|fixed
index|[
literal|3
index|]
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
block|{
comment|/* multiple sizes */
name|ptr
operator|->
name|fixed
index|[
literal|1
index|]
operator|=
literal|16
expr_stmt|;
name|ptr
operator|->
name|fixed
index|[
literal|2
index|]
operator|=
literal|32
expr_stmt|;
name|ptr
operator|->
name|fixed
index|[
literal|3
index|]
operator|=
literal|64
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|speed
operator|==
name|USB_SPEED_VARIABLE
operator|)
operator|&&
operator|(
name|type
operator|==
name|UE_BULK
operator|)
condition|)
block|{
comment|/* multiple sizes */
name|ptr
operator|->
name|fixed
index|[
literal|2
index|]
operator|=
literal|1024
expr_stmt|;
name|ptr
operator|->
name|fixed
index|[
literal|3
index|]
operator|=
literal|1536
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|usbd_xfer_softc
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|priv_sc
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|usbd_xfer_get_priv
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|priv_fifo
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_set_priv
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|xfer
operator|->
name|priv_fifo
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|usbd_xfer_state
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|usb_state
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_xfer_set_flag
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|USB_FORCE_SHORT_XFER
case|:
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|USB_SHORT_XFER_OK
case|:
name|xfer
operator|->
name|flags
operator|.
name|short_xfer_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|USB_MULTI_SHORT_OK
case|:
name|xfer
operator|->
name|flags
operator|.
name|short_frames_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|USB_MANUAL_STATUS
case|:
name|xfer
operator|->
name|flags
operator|.
name|manual_status
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|usbd_xfer_clr_flag
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|USB_FORCE_SHORT_XFER
case|:
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USB_SHORT_XFER_OK
case|:
name|xfer
operator|->
name|flags
operator|.
name|short_xfer_ok
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USB_MULTI_SHORT_OK
case|:
name|xfer
operator|->
name|flags
operator|.
name|short_frames_ok
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USB_MANUAL_STATUS
case|:
name|xfer
operator|->
name|flags
operator|.
name|manual_status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * The following function returns in milliseconds when the isochronous  * transfer was completed by the hardware. The returned value wraps  * around 65536 milliseconds.  */
end_comment

begin_function
name|uint16_t
name|usbd_xfer_get_timestamp
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
return|return
operator|(
name|xfer
operator|->
name|isoc_time_complete
operator|)
return|;
block|}
end_function

end_unit

