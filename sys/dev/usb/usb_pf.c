begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_pf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_comment
comment|/*  * All usbpf implementations are extracted from bpf(9) APIs and it's  * specialized for USB packet filtering between the driver and the host  * controller.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_USBPF
argument_list|,
literal|"USBPktFilter"
argument_list|,
literal|"USB Packet Filter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Rotate the packet buffers in descriptor ud.  Move the store buffer into the  * hold slot, and the free buffer ino the store slot.  Zero the length of the  * new store buffer.  Descriptor lock should be held.  */
end_comment

begin_define
define|#
directive|define
name|USBPF_ROTATE_BUFFERS
parameter_list|(
name|ud
parameter_list|)
value|do {				\ 	(ud)->ud_hbuf = (ud)->ud_sbuf;					\ 	(ud)->ud_hlen = (ud)->ud_slen;					\ 	(ud)->ud_sbuf = (ud)->ud_fbuf;					\ 	(ud)->ud_slen = 0;						\ 	(ud)->ud_fbuf = NULL;						\ 	usbpf_bufheld(ud);						\ } while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__i386__
end_ifndef

begin_define
define|#
directive|define
name|USBPF_ALIGN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USBPF_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|USBPF_EXTRACT_SHORT
parameter_list|(
name|p
parameter_list|)
value|((u_int16_t)ntohs(*(u_int16_t *)p))
end_define

begin_define
define|#
directive|define
name|USBPF_EXTRACT_LONG
parameter_list|(
name|p
parameter_list|)
value|(ntohl(*(u_int32_t *)p))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USBPF_EXTRACT_SHORT
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int16_t)							\ 	    ((u_int16_t)*((u_char *)p+0)<<8|				\ 		(u_int16_t)*((u_char *)p+1)<<0))
end_define

begin_define
define|#
directive|define
name|USBPF_EXTRACT_LONG
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int32_t)*((u_char *)p+0)<<24|				\ 	    (u_int32_t)*((u_char *)p+1)<<16|				\ 	    (u_int32_t)*((u_char *)p+2)<<8|				\ 	    (u_int32_t)*((u_char *)p+3)<<0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Number of scratch memory words (for USBPF_LD|USBPF_MEM and USBPF_ST).  */
end_comment

begin_define
define|#
directive|define
name|USBPF_MEMWORDS
value|16
end_define

begin_comment
comment|/* Values for ud_state */
end_comment

begin_define
define|#
directive|define
name|USBPF_IDLE
value|0
end_define

begin_comment
comment|/* no select in progress */
end_comment

begin_define
define|#
directive|define
name|USBPF_WAITING
value|1
end_define

begin_comment
comment|/* waiting for read timeout in select */
end_comment

begin_define
define|#
directive|define
name|USBPF_TIMED_OUT
value|2
end_define

begin_comment
comment|/* read timeout has expired in select */
end_comment

begin_define
define|#
directive|define
name|PRIUSB
value|26
end_define

begin_comment
comment|/* interruptible */
end_comment

begin_comment
comment|/* Frame directions */
end_comment

begin_enum
enum|enum
name|usbpf_direction
block|{
name|USBPF_D_IN
block|,
comment|/* See incoming frames */
name|USBPF_D_INOUT
block|,
comment|/* See incoming and outgoing frames */
name|USBPF_D_OUT
comment|/* See outgoing frames */
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|usbpf_append_bytes
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbpf_attachd
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|,
name|struct
name|usbpf_if
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbpf_detachd
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_canfreebuf
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbpf_buf_reclaimed
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_canwritebuf
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|usbpf_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|usbpf_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|usbpf_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|usbpf_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|usbpf_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|usbpf_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|usbpf_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|usbpf_open
block|,
operator|.
name|d_read
operator|=
name|usbpf_read
block|,
operator|.
name|d_write
operator|=
name|usbpf_write
block|,
operator|.
name|d_ioctl
operator|=
name|usbpf_ioctl
block|,
operator|.
name|d_poll
operator|=
name|usbpf_poll
block|,
operator|.
name|d_name
operator|=
literal|"usbpf"
block|,
operator|.
name|d_kqfilter
operator|=
name|usbpf_kqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|usbpf_cdev
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|usbpf_if
argument_list|)
name|usbpf_iflist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|usbpf_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global lock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|usbpf_uifd_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|usbpf_bufsize
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USBPF_MINBUFSIZE
value|32
end_define

begin_define
define|#
directive|define
name|USBPF_MAXBUFSIZE
value|0x80000
end_define

begin_decl_stmt
specifier|static
name|int
name|usbpf_maxbufsize
init|=
name|USBPF_MAXBUFSIZE
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USBPF_MAXINSNS
value|512
end_define

begin_decl_stmt
specifier|static
name|int
name|usbpf_maxinsns
init|=
name|USBPF_MAXINSNS
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usbpf_buffer_init
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|ud
operator|->
name|ud_bufsize
operator|=
name|usbpf_bufsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free USBPF kernel buffers on device close.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_buffer_free
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
if|if
condition|(
name|ud
operator|->
name|ud_sbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ud
operator|->
name|ud_sbuf
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_hbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ud
operator|->
name|ud_hbuf
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_fbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ud
operator|->
name|ud_fbuf
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|ud
operator|->
name|ud_sbuf
operator|=
name|ud
operator|->
name|ud_hbuf
operator|=
name|ud
operator|->
name|ud_fbuf
operator|=
operator|(
name|caddr_t
operator|)
operator|~
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_buffer_alloc
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ud
operator|->
name|ud_fbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: ud_fbuf != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ud
operator|->
name|ud_sbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: ud_sbuf != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ud
operator|->
name|ud_hbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: ud_hbuf != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_fbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|ud
operator|->
name|ud_bufsize
argument_list|,
name|M_USBPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_sbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|ud
operator|->
name|ud_bufsize
argument_list|,
name|M_USBPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_hbuf
operator|=
name|NULL
expr_stmt|;
name|ud
operator|->
name|ud_slen
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_hlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy buffer storage to user space in read().  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_buffer_uiomove
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
return|return
operator|(
name|uiomove
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple data copy to the current kernel buffer.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_buffer_append_bytes
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|src_bytes
decl_stmt|;
name|src_bytes
operator|=
operator|(
name|u_char
operator|*
operator|)
name|src
expr_stmt|;
name|bcopy
argument_list|(
name|src_bytes
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate or resize buffers.  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_buffer_ioctl_sblen
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|u_int
modifier|*
name|i
parameter_list|)
block|{
name|u_int
name|size
decl_stmt|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_bif
operator|!=
name|NULL
condition|)
block|{
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|size
operator|=
operator|*
name|i
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|usbpf_maxbufsize
condition|)
operator|*
name|i
operator|=
name|size
operator|=
name|usbpf_maxbufsize
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<
name|USBPF_MINBUFSIZE
condition|)
operator|*
name|i
operator|=
name|size
operator|=
name|USBPF_MINBUFSIZE
expr_stmt|;
name|ud
operator|->
name|ud_bufsize
operator|=
name|size
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|usbpf_code_map
index|[]
init|=
block|{
literal|0x10ff
block|,
comment|/* 0x00-0x0f: 1111111100001000 */
literal|0x3070
block|,
comment|/* 0x10-0x1f: 0000111000001100 */
literal|0x3131
block|,
comment|/* 0x20-0x2f: 1000110010001100 */
literal|0x3031
block|,
comment|/* 0x30-0x3f: 1000110000001100 */
literal|0x3131
block|,
comment|/* 0x40-0x4f: 1000110010001100 */
literal|0x1011
block|,
comment|/* 0x50-0x5f: 1000100000001000 */
literal|0x1013
block|,
comment|/* 0x60-0x6f: 1100100000001000 */
literal|0x1010
block|,
comment|/* 0x70-0x7f: 0000100000001000 */
literal|0x0093
block|,
comment|/* 0x80-0x8f: 1100100100000000 */
literal|0x0000
block|,
comment|/* 0x90-0x9f: 0000000000000000 */
literal|0x0000
block|,
comment|/* 0xa0-0xaf: 0000000000000000 */
literal|0x0002
block|,
comment|/* 0xb0-0xbf: 0100000000000000 */
literal|0x0000
block|,
comment|/* 0xc0-0xcf: 0000000000000000 */
literal|0x0000
block|,
comment|/* 0xd0-0xdf: 0000000000000000 */
literal|0x0000
block|,
comment|/* 0xe0-0xef: 0000000000000000 */
literal|0x0000
comment|/* 0xf0-0xff: 0000000000000000 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USBPF_VALIDATE_CODE
parameter_list|(
name|c
parameter_list|)
define|\
value|((c)<= 0xff&& (usbpf_code_map[(c)>> 4]& (1<< ((c)& 0xf))) != 0)
end_define

begin_comment
comment|/*  * Return true if the 'fcode' is a valid filter program.  * The constraints are that each jump be forward and to a valid  * code.  The code must terminate with either an accept or reject.  *  * The kernel needs to be able to verify an application's filter code.  * Otherwise, a bogus program could easily crash the system.  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_validate
parameter_list|(
specifier|const
name|struct
name|usbpf_insn
modifier|*
name|f
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
specifier|const
name|struct
name|usbpf_insn
modifier|*
name|p
decl_stmt|;
comment|/* Do not accept negative length filter. */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* An empty filter means accept all. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|f
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Check that the code is valid. 		 */
if|if
condition|(
operator|!
name|USBPF_VALIDATE_CODE
argument_list|(
name|p
operator|->
name|code
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Check that that jumps are forward, and within 		 * the code block. 		 */
if|if
condition|(
name|USBPF_CLASS
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|==
name|USBPF_JMP
condition|)
block|{
specifier|register
name|u_int
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|code
operator|==
operator|(
name|USBPF_JMP
operator||
name|USBPF_JA
operator|)
condition|)
name|offset
operator|=
name|p
operator|->
name|k
expr_stmt|;
else|else
name|offset
operator|=
name|p
operator|->
name|jt
operator|>
name|p
operator|->
name|jf
condition|?
name|p
operator|->
name|jt
else|:
name|p
operator|->
name|jf
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
call|(
name|u_int
call|)
argument_list|(
name|len
operator|-
name|i
argument_list|)
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * Check that memory operations use valid addresses. 		 */
if|if
condition|(
name|p
operator|->
name|code
operator|==
name|USBPF_ST
operator|||
name|p
operator|->
name|code
operator|==
name|USBPF_STX
operator|||
name|p
operator|->
name|code
operator|==
operator|(
name|USBPF_LD
operator||
name|USBPF_MEM
operator|)
operator|||
name|p
operator|->
name|code
operator|==
operator|(
name|USBPF_LDX
operator||
name|USBPF_MEM
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|k
operator|>=
name|USBPF_MEMWORDS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * Check for constant division by 0. 		 */
if|if
condition|(
name|p
operator|->
name|code
operator|==
operator|(
name|USBPF_ALU
operator||
name|USBPF_DIV
operator||
name|USBPF_K
operator|)
operator|&&
name|p
operator|->
name|k
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|USBPF_CLASS
argument_list|(
name|f
index|[
name|len
operator|-
literal|1
index|]
operator|.
name|code
argument_list|)
operator|==
name|USBPF_RET
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|MINDEX
parameter_list|(
name|m
parameter_list|,
name|k
parameter_list|)
define|\
value|{ \ 	register int len = m->m_len; \  \ 	while (k>= len) { \ 		k -= len; \ 		m = m->m_next; \ 		if (m == 0) \ 			return (0); \ 		len = m->m_len; \ 	} \ }
end_define

begin_function_decl
specifier|static
name|u_int16_t
name|m_xhalf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|usbpf_u_int32
name|k
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|m_xword
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|usbpf_u_int32
name|k
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|u_int32_t
name|m_xword
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|usbpf_u_int32
name|k
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|k
operator|>=
name|len
condition|)
block|{
name|k
operator|-=
name|len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|k
expr_stmt|;
if|if
condition|(
name|len
operator|-
name|k
operator|>=
literal|4
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBPF_EXTRACT_LONG
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
name|m0
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
operator|||
name|m0
operator|->
name|m_len
operator|+
name|len
operator|-
name|k
operator|<
literal|4
condition|)
goto|goto
name|bad
goto|;
operator|*
name|err
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|len
operator|-
name|k
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|cp
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|np
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|np
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|np
index|[
literal|2
index|]
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|cp
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|cp
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|np
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|np
index|[
literal|1
index|]
operator|)
return|;
default|default:
return|return
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|cp
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|cp
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|cp
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|np
index|[
literal|0
index|]
operator|)
return|;
block|}
name|bad
label|:
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|m_xhalf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|usbpf_u_int32
name|k
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|k
operator|>=
name|len
condition|)
block|{
name|k
operator|-=
name|len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|k
expr_stmt|;
if|if
condition|(
name|len
operator|-
name|k
operator|>=
literal|2
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|USBPF_EXTRACT_SHORT
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
name|m0
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
operator|*
name|err
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|0
index|]
operator|)
return|;
name|bad
label|:
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Execute the filter program starting at pc on the packet p  * wirelen is the length of the original packet  * buflen is the amount of data present  */
end_comment

begin_function
specifier|static
name|u_int
name|usbpf_filter
parameter_list|(
specifier|const
name|struct
name|usbpf_insn
modifier|*
name|pc
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|wirelen
parameter_list|,
name|u_int
name|buflen
parameter_list|)
block|{
name|u_int32_t
name|A
init|=
literal|0
decl_stmt|,
name|X
init|=
literal|0
decl_stmt|;
name|usbpf_u_int32
name|k
decl_stmt|;
name|u_int32_t
name|mem
index|[
name|USBPF_MEMWORDS
index|]
decl_stmt|;
comment|/* 	 * XXX temporarily the filter system is disabled because currently it 	 * could not handle the some machine code properly that leads to 	 * kernel crash by invalid usage. 	 */
return|return
operator|(
operator|(
name|u_int
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|pc
operator|==
name|NULL
condition|)
comment|/* 		 * No filter means accept all. 		 */
return|return
operator|(
operator|(
name|u_int
operator|)
operator|-
literal|1
operator|)
return|;
operator|--
name|pc
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|pc
expr_stmt|;
switch|switch
condition|(
name|pc
operator|->
name|code
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|_KERNEL
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|USBPF_RET
operator||
name|USBPF_K
case|:
return|return
operator|(
operator|(
name|u_int
operator|)
name|pc
operator|->
name|k
operator|)
return|;
case|case
name|USBPF_RET
operator||
name|USBPF_A
case|:
return|return
operator|(
operator|(
name|u_int
operator|)
name|A
operator|)
return|;
case|case
name|USBPF_LD
operator||
name|USBPF_W
operator||
name|USBPF_ABS
case|:
name|k
operator|=
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|buflen
operator|||
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|>
name|buflen
operator|-
name|k
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|int
name|merr
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|A
operator|=
name|m_xword
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
argument_list|,
name|k
argument_list|,
operator|&
name|merr
argument_list|)
expr_stmt|;
if|if
condition|(
name|merr
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|USBPF_ALIGN
if|if
condition|(
operator|(
call|(
name|intptr_t
call|)
argument_list|(
name|p
operator|+
name|k
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|A
operator|=
name|USBPF_EXTRACT_LONG
argument_list|(
operator|&
name|p
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|A
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|p
operator|+
name|k
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_H
operator||
name|USBPF_ABS
case|:
name|k
operator|=
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|buflen
operator|||
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
operator|>
name|buflen
operator|-
name|k
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|int
name|merr
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|A
operator|=
name|m_xhalf
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
argument_list|,
name|k
argument_list|,
operator|&
name|merr
argument_list|)
expr_stmt|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|A
operator|=
name|USBPF_EXTRACT_SHORT
argument_list|(
operator|&
name|p
index|[
name|k
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_B
operator||
name|USBPF_ABS
case|:
name|k
operator|=
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|buflen
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
expr_stmt|;
name|MINDEX
argument_list|(
name|m
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|A
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
name|k
index|]
expr_stmt|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|A
operator|=
name|p
index|[
name|k
index|]
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_W
operator||
name|USBPF_LEN
case|:
name|A
operator|=
name|wirelen
expr_stmt|;
continue|continue;
case|case
name|USBPF_LDX
operator||
name|USBPF_W
operator||
name|USBPF_LEN
case|:
name|X
operator|=
name|wirelen
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_W
operator||
name|USBPF_IND
case|:
name|k
operator|=
name|X
operator|+
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|k
operator|>
name|buflen
operator|||
name|X
operator|>
name|buflen
operator|-
name|pc
operator|->
name|k
operator|||
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|>
name|buflen
operator|-
name|k
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|int
name|merr
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|A
operator|=
name|m_xword
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
argument_list|,
name|k
argument_list|,
operator|&
name|merr
argument_list|)
expr_stmt|;
if|if
condition|(
name|merr
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|USBPF_ALIGN
if|if
condition|(
operator|(
call|(
name|intptr_t
call|)
argument_list|(
name|p
operator|+
name|k
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|A
operator|=
name|USBPF_EXTRACT_LONG
argument_list|(
operator|&
name|p
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|A
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|p
operator|+
name|k
operator|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_H
operator||
name|USBPF_IND
case|:
name|k
operator|=
name|X
operator|+
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|X
operator|>
name|buflen
operator|||
name|pc
operator|->
name|k
operator|>
name|buflen
operator|-
name|X
operator|||
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
operator|>
name|buflen
operator|-
name|k
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|int
name|merr
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|A
operator|=
name|m_xhalf
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
argument_list|,
name|k
argument_list|,
operator|&
name|merr
argument_list|)
expr_stmt|;
if|if
condition|(
name|merr
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|A
operator|=
name|USBPF_EXTRACT_SHORT
argument_list|(
operator|&
name|p
index|[
name|k
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_B
operator||
name|USBPF_IND
case|:
name|k
operator|=
name|X
operator|+
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|k
operator|>=
name|buflen
operator|||
name|X
operator|>=
name|buflen
operator|-
name|pc
operator|->
name|k
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
expr_stmt|;
name|MINDEX
argument_list|(
name|m
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|A
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
name|k
index|]
expr_stmt|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|A
operator|=
name|p
index|[
name|k
index|]
expr_stmt|;
continue|continue;
case|case
name|USBPF_LDX
operator||
name|USBPF_MSH
operator||
name|USBPF_B
case|:
name|k
operator|=
name|pc
operator|->
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|buflen
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|buflen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
expr_stmt|;
name|MINDEX
argument_list|(
name|m
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|X
operator|=
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
name|k
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|2
expr_stmt|;
continue|continue;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|X
operator|=
operator|(
name|p
index|[
name|pc
operator|->
name|k
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|2
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_IMM
case|:
name|A
operator|=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_LDX
operator||
name|USBPF_IMM
case|:
name|X
operator|=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_LD
operator||
name|USBPF_MEM
case|:
name|A
operator|=
name|mem
index|[
name|pc
operator|->
name|k
index|]
expr_stmt|;
continue|continue;
case|case
name|USBPF_LDX
operator||
name|USBPF_MEM
case|:
name|X
operator|=
name|mem
index|[
name|pc
operator|->
name|k
index|]
expr_stmt|;
continue|continue;
case|case
name|USBPF_ST
case|:
name|mem
index|[
name|pc
operator|->
name|k
index|]
operator|=
name|A
expr_stmt|;
continue|continue;
case|case
name|USBPF_STX
case|:
name|mem
index|[
name|pc
operator|->
name|k
index|]
operator|=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JA
case|:
name|pc
operator|+=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JGT
operator||
name|USBPF_K
case|:
name|pc
operator|+=
operator|(
name|A
operator|>
name|pc
operator|->
name|k
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JGE
operator||
name|USBPF_K
case|:
name|pc
operator|+=
operator|(
name|A
operator|>=
name|pc
operator|->
name|k
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JEQ
operator||
name|USBPF_K
case|:
name|pc
operator|+=
operator|(
name|A
operator|==
name|pc
operator|->
name|k
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JSET
operator||
name|USBPF_K
case|:
name|pc
operator|+=
operator|(
name|A
operator|&
name|pc
operator|->
name|k
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JGT
operator||
name|USBPF_X
case|:
name|pc
operator|+=
operator|(
name|A
operator|>
name|X
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JGE
operator||
name|USBPF_X
case|:
name|pc
operator|+=
operator|(
name|A
operator|>=
name|X
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JEQ
operator||
name|USBPF_X
case|:
name|pc
operator|+=
operator|(
name|A
operator|==
name|X
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_JMP
operator||
name|USBPF_JSET
operator||
name|USBPF_X
case|:
name|pc
operator|+=
operator|(
name|A
operator|&
name|X
operator|)
condition|?
name|pc
operator|->
name|jt
else|:
name|pc
operator|->
name|jf
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_ADD
operator||
name|USBPF_X
case|:
name|A
operator|+=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_SUB
operator||
name|USBPF_X
case|:
name|A
operator|-=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_MUL
operator||
name|USBPF_X
case|:
name|A
operator|*=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_DIV
operator||
name|USBPF_X
case|:
if|if
condition|(
name|X
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|A
operator|/=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_AND
operator||
name|USBPF_X
case|:
name|A
operator|&=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_OR
operator||
name|USBPF_X
case|:
name|A
operator||=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_LSH
operator||
name|USBPF_X
case|:
name|A
operator|<<=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_RSH
operator||
name|USBPF_X
case|:
name|A
operator|>>=
name|X
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_ADD
operator||
name|USBPF_K
case|:
name|A
operator|+=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_SUB
operator||
name|USBPF_K
case|:
name|A
operator|-=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_MUL
operator||
name|USBPF_K
case|:
name|A
operator|*=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_DIV
operator||
name|USBPF_K
case|:
name|A
operator|/=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_AND
operator||
name|USBPF_K
case|:
name|A
operator|&=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_OR
operator||
name|USBPF_K
case|:
name|A
operator||=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_LSH
operator||
name|USBPF_K
case|:
name|A
operator|<<=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_RSH
operator||
name|USBPF_K
case|:
name|A
operator|>>=
name|pc
operator|->
name|k
expr_stmt|;
continue|continue;
case|case
name|USBPF_ALU
operator||
name|USBPF_NEG
case|:
name|A
operator|=
operator|-
name|A
expr_stmt|;
continue|continue;
case|case
name|USBPF_MISC
operator||
name|USBPF_TAX
case|:
name|X
operator|=
name|A
expr_stmt|;
continue|continue;
case|case
name|USBPF_MISC
operator||
name|USBPF_TXA
case|:
name|A
operator|=
name|X
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_free
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
switch|switch
condition|(
name|ud
operator|->
name|ud_bufmode
condition|)
block|{
case|case
name|USBPF_BUFMODE_BUFFER
case|:
return|return
operator|(
name|usbpf_buffer_free
argument_list|(
name|ud
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"usbpf_buf_free"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notify the buffer model that a buffer has moved into the hold position.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_bufheld
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free buffers currently in use by a descriptor.  * Called on close.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_freed
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
comment|/* 	 * We don't need to lock out interrupts since this descriptor has 	 * been detached from its interface and it yet hasn't been marked 	 * free. 	 */
name|usbpf_free
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_rfilter
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ud
operator|->
name|ud_rfilter
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_wfilter
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ud
operator|->
name|ud_wfilter
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ud
operator|->
name|ud_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close the descriptor by detaching it from its interface,  * deallocating its buffers, and marking it free.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|usbpf_d
modifier|*
name|ud
init|=
name|data
decl_stmt|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_state
operator|==
name|USBPF_WAITING
condition|)
name|callout_stop
argument_list|(
operator|&
name|ud
operator|->
name|ud_callout
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_state
operator|=
name|USBPF_IDLE
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|ud
operator|->
name|ud_sigio
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_bif
condition|)
name|usbpf_detachd
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|ud
operator|->
name|ud_sel
argument_list|,
name|PRIUSB
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|ud
operator|->
name|ud_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ud
operator|->
name|ud_callout
argument_list|)
expr_stmt|;
name|usbpf_freed
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ud
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open device.  Returns ENXIO for illegal minor device number,  * EBUSY if file is open by another process.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|usbpf_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usbpf_d
modifier|*
name|ud
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ud
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
argument_list|,
name|M_USBPF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|ud
argument_list|,
name|usbpf_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ud
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|usbpf_buffer_init
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_bufmode
operator|=
name|USBPF_BUFMODE_BUFFER
expr_stmt|;
name|ud
operator|->
name|ud_sig
operator|=
name|SIGIO
expr_stmt|;
name|ud
operator|->
name|ud_direction
operator|=
name|USBPF_D_INOUT
expr_stmt|;
name|ud
operator|->
name|ud_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ud
operator|->
name|ud_mtx
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"usbpf cdev lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|ud
operator|->
name|ud_callout
argument_list|,
operator|&
name|ud
operator|->
name|ud_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|ud
operator|->
name|ud_sel
operator|.
name|si_note
argument_list|,
operator|&
name|ud
operator|->
name|ud_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_uiomove
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
if|if
condition|(
name|ud
operator|->
name|ud_bufmode
operator|!=
name|USBPF_BUFMODE_BUFFER
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|usbpf_buffer_uiomove
argument_list|(
name|ud
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  usbpf_read - read next chunk of packets from buffers  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|usbpf_d
modifier|*
name|ud
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|non_block
decl_stmt|;
name|int
name|timed_out
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Restrict application to use a buffer the same size as 	 * as kernel buffers. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|ud
operator|->
name|ud_bufsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|non_block
operator|=
operator|(
operator|(
name|ioflag
operator|&
name|O_NONBLOCK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_pid
operator|=
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_bufmode
operator|!=
name|USBPF_BUFMODE_BUFFER
condition|)
block|{
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|ud
operator|->
name|ud_state
operator|==
name|USBPF_WAITING
condition|)
name|callout_stop
argument_list|(
operator|&
name|ud
operator|->
name|ud_callout
argument_list|)
expr_stmt|;
name|timed_out
operator|=
operator|(
name|ud
operator|->
name|ud_state
operator|==
name|USBPF_TIMED_OUT
operator|)
expr_stmt|;
name|ud
operator|->
name|ud_state
operator|=
name|USBPF_IDLE
expr_stmt|;
comment|/* 	 * If the hold buffer is empty, then do a timed sleep, which 	 * ends when the timeout expires or when enough packets 	 * have arrived to fill the store buffer. 	 */
while|while
condition|(
name|ud
operator|->
name|ud_hbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ud
operator|->
name|ud_slen
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A packet(s) either arrived since the previous 			 * read or arrived while we were asleep. 			 */
if|if
condition|(
name|ud
operator|->
name|ud_immediate
operator|||
name|non_block
operator|||
name|timed_out
condition|)
block|{
comment|/* 				 * Rotate the buffers and return what's here 				 * if we are in immediate mode, non-blocking 				 * flag is set, or this descriptor timed out. 				 */
name|USBPF_ROTATE_BUFFERS
argument_list|(
name|ud
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * No data is available, check to see if the usbpf device 		 * is still pointed at a real interface.  If not, return 		 * ENXIO so that the userland process knows to rebind 		 * it before using it again. 		 */
if|if
condition|(
name|ud
operator|->
name|ud_bif
operator|==
name|NULL
condition|)
block|{
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|non_block
condition|)
block|{
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|error
operator|=
name|msleep
argument_list|(
name|ud
argument_list|,
operator|&
name|ud
operator|->
name|ud_mtx
argument_list|,
name|PRIUSB
operator||
name|PCATCH
argument_list|,
literal|"uff"
argument_list|,
name|ud
operator|->
name|ud_rtout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* 			 * On a timeout, return what's in the buffer, 			 * which may be nothing.  If there is something 			 * in the store buffer, we can rotate the buffers. 			 */
if|if
condition|(
name|ud
operator|->
name|ud_hbuf
condition|)
comment|/* 				 * We filled up the buffer in between 				 * getting the timeout and arriving 				 * here, so we don't need to rotate. 				 */
break|break;
if|if
condition|(
name|ud
operator|->
name|ud_slen
operator|==
literal|0
condition|)
block|{
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|USBPF_ROTATE_BUFFERS
argument_list|(
name|ud
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * At this point, we know we have something in the hold slot. 	 */
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
comment|/* 	 * Move data from hold buffer into user space. 	 * We know the entire buffer is transferred since 	 * we checked above that the read buffer is usbpf_bufsize bytes. 	 * 	 * XXXRW: More synchronization needed here: what if a second thread 	 * issues a read on the same fd at the same time?  Don't want this 	 * getting invalidated. 	 */
name|error
operator|=
name|usbpf_uiomove
argument_list|(
name|ud
argument_list|,
name|ud
operator|->
name|ud_hbuf
argument_list|,
name|ud
operator|->
name|ud_hlen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_fbuf
operator|=
name|ud
operator|->
name|ud_hbuf
expr_stmt|;
name|ud
operator|->
name|ud_hbuf
operator|=
name|NULL
expr_stmt|;
name|ud
operator|->
name|ud_hlen
operator|=
literal|0
expr_stmt|;
name|usbpf_buf_reclaimed
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
comment|/* NOT IMPLEMENTED */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_ioctl_sblen
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|u_int
modifier|*
name|i
parameter_list|)
block|{
if|if
condition|(
name|ud
operator|->
name|ud_bufmode
operator|!=
name|USBPF_BUFMODE_BUFFER
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|usbpf_buffer_ioctl_sblen
argument_list|(
name|ud
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a descriptor by flushing its packet buffer and clearing the receive  * and drop counts.  This is doable for kernel-only buffers, but with  * zero-copy buffers, we can't write to (or rotate) buffers that are  * currently owned by userspace.  It would be nice if we could encapsulate  * this logic in the buffer code rather than here.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_reset_d
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ud
operator|->
name|ud_hbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ud
operator|->
name|ud_bufmode
operator|!=
name|USBPF_BUFMODE_ZBUF
operator|||
name|usbpf_canfreebuf
argument_list|(
name|ud
argument_list|)
operator|)
condition|)
block|{
comment|/* Free the hold buffer. */
name|ud
operator|->
name|ud_fbuf
operator|=
name|ud
operator|->
name|ud_hbuf
expr_stmt|;
name|ud
operator|->
name|ud_hbuf
operator|=
name|NULL
expr_stmt|;
name|ud
operator|->
name|ud_hlen
operator|=
literal|0
expr_stmt|;
name|usbpf_buf_reclaimed
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbpf_canwritebuf
argument_list|(
name|ud
argument_list|)
condition|)
name|ud
operator|->
name|ud_slen
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_rcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_dcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_fcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_wcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_wfcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_wdcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|->
name|ud_zcopy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_setif
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|struct
name|usbpf_ifreq
modifier|*
name|ufr
parameter_list|)
block|{
name|struct
name|usbpf_if
modifier|*
name|uif
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|theywant
decl_stmt|;
name|theywant
operator|=
name|usb_bus_find
argument_list|(
name|ufr
operator|->
name|ufr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|theywant
operator|==
name|NULL
operator|||
name|theywant
operator|->
name|uif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|uif
operator|=
name|theywant
operator|->
name|uif
expr_stmt|;
switch|switch
condition|(
name|ud
operator|->
name|ud_bufmode
condition|)
block|{
case|case
name|USBPF_BUFMODE_BUFFER
case|:
if|if
condition|(
name|ud
operator|->
name|ud_sbuf
operator|==
name|NULL
condition|)
name|usbpf_buffer_alloc
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ud
operator|->
name|ud_sbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ud_sbuf == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"usbpf_setif: bufmode %d"
argument_list|,
name|ud
operator|->
name|ud_bufmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uif
operator|!=
name|ud
operator|->
name|ud_bif
condition|)
block|{
if|if
condition|(
name|ud
operator|->
name|ud_bif
condition|)
comment|/* 			 * Detach if attached to something else. 			 */
name|usbpf_detachd
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|usbpf_attachd
argument_list|(
name|ud
argument_list|,
name|uif
argument_list|)
expr_stmt|;
block|}
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|usbpf_reset_d
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set d's packet filter program to fp.  If this file already has a filter,  * free it and replace it.  Returns EINVAL for bogus requests.  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_setf
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|struct
name|usbpf_program
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|struct
name|usbpf_insn
modifier|*
name|fcode
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|u_int
name|wfilter
decl_stmt|,
name|flen
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|UIOCSETWF
condition|)
block|{
name|old
operator|=
name|ud
operator|->
name|ud_wfilter
expr_stmt|;
name|wfilter
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wfilter
operator|=
literal|0
expr_stmt|;
name|old
operator|=
name|ud
operator|->
name|ud_rfilter
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|uf_insns
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|uf_len
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfilter
condition|)
name|ud
operator|->
name|ud_wfilter
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|ud
operator|->
name|ud_rfilter
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|UIOCSETF
condition|)
name|usbpf_reset_d
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flen
operator|=
name|fp
operator|->
name|uf_len
expr_stmt|;
if|if
condition|(
name|flen
operator|>
name|usbpf_maxinsns
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
name|flen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|uf_insns
argument_list|)
expr_stmt|;
name|fcode
operator|=
operator|(
expr|struct
name|usbpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_USBPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|uf_insns
argument_list|,
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|size
argument_list|)
operator|==
literal|0
operator|&&
name|usbpf_validate
argument_list|(
name|fcode
argument_list|,
operator|(
name|int
operator|)
name|flen
argument_list|)
condition|)
block|{
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfilter
condition|)
name|ud
operator|->
name|ud_wfilter
operator|=
name|fcode
expr_stmt|;
else|else
block|{
name|ud
operator|->
name|ud_rfilter
operator|=
name|fcode
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|UIOCSETF
condition|)
name|usbpf_reset_d
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|usbpf_d
modifier|*
name|ud
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Refresh PID associated with this descriptor. 	 */
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_state
operator|==
name|USBPF_WAITING
condition|)
name|callout_stop
argument_list|(
operator|&
name|ud
operator|->
name|ud_callout
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_state
operator|=
name|USBPF_IDLE
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_locked
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|UIOCGBLEN
case|:
case|case
name|UIOCSBLEN
case|:
case|case
name|UIOCVERSION
case|:
break|break;
default|default:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
comment|/* 	 * Get buffer len [for read()]. 	 */
case|case
name|UIOCGBLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|ud
operator|->
name|ud_bufsize
expr_stmt|;
break|break;
comment|/* 	 * Set buffer length. 	 */
case|case
name|UIOCSBLEN
case|:
name|error
operator|=
name|usbpf_ioctl_sblen
argument_list|(
name|ud
argument_list|,
operator|(
name|u_int
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set read filter. 	 */
case|case
name|UIOCSETF
case|:
name|error
operator|=
name|usbpf_setf
argument_list|(
name|ud
argument_list|,
operator|(
expr|struct
name|usbpf_program
operator|*
operator|)
name|addr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set read timeout. 	 */
case|case
name|UIOCSRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
comment|/* 			 * Subtract 1 tick from tvtohz() since this isn't 			 * a one-shot timer. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|itimerfix
argument_list|(
name|tv
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ud
operator|->
name|ud_rtout
operator|=
name|tvtohz
argument_list|(
name|tv
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get read timeout. 	 */
case|case
name|UIOCGRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|ud
operator|->
name|ud_rtout
operator|/
name|hz
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
operator|(
name|ud
operator|->
name|ud_rtout
operator|%
name|hz
operator|)
operator|*
name|tick
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get packet stats. 	 */
case|case
name|UIOCGSTATS
case|:
block|{
name|struct
name|usbpf_stat
modifier|*
name|us
init|=
operator|(
expr|struct
name|usbpf_stat
operator|*
operator|)
name|addr
decl_stmt|;
comment|/* XXXCSJP overflow */
name|us
operator|->
name|us_recv
operator|=
name|ud
operator|->
name|ud_rcount
expr_stmt|;
name|us
operator|->
name|us_drop
operator|=
name|ud
operator|->
name|ud_dcount
expr_stmt|;
break|break;
block|}
case|case
name|UIOCVERSION
case|:
block|{
name|struct
name|usbpf_version
modifier|*
name|uv
init|=
operator|(
expr|struct
name|usbpf_version
operator|*
operator|)
name|addr
decl_stmt|;
name|uv
operator|->
name|uv_major
operator|=
name|USBPF_MAJOR_VERSION
expr_stmt|;
name|uv
operator|->
name|uv_minor
operator|=
name|USBPF_MINOR_VERSION
expr_stmt|;
break|break;
block|}
comment|/* 	 * Set interface. 	 */
case|case
name|UIOCSETIF
case|:
name|error
operator|=
name|usbpf_setif
argument_list|(
name|ud
argument_list|,
operator|(
expr|struct
name|usbpf_ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for select() and poll() system calls  *  * Return true iff the specific operation will not block indefinitely.  * Otherwise, return false but make a note that a selwakeup() must be done.  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* NOT IMPLEMENTED */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for kevent() system call.  Register EVFILT_READ filters and  * reject all others.  */
end_comment

begin_function
name|int
name|usbpf_kqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
comment|/* NOT IMPLEMENTED */
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach file to the usbpf interface, i.e. make d listen on bp.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_attachd
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|struct
name|usbpf_if
modifier|*
name|uif
parameter_list|)
block|{
name|USBPFIF_LOCK
argument_list|(
name|uif
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_bif
operator|=
name|uif
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uif
operator|->
name|uif_dlist
argument_list|,
name|ud
argument_list|,
name|ud_next
argument_list|)
expr_stmt|;
name|usbpf_uifd_cnt
operator|++
expr_stmt|;
name|USBPFIF_UNLOCK
argument_list|(
name|uif
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach a file from its interface.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_detachd
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|struct
name|usbpf_if
modifier|*
name|uif
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|ubus
decl_stmt|;
name|uif
operator|=
name|ud
operator|->
name|ud_bif
expr_stmt|;
name|USBPFIF_LOCK
argument_list|(
name|uif
argument_list|)
expr_stmt|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|ubus
operator|=
name|ud
operator|->
name|ud_bif
operator|->
name|uif_ubus
expr_stmt|;
comment|/* 	 * Remove d from the interface's descriptor list. 	 */
name|LIST_REMOVE
argument_list|(
name|ud
argument_list|,
name|ud_next
argument_list|)
expr_stmt|;
name|usbpf_uifd_cnt
operator|--
expr_stmt|;
name|ud
operator|->
name|ud_bif
operator|=
name|NULL
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|USBPFIF_UNLOCK
argument_list|(
name|uif
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbpf_attach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|,
name|struct
name|usbpf_if
modifier|*
modifier|*
name|driverp
parameter_list|)
block|{
name|struct
name|usbpf_if
modifier|*
name|uif
decl_stmt|;
name|uif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|uif
argument_list|)
argument_list|,
name|M_USBPF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|uif
operator|->
name|uif_dlist
argument_list|)
expr_stmt|;
name|uif
operator|->
name|uif_ubus
operator|=
name|ubus
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|uif
operator|->
name|uif_mtx
argument_list|,
literal|"usbpf interface lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|driverp
operator|==
name|NULL
argument_list|,
operator|(
literal|"usbpf_attach: driverp already initialized"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|driverp
operator|=
name|uif
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|usbpf_iflist
argument_list|,
name|uif
argument_list|,
name|uif_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf attached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there are processes sleeping on this descriptor, wake them up.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|usbpf_wakeup
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_state
operator|==
name|USBPF_WAITING
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|ud
operator|->
name|ud_callout
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_state
operator|=
name|USBPF_IDLE
expr_stmt|;
block|}
name|wakeup
argument_list|(
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|->
name|ud_async
operator|&&
name|ud
operator|->
name|ud_sig
operator|&&
name|ud
operator|->
name|ud_sigio
condition|)
name|pgsigio
argument_list|(
operator|&
name|ud
operator|->
name|ud_sigio
argument_list|,
name|ud
operator|->
name|ud_sig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|ud
operator|->
name|ud_sel
argument_list|,
name|PRIUSB
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|ud
operator|->
name|ud_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbpf_detach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
name|struct
name|usbpf_if
modifier|*
name|uif
decl_stmt|;
name|struct
name|usbpf_d
modifier|*
name|ud
decl_stmt|;
comment|/* Locate USBPF interface information */
name|mtx_lock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|uif
argument_list|,
argument|&usbpf_iflist
argument_list|,
argument|uif_next
argument_list|)
block|{
if|if
condition|(
name|ubus
operator|==
name|uif
operator|->
name|uif_ubus
condition|)
break|break;
block|}
comment|/* Interface wasn't attached */
if|if
condition|(
operator|(
name|uif
operator|==
name|NULL
operator|)
operator|||
operator|(
name|uif
operator|->
name|uif_ubus
operator|==
name|NULL
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"usbpf_detach: not attached\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
name|LIST_REMOVE
argument_list|(
name|uif
argument_list|,
name|uif_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ud
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uif
operator|->
name|uif_dlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|usbpf_detachd
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|usbpf_wakeup
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|uif
operator|->
name|uif_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uif
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Time stamping functions */
end_comment

begin_define
define|#
directive|define
name|USBPF_T_MICROTIME
value|0x0000
end_define

begin_define
define|#
directive|define
name|USBPF_T_NANOTIME
value|0x0001
end_define

begin_define
define|#
directive|define
name|USBPF_T_BINTIME
value|0x0002
end_define

begin_define
define|#
directive|define
name|USBPF_T_NONE
value|0x0003
end_define

begin_define
define|#
directive|define
name|USBPF_T_FORMAT_MASK
value|0x0003
end_define

begin_define
define|#
directive|define
name|USBPF_T_NORMAL
value|0x0000
end_define

begin_define
define|#
directive|define
name|USBPF_T_FAST
value|0x0100
end_define

begin_define
define|#
directive|define
name|USBPF_T_MONOTONIC
value|0x0200
end_define

begin_define
define|#
directive|define
name|USBPF_T_FORMAT
parameter_list|(
name|t
parameter_list|)
value|((t)& USBPF_T_FORMAT_MASK)
end_define

begin_define
define|#
directive|define
name|USBPF_TSTAMP_NONE
value|0
end_define

begin_define
define|#
directive|define
name|USBPF_TSTAMP_FAST
value|1
end_define

begin_define
define|#
directive|define
name|USBPF_TSTAMP_NORMAL
value|2
end_define

begin_function
specifier|static
name|int
name|usbpf_ts_quality
parameter_list|(
name|int
name|tstype
parameter_list|)
block|{
if|if
condition|(
name|tstype
operator|==
name|USBPF_T_NONE
condition|)
return|return
operator|(
name|USBPF_TSTAMP_NONE
operator|)
return|;
if|if
condition|(
operator|(
name|tstype
operator|&
name|USBPF_T_FAST
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|USBPF_TSTAMP_FAST
operator|)
return|;
return|return
operator|(
name|USBPF_TSTAMP_NORMAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_gettime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|int
name|tstype
parameter_list|)
block|{
name|int
name|quality
decl_stmt|;
name|quality
operator|=
name|usbpf_ts_quality
argument_list|(
name|tstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|quality
operator|==
name|USBPF_TSTAMP_NONE
condition|)
return|return
operator|(
name|quality
operator|)
return|;
if|if
condition|(
name|quality
operator|==
name|USBPF_TSTAMP_NORMAL
condition|)
name|binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
else|else
name|getbinuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
return|return
operator|(
name|quality
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the buffer mechanism has a way to decide that a held buffer can be made  * free, then it is exposed via the usbpf_canfreebuf() interface.  (1) is  * returned if the buffer can be discarded, (0) is returned if it cannot.  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_canfreebuf
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow the buffer model to indicate that the current store buffer is  * immutable, regardless of the appearance of space.  Return (1) if the  * buffer is writable, and (0) if not.  */
end_comment

begin_function
specifier|static
name|int
name|usbpf_canwritebuf
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify buffer model that an attempt to write to the store buffer has  * resulted in a dropped packet, in which case the buffer may be considered  * full.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_buffull
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function gets called when the free buffer is re-assigned.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_buf_reclaimed
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ud
operator|->
name|ud_bufmode
condition|)
block|{
case|case
name|USBPF_BUFMODE_BUFFER
case|:
return|return;
default|default:
name|panic
argument_list|(
literal|"usbpf_buf_reclaimed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SIZEOF_USBPF_HDR
parameter_list|(
name|type
parameter_list|)
define|\
value|(offsetof(type, uh_hdrlen) + sizeof(((type *)0)->uh_hdrlen))
end_define

begin_function
specifier|static
name|int
name|usbpf_hdrlen
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|)
block|{
name|int
name|hdrlen
decl_stmt|;
name|hdrlen
operator|=
name|ud
operator|->
name|ud_bif
operator|->
name|uif_hdrlen
expr_stmt|;
name|hdrlen
operator|+=
name|SIZEOF_USBPF_HDR
argument_list|(
expr|struct
name|usbpf_xhdr
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|USBPF_WORDALIGN
argument_list|(
name|hdrlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdrlen
operator|-
name|ud
operator|->
name|ud_bif
operator|->
name|uif_hdrlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_bintime2ts
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|struct
name|usbpf_ts
modifier|*
name|ts
parameter_list|,
name|int
name|tstype
parameter_list|)
block|{
name|struct
name|bintime
name|bt2
decl_stmt|;
name|struct
name|timeval
name|tsm
decl_stmt|;
name|struct
name|timespec
name|tsn
decl_stmt|;
if|if
condition|(
operator|(
name|tstype
operator|&
name|USBPF_T_MONOTONIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bt2
operator|=
operator|*
name|bt
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt2
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bt
operator|=
operator|&
name|bt2
expr_stmt|;
block|}
switch|switch
condition|(
name|USBPF_T_FORMAT
argument_list|(
name|tstype
argument_list|)
condition|)
block|{
case|case
name|USBPF_T_MICROTIME
case|:
name|bintime2timeval
argument_list|(
name|bt
argument_list|,
operator|&
name|tsm
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ut_sec
operator|=
name|tsm
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|->
name|ut_frac
operator|=
name|tsm
operator|.
name|tv_usec
expr_stmt|;
break|break;
case|case
name|USBPF_T_NANOTIME
case|:
name|bintime2timespec
argument_list|(
name|bt
argument_list|,
operator|&
name|tsn
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ut_sec
operator|=
name|tsn
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|->
name|ut_frac
operator|=
name|tsn
operator|.
name|tv_nsec
expr_stmt|;
break|break;
case|case
name|USBPF_T_BINTIME
case|:
name|ts
operator|->
name|ut_sec
operator|=
name|bt
operator|->
name|sec
expr_stmt|;
name|ts
operator|->
name|ut_frac
operator|=
name|bt
operator|->
name|frac
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Move the packet data from interface memory (pkt) into the  * store buffer.  "cpfn" is the routine called to do the actual data  * transfer.  bcopy is passed in to copy contiguous chunks, while  * usbpf_append_mbuf is passed in to copy mbuf chains.  In the latter case,  * pkt is really an mbuf.  */
end_comment

begin_function
specifier|static
name|void
name|catchpacket
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|u_char
modifier|*
name|pkt
parameter_list|,
name|u_int
name|pktlen
parameter_list|,
name|u_int
name|snaplen
parameter_list|,
name|void
function_decl|(
modifier|*
name|cpfn
function_decl|)
parameter_list|(
name|struct
name|usbpf_d
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|usbpf_xhdr
name|hdr
decl_stmt|;
name|int
name|caplen
decl_stmt|,
name|curlen
decl_stmt|,
name|hdrlen
decl_stmt|,
name|totlen
decl_stmt|;
name|int
name|do_wakeup
init|=
literal|0
decl_stmt|;
name|int
name|do_timestamp
decl_stmt|;
name|int
name|tstype
decl_stmt|;
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
comment|/* 	 * Detect whether user space has released a buffer back to us, and if 	 * so, move it from being a hold buffer to a free buffer.  This may 	 * not be the best place to do it (for example, we might only want to 	 * run this check if we need the space), but for now it's a reliable 	 * spot to do it. 	 */
if|if
condition|(
name|ud
operator|->
name|ud_fbuf
operator|==
name|NULL
operator|&&
name|usbpf_canfreebuf
argument_list|(
name|ud
argument_list|)
condition|)
block|{
name|ud
operator|->
name|ud_fbuf
operator|=
name|ud
operator|->
name|ud_hbuf
expr_stmt|;
name|ud
operator|->
name|ud_hbuf
operator|=
name|NULL
expr_stmt|;
name|ud
operator|->
name|ud_hlen
operator|=
literal|0
expr_stmt|;
name|usbpf_buf_reclaimed
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out how many bytes to move.  If the packet is 	 * greater or equal to the snapshot length, transfer that 	 * much.  Otherwise, transfer the whole packet (unless 	 * we hit the buffer size limit). 	 */
name|hdrlen
operator|=
name|usbpf_hdrlen
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|hdrlen
operator|+
name|min
argument_list|(
name|snaplen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
name|ud
operator|->
name|ud_bufsize
condition|)
name|totlen
operator|=
name|ud
operator|->
name|ud_bufsize
expr_stmt|;
comment|/* 	 * Round up the end of the previous packet to the next longword. 	 * 	 * Drop the packet if there's no room and no hope of room 	 * If the packet would overflow the storage buffer or the storage 	 * buffer is considered immutable by the buffer model, try to rotate 	 * the buffer and wakeup pending processes. 	 */
name|curlen
operator|=
name|USBPF_WORDALIGN
argument_list|(
name|ud
operator|->
name|ud_slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|curlen
operator|+
name|totlen
operator|>
name|ud
operator|->
name|ud_bufsize
operator|||
operator|!
name|usbpf_canwritebuf
argument_list|(
name|ud
argument_list|)
condition|)
block|{
if|if
condition|(
name|ud
operator|->
name|ud_fbuf
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There's no room in the store buffer, and no 			 * prospect of room, so drop the packet.  Notify the 			 * buffer model. 			 */
name|usbpf_buffull
argument_list|(
name|ud
argument_list|)
expr_stmt|;
operator|++
name|ud
operator|->
name|ud_dcount
expr_stmt|;
return|return;
block|}
name|USBPF_ROTATE_BUFFERS
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ud
operator|->
name|ud_immediate
operator|||
name|ud
operator|->
name|ud_state
operator|==
name|USBPF_TIMED_OUT
condition|)
comment|/* 		 * Immediate mode is set, or the read timeout has already 		 * expired during a select call.  A packet arrived, so the 		 * reader should be woken up. 		 */
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|caplen
operator|=
name|totlen
operator|-
name|hdrlen
expr_stmt|;
name|tstype
operator|=
name|ud
operator|->
name|ud_tstamp
expr_stmt|;
name|do_timestamp
operator|=
name|tstype
operator|!=
name|USBPF_T_NONE
expr_stmt|;
comment|/* 	 * Append the usbpf header.  Note we append the actual header size, but 	 * move forward the length of the header plus padding. 	 */
name|bzero
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_timestamp
condition|)
name|usbpf_bintime2ts
argument_list|(
name|bt
argument_list|,
operator|&
name|hdr
operator|.
name|uh_tstamp
argument_list|,
name|tstype
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|uh_datalen
operator|=
name|pktlen
expr_stmt|;
name|hdr
operator|.
name|uh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|hdr
operator|.
name|uh_caplen
operator|=
name|caplen
expr_stmt|;
name|usbpf_append_bytes
argument_list|(
name|ud
argument_list|,
name|ud
operator|->
name|ud_sbuf
argument_list|,
name|curlen
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the packet data into the store buffer and update its length. 	 */
call|(
modifier|*
name|cpfn
call|)
argument_list|(
name|ud
argument_list|,
name|ud
operator|->
name|ud_sbuf
argument_list|,
name|curlen
operator|+
name|hdrlen
argument_list|,
name|pkt
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|ud
operator|->
name|ud_slen
operator|=
name|curlen
operator|+
name|totlen
expr_stmt|;
if|if
condition|(
name|do_wakeup
condition|)
name|usbpf_wakeup
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Incoming linkage from device drivers.  Process the packet pkt, of length  * pktlen, which is stored in a contiguous buffer.  The packet is parsed  * by each process' filter, and if accepted, stashed into the corresponding  * buffer.  */
end_comment

begin_function
specifier|static
name|void
name|usbpf_tap
parameter_list|(
name|struct
name|usbpf_if
modifier|*
name|uif
parameter_list|,
name|u_char
modifier|*
name|pkt
parameter_list|,
name|u_int
name|pktlen
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|usbpf_d
modifier|*
name|ud
decl_stmt|;
name|u_int
name|slen
decl_stmt|;
name|int
name|gottime
decl_stmt|;
name|gottime
operator|=
name|USBPF_TSTAMP_NONE
expr_stmt|;
name|USBPFIF_LOCK
argument_list|(
name|uif
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ud
argument_list|,
argument|&uif->uif_dlist
argument_list|,
argument|ud_next
argument_list|)
block|{
name|USBPFD_LOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
operator|++
name|ud
operator|->
name|ud_rcount
expr_stmt|;
name|slen
operator|=
name|usbpf_filter
argument_list|(
name|ud
operator|->
name|ud_rfilter
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
block|{
name|ud
operator|->
name|ud_fcount
operator|++
expr_stmt|;
if|if
condition|(
name|gottime
operator|<
name|usbpf_ts_quality
argument_list|(
name|ud
operator|->
name|ud_tstamp
argument_list|)
condition|)
name|gottime
operator|=
name|usbpf_gettime
argument_list|(
operator|&
name|bt
argument_list|,
name|ud
operator|->
name|ud_tstamp
argument_list|)
expr_stmt|;
name|catchpacket
argument_list|(
name|ud
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|usbpf_append_bytes
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
block|}
name|USBPFD_UNLOCK
argument_list|(
name|ud
argument_list|)
expr_stmt|;
block|}
name|USBPFIF_UNLOCK
argument_list|(
name|uif
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_xferflags
parameter_list|(
name|struct
name|usb_xfer_flags
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|force_short_xfer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_FORCE_SHORT_XFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_XFER_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|pipe_bof
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PIPE_BOF
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|proxy_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PROXY_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|ext_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_EXT_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|manual_status
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_MANUAL_STATUS
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|no_pipe_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_NO_PIPE_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|stall_pipe
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_STALL_PIPE
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_status
parameter_list|(
name|struct
name|usb_xfer_flags_int
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|open
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_OPEN
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|transferring
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_TRANSFERRING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_dma_delay
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_DMA_DELAY
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_close
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_CLOSE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|draining
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DRAINING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|started
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_STARTED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bandwidth_reclaimed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BW_RECLAIMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_hdr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_HDR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_act
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_ACT
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_stall
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_STALL
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_XFER_OK
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|flags
operator|->
name|bdma_enable
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_ENABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_no_post_sync
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_NO_POST_SYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_setup
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_SETUP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|->
name|isochronous_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_ISOCHRONOUS_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|curr_dma_set
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CURR_DMA_SET
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|can_cancel_immed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CAN_CANCEL_IMMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|doing_callback
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DOING_CALLBACK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbpf_xfertap
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
init|=
name|xfer
operator|->
name|endpoint
decl_stmt|;
name|struct
name|usb_page_search
name|res
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
init|=
name|xfer
operator|->
name|xroot
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|bus
init|=
name|info
operator|->
name|bus
decl_stmt|;
name|struct
name|usbpf_pkthdr
modifier|*
name|up
decl_stmt|;
name|usb_frlength_t
name|isoc_offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* 	 * NB: usbpf_uifd_cnt isn't protected by USBPFIF_LOCK() because it's 	 * not harmful. 	 */
if|if
condition|(
name|usbpf_uifd_cnt
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * XXX TODO 	 * Allocating the buffer here causes copy operations twice what's 	 * really inefficient. Copying usbpf_pkthdr and data is for USB packet 	 * read filter to pass a virtually linear buffer. 	 */
name|buf
operator|=
name|ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
operator|+
operator|(
name|USB_PAGE_SIZE
operator|*
literal|5
operator|)
argument_list|,
name|M_USBPF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"usbpf_xfertap: out of memory\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
name|end
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
operator|+
operator|(
name|USB_PAGE_SIZE
operator|*
literal|5
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|usbpf_pkthdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|up
operator|->
name|up_busunit
operator|=
name|htole32
argument_list|(
name|device_get_unit
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_type
operator|=
name|type
expr_stmt|;
name|up
operator|->
name|up_xfertype
operator|=
name|ep
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
name|up
operator|->
name|up_address
operator|=
name|xfer
operator|->
name|address
expr_stmt|;
name|up
operator|->
name|up_endpoint
operator|=
name|xfer
operator|->
name|endpointno
expr_stmt|;
name|up
operator|->
name|up_flags
operator|=
name|htole32
argument_list|(
name|usbpf_aggregate_xferflags
argument_list|(
operator|&
name|xfer
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_status
operator|=
name|htole32
argument_list|(
name|usbpf_aggregate_status
argument_list|(
operator|&
name|xfer
operator|->
name|flags_int
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|USBPF_XFERTAP_SUBMIT
case|:
name|up
operator|->
name|up_length
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|sumlen
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_frames
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
break|break;
case|case
name|USBPF_XFERTAP_DONE
case|:
name|up
operator|->
name|up_length
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|actlen
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_frames
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|aframes
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"wrong usbpf type (%d)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|up_error
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|error
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_interval
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|interval
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|up
operator|->
name|up_frames
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|>=
name|end
condition|)
goto|goto
name|done
goto|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|ptr
operator|)
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
operator|>=
name|end
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
operator|==
literal|1
condition|)
block|{
name|usbd_get_page
argument_list|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
literal|0
index|]
argument_list|,
name|isoc_offset
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|isoc_offset
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|usbd_get_page
argument_list|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|res
operator|.
name|buffer
argument_list|,
name|ptr
argument_list|,
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
block|}
name|usbpf_tap
argument_list|(
name|bus
operator|->
name|uif
argument_list|,
name|buf
argument_list|,
name|ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_USBPF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_append_bytes
parameter_list|(
name|struct
name|usbpf_d
modifier|*
name|ud
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|USBPFD_LOCK_ASSERT
argument_list|(
name|ud
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ud
operator|->
name|ud_bufmode
condition|)
block|{
case|case
name|USBPF_BUFMODE_BUFFER
case|:
return|return
operator|(
name|usbpf_buffer_append_bytes
argument_list|(
name|ud
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"usbpf_buf_append_bytes"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|usbpf_mtx
argument_list|,
literal|"USB packet filter global lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|usbpf_iflist
argument_list|)
expr_stmt|;
name|usbpf_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|usbpf_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"usbpf"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_drvuninit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|usbpf_cdev
operator|!=
name|NULL
condition|)
block|{
name|destroy_dev
argument_list|(
name|usbpf_cdev
argument_list|)
expr_stmt|;
name|usbpf_cdev
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|usbpf_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usbpf_dev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|usbpf_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usbpf_undev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|usbpf_drvuninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

