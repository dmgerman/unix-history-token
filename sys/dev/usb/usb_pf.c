begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_pf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|usb_no_pf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|no_pf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|usb_no_pf
argument_list|,
literal|0
argument_list|,
literal|"Set to disable USB packet filtering"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.no_pf"
argument_list|,
operator|&
name|usb_no_pf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|usbpf_attach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|usb_no_pf
operator|!=
literal|0
condition|)
block|{
name|ubus
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|ubus
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_USB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf: Could not allocate "
literal|"instance\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"usbus"
argument_list|,
name|device_get_unit
argument_list|(
name|ubus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_CANTCONFIG
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX According to the specification of DLT_USB, it indicates 	 * packets beginning with USB setup header. But not sure all 	 * packets would be. 	 */
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_USB
argument_list|,
name|USBPF_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf: Attached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbpf_detach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ubus
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ubus
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_xferflags
parameter_list|(
name|struct
name|usb_xfer_flags
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|force_short_xfer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_FORCE_SHORT_XFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_XFER_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|pipe_bof
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PIPE_BOF
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|proxy_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PROXY_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|ext_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_EXT_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|manual_status
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_MANUAL_STATUS
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|no_pipe_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_NO_PIPE_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|stall_pipe
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_STALL_PIPE
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_status
parameter_list|(
name|struct
name|usb_xfer_flags_int
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|open
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_OPEN
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|transferring
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_TRANSFERRING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_dma_delay
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_DMA_DELAY
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_close
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_CLOSE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|draining
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DRAINING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|started
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_STARTED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bandwidth_reclaimed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BW_RECLAIMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_hdr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_HDR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_act
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_ACT
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_stall
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_STALL
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_XFER_OK
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|flags
operator|->
name|bdma_enable
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_ENABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_no_post_sync
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_NO_POST_SYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_setup
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_SETUP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|->
name|isochronous_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_ISOCHRONOUS_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|curr_dma_set
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CURR_DMA_SET
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|can_cancel_immed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CAN_CANCEL_IMMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|doing_callback
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DOING_CALLBACK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_xfer_frame_is_read
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|uint32_t
name|frame
parameter_list|)
block|{
name|int
name|isread
decl_stmt|;
if|if
condition|(
operator|(
name|frame
operator|==
literal|0
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* special case */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* The device controller writes to memory */
name|isread
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The host controller reads from memory */
name|isread
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|isread
operator|=
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|isread
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_xfer_precompute_size
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|uint32_t
name|totlen
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
else|else
name|nframes
operator|=
name|xfer
operator|->
name|aframes
expr_stmt|;
name|totlen
operator|=
name|USBPF_HDR_LEN
operator|+
operator|(
name|USBPF_FRAME_HDR_LEN
operator|*
name|nframes
operator|)
expr_stmt|;
comment|/* precompute all trace lengths */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nframes
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|usbpf_xfer_frame_is_read
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|USBPF_XFERTAP_SUBMIT
condition|)
block|{
name|totlen
operator|+=
name|USBPF_FRAME_ALIGN
argument_list|(
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
block|{
name|totlen
operator|+=
name|USBPF_FRAME_ALIGN
argument_list|(
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|totlen
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbpf_xfertap
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
name|struct
name|usbpf_pkthdr
modifier|*
name|up
decl_stmt|;
name|struct
name|usbpf_framehdr
modifier|*
name|uf
decl_stmt|;
name|usb_frlength_t
name|offset
decl_stmt|;
name|uint32_t
name|totlen
decl_stmt|;
name|uint32_t
name|frame
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|bus
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|bus
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|usb_no_pf
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|bus
operator|->
name|ifp
operator|==
name|NULL
operator|||
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|bpf_peers_present
argument_list|(
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
return|return;
name|totlen
operator|=
name|usbpf_xfer_precompute_size
argument_list|(
name|xfer
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
else|else
name|nframes
operator|=
name|xfer
operator|->
name|aframes
expr_stmt|;
comment|/* 	 * XXX TODO XXX 	 * 	 * When BPF supports it we could pass a fragmented array of 	 * buffers avoiding the data copy operation here. 	 */
name|buf
operator|=
name|ptr
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|parent
argument_list|,
literal|"usbpf: Out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|up
operator|=
operator|(
expr|struct
name|usbpf_pkthdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|USBPF_HDR_LEN
expr_stmt|;
comment|/* fill out header */
name|temp
operator|=
name|device_get_unit
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_totlen
operator|=
name|htole32
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_busunit
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_address
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|device_index
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
name|up
operator|->
name|up_mode
operator|=
name|USBPF_MODE_DEVICE
expr_stmt|;
else|else
name|up
operator|->
name|up_mode
operator|=
name|USBPF_MODE_HOST
expr_stmt|;
name|up
operator|->
name|up_type
operator|=
name|type
expr_stmt|;
name|up
operator|->
name|up_xfertype
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
name|temp
operator|=
name|usbpf_aggregate_xferflags
argument_list|(
operator|&
name|xfer
operator|->
name|flags
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_flags
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|usbpf_aggregate_status
argument_list|(
operator|&
name|xfer
operator|->
name|flags_int
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_status
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|error
expr_stmt|;
name|up
operator|->
name|up_error
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|interval
expr_stmt|;
name|up
operator|->
name|up_interval
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_frames
operator|=
name|htole32
argument_list|(
name|nframes
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
name|up
operator|->
name|up_packet_size
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|max_packet_count
expr_stmt|;
name|up
operator|->
name|up_packet_count
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|endpointno
expr_stmt|;
name|up
operator|->
name|up_endpoint
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_speed
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
expr_stmt|;
comment|/* clear reserved area */
name|memset
argument_list|(
name|up
operator|->
name|up_reserved
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|up_reserved
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init offset and frame */
name|offset
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
literal|0
expr_stmt|;
comment|/* iterate all the USB frames and copy data, if any */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nframes
condition|;
name|x
operator|++
control|)
block|{
name|uint32_t
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
comment|/* get length */
name|length
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
comment|/* get frame header pointer */
name|uf
operator|=
operator|(
expr|struct
name|usbpf_framehdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|USBPF_FRAME_HDR_LEN
expr_stmt|;
comment|/* fill out packet header */
name|uf
operator|->
name|length
operator|=
name|htole32
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|uf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* get information about data read/write */
name|isread
operator|=
name|usbpf_xfer_frame_is_read
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* check if we need to copy any data */
if|if
condition|(
name|isread
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|uf
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|USBPF_FRAMEFLAG_DATA_FOLLOWS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
name|USBPF_XFERTAP_SUBMIT
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|uf
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|USBPF_FRAMEFLAG_DATA_FOLLOWS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check if data is read direction */
if|if
condition|(
name|isread
condition|)
name|uf
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|USBPF_FRAMEFLAG_READ
argument_list|)
expr_stmt|;
comment|/* copy USB data, if any */
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
comment|/* copy data */
name|usbd_copy_out
argument_list|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
name|frame
index|]
argument_list|,
name|offset
argument_list|,
name|ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* align length */
name|temp
operator|=
name|USBPF_FRAME_ALIGN
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* zero pad */
if|if
condition|(
name|temp
operator|!=
name|length
condition|)
name|memset
argument_list|(
name|ptr
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|temp
operator|-
name|length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|offset
operator|+=
name|usbd_xfer_old_frame_length
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|++
expr_stmt|;
block|}
block|}
name|bpf_tap
argument_list|(
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|,
name|buf
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

