begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_pf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_function_decl
specifier|static
name|void
name|usbpf_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbpf_uninit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_clone_match
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_clone_destroy
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb_bus
modifier|*
name|usbpf_ifname2ubus
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|usbpf_aggregate_xferflags
parameter_list|(
name|struct
name|usb_xfer_flags
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|usbpf_aggregate_status
parameter_list|(
name|struct
name|usb_xfer_flags_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usbpf_xfer_frame_is_read
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|usbpf_xfer_precompute_size
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|if_clone
modifier|*
name|usbpf_cloner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|usbusname
index|[]
init|=
literal|"usbus"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usbpf_init
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|usbpf_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usbpf_uninit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|usbpf_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usbpf_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|usbpf_cloner
operator|=
name|if_clone_advanced
argument_list|(
name|usbusname
argument_list|,
literal|0
argument_list|,
name|usbpf_clone_match
argument_list|,
name|usbpf_clone_create
argument_list|,
name|usbpf_clone_destroy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbpf_uninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|devlcnt
decl_stmt|;
name|device_t
modifier|*
name|devlp
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|ubus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|if_clone_detach
argument_list|(
name|usbpf_cloner
argument_list|)
expr_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
name|usbusname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
return|return;
name|error
operator|=
name|devclass_get_devices
argument_list|(
name|dc
argument_list|,
operator|&
name|devlp
argument_list|,
operator|&
name|devlcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devlcnt
condition|;
name|i
operator|++
control|)
block|{
name|ubus
operator|=
name|device_get_softc
argument_list|(
name|devlp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubus
operator|!=
name|NULL
operator|&&
name|ubus
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|usbpf_clone_destroy
argument_list|(
name|usbpf_cloner
argument_list|,
name|ubus
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|devlp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
comment|/* No configuration allowed. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb_bus
modifier|*
name|usbpf_ifname2ubus
parameter_list|(
specifier|const
name|char
modifier|*
name|ifname
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|devclass_t
name|dc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ifname
argument_list|,
name|usbusname
argument_list|,
sizeof|sizeof
argument_list|(
name|usbusname
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|error
operator|=
name|ifc_name2unit
argument_list|(
name|ifname
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dc
operator|=
name|devclass_find
argument_list|(
name|usbusname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|dc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_clone_match
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|ubus
decl_stmt|;
name|ubus
operator|=
name|usbpf_ifname2ubus
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubus
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ubus
operator|->
name|ifp
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|ubus
decl_stmt|;
name|error
operator|=
name|ifc_name2unit
argument_list|(
name|name
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ubus
operator|=
name|usbpf_ifname2ubus
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubus
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ubus
operator|->
name|ifp
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|error
operator|=
name|ifc_alloc_unit
argument_list|(
name|ifc
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf: Could not allocate "
literal|"instance\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ifp
operator|=
name|ubus
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_USB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf: Could not allocate "
literal|"instance\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|ubus
expr_stmt|;
name|ifp
operator|->
name|if_dname
operator|=
name|usbusname
expr_stmt|;
name|ifp
operator|->
name|if_dunit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|usbpf_ioctl
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|rt_ifmsg
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX According to the specification of DLT_USB, it indicates 	 * packets beginning with USB setup header. But not sure all 	 * packets would be. 	 */
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_USB
argument_list|,
name|USBPF_HDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_clone_destroy
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|ubus
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|ubus
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|unit
operator|=
name|ifp
operator|->
name|if_dunit
expr_stmt|;
name|ubus
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbpf_attach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf: Attached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbpf_detach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
if|if
condition|(
name|ubus
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|usbpf_clone_destroy
argument_list|(
name|usbpf_cloner
argument_list|,
name|ubus
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf: Detached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_xferflags
parameter_list|(
name|struct
name|usb_xfer_flags
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|force_short_xfer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_FORCE_SHORT_XFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_XFER_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|pipe_bof
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PIPE_BOF
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|proxy_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PROXY_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|ext_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_EXT_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|manual_status
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_MANUAL_STATUS
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|no_pipe_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_NO_PIPE_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|stall_pipe
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_STALL_PIPE
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_status
parameter_list|(
name|struct
name|usb_xfer_flags_int
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|open
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_OPEN
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|transferring
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_TRANSFERRING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_dma_delay
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_DMA_DELAY
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_close
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_CLOSE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|draining
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DRAINING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|started
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_STARTED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bandwidth_reclaimed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BW_RECLAIMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_hdr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_HDR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_act
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_ACT
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_stall
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_STALL
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_XFER_OK
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|flags
operator|->
name|bdma_enable
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_ENABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_no_post_sync
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_NO_POST_SYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_setup
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_SETUP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|->
name|isochronous_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_ISOCHRONOUS_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|curr_dma_set
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CURR_DMA_SET
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|can_cancel_immed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CAN_CANCEL_IMMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|doing_callback
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DOING_CALLBACK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usbpf_xfer_frame_is_read
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|uint32_t
name|frame
parameter_list|)
block|{
name|int
name|isread
decl_stmt|;
if|if
condition|(
operator|(
name|frame
operator|==
literal|0
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_hdr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* special case */
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
block|{
comment|/* The device controller writes to memory */
name|isread
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The host controller reads from memory */
name|isread
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|isread
operator|=
name|USB_GET_DATA_ISREAD
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|isread
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_xfer_precompute_size
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|uint32_t
name|totlen
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
else|else
name|nframes
operator|=
name|xfer
operator|->
name|aframes
expr_stmt|;
name|totlen
operator|=
name|USBPF_HDR_LEN
operator|+
operator|(
name|USBPF_FRAME_HDR_LEN
operator|*
name|nframes
operator|)
expr_stmt|;
comment|/* precompute all trace lengths */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nframes
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|usbpf_xfer_frame_is_read
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|USBPF_XFERTAP_SUBMIT
condition|)
block|{
name|totlen
operator|+=
name|USBPF_FRAME_ALIGN
argument_list|(
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
block|{
name|totlen
operator|+=
name|USBPF_FRAME_ALIGN
argument_list|(
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|totlen
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbpf_xfertap
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|usb_bus
modifier|*
name|bus
decl_stmt|;
name|struct
name|usbpf_pkthdr
modifier|*
name|up
decl_stmt|;
name|struct
name|usbpf_framehdr
modifier|*
name|uf
decl_stmt|;
name|usb_frlength_t
name|offset
decl_stmt|;
name|uint32_t
name|totlen
decl_stmt|;
name|uint32_t
name|frame
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|nframes
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|bus
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|bus
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|bus
operator|->
name|ifp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|bpf_peers_present
argument_list|(
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
return|return;
name|totlen
operator|=
name|usbpf_xfer_precompute_size
argument_list|(
name|xfer
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
name|nframes
operator|=
name|xfer
operator|->
name|nframes
expr_stmt|;
else|else
name|nframes
operator|=
name|xfer
operator|->
name|aframes
expr_stmt|;
comment|/* 	 * XXX TODO XXX 	 * 	 * When BPF supports it we could pass a fragmented array of 	 * buffers avoiding the data copy operation here. 	 */
name|buf
operator|=
name|ptr
operator|=
name|malloc
argument_list|(
name|totlen
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|bus
operator|->
name|parent
argument_list|,
literal|"usbpf: Out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|up
operator|=
operator|(
expr|struct
name|usbpf_pkthdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|USBPF_HDR_LEN
expr_stmt|;
comment|/* fill out header */
name|temp
operator|=
name|device_get_unit
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_totlen
operator|=
name|htole32
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_busunit
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_address
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|device_index
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|usb_mode
operator|==
name|USB_MODE_DEVICE
condition|)
name|up
operator|->
name|up_mode
operator|=
name|USBPF_MODE_DEVICE
expr_stmt|;
else|else
name|up
operator|->
name|up_mode
operator|=
name|USBPF_MODE_HOST
expr_stmt|;
name|up
operator|->
name|up_type
operator|=
name|type
expr_stmt|;
name|up
operator|->
name|up_xfertype
operator|=
name|xfer
operator|->
name|endpoint
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
name|temp
operator|=
name|usbpf_aggregate_xferflags
argument_list|(
operator|&
name|xfer
operator|->
name|flags
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_flags
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|usbpf_aggregate_status
argument_list|(
operator|&
name|xfer
operator|->
name|flags_int
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_status
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|error
expr_stmt|;
name|up
operator|->
name|up_error
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|interval
expr_stmt|;
name|up
operator|->
name|up_interval
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_frames
operator|=
name|htole32
argument_list|(
name|nframes
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|max_packet_size
expr_stmt|;
name|up
operator|->
name|up_packet_size
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|max_packet_count
expr_stmt|;
name|up
operator|->
name|up_packet_count
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xfer
operator|->
name|endpointno
expr_stmt|;
name|up
operator|->
name|up_endpoint
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_speed
operator|=
name|xfer
operator|->
name|xroot
operator|->
name|udev
operator|->
name|speed
expr_stmt|;
comment|/* clear reserved area */
name|memset
argument_list|(
name|up
operator|->
name|up_reserved
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|up_reserved
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init offset and frame */
name|offset
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
literal|0
expr_stmt|;
comment|/* iterate all the USB frames and copy data, if any */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|nframes
condition|;
name|x
operator|++
control|)
block|{
name|uint32_t
name|length
decl_stmt|;
name|int
name|isread
decl_stmt|;
comment|/* get length */
name|length
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
comment|/* get frame header pointer */
name|uf
operator|=
operator|(
expr|struct
name|usbpf_framehdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|USBPF_FRAME_HDR_LEN
expr_stmt|;
comment|/* fill out packet header */
name|uf
operator|->
name|length
operator|=
name|htole32
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|uf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* get information about data read/write */
name|isread
operator|=
name|usbpf_xfer_frame_is_read
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* check if we need to copy any data */
if|if
condition|(
name|isread
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|USBPF_XFERTAP_SUBMIT
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|uf
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|USBPF_FRAMEFLAG_DATA_FOLLOWS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|!=
name|USBPF_XFERTAP_SUBMIT
condition|)
name|length
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|uf
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|USBPF_FRAMEFLAG_DATA_FOLLOWS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check if data is read direction */
if|if
condition|(
name|isread
condition|)
name|uf
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|USBPF_FRAMEFLAG_READ
argument_list|)
expr_stmt|;
comment|/* copy USB data, if any */
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
comment|/* copy data */
name|usbd_copy_out
argument_list|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
name|frame
index|]
argument_list|,
name|offset
argument_list|,
name|ptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* align length */
name|temp
operator|=
name|USBPF_FRAME_ALIGN
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* zero pad */
if|if
condition|(
name|temp
operator|!=
name|length
condition|)
name|memset
argument_list|(
name|ptr
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|temp
operator|-
name|length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
condition|)
block|{
name|offset
operator|+=
name|usbd_xfer_old_frame_length
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|++
expr_stmt|;
block|}
block|}
name|bpf_tap
argument_list|(
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|,
name|buf
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

