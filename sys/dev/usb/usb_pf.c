begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_pf.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_function
name|void
name|usbpf_attach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|devclass_t
name|dc
init|=
name|devclass_find
argument_list|(
literal|"usbus"
argument_list|)
decl_stmt|;
name|ifp
operator|=
name|ubus
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_USB
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
literal|"usbus"
argument_list|,
name|devclass_get_count
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
operator|==
name|USBPF_HDR_LEN
argument_list|,
operator|(
literal|"wrong USB pf header length (%zd)"
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX According to the specification of DLT_USB, it indicates packets 	 * beginning with USB setup header.  But not sure all packets would be. 	 */
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_USB
argument_list|,
name|USBPF_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ubus
operator|->
name|parent
argument_list|,
literal|"usbpf attached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usbpf_detach
parameter_list|(
name|struct
name|usb_bus
modifier|*
name|ubus
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ubus
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ubus
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_xferflags
parameter_list|(
name|struct
name|usb_xfer_flags
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|force_short_xfer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_FORCE_SHORT_XFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_XFER_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|pipe_bof
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PIPE_BOF
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|proxy_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_PROXY_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|ext_buffer
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_EXT_BUFFER
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|manual_status
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_MANUAL_STATUS
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|no_pipe_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_NO_PIPE_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|stall_pipe
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_FLAG_STALL_PIPE
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|usbpf_aggregate_status
parameter_list|(
name|struct
name|usb_xfer_flags_int
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|open
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_OPEN
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|transferring
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_TRANSFERRING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_dma_delay
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_DMA_DELAY
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|did_close
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DID_CLOSE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|draining
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DRAINING
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|started
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_STARTED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bandwidth_reclaimed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BW_RECLAIMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_hdr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_HDR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_act
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_ACT
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|control_stall
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CONTROL_STALL
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_frames_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_FRAMES_OK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|short_xfer_ok
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_SHORT_XFER_OK
expr_stmt|;
if|#
directive|if
name|USB_HAVE_BUSDMA
if|if
condition|(
name|flags
operator|->
name|bdma_enable
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_ENABLE
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_no_post_sync
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_NO_POST_SYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|bdma_setup
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_BDMA_SETUP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|->
name|isochronous_xfr
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_ISOCHRONOUS_XFR
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|curr_dma_set
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CURR_DMA_SET
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|can_cancel_immed
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_CAN_CANCEL_IMMED
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|doing_callback
operator|==
literal|1
condition|)
name|val
operator||=
name|USBPF_STATUS_DOING_CALLBACK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbpf_xfertap
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|usb_endpoint
modifier|*
name|ep
init|=
name|xfer
operator|->
name|endpoint
decl_stmt|;
name|struct
name|usb_page_search
name|res
decl_stmt|;
name|struct
name|usb_xfer_root
modifier|*
name|info
init|=
name|xfer
operator|->
name|xroot
decl_stmt|;
name|struct
name|usb_bus
modifier|*
name|bus
init|=
name|info
operator|->
name|bus
decl_stmt|;
name|struct
name|usbpf_pkthdr
modifier|*
name|up
decl_stmt|;
name|usb_frlength_t
name|isoc_offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|bpf_peers_present
argument_list|(
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
return|return;
comment|/* 	 * XXX TODO 	 * Allocating the buffer here causes copy operations twice what's 	 * really inefficient. Copying usbpf_pkthdr and data is for USB packet 	 * read filter to pass a virtually linear buffer. 	 */
name|buf
operator|=
name|ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
operator|+
operator|(
name|USB_PAGE_SIZE
operator|*
literal|5
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"usbpf_xfertap: out of memory\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return;
block|}
name|end
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
operator|+
operator|(
name|USB_PAGE_SIZE
operator|*
literal|5
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|usbpf_pkthdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|up
operator|->
name|up_busunit
operator|=
name|htole32
argument_list|(
name|device_get_unit
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_type
operator|=
name|type
expr_stmt|;
name|up
operator|->
name|up_xfertype
operator|=
name|ep
operator|->
name|edesc
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
name|up
operator|->
name|up_address
operator|=
name|xfer
operator|->
name|address
expr_stmt|;
name|up
operator|->
name|up_endpoint
operator|=
name|xfer
operator|->
name|endpointno
expr_stmt|;
name|up
operator|->
name|up_flags
operator|=
name|htole32
argument_list|(
name|usbpf_aggregate_xferflags
argument_list|(
operator|&
name|xfer
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_status
operator|=
name|htole32
argument_list|(
name|usbpf_aggregate_status
argument_list|(
operator|&
name|xfer
operator|->
name|flags_int
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|USBPF_XFERTAP_SUBMIT
case|:
name|up
operator|->
name|up_length
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|sumlen
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_frames
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|nframes
argument_list|)
expr_stmt|;
break|break;
case|case
name|USBPF_XFERTAP_DONE
case|:
name|up
operator|->
name|up_length
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|actlen
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_frames
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|aframes
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"wrong usbpf type (%d)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|up
operator|->
name|up_error
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|error
argument_list|)
expr_stmt|;
name|up
operator|->
name|up_interval
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|interval
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|usbpf_pkthdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|up
operator|->
name|up_frames
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|>=
name|end
condition|)
goto|goto
name|done
goto|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|ptr
operator|)
operator|=
name|htole32
argument_list|(
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
operator|>=
name|end
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|isochronous_xfr
operator|==
literal|1
condition|)
block|{
name|usbd_get_page
argument_list|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
literal|0
index|]
argument_list|,
name|isoc_offset
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|isoc_offset
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|usbd_get_page
argument_list|(
operator|&
name|xfer
operator|->
name|frbuffers
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|res
operator|.
name|buffer
argument_list|,
name|ptr
argument_list|,
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|i
index|]
expr_stmt|;
block|}
name|bpf_tap
argument_list|(
name|bus
operator|->
name|ifp
operator|->
name|if_bpf
argument_list|,
name|buf
argument_list|,
name|ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

