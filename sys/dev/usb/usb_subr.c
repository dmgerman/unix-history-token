begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: usb_subr.c,v 1.7 1998/08/02 22:30:53 augustss Exp $	*/
end_comment

begin_comment
comment|/*	FreeBSD $Id$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * Author: Lennart Augustsson<augustss@carlstedt.se>  *         Carlstedt Research& Technology  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/usb/usb_port.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (usbdebug) printf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (usbdebug>(n)) printf x
end_define

begin_decl_stmt
specifier|extern
name|int
name|usbdebug
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|usbd_status
name|usbd_set_config
name|__P
argument_list|(
operator|(
name|usbd_device_handle
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|usbd_get_string
name|__P
argument_list|(
operator|(
name|usbd_device_handle
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usbd_getnewaddr
name|__P
argument_list|(
operator|(
name|usbd_bus_handle
name|bus
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usbd_print
name|__P
argument_list|(
operator|(
name|void
operator|*
name|aux
operator|,
specifier|const
name|char
operator|*
name|pnp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
name|int
name|usbd_submatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|cfdata
operator|*
name|cf
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|usb_interface_descriptor_t
modifier|*
name|usbd_find_idesc
name|__P
argument_list|(
operator|(
name|usb_config_descriptor_t
operator|*
name|cd
operator|,
name|int
name|ino
operator|,
name|int
name|ano
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|usbd_fill_iface_data
name|__P
argument_list|(
operator|(
name|usbd_device_handle
name|dev
operator|,
name|int
name|i
operator|,
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usbd_free_iface_data
name|__P
argument_list|(
operator|(
name|usbd_device_handle
name|dev
operator|,
name|int
name|ifcno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usbd_kill_pipe
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|usbd_status
name|usbd_probe_and_attach
parameter_list|(
name|bdevice
modifier|*
name|parent
parameter_list|,
name|usbd_device_handle
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USBVERBOSE
end_ifdef

begin_typedef
typedef|typedef
name|u_int16_t
name|usb_vendor_id_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int16_t
name|usb_product_id_t
typedef|;
end_typedef

begin_comment
comment|/*  * Descriptions of of known vendors and devices ("products").  */
end_comment

begin_struct
struct|struct
name|usb_knowndev
block|{
name|usb_vendor_id_t
name|vendor
decl_stmt|;
name|usb_product_id_t
name|product
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|vendorname
decl_stmt|,
modifier|*
name|productname
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|USB_KNOWNDEV_NOPROD
value|0x01
end_define

begin_comment
comment|/* match on vendor only */
end_comment

begin_include
include|#
directive|include
file|<dev/usb/usbdevs_data.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USBVERBOSE */
end_comment

begin_function
name|char
modifier|*
name|usbd_get_string
parameter_list|(
name|dev
parameter_list|,
name|si
parameter_list|,
name|buf
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|si
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|swap
init|=
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_SWAP_UNICODE
decl_stmt|;
name|usb_device_request_t
name|req
decl_stmt|;
name|usb_string_descriptor_t
name|us
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_int16_t
name|c
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|lang
decl_stmt|;
comment|/* NWH */
if|if
condition|(
name|si
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_NO_STRINGS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_DEVICE
expr_stmt|;
comment|/* fetch default language */
name|req
operator|.
name|bRequest
operator|=
name|UR_GET_DESCRIPTOR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UDESC_STRING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* only first word in bString */
name|r
operator|=
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
literal|0
return|;
name|lang
operator|=
name|UGETW
argument_list|(
name|us
operator|.
name|bString
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_GET_DESCRIPTOR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UDESC_STRING
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* only size byte first */
name|r
operator|=
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
literal|0
return|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|us
operator|.
name|bLength
argument_list|)
expr_stmt|;
comment|/* the whole string */
name|r
operator|=
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|buf
expr_stmt|;
name|n
operator|=
name|us
operator|.
name|bLength
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|UGETW
argument_list|(
name|us
operator|.
name|bString
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Convert from Unicode, handle buggy strings. */
if|if
condition|(
operator|(
name|c
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0x00ff
operator|)
operator|==
literal|0
operator|&&
name|swap
condition|)
operator|*
name|s
operator|++
operator|=
name|c
operator|>>
literal|8
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|usbd_devinfo_vp
parameter_list|(
name|dev
parameter_list|,
name|v
parameter_list|,
name|p
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
name|usb_device_descriptor_t
modifier|*
name|udd
init|=
operator|&
name|dev
operator|->
name|ddesc
decl_stmt|;
name|char
modifier|*
name|vendor
init|=
literal|0
decl_stmt|,
modifier|*
name|product
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USBVERBOSE
name|struct
name|usb_knowndev
modifier|*
name|kdp
decl_stmt|;
endif|#
directive|endif
name|vendor
operator|=
name|usbd_get_string
argument_list|(
name|dev
argument_list|,
name|udd
operator|->
name|iManufacturer
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|product
operator|=
name|usbd_get_string
argument_list|(
name|dev
argument_list|,
name|udd
operator|->
name|iProduct
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USBVERBOSE
if|if
condition|(
operator|!
name|vendor
condition|)
block|{
for|for
control|(
name|kdp
operator|=
name|usb_knowndevs
init|;
name|kdp
operator|->
name|vendorname
operator|!=
name|NULL
condition|;
name|kdp
operator|++
control|)
block|{
if|if
condition|(
name|kdp
operator|->
name|vendor
operator|==
name|UGETW
argument_list|(
name|udd
operator|->
name|idVendor
argument_list|)
operator|&&
operator|(
name|kdp
operator|->
name|product
operator|==
name|UGETW
argument_list|(
name|udd
operator|->
name|idProduct
argument_list|)
operator|||
operator|(
name|kdp
operator|->
name|flags
operator|&
name|USB_KNOWNDEV_NOPROD
operator|)
operator|!=
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|kdp
operator|->
name|vendorname
operator|==
name|NULL
condition|)
name|vendor
operator|=
name|product
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|vendor
operator|=
name|kdp
operator|->
name|vendorname
expr_stmt|;
name|product
operator|=
operator|(
name|kdp
operator|->
name|flags
operator|&
name|USB_KNOWNDEV_NOPROD
operator|)
operator|==
literal|0
condition|?
name|kdp
operator|->
name|productname
else|:
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|vendor
condition|)
name|strcpy
argument_list|(
name|v
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|v
argument_list|,
literal|"vendor 0x%04x"
argument_list|,
name|UGETW
argument_list|(
name|udd
operator|->
name|idVendor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|product
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|product
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"product 0x%04x"
argument_list|,
name|UGETW
argument_list|(
name|udd
operator|->
name|idProduct
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|usbd_printBCD
parameter_list|(
name|cp
parameter_list|,
name|bcd
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|bcd
decl_stmt|;
block|{
return|return
operator|(
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%x.%02x"
argument_list|,
name|bcd
operator|>>
literal|8
argument_list|,
name|bcd
operator|&
literal|0xff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_devinfo
parameter_list|(
name|dev
parameter_list|,
name|showclass
parameter_list|,
name|cp
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|showclass
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|usb_device_descriptor_t
modifier|*
name|udd
init|=
operator|&
name|dev
operator|->
name|ddesc
decl_stmt|;
name|char
name|vendor
index|[
name|USB_MAX_STRING_LEN
index|]
decl_stmt|;
name|char
name|product
index|[
name|USB_MAX_STRING_LEN
index|]
decl_stmt|;
name|int
name|bcdDevice
decl_stmt|,
name|bcdUSB
decl_stmt|;
name|usbd_devinfo_vp
argument_list|(
name|dev
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s %s"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
name|showclass
condition|)
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" (class %d/%d)"
argument_list|,
name|udd
operator|->
name|bDeviceClass
argument_list|,
name|udd
operator|->
name|bDeviceSubClass
argument_list|)
expr_stmt|;
name|bcdUSB
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdUSB
argument_list|)
expr_stmt|;
name|bcdDevice
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdDevice
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" (rev "
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|usbd_printBCD
argument_list|(
name|cp
argument_list|,
name|bcdUSB
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|cp
operator|+=
name|usbd_printBCD
argument_list|(
name|cp
argument_list|,
name|bcdDevice
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|')'
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" addr %d"
argument_list|,
name|dev
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delay for a certain number of ms */
end_comment

begin_function
name|void
name|usbd_delay_ms
parameter_list|(
name|bus
parameter_list|,
name|ms
parameter_list|)
name|usbd_bus_handle
name|bus
decl_stmt|;
name|int
name|ms
decl_stmt|;
block|{
comment|/* Wait at least two clock ticks so we know the time has passed. */
if|if
condition|(
name|bus
operator|->
name|use_polling
condition|)
name|delay
argument_list|(
operator|(
name|ms
operator|+
literal|1
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
else|else
name|tsleep
argument_list|(
operator|&
name|ms
argument_list|,
name|PRIBIO
argument_list|,
literal|"usbdly"
argument_list|,
operator|(
name|ms
operator|*
name|hz
operator|+
literal|999
operator|)
operator|/
literal|1000
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_reset_port
parameter_list|(
name|dev
parameter_list|,
name|port
parameter_list|,
name|ps
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|port
decl_stmt|;
name|usb_port_status_t
modifier|*
name|ps
decl_stmt|;
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_OTHER
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_FEATURE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UHF_PORT_RESET
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"usbd_reset_port: port %d reset done, error=%d\n"
operator|,
name|port
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|n
operator|=
literal|10
expr_stmt|;
do|do
block|{
comment|/* Wait for device to recover from reset. */
name|usbd_delay_ms
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
name|USB_PORT_RESET_DELAY
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_get_port_status
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_reset_port: get status failed %d\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
name|UGETW
argument_list|(
name|ps
operator|->
name|wPortChange
argument_list|)
operator|&
name|UPS_C_PORT_RESET
operator|)
operator|==
literal|0
operator|&&
operator|--
name|n
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"usbd_reset_port: timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
name|r
operator|=
name|usbd_clear_port_feature
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|UHF_C_PORT_RESET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_reset_port: clear port feature failed %d\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|usb_interface_descriptor_t
modifier|*
name|usbd_find_idesc
parameter_list|(
name|cd
parameter_list|,
name|ino
parameter_list|,
name|ano
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|cd
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|ano
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|cd
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|UGETW
argument_list|(
name|cd
operator|->
name|wTotalLength
argument_list|)
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|d
decl_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|+=
name|d
operator|->
name|bLength
control|)
block|{
name|d
operator|=
operator|(
name|usb_interface_descriptor_t
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|d
operator|->
name|bLength
operator|<=
name|end
operator|&&
name|d
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|&&
name|d
operator|->
name|bInterfaceNumber
operator|==
name|ino
operator|&&
name|d
operator|->
name|bAlternateSetting
operator|==
name|ano
condition|)
return|return
operator|(
name|d
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_fill_iface_data
parameter_list|(
name|dev
parameter_list|,
name|ino
parameter_list|,
name|ano
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|ino
decl_stmt|;
name|int
name|ano
decl_stmt|;
block|{
name|usbd_interface_handle
name|ifc
init|=
operator|&
name|dev
operator|->
name|ifaces
index|[
name|ino
index|]
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ed
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|endpt
decl_stmt|,
name|nendpt
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usbd_fill_iface_data: ino=%d ano=%d\n"
operator|,
name|ino
operator|,
name|ano
operator|)
argument_list|)
expr_stmt|;
name|ifc
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|ifc
operator|->
name|state
operator|=
name|USBD_INTERFACE_ACTIVE
expr_stmt|;
name|ifc
operator|->
name|idesc
operator|=
name|usbd_find_idesc
argument_list|(
name|dev
operator|->
name|cdesc
argument_list|,
name|ino
argument_list|,
name|ano
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifc
operator|->
name|idesc
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|nendpt
operator|=
name|ifc
operator|->
name|idesc
operator|->
name|bNumEndpoints
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"usbd_fill_iface_data: found idesc n=%d\n"
operator|,
name|nendpt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nendpt
operator|!=
literal|0
condition|)
block|{
name|ifc
operator|->
name|endpoints
operator|=
name|malloc
argument_list|(
name|nendpt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_endpoint
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifc
operator|->
name|endpoints
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
else|else
name|ifc
operator|->
name|endpoints
operator|=
literal|0
expr_stmt|;
name|ifc
operator|->
name|priv
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ifc
operator|->
name|idesc
operator|+
name|ifc
operator|->
name|idesc
operator|->
name|bLength
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|cdesc
operator|+
name|UGETW
argument_list|(
name|dev
operator|->
name|cdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
for|for
control|(
name|endpt
operator|=
literal|0
init|;
name|endpt
operator|<
name|nendpt
condition|;
name|endpt
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"usbd_fill_iface_data: endpt=%d\n"
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|+=
name|ed
operator|->
name|bLength
control|)
block|{
name|ed
operator|=
operator|(
name|usb_endpoint_descriptor_t
operator|*
operator|)
name|p
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"usbd_fill_iface_data: p=%p end=%p len=%d type=%d\n"
operator|,
name|p
operator|,
name|end
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|ed
operator|->
name|bLength
operator|<=
name|end
operator|&&
name|ed
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|ed
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
condition|)
break|break;
block|}
name|r
operator|=
name|USBD_INVAL
expr_stmt|;
goto|goto
name|bad
goto|;
name|found
label|:
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|edesc
operator|=
name|ed
expr_stmt|;
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|state
operator|=
name|USBD_ENDPOINT_ACTIVE
expr_stmt|;
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|toggle
operator|=
literal|0
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|ifc
operator|->
name|pipes
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|ifc
operator|->
name|endpoints
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_free_iface_data
parameter_list|(
name|dev
parameter_list|,
name|ifcno
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|ifcno
decl_stmt|;
block|{
name|usbd_interface_handle
name|ifc
init|=
operator|&
name|dev
operator|->
name|ifaces
index|[
name|ifcno
index|]
decl_stmt|;
if|if
condition|(
name|ifc
operator|->
name|endpoints
condition|)
name|free
argument_list|(
name|ifc
operator|->
name|endpoints
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|usbd_set_config
parameter_list|(
name|dev
parameter_list|,
name|conf
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|conf
decl_stmt|;
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_CONFIG
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_set_config_no
parameter_list|(
name|dev
parameter_list|,
name|no
parameter_list|,
name|msg
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|no
decl_stmt|;
name|int
name|msg
decl_stmt|;
block|{
name|usb_status_t
name|ds
decl_stmt|;
name|usb_hub_status_t
name|hs
decl_stmt|;
name|usb_config_descriptor_t
name|cd
decl_stmt|,
modifier|*
name|cdp
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|ifcno
decl_stmt|,
name|nifc
decl_stmt|,
name|len
decl_stmt|,
name|selfpowered
decl_stmt|,
name|power
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usbd_set_config_no: dev=%p no=%d\n"
operator|,
name|dev
operator|,
name|no
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check that all interfaces are idle */
if|if
condition|(
name|dev
operator|->
name|config
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_no: free old config\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Free all configuration data structures. */
name|nifc
operator|=
name|dev
operator|->
name|cdesc
operator|->
name|bNumInterface
expr_stmt|;
for|for
control|(
name|ifcno
operator|=
literal|0
init|;
name|ifcno
operator|<
name|nifc
condition|;
name|ifcno
operator|++
control|)
name|usbd_free_iface_data
argument_list|(
name|dev
argument_list|,
name|ifcno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|ifaces
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|cdesc
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|dev
operator|->
name|ifaces
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|cdesc
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|config
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_ADDRESSED
expr_stmt|;
block|}
comment|/* Figure out what config number to use. */
name|r
operator|=
name|usbd_get_config_desc
argument_list|(
name|dev
argument_list|,
name|no
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|len
operator|=
name|UGETW
argument_list|(
name|cd
operator|.
name|wTotalLength
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|r
operator|=
name|usbd_get_desc
argument_list|(
name|dev
argument_list|,
name|UDESC_CONFIG
argument_list|,
name|no
argument_list|,
name|len
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|bad
goto|;
name|selfpowered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_SELF_POWERED
condition|)
block|{
comment|/* May be self powered. */
if|if
condition|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_BUS_POWERED
condition|)
block|{
comment|/* Must ask device. */
if|if
condition|(
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_HUB_POWER
condition|)
block|{
comment|/* Buggy hub, use hub descriptor. */
name|r
operator|=
name|usbd_get_hub_status
argument_list|(
name|dev
argument_list|,
operator|&
name|hs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|USBD_NORMAL_COMPLETION
operator|&&
operator|!
operator|(
name|UGETW
argument_list|(
name|hs
operator|.
name|wHubStatus
argument_list|)
operator|&
name|UHS_LOCAL_POWER
operator|)
condition|)
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|usbd_get_device_status
argument_list|(
name|dev
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|USBD_NORMAL_COMPLETION
operator|&&
operator|(
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
operator|&
name|UDS_SELF_POWERED
operator|)
condition|)
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_no: status=0x%04x, error=%d\n"
operator|,
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_no: (addr %d) attr=0x%02x, selfpowered=%d, power=%d, powerquirk=%x\n"
operator|,
name|dev
operator|->
name|address
operator|,
name|cdp
operator|->
name|bmAttributes
operator|,
name|selfpowered
operator|,
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
operator|,
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_HUB_POWER
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
operator|!
name|dev
operator|->
name|powersrc
condition|)
block|{
name|printf
argument_list|(
literal|"usbd_set_config_no: No power source?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
endif|#
directive|endif
name|power
operator|=
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|power
operator|>
name|dev
operator|->
name|powersrc
operator|->
name|power
condition|)
block|{
comment|/* XXX print nicer message. */
if|if
condition|(
name|msg
condition|)
name|DEVICE_ERROR
argument_list|(
name|dev
operator|->
name|bus
operator|->
name|bdev
argument_list|,
operator|(
literal|"device addr %d (config %d) exceeds power budget, %d mA> %d mA\n"
operator|,
name|dev
operator|->
name|address
operator|,
name|cdp
operator|->
name|bConfigurationValue
operator|,
name|power
operator|,
name|dev
operator|->
name|powersrc
operator|->
name|power
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|USBD_NO_POWER
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dev
operator|->
name|power
operator|=
name|power
expr_stmt|;
name|dev
operator|->
name|self_powered
operator|=
name|selfpowered
expr_stmt|;
name|r
operator|=
name|usbd_set_config
argument_list|(
name|dev
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_no: setting config=%d failed, error=%d\n"
operator|,
name|cdp
operator|->
name|bConfigurationValue
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_no: setting new config %d\n"
operator|,
name|cdp
operator|->
name|bConfigurationValue
operator|)
argument_list|)
expr_stmt|;
name|nifc
operator|=
name|cdp
operator|->
name|bNumInterface
expr_stmt|;
name|dev
operator|->
name|ifaces
operator|=
name|malloc
argument_list|(
name|nifc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|ifaces
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usbd_set_config_no: dev=%p cdesc=%p\n"
operator|,
name|dev
operator|,
name|cdp
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|cdesc
operator|=
name|cdp
expr_stmt|;
name|dev
operator|->
name|config
operator|=
name|cdp
operator|->
name|bConfigurationValue
expr_stmt|;
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_CONFIGURED
expr_stmt|;
for|for
control|(
name|ifcno
operator|=
literal|0
init|;
name|ifcno
operator|<
name|nifc
condition|;
name|ifcno
operator|++
control|)
block|{
name|r
operator|=
name|usbd_fill_iface_data
argument_list|(
name|dev
argument_list|,
name|ifcno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
while|while
condition|(
operator|--
name|ifcno
operator|>=
literal|0
condition|)
name|usbd_free_iface_data
argument_list|(
name|dev
argument_list|,
name|ifcno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|cdp
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX add function for alternate settings */
end_comment

begin_function
name|usbd_status
name|usbd_setup_pipe
parameter_list|(
name|dev
parameter_list|,
name|iface
parameter_list|,
name|ep
parameter_list|,
name|pipe
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|struct
name|usbd_endpoint
modifier|*
name|ep
decl_stmt|;
name|usbd_pipe_handle
modifier|*
name|pipe
decl_stmt|;
block|{
name|usbd_pipe_handle
name|p
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\n"
operator|,
name|dev
operator|,
name|iface
operator|,
name|ep
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|bus
operator|->
name|pipe_size
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|p
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|p
operator|->
name|iface
operator|=
name|iface
expr_stmt|;
name|p
operator|->
name|state
operator|=
name|USBD_PIPE_ACTIVE
expr_stmt|;
name|p
operator|->
name|endpoint
operator|=
name|ep
expr_stmt|;
name|ep
operator|->
name|refcnt
operator|++
expr_stmt|;
name|p
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|intrreqh
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|p
operator|->
name|queue
argument_list|)
expr_stmt|;
name|r
operator|=
name|dev
operator|->
name|bus
operator|->
name|open_pipe
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_setup_pipe: endpoint=%d failed, error=%d\n"
operator|,
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
operator|*
name|pipe
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort the device control pipe. */
end_comment

begin_function
name|void
name|usbd_kill_pipe
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|pipe
operator|->
name|methods
operator|->
name|close
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|endpoint
operator|->
name|refcnt
operator|--
expr_stmt|;
name|free
argument_list|(
name|pipe
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|usbd_getnewaddr
parameter_list|(
name|bus
parameter_list|)
name|usbd_bus_handle
name|bus
decl_stmt|;
block|{
name|int
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
literal|1
init|;
name|addr
operator|<
name|USB_MAX_DEVICES
condition|;
name|addr
operator|++
control|)
if|if
condition|(
name|bus
operator|->
name|devices
index|[
name|addr
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|addr
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NWH separated out the probe and attach code  */
end_comment

begin_function
specifier|static
name|usbd_status
name|usbd_probe_and_attach
parameter_list|(
name|parent
parameter_list|,
name|dev
parameter_list|)
name|bdevice
modifier|*
name|parent
decl_stmt|;
name|usbd_device_handle
name|dev
decl_stmt|;
block|{
name|struct
name|usb_attach_arg
name|uaa
decl_stmt|;
name|usb_device_descriptor_t
modifier|*
name|dd
init|=
operator|&
name|dev
operator|->
name|ddesc
decl_stmt|;
name|int
name|r
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|,
name|confi
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|dev
operator|->
name|bdev
operator|=
name|device_add_child
argument_list|(
operator|*
name|parent
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|bdev
condition|)
block|{
name|DEVICE_ERROR
argument_list|(
name|dev
operator|->
name|bus
operator|->
name|bdev
argument_list|,
operator|(
literal|"Device creation failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
endif|#
directive|endif
name|uaa
operator|.
name|device
operator|=
name|dev
expr_stmt|;
name|uaa
operator|.
name|iface
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|usegeneric
operator|=
literal|0
expr_stmt|;
comment|/* First try with device specific drivers. */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|config_found_sm
argument_list|(
name|parent
argument_list|,
operator|&
name|uaa
argument_list|,
name|usbd_print
argument_list|,
name|usbd_submatch
argument_list|)
operator|!=
literal|0
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|dev
operator|->
name|bdev
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: no device driver found\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Next try with interface drivers. */
for|for
control|(
name|confi
operator|=
literal|0
init|;
name|confi
operator|<
name|dd
operator|->
name|bNumConfigurations
condition|;
name|confi
operator|++
control|)
block|{
name|r
operator|=
name|usbd_set_config_no
argument_list|(
name|dev
argument_list|,
name|confi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DEVICE_ERROR
argument_list|(
operator|*
name|parent
argument_list|,
operator|(
literal|"set config failed, r=%d\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
for|for
control|(
name|found
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|cdesc
operator|->
name|bNumInterface
condition|;
name|i
operator|++
control|)
block|{
name|uaa
operator|.
name|iface
operator|=
operator|&
name|dev
operator|->
name|ifaces
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|config_found_sm
argument_list|(
name|parent
argument_list|,
operator|&
name|uaa
argument_list|,
name|usbd_print
argument_list|,
name|usbd_submatch
argument_list|)
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|dev
operator|->
name|bdev
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
comment|/* No interfaces were attach in any of the configurations. */
if|if
condition|(
name|dd
operator|->
name|bNumConfigurations
operator|>
literal|0
condition|)
name|usbd_set_config_no
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: no interface drivers found\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Finally try the generic driver. */
name|uaa
operator|.
name|iface
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|usegeneric
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|config_found_sm
argument_list|(
name|parent
argument_list|,
operator|&
name|uaa
argument_list|,
name|usbd_print
argument_list|,
name|usbd_submatch
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|device_probe_and_attach
argument_list|(
name|dev
operator|->
name|bdev
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
endif|#
directive|endif
comment|/* generic attach failed, but leave the device as it is 	 * we just did not find any drivers, that's all. the device is 	 * fully operational and not harming anyone 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: generic attach failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a new device has been put in the powered state,  * but not yet in the addressed state.  * Get initial descriptor, set the address, get full descriptor,  * and attach a driver.  */
end_comment

begin_function
name|usbd_status
name|usbd_new_device
parameter_list|(
name|parent
parameter_list|,
name|bus
parameter_list|,
name|depth
parameter_list|,
name|lowspeed
parameter_list|,
name|port
parameter_list|,
name|up
parameter_list|)
name|bdevice
modifier|*
name|parent
decl_stmt|;
name|usbd_bus_handle
name|bus
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|lowspeed
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|usbd_port
modifier|*
name|up
decl_stmt|;
block|{
name|usbd_device_handle
name|dev
decl_stmt|;
name|usb_device_descriptor_t
modifier|*
name|dd
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device bus=%p depth=%d lowspeed=%d\n"
operator|,
name|bus
operator|,
name|depth
operator|,
name|lowspeed
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|usbd_getnewaddr
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|DEVICE_ERROR
argument_list|(
name|bus
operator|->
name|bdev
argument_list|,
operator|(
literal|"No free USB addresses, new device ignored.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NO_ADDR
operator|)
return|;
block|}
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|memset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
comment|/* Set up default endpoint handle. */
name|dev
operator|->
name|def_ep
operator|.
name|edesc
operator|=
operator|&
name|dev
operator|->
name|def_ep_desc
expr_stmt|;
name|dev
operator|->
name|def_ep
operator|.
name|state
operator|=
name|USBD_ENDPOINT_ACTIVE
expr_stmt|;
name|dev
operator|->
name|def_ep
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|def_ep
operator|.
name|toggle
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* Set up default endpoint descriptor. */
name|dev
operator|->
name|def_ep_desc
operator|.
name|bLength
operator|=
name|USB_ENDPOINT_DESCRIPTOR_SIZE
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bEndpointAddress
operator|=
name|USB_CONTROL_ENDPOINT
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bmAttributes
operator|=
name|UE_CONTROL
expr_stmt|;
name|USETW
argument_list|(
name|dev
operator|->
name|def_ep_desc
operator|.
name|wMaxPacketSize
argument_list|,
name|USB_MAX_IPACKET
argument_list|)
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bInterval
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_DEFAULT
expr_stmt|;
name|dev
operator|->
name|quirks
operator|=
operator|&
name|usbd_no_quirk
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|USB_START_ADDR
expr_stmt|;
name|dev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|lowspeed
operator|=
name|lowspeed
operator|!=
literal|0
expr_stmt|;
name|dev
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|dev
operator|->
name|powersrc
operator|=
name|up
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|dev
operator|->
name|bdev
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* Establish the the default pipe. */
name|r
operator|=
name|usbd_setup_pipe
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|dev
operator|->
name|def_ep
argument_list|,
operator|&
name|dev
operator|->
name|default_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|up
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|dd
operator|=
operator|&
name|dev
operator|->
name|ddesc
expr_stmt|;
comment|/* Try a few times in case the device is slow (i.e. outside specs.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the first 8 bytes of the device descriptor. */
name|r
operator|=
name|usbd_get_desc
argument_list|(
name|dev
argument_list|,
name|UDESC_DEVICE
argument_list|,
literal|0
argument_list|,
name|USB_MAX_IPACKET
argument_list|,
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|USBD_NORMAL_COMPLETION
condition|)
break|break;
name|usbd_delay_ms
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
literal|200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_new_device: addr=%d, getting first desc failed\n"
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, subclass=%d, protocol=%d, maxpacket=%d, ls=%d\n"
operator|,
name|addr
operator|,
name|UGETW
argument_list|(
name|dd
operator|->
name|bcdUSB
argument_list|)
operator|,
name|dd
operator|->
name|bDeviceClass
operator|,
name|dd
operator|->
name|bDeviceSubClass
operator|,
name|dd
operator|->
name|bDeviceProtocol
operator|,
name|dd
operator|->
name|bMaxPacketSize
operator|,
name|dev
operator|->
name|lowspeed
operator|)
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|dev
operator|->
name|def_ep_desc
operator|.
name|wMaxPacketSize
argument_list|,
name|dd
operator|->
name|bMaxPacketSize
argument_list|)
expr_stmt|;
comment|/* Get the full device descriptor. */
name|r
operator|=
name|usbd_get_device_desc
argument_list|(
name|dev
argument_list|,
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_new_device: addr=%d, getting full desc failed\n"
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/* Figure out what's wrong with this device. */
name|dev
operator|->
name|quirks
operator|=
name|usbd_find_quirk
argument_list|(
name|dd
argument_list|)
expr_stmt|;
comment|/* Set the address */
name|r
operator|=
name|usbd_set_address
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_new_device: set address %d failed\n"
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
name|USBD_SET_ADDR_FAILED
return|;
block|}
name|dev
operator|->
name|address
operator|=
name|addr
expr_stmt|;
comment|/* New device address now */
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_ADDRESSED
expr_stmt|;
name|bus
operator|->
name|devices
index|[
name|addr
index|]
operator|=
name|dev
expr_stmt|;
comment|/* Assume 100mA bus powered for now. Changed when configured. */
name|dev
operator|->
name|power
operator|=
name|USB_MIN_POWER
expr_stmt|;
name|dev
operator|->
name|self_powered
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n"
operator|,
name|addr
operator|,
name|dev
operator|,
name|parent
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_probe_and_attach
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_remove_device
parameter_list|(
name|dev
parameter_list|,
name|up
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|struct
name|usbd_port
modifier|*
name|up
decl_stmt|;
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_remove_device: %p\n"
operator|,
name|dev
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* XXX bit of a hack, only for hubs the detach is called 	 * 	 * easiest solution, register a detach method in the softc, call that 	 * one and pass the device struct to it, or the softc. Whatever. 	 */
if|if
condition|(
name|dev
operator|->
name|bdev
operator|&&
name|dev
operator|->
name|hub
condition|)
name|uhub_detach
argument_list|(
name|dev
operator|->
name|hub
operator|->
name|hubdata
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|dev
operator|->
name|bdev
condition|)
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|dev
operator|->
name|bdev
argument_list|)
argument_list|,
name|dev
operator|->
name|bdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|->
name|default_pipe
condition|)
name|usbd_kill_pipe
argument_list|(
name|dev
operator|->
name|default_pipe
argument_list|)
expr_stmt|;
name|up
operator|->
name|device
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|bus
operator|->
name|devices
index|[
name|dev
operator|->
name|address
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|int
name|usbd_print
parameter_list|(
name|aux
parameter_list|,
name|pnp
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|pnp
decl_stmt|;
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|aux
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"usbd_print dev=%p\n"
operator|,
name|uaa
operator|->
name|device
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnp
condition|)
block|{
if|if
condition|(
operator|!
name|uaa
operator|->
name|usegeneric
condition|)
return|return
operator|(
name|QUIET
operator|)
return|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|1
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, %s"
argument_list|,
name|devinfo
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uaa
operator|->
name|port
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" port %d"
argument_list|,
name|uaa
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|configno
operator|!=
name|UHUB_UNK_CONFIGURATION
condition|)
name|printf
argument_list|(
literal|" configuration %d"
argument_list|,
name|uaa
operator|->
name|configno
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|ifaceno
operator|!=
name|UHUB_UNK_INTERFACE
condition|)
name|printf
argument_list|(
literal|" interface %d"
argument_list|,
name|uaa
operator|->
name|ifaceno
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNCONF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usbd_submatch
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|aux
decl_stmt|;
if|if
condition|(
operator|(
name|uaa
operator|->
name|port
operator|!=
literal|0
operator|&&
name|cf
operator|->
name|uhubcf_port
operator|!=
name|UHUB_UNK_PORT
operator|&&
name|cf
operator|->
name|uhubcf_port
operator|!=
name|uaa
operator|->
name|port
operator|)
operator|||
operator|(
name|uaa
operator|->
name|configno
operator|!=
name|UHUB_UNK_CONFIGURATION
operator|&&
name|cf
operator|->
name|uhubcf_configuration
operator|!=
name|UHUB_UNK_CONFIGURATION
operator|&&
name|cf
operator|->
name|uhubcf_configuration
operator|!=
name|uaa
operator|->
name|configno
operator|)
operator|||
operator|(
name|uaa
operator|->
name|ifaceno
operator|!=
name|UHUB_UNK_INTERFACE
operator|&&
name|cf
operator|->
name|uhubcf_interface
operator|!=
name|UHUB_UNK_INTERFACE
operator|&&
name|cf
operator|->
name|uhubcf_interface
operator|!=
name|uaa
operator|->
name|ifaceno
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
call|(
modifier|*
name|cf
operator|->
name|cf_attach
operator|->
name|ca_match
call|)
argument_list|(
name|parent
argument_list|,
name|cf
argument_list|,
name|aux
argument_list|)
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_function
specifier|static
name|void
name|usbd_bus_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
comment|/* FIXME print the device address and the configuration used 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

