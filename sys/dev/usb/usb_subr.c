begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: usb_subr.c,v 1.29 1999/03/18 12:08:43 augustss Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (augustss@carlstedt.se) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|d
parameter_list|)
value|DELAY(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (usbdebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (usbdebug>(n)) logprintf x
end_define

begin_decl_stmt
specifier|extern
name|int
name|usbdebug
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|usbd_status
name|usbd_set_config
name|__P
argument_list|(
operator|(
name|usbd_device_handle
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|usbd_get_string
name|__P
argument_list|(
operator|(
name|usbd_device_handle
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usbd_getnewaddr
name|__P
argument_list|(
operator|(
name|usbd_bus_handle
name|bus
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_decl_stmt
name|int
name|usbd_print
name|__P
argument_list|(
operator|(
name|void
operator|*
name|aux
operator|,
specifier|const
name|char
operator|*
name|pnp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usbd_submatch
name|__P
argument_list|(
operator|(
name|bdevice
operator|*
operator|,
expr|struct
name|cfdata
operator|*
name|cf
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|usbd_free_iface_data
name|__P
argument_list|(
operator|(
name|usbd_device_handle
name|dev
operator|,
name|int
name|ifcno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usbd_kill_pipe
name|__P
argument_list|(
operator|(
name|usbd_pipe_handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|usbd_status
name|usbd_probe_and_attach
name|__P
argument_list|(
operator|(
name|bdevice
operator|*
name|parent
operator|,
name|usbd_device_handle
name|dev
operator|,
name|int
name|port
operator|,
name|int
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|usbd_status
name|usbd_get_string_desc
parameter_list|(
name|dev
parameter_list|,
name|sindex
parameter_list|,
name|langid
parameter_list|,
name|sdesc
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|sindex
decl_stmt|;
name|int
name|langid
decl_stmt|;
name|usb_string_descriptor_t
modifier|*
name|sdesc
decl_stmt|;
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_GET_DESCRIPTOR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UDESC_STRING
argument_list|,
name|sindex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|langid
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* only size byte first */
name|r
operator|=
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
name|sdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|sdesc
operator|->
name|bLength
argument_list|)
expr_stmt|;
comment|/* the whole string */
return|return
operator|(
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
name|sdesc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|usbd_get_string
parameter_list|(
name|dev
parameter_list|,
name|si
parameter_list|,
name|buf
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|si
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|swap
init|=
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_SWAP_UNICODE
decl_stmt|;
name|usb_string_descriptor_t
name|us
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_int16_t
name|c
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
if|if
condition|(
name|si
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_NO_STRINGS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dev
operator|->
name|langid
operator|==
name|USBD_NOLANG
condition|)
block|{
comment|/* Set up default language */
name|r
operator|=
name|usbd_get_string_desc
argument_list|(
name|dev
argument_list|,
name|USB_LANGUAGE_TABLE
argument_list|,
literal|0
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
operator|||
name|us
operator|.
name|bLength
operator|<
literal|4
condition|)
block|{
name|dev
operator|->
name|langid
operator|=
literal|0
expr_stmt|;
comment|/* Well, just pick English then */
block|}
else|else
block|{
comment|/* Pick the first language as the default. */
name|dev
operator|->
name|langid
operator|=
name|UGETW
argument_list|(
name|us
operator|.
name|bString
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|=
name|usbd_get_string_desc
argument_list|(
name|dev
argument_list|,
name|si
argument_list|,
name|dev
operator|->
name|langid
argument_list|,
operator|&
name|us
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|buf
expr_stmt|;
name|n
operator|=
name|us
operator|.
name|bLength
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|UGETW
argument_list|(
name|us
operator|.
name|bString
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Convert from Unicode, handle buggy strings. */
if|if
condition|(
operator|(
name|c
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0x00ff
operator|)
operator|==
literal|0
operator|&&
name|swap
condition|)
operator|*
name|s
operator|++
operator|=
name|c
operator|>>
literal|8
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|usbd_devinfo_vp
parameter_list|(
name|dev
parameter_list|,
name|v
parameter_list|,
name|p
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
name|usb_device_descriptor_t
modifier|*
name|udd
init|=
operator|&
name|dev
operator|->
name|ddesc
decl_stmt|;
name|char
modifier|*
name|vendor
init|=
literal|0
decl_stmt|,
modifier|*
name|product
init|=
literal|0
decl_stmt|;
name|vendor
operator|=
name|usbd_get_string
argument_list|(
name|dev
argument_list|,
name|udd
operator|->
name|iManufacturer
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|product
operator|=
name|usbd_get_string
argument_list|(
name|dev
argument_list|,
name|udd
operator|->
name|iProduct
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
condition|)
name|strcpy
argument_list|(
name|v
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|v
argument_list|,
literal|"vendor 0x%04x"
argument_list|,
name|UGETW
argument_list|(
name|udd
operator|->
name|idVendor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|product
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|product
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"product 0x%04x"
argument_list|,
name|UGETW
argument_list|(
name|udd
operator|->
name|idProduct
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|usbd_printBCD
parameter_list|(
name|cp
parameter_list|,
name|bcd
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|bcd
decl_stmt|;
block|{
return|return
operator|(
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%x.%02x"
argument_list|,
name|bcd
operator|>>
literal|8
argument_list|,
name|bcd
operator|&
literal|0xff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_devinfo
parameter_list|(
name|dev
parameter_list|,
name|showclass
parameter_list|,
name|cp
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|showclass
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|usb_device_descriptor_t
modifier|*
name|udd
init|=
operator|&
name|dev
operator|->
name|ddesc
decl_stmt|;
name|char
name|vendor
index|[
name|USB_MAX_STRING_LEN
index|]
decl_stmt|;
name|char
name|product
index|[
name|USB_MAX_STRING_LEN
index|]
decl_stmt|;
name|int
name|bcdDevice
decl_stmt|,
name|bcdUSB
decl_stmt|;
name|usbd_devinfo_vp
argument_list|(
name|dev
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s %s"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
name|showclass
condition|)
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|", class %d/%d"
argument_list|,
name|udd
operator|->
name|bDeviceClass
argument_list|,
name|udd
operator|->
name|bDeviceSubClass
argument_list|)
expr_stmt|;
name|bcdUSB
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdUSB
argument_list|)
expr_stmt|;
name|bcdDevice
operator|=
name|UGETW
argument_list|(
name|udd
operator|->
name|bcdDevice
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|", rev "
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|usbd_printBCD
argument_list|(
name|cp
argument_list|,
name|bcdUSB
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|cp
operator|+=
name|usbd_printBCD
argument_list|(
name|cp
argument_list|,
name|bcdDevice
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|", addr %d"
argument_list|,
name|dev
operator|->
name|address
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delay for a certain number of ms */
end_comment

begin_function
name|void
name|usb_delay_ms
parameter_list|(
name|bus
parameter_list|,
name|ms
parameter_list|)
name|usbd_bus_handle
name|bus
decl_stmt|;
name|u_int
name|ms
decl_stmt|;
block|{
comment|/* Wait at least two clock ticks so we know the time has passed. */
if|if
condition|(
name|bus
operator|->
name|use_polling
condition|)
name|delay
argument_list|(
operator|(
name|ms
operator|+
literal|1
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
else|else
name|tsleep
argument_list|(
operator|&
name|ms
argument_list|,
name|PRIBIO
argument_list|,
literal|"usbdly"
argument_list|,
operator|(
name|ms
operator|*
name|hz
operator|+
literal|999
operator|)
operator|/
literal|1000
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delay given a device handle. */
end_comment

begin_function
name|void
name|usbd_delay_ms
parameter_list|(
name|dev
parameter_list|,
name|ms
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|u_int
name|ms
decl_stmt|;
block|{
name|usb_delay_ms
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_reset_port
parameter_list|(
name|dev
parameter_list|,
name|port
parameter_list|,
name|ps
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|port
decl_stmt|;
name|usb_port_status_t
modifier|*
name|ps
decl_stmt|;
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_OTHER
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_FEATURE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UHF_PORT_RESET
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"usbd_reset_port: port %d reset done, %s\n"
operator|,
name|port
operator|,
name|usbd_errstr
argument_list|(
name|r
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|n
operator|=
literal|10
expr_stmt|;
do|do
block|{
comment|/* Wait for device to recover from reset. */
name|usbd_delay_ms
argument_list|(
name|dev
argument_list|,
name|USB_PORT_RESET_DELAY
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_get_port_status
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_reset_port: get port %d status failed %s\n"
operator|,
name|port
operator|,
name|usbd_errstr
argument_list|(
name|r
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
name|UGETW
argument_list|(
name|ps
operator|->
name|wPortChange
argument_list|)
operator|&
name|UPS_C_PORT_RESET
operator|)
operator|==
literal|0
operator|&&
operator|--
name|n
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"usbd_reset_port: timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
name|r
operator|=
name|usbd_clear_port_feature
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|UHF_C_PORT_RESET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_reset_port: clear port %d feature failed %d\n"
operator|,
name|port
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Wait for the device to recover from reset. */
name|usbd_delay_ms
argument_list|(
name|dev
argument_list|,
name|USB_PORT_RESET_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|usb_interface_descriptor_t
modifier|*
name|usbd_find_idesc
parameter_list|(
name|cd
parameter_list|,
name|ifaceidx
parameter_list|,
name|altidx
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|cd
decl_stmt|;
name|int
name|ifaceidx
decl_stmt|;
name|int
name|altidx
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|cd
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|UGETW
argument_list|(
name|cd
operator|->
name|wTotalLength
argument_list|)
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|d
decl_stmt|;
name|int
name|curidx
decl_stmt|,
name|lastidx
decl_stmt|,
name|curaidx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|curidx
operator|=
name|lastidx
operator|=
operator|-
literal|1
init|;
name|p
operator|<
name|end
condition|;
control|)
block|{
name|d
operator|=
operator|(
name|usb_interface_descriptor_t
operator|*
operator|)
name|p
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"usbd_find_idesc: idx=%d(%d) altidx=%d(%d) len=%d "
literal|"type=%d\n"
operator|,
name|ifaceidx
operator|,
name|curidx
operator|,
name|altidx
operator|,
name|curaidx
operator|,
name|d
operator|->
name|bLength
operator|,
name|d
operator|->
name|bDescriptorType
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bLength
operator|==
literal|0
condition|)
comment|/* bad descriptor */
break|break;
name|p
operator|+=
name|d
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|p
operator|<=
name|end
operator|&&
name|d
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bInterfaceNumber
operator|!=
name|lastidx
condition|)
block|{
name|lastidx
operator|=
name|d
operator|->
name|bInterfaceNumber
expr_stmt|;
name|curidx
operator|++
expr_stmt|;
name|curaidx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|curaidx
operator|++
expr_stmt|;
if|if
condition|(
name|ifaceidx
operator|==
name|curidx
operator|&&
name|altidx
operator|==
name|curaidx
condition|)
return|return
operator|(
name|d
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|usb_endpoint_descriptor_t
modifier|*
name|usbd_find_edesc
parameter_list|(
name|cd
parameter_list|,
name|ifaceidx
parameter_list|,
name|altidx
parameter_list|,
name|endptidx
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|cd
decl_stmt|;
name|int
name|ifaceidx
decl_stmt|;
name|int
name|altidx
decl_stmt|;
name|int
name|endptidx
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|cd
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|UGETW
argument_list|(
name|cd
operator|->
name|wTotalLength
argument_list|)
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|d
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|e
decl_stmt|;
name|int
name|curidx
decl_stmt|;
name|d
operator|=
name|usbd_find_idesc
argument_list|(
name|cd
argument_list|,
name|ifaceidx
argument_list|,
name|altidx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|endptidx
operator|>=
name|d
operator|->
name|bNumEndpoints
condition|)
comment|/* quick exit */
return|return
operator|(
literal|0
operator|)
return|;
name|curidx
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|d
operator|->
name|bLength
init|;
name|p
operator|<
name|end
condition|;
control|)
block|{
name|e
operator|=
operator|(
name|usb_endpoint_descriptor_t
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|bLength
operator|==
literal|0
condition|)
comment|/* bad descriptor */
break|break;
name|p
operator|+=
name|e
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|p
operator|<=
name|end
operator|&&
name|e
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|<=
name|end
operator|&&
name|e
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
condition|)
block|{
name|curidx
operator|++
expr_stmt|;
if|if
condition|(
name|curidx
operator|==
name|endptidx
condition|)
return|return
operator|(
name|e
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_fill_iface_data
parameter_list|(
name|dev
parameter_list|,
name|ifaceidx
parameter_list|,
name|altidx
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|ifaceidx
decl_stmt|;
name|int
name|altidx
decl_stmt|;
block|{
name|usbd_interface_handle
name|ifc
init|=
operator|&
name|dev
operator|->
name|ifaces
index|[
name|ifaceidx
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|endpt
decl_stmt|,
name|nendpt
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"usbd_fill_iface_data: ifaceidx=%d altidx=%d\n"
operator|,
name|ifaceidx
operator|,
name|altidx
operator|)
argument_list|)
expr_stmt|;
name|ifc
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|ifc
operator|->
name|idesc
operator|=
name|usbd_find_idesc
argument_list|(
name|dev
operator|->
name|cdesc
argument_list|,
name|ifaceidx
argument_list|,
name|altidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifc
operator|->
name|idesc
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|ifc
operator|->
name|index
operator|=
name|ifaceidx
expr_stmt|;
name|ifc
operator|->
name|altindex
operator|=
name|altidx
expr_stmt|;
name|nendpt
operator|=
name|ifc
operator|->
name|idesc
operator|->
name|bNumEndpoints
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"usbd_fill_iface_data: found idesc n=%d\n"
operator|,
name|nendpt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nendpt
operator|!=
literal|0
condition|)
block|{
name|ifc
operator|->
name|endpoints
operator|=
name|malloc
argument_list|(
name|nendpt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_endpoint
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifc
operator|->
name|endpoints
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
else|else
name|ifc
operator|->
name|endpoints
operator|=
literal|0
expr_stmt|;
name|ifc
operator|->
name|priv
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ifc
operator|->
name|idesc
operator|+
name|ifc
operator|->
name|idesc
operator|->
name|bLength
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|cdesc
operator|+
name|UGETW
argument_list|(
name|dev
operator|->
name|cdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
define|#
directive|define
name|ed
value|((usb_endpoint_descriptor_t *)p)
for|for
control|(
name|endpt
operator|=
literal|0
init|;
name|endpt
operator|<
name|nendpt
condition|;
name|endpt
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"usbd_fill_iface_data: endpt=%d\n"
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|+=
name|ed
operator|->
name|bLength
control|)
block|{
name|ed
operator|=
operator|(
name|usb_endpoint_descriptor_t
operator|*
operator|)
name|p
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
operator|(
literal|"usbd_fill_iface_data: p=%p end=%p "
literal|"len=%d type=%d\n"
operator|,
name|p
operator|,
name|end
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|ed
operator|->
name|bLength
operator|<=
name|end
operator|&&
name|ed
operator|->
name|bLength
operator|!=
literal|0
operator|&&
name|ed
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|ed
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|||
name|ed
operator|->
name|bLength
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* passed end, or bad desc */
goto|goto
name|bad
goto|;
name|found
label|:
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|edesc
operator|=
name|ed
expr_stmt|;
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|state
operator|=
name|USBD_ENDPOINT_ACTIVE
expr_stmt|;
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
name|ifc
operator|->
name|endpoints
index|[
name|endpt
index|]
operator|.
name|toggle
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
name|ed
operator|->
name|bLength
expr_stmt|;
block|}
undef|#
directive|undef
name|ed
name|LIST_INIT
argument_list|(
operator|&
name|ifc
operator|->
name|pipes
argument_list|)
expr_stmt|;
name|ifc
operator|->
name|state
operator|=
name|USBD_INTERFACE_ACTIVE
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|ifc
operator|->
name|endpoints
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_free_iface_data
parameter_list|(
name|dev
parameter_list|,
name|ifcno
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|ifcno
decl_stmt|;
block|{
name|usbd_interface_handle
name|ifc
init|=
operator|&
name|dev
operator|->
name|ifaces
index|[
name|ifcno
index|]
decl_stmt|;
if|if
condition|(
name|ifc
operator|->
name|endpoints
condition|)
name|free
argument_list|(
name|ifc
operator|->
name|endpoints
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|usbd_set_config
parameter_list|(
name|dev
parameter_list|,
name|conf
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|conf
decl_stmt|;
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_SET_CONFIG
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|usbd_do_request
argument_list|(
name|dev
argument_list|,
operator|&
name|req
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_set_config_no
parameter_list|(
name|dev
parameter_list|,
name|no
parameter_list|,
name|msg
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|no
decl_stmt|;
name|int
name|msg
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
name|usb_config_descriptor_t
name|cd
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usbd_set_config_no: %d\n"
operator|,
name|no
operator|)
argument_list|)
expr_stmt|;
comment|/* Figure out what config index to use. */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|dev
operator|->
name|ddesc
operator|.
name|bNumConfigurations
condition|;
name|index
operator|++
control|)
block|{
name|r
operator|=
name|usbd_get_config_desc
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|cd
operator|.
name|bConfigurationValue
operator|==
name|no
condition|)
return|return
operator|(
name|usbd_set_config_index
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_set_config_index
parameter_list|(
name|dev
parameter_list|,
name|index
parameter_list|,
name|msg
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|msg
decl_stmt|;
block|{
name|usb_status_t
name|ds
decl_stmt|;
name|usb_hub_status_t
name|hs
decl_stmt|;
name|usb_config_descriptor_t
name|cd
decl_stmt|,
modifier|*
name|cdp
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|ifcidx
decl_stmt|,
name|nifc
decl_stmt|,
name|len
decl_stmt|,
name|selfpowered
decl_stmt|,
name|power
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usbd_set_config_index: dev=%p index=%d\n"
operator|,
name|dev
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check that all interfaces are idle */
if|if
condition|(
name|dev
operator|->
name|config
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_index: free old config\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Free all configuration data structures. */
name|nifc
operator|=
name|dev
operator|->
name|cdesc
operator|->
name|bNumInterface
expr_stmt|;
for|for
control|(
name|ifcidx
operator|=
literal|0
init|;
name|ifcidx
operator|<
name|nifc
condition|;
name|ifcidx
operator|++
control|)
name|usbd_free_iface_data
argument_list|(
name|dev
argument_list|,
name|ifcidx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|ifaces
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|cdesc
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
name|dev
operator|->
name|ifaces
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|cdesc
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|config
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_ADDRESSED
expr_stmt|;
block|}
comment|/* Figure out what config number to use. */
name|r
operator|=
name|usbd_get_config_desc
argument_list|(
name|dev
argument_list|,
name|index
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|len
operator|=
name|UGETW
argument_list|(
name|cd
operator|.
name|wTotalLength
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|r
operator|=
name|usbd_get_desc
argument_list|(
name|dev
argument_list|,
name|UDESC_CONFIG
argument_list|,
name|index
argument_list|,
name|len
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|cdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CONFIG
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_set_config_index: bad desc %d\n"
operator|,
name|cdp
operator|->
name|bDescriptorType
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|USBD_INVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|selfpowered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_SELF_POWERED
condition|)
block|{
comment|/* May be self powered. */
if|if
condition|(
name|cdp
operator|->
name|bmAttributes
operator|&
name|UC_BUS_POWERED
condition|)
block|{
comment|/* Must ask device. */
if|if
condition|(
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_HUB_POWER
condition|)
block|{
comment|/* Buggy hub, use hub descriptor. */
name|r
operator|=
name|usbd_get_hub_status
argument_list|(
name|dev
argument_list|,
operator|&
name|hs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|USBD_NORMAL_COMPLETION
operator|&&
operator|!
operator|(
name|UGETW
argument_list|(
name|hs
operator|.
name|wHubStatus
argument_list|)
operator|&
name|UHS_LOCAL_POWER
operator|)
condition|)
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|usbd_get_device_status
argument_list|(
name|dev
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|USBD_NORMAL_COMPLETION
operator|&&
operator|(
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
operator|&
name|UDS_SELF_POWERED
operator|)
condition|)
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_index: status=0x%04x, %s\n"
operator|,
name|UGETW
argument_list|(
name|ds
operator|.
name|wStatus
argument_list|)
operator|,
name|usbd_errstr
argument_list|(
name|r
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|selfpowered
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_index: (addr %d) attr=0x%02x, "
literal|"selfpowered=%d, power=%d, powerquirk=%x\n"
operator|,
name|dev
operator|->
name|address
operator|,
name|cdp
operator|->
name|bmAttributes
operator|,
name|selfpowered
operator|,
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
operator|,
name|dev
operator|->
name|quirks
operator|->
name|uq_flags
operator|&
name|UQ_HUB_POWER
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
operator|!
name|dev
operator|->
name|powersrc
condition|)
block|{
name|printf
argument_list|(
literal|"usbd_set_config_index: No power source?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_IOERROR
operator|)
return|;
block|}
endif|#
directive|endif
name|power
operator|=
name|cdp
operator|->
name|bMaxPower
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|power
operator|>
name|dev
operator|->
name|powersrc
operator|->
name|power
condition|)
block|{
comment|/* XXX print nicer message. */
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s: device addr %d (config %d) exceeds power "
literal|"budget, %d mA> %d mA\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|dev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|,
name|dev
operator|->
name|address
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|,
name|power
argument_list|,
name|dev
operator|->
name|powersrc
operator|->
name|power
argument_list|)
expr_stmt|;
name|r
operator|=
name|USBD_NO_POWER
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dev
operator|->
name|power
operator|=
name|power
expr_stmt|;
name|dev
operator|->
name|self_powered
operator|=
name|selfpowered
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_index: set config %d\n"
operator|,
name|cdp
operator|->
name|bConfigurationValue
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_set_config
argument_list|(
name|dev
argument_list|,
name|cdp
operator|->
name|bConfigurationValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_index: setting config=%d failed, %s\n"
operator|,
name|cdp
operator|->
name|bConfigurationValue
operator|,
name|usbd_errstr
argument_list|(
name|r
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_set_config_index: setting new config %d\n"
operator|,
name|cdp
operator|->
name|bConfigurationValue
operator|)
argument_list|)
expr_stmt|;
name|nifc
operator|=
name|cdp
operator|->
name|bNumInterface
expr_stmt|;
name|dev
operator|->
name|ifaces
operator|=
name|malloc
argument_list|(
name|nifc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface
argument_list|)
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|ifaces
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|USBD_NOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usbd_set_config_index: dev=%p cdesc=%p\n"
operator|,
name|dev
operator|,
name|cdp
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|cdesc
operator|=
name|cdp
expr_stmt|;
name|dev
operator|->
name|config
operator|=
name|cdp
operator|->
name|bConfigurationValue
expr_stmt|;
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_CONFIGURED
expr_stmt|;
for|for
control|(
name|ifcidx
operator|=
literal|0
init|;
name|ifcidx
operator|<
name|nifc
condition|;
name|ifcidx
operator|++
control|)
block|{
name|r
operator|=
name|usbd_fill_iface_data
argument_list|(
name|dev
argument_list|,
name|ifcidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
while|while
condition|(
operator|--
name|ifcidx
operator|>=
literal|0
condition|)
name|usbd_free_iface_data
argument_list|(
name|dev
argument_list|,
name|ifcidx
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|cdp
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX add function for alternate settings */
end_comment

begin_function
name|usbd_status
name|usbd_setup_pipe
parameter_list|(
name|dev
parameter_list|,
name|iface
parameter_list|,
name|ep
parameter_list|,
name|pipe
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|struct
name|usbd_endpoint
modifier|*
name|ep
decl_stmt|;
name|usbd_pipe_handle
modifier|*
name|pipe
decl_stmt|;
block|{
name|usbd_pipe_handle
name|p
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\n"
operator|,
name|dev
operator|,
name|iface
operator|,
name|ep
operator|,
name|pipe
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|bus
operator|->
name|pipe_size
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|p
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|p
operator|->
name|iface
operator|=
name|iface
expr_stmt|;
name|p
operator|->
name|state
operator|=
name|USBD_PIPE_ACTIVE
expr_stmt|;
name|p
operator|->
name|endpoint
operator|=
name|ep
expr_stmt|;
name|ep
operator|->
name|refcnt
operator|++
expr_stmt|;
name|p
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|intrreqh
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|disco
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|discoarg
operator|=
literal|0
expr_stmt|;
name|SIMPLEQ_INIT
argument_list|(
operator|&
name|p
operator|->
name|queue
argument_list|)
expr_stmt|;
name|r
operator|=
name|dev
operator|->
name|bus
operator|->
name|open_pipe
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_setup_pipe: endpoint=0x%x failed, %s\n"
operator|,
name|ep
operator|->
name|edesc
operator|->
name|bEndpointAddress
operator|,
name|usbd_errstr
argument_list|(
name|r
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
operator|*
name|pipe
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Abort the device control pipe. */
end_comment

begin_function
name|void
name|usbd_kill_pipe
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|pipe
operator|->
name|methods
operator|->
name|close
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|endpoint
operator|->
name|refcnt
operator|--
expr_stmt|;
name|free
argument_list|(
name|pipe
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|usbd_getnewaddr
parameter_list|(
name|bus
parameter_list|)
name|usbd_bus_handle
name|bus
decl_stmt|;
block|{
name|int
name|addr
decl_stmt|;
for|for
control|(
name|addr
operator|=
literal|1
init|;
name|addr
operator|<
name|USB_MAX_DEVICES
condition|;
name|addr
operator|++
control|)
if|if
condition|(
name|bus
operator|->
name|devices
index|[
name|addr
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|addr
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|usbd_probe_and_attach
parameter_list|(
name|parent
parameter_list|,
name|dev
parameter_list|,
name|port
parameter_list|,
name|addr
parameter_list|)
name|bdevice
modifier|*
name|parent
decl_stmt|;
name|usbd_device_handle
name|dev
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|addr
decl_stmt|;
block|{
name|struct
name|usb_attach_arg
name|uaa
decl_stmt|;
name|usb_device_descriptor_t
modifier|*
name|dd
init|=
operator|&
name|dev
operator|->
name|ddesc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
name|found
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|r
decl_stmt|,
name|i
decl_stmt|,
name|confi
decl_stmt|,
name|nifaces
decl_stmt|;
name|usbd_interface_handle
name|ifaces
index|[
literal|256
index|]
decl_stmt|;
comment|/* 256 is the absolute max */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXX uaa is a static var. Not a problem as it _should_ be used only  * during probe and attach. Should be changed however  */
name|bdevice
name|bdev
decl_stmt|;
name|bdev
operator|=
name|device_add_child
argument_list|(
operator|*
name|parent
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|uaa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bdev
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Device creation failed\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|dev
operator|->
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|uaa
operator|.
name|device
operator|=
name|dev
expr_stmt|;
name|uaa
operator|.
name|iface
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|ifaces
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|nifaces
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|usegeneric
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|uaa
operator|.
name|configno
operator|=
name|UHUB_UNK_CONFIGURATION
expr_stmt|;
name|uaa
operator|.
name|ifaceno
operator|=
name|UHUB_UNK_INTERFACE
expr_stmt|;
comment|/* First try with device specific drivers. */
if|if
condition|(
name|USB_DO_ATTACH
argument_list|(
name|dev
argument_list|,
name|bdev
argument_list|,
name|parent
argument_list|,
operator|&
name|uaa
argument_list|,
name|usbd_print
argument_list|,
name|usbd_submatch
argument_list|)
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_probe_and_attach: no device specific driver found\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Next try with interface drivers. */
for|for
control|(
name|confi
operator|=
literal|0
init|;
name|confi
operator|<
name|dd
operator|->
name|bNumConfigurations
condition|;
name|confi
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"usbd_probe_and_attach: trying config idx=%d\n"
operator|,
name|confi
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_set_config_index
argument_list|(
name|dev
argument_list|,
name|confi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|printf
argument_list|(
literal|"%s: port %d, set config at addr %d failed, %s\n"
argument_list|,
name|USBDEVNAME
argument_list|(
operator|*
name|parent
argument_list|)
argument_list|,
name|port
argument_list|,
name|addr
argument_list|,
name|usbd_errstr
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|nifaces
operator|=
name|dev
operator|->
name|cdesc
operator|->
name|bNumInterface
expr_stmt|;
name|uaa
operator|.
name|configno
operator|=
name|dev
operator|->
name|cdesc
operator|->
name|bConfigurationValue
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nifaces
condition|;
name|i
operator|++
control|)
name|ifaces
index|[
name|i
index|]
operator|=
operator|&
name|dev
operator|->
name|ifaces
index|[
name|i
index|]
expr_stmt|;
name|uaa
operator|.
name|ifaces
operator|=
name|ifaces
expr_stmt|;
name|uaa
operator|.
name|nifaces
operator|=
name|nifaces
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nifaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ifaces
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* interface already claimed */
name|uaa
operator|.
name|iface
operator|=
name|ifaces
index|[
name|i
index|]
expr_stmt|;
name|uaa
operator|.
name|ifaceno
operator|=
name|ifaces
index|[
name|i
index|]
operator|->
name|idesc
operator|->
name|bInterfaceNumber
expr_stmt|;
if|if
condition|(
name|USB_DO_ATTACH
argument_list|(
name|dev
argument_list|,
name|bdev
argument_list|,
name|parent
argument_list|,
operator|&
name|uaa
argument_list|,
name|usbd_print
argument_list|,
name|usbd_submatch
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|found
operator|++
expr_stmt|;
name|ifaces
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* consumed */
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXX FreeBSD can't handle multiple intfaces 				 *     on 1 device yet */
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* No interfaces were attached in any of the configurations. */
if|if
condition|(
name|dd
operator|->
name|bNumConfigurations
operator|>
literal|1
condition|)
comment|/* don't change if only 1 config */
name|usbd_set_config_index
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_probe_and_attach: no interface drivers found\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Finally try the generic driver. */
name|uaa
operator|.
name|iface
operator|=
literal|0
expr_stmt|;
name|uaa
operator|.
name|usegeneric
operator|=
literal|1
expr_stmt|;
name|uaa
operator|.
name|configno
operator|=
name|UHUB_UNK_CONFIGURATION
expr_stmt|;
name|uaa
operator|.
name|ifaceno
operator|=
name|UHUB_UNK_INTERFACE
expr_stmt|;
if|if
condition|(
name|USB_DO_ATTACH
argument_list|(
name|dev
argument_list|,
name|bdev
argument_list|,
name|parent
argument_list|,
operator|&
name|uaa
argument_list|,
name|usbd_print
argument_list|,
name|usbd_submatch
argument_list|)
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
comment|/*  	 * The generic attach failed, but leave the device as it is. 	 * We just did not find any drivers, that's all.  The device is 	 * fully operational and not harming anyone. 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_probe_and_attach: generic attach failed\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/*  * XXX should we delete the child again? Left for now to avoid dangling  * references. 	device_delete_child(*parent, bdev); */
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a new device has been put in the powered state,  * but not yet in the addressed state.  * Get initial descriptor, set the address, get full descriptor,  * and attach a driver.  */
end_comment

begin_function
name|usbd_status
name|usbd_new_device
parameter_list|(
name|parent
parameter_list|,
name|bus
parameter_list|,
name|depth
parameter_list|,
name|lowspeed
parameter_list|,
name|port
parameter_list|,
name|up
parameter_list|)
name|bdevice
modifier|*
name|parent
decl_stmt|;
name|usbd_bus_handle
name|bus
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|lowspeed
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|usbd_port
modifier|*
name|up
decl_stmt|;
block|{
name|usbd_device_handle
name|dev
decl_stmt|;
name|usb_device_descriptor_t
modifier|*
name|dd
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device bus=%p depth=%d lowspeed=%d\n"
operator|,
name|bus
operator|,
name|depth
operator|,
name|lowspeed
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|usbd_getnewaddr
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: No free USB addresses, new device ignored.\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|bus
operator|->
name|bdev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NO_ADDR
operator|)
return|;
block|}
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|,
name|M_USB
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
literal|0
condition|)
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
name|memset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|bus
operator|=
name|bus
expr_stmt|;
comment|/* Set up default endpoint handle. */
name|dev
operator|->
name|def_ep
operator|.
name|edesc
operator|=
operator|&
name|dev
operator|->
name|def_ep_desc
expr_stmt|;
name|dev
operator|->
name|def_ep
operator|.
name|state
operator|=
name|USBD_ENDPOINT_ACTIVE
expr_stmt|;
comment|/* Set up default endpoint descriptor. */
name|dev
operator|->
name|def_ep_desc
operator|.
name|bLength
operator|=
name|USB_ENDPOINT_DESCRIPTOR_SIZE
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bEndpointAddress
operator|=
name|USB_CONTROL_ENDPOINT
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bmAttributes
operator|=
name|UE_CONTROL
expr_stmt|;
name|USETW
argument_list|(
name|dev
operator|->
name|def_ep_desc
operator|.
name|wMaxPacketSize
argument_list|,
name|USB_MAX_IPACKET
argument_list|)
expr_stmt|;
name|dev
operator|->
name|def_ep_desc
operator|.
name|bInterval
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_DEFAULT
expr_stmt|;
name|dev
operator|->
name|quirks
operator|=
operator|&
name|usbd_no_quirk
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|USB_START_ADDR
expr_stmt|;
name|dev
operator|->
name|ddesc
operator|.
name|bMaxPacketSize
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|lowspeed
operator|=
name|lowspeed
operator|!=
literal|0
expr_stmt|;
name|dev
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|dev
operator|->
name|powersrc
operator|=
name|up
expr_stmt|;
name|dev
operator|->
name|langid
operator|=
name|USBD_NOLANG
expr_stmt|;
comment|/* Establish the the default pipe. */
name|r
operator|=
name|usbd_setup_pipe
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|dev
operator|->
name|def_ep
argument_list|,
operator|&
name|dev
operator|->
name|default_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|up
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|dd
operator|=
operator|&
name|dev
operator|->
name|ddesc
expr_stmt|;
comment|/* Try a few times in case the device is slow (i.e. outside specs.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get the first 8 bytes of the device descriptor. */
name|r
operator|=
name|usbd_get_desc
argument_list|(
name|dev
argument_list|,
name|UDESC_DEVICE
argument_list|,
literal|0
argument_list|,
name|USB_MAX_IPACKET
argument_list|,
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|USBD_NORMAL_COMPLETION
condition|)
break|break;
name|usbd_delay_ms
argument_list|(
name|dev
argument_list|,
literal|200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_new_device: addr=%d, getting first desc "
literal|"failed\n"
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|dd
operator|->
name|bDescriptorType
operator|!=
name|UDESC_DEVICE
condition|)
block|{
comment|/* Illegal device descriptor */
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_new_device: illegal descriptor %d\n"
operator|,
name|dd
operator|->
name|bDescriptorType
operator|)
argument_list|)
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, "
literal|"subclass=%d, protocol=%d, maxpacket=%d, ls=%d\n"
operator|,
name|addr
operator|,
name|UGETW
argument_list|(
name|dd
operator|->
name|bcdUSB
argument_list|)
operator|,
name|dd
operator|->
name|bDeviceClass
operator|,
name|dd
operator|->
name|bDeviceSubClass
operator|,
name|dd
operator|->
name|bDeviceProtocol
operator|,
name|dd
operator|->
name|bMaxPacketSize
operator|,
name|dev
operator|->
name|lowspeed
operator|)
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|dev
operator|->
name|def_ep_desc
operator|.
name|wMaxPacketSize
argument_list|,
name|dd
operator|->
name|bMaxPacketSize
argument_list|)
expr_stmt|;
comment|/* Get the full device descriptor. */
name|r
operator|=
name|usbd_get_device_desc
argument_list|(
name|dev
argument_list|,
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usbd_new_device: addr=%d, getting full desc "
literal|"failed\n"
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Figure out what's wrong with this device. */
name|dev
operator|->
name|quirks
operator|=
name|usbd_find_quirk
argument_list|(
name|dd
argument_list|)
expr_stmt|;
comment|/* Set the address */
name|r
operator|=
name|usbd_set_address
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|DPRINTFN
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
literal|"usb_new_device: set address %d failed\n"
operator|,
name|addr
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|USBD_SET_ADDR_FAILED
expr_stmt|;
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Allow device time to set new address */
name|usbd_delay_ms
argument_list|(
name|dev
argument_list|,
name|USB_SET_ADDRESS_SETTLE
argument_list|)
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|addr
expr_stmt|;
comment|/* New device address now */
name|dev
operator|->
name|state
operator|=
name|USBD_DEVICE_ADDRESSED
expr_stmt|;
name|bus
operator|->
name|devices
index|[
name|addr
index|]
operator|=
name|dev
expr_stmt|;
comment|/* Assume 100mA bus powered for now. Changed when configured. */
name|dev
operator|->
name|power
operator|=
name|USB_MIN_POWER
expr_stmt|;
name|dev
operator|->
name|self_powered
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n"
operator|,
name|addr
operator|,
name|dev
operator|,
name|parent
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|usbd_probe_and_attach
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|port
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|usbd_remove_device
argument_list|(
name|dev
argument_list|,
name|up
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usbd_remove_device
parameter_list|(
name|dev
parameter_list|,
name|up
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|struct
name|usbd_port
modifier|*
name|up
decl_stmt|;
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"usbd_remove_device: %p\n"
operator|,
name|dev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|default_pipe
condition|)
name|usbd_kill_pipe
argument_list|(
name|dev
operator|->
name|default_pipe
argument_list|)
expr_stmt|;
name|up
operator|->
name|device
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|bus
operator|->
name|devices
index|[
name|dev
operator|->
name|address
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|,
name|M_USB
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|int
name|usbd_print
parameter_list|(
name|aux
parameter_list|,
name|pnp
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|pnp
decl_stmt|;
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|aux
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|15
argument_list|,
operator|(
literal|"usbd_print dev=%p\n"
operator|,
name|uaa
operator|->
name|device
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnp
condition|)
block|{
if|if
condition|(
operator|!
name|uaa
operator|->
name|usegeneric
condition|)
return|return
operator|(
name|QUIET
operator|)
return|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|1
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, %s"
argument_list|,
name|devinfo
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uaa
operator|->
name|port
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" port %d"
argument_list|,
name|uaa
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|configno
operator|!=
name|UHUB_UNK_CONFIGURATION
condition|)
name|printf
argument_list|(
literal|" configuration %d"
argument_list|,
name|uaa
operator|->
name|configno
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaa
operator|->
name|ifaceno
operator|!=
name|UHUB_UNK_INTERFACE
condition|)
name|printf
argument_list|(
literal|" interface %d"
argument_list|,
name|uaa
operator|->
name|ifaceno
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNCONF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usbd_submatch
parameter_list|(
name|parent
parameter_list|,
name|cf
parameter_list|,
name|aux
parameter_list|)
name|struct
name|device
modifier|*
name|parent
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cf
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|aux
decl_stmt|;
if|if
condition|(
operator|(
name|uaa
operator|->
name|port
operator|!=
literal|0
operator|&&
name|cf
operator|->
name|uhubcf_port
operator|!=
name|UHUB_UNK_PORT
operator|&&
name|cf
operator|->
name|uhubcf_port
operator|!=
name|uaa
operator|->
name|port
operator|)
operator|||
operator|(
name|uaa
operator|->
name|configno
operator|!=
name|UHUB_UNK_CONFIGURATION
operator|&&
name|cf
operator|->
name|uhubcf_configuration
operator|!=
name|UHUB_UNK_CONFIGURATION
operator|&&
name|cf
operator|->
name|uhubcf_configuration
operator|!=
name|uaa
operator|->
name|configno
operator|)
operator|||
operator|(
name|uaa
operator|->
name|ifaceno
operator|!=
name|UHUB_UNK_INTERFACE
operator|&&
name|cf
operator|->
name|uhubcf_interface
operator|!=
name|UHUB_UNK_INTERFACE
operator|&&
name|cf
operator|->
name|uhubcf_interface
operator|!=
name|uaa
operator|->
name|ifaceno
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
call|(
modifier|*
name|cf
operator|->
name|cf_attach
operator|->
name|ca_match
call|)
argument_list|(
name|parent
argument_list|,
name|cf
argument_list|,
name|aux
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|usbd_status
name|usb_insert_transfer
parameter_list|(
name|reqh
parameter_list|)
name|usbd_request_handle
name|reqh
decl_stmt|;
block|{
name|usbd_pipe_handle
name|pipe
init|=
name|reqh
operator|->
name|pipe
decl_stmt|;
name|usbd_interface_handle
name|iface
init|=
name|pipe
operator|->
name|iface
decl_stmt|;
if|if
condition|(
name|pipe
operator|->
name|state
operator|==
name|USBD_PIPE_IDLE
operator|||
operator|(
name|iface
operator|&&
name|iface
operator|->
name|state
operator|==
name|USBD_INTERFACE_IDLE
operator|)
condition|)
return|return
operator|(
name|USBD_IS_IDLE
operator|)
return|;
name|SIMPLEQ_INSERT_TAIL
argument_list|(
operator|&
name|pipe
operator|->
name|queue
argument_list|,
name|reqh
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|state
operator|!=
name|USBD_PIPE_ACTIVE
operator|||
operator|(
name|iface
operator|&&
name|iface
operator|->
name|state
operator|!=
name|USBD_INTERFACE_ACTIVE
operator|)
condition|)
return|return
operator|(
name|USBD_NOT_STARTED
operator|)
return|;
if|if
condition|(
name|pipe
operator|->
name|running
condition|)
return|return
operator|(
name|USBD_IN_PROGRESS
operator|)
return|;
name|pipe
operator|->
name|running
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_start_next
parameter_list|(
name|pipe
parameter_list|)
name|usbd_pipe_handle
name|pipe
decl_stmt|;
block|{
name|usbd_request_handle
name|reqh
decl_stmt|;
name|usbd_status
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|pipe
operator|->
name|queue
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"usb_start_next: empty\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* First remove remove old */
name|SIMPLEQ_REMOVE_HEAD
argument_list|(
operator|&
name|pipe
operator|->
name|queue
argument_list|,
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|pipe
operator|->
name|queue
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|state
operator|!=
name|USBD_PIPE_ACTIVE
condition|)
block|{
name|pipe
operator|->
name|running
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|reqh
operator|=
name|SIMPLEQ_FIRST
argument_list|(
operator|&
name|pipe
operator|->
name|queue
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"usb_start_next: start reqh=%p\n"
operator|,
name|reqh
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reqh
condition|)
name|pipe
operator|->
name|running
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|r
operator|=
name|pipe
operator|->
name|methods
operator|->
name|start
argument_list|(
name|reqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|USBD_IN_PROGRESS
condition|)
block|{
name|printf
argument_list|(
literal|"usb_start_next: error=%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|running
operator|=
literal|0
expr_stmt|;
comment|/* XXX do what? */
block|}
block|}
block|}
end_function

begin_function
name|void
name|usbd_fill_deviceinfo
parameter_list|(
name|dev
parameter_list|,
name|di
parameter_list|)
name|usbd_device_handle
name|dev
decl_stmt|;
name|struct
name|usb_device_info
modifier|*
name|di
decl_stmt|;
block|{
name|struct
name|usbd_port
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|s
decl_stmt|;
name|di
operator|->
name|config
operator|=
name|dev
operator|->
name|config
expr_stmt|;
name|usbd_devinfo_vp
argument_list|(
name|dev
argument_list|,
name|di
operator|->
name|vendor
argument_list|,
name|di
operator|->
name|product
argument_list|)
expr_stmt|;
name|usbd_printBCD
argument_list|(
name|di
operator|->
name|revision
argument_list|,
name|UGETW
argument_list|(
name|dev
operator|->
name|ddesc
operator|.
name|bcdDevice
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|->
name|vendorNo
operator|=
name|UGETW
argument_list|(
name|dev
operator|->
name|ddesc
operator|.
name|idVendor
argument_list|)
expr_stmt|;
name|di
operator|->
name|productNo
operator|=
name|UGETW
argument_list|(
name|dev
operator|->
name|ddesc
operator|.
name|idProduct
argument_list|)
expr_stmt|;
name|di
operator|->
name|class
operator|=
name|dev
operator|->
name|ddesc
operator|.
name|bDeviceClass
expr_stmt|;
name|di
operator|->
name|power
operator|=
name|dev
operator|->
name|self_powered
condition|?
literal|0
else|:
name|dev
operator|->
name|power
expr_stmt|;
name|di
operator|->
name|lowspeed
operator|=
name|dev
operator|->
name|lowspeed
expr_stmt|;
name|di
operator|->
name|addr
operator|=
name|dev
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|hub
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|di
operator|->
name|ports
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|di
operator|->
name|ports
index|[
literal|0
index|]
argument_list|)
operator|&&
name|i
operator|<
name|dev
operator|->
name|hub
operator|->
name|hubdesc
operator|.
name|bNbrPorts
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|dev
operator|->
name|hub
operator|->
name|ports
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|device
condition|)
name|r
operator|=
name|p
operator|->
name|device
operator|->
name|address
expr_stmt|;
else|else
block|{
name|s
operator|=
name|UGETW
argument_list|(
name|p
operator|->
name|status
operator|.
name|wPortStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|UPS_PORT_ENABLED
condition|)
name|r
operator|=
name|USB_PORT_ENABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|&
name|UPS_SUSPEND
condition|)
name|r
operator|=
name|USB_PORT_SUSPENDED
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|&
name|UPS_PORT_POWER
condition|)
name|r
operator|=
name|USB_PORT_POWERED
expr_stmt|;
else|else
name|r
operator|=
name|USB_PORT_DISABLED
expr_stmt|;
block|}
name|di
operator|->
name|ports
index|[
name|i
index|]
operator|=
name|r
expr_stmt|;
block|}
name|di
operator|->
name|nports
operator|=
name|dev
operator|->
name|hub
operator|->
name|hubdesc
operator|.
name|bNbrPorts
expr_stmt|;
block|}
else|else
name|di
operator|->
name|nports
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

