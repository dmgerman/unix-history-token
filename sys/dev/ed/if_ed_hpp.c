begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005, M. Warner Losh  * All rights reserved.  * Copyright (c) 1995, David Greenman   * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ed.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ED_HPP
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edvar.h>
end_include

begin_function_decl
specifier|static
name|void
name|ed_hpp_readmem
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_hpp_writemem
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_hpp_set_physical_link
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|ed_hpp_write_mbufs
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Interrupt conversion table for the HP PC LAN+  */
end_comment

begin_decl_stmt
specifier|static
name|uint16_t
name|ed_hpp_intr_val
index|[]
init|=
block|{
literal|0
block|,
comment|/* 0 */
literal|0
block|,
comment|/* 1 */
literal|0
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3 */
literal|4
block|,
comment|/* 4 */
literal|5
block|,
comment|/* 5 */
literal|6
block|,
comment|/* 6 */
literal|7
block|,
comment|/* 7 */
literal|0
block|,
comment|/* 8 */
literal|9
block|,
comment|/* 9 */
literal|10
block|,
comment|/* 10 */
literal|11
block|,
comment|/* 11 */
literal|12
block|,
comment|/* 12 */
literal|0
block|,
comment|/* 13 */
literal|0
block|,
comment|/* 14 */
literal|15
comment|/* 15 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ED_HPP_TEST_SIZE
value|16
end_define

begin_comment
comment|/*  * Probe and vendor specific initialization for the HP PC Lan+ Cards.  * (HP Part nos: 27247B and 27252A).  *  * The card has an asic wrapper around a DS8390 core.  The asic handles   * host accesses and offers both standard register IO and memory mapped   * IO.  Memory mapped I/O allows better performance at the expense of greater  * chance of an incompatibility with existing ISA cards.  *  * The card has a few caveats: it isn't tolerant of byte wide accesses, only  * short (16 bit) or word (32 bit) accesses are allowed.  Some card revisions  * don't allow 32 bit accesses; these are indicated by a bit in the software  * ID register (see if_edreg.h).  *   * Other caveats are: we should read the MAC address only when the card  * is inactive.  *  * For more information; please consult the CRYNWR packet driver.  *  * The AUI port is turned on using the "link2" option on the ifconfig   * command line.  */
end_comment

begin_function
name|int
name|ed_probe_HP_pclanp
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* temp var */
name|int
name|memsize
decl_stmt|;
comment|/* mem on board */
name|u_char
name|checksum
decl_stmt|;
comment|/* checksum of board address */
name|u_char
name|irq
decl_stmt|;
comment|/* board configured IRQ */
name|uint8_t
name|test_pattern
index|[
name|ED_HPP_TEST_SIZE
index|]
decl_stmt|;
comment|/* read/write areas for */
name|uint8_t
name|test_buffer
index|[
name|ED_HPP_TEST_SIZE
index|]
decl_stmt|;
comment|/* probing card */
name|u_long
name|conf_maddr
decl_stmt|,
name|conf_msize
decl_stmt|,
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ED_HPP_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fill in basic information */
name|sc
operator|->
name|asic_offset
operator|=
name|ED_HPP_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_HPP_NIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_DP8390
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* the 8390 core needs to be in byte mode */
comment|/*  	 * Look for the HP PCLAN+ signature: "0x50,0x48,0x00,0x53"  	 */
if|if
condition|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
argument_list|)
operator|!=
literal|0x50
operator|)
operator|||
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
operator|+
literal|1
argument_list|)
operator|!=
literal|0x48
operator|)
operator|||
operator|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
operator|+
literal|2
argument_list|)
operator|&
literal|0xF0
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
operator|+
literal|3
argument_list|)
operator|!=
literal|0x53
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*  	 * Read the MAC address and verify checksum on the address. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_MAC
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|checksum
operator|=
literal|0
init|;
name|n
operator|<
name|ETHER_ADDR_LEN
condition|;
name|n
operator|++
control|)
name|checksum
operator|+=
operator|(
name|sc
operator|->
name|enaddr
index|[
name|n
index|]
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_MAC_ADDR
operator|+
name|n
argument_list|)
operator|)
expr_stmt|;
name|checksum
operator|+=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_MAC_ADDR
operator|+
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
literal|0xFF
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Verify that the software model number is 0. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|hpp_id
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|)
operator|)
operator|&
name|ED_HPP_ID_SOFT_MODEL_MASK
operator|)
operator|!=
literal|0x0000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Read in and save the current options configured on card. 	 */
name|sc
operator|->
name|hpp_options
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hpp_options
operator||=
operator|(
name|ED_HPP_OPTION_NIC_RESET
operator||
name|ED_HPP_OPTION_CHIP_RESET
operator||
name|ED_HPP_OPTION_ENABLE_IRQ
operator|)
expr_stmt|;
comment|/*  	 * Reset the chip.  This requires writing to the option register 	 * so take care to preserve the other bits. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
operator|(
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_NIC_RESET
operator||
name|ED_HPP_OPTION_CHIP_RESET
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* wait for chip reset to complete */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
operator|(
name|sc
operator|->
name|hpp_options
operator||
operator|(
name|ED_HPP_OPTION_NIC_RESET
operator||
name|ED_HPP_OPTION_CHIP_RESET
operator||
name|ED_HPP_OPTION_ENABLE_IRQ
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* reset did not complete */
comment|/* 	 * Read out configuration information. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_HW
argument_list|)
expr_stmt|;
name|irq
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_HW_IRQ
argument_list|)
expr_stmt|;
comment|/*  	 * Check for impossible IRQ. 	 */
if|if
condition|(
name|irq
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|ed_hpp_intr_val
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ed_hpp_intr_val
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*  	 * If the kernel IRQ was specified with a '?' use the cards idea 	 * of the IRQ.  If the kernel IRQ was explicitly specified, it  	 * should match that of the hardware. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|ed_hpp_intr_val
index|[
name|irq
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|conf_irq
operator|!=
name|ed_hpp_intr_val
index|[
name|irq
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Fill in softconfig info. 	 */
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_HP
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_HP_PCLANPLUS
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"HP-PCLAN+"
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
comment|/* we DON'T have dual ported RAM */
name|sc
operator|->
name|mem_start
operator|=
literal|0
expr_stmt|;
comment|/* we use offsets inside the card RAM */
name|sc
operator|->
name|hpp_mem_start
operator|=
name|NULL
expr_stmt|;
comment|/* no memory mapped I/O by default */
comment|/* 	 * The board has 32KB of memory.  Is there a way to determine 	 * this programmatically? 	 */
name|memsize
operator|=
literal|32768
expr_stmt|;
comment|/* 	 * Check if memory mapping of the I/O registers possible. 	 */
if|if
condition|(
name|sc
operator|->
name|hpp_options
operator|&
name|ED_HPP_OPTION_MEM_ENABLE
condition|)
block|{
name|u_long
name|mem_addr
decl_stmt|;
comment|/* 		 * determine the memory address from the board. 		 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_HW
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
operator|(
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_HW_MEM_MAP
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 		 * Check that the kernel specified start of memory and 		 * hardware's idea of it match. 		 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_maddr
argument_list|,
operator|&
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mem_addr
operator|!=
name|conf_maddr
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|hpp_mem_start
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the rest of the soft config structure. 	 */
comment|/* 	 * The transmit page index. 	 */
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_HPP_TX_PAGE_OFFSET
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Memory description 	 */
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|mem_size
expr_stmt|;
comment|/* 	 * Receive area starts after the transmit area and  	 * continues till the end of memory. 	 */
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
operator|(
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
operator|(
name|sc
operator|->
name|mem_size
operator|/
name|ED_PAGE_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
literal|0
expr_stmt|;
comment|/* value works */
comment|/* 	 * Set the wrap registers for string I/O reads. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_HW
argument_list|)
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_HW_WRAP
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|rec_page_start
operator|/
name|ED_PAGE_SIZE
operator|)
operator||
operator|(
operator|(
operator|(
name|sc
operator|->
name|rec_page_stop
operator|/
name|ED_PAGE_SIZE
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the register page to normal operation. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_PERF
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can read/write from adapter memory. 	 * Create test pattern. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ED_HPP_TEST_SIZE
condition|;
name|n
operator|++
control|)
name|test_pattern
index|[
name|n
index|]
operator|=
operator|(
name|n
operator|*
name|n
operator|)
operator|^
operator|~
name|n
expr_stmt|;
undef|#
directive|undef
name|ED_HPP_TEST_SIZE
comment|/* 	 * Check that the memory is accessible thru the I/O ports. 	 * Write out the contents of "test_pattern", read back 	 * into "test_buffer" and compare the two for any 	 * mismatch. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|32768
operator|/
name|ED_PAGE_SIZE
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|ed_hpp_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
operator|(
name|n
operator|*
name|ED_PAGE_SIZE
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_hpp_readmem
argument_list|(
name|sc
argument_list|,
operator|(
name|n
operator|*
name|ED_PAGE_SIZE
operator|)
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_mediachg
operator|=
name|ed_hpp_set_physical_link
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_hpp_write_mbufs
expr_stmt|;
name|sc
operator|->
name|readmem
operator|=
name|ed_hpp_readmem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HP PC Lan+ : Set the physical link to use AUI or TP/TL.  */
end_comment

begin_function
specifier|static
name|void
name|ed_hpp_set_physical_link
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|lan_page
decl_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_LAN
argument_list|)
expr_stmt|;
name|lan_page
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
block|{
comment|/* 		 * Use the AUI port. 		 */
name|lan_page
operator||=
name|ED_HPP_LAN_AUI
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_LAN
argument_list|)
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|lan_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Use the ThinLan interface 		 */
name|lan_page
operator|&=
operator|~
name|ED_HPP_LAN_AUI
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_LAN
argument_list|)
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|lan_page
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the lan card to re-initialize itself 	 */
name|DELAY
argument_list|(
literal|150000
argument_list|)
expr_stmt|;
comment|/* wait 150 ms */
comment|/* 	 * Restore normal pages. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_PERF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Support routines to handle the HP PC Lan+ card.  */
end_comment

begin_comment
comment|/*  * HP PC Lan+: Read from NIC memory, using either PIO or memory mapped  * IO.  */
end_comment

begin_function
specifier|static
name|void
name|ed_hpp_readmem
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|src
parameter_list|,
name|uint8_t
modifier|*
name|dst
parameter_list|,
name|uint16_t
name|amount
parameter_list|)
block|{
name|int
name|use_32bit_access
init|=
operator|!
operator|(
name|sc
operator|->
name|hpp_id
operator|&
name|ED_HPP_ID_16_BIT_ACCESS
operator|)
decl_stmt|;
comment|/* Program the source address in RAM */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_2
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * The HP PC Lan+ card supports word reads as well as 	 * a memory mapped i/o port that is aliased to every  	 * even address on the board. 	 */
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
block|{
comment|/* Enable memory mapped access.  */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_MEM_DISABLE
operator||
name|ED_HPP_OPTION_BOOT_ROM_ENB
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_32bit_access
operator|&&
operator|(
name|amount
operator|>
literal|3
operator|)
condition|)
block|{
name|uint32_t
modifier|*
name|dl
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|dst
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
specifier|const
name|sl
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|uint32_t
modifier|*
specifier|const
name|fence
init|=
name|dl
operator|+
operator|(
name|amount
operator|>>
literal|2
operator|)
decl_stmt|;
comment|/* 			 * Copy out NIC data.  We could probably write this 			 * as a `movsl'. The currently generated code is lousy. 			 */
while|while
condition|(
name|dl
operator|<
name|fence
condition|)
operator|*
name|dl
operator|++
operator|=
operator|*
name|sl
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|amount
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* Finish off any words left, as a series of short reads */
if|if
condition|(
name|amount
operator|>
literal|1
condition|)
block|{
name|u_short
modifier|*
name|d
init|=
operator|(
name|u_short
operator|*
operator|)
name|dst
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
specifier|const
name|s
init|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|u_short
modifier|*
specifier|const
name|fence
init|=
name|d
operator|+
operator|(
name|amount
operator|>>
literal|1
operator|)
decl_stmt|;
comment|/* Copy out NIC data.  */
while|while
condition|(
name|d
operator|<
name|fence
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|amount
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* 		 * read in a byte; however we need to always read 16 bits 		 * at a time or the hardware gets into a funny state 		 */
if|if
condition|(
name|amount
operator|==
literal|1
condition|)
block|{
comment|/* need to read in a short and copy LSB */
specifier|volatile
name|u_short
modifier|*
specifier|const
name|s
init|=
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|*
name|s
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
comment|/* Restore Boot ROM access.  */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read in data using the I/O port */
if|if
condition|(
name|use_32bit_access
operator|&&
operator|(
name|amount
operator|>
literal|3
operator|)
condition|)
block|{
name|ed_asic_insl
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|dst
argument_list|,
name|amount
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|amount
operator|&=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|amount
operator|>
literal|1
condition|)
block|{
name|ed_asic_insw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|dst
argument_list|,
name|amount
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|amount
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|amount
operator|==
literal|1
condition|)
block|{
comment|/* read in a short and keep the LSB */
operator|*
name|dst
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * HP PC Lan+: Write to NIC memory, using either PIO or memory mapped  * IO.  *	Only used in the probe routine to test the memory. 'len' must  *	be even.  */
end_comment

begin_function
specifier|static
name|void
name|ed_hpp_writemem
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|src
parameter_list|,
name|uint16_t
name|dst
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
comment|/* reset remote DMA complete flag */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* program the write address in RAM */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
operator|(
name|u_short
operator|*
operator|)
name|src
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|d
init|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|u_short
modifier|*
specifier|const
name|fence
init|=
name|s
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
decl_stmt|;
comment|/* 		 * Enable memory mapped access. 		 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_MEM_DISABLE
operator||
name|ED_HPP_OPTION_BOOT_ROM_ENB
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Copy to NIC memory. 		 */
while|while
condition|(
name|s
operator|<
name|fence
condition|)
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* 		 * Restore Boot ROM access. 		 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* write data using I/O writes */
name|ed_asic_outsw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|src
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write to HP PC Lan+ NIC memory.  Access to the NIC can be by using   * outsw() or via the memory mapped interface to the same register.  * Writes have to be in word units; byte accesses won't work and may cause  * the NIC to behave weirdly. Long word accesses are permitted if the ASIC  * allows it.  */
end_comment

begin_function
specifier|static
name|u_short
name|ed_hpp_write_mbufs
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|bus_size_t
name|dst
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|wantbyte
decl_stmt|;
name|unsigned
name|short
name|total_len
decl_stmt|;
name|unsigned
name|char
name|savebyte
index|[
literal|2
index|]
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
specifier|const
name|d
init|=
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|int
name|use_32bit_accesses
init|=
operator|!
operator|(
name|sc
operator|->
name|hpp_id
operator|&
name|ED_HPP_ID_16_BIT_ACCESS
operator|)
decl_stmt|;
comment|/* select page 0 registers */
name|ed_nic_barrier
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
name|ed_nic_barrier
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
comment|/* reset remote DMA complete flag */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* program the write address in RAM */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
comment|/* enable memory mapped I/O */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_MEM_DISABLE
operator||
name|ED_HPP_OPTION_BOOT_ROM_ENB
operator|)
argument_list|)
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
name|total_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
block|{
comment|/* Memory mapped I/O port */
while|while
condition|(
name|m
condition|)
block|{
name|total_len
operator|+=
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|caddr_t
name|data
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
comment|/* finish the last word of the previous mbuf */
if|if
condition|(
name|wantbyte
condition|)
block|{
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
operator|*
name|d
operator|=
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
name|savebyte
operator|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
operator|(
name|len
operator|>
literal|3
operator|)
operator|&&
operator|(
name|use_32bit_accesses
operator|)
condition|)
block|{
specifier|volatile
name|uint32_t
modifier|*
specifier|const
name|dl
init|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|d
decl_stmt|;
name|uint32_t
modifier|*
name|sl
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|data
decl_stmt|;
name|uint32_t
modifier|*
name|fence
init|=
name|sl
operator|+
operator|(
name|len
operator|>>
literal|2
operator|)
decl_stmt|;
while|while
condition|(
name|sl
operator|<
name|fence
condition|)
operator|*
name|dl
operator|=
operator|*
name|sl
operator|++
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|len
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* finish off remain 16 bit writes */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
operator|(
name|u_short
operator|*
operator|)
name|data
decl_stmt|;
name|u_short
modifier|*
name|fence
init|=
name|s
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|fence
condition|)
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* save last byte if needed */
if|if
condition|(
operator|(
name|wantbyte
operator|=
operator|(
name|len
operator|==
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* to next mbuf */
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* write last byte */
operator|*
name|d
operator|=
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
name|savebyte
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use programmed I/O */
while|while
condition|(
name|m
condition|)
block|{
name|total_len
operator|+=
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|caddr_t
name|data
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
comment|/* finish the last word of the previous mbuf */
if|if
condition|(
name|wantbyte
condition|)
block|{
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
name|savebyte
operator|)
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
operator|(
name|len
operator|>
literal|3
operator|)
operator|&&
name|use_32bit_accesses
condition|)
block|{
name|ed_asic_outsl
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|len
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* finish off remaining 16 bit accesses */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|ed_asic_outsw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wantbyte
operator|=
operator|(
name|len
operator|==
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
block|}
comment|/* if len != 0 */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* spit last byte */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
comment|/* turn off memory mapped i/o */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
argument_list|)
expr_stmt|;
return|return
operator|(
name|total_len
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ED_HPP */
end_comment

end_unit

