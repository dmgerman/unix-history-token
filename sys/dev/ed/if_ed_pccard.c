begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005, M. Warner Losh  * Copyright (c) 1995, David Greenman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Notes for adding media support.  Each chipset is somewhat different  * from the others.  Linux has a table of OIDs that it uses to see what  * supports the misc register of the NS83903.  But a sampling of datasheets  * I could dig up on cards I own paints a different picture.  *  * Chipset specific details:  * NS 83903/902A paired  *    ccr base 0x1020  *    id register at 0x1000: 7-3 = 0, 2-0 = 1.  *	(maybe this test is too week)  *    misc register at 0x018:  *	6 WAIT_TOUTENABLE enable watchdog timeout  *	3 AUI/TPI 1 AUX, 0 TPI  *	2 loopback  *      1 gdlink (tpi mode only) 1 tp good, 0 tp bad  *	0 0-no mam, 1 mam connected  *  * NS83926 appears to be a NS pcmcia glue chip used on the IBM Ethernet II  * and the NEC PC9801N-J12 ccr base 0x2000!  *  * winbond 289c926  *    ccr base 0xfd0  *    cfb (am 0xff2):  *	0-1 PHY01	00 TPI, 01 10B2, 10 10B5, 11 TPI (reduced squ)  *	2 LNKEN		0 - enable link and auto switch, 1 disable  *	3 LNKSTS	TPI + LNKEN=0 + link good == 1, else 0  *    sr (am 0xff4)  *	88 00 88 00 88 00, etc  *  * TMI tc3299a (cr PHY01 == 0)  *    ccr base 0x3f8  *    cra (io 0xa)  *    crb (io 0xb)  *	0-1 PHY01	00 auto, 01 res, 10 10B5, 11 TPI  *	2 GDLINK	1 disable checking of link  *	6 LINK		0 bad link, 1 good link  *  * EN5017A, EN5020	no data, but very popular  * Other chips?  * NetBSD supports RTL8019, but none have surfaced that I can see  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/ax88x90reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/dl100xxreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/tc5299jreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccard_cis.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|"pccarddevs.h"
end_include

begin_comment
comment|/*  * NE-2000 based PC Cards have a number of ways to get the MAC address.  * Some cards encode this as a FUNCE.  Others have this in the ROMs the  * same way that ISA cards do.  Some have it encoded in the attribute  * memory somewhere that isn't in the CIS.  Some new chipsets have it  * in special registers in the ASIC part of the chip.  *  * For those cards that have the MAC adress stored in attribute memory  * outside of a FUNCE entry in the CIS, nearly all of them have it at  * a fixed offset (0xff0).  We use that offset as a source of last  * resource if other offsets have failed.  This is the address of the  * National Semiconductor DP83903A, which is the only chip's datasheet  * I've found.  */
end_comment

begin_define
define|#
directive|define
name|ED_DEFAULT_MAC_OFFSET
value|0xff0
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|ed_product
block|{
name|struct
name|pccard_product
name|prod
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|NE2000DVF_DL100XX
value|0x0001
comment|/* chip is D-Link DL10019/22 */
define|#
directive|define
name|NE2000DVF_AX88X90
value|0x0002
comment|/* chip is ASIX AX88[17]90 */
define|#
directive|define
name|NE2000DVF_TC5299J
value|0x0004
comment|/* chip is Tamarack TC5299J */
define|#
directive|define
name|NE2000DVF_TOSHIBA
value|0x0008
comment|/* Toshiba DP83902A */
define|#
directive|define
name|NE2000DVF_ENADDR
value|0x0100
comment|/* Get MAC from attr mem */
define|#
directive|define
name|NE2000DVF_ANYFUNC
value|0x0200
comment|/* Allow any function type */
define|#
directive|define
name|NE2000DVF_MODEM
value|0x0400
comment|/* Has a modem/serial */
name|int
name|enoff
decl_stmt|;
block|}
name|ed_pccard_products
index|[]
init|=
block|{
block|{
name|PCMCIA_CARD
argument_list|(
name|ACCTON
argument_list|,
name|EN2212
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|ACCTON
argument_list|,
name|EN2216
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|ALLIEDTELESIS
argument_list|,
name|LA_PCM
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|AMBICOM
argument_list|,
name|AMB8002
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|AMBICOM
argument_list|,
name|AMB8002T
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|AMBICOM
argument_list|,
name|AMB8010
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|AMBICOM
argument_list|,
name|AMB8010_ALT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|AMBICOM
argument_list|,
name|AMB8610
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BILLIONTON
argument_list|,
name|CFLT10N
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BILLIONTON
argument_list|,
name|LNA100B
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BILLIONTON
argument_list|,
name|LNT10TB
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BILLIONTON
argument_list|,
name|LNT10TN
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BROMAX
argument_list|,
name|AXNET
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BROMAX
argument_list|,
name|IPORT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BROMAX
argument_list|,
name|IPORT2
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BUFFALO
argument_list|,
name|LPC2_CLT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BUFFALO
argument_list|,
name|LPC3_CLT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BUFFALO
argument_list|,
name|LPC3_CLX
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BUFFALO
argument_list|,
name|LPC4_TX
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BUFFALO
argument_list|,
name|LPC4_CLX
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|BUFFALO
argument_list|,
name|LPC_CF_CLT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|CNET
argument_list|,
name|NE2000
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COMPEX
argument_list|,
name|AX88190
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COMPEX
argument_list|,
name|LANMODEM
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COMPEX
argument_list|,
name|LINKPORT_ENET_B
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|ETHER_II_PCC_T
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|ETHER_II_PCC_TD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|ETHER_PCC_T
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|ETHER_PCC_TD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|FAST_ETHER_PCC_TX
argument_list|)
block|,
name|NE2000DVF_DL100XX
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|FETHER_PCC_TXD
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|FETHER_PCC_TXF
argument_list|)
block|,
name|NE2000DVF_DL100XX
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|FETHER_II_PCC_TXD
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|COREGA
argument_list|,
name|LAPCCTXD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|DAYNA
argument_list|,
name|COMMUNICARD_E_1
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|DAYNA
argument_list|,
name|COMMUNICARD_E_2
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|DLINK
argument_list|,
name|DE650
argument_list|)
block|,
name|NE2000DVF_ANYFUNC
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|DLINK
argument_list|,
name|DE660
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|DLINK
argument_list|,
name|DE660PLUS
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|DYNALINK
argument_list|,
name|L10C
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|EDIMAX
argument_list|,
name|EP4000A
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|EPSON
argument_list|,
name|EEN10B
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|EXP
argument_list|,
name|THINLANCOMBO
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|GLOBALVILLAGE
argument_list|,
name|LANMODEM
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|GREY_CELL
argument_list|,
name|TDK3000
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|GREY_CELL
argument_list|,
name|DMF650TX
argument_list|)
block|,
name|NE2000DVF_ANYFUNC
operator||
name|NE2000DVF_DL100XX
operator||
name|NE2000DVF_MODEM
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|GVC
argument_list|,
name|NIC_2000P
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|IBM
argument_list|,
name|HOME_AND_AWAY
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|IBM
argument_list|,
name|INFOMOVER
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|IODATA3
argument_list|,
name|PCLAT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|KINGSTON
argument_list|,
name|CIO10T
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|KINGSTON
argument_list|,
name|KNE2
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|LANTECH
argument_list|,
name|FASTNETTX
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
comment|/* Same ID for many different cards, including generic NE2000 */
block|{
name|PCMCIA_CARD
argument_list|(
name|LINKSYS
argument_list|,
name|COMBO_ECARD
argument_list|)
block|,
name|NE2000DVF_DL100XX
operator||
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|LINKSYS
argument_list|,
name|ECARD_1
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|LINKSYS
argument_list|,
name|ECARD_2
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|LINKSYS
argument_list|,
name|ETHERFAST
argument_list|)
block|,
name|NE2000DVF_DL100XX
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|LINKSYS
argument_list|,
name|TRUST_COMBO_ECARD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MACNICA
argument_list|,
name|ME1_JEIDA
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MAGICRAM
argument_list|,
name|ETHER
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MELCO
argument_list|,
name|LPC3_CLX
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MELCO
argument_list|,
name|LPC3_TX
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MELCO2
argument_list|,
name|LPC2_T
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MELCO2
argument_list|,
name|LPC2_TX
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|MITSUBISHI
argument_list|,
name|B8895
argument_list|)
block|,
name|NE2000DVF_ANYFUNC
block|}
block|,
comment|/* NG */
block|{
name|PCMCIA_CARD
argument_list|(
name|MICRORESEARCH
argument_list|,
name|MR10TPC
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|NDC
argument_list|,
name|ND5100_E
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|NETGEAR
argument_list|,
name|FA410TXC
argument_list|)
block|,
name|NE2000DVF_DL100XX
block|}
block|,
comment|/* Same ID as DLINK DFE-670TXD.  670 has DL10022, fa411 has ax88790 */
block|{
name|PCMCIA_CARD
argument_list|(
name|NETGEAR
argument_list|,
name|FA411
argument_list|)
block|,
name|NE2000DVF_AX88X90
operator||
name|NE2000DVF_DL100XX
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|NEXTCOM
argument_list|,
name|NEXTHAWK
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|NEWMEDIA
argument_list|,
name|LANSURFER
argument_list|)
block|,
name|NE2000DVF_ANYFUNC
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|NEWMEDIA
argument_list|,
name|LIVEWIRE
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|OEM2
argument_list|,
literal|100BASE
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|OEM2
argument_list|,
name|ETHERNET
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|OEM2
argument_list|,
name|FAST_ETHERNET
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|OEM2
argument_list|,
name|NE2000
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|PLANET
argument_list|,
name|SMARTCOM2000
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|PREMAX
argument_list|,
name|PE200
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|PSION
argument_list|,
name|LANGLOBAL
argument_list|)
block|,
name|NE2000DVF_ANYFUNC
operator||
name|NE2000DVF_AX88X90
operator||
name|NE2000DVF_MODEM
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RACORE
argument_list|,
name|ETHERNET
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RACORE
argument_list|,
name|FASTENET
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RACORE
argument_list|,
literal|8041TX
argument_list|)
block|,
name|NE2000DVF_AX88X90
operator||
name|NE2000DVF_TC5299J
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RELIA
argument_list|,
name|COMBO
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RIOS
argument_list|,
name|PCCARD3
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RPTI
argument_list|,
name|EP400
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|RPTI
argument_list|,
name|EP401
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SMC
argument_list|,
name|EZCARD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SOCKET
argument_list|,
name|EA_ETHER
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SOCKET
argument_list|,
name|ES_1000
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SOCKET
argument_list|,
name|LP_ETHER
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SOCKET
argument_list|,
name|LP_ETHER_CF
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SOCKET
argument_list|,
name|LP_ETH_10_100_CF
argument_list|)
block|,
name|NE2000DVF_DL100XX
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SVEC
argument_list|,
name|COMBOCARD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|SVEC
argument_list|,
name|LANCARD
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TAMARACK
argument_list|,
name|ETHERNET
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TDK
argument_list|,
name|CFE_10
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TDK
argument_list|,
name|LAK_CD031
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TDK
argument_list|,
name|DFL5610WS
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TELECOMDEVICE
argument_list|,
name|LM5LT
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TELECOMDEVICE
argument_list|,
name|TCD_HPC100
argument_list|)
block|,
name|NE2000DVF_AX88X90
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TJ
argument_list|,
name|PTJ_LAN_T
argument_list|)
block|,
literal|0
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|TOSHIBA2
argument_list|,
name|LANCT00A
argument_list|)
block|,
name|NE2000DVF_ANYFUNC
operator||
name|NE2000DVF_TOSHIBA
block|}
block|,
block|{
name|PCMCIA_CARD
argument_list|(
name|ZONET
argument_list|,
name|ZEN
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
name|NULL
block|}
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  *      PC Card (PCMCIA) specific code.  */
end_comment

begin_function_decl
specifier|static
name|int
name|ed_pccard_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_pccard_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_pccard_tick
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_pccard_dl100xx
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ed_product
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_pccard_dl100xx_mii_reset
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ed_pccard_dl100xx_mii_readbits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_pccard_dl100xx_mii_writebits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|val
parameter_list|,
name|int
name|nbits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_pccard_ax88x90
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ed_product
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ed_pccard_ax88x90_mii_readbits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_pccard_ax88x90_mii_writebits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|val
parameter_list|,
name|int
name|nbits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_pccard_tc5299j
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ed_product
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|ed_pccard_tc5299j_mii_readbits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_pccard_tc5299j_mii_writebits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|val
parameter_list|,
name|int
name|nbits
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ed_pccard_print_entry
parameter_list|(
specifier|const
name|struct
name|ed_product
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Product entry: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|prod
operator|.
name|pp_name
condition|)
name|printf
argument_list|(
literal|"name='%s',"
argument_list|,
name|pp
operator|->
name|prod
operator|.
name|pp_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vendor=%#x,product=%#x"
argument_list|,
name|pp
operator|->
name|prod
operator|.
name|pp_vendor
argument_list|,
name|pp
operator|->
name|prod
operator|.
name|pp_product
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|prod
operator|.
name|pp_cis
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|",CIS%d='%s'"
argument_list|,
name|i
argument_list|,
name|pp
operator|->
name|prod
operator|.
name|pp_cis
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|ed_product
modifier|*
name|pp
decl_stmt|,
modifier|*
name|pp2
decl_stmt|;
name|int
name|error
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|uint32_t
name|fcn
init|=
name|PCCARD_FUNCTION_UNSPEC
decl_stmt|;
comment|/* Make sure we're a network function */
name|error
operator|=
name|pccard_get_function
argument_list|(
name|dev
argument_list|,
operator|&
name|fcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|pp
operator|=
operator|(
specifier|const
expr|struct
name|ed_product
operator|*
operator|)
name|pccard_product_lookup
argument_list|(
name|dev
argument_list|,
operator|(
specifier|const
expr|struct
name|pccard_product
operator|*
operator|)
name|ed_pccard_products
argument_list|,
sizeof|sizeof
argument_list|(
name|ed_pccard_products
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|prod
operator|.
name|pp_name
operator|!=
name|NULL
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|pp
operator|->
name|prod
operator|.
name|pp_name
argument_list|)
expr_stmt|;
comment|/* 		 * Some devices don't ID themselves as network, but 		 * that's OK if the flags say so. 		 */
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_ANYFUNC
operator|)
operator|&&
name|fcn
operator|!=
name|PCCARD_FUNCTION_NETWORK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 		 * Some devices match multiple entries.  Report that 		 * as a warning to help cull the table 		 */
name|pp2
operator|=
name|pp
expr_stmt|;
while|while
condition|(
operator|(
name|pp2
operator|=
operator|(
specifier|const
expr|struct
name|ed_product
operator|*
operator|)
name|pccard_product_lookup
argument_list|(
name|dev
argument_list|,
operator|(
specifier|const
expr|struct
name|pccard_product
operator|*
operator|)
operator|(
name|pp2
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ed_pccard_products
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning: card matches multiple entries.  Report to imp@freebsd.org\n"
argument_list|)
expr_stmt|;
name|ed_pccard_print_entry
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|ed_pccard_print_entry
argument_list|(
name|pp2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_rom_mac
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
modifier|*
name|enaddr
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
name|romdata
index|[
literal|32
index|]
decl_stmt|,
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Read in the rom data at location 0.  Since there are no 	 * NE-1000 based PC Card devices, we'll assume we're 16-bit. 	 * 	 * In researching what format this takes, I've found that the 	 * following appears to be true for multiple cards based on 	 * observation as well as datasheet digging. 	 * 	 * Data is stored in some ROM and is copied out 8 bits at a time 	 * into 16-bit wide locations.  This means that the odd locations 	 * of the ROM are not used (and can be either 0 or ff). 	 * 	 * The contents appears to be as follows: 	 * PROM   RAM 	 * Offset Offset	What 	 *  0      0	ENETADDR 0 	 *  1      2	ENETADDR 1 	 *  2      4	ENETADDR 2 	 *  3      6	ENETADDR 3 	 *  4      8	ENETADDR 4 	 *  5     10	ENETADDR 5 	 *  6-13  12-26 Reserved (varies by manufacturer) 	 * 14     28	0x57 	 * 15     30    0x57 	 * 	 * Some manufacturers have another image of enetaddr from 	 * PROM offset 0x10 to 0x15 with 0x42 in 0x1e and 0x1f, but 	 * this doesn't appear to be universally documented in the 	 * datasheets.  Some manufactuers have a card type, card config 	 * checksums, etc encoded into PROM offset 6-13, but deciphering it 	 * requires more knowledge about the exact underlying chipset than 	 * we possess (and maybe can possess). 	 */
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|romdata
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ROM DATA: %32D\n"
argument_list|,
name|romdata
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|romdata
index|[
literal|28
index|]
operator|!=
literal|0x57
operator|||
name|romdata
index|[
literal|30
index|]
operator|!=
literal|0x57
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sum
operator||=
name|romdata
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|enaddr
index|[
name|i
index|]
operator|=
name|romdata
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_add_modem
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Need to write this code\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_kick_phy
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
comment|/* 	 * Many of the PHYs that wind up on PC Cards are weird in 	 * this way.  Generally, we don't need to worry so much about 	 * the Isolation protocol since there's only one PHY in 	 * these designs, so this workaround is reasonable. 	 */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
block|{
name|miisc
operator|->
name|mii_flags
operator||=
name|MIIF_FORCEANEG
expr_stmt|;
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_media_ioctl
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifreq
modifier|*
name|ifr
parameter_list|,
name|u_long
name|command
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
return|return
operator|(
name|ifmedia_ioctl
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_pccard_mediachg
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
return|return;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_char
name|sum
decl_stmt|;
name|u_char
name|enaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
specifier|const
name|struct
name|ed_product
modifier|*
name|pp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|,
name|port_rid
decl_stmt|,
name|modem_rid
decl_stmt|;
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|size
decl_stmt|;
specifier|static
name|uint16_t
modifier|*
name|intr_vals
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
operator|(
specifier|const
expr|struct
name|ed_product
operator|*
operator|)
name|pccard_product_lookup
argument_list|(
name|dev
argument_list|,
operator|(
specifier|const
expr|struct
name|pccard_product
operator|*
operator|)
name|ed_pccard_products
argument_list|,
sizeof|sizeof
argument_list|(
name|ed_pccard_products
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Can't find\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|modem_rid
operator|=
name|port_rid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_MODEM
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|ED_NOVELL_IO_PORTS
condition|)
name|port_rid
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|modem_rid
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|port_rid
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot locate my ports!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
else|else
block|{
name|port_rid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate the port resource during setup. */
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|,
name|ED_NOVELL_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"alloc_port failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|rman_get_size
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|==
name|ED_NOVELL_IO_PORTS
operator|/
literal|2
condition|)
block|{
name|port_rid
operator|++
expr_stmt|;
name|sc
operator|->
name|port_res2
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|port_rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res2
operator|==
name|NULL
operator|||
name|rman_get_size
argument_list|(
name|sc
operator|->
name|port_res2
argument_list|)
operator|!=
name|ED_NOVELL_IO_PORTS
operator|/
literal|2
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|error
operator|=
name|ed_alloc_irq
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Determine which chipset we are.  Almost all the PC Card chipsets 	 * have the Novel ASIC and NIC offsets.  There's 2 known cards that 	 * follow the WD80x3 conventions, which are handled as a special case. 	 */
name|sc
operator|->
name|asic_offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|flags
operator|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|ed_pccard_dl100xx
argument_list|(
name|dev
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|ed_pccard_ax88x90
argument_list|(
name|dev
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|ed_pccard_tc5299j
argument_list|(
name|dev
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ed_probe_Novell_generic
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Novell probe generic %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_TOSHIBA
operator|)
condition|)
block|{
name|flags
operator||=
name|ED_FLAGS_TOSH_ETHER
expr_stmt|;
name|flags
operator||=
name|ED_FLAGS_PCCARD
expr_stmt|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_WD_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_WD_NIC_OFFSET
expr_stmt|;
name|error
operator|=
name|ed_probe_WD80x3_generic
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|intr_vals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * There are several ways to get the MAC address for the card. 	 * Some of the above probe routines can fill in the enaddr.  If 	 * not, we run through a number of 'well known' locations: 	 *	(1) From the PC Card FUNCE 	 *	(2) From offset 0 in the shared memory 	 *	(3) From a hinted offset in attribute memory 	 *	(4) From 0xff0 in attribute memory 	 * If we can't get a non-zero MAC address from this list, we fail. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sum
operator||=
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
block|{
name|pccard_get_ether
argument_list|(
name|dev
argument_list|,
name|enaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CIS MAC %6D\n"
argument_list|,
name|enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sum
operator||=
name|enaddr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0
operator|&&
name|ed_pccard_rom_mac
argument_list|(
name|dev
argument_list|,
name|enaddr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ROM mac %6D\n"
argument_list|,
name|enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
literal|0
operator|&&
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_ENADDR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|pccard_attr_read_1
argument_list|(
name|dev
argument_list|,
name|pp
operator|->
name|enoff
operator|+
name|i
operator|*
literal|2
argument_list|,
name|enaddr
operator|+
name|i
argument_list|)
expr_stmt|;
name|sum
operator||=
name|enaddr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hint %x MAC %6D\n"
argument_list|,
name|pp
operator|->
name|enoff
argument_list|,
name|enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|pccard_attr_read_1
argument_list|(
name|dev
argument_list|,
name|ED_DEFAULT_MAC_OFFSET
operator|+
name|i
operator|*
literal|2
argument_list|,
name|enaddr
operator|+
name|i
argument_list|)
expr_stmt|;
name|sum
operator||=
name|enaddr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Fallback MAC %6D\n"
argument_list|,
name|enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot extract MAC address.\n"
argument_list|)
expr_stmt|;
name|ed_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|enaddr
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ed_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_DL10019
operator|||
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_DL10022
condition|)
block|{
comment|/* Probe for an MII bus, but ignore errors. */
name|ed_pccard_dl100xx_mii_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|ed_ifmedia_upd
argument_list|,
name|ed_ifmedia_sts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88190
operator|||
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88790
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|ed_ifmedia_upd
argument_list|,
name|ed_ifmedia_sts
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Missing mii %d!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_TC5299J
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|ed_ifmedia_upd
argument_list|,
name|ed_ifmedia_sts
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Missing mii!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_tick
operator|=
name|ed_pccard_tick
expr_stmt|;
name|sc
operator|->
name|sc_mediachg
operator|=
name|ed_pccard_mediachg
expr_stmt|;
name|sc
operator|->
name|sc_media_ioctl
operator|=
name|ed_pccard_media_ioctl
expr_stmt|;
name|ed_pccard_kick_phy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ed_gen_ifmedia_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|modem_rid
operator|!=
operator|-
literal|1
condition|)
name|ed_pccard_add_modem
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|edintr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"setup intr failed %d \n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|ed_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the Ethernet MAC addrees for PCMCIA Linksys EtherFast 10/100   * and compatible cards (DL10019C Ethernet controller).  */
end_comment

begin_function
specifier|static
name|int
name|ed_pccard_dl100xx
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ed_product
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
name|uint8_t
name|id
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_DL100XX
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Trying DL100xx probing\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_probe_Novell_generic
argument_list|(
name|dev
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Novell generic probe failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Linksys registers(offset from ASIC base) 	 * 	 * 0x04-0x09 : Physical Address Register 0-5 (PAR0-PAR5) 	 * 0x0A      : Card ID Register (CIR) 	 * 0x0B      : Check Sum Register (SR) 	 */
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0x04
init|;
name|i
operator|<
literal|0x0c
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
literal|0xff
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Bad checksum %#x\n"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* invalid DL10019C */
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CIR is %d\n"
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
literal|0xa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
literal|0x04
operator|+
name|i
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_WTS
operator||
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|id
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Hard code values based on the datasheet.  We're NE-2000 compatible 	 * NIC with 24kb of packet memory starting at 24k offset.  These 	 * cards also work with 16k at 16k, but don't work with 24k at 16k 	 * or 32k at 16k. 	 */
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE2000
expr_stmt|;
name|sc
operator|->
name|mem_start
operator|=
literal|24
operator|*
literal|1024
expr_stmt|;
name|memsize
operator|=
name|sc
operator|->
name|mem_size
operator|=
literal|24
operator|*
literal|1024
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|txb_cnt
operator|=
literal|3
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTART
argument_list|,
name|sc
operator|->
name|mem_start
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTOP
argument_list|,
name|sc
operator|->
name|mem_end
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|chip_type
operator|=
operator|(
name|id
operator|&
literal|0x90
operator|)
operator|==
literal|0x90
condition|?
name|ED_CHIP_TYPE_DL10022
else|:
name|ED_CHIP_TYPE_DL10019
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
operator|(
operator|(
name|id
operator|&
literal|0x90
operator|)
operator|==
literal|0x90
operator|)
condition|?
literal|"DL10022"
else|:
literal|"DL10019"
expr_stmt|;
name|sc
operator|->
name|mii_readbits
operator|=
name|ed_pccard_dl100xx_mii_readbits
expr_stmt|;
name|sc
operator|->
name|mii_writebits
operator|=
name|ed_pccard_dl100xx_mii_writebits
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MII bit-twiddling routines for cards using Dlink chipset */
end_comment

begin_define
define|#
directive|define
name|DL100XX_MIISET
parameter_list|(
name|sc
parameter_list|,
name|x
parameter_list|)
value|ed_asic_outb(sc, ED_DL100XX_MIIBUS, \     ed_asic_inb(sc, ED_DL100XX_MIIBUS) | (x))
end_define

begin_define
define|#
directive|define
name|DL100XX_MIICLR
parameter_list|(
name|sc
parameter_list|,
name|x
parameter_list|)
value|ed_asic_outb(sc, ED_DL100XX_MIIBUS, \     ed_asic_inb(sc, ED_DL100XX_MIIBUS)& ~(x))
end_define

begin_function
specifier|static
name|void
name|ed_pccard_dl100xx_mii_reset
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|!=
name|ED_CHIP_TYPE_DL10022
condition|)
return|return;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MIIBUS
argument_list|,
name|ED_DL10022_MII_RESET2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MIIBUS
argument_list|,
name|ED_DL10022_MII_RESET2
operator||
name|ED_DL10022_MII_RESET1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MIIBUS
argument_list|,
name|ED_DL10022_MII_RESET2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MIIBUS
argument_list|,
name|ED_DL10022_MII_RESET2
operator||
name|ED_DL10022_MII_RESET1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MIIBUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_pccard_dl100xx_mii_writebits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|val
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DL100XX_MIISET
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_DIROUT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
name|DL100XX_MIISET
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_DATAOUT
argument_list|)
expr_stmt|;
else|else
name|DL100XX_MIICLR
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_DATAOUT
argument_list|)
expr_stmt|;
name|DL100XX_MIISET
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_CLK
argument_list|)
expr_stmt|;
name|DL100XX_MIICLR
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_CLK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|ed_pccard_dl100xx_mii_readbits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|val
init|=
literal|0
decl_stmt|;
name|DL100XX_MIICLR
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_DIROUT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DL100XX_MIISET
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_CLK
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MIIBUS
argument_list|)
operator|&
name|ED_DL100XX_MII_DATAIN
condition|)
name|val
operator|++
expr_stmt|;
name|DL100XX_MIICLR
argument_list|(
name|sc
argument_list|,
name|ED_DL100XX_MII_CLK
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_pccard_ax88x90_reset
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Reset Card */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
operator||
name|ED_CR_PAGE_0
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait for the RST bit to assert, but cap it at 10ms */
for|for
control|(
name|i
operator|=
literal|10000
init|;
operator|!
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
operator|&&
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
continue|continue;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RST
argument_list|)
expr_stmt|;
comment|/* ACK INTR */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Reset didn't finish\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for ax88x90 boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_ax88x90_generic
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
specifier|static
name|char
name|test_pattern
index|[
literal|32
index|]
init|=
literal|"THIS is A memory TEST pattern"
decl_stmt|;
name|char
name|test_buffer
index|[
literal|32
index|]
decl_stmt|;
name|ed_pccard_ax88x90_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
comment|/* 	 * This prevents packets from being stored in the NIC memory when the 	 * readmem routine turns on the start bit in the CR.  We write some 	 * bytes in word mode and verify we can read them back.  If we can't 	 * then we don't have an AX88x90 chip here. 	 */
name|sc
operator|->
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_MON
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_WTS
operator||
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
literal|16384
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|16384
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Hard code values based on the datasheet.  We're NE-2000 compatible 	 * NIC with 16kb of packet memory starting at 16k offset. 	 */
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE2000
expr_stmt|;
name|memsize
operator|=
name|sc
operator|->
name|mem_size
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
name|sc
operator|->
name|mem_start
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_TEST
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_AX88790
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_AX88190
expr_stmt|;
comment|/* 		 * The AX88190 (not A) has external 64k SRAM.  Probe for this 		 * here.  Most of the cards I have either use the AX88190A 		 * part, or have only 32k SRAM for some reason, so I don't 		 * know if this works or not. 		 */
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
literal|32768
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|32768
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|mem_start
operator|=
literal|2
operator|*
literal|1024
expr_stmt|;
name|memsize
operator|=
name|sc
operator|->
name|mem_size
operator|=
literal|62
operator|*
literal|1024
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_size
operator|>
literal|16
operator|*
literal|1024
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|3
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTART
argument_list|,
name|sc
operator|->
name|mem_start
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTOP
argument_list|,
name|sc
operator|->
name|mem_end
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Get the mac before we go -- It's just at 0x400 in "SRAM" */
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|0x400
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* clear any pending interrupts that might have occurred above */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_pio_write_mbufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_pccard_ax88x90_check_mii
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|id
decl_stmt|;
comment|/* 	 * All AX88x90 devices have MII and a PHY, so we use this to weed out 	 * chips that would otherwise make it through the tests we have after 	 * this point. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|ed_miibus_readreg
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|MII_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
operator|&&
name|id
operator|!=
literal|0xffff
condition|)
break|break;
block|}
comment|/* 	 * Found one, we're good. 	 */
if|if
condition|(
name|i
operator|!=
literal|32
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Didn't find anything, so try to power up and try again.  The PHY 	 * may be not responding because we're in power down mode. 	 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88190
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pccard_ccr_write_1
argument_list|(
name|dev
argument_list|,
name|PCCARD_CCR_STATUS
argument_list|,
name|PCCARD_CCR_STATUS_PWRDWN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|ed_miibus_readreg
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|MII_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
operator|&&
name|id
operator|!=
literal|0xffff
condition|)
break|break;
block|}
comment|/* 	 * Still no joy?  We're AFU, punt. 	 */
if|if
condition|(
name|i
operator|==
literal|32
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Special setup for AX88[17]90  */
end_comment

begin_function
specifier|static
name|int
name|ed_pccard_ax88x90
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ed_product
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|iobase
decl_stmt|;
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_AX88X90
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Checking AX88x90\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the IOBASE Register.  The AX88x90 cards are potentially 	 * multifunction cards, and thus requires a slight workaround. 	 * We write the address the card is at, on the off chance that this 	 * card is not MFC. 	 * XXX I'm not sure that this is still needed... 	 */
name|iobase
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|pccard_ccr_write_1
argument_list|(
name|dev
argument_list|,
name|PCCARD_CCR_IOBASE0
argument_list|,
name|iobase
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pccard_ccr_write_1
argument_list|(
name|dev
argument_list|,
name|PCCARD_CCR_IOBASE1
argument_list|,
operator|(
name|iobase
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mii_readbits
operator|=
name|ed_pccard_ax88x90_mii_readbits
expr_stmt|;
name|sc
operator|->
name|mii_writebits
operator|=
name|ed_pccard_ax88x90_mii_writebits
expr_stmt|;
name|error
operator|=
name|ed_probe_ax88x90_generic
argument_list|(
name|dev
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probe ax88x90 failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|ed_pccard_ax88x90_check_mii
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE2000
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88190
condition|)
name|sc
operator|->
name|type_str
operator|=
literal|"AX88190"
expr_stmt|;
else|else
name|sc
operator|->
name|type_str
operator|=
literal|"AX88790"
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
empty_stmt|;
name|sc
operator|->
name|mii_readbits
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mii_writebits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_pccard_ax88x90_mii_writebits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|val
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|data
operator|=
operator|(
name|val
operator|>>
name|i
operator|)
operator|&
literal|1
condition|?
name|ED_AX88X90_MII_DATAOUT
else|:
literal|0
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_MIIBUS
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_MIIBUS
argument_list|,
name|data
operator||
name|ED_AX88X90_MII_CLK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|ed_pccard_ax88x90_mii_readbits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|val
init|=
literal|0
decl_stmt|;
name|uint8_t
name|mdio
decl_stmt|;
name|mdio
operator|=
name|ED_AX88X90_MII_DIRIN
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_MIIBUS
argument_list|,
name|mdio
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_MIIBUS
argument_list|)
operator|&
name|ED_AX88X90_MII_DATAIN
condition|)
name|val
operator|++
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_MIIBUS
argument_list|,
name|mdio
operator||
name|ED_AX88X90_MII_CLK
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Special setup for TC5299J  */
end_comment

begin_function
specifier|static
name|int
name|ed_pccard_tc5299j
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|ed_product
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|id
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|flags
operator|&
name|NE2000DVF_TC5299J
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Checking Tc5299j\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_probe_Novell_generic
argument_list|(
name|dev
argument_list|,
name|device_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probe novel returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Check to see if we have a MII PHY ID at any address.  All TC5299J 	 * devices have MII and a PHY, so we use this to weed out chips that 	 * would otherwise make it through the tests we have after this point. 	 */
name|sc
operator|->
name|mii_readbits
operator|=
name|ed_pccard_tc5299j_mii_readbits
expr_stmt|;
name|sc
operator|->
name|mii_writebits
operator|=
name|ed_pccard_tc5299j_mii_writebits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|ed_miibus_readreg
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|MII_PHYIDR1
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
operator|&&
name|id
operator|!=
literal|0xffff
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|32
condition|)
block|{
name|sc
operator|->
name|mii_readbits
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mii_writebits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ts
operator|=
literal|"TC5299J"
expr_stmt|;
if|if
condition|(
name|ed_pccard_rom_mac
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|mii_readbits
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mii_writebits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE2000
expr_stmt|;
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_TC5299J
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
name|ts
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_pccard_tc5299j_mii_writebits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|val
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|cr
decl_stmt|,
name|data
decl_stmt|;
comment|/* Select page 3 */
name|cr
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|cr
operator||
name|ED_CR_PAGE_3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|data
operator|=
operator|(
name|val
operator|>>
name|i
operator|)
operator|&
literal|1
condition|?
name|ED_TC5299J_MII_DATAOUT
else|:
literal|0
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|,
name|data
operator||
name|ED_TC5299J_MII_CLK
argument_list|)
expr_stmt|;
block|}
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore prior page */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ed_pccard_tc5299j_mii_readbits
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|val
init|=
literal|0
decl_stmt|;
name|uint8_t
name|cr
decl_stmt|;
comment|/* Select page 3 */
name|cr
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|cr
operator||
name|ED_CR_PAGE_3
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|,
name|ED_TC5299J_MII_DIROUT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nbits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|,
name|ED_TC5299J_MII_CLK
operator||
name|ED_TC5299J_MII_DIROUT
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|)
operator|&
name|ED_TC5299J_MII_DATAIN
condition|)
name|val
operator|++
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_TC5299J_MIIBUS
argument_list|,
name|ED_TC5299J_MII_DIROUT
argument_list|)
expr_stmt|;
block|}
comment|/* Restore prior page */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * MII bus support routines.  */
end_comment

begin_function
specifier|static
name|int
name|ed_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|failed
decl_stmt|,
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * The AX88790 has an interesting quirk.  It has an internal phy that 	 * needs a special bit set to access, but can also have additional 	 * external PHYs set for things like HomeNET media.  When accessing 	 * the internal PHY, a bit has to be set, when accessing the external 	 * PHYs, it must be clear.  See Errata 1, page 51, in the AX88790 	 * datasheet for more details. 	 * 	 * Also, PHYs above 16 appear to be phantoms on some cards, but not 	 * others.  Registers read for this are often the same as prior values 	 * read.  Filter all register requests to 17-31. 	 * 	 * I can't explain it, since I don't have the DL100xx data sheets, but 	 * the DL100xx chips do 13-bits before the 'ACK' but, but the AX88x90 	 * chips have 14.  The linux pcnet and axnet drivers confirm this. 	 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88790
condition|)
block|{
if|if
condition|(
name|phy
operator|>
literal|0x10
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|phy
operator|==
literal|0x10
condition|)
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_GPIO
argument_list|,
name|ED_AX88X90_GPIO_INT_PHY
argument_list|)
expr_stmt|;
else|else
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_GPIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
literal|0xffffffff
argument_list|,
literal|32
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_STARTDELIM
argument_list|,
name|ED_MII_STARTDELIM_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_READOP
argument_list|,
name|ED_MII_OP_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|ED_MII_PHY_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|ED_MII_REG_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88790
operator|||
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88190
condition|)
call|(
modifier|*
name|sc
operator|->
name|mii_readbits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_ACK_BITS
argument_list|)
expr_stmt|;
name|failed
operator|=
call|(
modifier|*
name|sc
operator|->
name|mii_readbits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_ACK_BITS
argument_list|)
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|sc
operator|->
name|mii_readbits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_DATA_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_IDLE
argument_list|,
name|ED_MII_IDLE_BITS
argument_list|)
expr_stmt|;
comment|/*	printf("Reading phy %d reg %#x returning %#x (valid %d)\n", phy, reg, val, !failed); */
return|return
operator|(
name|failed
condition|?
literal|0
else|:
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
comment|/*	printf("Writing phy %d reg %#x data %#x\n", phy, reg, data); */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* See ed_miibus_readreg for details */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88790
condition|)
block|{
if|if
condition|(
name|phy
operator|>
literal|0x10
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|phy
operator|==
literal|0x10
condition|)
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_GPIO
argument_list|,
name|ED_AX88X90_GPIO_INT_PHY
argument_list|)
expr_stmt|;
else|else
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_AX88X90_GPIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
literal|0xffffffff
argument_list|,
literal|32
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_STARTDELIM
argument_list|,
name|ED_MII_STARTDELIM_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_WRITEOP
argument_list|,
name|ED_MII_OP_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|ED_MII_PHY_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|ED_MII_REG_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_TURNAROUND
argument_list|,
name|ED_MII_TURNAROUND_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|ED_MII_DATA_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_IDLE
argument_list|,
name|ED_MII_IDLE_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ED_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_pccard_kick_phy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ED_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
return|return;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_child_detached
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|sc
operator|->
name|miibus
condition|)
name|sc
operator|->
name|miibus
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_pccard_tick
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|media
init|=
literal|0
decl_stmt|;
name|ED_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|media
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
operator|&&
name|media
operator|!=
name|mii
operator|->
name|mii_media_status
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_DL10022
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_DL10022_DIAG
argument_list|,
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FDX
operator|)
condition|?
name|ED_DL10022_COLLISON_DIS
else|:
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_DL10019
condition|)
block|{
name|write_asic
argument_list|(
name|sc
argument_list|,
name|ED_DL10019_MAGIC
argument_list|,
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FDX
operator|)
condition|?
name|DL19FDUPLX
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ed_pccard_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ed_pccard_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ed_pccard_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ed_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_child_detached
argument_list|,
name|ed_child_detached
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|ed_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|ed_miibus_writereg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ed_pccard_driver
init|=
block|{
literal|"ed"
block|,
name|ed_pccard_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ed_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ed
argument_list|,
name|pccard
argument_list|,
name|ed_pccard_driver
argument_list|,
name|ed_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|ed
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ed
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ed
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

