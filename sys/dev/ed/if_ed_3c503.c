begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005, M. Warner Losh  * All rights reserved.  * Copyright (c) 1995, David Greenman   * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ed.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ED_3C503
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_comment
comment|/* XXX: ed_3c503_mediachg() */
end_comment

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edvar.h>
end_include

begin_function_decl
specifier|static
name|void
name|ed_3c503_mediachg
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for 3Com 3c503 boards  */
end_comment

begin_function
name|int
name|ed_probe_3Com
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|u_char
name|isa16bit
decl_stmt|;
name|u_long
name|conf_maddr
decl_stmt|,
name|conf_msize
decl_stmt|,
name|irq
decl_stmt|,
name|junk
decl_stmt|,
name|pmem
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ED_3COM_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_3COM_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_3COM_NIC_OFFSET
expr_stmt|;
comment|/* 	 * Verify that the kernel configured I/O address matches the board 	 * configured address 	 */
switch|switch
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_BCFR
argument_list|)
condition|)
block|{
case|case
name|ED_3COM_BCFR_300
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x300
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_310
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x310
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_330
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x330
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_350
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x350
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_250
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x250
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_280
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x280
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_2A0
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x2a0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_2E0
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x2e0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_maddr
argument_list|,
operator|&
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Verify that the kernel shared memory address matches the board 	 * configured address. 	 */
switch|switch
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_PCFR
argument_list|)
condition|)
block|{
case|case
name|ED_3COM_PCFR_DC000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xdc000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_D8000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xd8000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_CC000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xcc000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_C8000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xc8000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Reset NIC and ASIC. Enable on-board transceiver throughout reset 	 * sequence because it'll lock up if the cable isn't connected if we 	 * don't. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_RST
operator||
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for a while, then un-reset it 	 */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * The 3Com ASIC defaults to rather strange settings for the CR after 	 * a reset - it's important to set it again after the following outb 	 * (this is done when we map the PROM below). 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Wait a bit for the NIC to recover from the reset 	 */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_3COM
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"3c503"
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
comment|/* 	 * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window 	 * to it. 	 */
name|memsize
operator|=
literal|8192
expr_stmt|;
comment|/* 	 * Get station address from on-board ROM 	 */
comment|/* 	 * First, map ethernet address PROM over the top of where the NIC 	 * registers normally appear. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_EALO
operator||
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap PROM - select NIC registers. The proper setting of the 	 * tranceiver is set in ed_init so that the attach code is given a 	 * chance to set the default based on a compile-time config option 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Determine if this is an 8bit or 16bit board 	 */
comment|/* 	 * select page 0 registers 	 */
name|ed_nic_barrier
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_0
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|ed_nic_barrier
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to clear WTS bit. If it doesn't clear, then this is a 16bit 	 * board. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * select page 2 registers 	 */
name|ed_nic_barrier
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_2
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|ed_nic_barrier
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * The 3c503 forces the WTS bit to a one if this is a 16bit board 	 */
if|if
condition|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P2_DCR
argument_list|)
operator|&
name|ED_DCR_WTS
condition|)
name|isa16bit
operator|=
literal|1
expr_stmt|;
else|else
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * select page 0 registers 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P2_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pmem
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_isa_mem_ok
argument_list|(
name|dev
argument_list|,
name|pmem
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mem_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
comment|/* 	 * We have an entire 8k window to put the transmit buffers on the 	 * 16bit boards. But since the 16bit 3c503's shared memory is only 	 * fast enough to overlap the loading of one full-size packet, trying 	 * to load more than 2 buffers can actually leave the transmitter idle 	 * during the load. So 2 seems the best value. (Although a mix of 	 * variable-sized packets might change this assumption. Nonetheless, 	 * we optimize for linear transfers of same-size packets.) 	 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_3COM_TX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_3COM_RX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ED_3COM_RX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_TXBUF_SIZE
operator|+
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|isa16bit
operator|=
name|isa16bit
expr_stmt|;
comment|/* 	 * Initialize GA page start/stop registers. Probably only needed if 	 * doing DMA, but what the hell. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_PSTR
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_PSPR
argument_list|,
name|sc
operator|->
name|rec_page_stop
argument_list|)
expr_stmt|;
comment|/* 	 * Set IRQ. 3c503 only allows a choice of irq 2-5. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|9
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be 3-5,9 for 3c503\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Initialize GA configuration register. Set bank and enable shared 	 * mem. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
operator||
name|ED_3COM_GACFR_MBS0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize "Vector Pointer" registers. These gawd-awful things are 	 * compared to 20 bits of the address on ISA, and if they match, the 	 * shared memory is disabled. We set them to 0xffff0...allegedly the 	 * reset vector. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_VPTR2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_VPTR1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_VPTR0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_clear_memory
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mediachg
operator|=
name|ed_3c503_mediachg
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_shmem_write_mbufs
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_3c503_mediachg
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
comment|/* 	 * If this is a 3Com board, the tranceiver must be software enabled 	 * (there is no settable hardware default). 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ED_3C503 */
end_comment

end_unit

