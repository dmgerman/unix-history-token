begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Device driver for National Semiconductor DS8390/WD83C690 based ethernet  *   adapters. By David Greenman, 29-April-1993  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  *  * Currently supports the Western Digital/SMC 8003 and 8013 series,  *   the SMC Elite Ultra (8216), the 3Com 3c503, the NE1000 and NE2000,  *   and a variety of similar clones.  *  */
end_comment

begin_comment
comment|/*  * $Id: if_ed.c,v 1.35 1994/03/02 05:50:01 davidg Exp $  */
end_comment

begin_include
include|#
directive|include
file|"ed.h"
end_include

begin_if
if|#
directive|if
name|NED
operator|>
literal|0
end_if

begin_comment
comment|/* bpfilter included here in case it is needed in future net includes */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"net/if.h"
end_include

begin_include
include|#
directive|include
file|"net/if_dl.h"
end_include

begin_include
include|#
directive|include
file|"net/if_types.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"net/bpf.h"
end_include

begin_include
include|#
directive|include
file|"net/bpfdesc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/if_edreg.h"
end_include

begin_include
include|#
directive|include
file|"i386/include/pio.h"
end_include

begin_comment
comment|/* For backwards compatibility */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IFF_ALTPHYS
end_ifndef

begin_define
define|#
directive|define
name|IFF_ALTPHYS
value|IFF_LLC0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ed_softc: per line info and status  */
end_comment

begin_struct
struct|struct
name|ed_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* ethernet common */
name|char
modifier|*
name|type_str
decl_stmt|;
comment|/* pointer to type string */
name|u_char
name|vendor
decl_stmt|;
comment|/* interface vendor */
name|u_char
name|type
decl_stmt|;
comment|/* interface type code */
name|u_short
name|asic_addr
decl_stmt|;
comment|/* ASIC I/O bus address */
name|u_short
name|nic_addr
decl_stmt|;
comment|/* NIC (DS8390) I/O bus address */
comment|/*  * The following 'proto' variable is part of a work-around for 8013EBT asics  *	being write-only. It's sort of a prototype/shadow of the real thing.  */
name|u_char
name|wd_laar_proto
decl_stmt|;
name|u_char
name|isa16bit
decl_stmt|;
comment|/* width of access to card 0=8 or 1=16 */
name|int
name|is790
decl_stmt|;
comment|/* set by the probe code if the card is 790 based */
name|caddr_t
name|bpf
decl_stmt|;
comment|/* BPF "magic cookie" */
name|caddr_t
name|mem_start
decl_stmt|;
comment|/* NIC memory start address */
name|caddr_t
name|mem_end
decl_stmt|;
comment|/* NIC memory end address */
name|u_long
name|mem_size
decl_stmt|;
comment|/* total NIC memory size */
name|caddr_t
name|mem_ring
decl_stmt|;
comment|/* start of RX ring-buffer (in NIC mem) */
name|u_char
name|mem_shared
decl_stmt|;
comment|/* NIC memory is shared with host */
name|u_char
name|xmit_busy
decl_stmt|;
comment|/* transmitter is busy */
name|u_char
name|txb_cnt
decl_stmt|;
comment|/* number of transmit buffers */
name|u_char
name|txb_inuse
decl_stmt|;
comment|/* number of TX buffers currently in-use*/
name|u_char
name|txb_new
decl_stmt|;
comment|/* pointer to where new buffer will be added */
name|u_char
name|txb_next_tx
decl_stmt|;
comment|/* pointer to next buffer ready to xmit */
name|u_short
name|txb_len
index|[
literal|8
index|]
decl_stmt|;
comment|/* buffered xmit buffer lengths */
name|u_char
name|tx_page_start
decl_stmt|;
comment|/* first page of TX buffer area */
name|u_char
name|rec_page_start
decl_stmt|;
comment|/* first page of RX ring-buffer */
name|u_char
name|rec_page_stop
decl_stmt|;
comment|/* last page of RX ring-buffer */
name|u_char
name|next_packet
decl_stmt|;
comment|/* pointer to next unread RX packet */
block|}
name|ed_softc
index|[
name|NED
index|]
struct|;
end_struct

begin_function_decl
name|int
name|ed_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ed_init
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|edintr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ed_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ed_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ed_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ed_reset
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ed_watchdog
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_get_packet
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
comment|/*u_short*/
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_stop
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ed_rint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ed_xmit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|char
modifier|*
name|ed_ring_copy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|ed_pio_readmem
argument_list|()
decl_stmt|,
name|ed_pio_writemem
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|u_short
name|ed_pio_write_mbufs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|ether_output
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|trailer_header
block|{
name|u_short
name|ether_type
decl_stmt|;
name|u_short
name|ether_residual
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|isa_driver
name|eddriver
init|=
block|{
name|ed_probe
block|,
name|ed_attach
block|,
literal|"ed"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Interrupt conversion table for WD/SMC ASIC  * (IRQ* are defined in icu.h)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ed_intr_mask
index|[]
init|=
block|{
name|IRQ9
block|,
name|IRQ3
block|,
name|IRQ5
block|,
name|IRQ7
block|,
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ15
block|,
name|IRQ4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Interrupt conversion table for 585/790 Combo  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ed_790_intr_mask
index|[]
init|=
block|{
literal|0
block|,
name|IRQ9
block|,
name|IRQ3
block|,
name|IRQ5
block|,
name|IRQ7
block|,
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ15
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_MAX_LEN
value|1518
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_define
define|#
directive|define
name|ETHER_HDR_SIZE
value|14
end_define

begin_comment
comment|/*  * Determine if the device is present  *  *   on entry:  * 	a pointer to an isa_device struct  *   on exit:  *	NULL if device not found  *	or # of i/o addresses used (if found)  */
end_comment

begin_function
name|int
name|ed_probe
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|nports
decl_stmt|;
if|if
condition|(
name|nports
operator|=
name|ed_probe_WD80x3
argument_list|(
name|isa_dev
argument_list|)
condition|)
return|return
operator|(
name|nports
operator|)
return|;
if|if
condition|(
name|nports
operator|=
name|ed_probe_3Com
argument_list|(
name|isa_dev
argument_list|)
condition|)
return|return
operator|(
name|nports
operator|)
return|;
if|if
condition|(
name|nports
operator|=
name|ed_probe_Novell
argument_list|(
name|isa_dev
argument_list|)
condition|)
return|return
operator|(
name|nports
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic probe routine for testing for the existance of a DS8390.  *	Must be called after the NIC has just been reset. This routine  *	works by looking at certain register values that are gauranteed  *	to be initialized a certain way after power-up or reset. Seems  *	not to currently work on the 83C690.  *  * Specifically:  *  *	Register			reset bits	set bits  *	Command Register (CR)		TXP, STA	RD2, STP  *	Interrupt Status (ISR)				RST  *	Interrupt Mask (IMR)		All bits  *	Data Control (DCR)				LAS  *	Transmit Config. (TCR)		LB1, LB0  *  * We only look at the CR and ISR registers, however, because looking at  *	the others would require changing register pages (which would be  *	intrusive if this isn't an 8390).  *  * Return 1 if 8390 was found, 0 if not.   */
end_comment

begin_function
name|int
name|ed_probe_generic8390
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|)
operator|&
operator|(
name|ED_CR_RD2
operator||
name|ED_CR_TXP
operator||
name|ED_CR_STA
operator||
name|ED_CR_STP
operator|)
operator|)
operator|!=
operator|(
name|ED_CR_RD2
operator||
name|ED_CR_STP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
operator|!=
name|ED_ISR_RST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for SMC/WD80x3 boards  */
end_comment

begin_function
name|int
name|ed_probe_WD80x3
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|u_char
name|iptr
decl_stmt|,
name|isa16bit
decl_stmt|,
name|sum
decl_stmt|;
name|sc
operator|->
name|asic_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|nic_addr
operator|=
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_NIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|is790
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TOSH_ETHER
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_POW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Attempt to do a checksum over the station address PROM. 	 *	If it fails, it's probably not a SMC/WD board. There 	 *	is a problem with this, though: some clone WD boards 	 *	don't pass the checksum test. Danpex boards for one. 	 */
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_PROM
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|ED_WD_ROM_CHECKSUM_TOTAL
condition|)
block|{
comment|/* 		 * Checksum is invalid. This often happens with cheap 		 *	WD8003E clones.  In this case, the checksum byte 		 *	(the eighth byte) seems to always be zero. 		 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_CARD_ID
argument_list|)
operator|!=
name|ED_TYPE_WD8003E
operator|||
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_PROM
operator|+
literal|7
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* reset card to force it into a known state. */
ifdef|#
directive|ifdef
name|TOSH_ETHER
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_RST
operator||
name|ED_WD_MSR_POW
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_RST
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|)
operator|&
operator|~
name|ED_WD_MSR_RST
argument_list|)
expr_stmt|;
comment|/* wait in the case this card is reading it's EEROM */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_WD_SMC
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_CARD_ID
argument_list|)
expr_stmt|;
comment|/* 	 * Set initial values for width/size. 	 */
name|memsize
operator|=
literal|8192
expr_stmt|;
name|isa16bit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE_WD8003S
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003S"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8003E
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003E"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8003EB
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003EB"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8003W
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003W"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EBT
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EBT"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013W
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013W"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EP
case|:
comment|/* also WD8003EP */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_ICR
argument_list|)
operator|&
name|ED_WD_ICR_16BIT
condition|)
block|{
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EP"
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003EP"
expr_stmt|;
block|}
break|break;
case|case
name|ED_TYPE_WD8013WC
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013WC"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EBP
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EBP"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EPC
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EPC"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_SMC8216C
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"SMC8216/SMC8216C"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|is790
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_SMC8216T
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"SMC8216T"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|is790
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TOSH_ETHER
case|case
name|ED_TYPE_TOSHIBA1
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"Toshiba1"
expr_stmt|;
name|memsize
operator|=
literal|32768
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_TOSHIBA4
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"Toshiba4"
expr_stmt|;
name|memsize
operator|=
literal|32768
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|sc
operator|->
name|type_str
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* 	 * Make some adjustments to initial values depending on what is 	 *	found in the ICR. 	 */
if|if
condition|(
name|isa16bit
operator|&&
operator|(
name|sc
operator|->
name|type
operator|!=
name|ED_TYPE_WD8013EBT
operator|)
ifdef|#
directive|ifdef
name|TOSH_ETHER
operator|&&
operator|(
name|sc
operator|->
name|type
operator|!=
name|ED_TYPE_TOSHIBA1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|type
operator|!=
name|ED_TYPE_TOSHIBA4
operator|)
endif|#
directive|endif
operator|&&
operator|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_ICR
argument_list|)
operator|&
name|ED_WD_ICR_16BIT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|isa16bit
operator|=
literal|0
expr_stmt|;
name|memsize
operator|=
literal|8192
expr_stmt|;
block|}
if|#
directive|if
name|ED_DEBUG
name|printf
argument_list|(
literal|"type = %x type_str=%s isa16bit=%d memsize=%d id_msize=%d\n"
argument_list|,
name|sc
operator|->
name|type
argument_list|,
name|sc
operator|->
name|type_str
argument_list|,
name|isa16bit
argument_list|,
name|memsize
argument_list|,
name|isa_dev
operator|->
name|id_msize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x -> %x\n"
argument_list|,
name|i
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allow the user to override the autoconfiguration 	 */
if|if
condition|(
name|isa_dev
operator|->
name|id_msize
condition|)
name|memsize
operator|=
name|isa_dev
operator|->
name|id_msize
expr_stmt|;
comment|/* 	 * (note that if the user specifies both of the following flags 	 *	that '8bit' mode intentionally has precedence) 	 */
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_FORCE_16BIT_MODE
condition|)
name|isa16bit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_FORCE_8BIT_MODE
condition|)
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check 83C584 interrupt configuration register if this board has one 	 *	XXX - we could also check the IO address register. But why 	 *		bother...if we get past this, it *has* to be correct. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|type
operator|&
name|ED_WD_SOFTCONFIG
operator|)
operator|&&
operator|(
operator|!
name|sc
operator|->
name|is790
operator|)
condition|)
block|{
comment|/* 		 * Assemble together the encoded interrupt number. 		 */
name|iptr
operator|=
operator|(
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD_ICR
argument_list|)
operator|&
name|ED_WD_ICR_IR2
operator|)
operator||
operator|(
operator|(
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD_IRR
argument_list|)
operator|&
operator|(
name|ED_WD_IRR_IR0
operator||
name|ED_WD_IRR_IR1
operator|)
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
comment|/* 		 * Translate it using translation table, and check for correctness. 		 */
if|if
condition|(
name|ed_intr_mask
index|[
name|iptr
index|]
operator|!=
name|isa_dev
operator|->
name|id_irq
condition|)
block|{
name|printf
argument_list|(
literal|"ed%d: kernel configured irq %d doesn't match board configured irq %d\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|ffs
argument_list|(
name|isa_dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|ffs
argument_list|(
name|ed_intr_mask
index|[
name|iptr
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Enable the interrupt. 		 */
name|outb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD_IRR
argument_list|,
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD_IRR
argument_list|)
operator||
name|ED_WD_IRR_IEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_HWR
argument_list|,
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_HWR
argument_list|)
operator||
name|ED_WD790_HWR_SWH
argument_list|)
expr_stmt|;
name|iptr
operator|=
operator|(
operator|(
operator|(
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_GCR
argument_list|)
operator|&
name|ED_WD790_GCR_IR2
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_GCR
argument_list|)
operator|&
operator|(
name|ED_WD790_GCR_IR1
operator||
name|ED_WD790_GCR_IR0
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|outb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_HWR
argument_list|,
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_HWR
argument_list|)
operator|&
operator|~
name|ED_WD790_HWR_SWH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed_790_intr_mask
index|[
name|iptr
index|]
operator|!=
name|isa_dev
operator|->
name|id_irq
condition|)
block|{
name|printf
argument_list|(
literal|"ed%d: kernel configured irq %d doesn't match board configured irq %d %d\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|ffs
argument_list|(
name|isa_dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|ffs
argument_list|(
name|ed_790_intr_mask
index|[
name|iptr
index|]
argument_list|)
operator|-
literal|1
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * Enable interrupts. 		 */
name|outb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_ICR
argument_list|,
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_WD790_ICR
argument_list|)
operator||
name|ED_WD790_ICR_EIL
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|isa16bit
operator|=
name|isa16bit
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX - I'm not sure if PIO mode is even possible on WD/SMC boards */
comment|/* 	 * The following allows the WD/SMC boards to be used in Programmed I/O 	 *	mode - without mapping the NIC memory shared. ...Not the prefered 	 *	way, but it might be the only way. 	 */
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_FORCE_PIO
condition|)
block|{
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
name|isa_dev
operator|->
name|id_maddr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|isa_dev
operator|->
name|id_msize
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|caddr_t
operator|)
name|isa_dev
operator|->
name|id_maddr
expr_stmt|;
comment|/* 	 * allocate one xmit buffer if< 16k, two buffers otherwise 	 */
if|if
condition|(
operator|(
name|memsize
operator|<
literal|16384
operator|)
operator|||
operator|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
operator|)
condition|)
block|{
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_TXBUF_SIZE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|*
literal|2
operator|)
expr_stmt|;
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_TXBUF_SIZE
operator|*
literal|2
expr_stmt|;
block|}
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_WD_PAGE_OFFSET
expr_stmt|;
comment|/* 	 * Get station address from on-board ROM 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_PROM
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
block|{
comment|/* 		 * Set address and enable interface shared memory. 		 */
if|if
condition|(
operator|!
name|sc
operator|->
name|is790
condition|)
block|{
ifdef|#
directive|ifdef
name|TOSH_ETHER
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xe0
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
operator|+
literal|2
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
operator||
name|ED_WD_MSR_POW
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|13
operator|)
operator|&
name|ED_WD_MSR_ADDR
operator|)
operator||
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
literal|0x04
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
literal|0x04
argument_list|)
operator||
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
literal|0x0b
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|13
operator|)
operator|&
literal|0x0f
operator|)
operator||
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|11
operator|)
operator|&
literal|0x40
operator|)
operator||
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
literal|0x0b
argument_list|)
operator|&
literal|0xb0
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
literal|0x04
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
literal|0x04
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set upper address bits and 8/16 bit access to shared memory 		 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|sc
operator|->
name|wd_laar_proto
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator|=
name|ED_WD_LAAR_L16EN
operator||
name|ED_WD_LAAR_M16EN
operator||
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|19
operator|)
operator|&
name|ED_WD_LAAR_ADDRHI
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|type
operator|&
name|ED_WD_SOFTCONFIG
operator|)
operator|||
ifdef|#
directive|ifdef
name|TOSH_ETHER
operator|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_TOSHIBA1
operator|)
operator|||
operator|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_TOSHIBA4
operator|)
operator|||
endif|#
directive|endif
operator|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_WD8013EBT
operator|)
operator|&&
operator|(
operator|!
name|sc
operator|->
name|is790
operator|)
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|19
operator|)
operator|&
name|ED_WD_LAAR_ADDRHI
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Now zero memory and verify that it is clear 		 */
name|bzero
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|memsize
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|sc
operator|->
name|mem_start
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ed%d: failed to clear shared memory at %x - check configuration\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Disable 16 bit access to shared memory 				 */
if|if
condition|(
name|isa16bit
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator|&=
operator|~
name|ED_WD_LAAR_M16EN
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Disable 16bit access to shared memory - we leave it disabled so 		 *	that 1) machines reboot properly when the board is set 		 *	16 bit mode and there are conflicting 8bit devices/ROMS 		 *	in the same 128k address space as this boards shared 		 *	memory. and 2) so that other 8 bit devices with shared 		 *	memory can be used in this 128k region, too. 		 */
if|if
condition|(
name|isa16bit
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator|&=
operator|~
name|ED_WD_LAAR_M16EN
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ED_WD_IO_PORTS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for 3Com 3c503 boards  */
end_comment

begin_function
name|int
name|ed_probe_3Com
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|u_char
name|isa16bit
decl_stmt|,
name|sum
decl_stmt|;
name|sc
operator|->
name|asic_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_3COM_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_3COM_NIC_OFFSET
expr_stmt|;
comment|/* 	 * Verify that the kernel configured I/O address matches the board 	 *	configured address 	 */
switch|switch
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_BCFR
argument_list|)
condition|)
block|{
case|case
name|ED_3COM_BCFR_300
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x300
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_310
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x310
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_330
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x330
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_350
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x350
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_250
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x250
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_280
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x280
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_2A0
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x2a0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_2E0
case|:
if|if
condition|(
name|isa_dev
operator|->
name|id_iobase
operator|!=
literal|0x2e0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Verify that the kernel shared memory address matches the 	 *	board configured address. 	 */
switch|switch
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_PCFR
argument_list|)
condition|)
block|{
case|case
name|ED_3COM_PCFR_DC000
case|:
if|if
condition|(
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
operator|!=
literal|0xdc000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_D8000
case|:
if|if
condition|(
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
operator|!=
literal|0xd8000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_CC000
case|:
if|if
condition|(
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
operator|!=
literal|0xcc000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_C8000
case|:
if|if
condition|(
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
operator|!=
literal|0xc8000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Reset NIC and ASIC. Enable on-board transceiver throughout reset 	 *	sequence because it'll lock up if the cable isn't connected 	 *	if we don't. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_RST
operator||
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for a while, then un-reset it 	 */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * The 3Com ASIC defaults to rather strange settings for the CR after 	 *	a reset - it's important to set it again after the following 	 *	outb (this is done when we map the PROM below). 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Wait a bit for the NIC to recover from the reset 	 */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_3COM
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"3c503"
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k 	 *	window to it. 	 */
name|memsize
operator|=
literal|8192
expr_stmt|;
comment|/* 	 * Get station address from on-board ROM 	 */
comment|/* 	 * First, map ethernet address PROM over the top of where the NIC 	 *	registers normally appear. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_EALO
operator||
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap PROM - select NIC registers. The proper setting of the 	 *	tranceiver is set in ed_init so that the attach code 	 *	is given a chance to set the default based on a compile-time 	 *	config option 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Determine if this is an 8bit or 16bit board 	 */
comment|/* 	 * select page 0 registers 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to clear WTS bit. If it doesn't clear, then this is a 	 *	16bit board. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * select page 2 registers 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_2
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * The 3c503 forces the WTS bit to a one if this is a 16bit board 	 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P2_DCR
argument_list|)
operator|&
name|ED_DCR_WTS
condition|)
name|isa16bit
operator|=
literal|1
expr_stmt|;
else|else
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * select page 0 registers 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P2_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|caddr_t
operator|)
name|isa_dev
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
comment|/* 	 * We have an entire 8k window to put the transmit buffers on the 	 *	16bit boards. But since the 16bit 3c503's shared memory 	 *	is only fast enough to overlap the loading of one full-size 	 *	packet, trying to load more than 2 buffers can actually 	 *	leave the transmitter idle during the load. So 2 seems 	 *	the best value. (Although a mix of variable-sized packets 	 *	might change this assumption. Nonetheless, we optimize for 	 *	linear transfers of same-size packets.) 	 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_3COM_TX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_3COM_RX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ED_3COM_RX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_TXBUF_SIZE
operator|+
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|isa16bit
operator|=
name|isa16bit
expr_stmt|;
comment|/* 	 * Initialize GA page start/stop registers. Probably only needed 	 *	if doing DMA, but what the hell. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_PSTR
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_PSPR
argument_list|,
name|sc
operator|->
name|rec_page_stop
argument_list|)
expr_stmt|;
comment|/* 	 * Set IRQ. 3c503 only allows a choice of irq 2-5. 	 */
switch|switch
condition|(
name|isa_dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ2
case|:
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ2
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQ3
case|:
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ3
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQ4
case|:
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ4
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ed%d: Invalid irq configuration (%d) must be 2-5 for 3c503\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|ffs
argument_list|(
name|isa_dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Initialize GA configuration register. Set bank and enable shared mem. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
operator||
name|ED_3COM_GACFR_MBS0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize "Vector Pointer" registers. These gawd-awful things 	 *	are compared to 20 bits of the address on ISA, and if they 	 *	match, the shared memory is disabled. We set them to 	 *	0xffff0...allegedly the reset vector. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_VPTR2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_VPTR1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_VPTR0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Zero memory and verify that it is clear 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|memsize
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|sc
operator|->
name|mem_start
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ed%d: failed to clear shared memory at %x - check configuration\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|isa_dev
operator|->
name|id_msize
operator|=
name|memsize
expr_stmt|;
return|return
operator|(
name|ED_3COM_IO_PORTS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for NE1000/2000 boards  */
end_comment

begin_function
name|int
name|ed_probe_Novell
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|u_int
name|memsize
decl_stmt|,
name|n
decl_stmt|;
name|u_char
name|romdata
index|[
literal|16
index|]
decl_stmt|,
name|isa16bit
init|=
literal|0
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|char
name|test_pattern
index|[
literal|32
index|]
init|=
literal|"THIS is A memory TEST pattern"
decl_stmt|;
name|char
name|test_buffer
index|[
literal|32
index|]
decl_stmt|;
name|sc
operator|->
name|asic_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
comment|/* XXX - do Novell-specific probe here */
comment|/* Reset the board */
name|tmp
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * I don't know if this is necessary; probably cruft leftover from 	 *	Clarkson packet driver code. Doesn't do a thing on the boards 	 *	I've tested. -DG [note that a outb(0x84, 0) seems to work 	 *	here, and is non-invasive...but some boards don't seem to reset 	 *	and I don't have complete documentation on what the 'right' 	 *	thing to do is...so we do the invasive thing for now. Yuck.] 	 */
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_RESET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 *	NIC properly (or the NIC chip doesn't reset fully on power-up) 	 * XXX - this makes the probe invasive! ...Done against my better 	 *	judgement. -DLG 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
name|isa_dev
operator|->
name|id_maddr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Test the ability to read and write to the NIC memory. This has 	 * the side affect of determining if this is an NE1000 or an NE2000. 	 */
comment|/* 	 * This prevents packets from being stored in the NIC memory when 	 *	the readmem routine turns on the start bit in the CR. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_MON
argument_list|)
expr_stmt|;
comment|/* Temporarily initialize DCR for byte operations */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTART
argument_list|,
literal|8192
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTOP
argument_list|,
literal|16384
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Write a test pattern in byte mode. If this fails, then there 	 *	probably isn't any memory at 8k - which likely means 	 *	that the board is an NE2000. 	 */
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
literal|8192
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|8192
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
condition|)
block|{
comment|/* not an NE1000 - try NE2000 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
name|ED_DCR_WTS
operator||
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTART
argument_list|,
literal|16384
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTOP
argument_list|,
literal|32768
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Write a test pattern in word mode. If this also fails, then 		 *	we don't know what this board is. 		 */
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
literal|16384
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|16384
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not an NE2000 either */
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE2000
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"NE2000"
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE1000
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"NE1000"
expr_stmt|;
block|}
comment|/* 8k of memory plus an additional 8k if 16bit */
name|memsize
operator|=
literal|8192
operator|+
name|sc
operator|->
name|isa16bit
operator|*
literal|8192
expr_stmt|;
if|#
directive|if
literal|0
comment|/* probably not useful - NE boards only come two ways */
comment|/* allow kernel config file overrides */
block|if (isa_dev->id_msize) 		memsize = isa_dev->id_msize;
endif|#
directive|endif
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
comment|/* NIC memory doesn't start at zero on an NE board */
comment|/* The start address is tied to the bus width */
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|char
operator|*
operator|)
literal|8192
operator|+
name|sc
operator|->
name|isa16bit
operator|*
literal|8192
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
comment|/* 	 * Use one xmit buffer if< 16k, two buffers otherwise (if not told 	 *	otherwise). 	 */
if|if
condition|(
operator|(
name|memsize
operator|<
literal|16384
operator|)
operator|||
operator|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
operator|)
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|romdata
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ETHER_ADDR_LEN
condition|;
name|n
operator|++
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|n
index|]
operator|=
name|romdata
index|[
name|n
operator|*
operator|(
name|sc
operator|->
name|isa16bit
operator|+
literal|1
operator|)
index|]
expr_stmt|;
comment|/* clear any pending interrupts that might have occurred above */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
name|ED_NOVELL_IO_PORTS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
name|int
name|ed_attach
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
comment|/* 	 * Set interface to stopped condition (reset) 	 */
name|ed_stop
argument_list|(
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|ifp
operator|->
name|if_unit
operator|=
name|isa_dev
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ed"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ed_init
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ed_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ed_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|ed_reset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ed_watchdog
expr_stmt|;
comment|/* 	 * Set default state for ALTPHYS flag (used to disable the tranceiver 	 *	for AUI operation), based on compile-time config option. 	 */
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
name|ED_FLAGS_DISABLE_TRANCEIVER
condition|)
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
operator||
name|IFF_ALTPHYS
operator|)
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
operator|)
expr_stmt|;
comment|/* 	 * Attach the interface 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Search down the ifa address list looking for the AF_LINK type entry 	 */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
comment|/* 	 * If we find an AF_LINK type entry we fill in the hardware address. 	 *	This is useful for netstat(1) to keep track of which interface 	 *	is which. 	 */
if|if
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Fill in the link-level address for this interface 		 */
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Print additional info when attached 	 */
name|printf
argument_list|(
literal|"ed%d: address %s, "
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type_str
operator|&&
operator|(
operator|*
name|sc
operator|->
name|type_str
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"type %s "
argument_list|,
name|sc
operator|->
name|type_str
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"type unknown (0x%x) "
argument_list|,
name|sc
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|sc
operator|->
name|isa16bit
condition|?
literal|"(16 bit)"
else|:
literal|"(8 bit)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_3COM
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|)
condition|?
literal|" tranceiver disabled"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * If BPF is in the kernel, call the attach for it 	 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reset interface.  */
end_comment

begin_function
name|void
name|ed_reset
parameter_list|(
name|unit
parameter_list|,
name|uban
parameter_list|)
name|int
name|unit
decl_stmt|;
name|int
name|uban
decl_stmt|;
comment|/* XXX */
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Stop interface and re-initialize. 	 */
name|ed_stop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ed_init
argument_list|(
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_function
name|void
name|ed_stop
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|n
init|=
literal|5000
decl_stmt|;
comment|/* 	 * Stop everything on the interface, and select page 0 registers. 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_STP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for interface to enter stopped state, but limit # of checks 	 *	to 'n' (about 5ms). It shouldn't even take 5us on modern 	 *	DS8390's, but just in case it's an old one. 	 */
while|while
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|--
name|n
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  *	generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
name|void
name|ed_watchdog
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|unit
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ed%d: device timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
name|ed_reset
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.   */
end_comment

begin_function
name|void
name|ed_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|u_char
name|command
decl_stmt|;
comment|/* address not known */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* 	 * Initialize the NIC in the exact order outlined in the NS manual. 	 *	This init procedure is "mandatory"...don't change what or when 	 *	things happen. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* reset transmitter flags */
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_inuse
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_new
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_next_tx
operator|=
literal|0
expr_stmt|;
comment|/* This variable is used below - don't move this assignment */
name|sc
operator|->
name|next_packet
operator|=
name|sc
operator|->
name|rec_page_start
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Set interface for page 0, Remote DMA complete, Stopped 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_STP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
comment|/* 		 * Set FIFO threshold to 8, No auto-init Remote DMA, 		 *	byte order=80x86, word-wide DMA xfers, 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_WTS
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Same as above, but byte-wide DMA xfers 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear Remote Byte Count Registers 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Enable reception of broadcast packets 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_AB
argument_list|)
expr_stmt|;
comment|/* 	 * Place NIC in internal loopback mode 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TCR
argument_list|,
name|ED_TCR_LB0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize transmit/receive (ring-buffer) Page Start 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TPSR
argument_list|,
name|sc
operator|->
name|tx_page_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTART
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
comment|/* Set lower bits of byte addressable framing to 0 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
literal|0x09
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Receiver (ring-buffer) Page Stop and Boundry 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTOP
argument_list|,
name|sc
operator|->
name|rec_page_stop
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_BNRY
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
comment|/* 	 * Clear all interrupts. A '1' in each bit position clears the 	 *	corresponding flag. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the following interrupts: receive/transmit complete, 	 *	receive/transmit error, and Receiver OverWrite. 	 * 	 * Counter overflow and Remote DMA complete are *not* enabled. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_IMR
argument_list|,
name|ED_IMR_PRXE
operator||
name|ED_IMR_PTXE
operator||
name|ED_IMR_RXEE
operator||
name|ED_IMR_TXEE
operator||
name|ED_IMR_OVWE
argument_list|)
expr_stmt|;
comment|/* 	 * Program Command Register for page 1 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy out our station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_PAR0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Initialize multicast address hashing registers to accept 	 *	 all multicasts (only used when in promiscuous mode) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_MAR0
operator|+
name|i
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set Current Page pointer to next_packet (initialized above) 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CURR
argument_list|,
name|sc
operator|->
name|next_packet
argument_list|)
expr_stmt|;
comment|/* 	 * Set Command Register for page 0, Remote DMA complete, 	 * 	and interface Start. 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CR
argument_list|,
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Take interface out of loopback 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a 3Com board, the tranceiver must be software enabled 	 *	(there is no settable hardware default). 	 */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_3COM
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set 'running' flag, and clear output active flag. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * ...and attempt to start output 	 */
name|ed_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine actually starts the transmission on the interface  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ed_xmit
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
name|len
operator|=
name|sc
operator|->
name|txb_len
index|[
name|sc
operator|->
name|txb_next_tx
index|]
expr_stmt|;
comment|/* 	 * Set NIC for page 0 register access 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set TX buffer start page 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TPSR
argument_list|,
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_next_tx
operator|*
name|ED_TXBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Set TX length 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TBCR0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Set page 0, Remote DMA complete, Transmit Packet, and *Start* 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_TXP
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_TXP
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|xmit_busy
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Point to next transmit buffer slot and wrap if necessary. 	 */
name|sc
operator|->
name|txb_next_tx
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txb_next_tx
operator|==
name|sc
operator|->
name|txb_cnt
condition|)
name|sc
operator|->
name|txb_next_tx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set a timer just in case we never hear from the board again 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
name|void
name|ed_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|;
name|outloop
label|:
comment|/* 	 * First, see if there are buffered packets and an idle 	 *	transmitter - should never happen at this point. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_inuse
operator|&&
operator|(
name|sc
operator|->
name|xmit_busy
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ed: packets buffers, but transmitter idle\n"
argument_list|)
expr_stmt|;
name|ed_xmit
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See if there is room to put another packet in the buffer. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_inuse
operator|==
name|sc
operator|->
name|txb_cnt
condition|)
block|{
comment|/* 		 * No room. Indicate this to the outside world 		 *	and exit. 		 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* 	 * We are using the !OACTIVE flag to indicate to the outside 	 * world that we can accept an additional packet rather than 	 * that the transmitter is _actually_ active. Indeed, the 	 * transmitter may be active, but if we haven't filled all 	 * the buffers with data then we still want to accept more. 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|m0
operator|=
name|m
expr_stmt|;
comment|/* txb_new points to next open buffer slot */
name|buffer
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|sc
operator|->
name|txb_new
operator|*
name|ED_TXBUF_SIZE
operator|*
name|ED_PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
block|{
comment|/* 		 * Special case setup for 16 bit boards... 		 */
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|vendor
condition|)
block|{
comment|/* 			 * For 16bit 3Com boards (which have 16k of memory), 			 *	we have the xmit buffers in a different page 			 *	of memory ('page 0') - so change pages. 			 */
case|case
name|ED_VENDOR_3COM
case|:
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * Enable 16bit access to shared memory on WD/SMC boards 			 *	Don't update wd_laar_proto because we want to restore the 			 *	previous state (because an arp reply in the input code 			 *	may cause a call-back to ed_start) 			 * XXX - the call-back to 'start' is a bug, IMHO. 			 */
case|case
name|ED_VENDOR_WD_SMC
case|:
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator||
name|ED_WD_LAAR_M16EN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* 		 * Restore previous shared memory access 		 */
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|vendor
condition|)
block|{
case|case
name|ED_VENDOR_3COM
case|:
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
operator||
name|ED_3COM_GACFR_MBS0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_VENDOR_WD_SMC
case|:
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|len
operator|=
name|ed_pio_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|txb_len
index|[
name|sc
operator|->
name|txb_new
index|]
operator|=
name|MAX
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txb_inuse
operator|++
expr_stmt|;
comment|/* 	 * Point to next buffer slot and wrap if necessary. 	 */
name|sc
operator|->
name|txb_new
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txb_new
operator|==
name|sc
operator|->
name|txb_cnt
condition|)
name|sc
operator|->
name|txb_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|xmit_busy
operator|==
literal|0
condition|)
name|ed_xmit
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * If there is BPF support in the configuration, tap off here. 	 *   The following has support for converting trailer packets 	 *   back to normal. 	 * XXX - support for trailer packets in BPF should be moved into 	 *	the bpf code proper to avoid code duplication in all of 	 *	the drivers. 	 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|bpf
condition|)
block|{
name|u_short
name|etype
decl_stmt|;
name|int
name|off
decl_stmt|,
name|datasize
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|trailer_header
name|trailer_header
decl_stmt|;
name|char
name|ether_packet
index|[
name|ETHER_MAX_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|ether_packet
expr_stmt|;
comment|/* 		 * We handle trailers below: 		 * Copy ether header first, then residual data, 		 * then data. Put all this in a temporary buffer 		 * 'ether_packet' and send off to bpf. Since the 		 * system has generated this packet, we assume 		 * that all of the offsets in the packet are 		 * correct; if they're not, the system will almost 		 * certainly crash in m_copydata. 		 * We make no assumptions about how the data is 		 * arranged in the mbuf chain (i.e. how much 		 * data is in each mbuf, if mbuf clusters are 		 * used, etc.), which is why we use m_copydata 		 * to get the ether header rather than assume 		 * that this is located in the first mbuf. 		 */
comment|/* copy ether header */
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|ep
expr_stmt|;
name|ep
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|datasize
operator|=
operator|(
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
name|off
operator|=
name|datasize
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* copy trailer_header into a data structure */
name|m_copydata
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|trailer_header
operator|.
name|ether_type
argument_list|)
expr_stmt|;
comment|/* copy residual data */
name|m_copydata
argument_list|(
name|m0
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
name|resid
operator|=
name|ntohs
argument_list|(
name|trailer_header
operator|.
name|ether_residual
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|resid
expr_stmt|;
comment|/* copy data */
name|m_copydata
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|datasize
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|datasize
expr_stmt|;
comment|/* restore original ether packet type */
name|eh
operator|->
name|ether_type
operator|=
name|trailer_header
operator|.
name|ether_type
expr_stmt|;
name|bpf_tap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|ether_packet
argument_list|,
name|ep
operator|-
name|ether_packet
argument_list|)
expr_stmt|;
block|}
else|else
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * Loop back to the top to possibly buffer more packets 	 */
goto|goto
name|outloop
goto|;
block|}
end_function

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ed_rint
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|boundry
decl_stmt|,
name|current
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|struct
name|ed_ring
name|packet_hdr
decl_stmt|;
name|char
modifier|*
name|packet_ptr
decl_stmt|;
comment|/* 	 * Set NIC to page 1 registers to get 'current' pointer 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e. 	 *	it points to where new data has been buffered. The 'CURR' 	 *	(current) register points to the logical end of the ring-buffer 	 *	- i.e. it points to where additional new data will be added. 	 *	We loop here until the logical beginning equals the logical 	 *	end (or in other words, until the ring-buffer is empty). 	 */
while|while
condition|(
name|sc
operator|->
name|next_packet
operator|!=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CURR
argument_list|)
condition|)
block|{
comment|/* get pointer to this buffer's header structure */
name|packet_ptr
operator|=
name|sc
operator|->
name|mem_ring
operator|+
operator|(
name|sc
operator|->
name|next_packet
operator|-
name|sc
operator|->
name|rec_page_start
operator|)
operator|*
name|ED_PAGE_SIZE
expr_stmt|;
comment|/* 		 * The byte count includes the FCS - Frame Check Sequence (a 		 *	32 bit CRC). 		 */
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|packet_hdr
operator|=
operator|*
operator|(
expr|struct
name|ed_ring
operator|*
operator|)
name|packet_ptr
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|packet_ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packet_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|packet_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|packet_hdr
operator|.
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
name|ETHER_MIN_LEN
operator|)
operator|&&
operator|(
name|len
operator|<=
name|ETHER_MAX_LEN
operator|)
condition|)
block|{
comment|/* 			 * Go get packet. len - 4 removes CRC from length. 			 */
name|ed_get_packet
argument_list|(
name|sc
argument_list|,
name|packet_ptr
operator|+
literal|4
argument_list|,
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Really BAD...probably indicates that the ring pointers 			 *	are corrupted. Also seen on early rev chips under 			 *	high load - the byte order of the length gets switched. 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ed%d: NIC memory corrupt - invalid packet length %d\n"
argument_list|,
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
name|ed_reset
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Update next packet pointer 		 */
name|sc
operator|->
name|next_packet
operator|=
name|packet_hdr
operator|.
name|next_packet
expr_stmt|;
comment|/* 		 * Update NIC boundry pointer - being careful to keep it 		 *	one buffer behind. (as recommended by NS databook) 		 */
name|boundry
operator|=
name|sc
operator|->
name|next_packet
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|boundry
operator|<
name|sc
operator|->
name|rec_page_start
condition|)
name|boundry
operator|=
name|sc
operator|->
name|rec_page_stop
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Set NIC to page 0 registers to update boundry register 		 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_BNRY
argument_list|,
name|boundry
argument_list|)
expr_stmt|;
comment|/* 		 * Set NIC to page 1 registers before looping to top (prepare to 		 *	get 'CURR' current pointer) 		 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_function
name|void
name|edintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|isr
decl_stmt|;
comment|/* 	 * Set NIC to page 0 registers 	 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * loop until there are no more new interrupts 	 */
while|while
condition|(
name|isr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
condition|)
block|{
comment|/* 		 * reset all the bits that we are 'acknowledging' 		 *	by writing a '1' to each bit position that was set 		 * (writing a '1' *clears* the bit) 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
name|isr
argument_list|)
expr_stmt|;
comment|/* 		 * Handle transmitter interrupts. Handle these first 		 *	because the receiver will reset the board under 		 *	some conditions. 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ED_ISR_PTX
operator||
name|ED_ISR_TXE
operator|)
condition|)
block|{
name|u_char
name|collisions
init|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_NCR
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
comment|/* 			 * Check for transmit error. If a TX completed with an 			 * error, we end up throwing the packet away. Really 			 * the only error that is possible is excessive 			 * collisions, and in this case it is best to allow the 			 * automatic mechanisms of TCP to backoff the flow. Of 			 * course, with UDP we're screwed, but this is expected 			 * when a network is heavily loaded. 			 */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ED_ISR_TXE
condition|)
block|{
comment|/* 				 * Excessive collisions (16) 				 */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TSR
argument_list|)
operator|&
name|ED_TSR_ABT
operator|)
operator|&&
operator|(
name|collisions
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 					 *    When collisions total 16, the 					 * P0_NCR will indicate 0, and the 					 * TSR_ABT is set. 					 */
name|collisions
operator|=
literal|16
expr_stmt|;
block|}
comment|/* 				 * update output errors counter 				 */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Update total number of successfully 				 * 	transmitted packets. 				 */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
expr_stmt|;
block|}
comment|/* 			 * reset tx busy and output active flags 			 */
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 			 * clear watchdog timer 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Add in total number of collisions on last 			 *	transmission. 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
name|collisions
expr_stmt|;
comment|/* 			 * Decrement buffer in-use count if not zero (can only 			 *	be zero if a transmitter interrupt occured while 			 *	not actually transmitting). 			 * If data is ready to transmit, start it transmitting, 			 *	otherwise defer until after handling receiver 			 */
if|if
condition|(
name|sc
operator|->
name|txb_inuse
operator|&&
operator|--
name|sc
operator|->
name|txb_inuse
condition|)
name|ed_xmit
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle receiver interrupts 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ED_ISR_PRX
operator||
name|ED_ISR_RXE
operator||
name|ED_ISR_OVW
operator|)
condition|)
block|{
comment|/* 		     * Overwrite warning. In order to make sure that a lockup 		     *	of the local DMA hasn't occurred, we reset and 		     *	re-init the NIC. The NSC manual suggests only a 		     *	partial reset/re-init is necessary - but some 		     *	chips seem to want more. The DMA lockup has been 		     *	seen only with early rev chips - Methinks this 		     *	bug was fixed in later revs. -DG 		     */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_OVW
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ed%d: warning - receiver ring buffer overrun\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Stop/reset/re-init NIC 				 */
name|ed_reset
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * Receiver Error. One or more of: CRC error, frame 			     *	alignment error FIFO overrun, or missed packet. 			     */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_RXE
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed%d: receive error %x\n"
argument_list|,
name|unit
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSR
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 				 * Go get the packet(s) 				 * XXX - Doing this on an error is dubious 				 *    because there shouldn't be any data to 				 *    get (we've configured the interface to 				 *    not accept packets with errors). 				 */
comment|/* 				 * Enable 16bit access to shared memory first 				 *	on WD/SMC boards. 				 */
if|if
condition|(
name|sc
operator|->
name|isa16bit
operator|&&
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_WD_SMC
operator|)
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator||=
name|ED_WD_LAAR_M16EN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
block|}
name|ed_rint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* disable 16bit access */
if|if
condition|(
name|sc
operator|->
name|isa16bit
operator|&&
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_WD_SMC
operator|)
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_LAAR
argument_list|,
operator|(
name|sc
operator|->
name|wd_laar_proto
operator|&=
operator|~
name|ED_WD_LAAR_M16EN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_WD_MSR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 * 	attempt to start output on the interface. 		 *	This is done after handling the receiver to 		 *	give the receiver priority. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
name|ed_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
comment|/* 		 * return NIC CR to standard state: page 0, remote DMA complete, 		 * 	start (toggling the TXP bit off, even if was just set 		 *	in the transmit routine, is *okay* - it is 'edge' 		 *	triggered from low to high) 		 */
if|if
condition|(
name|sc
operator|->
name|is790
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the Network Talley Counters overflow, read them to 		 *	reset them. It appears that old 8390's won't 		 *	clear the ISR flag otherwise - resulting in an 		 *	infinite loop. 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_CNT
condition|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CNTR0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CNTR1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CNTR2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  *	pretty ugly.  */
end_comment

begin_function
name|int
name|ed_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|&
name|ed_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ed_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
comment|/* 			 * See if another station has *our* IP address. 			 * i.e.: There is an address conflict! If a 			 * conflict exists, a message is sent to the 			 * console. 			 */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
comment|/* 		 * XXX - This code is probably wrong 		 */
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 *  				 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Set new address 			 */
name|ed_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|ed_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sa_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If interface is marked down and it is running, then stop it 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|ed_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If interface is marked up and it is stopped, then start it 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
name|ed_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 			 * Set promiscuous mode on interface. 			 *	XXX - for multicasts to work, we would need to 			 *		write 1's in all bits of multicast 			 *		hashing array. For now we assume that 			 *		this was done in ed_init(). 			 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_PRO
operator||
name|ED_RCR_AM
operator||
name|ED_RCR_AB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX - for multicasts to work, we would need to 			 *	rewrite the multicast hashing array with the 			 *	proper hash (would have been destroyed above). 			 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_AB
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * An unfortunate hack to provide the (required) software control 		 *	of the tranceiver for 3Com boards. The ALTPHYS flag disables 		 *	the tranceiver if set. 		 */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_3COM
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Macro to calculate a new address within shared memory when given an offset  *	from an address, taking into account ring-wrap.  */
end_comment

begin_define
define|#
directive|define
name|ringoffset
parameter_list|(
name|sc
parameter_list|,
name|start
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
define|\
value|((type)( ((caddr_t)(start)+(off)>= (sc)->mem_end) ? \ 		(((caddr_t)(start)+(off))) - (sc)->mem_end \ 		+ (sc)->mem_ring: \ 		((caddr_t)(start)+(off)) ))
end_define

begin_comment
comment|/*  * Retreive packet from shared memory and send to the next level up via  *	ether_input(). If there is a BPF listener, give a copy to BPF, too.  */
end_comment

begin_function
specifier|static
name|void
name|ed_get_packet
parameter_list|(
name|sc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|u_short
name|len
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|head
init|=
literal|0
decl_stmt|,
modifier|*
name|ed_ring_to_mbuf
argument_list|()
decl_stmt|;
name|u_short
name|off
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|struct
name|trailer_header
name|trailer_header
decl_stmt|;
comment|/* Allocate a header mbuf */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|m
expr_stmt|;
comment|/* The following sillines is to make NFS happy */
define|#
directive|define
name|EROUND
value|((sizeof(struct ether_header) + 3)& ~3)
define|#
directive|define
name|EOFF
value|(EROUND - sizeof(struct ether_header))
comment|/* 	 * The following assumes there is room for 	 * the ether header in the header mbuf 	 */
name|head
operator|->
name|m_data
operator|+=
name|EOFF
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|head
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|head
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|mtod
argument_list|(
name|head
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|head
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with trailer protocol: 	 * If trailer protocol, calculate the datasize as 'off', 	 * which is also the offset to the trailer header. 	 * Set resid to the amount of packet data following the 	 * trailer header. 	 * Finally, copy residual data into mbuf chain. 	 */
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|<<
literal|9
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
operator|)
operator|>
name|len
condition|)
goto|goto
name|bad
goto|;
comment|/* insanity */
comment|/* 		 * If we have shared memory, we can get info directly from the 		 *	stored packet, otherwise we must get a local copy 		 *	of the trailer header using PIO. 		 */
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
block|{
name|eh
operator|->
name|ether_type
operator|=
operator|*
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|trailer_header
name|trailer_header
decl_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|trailer_header
argument_list|,
sizeof|sizeof
argument_list|(
name|trailer_header
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|trailer_header
operator|.
name|ether_type
expr_stmt|;
name|resid
operator|=
name|trailer_header
operator|.
name|ether_residual
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|off
operator|+
name|resid
operator|)
operator|>
name|len
condition|)
goto|goto
name|bad
goto|;
comment|/* insanity */
name|resid
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* insanity */
name|m
operator|=
name|ed_ring_to_mbuf
argument_list|(
name|sc
argument_list|,
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
operator|+
literal|4
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|head
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|len
operator|=
name|off
expr_stmt|;
name|head
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
literal|4
expr_stmt|;
comment|/* subtract trailer header */
block|}
comment|/* 	 * Pull packet off interface. Or if this was a trailer packet, 	 * the data portion is appended. 	 */
name|m
operator|=
name|ed_ring_to_mbuf
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf.  	 */
if|if
condition|(
name|sc
operator|->
name|bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no BPF listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 * 		 * XXX This test does not support multicasts. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Fix up data start offset in mbuf to point past ether header 	 */
name|m_adj
argument_list|(
name|head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * silly ether_input routine needs 'type' in host byte order 	 */
name|eh
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
if|if
condition|(
name|head
condition|)
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Supporting routines  */
end_comment

begin_comment
comment|/*  * Given a NIC memory source address and a host memory destination  *	address, copy 'amount' from NIC to host using Programmed I/O.  *	The 'amount' is rounded up to a word - okay as long as mbufs  *		are word sized.  *	This routine is currently Novell-specific.  */
end_comment

begin_function
name|void
name|ed_pio_readmem
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|short
name|src
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|short
name|amount
decl_stmt|;
block|{
name|unsigned
name|short
name|tmp_amount
decl_stmt|;
comment|/* select page 0 registers */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* round up to a word */
name|tmp_amount
operator|=
name|amount
expr_stmt|;
if|if
condition|(
name|amount
operator|&
literal|1
condition|)
operator|++
name|amount
expr_stmt|;
comment|/* set up DMA byte count */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR0
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR1
argument_list|,
name|amount
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up source address in NIC mem */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSAR0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSAR1
argument_list|,
name|src
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD0
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
name|insw
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
name|dst
argument_list|,
name|amount
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|insb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stripped down routine for writing a linear buffer to NIC memory.  *	Only used in the probe routine to test the memory. 'len' must  *	be even.  */
end_comment

begin_function
name|void
name|ed_pio_writemem
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|len
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|unsigned
name|short
name|dst
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
block|{
name|int
name|maxwait
init|=
literal|100
decl_stmt|;
comment|/* about 120us */
comment|/* select page 0 registers */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* reset remote DMA complete flag */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* set up DMA byte count */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up destination address in NIC mem */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSAR0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSAR1
argument_list|,
name|dst
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set remote DMA write */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
name|outsw
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
name|src
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
else|else
name|outsb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for remote DMA complete. This is necessary because on the 	 *	transmit side, data is handled internally by the NIC in bursts 	 *	and we can't start another remote DMA until this one completes. 	 *	Not waiting causes really bad things to happen - like the NIC 	 *	irrecoverably jamming the ISA bus. 	 */
while|while
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RDC
operator|)
operator|!=
name|ED_ISR_RDC
operator|)
operator|&&
operator|--
name|maxwait
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an mbuf chain to the destination NIC memory address using  *	programmed I/O.  */
end_comment

begin_function
name|u_short
name|ed_pio_write_mbufs
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|short
name|dst
decl_stmt|;
block|{
name|unsigned
name|short
name|len
decl_stmt|,
name|mb_offset
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|unsigned
name|char
name|residual
index|[
literal|2
index|]
decl_stmt|;
name|int
name|maxwait
init|=
literal|100
decl_stmt|;
comment|/* about 120us */
comment|/* First, count up the total number of bytes to copy */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
comment|/* select page 0 registers */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* reset remote DMA complete flag */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* set up DMA byte count */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up destination address in NIC mem */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSAR0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSAR1
argument_list|,
name|dst
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set remote DMA write */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
name|mb_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Transfer the mbuf chain to the NIC memory. 	 * The following code isn't too pretty. The problem is that we can only 	 *	transfer words to the board, and if an mbuf has an odd number 	 *	of bytes in it, this is a problem. It's not a simple matter of 	 *	just removing a byte from the next mbuf (adjusting data++ and 	 *	len--) because this will hose-over the mbuf chain which might 	 *	be needed later for BPF. Instead, we maintain an offset 	 *	(mb_offset) which let's us skip over the first byte in the 	 *	following mbuf. 	 */
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|-
name|mb_offset
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|-
name|mb_offset
operator|)
operator|>
literal|1
condition|)
name|outsw
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mb_offset
argument_list|,
operator|(
name|m
operator|->
name|m_len
operator|-
name|mb_offset
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* 				 * if odd number of bytes, get the odd byte from 				 * the next mbuf with data 				 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|-
name|mb_offset
operator|)
operator|&
literal|1
condition|)
block|{
comment|/* first the last byte in current mbuf */
name|residual
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* advance past any empty mbufs */
while|while
condition|(
name|m
operator|->
name|m_next
operator|&&
operator|(
name|m
operator|->
name|m_next
operator|->
name|m_len
operator|==
literal|0
operator|)
condition|)
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
comment|/* remove first byte in next mbuf */
name|residual
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|caddr_t
argument_list|)
operator|)
expr_stmt|;
name|mb_offset
operator|=
literal|1
expr_stmt|;
block|}
name|outw
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|residual
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|mb_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|outsb
argument_list|(
name|sc
operator|->
name|asic_addr
operator|+
name|ED_NOVELL_DATA
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * Wait for remote DMA complete. This is necessary because on the 	 *	transmit side, data is handled internally by the NIC in bursts 	 *	and we can't start another remote DMA until this one completes. 	 *	Not waiting causes really bad things to happen - like the NIC 	 *	irrecoverably jamming the ISA bus. 	 */
while|while
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RDC
operator|)
operator|!=
name|ED_ISR_RDC
operator|)
operator|&&
operator|--
name|maxwait
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|maxwait
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ed%d: remote transmit DMA failed to complete\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|ed_reset
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a source and destination address, copy 'amount' of a packet from  *	the ring buffer into a linear destination buffer. Takes into account  *	ring-wrap.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|ed_ring_copy
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_short
name|amount
decl_stmt|;
block|{
name|u_short
name|tmp_amount
decl_stmt|;
comment|/* does copy wrap to lower addr in ring buffer? */
if|if
condition|(
name|src
operator|+
name|amount
operator|>
name|sc
operator|->
name|mem_end
condition|)
block|{
name|tmp_amount
operator|=
name|sc
operator|->
name|mem_end
operator|-
name|src
expr_stmt|;
comment|/* copy amount up to end of NIC memory */
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|tmp_amount
argument_list|)
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|tmp_amount
argument_list|)
expr_stmt|;
name|amount
operator|-=
name|tmp_amount
expr_stmt|;
name|src
operator|=
name|sc
operator|->
name|mem_ring
expr_stmt|;
name|dst
operator|+=
name|tmp_amount
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
return|return
operator|(
name|src
operator|+
name|amount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy data from receive buffer to end of mbuf chain  * allocate additional mbufs as needed. return pointer  * to last mbuf in chain.  * sc = ed info (softc)  * src = pointer in ed ring buffer  * dst = pointer to last mbuf in mbuf chain to copy to  * amount = amount of data to copy  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ed_ring_to_mbuf
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|total_len
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dst
decl_stmt|;
name|u_short
name|total_len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|dst
decl_stmt|;
while|while
condition|(
name|total_len
condition|)
block|{
specifier|register
name|u_short
name|amount
init|=
name|min
argument_list|(
name|total_len
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
comment|/* no more data in this mbuf, alloc another */
comment|/* 			 * If there is enough data for an mbuf cluster, attempt 			 * 	to allocate one of those, otherwise, a regular 			 *	mbuf will do. 			 * Note that a regular mbuf is always required, even if 			 *	we get a cluster - getting a cluster does not 			 *	allocate any mbufs, and one is needed to assign 			 *	the cluster to. The mbuf that has a cluster 			 *	extension can not be used to contain data - only 			 *	the cluster can contain data. 			 */
name|dst
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|total_len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|amount
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|ed_ring_copy
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|amount
expr_stmt|;
name|total_len
operator|-=
name|amount
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

