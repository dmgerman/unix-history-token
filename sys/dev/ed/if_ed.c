begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, David Greenman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Device driver for National Semiconductor DS8390/WD83C690 based ethernet  *   adapters. By David Greenman, 29-April-1993  *  * Currently supports the Western Digital/SMC 8003 and 8013 series,  *   the SMC Elite Ultra (8216), the 3Com 3c503, the NE1000 and NE2000,  *   and a variety of similar clones.  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_ed.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
end_ifndef

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bridge.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edvar.h>
end_include

begin_decl_stmt
name|devclass_t
name|ed_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ed_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
end_ifndef

begin_function_decl
specifier|static
name|void
name|ed_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ds_getmcaf
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_get_packet
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
comment|/* u_short */
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ed_rint
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ed_xmit
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|char
modifier|*
name|ed_ring_copy
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
comment|/* u_short */
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_hpp_set_physical_link
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_hpp_readmem
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
comment|/* u_short */
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_hpp_writemem
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
comment|/* u_short */
name|int
parameter_list|,
comment|/* u_short */
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|ed_hpp_write_mbufs
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|ed_pio_write_mbufs
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_setrcr
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|ds_crc
parameter_list|(
name|u_char
modifier|*
name|ep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Interrupt conversion table for WD/SMC ASIC/83C584  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ed_intr_val
index|[]
init|=
block|{
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|15
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Interrupt conversion table for 83C790  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ed_790_intr_val
index|[]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Interrupt conversion table for the HP PC LAN+  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ed_hpp_intr_val
index|[]
init|=
block|{
literal|0
block|,
comment|/* 0 */
literal|0
block|,
comment|/* 1 */
literal|0
block|,
comment|/* 2 */
literal|3
block|,
comment|/* 3 */
literal|4
block|,
comment|/* 4 */
literal|5
block|,
comment|/* 5 */
literal|6
block|,
comment|/* 6 */
literal|7
block|,
comment|/* 7 */
literal|0
block|,
comment|/* 8 */
literal|9
block|,
comment|/* 9 */
literal|10
block|,
comment|/* 10 */
literal|11
block|,
comment|/* 11 */
literal|12
block|,
comment|/* 12 */
literal|0
block|,
comment|/* 13 */
literal|0
block|,
comment|/* 14 */
literal|15
comment|/* 15 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Generic probe routine for testing for the existance of a DS8390.  *	Must be called after the NIC has just been reset. This routine  *	works by looking at certain register values that are guaranteed  *	to be initialized a certain way after power-up or reset. Seems  *	not to currently work on the 83C690.  *  * Specifically:  *  *	Register			reset bits	set bits  *	Command Register (CR)		TXP, STA	RD2, STP  *	Interrupt Status (ISR)				RST  *	Interrupt Mask (IMR)		All bits  *	Data Control (DCR)				LAS  *	Transmit Config. (TCR)		LB1, LB0  *  * We only look at the CR and ISR registers, however, because looking at  *	the others would require changing register pages (which would be  *	intrusive if this isn't an 8390).  *  * Return 1 if 8390 was found, 0 if not.  */
end_comment

begin_function
name|int
name|ed_probe_generic8390
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|)
operator|&
operator|(
name|ED_CR_RD2
operator||
name|ED_CR_TXP
operator||
name|ED_CR_STA
operator||
name|ED_CR_STP
operator|)
operator|)
operator|!=
operator|(
name|ED_CR_RD2
operator||
name|ED_CR_STP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
operator|!=
name|ED_ISR_RST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for SMC/WD80x3 boards  */
end_comment

begin_function
name|int
name|ed_probe_WD80x3_generic
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|intr_vals
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|short
modifier|*
name|intr_vals
index|[]
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|memsize
decl_stmt|,
name|maddr
decl_stmt|;
name|u_char
name|iptr
decl_stmt|,
name|isa16bit
decl_stmt|,
name|sum
decl_stmt|,
name|totalsum
decl_stmt|;
name|u_long
name|conf_maddr
decl_stmt|,
name|conf_msize
decl_stmt|,
name|irq
decl_stmt|,
name|junk
decl_stmt|;
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_DP8390
expr_stmt|;
if|if
condition|(
name|ED_FLAGS_GETTYPE
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_FLAGS_TOSH_ETHER
condition|)
block|{
name|totalsum
operator|=
name|ED_WD_ROM_CHECKSUM_TOTAL_TOSH_ETHER
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_POW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
else|else
name|totalsum
operator|=
name|ED_WD_ROM_CHECKSUM_TOTAL
expr_stmt|;
comment|/* 	 * Attempt to do a checksum over the station address PROM. If it 	 * fails, it's probably not a SMC/WD board. There is a problem with 	 * this, though: some clone WD boards don't pass the checksum test. 	 * Danpex boards for one. 	 */
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_PROM
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|totalsum
condition|)
block|{
comment|/* 		 * Checksum is invalid. This often happens with cheap WD8003E 		 * clones.  In this case, the checksum byte (the eighth byte) 		 * seems to always be zero. 		 */
if|if
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_CARD_ID
argument_list|)
operator|!=
name|ED_TYPE_WD8003E
operator|||
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_PROM
operator|+
literal|7
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* reset card to force it into a known state. */
if|if
condition|(
name|ED_FLAGS_GETTYPE
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_FLAGS_TOSH_ETHER
condition|)
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_RST
operator||
name|ED_WD_MSR_POW
argument_list|)
expr_stmt|;
else|else
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|)
operator|&
operator|~
name|ED_WD_MSR_RST
argument_list|)
expr_stmt|;
comment|/* wait in the case this card is reading its EEROM */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_WD_SMC
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_CARD_ID
argument_list|)
expr_stmt|;
comment|/* 	 * Set initial values for width/size. 	 */
name|memsize
operator|=
literal|8192
expr_stmt|;
name|isa16bit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE_WD8003S
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003S"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8003E
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003E"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8003EB
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003EB"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8003W
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003W"
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EBT
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EBT"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013W
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013W"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EP
case|:
comment|/* also WD8003EP */
if|if
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_ICR
argument_list|)
operator|&
name|ED_WD_ICR_16BIT
condition|)
block|{
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EP"
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"WD8003EP"
expr_stmt|;
block|}
break|break;
case|case
name|ED_TYPE_WD8013WC
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013WC"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EBP
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EBP"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_WD8013EPC
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"WD8013EPC"
expr_stmt|;
name|memsize
operator|=
literal|16384
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_SMC8216C
case|:
comment|/* 8216 has 16K shared mem -- 8416 has 8K */
case|case
name|ED_TYPE_SMC8216T
case|:
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_SMC8216C
condition|)
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"SMC8216/SMC8216C"
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"SMC8216T"
expr_stmt|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|)
operator||
name|ED_WD790_HWR_SWH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_RAR
argument_list|)
operator|&
name|ED_WD790_RAR_SZ64
condition|)
block|{
case|case
name|ED_WD790_RAR_SZ64
case|:
name|memsize
operator|=
literal|65536
expr_stmt|;
break|break;
case|case
name|ED_WD790_RAR_SZ32
case|:
name|memsize
operator|=
literal|32768
expr_stmt|;
break|break;
case|case
name|ED_WD790_RAR_SZ16
case|:
name|memsize
operator|=
literal|16384
expr_stmt|;
break|break;
case|case
name|ED_WD790_RAR_SZ8
case|:
comment|/* 8216 has 16K shared mem -- 8416 has 8K */
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_SMC8216C
condition|)
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"SMC8416C/SMC8416BT"
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"SMC8416T"
expr_stmt|;
block|}
name|memsize
operator|=
literal|8192
expr_stmt|;
break|break;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|)
operator|&
operator|~
name|ED_WD790_HWR_SWH
argument_list|)
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_WD790
expr_stmt|;
break|break;
case|case
name|ED_TYPE_TOSHIBA1
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"Toshiba1"
expr_stmt|;
name|memsize
operator|=
literal|32768
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE_TOSHIBA4
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"Toshiba4"
expr_stmt|;
name|memsize
operator|=
literal|32768
expr_stmt|;
name|isa16bit
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|type_str
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* 	 * Make some adjustments to initial values depending on what is found 	 * in the ICR. 	 */
if|if
condition|(
name|isa16bit
operator|&&
operator|(
name|sc
operator|->
name|type
operator|!=
name|ED_TYPE_WD8013EBT
operator|)
operator|&&
operator|(
name|sc
operator|->
name|type
operator|!=
name|ED_TYPE_TOSHIBA1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|type
operator|!=
name|ED_TYPE_TOSHIBA4
operator|)
operator|&&
operator|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_ICR
argument_list|)
operator|&
name|ED_WD_ICR_16BIT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|isa16bit
operator|=
literal|0
expr_stmt|;
name|memsize
operator|=
literal|8192
expr_stmt|;
block|}
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_maddr
argument_list|,
operator|&
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
name|ED_DEBUG
name|printf
argument_list|(
literal|"type = %x type_str=%s isa16bit=%d memsize=%d id_msize=%d\n"
argument_list|,
name|sc
operator|->
name|type
argument_list|,
name|sc
operator|->
name|type_str
argument_list|,
name|isa16bit
argument_list|,
name|memsize
argument_list|,
name|conf_msize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x -> %x\n"
argument_list|,
name|i
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allow the user to override the autoconfiguration 	 */
if|if
condition|(
name|conf_msize
operator|>
literal|1
condition|)
name|memsize
operator|=
name|conf_msize
expr_stmt|;
name|maddr
operator|=
name|conf_maddr
expr_stmt|;
if|if
condition|(
name|maddr
operator|<
literal|0xa0000
operator|||
name|maddr
operator|+
name|memsize
operator|>
literal|0x1000000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid ISA memory address range configured: 0x%x - 0x%x\n"
argument_list|,
name|maddr
argument_list|,
name|maddr
operator|+
name|memsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * (note that if the user specifies both of the following flags that 	 * '8bit' mode intentionally has precedence) 	 */
if|if
condition|(
name|flags
operator|&
name|ED_FLAGS_FORCE_16BIT_MODE
condition|)
name|isa16bit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ED_FLAGS_FORCE_8BIT_MODE
condition|)
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If possible, get the assigned interrupt number from the card and 	 * use it. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|type
operator|&
name|ED_WD_SOFTCONFIG
operator|)
operator|&&
operator|(
name|sc
operator|->
name|chip_type
operator|!=
name|ED_CHIP_TYPE_WD790
operator|)
condition|)
block|{
comment|/* 		 * Assemble together the encoded interrupt number. 		 */
name|iptr
operator|=
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_ICR
argument_list|)
operator|&
name|ED_WD_ICR_IR2
operator|)
operator||
operator|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_IRR
argument_list|)
operator|&
operator|(
name|ED_WD_IRR_IR0
operator||
name|ED_WD_IRR_IR1
operator|)
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
comment|/* 		 * If no interrupt specified (or "?"), use what the board tells us. 		 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|intr_vals
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|intr_vals
index|[
literal|0
index|]
index|[
name|iptr
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Enable the interrupt. 		 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_IRR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_IRR
argument_list|)
operator||
name|ED_WD_IRR_IEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|)
operator||
name|ED_WD790_HWR_SWH
argument_list|)
expr_stmt|;
name|iptr
operator|=
operator|(
operator|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_GCR
argument_list|)
operator|&
name|ED_WD790_GCR_IR2
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_GCR
argument_list|)
operator|&
operator|(
name|ED_WD790_GCR_IR1
operator||
name|ED_WD790_GCR_IR0
operator|)
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|)
operator|&
operator|~
name|ED_WD790_HWR_SWH
argument_list|)
expr_stmt|;
comment|/* 		 * If no interrupt specified (or "?"), use what the board tells us. 		 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|intr_vals
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|intr_vals
index|[
literal|1
index|]
index|[
name|iptr
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Enable interrupts. 		 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_ICR
argument_list|,
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_ICR
argument_list|)
operator||
name|ED_WD790_ICR_EIL
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s cards don't support auto-detected/assigned interrupts.\n"
argument_list|,
name|sc
operator|->
name|type_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|isa16bit
operator|=
name|isa16bit
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"*** ed_alloc_memory() failed! (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|caddr_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
comment|/* 	 * allocate one xmit buffer if< 16k, two buffers otherwise 	 */
if|if
condition|(
operator|(
name|memsize
operator|<
literal|16384
operator|)
operator|||
operator|(
name|flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
operator|)
condition|)
block|{
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
block|}
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_WD_PAGE_OFFSET
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_WD_PAGE_OFFSET
operator|+
name|ED_TXBUF_SIZE
operator|*
name|sc
operator|->
name|txb_cnt
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|ED_WD_PAGE_OFFSET
operator|+
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|sc
operator|->
name|rec_page_start
operator|)
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
comment|/* 	 * Get station address from on-board ROM 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_PROM
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Set upper address bits and 8/16 bit access to shared memory. 	 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|sc
operator|->
name|wd_laar_proto
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|wd_laar_proto
operator|=
name|ED_WD_LAAR_L16EN
operator||
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|19
operator|)
operator|&
name|ED_WD_LAAR_ADDRHI
operator|)
expr_stmt|;
block|}
comment|/* 		 * Enable 16bit access 		 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator||
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|type
operator|&
name|ED_WD_SOFTCONFIG
operator|)
operator|||
operator|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_TOSHIBA1
operator|)
operator|||
operator|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_TOSHIBA4
operator|)
operator|||
operator|(
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_WD8013EBT
operator|)
operator|)
operator|&&
operator|(
name|sc
operator|->
name|chip_type
operator|!=
name|ED_CHIP_TYPE_WD790
operator|)
condition|)
block|{
name|sc
operator|->
name|wd_laar_proto
operator|=
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|19
operator|)
operator|&
name|ED_WD_LAAR_ADDRHI
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set address and enable interface shared memory. 	 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|!=
name|ED_CHIP_TYPE_WD790
condition|)
block|{
if|if
condition|(
name|ED_FLAGS_GETTYPE
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_FLAGS_TOSH_ETHER
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xe0
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
operator|+
literal|2
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
operator||
name|ED_WD_MSR_POW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|13
operator|)
operator|&
name|ED_WD_MSR_ADDR
operator|)
operator||
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
block|}
else|else
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|,
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|)
operator||
name|ED_WD790_HWR_SWH
operator|)
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_RAR
argument_list|,
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|13
operator|)
operator|&
literal|0x0f
operator|)
operator||
operator|(
operator|(
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|)
operator|>>
literal|11
operator|)
operator|&
literal|0x40
operator|)
operator||
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_RAR
argument_list|)
operator|&
literal|0xb0
operator|)
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|,
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_WD790_HWR
argument_list|)
operator|&
operator|~
name|ED_WD790_HWR_SWH
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("starting memory performance test at 0x%x, size %d...\n", 		sc->mem_start, memsize*16384); 	for (i = 0; i< 16384; i++) 		bzero(sc->mem_start, memsize); 	printf("***DONE***\n");
endif|#
directive|endif
comment|/* 	 * Now zero memory and verify that it is clear 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|memsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mem_start
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to clear shared memory at %lx - check configuration\n"
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Disable 16 bit access to shared memory 			 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator|&
operator|~
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Disable 16bit access to shared memory - we leave it 	 * disabled so that 1) machines reboot properly when the board 	 * is set 16 bit mode and there are conflicting 8bit 	 * devices/ROMS in the same 128k address space as this boards 	 * shared memory. and 2) so that other 8 bit devices with 	 * shared memory can be used in this 128k region, too. 	 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator|&
operator|~
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ed_probe_WD80x3
parameter_list|(
name|dev
parameter_list|,
name|port_rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|port_rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|static
name|unsigned
name|short
modifier|*
name|intr_vals
index|[]
init|=
block|{
name|ed_intr_val
block|,
name|ed_790_intr_val
block|}
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|,
name|ED_WD_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_WD_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_WD_NIC_OFFSET
expr_stmt|;
return|return
name|ed_probe_WD80x3_generic
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|intr_vals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for 3Com 3c503 boards  */
end_comment

begin_function
name|int
name|ed_probe_3Com
parameter_list|(
name|dev
parameter_list|,
name|port_rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|port_rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|u_char
name|isa16bit
decl_stmt|;
name|u_long
name|conf_maddr
decl_stmt|,
name|conf_msize
decl_stmt|,
name|irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ED_3COM_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_3COM_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_3COM_NIC_OFFSET
expr_stmt|;
comment|/* 	 * Verify that the kernel configured I/O address matches the board 	 * configured address 	 */
switch|switch
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_BCFR
argument_list|)
condition|)
block|{
case|case
name|ED_3COM_BCFR_300
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x300
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_310
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x310
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_330
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x330
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_350
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x350
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_250
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x250
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_280
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x280
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_2A0
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x2a0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_BCFR_2E0
case|:
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
literal|0x2e0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_maddr
argument_list|,
operator|&
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Verify that the kernel shared memory address matches the board 	 * configured address. 	 */
switch|switch
condition|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_PCFR
argument_list|)
condition|)
block|{
case|case
name|ED_3COM_PCFR_DC000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xdc000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_D8000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xd8000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_CC000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xcc000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|ED_3COM_PCFR_C8000
case|:
if|if
condition|(
name|conf_maddr
operator|!=
literal|0xc8000
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Reset NIC and ASIC. Enable on-board transceiver throughout reset 	 * sequence because it'll lock up if the cable isn't connected if we 	 * don't. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_RST
operator||
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for a while, then un-reset it 	 */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * The 3Com ASIC defaults to rather strange settings for the CR after 	 * a reset - it's important to set it again after the following outb 	 * (this is done when we map the PROM below). 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Wait a bit for the NIC to recover from the reset 	 */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_3COM
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"3c503"
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
comment|/* 	 * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window 	 * to it. 	 */
name|memsize
operator|=
literal|8192
expr_stmt|;
comment|/* 	 * Get station address from on-board ROM 	 */
comment|/* 	 * First, map ethernet address PROM over the top of where the NIC 	 * registers normally appear. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_EALO
operator||
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap PROM - select NIC registers. The proper setting of the 	 * tranceiver is set in ed_init so that the attach code is given a 	 * chance to set the default based on a compile-time config option 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 	 * Determine if this is an 8bit or 16bit board 	 */
comment|/* 	 * select page 0 registers 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to clear WTS bit. If it doesn't clear, then this is a 16bit 	 * board. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * select page 2 registers 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_2
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * The 3c503 forces the WTS bit to a one if this is a 16bit board 	 */
if|if
condition|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P2_DCR
argument_list|)
operator|&
name|ED_DCR_WTS
condition|)
name|isa16bit
operator|=
literal|1
expr_stmt|;
else|else
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * select page 0 registers 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P2_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|caddr_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
comment|/* 	 * We have an entire 8k window to put the transmit buffers on the 	 * 16bit boards. But since the 16bit 3c503's shared memory is only 	 * fast enough to overlap the loading of one full-size packet, trying 	 * to load more than 2 buffers can actually leave the transmitter idle 	 * during the load. So 2 seems the best value. (Although a mix of 	 * variable-sized packets might change this assumption. Nonetheless, 	 * we optimize for linear transfers of same-size packets.) 	 */
if|if
condition|(
name|isa16bit
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_3COM_TX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_3COM_RX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ED_3COM_RX_PAGE_OFFSET_16BIT
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_TXBUF_SIZE
operator|+
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ED_3COM_TX_PAGE_OFFSET_8BIT
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|isa16bit
operator|=
name|isa16bit
expr_stmt|;
comment|/* 	 * Initialize GA page start/stop registers. Probably only needed if 	 * doing DMA, but what the hell. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_PSTR
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_PSPR
argument_list|,
name|sc
operator|->
name|rec_page_stop
argument_list|)
expr_stmt|;
comment|/* 	 * Set IRQ. 3c503 only allows a choice of irq 2-5. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|9
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_IDCFR
argument_list|,
name|ED_3COM_IDCFR_IRQ5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be 3-5,9 for 3c503\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Initialize GA configuration register. Set bank and enable shared 	 * mem. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
operator||
name|ED_3COM_GACFR_MBS0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize "Vector Pointer" registers. These gawd-awful things are 	 * compared to 20 bits of the address on ISA, and if they match, the 	 * shared memory is disabled. We set them to 0xffff0...allegedly the 	 * reset vector. 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_VPTR2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_VPTR1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_VPTR0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Zero memory and verify that it is clear 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|mem_start
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|memsize
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|sc
operator|->
name|mem_start
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to clear shared memory at %lx - check configuration\n"
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|mem_start
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for NE1000/2000 boards  */
end_comment

begin_function
name|int
name|ed_probe_Novell_generic
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|memsize
decl_stmt|,
name|n
decl_stmt|;
name|u_char
name|romdata
index|[
literal|16
index|]
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|char
name|test_pattern
index|[
literal|32
index|]
init|=
literal|"THIS is A memory TEST pattern"
decl_stmt|;
name|char
name|test_buffer
index|[
literal|32
index|]
decl_stmt|;
comment|/* XXX - do Novell-specific probe here */
comment|/* Reset the board */
if|if
condition|(
name|ED_FLAGS_GETTYPE
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_FLAGS_GWETHER
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * I don't know if this is necessary; probably cruft leftover from 	 * Clarkson packet driver code. Doesn't do a thing on the boards I've 	 * tested. -DG [note that a outb(0x84, 0) seems to work here, and is 	 * non-invasive...but some boards don't seem to reset and I don't have 	 * complete documentation on what the 'right' thing to do is...so we 	 * do the invasive thing for now. Yuck.] 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 * NIC properly (or the NIC chip doesn't reset fully on power-up) XXX 	 * - this makes the probe invasive! ...Done against my better 	 * judgement. -DLG 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
comment|/* 	 * Test the ability to read and write to the NIC memory. This has the 	 * side affect of determining if this is an NE1000 or an NE2000. 	 */
comment|/* 	 * This prevents packets from being stored in the NIC memory when the 	 * readmem routine turns on the start bit in the CR. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_MON
argument_list|)
expr_stmt|;
comment|/* Temporarily initialize DCR for byte operations */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTART
argument_list|,
literal|8192
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTOP
argument_list|,
literal|16384
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Write a test pattern in byte mode. If this fails, then there 	 * probably isn't any memory at 8k - which likely means that the board 	 * is an NE2000. 	 */
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
literal|8192
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|8192
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE1000
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"NE1000"
expr_stmt|;
block|}
else|else
block|{
comment|/* neither an NE1000 nor a Linksys - try NE2000 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_WTS
operator||
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTART
argument_list|,
literal|16384
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTOP
argument_list|,
literal|32768
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Write a test pattern in word mode. If this also fails, then 		 * we don't know what this board is. 		 */
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
literal|16384
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|16384
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_NE2000
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"NE2000"
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* 8k of memory plus an additional 8k if 16bit */
name|memsize
operator|=
literal|8192
operator|+
name|sc
operator|->
name|isa16bit
operator|*
literal|8192
expr_stmt|;
if|#
directive|if
literal|0
comment|/* probably not useful - NE boards only come two ways */
comment|/* allow kernel config file overrides */
block|if (isa_dev->id_msize) 		memsize = isa_dev->id_msize;
endif|#
directive|endif
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
comment|/* NIC memory doesn't start at zero on an NE board */
comment|/* The start address is tied to the bus width */
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|char
operator|*
operator|)
literal|8192
operator|+
name|sc
operator|->
name|isa16bit
operator|*
literal|8192
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|ED_FLAGS_GETTYPE
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_FLAGS_GWETHER
condition|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|,
name|mstart
init|=
literal|0
decl_stmt|,
name|msize
init|=
literal|0
decl_stmt|;
name|char
name|pbuf0
index|[
name|ED_PAGE_SIZE
index|]
decl_stmt|,
name|pbuf
index|[
name|ED_PAGE_SIZE
index|]
decl_stmt|,
name|tbuf
index|[
name|ED_PAGE_SIZE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ED_PAGE_SIZE
condition|;
name|i
operator|++
control|)
name|pbuf0
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Clear all the memory. */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|pbuf0
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Search for the start of RAM. */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pbuf0
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ED_PAGE_SIZE
condition|;
name|i
operator|++
control|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|255
operator|-
name|x
expr_stmt|;
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|pbuf
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pbuf
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mstart
operator|=
name|x
operator|*
name|ED_PAGE_SIZE
expr_stmt|;
name|msize
operator|=
name|ED_PAGE_SIZE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|mstart
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot find start of RAM.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Search for the start of RAM. */
for|for
control|(
name|x
operator|=
operator|(
name|mstart
operator|/
name|ED_PAGE_SIZE
operator|)
operator|+
literal|1
init|;
name|x
operator|<
literal|256
condition|;
name|x
operator|++
control|)
block|{
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pbuf0
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ED_PAGE_SIZE
condition|;
name|i
operator|++
control|)
name|pbuf
index|[
name|i
index|]
operator|=
literal|255
operator|-
name|x
expr_stmt|;
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|pbuf
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|x
operator|*
literal|256
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|pbuf
argument_list|,
name|tbuf
argument_list|,
name|ED_PAGE_SIZE
argument_list|)
operator|==
literal|0
condition|)
name|msize
operator|+=
name|ED_PAGE_SIZE
expr_stmt|;
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|msize
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot find any RAM, start : %d, x = %d.\n"
argument_list|,
name|mstart
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RAM start at %d, size : %d.\n"
argument_list|,
name|mstart
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|msize
expr_stmt|;
name|sc
operator|->
name|mem_start
operator|=
operator|(
name|caddr_t
operator|)
name|mstart
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|msize
operator|+
name|mstart
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|mstart
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 * Use one xmit buffer if< 16k, two buffers otherwise (if not told 	 * otherwise). 	 */
if|if
condition|(
operator|(
name|memsize
operator|<
literal|16384
operator|)
operator|||
operator|(
name|flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
operator|)
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|romdata
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ETHER_ADDR_LEN
condition|;
name|n
operator|++
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|n
index|]
operator|=
name|romdata
index|[
name|n
operator|*
operator|(
name|sc
operator|->
name|isa16bit
operator|+
literal|1
operator|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ED_FLAGS_GETTYPE
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_FLAGS_GWETHER
operator|)
operator|&&
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|==
literal|0x86
operator|)
condition|)
block|{
name|sc
operator|->
name|type_str
operator|=
literal|"Gateway AT"
expr_stmt|;
block|}
comment|/* clear any pending interrupts that might have occurred above */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ed_probe_Novell
parameter_list|(
name|dev
parameter_list|,
name|port_rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|port_rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|,
name|ED_NOVELL_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
return|return
name|ed_probe_Novell_generic
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ED_HPP_TEST_SIZE
value|16
end_define

begin_comment
comment|/*  * Probe and vendor specific initialization for the HP PC Lan+ Cards.  * (HP Part nos: 27247B and 27252A).  *  * The card has an asic wrapper around a DS8390 core.  The asic handles   * host accesses and offers both standard register IO and memory mapped   * IO.  Memory mapped I/O allows better performance at the expense of greater  * chance of an incompatibility with existing ISA cards.  *  * The card has a few caveats: it isn't tolerant of byte wide accesses, only  * short (16 bit) or word (32 bit) accesses are allowed.  Some card revisions  * don't allow 32 bit accesses; these are indicated by a bit in the software  * ID register (see if_edreg.h).  *   * Other caveats are: we should read the MAC address only when the card  * is inactive.  *  * For more information; please consult the CRYNWR packet driver.  *  * The AUI port is turned on using the "link2" option on the ifconfig   * command line.  */
end_comment

begin_function
name|int
name|ed_probe_HP_pclanp
parameter_list|(
name|dev
parameter_list|,
name|port_rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|port_rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* temp var */
name|int
name|memsize
decl_stmt|;
comment|/* mem on board */
name|u_char
name|checksum
decl_stmt|;
comment|/* checksum of board address */
name|u_char
name|irq
decl_stmt|;
comment|/* board configured IRQ */
name|char
name|test_pattern
index|[
name|ED_HPP_TEST_SIZE
index|]
decl_stmt|;
comment|/* read/write areas for */
name|char
name|test_buffer
index|[
name|ED_HPP_TEST_SIZE
index|]
decl_stmt|;
comment|/* probing card */
name|u_long
name|conf_maddr
decl_stmt|,
name|conf_msize
decl_stmt|,
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|ED_HPP_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Fill in basic information */
name|sc
operator|->
name|asic_offset
operator|=
name|ED_HPP_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_HPP_NIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|chip_type
operator|=
name|ED_CHIP_TYPE_DP8390
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|0
expr_stmt|;
comment|/* the 8390 core needs to be in byte mode */
comment|/*  	 * Look for the HP PCLAN+ signature: "0x50,0x48,0x00,0x53"  	 */
if|if
condition|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
argument_list|)
operator|!=
literal|0x50
operator|)
operator|||
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
operator|+
literal|1
argument_list|)
operator|!=
literal|0x48
operator|)
operator|||
operator|(
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
operator|+
literal|2
argument_list|)
operator|&
literal|0xF0
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_ID
operator|+
literal|3
argument_list|)
operator|!=
literal|0x53
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/*  	 * Read the MAC address and verify checksum on the address. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_MAC
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|checksum
operator|=
literal|0
init|;
name|n
operator|<
name|ETHER_ADDR_LEN
condition|;
name|n
operator|++
control|)
name|checksum
operator|+=
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|n
index|]
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_MAC_ADDR
operator|+
name|n
argument_list|)
operator|)
expr_stmt|;
name|checksum
operator|+=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_MAC_ADDR
operator|+
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
literal|0xFF
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * Verify that the software model number is 0. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|hpp_id
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|)
operator|)
operator|&
name|ED_HPP_ID_SOFT_MODEL_MASK
operator|)
operator|!=
literal|0x0000
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * Read in and save the current options configured on card. 	 */
name|sc
operator|->
name|hpp_options
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hpp_options
operator||=
operator|(
name|ED_HPP_OPTION_NIC_RESET
operator||
name|ED_HPP_OPTION_CHIP_RESET
operator||
name|ED_HPP_OPTION_ENABLE_IRQ
operator|)
expr_stmt|;
comment|/*  	 * Reset the chip.  This requires writing to the option register 	 * so take care to preserve the other bits. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
operator|(
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_NIC_RESET
operator||
name|ED_HPP_OPTION_CHIP_RESET
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* wait for chip reset to complete */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
operator|(
name|sc
operator|->
name|hpp_options
operator||
operator|(
name|ED_HPP_OPTION_NIC_RESET
operator||
name|ED_HPP_OPTION_CHIP_RESET
operator||
name|ED_HPP_OPTION_ENABLE_IRQ
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/* reset did not complete */
comment|/* 	 * Read out configuration information. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_HW
argument_list|)
expr_stmt|;
name|irq
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_HPP_HW_IRQ
argument_list|)
expr_stmt|;
comment|/*  	 * Check for impossible IRQ. 	 */
if|if
condition|(
name|irq
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|ed_hpp_intr_val
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ed_hpp_intr_val
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/*  	 * If the kernel IRQ was specified with a '?' use the cards idea 	 * of the IRQ.  If the kernel IRQ was explicitly specified, it  	 * should match that of the hardware. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|ed_hpp_intr_val
index|[
name|irq
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|conf_irq
operator|!=
name|ed_hpp_intr_val
index|[
name|irq
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Fill in softconfig info. 	 */
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_HP
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|ED_TYPE_HP_PCLANPLUS
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"HP-PCLAN+"
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
comment|/* we DON'T have dual ported RAM */
name|sc
operator|->
name|mem_start
operator|=
literal|0
expr_stmt|;
comment|/* we use offsets inside the card RAM */
name|sc
operator|->
name|hpp_mem_start
operator|=
name|NULL
expr_stmt|;
comment|/* no memory mapped I/O by default */
comment|/* 	 * The board has 32KB of memory.  Is there a way to determine 	 * this programmatically? 	 */
name|memsize
operator|=
literal|32768
expr_stmt|;
comment|/* 	 * Check if memory mapping of the I/O registers possible. 	 */
if|if
condition|(
name|sc
operator|->
name|hpp_options
operator|&
name|ED_HPP_OPTION_MEM_ENABLE
condition|)
block|{
name|u_long
name|mem_addr
decl_stmt|;
comment|/* 		 * determine the memory address from the board. 		 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_HW
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
operator|(
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_HW_MEM_MAP
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 		 * Check that the kernel specified start of memory and 		 * hardware's idea of it match. 		 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_maddr
argument_list|,
operator|&
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mem_addr
operator|!=
name|conf_maddr
condition|)
return|return
name|ENXIO
return|;
name|error
operator|=
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|memsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|hpp_mem_start
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the rest of the soft config structure. 	 */
comment|/* 	 * The transmit page index. 	 */
name|sc
operator|->
name|tx_page_start
operator|=
name|ED_HPP_TX_PAGE_OFFSET
expr_stmt|;
if|if
condition|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Memory description 	 */
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|mem_size
expr_stmt|;
comment|/* 	 * Receive area starts after the transmit area and  	 * continues till the end of memory. 	 */
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
operator|(
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
operator|(
name|sc
operator|->
name|mem_size
operator|/
name|ED_PAGE_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
literal|0
expr_stmt|;
comment|/* value works */
comment|/* 	 * Set the wrap registers for string I/O reads. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_HW
argument_list|)
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_HW_WRAP
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|rec_page_start
operator|/
name|ED_PAGE_SIZE
operator|)
operator||
operator|(
operator|(
operator|(
name|sc
operator|->
name|rec_page_stop
operator|/
name|ED_PAGE_SIZE
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the register page to normal operation. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_PERF
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that we can read/write from adapter memory. 	 * Create test pattern. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ED_HPP_TEST_SIZE
condition|;
name|n
operator|++
control|)
block|{
name|test_pattern
index|[
name|n
index|]
operator|=
operator|(
name|n
operator|*
name|n
operator|)
operator|^
operator|~
name|n
expr_stmt|;
block|}
undef|#
directive|undef
name|ED_HPP_TEST_SIZE
comment|/* 	 * Check that the memory is accessible thru the I/O ports. 	 * Write out the contents of "test_pattern", read back 	 * into "test_buffer" and compare the two for any 	 * mismatch. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|32768
operator|/
name|ED_PAGE_SIZE
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|ed_hpp_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
operator|(
name|n
operator|*
name|ED_PAGE_SIZE
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_hpp_readmem
argument_list|(
name|sc
argument_list|,
operator|(
name|n
operator|*
name|ED_PAGE_SIZE
operator|)
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
condition|)
return|return
name|ENXIO
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HP PC Lan+ : Set the physical link to use AUI or TP/TL.  */
end_comment

begin_function
name|void
name|ed_hpp_set_physical_link
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|lan_page
decl_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_LAN
argument_list|)
expr_stmt|;
name|lan_page
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
comment|/* 		 * Use the AUI port. 		 */
name|lan_page
operator||=
name|ED_HPP_LAN_AUI
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_LAN
argument_list|)
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|lan_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Use the ThinLan interface 		 */
name|lan_page
operator|&=
operator|~
name|ED_HPP_LAN_AUI
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_LAN
argument_list|)
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|lan_page
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the lan card to re-initialize itself 	 */
name|DELAY
argument_list|(
literal|150000
argument_list|)
expr_stmt|;
comment|/* wait 150 ms */
comment|/* 	 * Restore normal pages. 	 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGING
argument_list|,
name|ED_HPP_PAGE_PERF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a port resource with the given resource id.  */
end_comment

begin_function
name|int
name|ed_alloc_port
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|size
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|port_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|port_used
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a memory resource with the given resource id.  */
end_comment

begin_function
name|int
name|ed_alloc_memory
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|size
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|mem_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|mem_used
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate an irq resource with the given resource id.  */
end_comment

begin_function
name|int
name|ed_alloc_irq
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|,
name|flags
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
operator|(
name|RF_ACTIVE
operator||
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|irq_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release all resources  */
end_comment

begin_function
name|void
name|ed_release_resources
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
name|int
name|ed_attach
parameter_list|(
name|sc
parameter_list|,
name|unit
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Set interface to stopped condition (reset) 	 */
name|ed_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
operator|->
name|if_name
condition|)
block|{
comment|/* 		 * Initialize ifnet structure 		 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ed"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ed_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ed_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ed_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ed_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|sc
operator|->
name|mibdata
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
name|sc
operator|->
name|mibdata
expr_stmt|;
comment|/* 		 * XXX - should do a better job. 		 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsEtherChipSet
operator|=
name|DOT3CHIPSET
argument_list|(
name|dot3VendorWesternDigital
argument_list|,
name|dot3ChipSetWesternDigital83C790
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsEtherChipSet
operator|=
name|DOT3CHIPSET
argument_list|(
name|dot3VendorNational
argument_list|,
name|dot3ChipSetNational8390
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3Compliance
operator|=
name|DOT3COMPLIANCE_COLLS
expr_stmt|;
comment|/* 		 * Set default state for ALTPHYS flag (used to disable the  		 * tranceiver for AUI operation), based on compile-time  		 * config option. 		 */
if|if
condition|(
name|flags
operator|&
name|ED_FLAGS_DISABLE_TRANCEIVER
condition|)
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator||
name|IFF_ALTPHYS
operator|)
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
comment|/* 		 * Attach the interface 		 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
block|}
comment|/* device attach does transition from UNCONFIGURED to IDLE state */
comment|/* 	 * Print additional info when attached 	 */
name|printf
argument_list|(
literal|"%s%d: address %6D, "
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type_str
operator|&&
operator|(
operator|*
name|sc
operator|->
name|type_str
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"type %s "
argument_list|,
name|sc
operator|->
name|type_str
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"type unknown (0x%x) "
argument_list|,
name|sc
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_HP
condition|)
name|printf
argument_list|(
literal|"(%s %s IO)"
argument_list|,
operator|(
name|sc
operator|->
name|hpp_id
operator|&
name|ED_HPP_ID_16_BIT_ACCESS
operator|)
condition|?
literal|"16-bit"
else|:
literal|"32-bit"
argument_list|,
name|sc
operator|->
name|hpp_mem_start
condition|?
literal|"memory mapped"
else|:
literal|"regular"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|sc
operator|->
name|isa16bit
condition|?
literal|"(16 bit)"
else|:
literal|"(8 bit)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
operator|(
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_3COM
operator|)
operator|||
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_HP
operator|)
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|)
condition|?
literal|" tranceiver disabled"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset interface.  */
end_comment

begin_function
specifier|static
name|void
name|ed_reset
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Stop interface and re-initialize. 	 */
name|ed_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ed_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_function
name|void
name|ed_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|n
init|=
literal|5000
decl_stmt|;
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
name|untimeout
argument_list|(
name|ed_tick
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
comment|/* 	 * Stop everything on the interface, and select page 0 registers. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for interface to enter stopped state, but limit # of checks to 	 * 'n' (about 5ms). It shouldn't even take 5us on modern DS8390's, but 	 * just in case it's an old one. 	 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|!=
name|ED_CHIP_TYPE_AX88190
condition|)
while|while
condition|(
operator|(
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|--
name|n
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  *	generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
specifier|static
name|void
name|ed_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ed%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ed_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
end_ifndef

begin_function
specifier|static
name|void
name|ed_tick
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tick_ch
operator|=
name|timeout
argument_list|(
name|ed_tick
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize device.  */
end_comment

begin_function
specifier|static
name|void
name|ed_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
comment|/* address not known */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
comment|/* unlikely? XXX */
return|return;
comment|/* 	 * Initialize the NIC in the exact order outlined in the NS manual. 	 * This init procedure is "mandatory"...don't change what or when 	 * things happen. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* reset transmitter flags */
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_inuse
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_new
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_next_tx
operator|=
literal|0
expr_stmt|;
comment|/* This variable is used below - don't move this assignment */
name|sc
operator|->
name|next_packet
operator|=
name|sc
operator|->
name|rec_page_start
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Set interface for page 0, Remote DMA complete, Stopped 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
comment|/* 		 * Set FIFO threshold to 8, No auto-init Remote DMA, byte 		 * order=80x86, word-wide DMA xfers, 		 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_WTS
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Same as above, but byte-wide DMA xfers 		 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear Remote Byte Count Registers 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For the moment, don't store incoming packets in memory. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_MON
argument_list|)
expr_stmt|;
comment|/* 	 * Place NIC in internal loopback mode 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TCR
argument_list|,
name|ED_TCR_LB0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize transmit/receive (ring-buffer) Page Start 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TPSR
argument_list|,
name|sc
operator|->
name|tx_page_start
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTART
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
comment|/* Set lower bits of byte addressable framing to 0 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
literal|0x09
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Receiver (ring-buffer) Page Stop and Boundry 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTOP
argument_list|,
name|sc
operator|->
name|rec_page_stop
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_BNRY
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
comment|/* 	 * Clear all interrupts. A '1' in each bit position clears the 	 * corresponding flag. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the following interrupts: receive/transmit complete, 	 * receive/transmit error, and Receiver OverWrite. 	 * 	 * Counter overflow and Remote DMA complete are *not* enabled. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_IMR
argument_list|,
name|ED_IMR_PRXE
operator||
name|ED_IMR_PTXE
operator||
name|ED_IMR_RXEE
operator||
name|ED_IMR_TXEE
operator||
name|ED_IMR_OVWE
argument_list|)
expr_stmt|;
comment|/* 	 * Program Command Register for page 1 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_PAGE_1
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * Copy out our station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P1_PAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set Current Page pointer to next_packet (initialized above) 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P1_CURR
argument_list|,
name|sc
operator|->
name|next_packet
argument_list|)
expr_stmt|;
comment|/* 	 * Program Receiver Configuration Register and multicast filter. CR is 	 * set to page 0 on return. 	 */
name|ed_setrcr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Take interface out of loopback 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a 3Com board, the tranceiver must be software enabled 	 * (there is no settable hardware default). 	 */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_3COM
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Set 'running' flag, and clear output active flag. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * ...and attempt to start output 	 */
name|ed_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
name|untimeout
argument_list|(
name|ed_tick
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tick_ch
operator|=
name|timeout
argument_list|(
name|ed_tick
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine actually starts the transmission on the interface  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ed_xmit
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|sc
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
name|len
operator|=
name|sc
operator|->
name|txb_len
index|[
name|sc
operator|->
name|txb_next_tx
index|]
expr_stmt|;
comment|/* 	 * Set NIC for page 0 register access 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * Set TX buffer start page 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TPSR
argument_list|,
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_next_tx
operator|*
name|ED_TXBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Set TX length 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TBCR0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Set page 0, Remote DMA complete, Transmit Packet, and *Start* 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_TXP
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmit_busy
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Point to next transmit buffer slot and wrap if necessary. 	 */
name|sc
operator|->
name|txb_next_tx
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txb_next_tx
operator|==
name|sc
operator|->
name|txb_cnt
condition|)
name|sc
operator|->
name|txb_next_tx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set a timer just in case we never hear from the board again 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|ed_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|printf
argument_list|(
literal|"ed_start(%p) GONE\n"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
name|outloop
label|:
comment|/* 	 * First, see if there are buffered packets and an idle transmitter - 	 * should never happen at this point. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_inuse
operator|&&
operator|(
name|sc
operator|->
name|xmit_busy
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ed: packets buffered, but transmitter idle\n"
argument_list|)
expr_stmt|;
name|ed_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See if there is room to put another packet in the buffer. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_inuse
operator|==
name|sc
operator|->
name|txb_cnt
condition|)
block|{
comment|/* 		 * No room. Indicate this to the outside world and exit. 		 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We are using the !OACTIVE flag to indicate to the outside 		 * world that we can accept an additional packet rather than 		 * that the transmitter is _actually_ active. Indeed, the 		 * transmitter may be active, but if we haven't filled all the 		 * buffers with data then we still want to accept more. 		 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|m0
operator|=
name|m
expr_stmt|;
comment|/* txb_new points to next open buffer slot */
name|buffer
operator|=
name|sc
operator|->
name|mem_start
operator|+
operator|(
name|sc
operator|->
name|txb_new
operator|*
name|ED_TXBUF_SIZE
operator|*
name|ED_PAGE_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
block|{
comment|/* 		 * Special case setup for 16 bit boards... 		 */
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|vendor
condition|)
block|{
comment|/* 				 * For 16bit 3Com boards (which have 16k of 				 * memory), we have the xmit buffers in a 				 * different page of memory ('page 0') - so 				 * change pages. 				 */
case|case
name|ED_VENDOR_3COM
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
argument_list|)
expr_stmt|;
break|break;
comment|/* 				 * Enable 16bit access to shared memory on 				 * WD/SMC boards. 				 */
case|case
name|ED_VENDOR_WD_SMC
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator||
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* 		 * Restore previous shared memory access 		 */
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|vendor
condition|)
block|{
case|case
name|ED_VENDOR_3COM
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_GACFR
argument_list|,
name|ED_3COM_GACFR_RSEL
operator||
name|ED_3COM_GACFR_MBS0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_VENDOR_WD_SMC
case|:
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator|&
operator|~
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|len
operator|=
name|ed_pio_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
operator|(
name|int
operator|)
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|outloop
goto|;
block|}
name|sc
operator|->
name|txb_len
index|[
name|sc
operator|->
name|txb_new
index|]
operator|=
name|max
argument_list|(
name|len
argument_list|,
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txb_inuse
operator|++
expr_stmt|;
comment|/* 	 * Point to next buffer slot and wrap if necessary. 	 */
name|sc
operator|->
name|txb_new
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txb_new
operator|==
name|sc
operator|->
name|txb_cnt
condition|)
name|sc
operator|->
name|txb_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|xmit_busy
operator|==
literal|0
condition|)
name|ed_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Tap off here if there is a bpf listener. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * Loop back to the top to possibly buffer more packets 	 */
goto|goto
name|outloop
goto|;
block|}
end_function

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ed_rint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|u_char
name|boundry
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|struct
name|ed_ring
name|packet_hdr
decl_stmt|;
name|char
modifier|*
name|packet_ptr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
comment|/* 	 * Set NIC to page 1 registers to get 'current' pointer 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_PAGE_1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * 'sc->next_packet' is the logical beginning of the ring-buffer - 	 * i.e. it points to where new data has been buffered. The 'CURR' 	 * (current) register points to the logical end of the ring-buffer - 	 * i.e. it points to where additional new data will be added. We loop 	 * here until the logical beginning equals the logical end (or in 	 * other words, until the ring-buffer is empty). 	 */
while|while
condition|(
name|sc
operator|->
name|next_packet
operator|!=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P1_CURR
argument_list|)
condition|)
block|{
comment|/* get pointer to this buffer's header structure */
name|packet_ptr
operator|=
name|sc
operator|->
name|mem_ring
operator|+
operator|(
name|sc
operator|->
name|next_packet
operator|-
name|sc
operator|->
name|rec_page_start
operator|)
operator|*
name|ED_PAGE_SIZE
expr_stmt|;
comment|/* 		 * The byte count includes a 4 byte header that was added by 		 * the NIC. 		 */
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|packet_hdr
operator|=
operator|*
operator|(
expr|struct
name|ed_ring
operator|*
operator|)
name|packet_ptr
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
operator|(
name|int
operator|)
name|packet_ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|packet_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|packet_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|packet_hdr
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ed_ring
argument_list|)
operator|)
operator|||
name|len
operator|<
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ed_ring
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Length is a wild value. There's a good chance that 			 * this was caused by the NIC being old and buggy. 			 * The bug is that the length low byte is duplicated in 			 * the high byte. Try to recalculate the length based on 			 * the pointer to the next packet. 			 */
comment|/* 			 * NOTE: sc->next_packet is pointing at the current packet. 			 */
name|len
operator|&=
name|ED_PAGE_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* preserve offset into page */
if|if
condition|(
name|packet_hdr
operator|.
name|next_packet
operator|>=
name|sc
operator|->
name|next_packet
condition|)
block|{
name|len
operator|+=
operator|(
name|packet_hdr
operator|.
name|next_packet
operator|-
name|sc
operator|->
name|next_packet
operator|)
operator|*
name|ED_PAGE_SIZE
expr_stmt|;
block|}
else|else
block|{
name|len
operator|+=
operator|(
operator|(
name|packet_hdr
operator|.
name|next_packet
operator|-
name|sc
operator|->
name|rec_page_start
operator|)
operator|+
operator|(
name|sc
operator|->
name|rec_page_stop
operator|-
name|sc
operator|->
name|next_packet
operator|)
operator|)
operator|*
name|ED_PAGE_SIZE
expr_stmt|;
block|}
comment|/* 			 * because buffers are aligned on 256-byte boundary, 			 * the length computed above is off by 256 in almost 			 * all cases. Fix it... 			 */
if|if
condition|(
name|len
operator|&
literal|0xff
condition|)
name|len
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ed_ring
argument_list|)
operator|)
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsFrameTooLongs
operator|++
expr_stmt|;
block|}
comment|/* 		 * Be fairly liberal about what we allow as a "reasonable" length 		 * so that a [crufty] packet will make it to BPF (and can thus 		 * be analyzed). Note that all that is really important is that 		 * we have a length that will fit into one mbuf cluster or less; 		 * the upper layer protocols can then figure out the length from 		 * their own length field(s). 		 * But make sure that we have at least a full ethernet header 		 * or we would be unable to call ether_input() later. 		 */
if|if
condition|(
operator|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ed_ring
argument_list|)
operator|+
name|ETHER_HDR_LEN
operator|)
operator|&&
operator|(
name|len
operator|<=
name|MCLBYTES
operator|)
operator|&&
operator|(
name|packet_hdr
operator|.
name|next_packet
operator|>=
name|sc
operator|->
name|rec_page_start
operator|)
operator|&&
operator|(
name|packet_hdr
operator|.
name|next_packet
operator|<
name|sc
operator|->
name|rec_page_stop
operator|)
condition|)
block|{
comment|/* 			 * Go get packet. 			 */
name|ed_get_packet
argument_list|(
name|sc
argument_list|,
name|packet_ptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ed_ring
argument_list|)
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ed_ring
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Really BAD. The ring pointers are corrupted. 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ed%d: NIC memory corrupt - invalid packet length %d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|ed_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Update next packet pointer 		 */
name|sc
operator|->
name|next_packet
operator|=
name|packet_hdr
operator|.
name|next_packet
expr_stmt|;
comment|/* 		 * Update NIC boundry pointer - being careful to keep it one 		 * buffer behind. (as recommended by NS databook) 		 */
name|boundry
operator|=
name|sc
operator|->
name|next_packet
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|boundry
operator|<
name|sc
operator|->
name|rec_page_start
condition|)
name|boundry
operator|=
name|sc
operator|->
name|rec_page_stop
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Set NIC to page 0 registers to update boundry register 		 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_BNRY
argument_list|,
name|boundry
argument_list|)
expr_stmt|;
comment|/* 		 * Set NIC to page 1 registers before looping to top (prepare 		 * to get 'CURR' current pointer) 		 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_PAGE_1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_function
name|void
name|edintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ed_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|sc
decl_stmt|;
name|u_char
name|isr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
return|return;
comment|/* 	 * Set NIC to page 0 registers 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * loop until there are no more new interrupts.  When the card 	 * goes away, the hardware will read back 0xff.  Looking at 	 * the interrupts, it would appear that 0xff is impossible, 	 * or at least extremely unlikely. 	 */
while|while
condition|(
operator|(
name|isr
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|isr
operator|!=
literal|0xff
condition|)
block|{
comment|/* 		 * reset all the bits that we are 'acknowledging' by writing a 		 * '1' to each bit position that was set (writing a '1' 		 * *clears* the bit) 		 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|isr
argument_list|)
expr_stmt|;
comment|/*  		 * XXX workaround for AX88190 		 * We limit this to 5000 iterations.  At 1us per inb/outb, 		 * this translates to about 15ms, which should be plenty 		 * of time, and also gives protection in the card eject 		 * case. 		 */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88190
condition|)
block|{
name|count
operator|=
literal|5000
expr_stmt|;
comment|/* 15ms */
while|while
condition|(
name|count
operator|--
operator|&&
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|isr
operator|)
condition|)
block|{
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|isr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 		 * Handle transmitter interrupts. Handle these first because 		 * the receiver will reset the board under some conditions. 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ED_ISR_PTX
operator||
name|ED_ISR_TXE
operator|)
condition|)
block|{
name|u_char
name|collisions
init|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_NCR
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
comment|/* 			 * Check for transmit error. If a TX completed with an 			 * error, we end up throwing the packet away. Really 			 * the only error that is possible is excessive 			 * collisions, and in this case it is best to allow 			 * the automatic mechanisms of TCP to backoff the 			 * flow. Of course, with UDP we're screwed, but this 			 * is expected when a network is heavily loaded. 			 */
operator|(
name|void
operator|)
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|ED_ISR_TXE
condition|)
block|{
name|u_char
name|tsr
decl_stmt|;
comment|/* 				 * Excessive collisions (16) 				 */
name|tsr
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_TSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tsr
operator|&
name|ED_TSR_ABT
operator|)
operator|&&
operator|(
name|collisions
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 					 * When collisions total 16, the 					 * P0_NCR will indicate 0, and the 					 * TSR_ABT is set. 					 */
name|collisions
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tsr
operator|&
name|ED_TSR_OWC
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsLateCollisions
operator|++
expr_stmt|;
if|if
condition|(
name|tsr
operator|&
name|ED_TSR_CDH
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsSQETestErrors
operator|++
expr_stmt|;
if|if
condition|(
name|tsr
operator|&
name|ED_TSR_CRS
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCarrierSenseErrors
operator|++
expr_stmt|;
if|if
condition|(
name|tsr
operator|&
name|ED_TSR_FU
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
comment|/* 				 * update output errors counter 				 */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Update total number of successfully 				 * transmitted packets. 				 */
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
comment|/* 			 * reset tx busy and output active flags 			 */
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 			 * clear watchdog timer 			 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Add in total number of collisions on last 			 * transmission. 			 */
name|ifp
operator|->
name|if_collisions
operator|+=
name|collisions
expr_stmt|;
switch|switch
condition|(
name|collisions
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|16
case|:
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|collisions
operator|-
literal|1
index|]
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 			 * Decrement buffer in-use count if not zero (can only 			 * be zero if a transmitter interrupt occured while 			 * not actually transmitting). If data is ready to 			 * transmit, start it transmitting, otherwise defer 			 * until after handling receiver 			 */
if|if
condition|(
name|sc
operator|->
name|txb_inuse
operator|&&
operator|--
name|sc
operator|->
name|txb_inuse
condition|)
name|ed_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle receiver interrupts 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ED_ISR_PRX
operator||
name|ED_ISR_RXE
operator||
name|ED_ISR_OVW
operator|)
condition|)
block|{
comment|/* 			 * Overwrite warning. In order to make sure that a 			 * lockup of the local DMA hasn't occurred, we reset 			 * and re-init the NIC. The NSC manual suggests only a 			 * partial reset/re-init is necessary - but some chips 			 * seem to want more. The DMA lockup has been seen 			 * only with early rev chips - Methinks this bug was 			 * fixed in later revs. -DG 			 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_OVW
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ed%d: warning - receiver ring buffer overrun\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Stop/reset/re-init NIC 				 */
name|ed_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Receiver Error. One or more of: CRC error, 				 * frame alignment error FIFO overrun, or 				 * missed packet. 				 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_RXE
condition|)
block|{
name|u_char
name|rsr
decl_stmt|;
name|rsr
operator|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsr
operator|&
name|ED_RSR_CRC
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
if|if
condition|(
name|rsr
operator|&
name|ED_RSR_FAE
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
if|if
condition|(
name|rsr
operator|&
name|ED_RSR_FO
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed%d: receive error %x\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSR
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 				 * Go get the packet(s) XXX - Doing this on an 				 * error is dubious because there shouldn't be 				 * any data to get (we've configured the 				 * interface to not accept packets with 				 * errors). 				 */
comment|/* 				 * Enable 16bit access to shared memory first 				 * on WD/SMC boards. 				 */
if|if
condition|(
name|sc
operator|->
name|isa16bit
operator|&&
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_WD_SMC
operator|)
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator||
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
name|ED_WD_MSR_MENB
argument_list|)
expr_stmt|;
block|}
block|}
name|ed_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* disable 16bit access */
if|if
condition|(
name|sc
operator|->
name|isa16bit
operator|&&
operator|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_WD_SMC
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_WD790
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_MSR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_WD_LAAR
argument_list|,
name|sc
operator|->
name|wd_laar_proto
operator|&
operator|~
name|ED_WD_LAAR_M16EN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 * attempt to start output on the interface. This is done 		 * after handling the receiver to give the receiver priority. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
name|ed_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 		 * return NIC CR to standard state: page 0, remote DMA 		 * complete, start (toggling the TXP bit off, even if was just 		 * set in the transmit routine, is *okay* - it is 'edge' 		 * triggered from low to high) 		 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 		 * If the Network Talley Counters overflow, read them to reset 		 * them. It appears that old 8390's won't clear the ISR flag 		 * otherwise - resulting in an infinite loop. 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_CNT
condition|)
block|{
operator|(
name|void
operator|)
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CNTR0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CNTR1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CNTR2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  *	pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|ed_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
endif|#
directive|endif
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|gone
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ed_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ed_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
block|}
comment|/* 		 * Promiscuous flag may have changed, so reprogram the RCR. 		 */
name|ed_setrcr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * An unfortunate hack to provide the (required) software 		 * control of the tranceiver for 3Com boards. The ALTPHYS flag 		 * disables the tranceiver if set. 		 */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_3COM
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_3COM_CR
argument_list|,
name|ED_3COM_CR_XSEL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_HP
condition|)
name|ed_hpp_set_physical_link
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
name|ed_setrcr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
if|if
condition|(
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a source and destination address, copy 'amount' of a packet from  *	the ring buffer into a linear destination buffer. Takes into account  *	ring-wrap.  */
end_comment

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|ed_ring_copy
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_short
name|amount
decl_stmt|;
block|{
name|u_short
name|tmp_amount
decl_stmt|;
comment|/* does copy wrap to lower addr in ring buffer? */
if|if
condition|(
name|src
operator|+
name|amount
operator|>
name|sc
operator|->
name|mem_end
condition|)
block|{
name|tmp_amount
operator|=
name|sc
operator|->
name|mem_end
operator|-
name|src
expr_stmt|;
comment|/* copy amount up to end of NIC memory */
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|tmp_amount
argument_list|)
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
operator|(
name|int
operator|)
name|src
argument_list|,
name|dst
argument_list|,
name|tmp_amount
argument_list|)
expr_stmt|;
name|amount
operator|-=
name|tmp_amount
expr_stmt|;
name|src
operator|=
name|sc
operator|->
name|mem_ring
expr_stmt|;
name|dst
operator|+=
name|tmp_amount
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem_shared
condition|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
else|else
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
operator|(
name|int
operator|)
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
return|return
operator|(
name|src
operator|+
name|amount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retreive packet from shared memory and send to the next level up via  * ether_input().  */
end_comment

begin_function
specifier|static
name|void
name|ed_get_packet
parameter_list|(
name|sc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|u_short
name|len
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* Allocate a header mbuf */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	 * We always put the received packet in a single buffer - 	 * either with just an mbuf header or in a cluster attached 	 * to the header. The +2 is to compensate for the alignment 	 * fixup below. 	 */
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|>
name|MHLEN
condition|)
block|{
comment|/* Attach an mbuf cluster */
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
comment|/* Insist on getting a cluster */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * The +2 is to longword align the start of the real packet. 	 * This is important for NFS. 	 */
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Don't read in the entire packet if we know we're going to drop it 	 * and no bpf is active. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
operator|&&
name|BDG_ACTIVE
argument_list|(
operator|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|)
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|bif
decl_stmt|;
name|ed_ring_copy
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|eh
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_in_ptr
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|BDG_DROP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|>
name|ETHER_HDR_LEN
condition|)
name|ed_ring_copy
argument_list|(
name|sc
argument_list|,
name|buf
operator|+
name|ETHER_HDR_LEN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
argument_list|,
name|len
operator|-
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 		 * Get packet, including link layer address, from interface. 		 */
name|ed_ring_copy
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|eh
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Remove link layer address. 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Supporting routines  */
end_comment

begin_comment
comment|/*  * Given a NIC memory source address and a host memory destination  *	address, copy 'amount' from NIC to host using Programmed I/O.  *	The 'amount' is rounded up to a word - okay as long as mbufs  *		are word sized.  *	This routine is currently Novell-specific.  */
end_comment

begin_function
name|void
name|ed_pio_readmem
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|src
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|short
name|amount
decl_stmt|;
block|{
comment|/* HP PC Lan+ cards need special handling */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_HP
operator|&&
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_HP_PCLANPLUS
condition|)
block|{
name|ed_hpp_readmem
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Regular Novell cards */
comment|/* select page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* round up to a word */
if|if
condition|(
name|amount
operator|&
literal|1
condition|)
operator|++
name|amount
expr_stmt|;
comment|/* set up DMA byte count */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR0
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR1
argument_list|,
name|amount
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up source address in NIC mem */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSAR0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSAR1
argument_list|,
name|src
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD0
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
name|ed_asic_insw
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
name|dst
argument_list|,
name|amount
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ed_asic_insb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stripped down routine for writing a linear buffer to NIC memory.  *	Only used in the probe routine to test the memory. 'len' must  *	be even.  */
end_comment

begin_function
name|void
name|ed_pio_writemem
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|len
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|unsigned
name|short
name|dst
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
block|{
name|int
name|maxwait
init|=
literal|200
decl_stmt|;
comment|/* about 240us */
comment|/* select page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* reset remote DMA complete flag */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* set up DMA byte count */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up destination address in NIC mem */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSAR0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSAR1
argument_list|,
name|dst
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set remote DMA write */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isa16bit
condition|)
block|{
name|ed_asic_outsw
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
name|src
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ed_asic_outsb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for remote DMA complete. This is necessary because on the 	 * transmit side, data is handled internally by the NIC in bursts and 	 * we can't start another remote DMA until this one completes. Not 	 * waiting causes really bad things to happen - like the NIC 	 * irrecoverably jamming the ISA bus. 	 */
while|while
condition|(
operator|(
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RDC
operator|)
operator|!=
name|ED_ISR_RDC
operator|)
operator|&&
operator|--
name|maxwait
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an mbuf chain to the destination NIC memory address using  *	programmed I/O.  */
end_comment

begin_function
specifier|static
name|u_short
name|ed_pio_write_mbufs
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|dst
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|sc
decl_stmt|;
name|unsigned
name|short
name|total_len
decl_stmt|,
name|dma_len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|int
name|maxwait
init|=
literal|200
decl_stmt|;
comment|/* about 240us */
comment|/* HP PC Lan+ cards need special handling */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|ED_VENDOR_HP
operator|&&
name|sc
operator|->
name|type
operator|==
name|ED_TYPE_HP_PCLANPLUS
condition|)
block|{
return|return
name|ed_hpp_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|dst
argument_list|)
return|;
block|}
comment|/* Regular Novell cards */
comment|/* First, count up the total number of bytes to copy */
for|for
control|(
name|total_len
operator|=
literal|0
operator|,
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|total_len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
name|dma_len
operator|=
name|total_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|isa16bit
operator|&&
operator|(
name|dma_len
operator|&
literal|1
operator|)
condition|)
name|dma_len
operator|++
expr_stmt|;
comment|/* select page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* reset remote DMA complete flag */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* set up DMA byte count */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR0
argument_list|,
name|dma_len
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RBCR1
argument_list|,
name|dma_len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up destination address in NIC mem */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSAR0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RSAR1
argument_list|,
name|dst
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set remote DMA write */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD1
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/*    * Transfer the mbuf chain to the NIC memory.    * 16-bit cards require that data be transferred as words, and only words.    * So that case requires some extra code to patch over odd-length mbufs.    */
if|if
condition|(
operator|!
name|sc
operator|->
name|isa16bit
condition|)
block|{
comment|/* NE1000s are easy */
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
condition|)
block|{
name|ed_asic_outsb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* NE2000s are a pain */
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|,
name|wantbyte
decl_stmt|;
name|unsigned
name|char
name|savebyte
index|[
literal|2
index|]
decl_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* finish the last word */
if|if
condition|(
name|wantbyte
condition|)
block|{
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|ed_asic_outsw
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* save last byte, if necessary */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|wantbyte
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* spit last byte */
if|if
condition|(
name|wantbyte
condition|)
block|{
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_DATA
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Wait for remote DMA complete. This is necessary because on the 	 * transmit side, data is handled internally by the NIC in bursts and 	 * we can't start another remote DMA until this one completes. Not 	 * waiting causes really bad things to happen - like the NIC 	 * irrecoverably jamming the ISA bus. 	 */
while|while
condition|(
operator|(
operator|(
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RDC
operator|)
operator|!=
name|ED_ISR_RDC
operator|)
operator|&&
operator|--
name|maxwait
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|maxwait
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ed%d: remote transmit DMA failed to complete\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ed_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|total_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support routines to handle the HP PC Lan+ card.  */
end_comment

begin_comment
comment|/*  * HP PC Lan+: Read from NIC memory, using either PIO or memory mapped  * IO.  */
end_comment

begin_function
specifier|static
name|void
name|ed_hpp_readmem
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|short
name|src
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|short
name|amount
decl_stmt|;
block|{
name|int
name|use_32bit_access
init|=
operator|!
operator|(
name|sc
operator|->
name|hpp_id
operator|&
name|ED_HPP_ID_16_BIT_ACCESS
operator|)
decl_stmt|;
comment|/* Program the source address in RAM */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_2
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* 	 * The HP PC Lan+ card supports word reads as well as 	 * a memory mapped i/o port that is aliased to every  	 * even address on the board. 	 */
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
block|{
comment|/* Enable memory mapped access.  */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_MEM_DISABLE
operator||
name|ED_HPP_OPTION_BOOT_ROM_ENB
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_32bit_access
operator|&&
operator|(
name|amount
operator|>
literal|3
operator|)
condition|)
block|{
name|u_int32_t
modifier|*
name|dl
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|dst
decl_stmt|;
specifier|volatile
name|u_int32_t
modifier|*
specifier|const
name|sl
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|u_int32_t
modifier|*
specifier|const
name|fence
init|=
name|dl
operator|+
operator|(
name|amount
operator|>>
literal|2
operator|)
decl_stmt|;
comment|/* Copy out NIC data.  We could probably write this 			   as a `movsl'. The currently generated code is lousy. 			   */
while|while
condition|(
name|dl
operator|<
name|fence
condition|)
operator|*
name|dl
operator|++
operator|=
operator|*
name|sl
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|amount
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* Finish off any words left, as a series of short reads */
if|if
condition|(
name|amount
operator|>
literal|1
condition|)
block|{
name|u_short
modifier|*
name|d
init|=
operator|(
name|u_short
operator|*
operator|)
name|dst
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
specifier|const
name|s
init|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|u_short
modifier|*
specifier|const
name|fence
init|=
name|d
operator|+
operator|(
name|amount
operator|>>
literal|1
operator|)
decl_stmt|;
comment|/* Copy out NIC data.  */
while|while
condition|(
name|d
operator|<
name|fence
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|amount
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* 		 * read in a byte; however we need to always read 16 bits 		 * at a time or the hardware gets into a funny state 		 */
if|if
condition|(
name|amount
operator|==
literal|1
condition|)
block|{
comment|/* need to read in a short and copy LSB */
specifier|volatile
name|u_short
modifier|*
specifier|const
name|s
init|=
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|*
name|s
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
comment|/* Restore Boot ROM access.  */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read in data using the I/O port */
if|if
condition|(
name|use_32bit_access
operator|&&
operator|(
name|amount
operator|>
literal|3
operator|)
condition|)
block|{
name|ed_asic_insl
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|dst
argument_list|,
name|amount
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|amount
operator|&=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|amount
operator|>
literal|1
condition|)
block|{
name|ed_asic_insw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|dst
argument_list|,
name|amount
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|dst
operator|+=
operator|(
name|amount
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|amount
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|amount
operator|==
literal|1
condition|)
block|{
comment|/* read in a short and keep the LSB */
operator|*
name|dst
operator|=
name|ed_asic_inw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * HP PC Lan+: Write to NIC memory, using either PIO or memory mapped  * IO.  *	Only used in the probe routine to test the memory. 'len' must  *	be even.  */
end_comment

begin_function
name|void
name|ed_hpp_writemem
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|len
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
name|unsigned
name|short
name|dst
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
block|{
comment|/* reset remote DMA complete flag */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* program the write address in RAM */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
operator|(
name|u_short
operator|*
operator|)
name|src
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
name|d
init|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|u_short
modifier|*
specifier|const
name|fence
init|=
name|s
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
decl_stmt|;
comment|/* 		 * Enable memory mapped access. 		 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_MEM_DISABLE
operator||
name|ED_HPP_OPTION_BOOT_ROM_ENB
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Copy to NIC memory. 		 */
while|while
condition|(
name|s
operator|<
name|fence
condition|)
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* 		 * Restore Boot ROM access. 		 */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* write data using I/O writes */
name|ed_asic_outsw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|src
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write to HP PC Lan+ NIC memory.  Access to the NIC can be by using   * outsw() or via the memory mapped interface to the same register.  * Writes have to be in word units; byte accesses won't work and may cause  * the NIC to behave weirdly. Long word accesses are permitted if the ASIC  * allows it.  */
end_comment

begin_function
specifier|static
name|u_short
name|ed_hpp_write_mbufs
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|dst
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|wantbyte
decl_stmt|;
name|unsigned
name|short
name|total_len
decl_stmt|;
name|unsigned
name|char
name|savebyte
index|[
literal|2
index|]
decl_stmt|;
specifier|volatile
name|u_short
modifier|*
specifier|const
name|d
init|=
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|sc
operator|->
name|hpp_mem_start
decl_stmt|;
name|int
name|use_32bit_accesses
init|=
operator|!
operator|(
name|sc
operator|->
name|hpp_id
operator|&
name|ED_HPP_ID_16_BIT_ACCESS
operator|)
decl_stmt|;
comment|/* select page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* reset remote DMA complete flag */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
name|ED_ISR_RDC
argument_list|)
expr_stmt|;
comment|/* program the write address in RAM */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
comment|/* enable memory mapped I/O */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
operator|&
operator|~
operator|(
name|ED_HPP_OPTION_MEM_DISABLE
operator||
name|ED_HPP_OPTION_BOOT_ROM_ENB
operator|)
argument_list|)
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
name|total_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
block|{
comment|/* Memory mapped I/O port */
while|while
condition|(
name|m
condition|)
block|{
name|total_len
operator|+=
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|caddr_t
name|data
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
comment|/* finish the last word of the previous mbuf */
if|if
condition|(
name|wantbyte
condition|)
block|{
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
operator|*
name|d
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|savebyte
operator|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
operator|(
name|len
operator|>
literal|3
operator|)
operator|&&
operator|(
name|use_32bit_accesses
operator|)
condition|)
block|{
specifier|volatile
name|u_int32_t
modifier|*
specifier|const
name|dl
init|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|d
decl_stmt|;
name|u_int32_t
modifier|*
name|sl
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|data
decl_stmt|;
name|u_int32_t
modifier|*
name|fence
init|=
name|sl
operator|+
operator|(
name|len
operator|>>
literal|2
operator|)
decl_stmt|;
while|while
condition|(
name|sl
operator|<
name|fence
condition|)
operator|*
name|dl
operator|=
operator|*
name|sl
operator|++
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|len
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* finish off remain 16 bit writes */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
operator|(
name|u_short
operator|*
operator|)
name|data
decl_stmt|;
name|u_short
modifier|*
name|fence
init|=
name|s
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|fence
condition|)
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* save last byte if needed */
if|if
condition|(
operator|(
name|wantbyte
operator|=
operator|(
name|len
operator|==
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
comment|/* to next mbuf */
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* write last byte */
operator|*
name|d
operator|=
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
name|savebyte
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use programmed I/O */
while|while
condition|(
name|m
condition|)
block|{
name|total_len
operator|+=
operator|(
name|len
operator|=
name|m
operator|->
name|m_len
operator|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|caddr_t
name|data
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
comment|/* finish the last word of the previous mbuf */
if|if
condition|(
name|wantbyte
condition|)
block|{
name|savebyte
index|[
literal|1
index|]
operator|=
operator|*
name|data
expr_stmt|;
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
name|savebyte
operator|)
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|wantbyte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
operator|(
name|len
operator|>
literal|3
operator|)
operator|&&
name|use_32bit_accesses
condition|)
block|{
name|ed_asic_outsl
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|len
operator|&=
literal|3
expr_stmt|;
block|}
comment|/* finish off remaining 16 bit accesses */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|ed_asic_outsw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
operator|(
name|len
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wantbyte
operator|=
operator|(
name|len
operator|==
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|savebyte
index|[
literal|0
index|]
operator|=
operator|*
name|data
expr_stmt|;
block|}
comment|/* if len != 0 */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|wantbyte
condition|)
comment|/* spit last byte */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_PAGE_4
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
name|savebyte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hpp_mem_start
condition|)
comment|/* turn off memory mapped i/o */
name|ed_asic_outw
argument_list|(
name|sc
argument_list|,
name|ED_HPP_OPTION
argument_list|,
name|sc
operator|->
name|hpp_options
argument_list|)
expr_stmt|;
return|return
operator|(
name|total_len
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ED_NO_MIIBUS
end_ifndef

begin_comment
comment|/*  * MII bus support routines.  */
end_comment

begin_function
name|int
name|ed_miibus_readreg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|failed
decl_stmt|,
name|s
decl_stmt|,
name|val
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
literal|0xffffffff
argument_list|,
literal|32
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_STARTDELIM
argument_list|,
name|ED_MII_STARTDELIM_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_READOP
argument_list|,
name|ED_MII_OP_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|ED_MII_PHY_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|ED_MII_REG_BITS
argument_list|)
expr_stmt|;
name|failed
operator|=
call|(
modifier|*
name|sc
operator|->
name|mii_readbits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_ACK_BITS
argument_list|)
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|sc
operator|->
name|mii_readbits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_DATA_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_IDLE
argument_list|,
name|ED_MII_IDLE_BITS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|failed
condition|?
literal|0
else|:
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ed_miibus_writereg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|,
name|data
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|,
name|data
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
literal|0xffffffff
argument_list|,
literal|32
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_STARTDELIM
argument_list|,
name|ED_MII_STARTDELIM_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_WRITEOP
argument_list|,
name|ED_MII_OP_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|ED_MII_PHY_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|ED_MII_REG_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_TURNAROUND
argument_list|,
name|ED_MII_TURNAROUND_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|ED_MII_DATA_BITS
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|mii_writebits
call|)
argument_list|(
name|sc
argument_list|,
name|ED_MII_IDLE
argument_list|,
name|ED_MII_IDLE_BITS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ed_ifmedia_upd
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
operator|||
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
return|return
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ed_ifmedia_sts
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gone
operator|||
name|sc
operator|->
name|miibus
operator|==
name|NULL
condition|)
return|return;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ed_child_detached
parameter_list|(
name|dev
parameter_list|,
name|child
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|device_t
name|child
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|sc
operator|->
name|miibus
condition|)
name|sc
operator|->
name|miibus
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ed_setrcr
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|reg1
decl_stmt|;
comment|/* Bit 6 in AX88190 RCR register must be set. */
if|if
condition|(
name|sc
operator|->
name|chip_type
operator|==
name|ED_CHIP_TYPE_AX88190
condition|)
name|reg1
operator|=
name|ED_RCR_INTT
expr_stmt|;
else|else
name|reg1
operator|=
literal|0x00
expr_stmt|;
comment|/* set page 1 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_PAGE_1
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 		 * Reconfigure the multicast filter. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P1_MAR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 		 * And turn on promiscuous mode. Also enable reception of 		 * runts and packets with CRC& alignment errors. 		 */
comment|/* Set page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_PRO
operator||
name|ED_RCR_AM
operator||
name|ED_RCR_AB
operator||
name|ED_RCR_AR
operator||
name|ED_RCR_SEP
operator||
name|reg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set up multicast addresses and filter modes */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|u_int32_t
name|mcaf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|mcaf
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|mcaf
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
name|ds_getmcaf
argument_list|(
name|sc
argument_list|,
name|mcaf
argument_list|)
expr_stmt|;
comment|/* 			 * Set multicast filter on chip. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P1_MAR
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|mcaf
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_AM
operator||
name|ED_RCR_AB
operator||
name|reg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Initialize multicast address hashing registers to 			 * not accept multicasts. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P1_MAR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Set page 0 registers */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_AB
operator||
name|reg1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Start interface. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|sc
operator|->
name|cr_proto
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute crc for ethernet address  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|ds_crc
parameter_list|(
name|ep
parameter_list|)
name|u_char
modifier|*
name|ep
decl_stmt|;
block|{
define|#
directive|define
name|POLYNOMIAL
value|0x04c11db6
specifier|register
name|u_int32_t
name|crc
init|=
literal|0xffffffff
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|u_char
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|6
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|b
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|carry
operator|=
operator|(
operator|(
name|crc
operator|&
literal|0x80000000
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
name|b
operator|&
literal|0x01
operator|)
expr_stmt|;
name|crc
operator|<<=
literal|1
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|carry
condition|)
name|crc
operator|=
operator|(
name|crc
operator|^
name|POLYNOMIAL
operator|)
operator||
name|carry
expr_stmt|;
block|}
block|}
return|return
name|crc
return|;
undef|#
directive|undef
name|POLYNOMIAL
block|}
end_function

begin_comment
comment|/*  * Compute the multicast address filter from the  * list of multicast addresses we need to listen to.  */
end_comment

begin_function
specifier|static
name|void
name|ds_getmcaf
parameter_list|(
name|sc
parameter_list|,
name|mcaf
parameter_list|)
name|struct
name|ed_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
modifier|*
name|mcaf
decl_stmt|;
block|{
specifier|register
name|u_int32_t
name|index
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|af
init|=
operator|(
name|u_char
operator|*
operator|)
name|mcaf
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|mcaf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mcaf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->arpcom.ac_if.if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|ds_crc
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
operator|>>
literal|26
expr_stmt|;
name|af
index|[
name|index
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index
operator|&
literal|7
operator|)
expr_stmt|;
block|}
block|}
end_function

end_unit

