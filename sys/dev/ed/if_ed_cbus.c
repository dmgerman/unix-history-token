begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995, David Greenman  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_edreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ed/if_ed98.h>
end_include

begin_function_decl
specifier|static
name|int
name|ed98_alloc_port
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed98_alloc_memory
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_pio_testmem
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_CNET98
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_CNET98EL
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_EZ98
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_NEC77
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_NW98X
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_SB98
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_probe_SIC98
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed98_probe_Novell
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed98_probe_generic8390
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_reset_CNET98
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_winsel_CNET98
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ed_get_SB98
parameter_list|(
name|struct
name|ed_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_cbus_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ed_cbus_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|ed_ids
index|[]
init|=
block|{
comment|/* TODO - list up PnP boards for PC-98 */
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ed_cbus_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|type
operator|=
name|ED_TYPE98
argument_list|(
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed_cbus_probe: sc->type=%x\n"
argument_list|,
name|sc
operator|->
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check isapnp ids */
name|error
operator|=
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ed_ids
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed_cbus_probe: ISA_PNP_PROBE returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the card had a PnP ID that didn't match any we know about */
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
goto|goto
name|end
goto|;
comment|/* If we had some other problem. */
if|if
condition|(
operator|!
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
operator|)
condition|)
goto|goto
name|end
goto|;
comment|/* Heuristic probes */
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed_cbus_probe: Heuristic probes start\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE98_GENERIC
case|:
comment|/* 		 * CAUTION! 		 * sc->type of these boards are overwritten by PC/AT's value. 		 */
comment|/* 		 * SMC EtherEZ98 		 */
name|error
operator|=
name|ed_probe_EZ98
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|ed_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 		 * Allied Telesis CenterCom LA-98-T 		 */
name|error
operator|=
name|ed_probe_Novell
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ed_Novell_read_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
comment|/* 	 * NE2000-like boards probe routine 	 */
case|case
name|ED_TYPE98_BDN
case|:
comment|/* 		 * ELECOM LANEED LD-BDN 		 * PLANET SMART COM 98 EN-2298 		 */
case|case
name|ED_TYPE98_LGY
case|:
comment|/* 		 * MELCO LGY-98, IND-SP, IND-SS 		 * MACNICA NE2098 		 */
case|case
name|ED_TYPE98_ICM
case|:
comment|/* 		 * ICM DT-ET-25, DT-ET-T5, IF-2766ET, IF-2771ET 		 * D-Link DE-298P, DE-298 		 */
case|case
name|ED_TYPE98_EGY
case|:
comment|/* 		 * MELCO EGY-98 		 * Contec C-NET(98)E-A, C-NET(98)L-A 		 */
case|case
name|ED_TYPE98_108
case|:
comment|/* 		 * NEC PC-9801-107,108 		 */
case|case
name|ED_TYPE98_NC5098
case|:
comment|/* 		 * NextCom NC5098 		 */
name|error
operator|=
name|ed98_probe_Novell
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * other boards with special probe routine 	 */
case|case
name|ED_TYPE98_SIC
case|:
comment|/* 		 * Allied Telesis SIC-98 		 */
name|error
operator|=
name|ed_probe_SIC98
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_CNET98EL
case|:
comment|/* 		 * Contec C-NET(98)E/L 		 */
name|error
operator|=
name|ed_probe_CNET98EL
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_CNET98
case|:
comment|/* 		 * Contec C-NET(98) 		 */
name|error
operator|=
name|ed_probe_CNET98
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_LA98
case|:
comment|/* 		 * IO-DATA LA/T-98 		 * NEC PC-9801-77,78 		 */
name|error
operator|=
name|ed_probe_NEC77
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_NW98X
case|:
comment|/* 		 * Networld EC/EP-98X 		 */
name|error
operator|=
name|ed_probe_NW98X
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_SB98
case|:
comment|/* 		 * Soliton SB-9801 		 * Fujikura FN-9801 		 */
name|error
operator|=
name|ed_probe_SB98
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|end
label|:
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed_cbus_probe: end, error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ed_alloc_irq
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ed_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed_cbus_attach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_used
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ED_TYPE98
argument_list|(
name|flags
argument_list|)
operator|==
name|ED_TYPE98_GENERIC
condition|)
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_used
argument_list|)
expr_stmt|;
else|else
name|ed98_alloc_port
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem_used
condition|)
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_used
argument_list|)
expr_stmt|;
name|ed_alloc_irq
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|edintr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ed_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
name|ed_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt conversion table for EtherEZ98  */
end_comment

begin_decl_stmt
specifier|static
name|uint16_t
name|ed_EZ98_intr_val
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|9
block|,
literal|12
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ed_probe_EZ98
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|static
name|unsigned
name|short
modifier|*
name|intr_vals
index|[]
init|=
block|{
name|NULL
block|,
name|ed_EZ98_intr_val
block|}
decl_stmt|;
name|error
operator|=
name|ed_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|,
name|ED_EZ98_IO_PORTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|asic_offset
operator|=
name|ED_EZ98_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_EZ98_NIC_OFFSET
expr_stmt|;
return|return
name|ed_probe_WD80x3_generic
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|intr_vals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * I/O conversion tables  */
end_comment

begin_comment
comment|/* LGY-98, ICM, C-NET(98)E/L */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_generic
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *		Definitions for Contec C-NET(98)E/L  */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98EL_ICR
value|2
end_define

begin_comment
comment|/* Interrupt Configuration Register */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98EL_ICR_IRQ3
value|0x01
end_define

begin_define
define|#
directive|define
name|ED_CNET98EL_ICR_IRQ5
value|0x02
end_define

begin_define
define|#
directive|define
name|ED_CNET98EL_ICR_IRQ6
value|0x04
end_define

begin_define
define|#
directive|define
name|ED_CNET98EL_ICR_IRQ12
value|0x20
end_define

begin_define
define|#
directive|define
name|ED_CNET98EL_IMR
value|4
end_define

begin_comment
comment|/* Interrupt Mask Register	*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98EL_ISR
value|5
end_define

begin_comment
comment|/* Interrupt Status Register	*/
end_comment

begin_comment
comment|/* EGY-98 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_egy98
index|[]
init|=
block|{
literal|0
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x0a
block|,
literal|0x0c
block|,
literal|0x0e
block|,
literal|0x100
block|,
literal|0x102
block|,
literal|0x104
block|,
literal|0x106
block|,
literal|0x108
block|,
literal|0x10a
block|,
literal|0x10c
block|,
literal|0x10e
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SIC-98 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_sic98
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0200
block|,
literal|0x0400
block|,
literal|0x0600
block|,
literal|0x0800
block|,
literal|0x0a00
block|,
literal|0x0c00
block|,
literal|0x0e00
block|,
literal|0x1000
block|,
literal|0x1200
block|,
literal|0x1400
block|,
literal|0x1600
block|,
literal|0x1800
block|,
literal|0x1a00
block|,
literal|0x1c00
block|,
literal|0x1e00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LA/T-98, LD-BDN, PC-9801-77, SB-9801 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_la98
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x3000
block|,
literal|0x4000
block|,
literal|0x5000
block|,
literal|0x6000
block|,
literal|0x7000
block|,
literal|0x8000
block|,
literal|0x9000
block|,
literal|0xa000
block|,
literal|0xb000
block|,
literal|0xc000
block|,
literal|0xd000
block|,
literal|0xe000
block|,
literal|0xf000
block|,
literal|0x0100
comment|/* for NEC 77(see below) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *		Definitions for NEC PC-9801-77  */
end_comment

begin_define
define|#
directive|define
name|ED_NEC77_IRQ
value|16
end_define

begin_comment
comment|/* Interrupt Configuration Register */
end_comment

begin_define
define|#
directive|define
name|ED_NEC77_IRQ3
value|0x04
end_define

begin_define
define|#
directive|define
name|ED_NEC77_IRQ5
value|0x06
end_define

begin_define
define|#
directive|define
name|ED_NEC77_IRQ6
value|0x08
end_define

begin_define
define|#
directive|define
name|ED_NEC77_IRQ12
value|0x0a
end_define

begin_define
define|#
directive|define
name|ED_NEC77_IRQ13
value|0x02
end_define

begin_comment
comment|/*  *		Definitions for Soliton SB-9801  */
end_comment

begin_define
define|#
directive|define
name|ED_SB98_CFG
value|1
end_define

begin_comment
comment|/* Board configuration		*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_CFG_IRQ3
value|0x00
end_define

begin_define
define|#
directive|define
name|ED_SB98_CFG_IRQ5
value|0x04
end_define

begin_define
define|#
directive|define
name|ED_SB98_CFG_IRQ6
value|0x08
end_define

begin_define
define|#
directive|define
name|ED_SB98_CFG_IRQ12
value|0x0c
end_define

begin_define
define|#
directive|define
name|ED_SB98_CFG_ALTPORT
value|0x40
end_define

begin_comment
comment|/* use EXTERNAL media	*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_CFG_ENABLE
value|0xa0
end_define

begin_comment
comment|/* enable configuration	*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_EEPENA
value|2
end_define

begin_comment
comment|/* EEPROM access enable		*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_EEPENA_DISABLE
value|0x00
end_define

begin_define
define|#
directive|define
name|ED_SB98_EEPENA_ENABLE
value|0x01
end_define

begin_define
define|#
directive|define
name|ED_SB98_EEP
value|3
end_define

begin_comment
comment|/* EEPROM access		*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_EEP_SDA
value|0x01
end_define

begin_comment
comment|/* Serial Data	*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_EEP_SCL
value|0x02
end_define

begin_comment
comment|/* Serial Clock	*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_EEP_READ
value|0x01
end_define

begin_comment
comment|/* Read Command	*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_EEP_DELAY
value|300
end_define

begin_define
define|#
directive|define
name|ED_SB98_ADDRESS
value|0x01
end_define

begin_comment
comment|/* Station Address(1-6)	*/
end_comment

begin_define
define|#
directive|define
name|ED_SB98_POLARITY
value|4
end_define

begin_comment
comment|/* Polarity			*/
end_comment

begin_comment
comment|/* PC-9801-108 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_nec108
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0006
block|,
literal|0x0008
block|,
literal|0x000a
block|,
literal|0x000c
block|,
literal|0x000e
block|,
literal|0x1000
block|,
literal|0x1002
block|,
literal|0x1004
block|,
literal|0x1006
block|,
literal|0x1008
block|,
literal|0x100a
block|,
literal|0x100c
block|,
literal|0x100e
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C-NET(98) */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_cnet98
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0006
block|,
literal|0x0008
block|,
literal|0x000a
block|,
literal|0x000c
block|,
literal|0x000e
block|,
literal|0x0400
block|,
literal|0x0402
block|,
literal|0x0404
block|,
literal|0x0406
block|,
literal|0x0408
block|,
literal|0x040a
block|,
literal|0x040c
block|,
literal|0x040e
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *		Definitions for Contec C-NET(98)  */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG0L
value|0
end_define

begin_comment
comment|/* MAPPING register0 Low	*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG1L
value|1
end_define

begin_comment
comment|/* MAPPING register1 Low	*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG2L
value|2
end_define

begin_comment
comment|/* MAPPING register2 Low	*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG3L
value|3
end_define

begin_comment
comment|/* MAPPING register3 Low	*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG0H
value|4
end_define

begin_comment
comment|/* MAPPING register0 Hi		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG1H
value|5
end_define

begin_comment
comment|/* MAPPING register1 Hi		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG2H
value|6
end_define

begin_comment
comment|/* MAPPING register2 Hi		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_MAP_REG3H
value|7
end_define

begin_comment
comment|/* MAPPING register3 Hi		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_WIN_REG
value|8
end_define

begin_comment
comment|/* Window register		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_LEV
value|9
end_define

begin_comment
comment|/* Init level register		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_IRQ3
value|0x01
end_define

begin_comment
comment|/* INT 0 */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_IRQ5
value|0x02
end_define

begin_comment
comment|/* INT 1 */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_IRQ6
value|0x04
end_define

begin_comment
comment|/* INT 2 */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_IRQ9
value|0x08
end_define

begin_comment
comment|/* INT 3 */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_IRQ12
value|0x20
end_define

begin_comment
comment|/* INT 5 */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_IRQ13
value|0x40
end_define

begin_comment
comment|/* INT 6 */
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_REQ
value|10
end_define

begin_comment
comment|/* Init request register	*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_MASK
value|11
end_define

begin_comment
comment|/* Init mask register		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_STAT
value|12
end_define

begin_comment
comment|/* Init status register		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_INT_CLR
value|12
end_define

begin_comment
comment|/* Init clear register		*/
end_comment

begin_define
define|#
directive|define
name|ED_CNET98_RESERVE1
value|13
end_define

begin_define
define|#
directive|define
name|ED_CNET98_RESERVE2
value|14
end_define

begin_define
define|#
directive|define
name|ED_CNET98_RESERVE3
value|15
end_define

begin_comment
comment|/* EC/EP-98X, NC5098 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_ioaddr_nw98x
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0100
block|,
literal|0x0200
block|,
literal|0x0300
block|,
literal|0x0400
block|,
literal|0x0500
block|,
literal|0x0600
block|,
literal|0x0700
block|,
literal|0x0800
block|,
literal|0x0900
block|,
literal|0x0a00
block|,
literal|0x0b00
block|,
literal|0x0c00
block|,
literal|0x0d00
block|,
literal|0x0e00
block|,
literal|0x0f00
block|,
literal|0x1000
comment|/* for EC/EP-98X(see below) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *		Definitions for Networld EC/EP-98X  */
end_comment

begin_define
define|#
directive|define
name|ED_NW98X_IRQ
value|16
end_define

begin_comment
comment|/* Interrupt Configuration Register */
end_comment

begin_define
define|#
directive|define
name|ED_NW98X_IRQ3
value|0x04
end_define

begin_define
define|#
directive|define
name|ED_NW98X_IRQ5
value|0x06
end_define

begin_define
define|#
directive|define
name|ED_NW98X_IRQ6
value|0x08
end_define

begin_define
define|#
directive|define
name|ED_NW98X_IRQ12
value|0x0a
end_define

begin_define
define|#
directive|define
name|ED_NW98X_IRQ13
value|0x02
end_define

begin_comment
comment|/* NC5098 ASIC */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ed98_asic_nc5098
index|[]
init|=
block|{
comment|/*	DATA    ENADDR						RESET	*/
literal|0x0000
block|,
literal|0x2000
block|,
literal|0x2100
block|,
literal|0x2200
block|,
literal|0x2300
block|,
literal|0x2400
block|,
literal|0x2500
block|,
literal|0x4000
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *		Definitions for NextCom NC5098  */
end_comment

begin_define
define|#
directive|define
name|ED_NC5098_ENADDR
value|1
end_define

begin_comment
comment|/* Station Address(1-6)		*/
end_comment

begin_comment
comment|/*  * Allocate a port resource with the given resource id.  */
end_comment

begin_function
specifier|static
name|int
name|ed98_alloc_port
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bus_addr_t
modifier|*
name|io_nic
decl_stmt|,
modifier|*
name|io_asic
decl_stmt|,
name|adj
decl_stmt|;
specifier|static
name|bus_addr_t
name|io_res
index|[
name|ED_NOVELL_IO_PORTS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|reset
decl_stmt|,
name|data
decl_stmt|;
comment|/* Set i/o table for resource manager */
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_generic
expr_stmt|;
name|offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|reset
operator|=
name|ED_NOVELL_RESET
expr_stmt|;
name|data
operator|=
name|ED_NOVELL_DATA
expr_stmt|;
name|n
operator|=
name|ED_NOVELL_IO_PORTS
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE98_LGY
case|:
name|io_asic
operator|=
name|ed98_ioaddr_egy98
expr_stmt|;
comment|/* XXX - Yes, we use egy98 */
name|offset
operator|=
literal|0x0200
expr_stmt|;
name|reset
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_EGY
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_egy98
expr_stmt|;
name|offset
operator|=
literal|0x0200
expr_stmt|;
name|reset
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_ICM
case|:
name|offset
operator|=
literal|0x0100
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_BDN
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_la98
expr_stmt|;
name|offset
operator|=
literal|0x0100
expr_stmt|;
name|reset
operator|=
literal|0x0c
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_SIC
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_sic98
expr_stmt|;
name|offset
operator|=
literal|0x2000
expr_stmt|;
name|n
operator|=
literal|16
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_108
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_nec108
expr_stmt|;
name|offset
operator|=
literal|0x0888
expr_stmt|;
comment|/* XXX - overwritten after */
name|reset
operator|=
literal|1
expr_stmt|;
name|n
operator|=
literal|16
expr_stmt|;
comment|/* XXX - does not set ASIC i/o here */
break|break;
case|case
name|ED_TYPE98_LA98
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_la98
expr_stmt|;
name|offset
operator|=
literal|0x0100
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_CNET98EL
case|:
name|offset
operator|=
literal|0x0400
expr_stmt|;
name|data
operator|=
literal|0x0e
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_CNET98
case|:
comment|/* XXX - Yes, we use generic i/o here */
name|offset
operator|=
literal|0x0400
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_NW98X
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_nw98x
expr_stmt|;
name|offset
operator|=
literal|0x1000
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_SB98
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_la98
expr_stmt|;
name|offset
operator|=
literal|0x0400
expr_stmt|;
name|reset
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_NC5098
case|:
name|io_nic
operator|=
name|ed98_ioaddr_nw98x
expr_stmt|;
name|io_asic
operator|=
name|ed98_asic_nc5098
expr_stmt|;
name|offset
operator|=
literal|0x2000
expr_stmt|;
name|reset
operator|=
literal|7
expr_stmt|;
name|n
operator|=
literal|16
operator|+
literal|8
expr_stmt|;
comment|/* XXX */
break|break;
block|}
name|bcopy
argument_list|(
name|io_nic
argument_list|,
name|io_res
argument_list|,
sizeof|sizeof
argument_list|(
name|io_nic
index|[
literal|0
index|]
argument_list|)
operator|*
name|ED_NOVELL_ASIC_OFFSET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ED_NOVELL_ASIC_OFFSET
init|;
name|i
operator|<
name|ED_NOVELL_IO_PORTS
condition|;
name|i
operator|++
control|)
name|io_res
index|[
name|i
index|]
operator|=
name|io_asic
index|[
name|i
operator|-
name|ED_NOVELL_ASIC_OFFSET
index|]
operator|+
name|offset
expr_stmt|;
name|res
operator|=
name|isa_alloc_resourcev
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|io_res
argument_list|,
name|n
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|sc
operator|->
name|port_rid
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|port_used
operator|=
name|n
expr_stmt|;
name|sc
operator|->
name|port_bst
operator|=
name|rman_get_bustag
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* Re-map i/o table if needed */
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE98_LA98
case|:
case|case
name|ED_TYPE98_NW98X
case|:
name|io_res
index|[
name|n
index|]
operator|=
name|io_asic
index|[
name|n
operator|-
name|ED_NOVELL_ASIC_OFFSET
index|]
operator|+
name|offset
expr_stmt|;
name|n
operator|++
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_108
case|:
name|adj
operator|=
operator|(
name|rman_get_start
argument_list|(
name|res
argument_list|)
operator|&
literal|0xf000
operator|)
operator|/
literal|2
expr_stmt|;
name|offset
operator|=
operator|(
name|offset
operator||
name|adj
operator|)
operator|-
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ED_NOVELL_ASIC_OFFSET
init|;
name|n
operator|<
name|ED_NOVELL_IO_PORTS
condition|;
name|n
operator|++
control|)
name|io_res
index|[
name|n
index|]
operator|=
name|io_asic
index|[
name|n
operator|-
name|ED_NOVELL_ASIC_OFFSET
index|]
operator|+
name|offset
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_CNET98
case|:
name|io_nic
operator|=
name|io_asic
operator|=
name|ed98_ioaddr_cnet98
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|io_nic
argument_list|,
name|io_res
argument_list|,
sizeof|sizeof
argument_list|(
name|io_nic
index|[
literal|0
index|]
argument_list|)
operator|*
name|ED_NOVELL_ASIC_OFFSET
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ED_NOVELL_ASIC_OFFSET
init|;
name|n
operator|<
name|ED_NOVELL_IO_PORTS
condition|;
name|n
operator|++
control|)
name|io_res
index|[
name|n
index|]
operator|=
name|io_asic
index|[
name|n
operator|-
name|ED_NOVELL_ASIC_OFFSET
index|]
operator|+
name|offset
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_NC5098
case|:
name|n
operator|=
name|ED_NOVELL_IO_PORTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reset
operator|!=
name|ED_NOVELL_RESET
condition|)
name|io_res
index|[
name|ED_NOVELL_ASIC_OFFSET
operator|+
name|ED_NOVELL_RESET
index|]
operator|=
name|io_res
index|[
name|ED_NOVELL_ASIC_OFFSET
operator|+
name|reset
index|]
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|ED_NOVELL_DATA
condition|)
block|{
name|io_res
index|[
name|ED_NOVELL_ASIC_OFFSET
operator|+
name|ED_NOVELL_DATA
index|]
operator|=
name|io_res
index|[
name|ED_NOVELL_ASIC_OFFSET
operator|+
name|data
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|io_res[ED_NOVELL_ASIC_OFFSET + ED_NOVELL_DATA + 1] = 			io_res[ED_NOVELL_ASIC_OFFSET + data + 1];
endif|#
directive|endif
block|}
name|error
operator|=
name|isa_load_resourcev
argument_list|(
name|res
argument_list|,
name|io_res
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed98_alloc_port: i/o ports = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x,"
argument_list|,
name|io_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed98_alloc_memory
parameter_list|(
name|dev
parameter_list|,
name|rid
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|rid
decl_stmt|;
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|conf_maddr
decl_stmt|,
name|conf_msize
decl_stmt|;
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_maddr
argument_list|,
operator|&
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|conf_maddr
operator|==
literal|0
operator|)
operator|||
operator|(
name|conf_msize
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|ed_alloc_memory
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
operator|(
name|int
operator|)
name|conf_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mem_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_size
operator|=
name|conf_msize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic probe routine for testing for the existance of a DS8390.  *	Must be called after the NIC has just been reset. This routine  *	works by looking at certain register values that are guaranteed  *	to be initialized a certain way after power-up or reset. Seems  *	not to currently work on the 83C690.  *  * Specifically:  *  *	Register			reset bits	set bits  *	Command Register (CR)		TXP, STA	RD2, STP  *	Interrupt Status (ISR)				RST  *	Interrupt Mask (IMR)		All bits  *	Data Control (DCR)				LAS  *	Transmit Config. (TCR)		LB1, LB0  *  * XXX - We only check the CR register.  *  * Return 1 if 8390 was found, 0 if not.  */
end_comment

begin_function
specifier|static
name|int
name|ed98_probe_generic8390
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|tmp
init|=
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"ed?: inb(ED_P0_CR)=%x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tmp
operator|&
operator|(
name|ED_CR_RD2
operator||
name|ED_CR_TXP
operator||
name|ED_CR_STA
operator||
name|ED_CR_STP
operator|)
operator|)
operator|!=
operator|(
name|ED_CR_RD2
operator||
name|ED_CR_STP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|ed_nic_inb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ed98_probe_Novell
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_char
name|romdata
index|[
name|ETHER_ADDR_LEN
operator|*
literal|2
index|]
decl_stmt|,
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed98_probe_Novell: start\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ed98_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
comment|/* Reset the board */
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed98_probe_Novell: reset\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
if|#
directive|if
literal|1
comment|/* XXX - I'm not sure this is really necessary... */
case|case
name|ED_TYPE98_BDN
case|:
name|tmp
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
operator|(
name|tmp
operator|&
literal|0xf0
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
literal|0x04
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0x08
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0x08
argument_list|,
name|tmp
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ED_TYPE98_NC5098
case|:
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tmp
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * I don't know if this is necessary; probably cruft leftover from 	 * Clarkson packet driver code. Doesn't do a thing on the boards I've 	 * tested. -DG [note that an outb(0x84, 0) seems to work here, and is 	 * non-invasive...but some boards don't seem to reset and I don't have 	 * complete documentation on what the 'right' thing to do is...so we 	 * do the invasive thing for now. Yuck.] 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 * NIC properly (or the NIC chip doesn't reset fully on power-up) XXX 	 * - this makes the probe invasive! ...Done against my better 	 * judgement. -DLG 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed98_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Test memory via PIO */
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed98_probe_Novell: test memory\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
if|if
condition|(
operator|!
name|ed_pio_testmem
argument_list|(
name|sc
argument_list|,
literal|8192
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
operator|&&
operator|!
name|ed_pio_testmem
argument_list|(
name|sc
argument_list|,
literal|16384
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Setup the board type */
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed98_probe_Novell: board type\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE98_BDN
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"LD-BDN"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_EGY
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"EGY-98"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_LGY
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"LGY-98"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_ICM
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"ICM"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_108
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"PC-9801-108"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_LA98
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"LA-98"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_NW98X
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"NW98X"
expr_stmt|;
break|break;
case|case
name|ED_TYPE98_NC5098
case|:
name|sc
operator|->
name|type_str
operator|=
literal|"NC5098"
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|type_str
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Get station address */
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|ED_TYPE98_NC5098
case|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ETHER_ADDR_LEN
condition|;
name|n
operator|++
control|)
name|sc
operator|->
name|enaddr
index|[
name|n
index|]
operator|=
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_NC5098_ENADDR
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|romdata
argument_list|,
sizeof|sizeof
argument_list|(
name|romdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ETHER_ADDR_LEN
condition|;
name|n
operator|++
control|)
name|sc
operator|->
name|enaddr
index|[
name|n
index|]
operator|=
name|romdata
index|[
name|n
operator|*
operator|(
name|sc
operator|->
name|isa16bit
operator|+
literal|1
operator|)
index|]
expr_stmt|;
break|break;
block|}
comment|/* clear any pending interrupts that might have occurred above */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_pio_write_mbufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for SIC-98 boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_SIC98
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
comment|/* 	 * Setup card RAM and I/O address 	 * Kernel Virtual to segment C0000-DFFFF???? 	 */
name|error
operator|=
name|ed98_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_SIC_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_SIC_NIC_OFFSET
expr_stmt|;
name|error
operator|=
name|ed98_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Reset card to force it into a known state. */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ED_TYPE98SUB
argument_list|(
name|flags
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* SIC-98/SIU-98 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x94
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x94
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SIU-98-D */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x94
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x9e
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* 	 * Here we check the card ROM, if the checksum passes, and the 	 * type code and ethernet address check out, then we know we have 	 * an SIC card. 	 */
name|sum
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|mem_bst
argument_list|,
name|sc
operator|->
name|mem_bsh
argument_list|,
literal|6
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sum
operator|^=
operator|(
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|mem_bst
argument_list|,
name|sc
operator|->
name|mem_bsh
argument_list|,
name|i
operator|*
literal|2
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ed_probe_sic98: got address %6D\n"
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sum
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|enaddr
index|[
literal|0
index|]
operator||
name|sc
operator|->
name|enaddr
index|[
literal|1
index|]
operator||
name|sc
operator|->
name|enaddr
index|[
literal|2
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_SIC
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"SIC98"
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
literal|0
expr_stmt|;
comment|/* 	 * SIC RAM page 0x0000-0x3fff(or 0x7fff) 	 */
if|if
condition|(
name|ED_TYPE98SUB
argument_list|(
name|flags
argument_list|)
operator|==
literal|0
condition|)
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
else|else
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0x8e
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_clear_memory
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|mem_size
expr_stmt|;
comment|/* 	 * allocate one xmit buffer if< 16k, two buffers otherwise 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|mem_size
operator|<
literal|16384
operator|)
operator|||
operator|(
name|flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
operator|)
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|ED_TXBUF_SIZE
operator|*
name|sc
operator|->
name|txb_cnt
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|mem_size
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_shmem_write_mbufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Contec C-NET(98) series support routines  */
end_comment

begin_function
specifier|static
name|void
name|ed_reset_CNET98
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int
name|init_addr
init|=
name|ED_CNET98_INIT
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
comment|/* Choose initial register address */
if|if
condition|(
name|ED_TYPE98SUB
argument_list|(
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|init_addr
operator|=
name|ED_CNET98_INIT2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed?: initial register=%x\n"
argument_list|,
name|init_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Reset the board to force it into a known state. 	 */
name|outb
argument_list|(
name|init_addr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* request */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|init_addr
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* cancel */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* 	 * Set I/O address(A15-12) and cpu type 	 * 	 *   AAAAIXXC(8bit) 	 *   AAAA: A15-A12,  I: I/O enable, XX: reserved, C: CPU type 	 * 	 * CPU type is 1:80286 or higher, 0:not. 	 * But FreeBSD runs under i386 or higher, thus it must be 1. 	 */
name|tmp
operator|=
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0xf000
operator|)
operator|>>
literal|8
expr_stmt|;
name|tmp
operator||=
operator|(
literal|0x08
operator||
literal|0x01
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed?: outb(%x, %x)\n"
argument_list|,
name|init_addr
operator|+
literal|2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|init_addr
operator|+
literal|2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 * NIC properly (or the NIC chip doesn't reset fully on power-up) XXX 	 * - this makes the probe invasive! ...Done against my better 	 * judgement. -DLG 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ed_winsel_CNET98
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|bank
parameter_list|)
block|{
name|u_char
name|mem
init|=
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
operator|>>
literal|12
operator|)
operator|&
literal|0xff
decl_stmt|;
comment|/* 	 * Disable window memory 	 *    bit7 is 0:disable 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_WIN_REG
argument_list|,
name|mem
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Select window address 	 *    FreeBSD address 0xf00xxxxx 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG0L
argument_list|,
name|bank
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG0H
argument_list|,
operator|(
name|bank
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG1L
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG1H
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG2L
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG2H
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG3L
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_MAP_REG3H
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * Enable window memory(16Kbyte) 	 *    bit7 is 1:enable 	 */
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed?: window start address=%x\n"
argument_list|,
name|mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_WIN_REG
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for C-NET(98) boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_CNET98
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|u_long
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|u_char
name|tmp_s
decl_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ed98_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
name|error
operator|=
name|ed98_alloc_memory
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check I/O address. 0x[a-f]3d0 are allowed. */
if|if
condition|(
operator|(
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0x0fff
operator|)
operator|!=
literal|0x03d0
operator|)
operator|||
operator|(
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0xf000
operator|)
operator|<
operator|(
name|u_short
operator|)
literal|0xa000
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid i/o port configuration (0x%lx) "
literal|"must be %s for %s\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
argument_list|,
literal|"0x[a-f]3d0"
argument_list|,
literal|"CNET98"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Check window area address */
name|tmp_s
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
operator|>>
literal|12
expr_stmt|;
if|if
condition|(
name|tmp_s
operator|<
literal|0x80
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Please change window address(0x%lx)\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|tmp_s
operator|&=
literal|0x0f
expr_stmt|;
name|tmp
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|>>
literal|12
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_s
operator|<=
name|tmp
operator|)
operator|&&
operator|(
name|tmp
operator|<
operator|(
name|tmp_s
operator|+
literal|4
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Please change iobase address(0x%lx) "
literal|"or window address(0x%lx)\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Reset the board */
name|ed_reset_CNET98
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 * NIC properly (or the NIC chip doesn't reset fully on power-up) XXX 	 * - this makes the probe invasive! ...Done against my better 	 * judgement. -DLG 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed98_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 *  Set window ethernet address area 	 *    board memory base 0x480000  data 256byte 	 */
name|ed_winsel_CNET98
argument_list|(
name|sc
argument_list|,
literal|0x4800
argument_list|)
expr_stmt|;
comment|/* 	 * Get station address from on-board ROM 	 */
name|bus_space_read_region_1
argument_list|(
name|sc
operator|->
name|mem_bst
argument_list|,
name|sc
operator|->
name|mem_bsh
argument_list|,
name|sc
operator|->
name|mem_start
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_MISC
expr_stmt|;
name|sc
operator|->
name|type_str
operator|=
literal|"CNET98"
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
comment|/* 	 * Set window buffer memory area 	 *    board memory base 0x400000  data 16kbyte 	 */
name|ed_winsel_CNET98
argument_list|(
name|sc
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
name|error
operator|=
name|ed_clear_memory
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|mem_shared
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|mem_size
expr_stmt|;
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|tx_page_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|mem_size
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
comment|/* 	 *   Set interrupt level 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|conf_irq
condition|)
block|{
case|case
literal|3
case|:
name|tmp
operator|=
name|ED_CNET98_INT_IRQ3
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|tmp
operator|=
name|ED_CNET98_INT_IRQ5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tmp
operator|=
name|ED_CNET98_INT_IRQ6
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|tmp
operator|=
name|ED_CNET98_INT_IRQ9
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|tmp
operator|=
name|ED_CNET98_INT_IRQ12
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|tmp
operator|=
name|ED_CNET98_INT_IRQ13
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be "
literal|"%s for %s\n"
argument_list|,
name|conf_irq
argument_list|,
literal|"3,5,6,9,12,13"
argument_list|,
literal|"CNET98"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_INT_LEV
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 *   Set interrupt mask. 	 *     bit7:1 all interrupt mask 	 *     bit1:1 timer interrupt mask 	 *     bit0:0 NS controler interrupt enable 	 */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98_INT_MASK
argument_list|,
literal|0x7e
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_shmem_write_mbufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for C-NET(98)E/L boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_CNET98EL
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|romdata
index|[
name|ETHER_ADDR_LEN
operator|*
literal|2
index|]
decl_stmt|,
name|tmp
decl_stmt|;
name|u_long
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed98_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
comment|/* Check I/O address. 0x[0-f]3d0 are allowed. */
if|if
condition|(
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0x0fff
operator|)
operator|!=
literal|0x03d0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid i/o port configuration (0x%lx) "
literal|"must be %s for %s\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
argument_list|,
literal|"0x?3d0"
argument_list|,
literal|"CNET98E/L"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Reset the board */
name|ed_reset_CNET98
argument_list|(
name|sc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 * NIC properly (or the NIC chip doesn't reset fully on power-up) XXX 	 * - this makes the probe invasive! ...Done against my better 	 * judgement. -DLG 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed98_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Test memory via PIO */
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
if|if
condition|(
operator|!
name|ed_pio_testmem
argument_list|(
name|sc
argument_list|,
name|ED_CNET98EL_PAGE_OFFSET
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* This looks like a C-NET(98)E/L board. */
name|sc
operator|->
name|type_str
operator|=
literal|"CNET98E/L"
expr_stmt|;
comment|/* 	 * Set IRQ. C-NET(98)E/L only allows a choice of irq 3,5,6. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|conf_irq
condition|)
block|{
case|case
literal|3
case|:
name|tmp
operator|=
name|ED_CNET98EL_ICR_IRQ3
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|tmp
operator|=
name|ED_CNET98EL_ICR_IRQ5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tmp
operator|=
name|ED_CNET98EL_ICR_IRQ6
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 12: 		tmp = ED_CNET98EL_ICR_IRQ12; 		break;
endif|#
directive|endif
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be "
literal|"%s for %s\n"
argument_list|,
name|conf_irq
argument_list|,
literal|"3,5,6"
argument_list|,
literal|"CNET98E/L"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98EL_ICR
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_CNET98EL_IMR
argument_list|,
literal|0x7e
argument_list|)
expr_stmt|;
comment|/* Get station address from on-board ROM */
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
literal|16384
argument_list|,
name|romdata
argument_list|,
sizeof|sizeof
argument_list|(
name|romdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
operator|=
name|romdata
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
comment|/* clear any pending interrupts that might have occurred above */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_pio_write_mbufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for PC-9801-77 boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_NEC77
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|u_long
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed98_probe_Novell
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* LA/T-98 does not need IRQ setting. */
if|if
condition|(
name|ED_TYPE98SUB
argument_list|(
name|flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Set IRQ. PC-9801-77 only allows a choice of irq 3,5,6,12,13. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|conf_irq
condition|)
block|{
case|case
literal|3
case|:
name|tmp
operator|=
name|ED_NEC77_IRQ3
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|tmp
operator|=
name|ED_NEC77_IRQ5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tmp
operator|=
name|ED_NEC77_IRQ6
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|tmp
operator|=
name|ED_NEC77_IRQ12
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|tmp
operator|=
name|ED_NEC77_IRQ13
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be "
literal|"%s for %s\n"
argument_list|,
name|conf_irq
argument_list|,
literal|"3,5,6,12,13"
argument_list|,
literal|"PC-9801-77"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NEC77_IRQ
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for EC/EP-98X boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_NW98X
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|u_long
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed98_probe_Novell
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Networld 98X3 does not need IRQ setting. */
if|if
condition|(
name|ED_TYPE98SUB
argument_list|(
name|flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Set IRQ. EC/EP-98X only allows a choice of irq 3,5,6,12,13. 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|conf_irq
condition|)
block|{
case|case
literal|3
case|:
name|tmp
operator|=
name|ED_NW98X_IRQ3
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|tmp
operator|=
name|ED_NW98X_IRQ5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tmp
operator|=
name|ED_NW98X_IRQ6
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|tmp
operator|=
name|ED_NW98X_IRQ12
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|tmp
operator|=
name|ED_NW98X_IRQ13
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be "
literal|"%s for %s\n"
argument_list|,
name|conf_irq
argument_list|,
literal|"3,5,6,12,13"
argument_list|,
literal|"EC/EP-98X"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NW98X_IRQ
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read SB-9801 station address from Serial Two-Wire EEPROM  */
end_comment

begin_function
specifier|static
name|void
name|ed_get_SB98
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|mask
decl_stmt|,
name|val
decl_stmt|;
comment|/* enable EEPROM acceess */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEPENA
argument_list|,
name|ED_SB98_EEPENA_ENABLE
argument_list|)
expr_stmt|;
comment|/* output start command */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SDA
operator||
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* output address (7bit) */
for|for
control|(
name|mask
operator|=
literal|0x40
init|;
name|mask
operator|!=
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ED_SB98_ADDRESS
operator|&
name|mask
condition|)
name|val
operator|=
name|ED_SB98_EEP_SDA
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|val
operator||
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* output READ command */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_READ
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_READ
operator||
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* read station address */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
comment|/* output ACK */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SDA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SDA
operator||
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
name|val
operator||=
operator|(
name|ed_asic_inb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|)
operator|&
name|ED_SB98_EEP_SDA
operator|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|enaddr
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/* output Last ACK */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SDA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SDA
operator||
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* output stop command */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEP
argument_list|,
name|ED_SB98_EEP_SDA
operator||
name|ED_SB98_EEP_SCL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|ED_SB98_EEP_DELAY
argument_list|)
expr_stmt|;
comment|/* disable EEPROM access */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_EEPENA
argument_list|,
name|ED_SB98_EEPENA_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe and vendor-specific initialization routine for SB-9801 boards  */
end_comment

begin_function
specifier|static
name|int
name|ed_probe_SB98
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port_rid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ed_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|u_long
name|conf_irq
decl_stmt|,
name|junk
decl_stmt|;
name|error
operator|=
name|ed98_alloc_port
argument_list|(
name|dev
argument_list|,
name|port_rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|asic_offset
operator|=
name|ED_NOVELL_ASIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|nic_offset
operator|=
name|ED_NOVELL_NIC_OFFSET
expr_stmt|;
comment|/* Check I/O address. 00d[02468ace] are allowed. */
if|if
condition|(
operator|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
operator|~
literal|0x000e
operator|)
operator|!=
literal|0x00d0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid i/o port configuration (0x%lx) "
literal|"must be %s for %s\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
argument_list|,
literal|"0xd?"
argument_list|,
literal|"SB9801"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Write I/O port address and read 4 times */
name|outb
argument_list|(
name|ED_SB98_IO_INHIBIT
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ED_SB98_IO_INHIBIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ED_SB98_IO_INHIBIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ED_SB98_IO_INHIBIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ED_SB98_IO_INHIBIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
comment|/* 	 * Check IRQ. Soliton SB-9801 only allows a choice of 	 * irq 3,5,6,12 	 */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|conf_irq
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|conf_irq
condition|)
block|{
case|case
literal|3
case|:
name|tmp
operator|=
name|ED_SB98_CFG_IRQ3
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|tmp
operator|=
name|ED_SB98_CFG_IRQ5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tmp
operator|=
name|ED_SB98_CFG_IRQ6
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|tmp
operator|=
name|ED_SB98_CFG_IRQ12
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid irq configuration (%ld) must be "
literal|"%s for %s\n"
argument_list|,
name|conf_irq
argument_list|,
literal|"3,5,6,12"
argument_list|,
literal|"SB9801"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ED_FLAGS_DISABLE_TRANCEIVER
condition|)
name|tmp
operator||=
name|ED_SB98_CFG_ALTPORT
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_CFG
argument_list|,
name|ED_SB98_CFG_ENABLE
operator||
name|tmp
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_SB98_POLARITY
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Reset the board. */
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
literal|0x7a
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|ed_asic_outb
argument_list|(
name|sc
argument_list|,
name|ED_NOVELL_RESET
argument_list|,
literal|0x79
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed because some NE clones apparently don't reset the 	 * NIC properly (or the NIC chip doesn't reset fully on power-up) XXX 	 * - this makes the probe invasive! ...Done against my better 	 * judgement. -DLG 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Make sure that we really have an 8390 based board */
if|if
condition|(
operator|!
name|ed98_probe_generic8390
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Test memory via PIO */
name|sc
operator|->
name|cr_proto
operator|=
name|ED_CR_RD2
expr_stmt|;
if|if
condition|(
operator|!
name|ed_pio_testmem
argument_list|(
name|sc
argument_list|,
literal|16384
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* This looks like an SB9801 board. */
name|sc
operator|->
name|type_str
operator|=
literal|"SB9801"
expr_stmt|;
comment|/* Get station address */
name|ed_get_SB98
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear any pending interrupts that might have occurred above */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_write_mbufs
operator|=
name|ed_pio_write_mbufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test the ability to read and write to the NIC memory.  */
end_comment

begin_function
specifier|static
name|int
name|ed_pio_testmem
parameter_list|(
name|struct
name|ed_softc
modifier|*
name|sc
parameter_list|,
name|int
name|page_offset
parameter_list|,
name|int
name|isa16bit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_long
name|memsize
decl_stmt|;
specifier|static
name|char
name|test_pattern
index|[
literal|32
index|]
init|=
literal|"THIS is A memory TEST pattern"
decl_stmt|;
name|char
name|test_buffer
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|int
name|page_end
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|vendor
operator|=
name|ED_VENDOR_NOVELL
expr_stmt|;
name|sc
operator|->
name|mem_shared
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|isa16bit
operator|=
name|isa16bit
expr_stmt|;
comment|/* 8k of memory plus an additional 8k if 16bit */
name|memsize
operator|=
operator|(
name|isa16bit
condition|?
literal|16384
else|:
literal|8192
operator|)
expr_stmt|;
comment|/* 	 * This prevents packets from being stored in the NIC memory when the 	 * readmem routine turns on the start bit in the CR. 	 */
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_RCR
argument_list|,
name|ED_RCR_MON
argument_list|)
expr_stmt|;
comment|/* Initialize DCR for byte/word operations */
if|if
condition|(
name|isa16bit
condition|)
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_WTS
operator||
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
else|else
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_LS
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTART
argument_list|,
name|page_offset
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ed_nic_outb
argument_list|(
name|sc
argument_list|,
name|ED_P0_PSTOP
argument_list|,
operator|(
name|page_offset
operator|+
name|memsize
operator|)
operator|/
name|ED_PAGE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed?: ed_pio_testmem: page start=%x, end=%lx"
argument_list|,
name|page_offset
argument_list|,
name|page_offset
operator|+
name|memsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Write a test pattern. If this fails, then we don't know 	 * what this board is. 	 */
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
name|page_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|page_offset
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed?: ed_pio_testmem: bcmp(page %x) NG"
argument_list|,
name|page_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Check the bottom. */
name|page_end
operator|=
name|page_offset
operator|+
name|memsize
operator|-
name|ED_PAGE_SIZE
expr_stmt|;
name|ed_pio_writemem
argument_list|(
name|sc
argument_list|,
name|test_pattern
argument_list|,
name|page_end
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ed_pio_readmem
argument_list|(
name|sc
argument_list|,
name|page_end
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|test_pattern
argument_list|,
name|test_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|test_pattern
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ED_DEBUG
name|printf
argument_list|(
literal|"ed?: ed_pio_testmem: bcmp(page %x) NG"
argument_list|,
name|page_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|mem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|mem_start
operator|=
name|page_offset
expr_stmt|;
name|sc
operator|->
name|mem_end
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|page_offset
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
comment|/* 	 * Use one xmit buffer if< 16k, two buffers otherwise (if not told 	 * otherwise). 	 */
if|if
condition|(
operator|(
name|memsize
operator|<
literal|16384
operator|)
operator|||
operator|(
name|flags
operator|&
name|ED_FLAGS_NO_MULTI_BUFFERING
operator|)
condition|)
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_cnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|sc
operator|->
name|tx_page_start
operator|+
name|memsize
operator|/
name|ED_PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|mem_ring
operator|=
name|sc
operator|->
name|mem_start
operator|+
name|sc
operator|->
name|txb_cnt
operator|*
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ed_cbus_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ed_cbus_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ed_cbus_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ed_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ed_cbus_driver
init|=
block|{
literal|"ed"
block|,
name|ed_cbus_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ed_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ed
argument_list|,
name|isa
argument_list|,
name|ed_cbus_driver
argument_list|,
name|ed_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ed
argument_list|,
name|isa
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ed
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

