begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_dagfuncs.c,v 1.7 2001/02/03 12:51:10 mrg Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * dagfuncs.c -- DAG node execution routines  *  * Rules:  * 1. Every DAG execution function must eventually cause node->status to  *    get set to "good" or "bad", and "FinishNode" to be called. In the  *    case of nodes that complete immediately (xor, NullNodeFunc, etc),  *    the node execution function can do these two things directly. In  *    the case of nodes that have to wait for some event (a disk read to  *    complete, a lock to be released, etc) to occur before they can  *    complete, this is typically achieved by having whatever module  *    is doing the operation call GenericWakeupFunc upon completion.  * 2. DAG execution functions should check the status in the DAG header  *    and NOP out their operations if the status is not "enable". However,  *    execution functions that release resources must be sure to release  *    them even when they NOP out the function that would use them.  *    Functions that acquire resources should go ahead and acquire them  *    even when they NOP, so that a downstream release node will not have  *    to check to find out whether or not the acquire was suppressed.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_layout.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_DiskReadFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_DiskWriteFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_DiskReadUndoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_DiskWriteUndoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_DiskUnlockFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_DiskUnlockUndoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_RegularXorUndoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_SimpleXorUndoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|rf_RecoveryXorUndoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************************************************************************  * main (only) configuration routine for this module  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_ConfigureDAGFuncs
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|RF_ASSERT
argument_list|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|8
operator|)
operator|&&
name|RF_LONGSHIFT
operator|==
literal|3
operator|)
operator|||
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|4
operator|)
operator|&&
name|RF_LONGSHIFT
operator|==
literal|2
operator|)
argument_list|)
expr_stmt|;
name|rf_DiskReadFunc
operator|=
name|rf_DiskReadFuncForThreads
expr_stmt|;
name|rf_DiskReadUndoFunc
operator|=
name|rf_DiskUndoFunc
expr_stmt|;
name|rf_DiskWriteFunc
operator|=
name|rf_DiskWriteFuncForThreads
expr_stmt|;
name|rf_DiskWriteUndoFunc
operator|=
name|rf_DiskUndoFunc
expr_stmt|;
name|rf_DiskUnlockFunc
operator|=
name|rf_DiskUnlockFuncForThreads
expr_stmt|;
name|rf_DiskUnlockUndoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|rf_RegularXorUndoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|rf_SimpleXorUndoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|rf_RecoveryXorUndoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the execution function associated with a terminate node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_TerminateFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|dagHdr
operator|->
name|numCommits
operator|==
name|node
operator|->
name|dagHdr
operator|->
name|numCommitNodes
argument_list|)
expr_stmt|;
name|node
operator|->
name|status
operator|=
name|rf_good
expr_stmt|;
return|return
operator|(
name|rf_FinishNode
argument_list|(
name|node
argument_list|,
name|RF_THREAD_CONTEXT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_TerminateUndoFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * execution functions associated with a mirror node  *  * parameters:  *  * 0 - physical disk addres of data  * 1 - buffer for holding read data  * 2 - parity stripe ID  * 3 - flags  * 4 - physical disk address of mirror (parity)  *  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_DiskReadMirrorIdleFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
comment|/* select the mirror copy with the shortest queue and fill in node 	 * parameters with physical disk address */
name|rf_SelectMirrorDiskIdle
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|rf_DiskReadFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_DiskReadMirrorPartitionFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
comment|/* select the mirror copy with the shortest queue and fill in node 	 * parameters with physical disk address */
name|rf_SelectMirrorDiskPartition
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|rf_DiskReadFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_DiskReadMirrorUndoFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
end_if

begin_comment
comment|/*****************************************************************************************  * the execution function associated with a parity log update node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_ParityLogUpdateFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|caddr_t
name|buf
init|=
operator|(
name|caddr_t
operator|)
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_ParityLogData_t
modifier|*
name|logData
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|logData
operator|=
name|rf_CreateParityLogData
argument_list|(
name|RF_UPDATE
argument_list|,
name|pda
argument_list|,
name|buf
argument_list|,
operator|(
name|RF_Raid_t
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
argument_list|,
name|node
operator|->
name|wakeFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
argument_list|,
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|logData
condition|)
name|rf_ParityLogAppend
argument_list|(
name|logData
argument_list|,
name|RF_FALSE
argument_list|,
name|NULL
argument_list|,
name|RF_FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|plog_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
call|(
name|node
operator|->
name|wakeFunc
call|)
argument_list|(
name|node
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the execution function associated with a parity log overwrite node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_ParityLogOverwriteFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|caddr_t
name|buf
init|=
operator|(
name|caddr_t
operator|)
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_ParityLogData_t
modifier|*
name|logData
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|logData
operator|=
name|rf_CreateParityLogData
argument_list|(
name|RF_OVERWRITE
argument_list|,
name|pda
argument_list|,
name|buf
argument_list|,
operator|(
name|RF_Raid_t
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
argument_list|,
name|node
operator|->
name|wakeFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
argument_list|,
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|logData
condition|)
name|rf_ParityLogAppend
argument_list|(
name|logData
argument_list|,
name|RF_FALSE
argument_list|,
name|NULL
argument_list|,
name|RF_FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|plog_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
call|(
name|node
operator|->
name|wakeFunc
call|)
argument_list|(
name|node
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

begin_function
name|int
name|rf_ParityLogUpdateFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_ParityLogOverwriteFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

begin_function
name|int
name|rf_ParityLogUpdateUndoFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_ParityLogOverwriteUndoFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the execution function associated with a NOP node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_NullNodeFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|node
operator|->
name|status
operator|=
name|rf_good
expr_stmt|;
return|return
operator|(
name|rf_FinishNode
argument_list|(
name|node
argument_list|,
name|RF_THREAD_CONTEXT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_NullNodeUndoFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|node
operator|->
name|status
operator|=
name|rf_undone
expr_stmt|;
return|return
operator|(
name|rf_FinishNode
argument_list|(
name|node
argument_list|,
name|RF_THREAD_CONTEXT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the execution function associated with a disk-read node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_DiskReadFuncForThreads
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|caddr_t
name|buf
init|=
operator|(
name|caddr_t
operator|)
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
init|=
operator|(
name|RF_StripeNum_t
operator|)
name|node
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
decl_stmt|;
name|unsigned
name|priority
init|=
name|RF_EXTRACT_PRIORITY
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|unsigned
name|lock
init|=
name|RF_EXTRACT_LOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|unsigned
name|unlock
init|=
name|RF_EXTRACT_UNLOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|unsigned
name|which_ru
init|=
name|RF_EXTRACT_RU
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|RF_DiskQueueDataFlags_t
name|flags
init|=
literal|0
decl_stmt|;
name|RF_IoType_t
name|iotype
init|=
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
operator|)
condition|?
name|RF_IO_TYPE_READ
else|:
name|RF_IO_TYPE_NOP
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
modifier|*
name|dqs
init|=
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
operator|)
operator|->
name|Queues
decl_stmt|;
name|void
modifier|*
name|b_proc
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|bp
condition|)
name|b_proc
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|RF_Buf_t
operator|)
name|node
operator|->
name|dagHdr
operator|->
name|bp
operator|)
operator|->
name|b_proc
expr_stmt|;
endif|#
directive|endif
name|RF_ASSERT
argument_list|(
operator|!
operator|(
name|lock
operator|&&
name|unlock
operator|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|lock
operator|)
condition|?
name|RF_LOCK_DISK_QUEUE
else|:
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|unlock
operator|)
condition|?
name|RF_UNLOCK_DISK_QUEUE
else|:
literal|0
expr_stmt|;
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|iotype
argument_list|,
name|pda
operator|->
name|startSector
argument_list|,
name|pda
operator|->
name|numSector
argument_list|,
name|buf
argument_list|,
name|parityStripeID
argument_list|,
name|which_ru
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|node
operator|->
name|wakeFunc
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
argument_list|,
name|flags
argument_list|,
name|b_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
block|{
call|(
name|node
operator|->
name|wakeFunc
call|)
argument_list|(
name|node
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|dagFuncData
operator|=
operator|(
name|void
operator|*
operator|)
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
operator|(
name|dqs
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|)
argument_list|,
name|req
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the execution function associated with a disk-write node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_DiskWriteFuncForThreads
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|caddr_t
name|buf
init|=
operator|(
name|caddr_t
operator|)
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
init|=
operator|(
name|RF_StripeNum_t
operator|)
name|node
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
decl_stmt|;
name|unsigned
name|priority
init|=
name|RF_EXTRACT_PRIORITY
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|unsigned
name|lock
init|=
name|RF_EXTRACT_LOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|unsigned
name|unlock
init|=
name|RF_EXTRACT_UNLOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|unsigned
name|which_ru
init|=
name|RF_EXTRACT_RU
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
decl_stmt|;
name|RF_DiskQueueDataFlags_t
name|flags
init|=
literal|0
decl_stmt|;
name|RF_IoType_t
name|iotype
init|=
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
operator|)
condition|?
name|RF_IO_TYPE_WRITE
else|:
name|RF_IO_TYPE_NOP
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
modifier|*
name|dqs
init|=
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
operator|)
operator|->
name|Queues
decl_stmt|;
name|void
modifier|*
name|b_proc
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|bp
condition|)
name|b_proc
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|RF_Buf_t
operator|)
name|node
operator|->
name|dagHdr
operator|->
name|bp
operator|)
operator|->
name|b_proc
expr_stmt|;
endif|#
directive|endif
comment|/* normal processing (rollaway or forward recovery) begins here */
name|RF_ASSERT
argument_list|(
operator|!
operator|(
name|lock
operator|&&
name|unlock
operator|)
argument_list|)
expr_stmt|;
name|flags
operator||=
operator|(
name|lock
operator|)
condition|?
name|RF_LOCK_DISK_QUEUE
else|:
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|unlock
operator|)
condition|?
name|RF_UNLOCK_DISK_QUEUE
else|:
literal|0
expr_stmt|;
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|iotype
argument_list|,
name|pda
operator|->
name|startSector
argument_list|,
name|pda
operator|->
name|numSector
argument_list|,
name|buf
argument_list|,
name|parityStripeID
argument_list|,
name|which_ru
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|node
operator|->
name|wakeFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|,
name|NULL
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
argument_list|,
name|flags
argument_list|,
name|b_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
block|{
call|(
name|node
operator|->
name|wakeFunc
call|)
argument_list|(
name|node
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|dagFuncData
operator|=
operator|(
name|void
operator|*
operator|)
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
operator|(
name|dqs
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|)
argument_list|,
name|req
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the undo function for disk nodes  * Note:  this is not a proper undo of a write node, only locks are released.  *        old data is not restored to disk!  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_DiskUndoFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
modifier|*
name|dqs
init|=
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
operator|)
operator|->
name|Queues
decl_stmt|;
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_NOP
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|node
operator|->
name|wakeFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|,
name|NULL
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
argument_list|,
name|RF_UNLOCK_DISK_QUEUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
call|(
name|node
operator|->
name|wakeFunc
call|)
argument_list|(
name|node
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|->
name|dagFuncData
operator|=
operator|(
name|void
operator|*
operator|)
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
operator|(
name|dqs
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|)
argument_list|,
name|req
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * the execution function associated with an "unlock disk queue" node  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_DiskUnlockFuncForThreads
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
modifier|*
name|dqs
init|=
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
operator|)
operator|->
name|Queues
decl_stmt|;
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_NOP
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|node
operator|->
name|wakeFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|,
name|NULL
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|)
argument_list|,
name|RF_UNLOCK_DISK_QUEUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
condition|)
call|(
name|node
operator|->
name|wakeFunc
call|)
argument_list|(
name|node
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
else|else
block|{
name|node
operator|->
name|dagFuncData
operator|=
operator|(
name|void
operator|*
operator|)
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
operator|(
name|dqs
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|)
argument_list|,
name|req
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * Callback routine for DiskRead and DiskWrite nodes.  When the disk op completes,  * the routine is called to set the node status and inform the execution engine that  * the node has fired.  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_GenericWakeupFunc
parameter_list|(
name|node
parameter_list|,
name|status
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|node
operator|->
name|status
condition|)
block|{
case|case
name|rf_bwd1
case|:
name|node
operator|->
name|status
operator|=
name|rf_bwd2
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|dagFuncData
condition|)
name|rf_FreeDiskQueueData
argument_list|(
operator|(
name|RF_DiskQueueData_t
operator|*
operator|)
name|node
operator|->
name|dagFuncData
argument_list|)
expr_stmt|;
return|return
operator|(
name|rf_DiskWriteFuncForThreads
argument_list|(
name|node
argument_list|)
operator|)
return|;
break|break;
case|case
name|rf_fired
case|:
if|if
condition|(
name|status
condition|)
name|node
operator|->
name|status
operator|=
name|rf_bad
expr_stmt|;
else|else
name|node
operator|->
name|status
operator|=
name|rf_good
expr_stmt|;
break|break;
case|case
name|rf_recover
case|:
comment|/* probably should never reach this case */
if|if
condition|(
name|status
condition|)
name|node
operator|->
name|status
operator|=
name|rf_panic
expr_stmt|;
else|else
name|node
operator|->
name|status
operator|=
name|rf_undone
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"rf_GenericWakeupFunc:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"node->status is %d,"
argument_list|,
name|node
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status is %d \n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|node
operator|->
name|dagFuncData
condition|)
name|rf_FreeDiskQueueData
argument_list|(
operator|(
name|RF_DiskQueueData_t
operator|*
operator|)
name|node
operator|->
name|dagFuncData
argument_list|)
expr_stmt|;
return|return
operator|(
name|rf_FinishNode
argument_list|(
name|node
argument_list|,
name|RF_INTR_CONTEXT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * there are three distinct types of xor nodes  * A "regular xor" is used in the fault-free case where the access spans a complete  * stripe unit.  It assumes that the result buffer is one full stripe unit in size,  * and uses the stripe-unit-offset values that it computes from the PDAs to determine  * where within the stripe unit to XOR each argument buffer.  *  * A "simple xor" is used in the fault-free case where the access touches only a portion  * of one (or two, in some cases) stripe unit(s).  It assumes that all the argument  * buffers are of the same size and have the same stripe unit offset.  *  * A "recovery xor" is used in the degraded-mode case.  It's similar to the regular  * xor function except that it takes the failed PDA as an additional parameter, and  * uses it to determine what portions of the argument buffers need to be xor'd into  * the result buffer, and where in the result buffer they should go.  ****************************************************************************************/
end_comment

begin_comment
comment|/* xor the params together and store the result in the result field.  * assume the result field points to a buffer that is the size of one SU,  * and use the pda params to determine where within the buffer to XOR  * the input buffers.  */
end_comment

begin_function
name|int
name|rf_RegularXorFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
decl_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
comment|/* don't do the XOR if the input is the same as the output */
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|node
operator|->
name|results
index|[
literal|0
index|]
condition|)
block|{
name|retcode
operator|=
name|rf_XorIntoBuffer
argument_list|(
name|raidPtr
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|xor_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
name|retcode
argument_list|)
operator|)
return|;
comment|/* call wake func 							 * explicitly since no 							 * I/O in this node */
block|}
end_function

begin_comment
comment|/* xor the inputs into the result buffer, ignoring placement issues */
end_comment

begin_function
name|int
name|rf_SimpleXorFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* don't do the XOR if the input is the same as the output */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|node
operator|->
name|results
index|[
literal|0
index|]
condition|)
block|{
name|retcode
operator|=
name|rf_bxor
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|RF_Buf_t
operator|)
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|xor_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
name|retcode
argument_list|)
operator|)
return|;
comment|/* call wake func 							 * explicitly since no 							 * I/O in this node */
block|}
end_function

begin_comment
comment|/* this xor is used by the degraded-mode dag functions to recover lost data.  * the second-to-last parameter is the PDA for the failed portion of the access.  * the code here looks at this PDA and assumes that the xor target buffer is  * equal in size to the number of sectors in the failed PDA.  It then uses  * the other PDAs in the parameter list to determine where within the target  * buffer the corresponding data should be xored.  */
end_comment

begin_function
name|int
name|rf_RecoveryXorFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
name|suoffset
decl_stmt|,
name|failedSUOffset
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|node
operator|->
name|results
index|[
literal|0
index|]
condition|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|srcbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|destbuf
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
operator|)
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|suoffset
operator|-
name|failedSUOffset
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_bxor
argument_list|(
name|srcbuf
argument_list|,
name|destbuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|xor_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
name|retcode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * The next three functions are utilities used by the above xor-execution functions.  ****************************************************************************************/
end_comment

begin_comment
comment|/*  * this is just a glorified buffer xor.  targbuf points to a buffer that is one full stripe unit  * in size.  srcbuf points to a buffer that may be less than 1 SU, but never more.  When the  * access described by pda is one SU in size (which by implication means it's SU-aligned),  * all that happens is (targbuf)<- (srcbuf ^ targbuf).  When the access is less than one  * SU in size the XOR occurs on only the portion of targbuf identified in the pda.  */
end_comment

begin_function
name|int
name|rf_XorIntoBuffer
parameter_list|(
name|raidPtr
parameter_list|,
name|pda
parameter_list|,
name|srcbuf
parameter_list|,
name|targbuf
parameter_list|,
name|bp
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|;
name|char
modifier|*
name|targbuf
decl_stmt|;
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|char
modifier|*
name|targptr
decl_stmt|;
name|int
name|sectPerSU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|SUOffset
init|=
name|pda
operator|->
name|startSector
operator|%
name|sectPerSU
decl_stmt|;
name|int
name|length
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|->
name|numSector
operator|<=
name|sectPerSU
argument_list|)
expr_stmt|;
name|targptr
operator|=
name|targbuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|SUOffset
argument_list|)
expr_stmt|;
name|length
operator|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_bxor
argument_list|(
name|srcbuf
argument_list|,
name|targptr
argument_list|,
name|length
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* it really should be the case that the buffer pointers (returned by malloc)  * are aligned to the natural word size of the machine, so this is the only  * case we optimize for.  The length should always be a multiple of the sector  * size, so there should be no problem with leftover bytes at the end.  */
end_comment

begin_function
name|int
name|rf_bxor
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|len
parameter_list|,
name|bp
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|unsigned
name|mask
init|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|src
operator|)
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|dest
operator|)
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|len
operator|&
name|mask
operator|)
condition|)
block|{
name|retcode
operator|=
name|rf_longword_bxor
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|src
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dest
argument_list|,
name|len
operator|>>
name|RF_LONGSHIFT
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* map a user buffer into kernel space, if necessary */
end_comment

begin_define
define|#
directive|define
name|REMAP_VA
parameter_list|(
name|_bp
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|(y) = (x)
end_define

begin_comment
comment|/* When XORing in kernel mode, we need to map each user page to kernel space before we can access it.  * We don't want to assume anything about which input buffers are in kernel/user  * space, nor about their alignment, so in each loop we compute the maximum number  * of bytes that we can xor without crossing any page boundaries, and do only this many  * bytes before the next remap.  */
end_comment

begin_function
name|int
name|rf_longword_bxor
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|len
parameter_list|,
name|bp
parameter_list|)
name|unsigned
name|long
modifier|*
name|src
decl_stmt|;
name|unsigned
name|long
modifier|*
name|dest
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* longwords */
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|unsigned
name|long
modifier|*
name|end
init|=
name|src
operator|+
name|len
decl_stmt|;
name|unsigned
name|long
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
comment|/* temps */
name|unsigned
name|long
modifier|*
name|pg_src
decl_stmt|,
modifier|*
name|pg_dest
decl_stmt|;
comment|/* per-page source/dest 							 * pointers */
name|int
name|longs_this_time
decl_stmt|;
comment|/* # longwords to xor in the current iteration */
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|src
argument_list|,
name|pg_src
argument_list|)
expr_stmt|;
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|dest
argument_list|,
name|pg_dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_src
operator|||
operator|!
name|pg_dest
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|longs_this_time
operator|=
name|RF_MIN
argument_list|(
name|len
argument_list|,
name|RF_MIN
argument_list|(
name|RF_BLIP
argument_list|(
name|pg_src
argument_list|)
argument_list|,
name|RF_BLIP
argument_list|(
name|pg_dest
argument_list|)
argument_list|)
operator|>>
name|RF_LONGSHIFT
argument_list|)
expr_stmt|;
comment|/* note len in longwords */
name|src
operator|+=
name|longs_this_time
expr_stmt|;
name|dest
operator|+=
name|longs_this_time
expr_stmt|;
name|len
operator|-=
name|longs_this_time
expr_stmt|;
while|while
condition|(
name|longs_this_time
operator|>=
literal|4
condition|)
block|{
name|d0
operator|=
name|pg_dest
index|[
literal|0
index|]
expr_stmt|;
name|d1
operator|=
name|pg_dest
index|[
literal|1
index|]
expr_stmt|;
name|d2
operator|=
name|pg_dest
index|[
literal|2
index|]
expr_stmt|;
name|d3
operator|=
name|pg_dest
index|[
literal|3
index|]
expr_stmt|;
name|s0
operator|=
name|pg_src
index|[
literal|0
index|]
expr_stmt|;
name|s1
operator|=
name|pg_src
index|[
literal|1
index|]
expr_stmt|;
name|s2
operator|=
name|pg_src
index|[
literal|2
index|]
expr_stmt|;
name|s3
operator|=
name|pg_src
index|[
literal|3
index|]
expr_stmt|;
name|pg_dest
index|[
literal|0
index|]
operator|=
name|d0
operator|^
name|s0
expr_stmt|;
name|pg_dest
index|[
literal|1
index|]
operator|=
name|d1
operator|^
name|s1
expr_stmt|;
name|pg_dest
index|[
literal|2
index|]
operator|=
name|d2
operator|^
name|s2
expr_stmt|;
name|pg_dest
index|[
literal|3
index|]
operator|=
name|d3
operator|^
name|s3
expr_stmt|;
name|pg_src
operator|+=
literal|4
expr_stmt|;
name|pg_dest
operator|+=
literal|4
expr_stmt|;
name|longs_this_time
operator|-=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|longs_this_time
operator|>
literal|0
condition|)
block|{
comment|/* cannot cross any page 						 * boundaries here */
operator|*
name|pg_dest
operator|++
operator|^=
operator|*
name|pg_src
operator|++
expr_stmt|;
name|longs_this_time
operator|--
expr_stmt|;
block|}
comment|/* either we're done, or we've reached a page boundary on one 		 * (or possibly both) of the pointers */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|src
argument_list|)
condition|)
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|src
argument_list|,
name|pg_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|dest
argument_list|)
condition|)
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|dest
argument_list|,
name|pg_dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_src
operator|||
operator|!
name|pg_dest
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
while|while
condition|(
name|src
operator|<
name|end
condition|)
block|{
operator|*
name|pg_dest
operator|++
operator|^=
operator|*
name|pg_src
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|dest
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|src
argument_list|)
condition|)
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|src
argument_list|,
name|pg_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|dest
argument_list|)
condition|)
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|dest
argument_list|,
name|pg_dest
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    dst = a ^ b ^ c;    a may equal dst    see comment above longword_bxor */
end_comment

begin_function
name|int
name|rf_longword_bxor3
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|len
parameter_list|,
name|bp
parameter_list|)
name|unsigned
name|long
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|long
modifier|*
name|a
decl_stmt|;
name|unsigned
name|long
modifier|*
name|b
decl_stmt|;
name|unsigned
name|long
modifier|*
name|c
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* length in longwords */
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pg_a
decl_stmt|,
modifier|*
name|pg_b
decl_stmt|,
modifier|*
name|pg_c
decl_stmt|,
modifier|*
name|pg_dst
decl_stmt|;
comment|/* per-page source/dest 								 * pointers */
name|int
name|longs_this_time
decl_stmt|;
comment|/* # longs to xor in the current iteration */
name|char
name|dst_is_a
init|=
literal|0
decl_stmt|;
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|a
argument_list|,
name|pg_a
argument_list|)
expr_stmt|;
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|b
argument_list|,
name|pg_b
argument_list|)
expr_stmt|;
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|c
argument_list|,
name|pg_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|dst
condition|)
block|{
name|pg_dst
operator|=
name|pg_a
expr_stmt|;
name|dst_is_a
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|,
name|pg_dst
argument_list|)
expr_stmt|;
block|}
comment|/* align dest to cache line.  Can't cross a pg boundary on dst here. */
while|while
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pg_dst
operator|)
operator|&
literal|0x1f
operator|)
condition|)
block|{
operator|*
name|pg_dst
operator|++
operator|=
operator|*
name|pg_a
operator|++
operator|^
operator|*
name|pg_b
operator|++
operator|^
operator|*
name|pg_c
operator|++
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|a
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|a
argument_list|,
name|pg_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_a
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|a
argument_list|,
name|pg_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_b
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|a
argument_list|,
name|pg_c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_c
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|len
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
literal|4
condition|)
block|{
name|longs_this_time
operator|=
name|RF_MIN
argument_list|(
name|len
argument_list|,
name|RF_MIN
argument_list|(
name|RF_BLIP
argument_list|(
name|a
argument_list|)
argument_list|,
name|RF_MIN
argument_list|(
name|RF_BLIP
argument_list|(
name|b
argument_list|)
argument_list|,
name|RF_MIN
argument_list|(
name|RF_BLIP
argument_list|(
name|c
argument_list|)
argument_list|,
name|RF_BLIP
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>>
name|RF_LONGSHIFT
argument_list|)
expr_stmt|;
name|a
operator|+=
name|longs_this_time
expr_stmt|;
name|b
operator|+=
name|longs_this_time
expr_stmt|;
name|c
operator|+=
name|longs_this_time
expr_stmt|;
name|dst
operator|+=
name|longs_this_time
expr_stmt|;
name|len
operator|-=
name|longs_this_time
expr_stmt|;
while|while
condition|(
name|longs_this_time
operator|>=
literal|4
condition|)
block|{
name|a0
operator|=
name|pg_a
index|[
literal|0
index|]
expr_stmt|;
name|longs_this_time
operator|-=
literal|4
expr_stmt|;
name|a1
operator|=
name|pg_a
index|[
literal|1
index|]
expr_stmt|;
name|a2
operator|=
name|pg_a
index|[
literal|2
index|]
expr_stmt|;
name|a3
operator|=
name|pg_a
index|[
literal|3
index|]
expr_stmt|;
name|pg_a
operator|+=
literal|4
expr_stmt|;
name|b0
operator|=
name|pg_b
index|[
literal|0
index|]
expr_stmt|;
name|b1
operator|=
name|pg_b
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
name|pg_b
index|[
literal|2
index|]
expr_stmt|;
name|b3
operator|=
name|pg_b
index|[
literal|3
index|]
expr_stmt|;
comment|/* start dual issue */
name|a0
operator|^=
name|b0
expr_stmt|;
name|b0
operator|=
name|pg_c
index|[
literal|0
index|]
expr_stmt|;
name|pg_b
operator|+=
literal|4
expr_stmt|;
name|a1
operator|^=
name|b1
expr_stmt|;
name|a2
operator|^=
name|b2
expr_stmt|;
name|a3
operator|^=
name|b3
expr_stmt|;
name|b1
operator|=
name|pg_c
index|[
literal|1
index|]
expr_stmt|;
name|a0
operator|^=
name|b0
expr_stmt|;
name|b2
operator|=
name|pg_c
index|[
literal|2
index|]
expr_stmt|;
name|a1
operator|^=
name|b1
expr_stmt|;
name|b3
operator|=
name|pg_c
index|[
literal|3
index|]
expr_stmt|;
name|a2
operator|^=
name|b2
expr_stmt|;
name|pg_dst
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
name|a3
operator|^=
name|b3
expr_stmt|;
name|pg_dst
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|pg_c
operator|+=
literal|4
expr_stmt|;
name|pg_dst
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|pg_dst
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|pg_dst
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|longs_this_time
operator|>
literal|0
condition|)
block|{
comment|/* cannot cross any page 						 * boundaries here */
operator|*
name|pg_dst
operator|++
operator|=
operator|*
name|pg_a
operator|++
operator|^
operator|*
name|pg_b
operator|++
operator|^
operator|*
name|pg_c
operator|++
expr_stmt|;
name|longs_this_time
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|a
argument_list|,
name|pg_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_a
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|dst_is_a
condition|)
name|pg_dst
operator|=
name|pg_a
expr_stmt|;
block|}
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|b
argument_list|,
name|pg_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_b
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|c
argument_list|,
name|pg_c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_c
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dst_is_a
condition|)
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|,
name|pg_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_dst
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
block|}
while|while
condition|(
name|len
condition|)
block|{
operator|*
name|pg_dst
operator|++
operator|=
operator|*
name|pg_a
operator|++
operator|^
operator|*
name|pg_b
operator|++
operator|^
operator|*
name|pg_c
operator|++
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|a
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|a
argument_list|,
name|pg_a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_a
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|dst_is_a
condition|)
name|pg_dst
operator|=
name|pg_a
expr_stmt|;
block|}
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|b
argument_list|,
name|pg_b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_b
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|c
argument_list|,
name|pg_c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_c
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dst_is_a
condition|)
if|if
condition|(
name|RF_PAGE_ALIGNED
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|REMAP_VA
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|,
name|pg_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg_dst
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|len
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_bxor3
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|len
parameter_list|,
name|bp
parameter_list|)
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|char
modifier|*
name|a
decl_stmt|;
name|unsigned
name|char
modifier|*
name|b
decl_stmt|;
name|unsigned
name|char
modifier|*
name|c
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|RF_ASSERT
argument_list|(
operator|(
operator|(
name|RF_UL
argument_list|(
name|dst
argument_list|)
operator||
name|RF_UL
argument_list|(
name|a
argument_list|)
operator||
name|RF_UL
argument_list|(
name|b
argument_list|)
operator||
name|RF_UL
argument_list|(
name|c
argument_list|)
operator||
name|len
operator|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rf_longword_bxor3
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dst
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|a
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|b
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|c
argument_list|,
name|len
operator|>>
name|RF_LONGSHIFT
argument_list|,
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

