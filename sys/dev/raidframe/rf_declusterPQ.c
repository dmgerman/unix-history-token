begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_declusterPQ.c,v 1.5 2001/01/26 14:06:17 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Daniel Stodolsky, Mark Holland, Jim Zelenka  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*--------------------------------------------------  * rf_declusterPQ.c  *  * mapping code for declustered P& Q or declustered EvenOdd  * much code borrowed from rf_decluster.c  *  *--------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_declusterPQ.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_PARITY_DECLUSTERING_PQ
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_EVENODD
operator|>
literal|0
operator|)
end_if

begin_comment
comment|/* configuration code */
end_comment

begin_function
name|int
name|rf_ConfigureDeclusteredPQ
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|b
decl_stmt|,
name|v
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|,
name|lambda
decl_stmt|;
comment|/* block design params */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
decl_stmt|;
name|int
modifier|*
name|first_avail_slot
decl_stmt|;
name|int
name|complete_FT_count
decl_stmt|,
name|SUID
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|int
name|numCompleteFullTablesPerDisk
decl_stmt|;
name|int
name|PUsPerDisk
decl_stmt|,
name|spareRegionDepthInPUs
decl_stmt|,
name|numCompleteSpareRegionsPerDisk
init|=
literal|0
decl_stmt|,
name|extraPUsPerDisk
decl_stmt|;
name|int
name|totSparePUsPerDisk
decl_stmt|;
name|int
name|diskOffsetOfLastFullTableInSUs
decl_stmt|,
name|SpareSpaceInSUs
decl_stmt|;
name|char
modifier|*
name|cfgBuf
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|cfgPtr
operator|->
name|layoutSpecific
operator|)
decl_stmt|;
name|cfgBuf
operator|+=
name|RF_SPAREMAP_NAME_LEN
expr_stmt|;
name|b
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|v
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|r
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|lambda
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|noRotate
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"RAIDFRAME: k=%d, minimum value 2\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 1. create layout specific structure */
name|RF_MallocAndAdd
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeclusteredConfigInfo_t
argument_list|)
argument_list|,
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|layoutPtr
operator|->
name|layoutSpecificInfo
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
comment|/* the sparemaps are generated assuming that parity is rotated, so we 	 * issue a warning if both distributed sparing and no-rotate are on at 	 * the same time */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
operator|&&
name|raidPtr
operator|->
name|noRotate
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Warning:  distributed sparing specified without parity rotation.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|numCol
operator|!=
name|v
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"RAID: config error: table element count (%d) not equal to no. of cols (%d)\n"
argument_list|,
name|v
argument_list|,
name|raidPtr
operator|->
name|numCol
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 3.  set up the values used in devRaidMap */
name|info
operator|->
name|BlocksPerTable
operator|=
name|b
expr_stmt|;
name|info
operator|->
name|NumParityReps
operator|=
name|info
operator|->
name|groupSize
operator|=
name|k
expr_stmt|;
name|info
operator|->
name|PUsPerBlock
operator|=
name|k
operator|-
literal|2
expr_stmt|;
comment|/* PQ */
name|info
operator|->
name|SUsPerTable
operator|=
name|b
operator|*
name|info
operator|->
name|PUsPerBlock
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* b blks, k-1 SUs each */
name|info
operator|->
name|SUsPerFullTable
operator|=
name|k
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
comment|/* rot k times */
name|info
operator|->
name|SUsPerBlock
operator|=
name|info
operator|->
name|PUsPerBlock
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|info
operator|->
name|TableDepthInPUs
operator|=
operator|(
name|b
operator|*
name|k
operator|)
operator|/
name|v
expr_stmt|;
name|info
operator|->
name|FullTableDepthInPUs
operator|=
name|info
operator|->
name|TableDepthInPUs
operator|*
name|k
expr_stmt|;
comment|/* k repetitions */
comment|/* used only in distributed sparing case */
name|info
operator|->
name|FullTablesPerSpareRegion
operator|=
operator|(
name|v
operator|-
literal|1
operator|)
operator|/
name|rf_gcd
argument_list|(
name|r
argument_list|,
name|v
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* (v-1)/gcd fulltables */
name|info
operator|->
name|TablesPerSpareRegion
operator|=
name|k
operator|*
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|=
operator|(
name|r
operator|*
name|info
operator|->
name|TablesPerSpareRegion
operator|/
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* check to make sure the block design is sufficiently small */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|+
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|>
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\n"
argument_list|,
operator|(
name|int
operator|)
name|info
operator|->
name|FullTableDepthInPUs
argument_list|,
operator|(
name|int
operator|)
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
argument_list|,
operator|(
name|int
operator|)
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|>
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* compute the size of each disk, and the number of tables in the last 	 * fulltable (which need not be complete) */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|PUsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|spareRegionDepthInPUs
operator|=
operator|(
name|info
operator|->
name|TablesPerSpareRegion
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|+
operator|(
name|info
operator|->
name|TablesPerSpareRegion
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|)
operator|/
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|SpareRegionDepthInSUs
operator|=
name|spareRegionDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|numCompleteSpareRegionsPerDisk
operator|=
name|PUsPerDisk
operator|/
name|spareRegionDepthInPUs
expr_stmt|;
name|info
operator|->
name|NumCompleteSRs
operator|=
name|numCompleteSpareRegionsPerDisk
expr_stmt|;
name|extraPUsPerDisk
operator|=
name|PUsPerDisk
operator|%
name|spareRegionDepthInPUs
expr_stmt|;
comment|/* assume conservatively that we need the full amount of spare 		 * space in one region in order to provide spares for the 		 * partial spare region at the end of the array.  We set "i" 		 * to the number of tables in the partial spare region.  This 		 * may actually include some fulltables. */
name|extraPUsPerDisk
operator|-=
operator|(
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
if|if
condition|(
name|extraPUsPerDisk
operator|<=
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|=
name|extraPUsPerDisk
operator|/
name|info
operator|->
name|TableDepthInPUs
expr_stmt|;
name|complete_FT_count
operator|=
name|raidPtr
operator|->
name|numRow
operator|*
operator|(
name|numCompleteSpareRegionsPerDisk
operator|*
operator|(
name|info
operator|->
name|TablesPerSpareRegion
operator|/
name|k
operator|)
operator|+
name|i
operator|/
name|k
operator|)
expr_stmt|;
name|info
operator|->
name|FullTableLimitSUID
operator|=
name|complete_FT_count
operator|*
name|info
operator|->
name|SUsPerFullTable
expr_stmt|;
name|info
operator|->
name|ExtraTablesPerDisk
operator|=
name|i
operator|%
name|k
expr_stmt|;
comment|/* note that in the last spare region, the spare space is 		 * complete even though data/parity space is not */
name|totSparePUsPerDisk
operator|=
operator|(
name|numCompleteSpareRegionsPerDisk
operator|+
literal|1
operator|)
operator|*
operator|(
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
name|info
operator|->
name|TotSparePUsPerDisk
operator|=
name|totSparePUsPerDisk
expr_stmt|;
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|=
operator|(
operator|(
name|complete_FT_count
operator|/
name|raidPtr
operator|->
name|numRow
operator|)
operator|*
name|info
operator|->
name|FullTableDepthInPUs
operator|+
comment|/* data& parity space */
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|+
name|totSparePUsPerDisk
comment|/* spare space */
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|layoutPtr
operator|->
name|dataStripeUnitsPerDisk
operator|=
operator|(
name|complete_FT_count
operator|*
name|info
operator|->
name|FullTableDepthInPUs
operator|+
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
operator|/
name|k
expr_stmt|;
block|}
else|else
block|{
comment|/* non-dist spare case:  force each disk to contain an 		 * integral number of tables */
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/=
operator|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*=
operator|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
comment|/* compute the number of tables in the last fulltable, which 		 * need not be complete */
name|complete_FT_count
operator|=
operator|(
operator|(
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|/
name|info
operator|->
name|FullTableDepthInPUs
operator|)
operator|*
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|info
operator|->
name|FullTableLimitSUID
operator|=
name|complete_FT_count
operator|*
name|info
operator|->
name|SUsPerFullTable
expr_stmt|;
name|info
operator|->
name|ExtraTablesPerDisk
operator|=
operator|(
operator|(
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|/
name|info
operator|->
name|TableDepthInPUs
operator|)
operator|%
name|k
expr_stmt|;
block|}
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
comment|/* find the disk offset of the stripe unit where the last fulltable 	 * starts */
name|numCompleteFullTablesPerDisk
operator|=
name|complete_FT_count
operator|/
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|diskOffsetOfLastFullTableInSUs
operator|=
name|numCompleteFullTablesPerDisk
operator|*
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|SpareSpaceInSUs
operator|=
name|numCompleteSpareRegionsPerDisk
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
name|diskOffsetOfLastFullTableInSUs
operator|+=
name|SpareSpaceInSUs
expr_stmt|;
name|info
operator|->
name|DiskOffsetOfLastSpareSpaceChunkInSUs
operator|=
name|diskOffsetOfLastFullTableInSUs
operator|+
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
block|}
name|info
operator|->
name|DiskOffsetOfLastFullTableInSUs
operator|=
name|diskOffsetOfLastFullTableInSUs
expr_stmt|;
name|info
operator|->
name|numCompleteFullTablesPerDisk
operator|=
name|numCompleteFullTablesPerDisk
expr_stmt|;
comment|/* 4.  create and initialize the lookup tables */
name|info
operator|->
name|LayoutTable
operator|=
name|rf_make_2d_array
argument_list|(
name|b
argument_list|,
name|k
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|LayoutTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|info
operator|->
name|OffsetTable
operator|=
name|rf_make_2d_array
argument_list|(
name|b
argument_list|,
name|k
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|OffsetTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|info
operator|->
name|BlockTable
operator|=
name|rf_make_2d_array
argument_list|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
argument_list|,
name|raidPtr
operator|->
name|numCol
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|BlockTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|first_avail_slot
operator|=
operator|(
name|int
operator|*
operator|)
name|rf_make_1d_array
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_avail_slot
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|*
name|cfgBuf
operator|++
expr_stmt|;
comment|/* initialize offset table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|info
operator|->
name|OffsetTable
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|first_avail_slot
index|[
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
index|]
expr_stmt|;
name|first_avail_slot
index|[
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
index|]
operator|++
expr_stmt|;
block|}
comment|/* initialize block table */
for|for
control|(
name|SUID
operator|=
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|layoutPtr
operator|->
name|SUsPerPU
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|info
operator|->
name|BlockTable
index|[
operator|(
name|info
operator|->
name|OffsetTable
index|[
name|i
index|]
index|[
name|j
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|+
name|l
index|]
index|[
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
index|]
operator|=
name|SUID
expr_stmt|;
block|}
name|SUID
operator|++
expr_stmt|;
block|}
block|}
name|rf_free_1d_array
argument_list|(
name|first_avail_slot
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 5.  set up the remaining redundant-but-useful parameters */
name|raidPtr
operator|->
name|totalSectors
operator|=
operator|(
name|k
operator|*
name|complete_FT_count
operator|+
name|raidPtr
operator|->
name|numRow
operator|*
name|info
operator|->
name|ExtraTablesPerDisk
operator|)
operator|*
name|info
operator|->
name|SUsPerTable
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|numStripe
operator|=
operator|(
name|raidPtr
operator|->
name|totalSectors
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
operator|/
operator|(
name|k
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* strange evaluation order below to try and minimize overflow 	 * problems */
name|layoutPtr
operator|->
name|dataSectorsPerStripe
operator|=
operator|(
name|k
operator|-
literal|2
operator|)
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|bytesPerStripeUnit
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|layoutPtr
operator|->
name|numDataCol
operator|=
name|k
operator|-
literal|2
expr_stmt|;
name|layoutPtr
operator|->
name|numParityCol
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_GetDefaultNumFloatingReconBuffersPQ
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|int
name|def_decl
decl_stmt|;
name|def_decl
operator|=
name|rf_GetDefaultNumFloatingReconBuffersDeclustered
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|RF_MAX
argument_list|(
literal|3
operator|*
name|raidPtr
operator|->
name|numCol
argument_list|,
name|def_decl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_MapSectorDeclusteredPQ
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|FullTableID
decl_stmt|,
name|FullTableOffset
decl_stmt|,
name|TableID
decl_stmt|,
name|TableOffset
decl_stmt|;
name|RF_StripeNum_t
name|BlockID
decl_stmt|,
name|BlockOffset
decl_stmt|,
name|RepIndex
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|,
name|outSU
decl_stmt|,
name|SpareRegion
init|=
literal|0
decl_stmt|,
name|SpareSpace
init|=
literal|0
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
comment|/* fulltable ID within array 						 * (across rows) */
operator|*
name|row
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|FullTableID
operator|/=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
comment|/* convert to fulltable ID on this 					 * disk */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|SpareRegion
operator|=
name|FullTableID
operator|/
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|SpareSpace
operator|=
name|SpareRegion
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
block|}
name|FullTableOffset
operator|=
name|SUID
operator|%
name|sus_per_fulltable
expr_stmt|;
name|TableID
operator|=
name|FullTableOffset
operator|/
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|TableOffset
operator|=
name|FullTableOffset
operator|-
name|TableID
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|BlockID
operator|=
name|TableOffset
operator|/
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockOffset
operator|=
name|TableOffset
operator|-
name|BlockID
operator|*
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockID
operator|%=
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|BlockOffset
operator|<
name|info
operator|->
name|groupSize
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/*            TableIDs go from 0 .. GroupSize-1 inclusive.            PUsPerBlock is k-2.            We want the tableIDs to rotate from the            right, so use GroupSize            */
name|RepIndex
operator|=
name|info
operator|->
name|groupSize
operator|-
literal|1
operator|-
name|TableID
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|RepIndex
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|noRotate
condition|)
block|{
if|if
condition|(
name|TableID
operator|==
literal|0
condition|)
name|BlockOffset
operator|++
expr_stmt|;
comment|/* P on last drive, Q on first */
else|else
name|BlockOffset
operator|+=
operator|(
operator|(
name|BlockOffset
operator|>=
name|RepIndex
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
comment|/* skip over PQ */
name|RF_ASSERT
argument_list|(
name|BlockOffset
operator|<
name|info
operator|->
name|groupSize
argument_list|)
expr_stmt|;
operator|*
name|col
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|BlockID
index|]
index|[
name|BlockOffset
index|]
expr_stmt|;
block|}
comment|/* remap to distributed spare space if indicated */
if|if
condition|(
name|remap
condition|)
block|{
name|rf_remap_to_spare_space
argument_list|(
name|layoutPtr
argument_list|,
name|info
argument_list|,
operator|*
name|row
argument_list|,
name|FullTableID
argument_list|,
name|TableID
argument_list|,
name|BlockID
argument_list|,
operator|(
name|base_suid
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|SpareRegion
argument_list|,
name|col
argument_list|,
operator|&
name|outSU
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outSU
operator|=
name|base_suid
expr_stmt|;
name|outSU
operator|+=
name|FullTableID
operator|*
name|fulltable_depth
expr_stmt|;
comment|/* offs to strt of FT */
name|outSU
operator|+=
name|SpareSpace
expr_stmt|;
comment|/* skip rsvd spare space */
name|outSU
operator|+=
name|TableID
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* offs to strt of tble */
name|outSU
operator|+=
name|info
operator|->
name|OffsetTable
index|[
name|BlockID
index|]
index|[
name|BlockOffset
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* offs to the PU */
block|}
name|outSU
operator|+=
name|TableOffset
operator|/
operator|(
name|info
operator|->
name|BlocksPerTable
operator|*
name|info
operator|->
name|PUsPerBlock
operator|)
expr_stmt|;
comment|/* offs to the SU within 										 * a PU */
comment|/* convert SUs to sectors, and, if not aligned to SU boundary, add in 	 * offset to sector */
operator|*
name|diskSector
operator|=
name|outSU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_MapParityDeclusteredPQ
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|FullTableID
decl_stmt|,
name|FullTableOffset
decl_stmt|,
name|TableID
decl_stmt|,
name|TableOffset
decl_stmt|;
name|RF_StripeNum_t
name|BlockID
decl_stmt|,
name|BlockOffset
decl_stmt|,
name|RepIndex
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|,
name|outSU
decl_stmt|,
name|SpareRegion
decl_stmt|,
name|SpareSpace
init|=
literal|0
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
comment|/* compute row& (possibly) spare space exactly as before */
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
operator|*
name|row
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|FullTableID
operator|/=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
comment|/* convert to fulltable ID on this 					 * disk */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|SpareRegion
operator|=
name|FullTableID
operator|/
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|SpareSpace
operator|=
name|SpareRegion
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
block|}
comment|/* compute BlockID and RepIndex exactly as before */
name|FullTableOffset
operator|=
name|SUID
operator|%
name|sus_per_fulltable
expr_stmt|;
name|TableID
operator|=
name|FullTableOffset
operator|/
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|TableOffset
operator|=
name|FullTableOffset
operator|-
name|TableID
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|BlockID
operator|=
name|TableOffset
operator|/
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockOffset
operator|=
name|TableOffset
operator|-
name|BlockID
operator|*
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockID
operator|%=
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
comment|/* the parity block is in the position indicated by RepIndex */
name|RepIndex
operator|=
operator|(
name|raidPtr
operator|->
name|noRotate
operator|)
condition|?
name|info
operator|->
name|PUsPerBlock
else|:
name|info
operator|->
name|groupSize
operator|-
literal|1
operator|-
name|TableID
expr_stmt|;
operator|*
name|col
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|BlockID
index|]
index|[
name|RepIndex
index|]
expr_stmt|;
if|if
condition|(
name|remap
condition|)
name|RF_PANIC
argument_list|()
expr_stmt|;
comment|/* compute sector as before, except use RepIndex instead of 	 * BlockOffset */
name|outSU
operator|=
name|base_suid
expr_stmt|;
name|outSU
operator|+=
name|FullTableID
operator|*
name|fulltable_depth
expr_stmt|;
name|outSU
operator|+=
name|SpareSpace
expr_stmt|;
comment|/* skip rsvd spare space */
name|outSU
operator|+=
name|TableID
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|outSU
operator|+=
name|info
operator|->
name|OffsetTable
index|[
name|BlockID
index|]
index|[
name|RepIndex
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|outSU
operator|+=
name|TableOffset
operator|/
operator|(
name|info
operator|->
name|BlocksPerTable
operator|*
name|info
operator|->
name|PUsPerBlock
operator|)
expr_stmt|;
operator|*
name|diskSector
operator|=
name|outSU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_MapQDeclusteredPQ
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|FullTableID
decl_stmt|,
name|FullTableOffset
decl_stmt|,
name|TableID
decl_stmt|,
name|TableOffset
decl_stmt|;
name|RF_StripeNum_t
name|BlockID
decl_stmt|,
name|BlockOffset
decl_stmt|,
name|RepIndex
decl_stmt|,
name|RepIndexQ
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|,
name|outSU
decl_stmt|,
name|SpareRegion
decl_stmt|,
name|SpareSpace
init|=
literal|0
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
comment|/* compute row& (possibly) spare space exactly as before */
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
operator|*
name|row
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|FullTableID
operator|/=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
comment|/* convert to fulltable ID on this 					 * disk */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|SpareRegion
operator|=
name|FullTableID
operator|/
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|SpareSpace
operator|=
name|SpareRegion
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
block|}
comment|/* compute BlockID and RepIndex exactly as before */
name|FullTableOffset
operator|=
name|SUID
operator|%
name|sus_per_fulltable
expr_stmt|;
name|TableID
operator|=
name|FullTableOffset
operator|/
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|TableOffset
operator|=
name|FullTableOffset
operator|-
name|TableID
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|BlockID
operator|=
name|TableOffset
operator|/
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockOffset
operator|=
name|TableOffset
operator|-
name|BlockID
operator|*
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockID
operator|%=
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
comment|/* the q block is in the position indicated by RepIndex */
name|RepIndex
operator|=
operator|(
name|raidPtr
operator|->
name|noRotate
operator|)
condition|?
name|info
operator|->
name|PUsPerBlock
else|:
name|info
operator|->
name|groupSize
operator|-
literal|1
operator|-
name|TableID
expr_stmt|;
name|RepIndexQ
operator|=
operator|(
operator|(
name|RepIndex
operator|==
operator|(
name|info
operator|->
name|groupSize
operator|-
literal|1
operator|)
operator|)
condition|?
literal|0
else|:
name|RepIndex
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|col
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|BlockID
index|]
index|[
name|RepIndexQ
index|]
expr_stmt|;
if|if
condition|(
name|remap
condition|)
name|RF_PANIC
argument_list|()
expr_stmt|;
comment|/* compute sector as before, except use RepIndex instead of 	 * BlockOffset */
name|outSU
operator|=
name|base_suid
expr_stmt|;
name|outSU
operator|+=
name|FullTableID
operator|*
name|fulltable_depth
expr_stmt|;
name|outSU
operator|+=
name|SpareSpace
expr_stmt|;
comment|/* skip rsvd spare space */
name|outSU
operator|+=
name|TableID
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|outSU
operator|+=
name|TableOffset
operator|/
operator|(
name|info
operator|->
name|BlocksPerTable
operator|*
name|info
operator|->
name|PUsPerBlock
operator|)
expr_stmt|;
name|outSU
operator|+=
name|info
operator|->
name|OffsetTable
index|[
name|BlockID
index|]
index|[
name|RepIndexQ
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
operator|*
name|diskSector
operator|=
name|outSU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns an array of ints identifying the disks that comprise the stripe containing the indicated address.  * the caller must _never_ attempt to modify this array.  */
end_comment

begin_function
name|void
name|rf_IdentifyStripeDeclusteredPQ
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|addr
parameter_list|,
name|RF_RowCol_t
modifier|*
modifier|*
name|diskids
parameter_list|,
name|RF_RowCol_t
modifier|*
name|outRow
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RF_StripeNum_t
name|stripeID
decl_stmt|,
name|FullTableID
decl_stmt|;
name|int
name|tableOffset
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
comment|/* fulltable ID within array 						 * (across rows) */
operator|*
name|outRow
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|stripeID
operator|=
name|rf_StripeUnitIDToStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|SUID
argument_list|)
expr_stmt|;
comment|/* find stripe offset 								 * into array */
name|tableOffset
operator|=
operator|(
name|stripeID
operator|%
name|info
operator|->
name|BlocksPerTable
operator|)
expr_stmt|;
comment|/* find offset into 								 * block design table */
operator|*
name|diskids
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|tableOffset
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_PARITY_DECLUSTERING_PQ> 0) || (RF_INCLUDE_EVENODD> 0) */
end_comment

end_unit

