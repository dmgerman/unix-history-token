begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_reconmap.c,v 1.6 1999/08/14 21:44:24 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*************************************************************************  * rf_reconmap.c  *  * code to maintain a map of what sectors have/have not been reconstructed  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_comment
comment|/* special pointer values indicating that a reconstruction unit  * has been either totally reconstructed or not at all.  Both  * are illegal pointer values, so you have to be careful not to  * dereference through them.  RU_NOTHING must be zero, since  * MakeReconMap uses bzero to initialize the structure.  These are used  * only at the head of the list.  */
end_comment

begin_define
define|#
directive|define
name|RU_ALL
value|((RF_ReconMapListElem_t *) -1)
end_define

begin_define
define|#
directive|define
name|RU_NOTHING
value|((RF_ReconMapListElem_t *) 0)
end_define

begin_comment
comment|/* used to mark the end of the list */
end_comment

begin_define
define|#
directive|define
name|RU_NIL
value|((RF_ReconMapListElem_t *) 0)
end_define

begin_function_decl
specifier|static
name|void
name|compact_stat_entry
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ReconMap_t
modifier|*
name|mapPtr
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|crunch_list
parameter_list|(
name|RF_ReconMap_t
modifier|*
name|mapPtr
parameter_list|,
name|RF_ReconMapListElem_t
modifier|*
name|listPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RF_ReconMapListElem_t
modifier|*
name|MakeReconMapListElem
parameter_list|(
name|RF_SectorNum_t
name|startSector
parameter_list|,
name|RF_SectorNum_t
name|stopSector
parameter_list|,
name|RF_ReconMapListElem_t
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FreeReconMapListElem
parameter_list|(
name|RF_ReconMap_t
modifier|*
name|mapPtr
parameter_list|,
name|RF_ReconMapListElem_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_size
parameter_list|(
name|RF_ReconMap_t
modifier|*
name|mapPtr
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PrintList
parameter_list|(
name|RF_ReconMapListElem_t
modifier|*
name|listPtr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * Creates and initializes new Reconstruction map  *  *-----------------------------------------------------------------------------*/
end_comment

begin_function
name|RF_ReconMap_t
modifier|*
name|rf_MakeReconMap
parameter_list|(
name|raidPtr
parameter_list|,
name|ru_sectors
parameter_list|,
name|disk_sectors
parameter_list|,
name|spareUnitsPerDisk
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_SectorCount_t
name|ru_sectors
decl_stmt|;
comment|/* size of reconstruction unit in 					 * sectors */
name|RF_SectorCount_t
name|disk_sectors
decl_stmt|;
comment|/* size of disk in sectors */
name|RF_ReconUnitCount_t
name|spareUnitsPerDisk
decl_stmt|;
comment|/* zero unless distributed 						 * sparing */
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_ReconUnitCount_t
name|num_rus
init|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerRU
decl_stmt|;
name|RF_ReconMap_t
modifier|*
name|p
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|RF_Malloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconMap_t
argument_list|)
argument_list|,
operator|(
name|RF_ReconMap_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|sectorsPerReconUnit
operator|=
name|ru_sectors
expr_stmt|;
name|p
operator|->
name|sectorsInDisk
operator|=
name|disk_sectors
expr_stmt|;
name|p
operator|->
name|totalRUs
operator|=
name|num_rus
expr_stmt|;
name|p
operator|->
name|spareRUs
operator|=
name|spareUnitsPerDisk
expr_stmt|;
name|p
operator|->
name|unitsLeft
operator|=
name|num_rus
operator|-
name|spareUnitsPerDisk
expr_stmt|;
name|RF_Malloc
argument_list|(
name|p
operator|->
name|status
argument_list|,
name|num_rus
operator|*
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_ReconMapListElem_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|p
operator|->
name|status
operator|!=
operator|(
name|RF_ReconMapListElem_t
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|status
argument_list|,
name|num_rus
operator|*
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|RF_ReconMap_t
argument_list|)
operator|+
name|num_rus
operator|*
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
operator|*
argument_list|)
expr_stmt|;
name|p
operator|->
name|maxSize
operator|=
name|p
operator|->
name|size
expr_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|p
operator|->
name|mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|p
operator|->
name|status
argument_list|,
name|num_rus
operator|*
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconMap_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * marks a new set of sectors as reconstructed.  All the possible mergings get  * complicated.  To simplify matters, the approach I take is to just dump  * something into the list, and then clean it up (i.e. merge elements and  * eliminate redundant ones) in a second pass over the list (compact_stat_entry()).  * Not 100% efficient, since a structure can be allocated and then immediately  * freed, but it keeps this code from becoming (more of) a nightmare of  * special cases.  The only thing that compact_stat_entry() assumes is that the  * list is sorted by startSector, and so this is the only condition I maintain  * here.  (MCH)  *  *-----------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|rf_ReconMapUpdate
parameter_list|(
name|raidPtr
parameter_list|,
name|mapPtr
parameter_list|,
name|startSector
parameter_list|,
name|stopSector
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|RF_SectorNum_t
name|startSector
decl_stmt|;
name|RF_SectorNum_t
name|stopSector
decl_stmt|;
block|{
name|RF_SectorCount_t
name|sectorsPerReconUnit
init|=
name|mapPtr
operator|->
name|sectorsPerReconUnit
decl_stmt|;
name|RF_SectorNum_t
name|i
decl_stmt|,
name|first_in_RU
decl_stmt|,
name|last_in_RU
decl_stmt|;
name|RF_ReconMapListElem_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|mapPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|startSector
operator|>=
literal|0
operator|&&
name|stopSector
operator|<
name|mapPtr
operator|->
name|sectorsInDisk
operator|&&
name|stopSector
operator|>=
name|startSector
argument_list|)
expr_stmt|;
while|while
condition|(
name|startSector
operator|<=
name|stopSector
condition|)
block|{
name|i
operator|=
name|startSector
operator|/
name|mapPtr
operator|->
name|sectorsPerReconUnit
expr_stmt|;
name|first_in_RU
operator|=
name|i
operator|*
name|sectorsPerReconUnit
expr_stmt|;
name|last_in_RU
operator|=
name|first_in_RU
operator|+
name|sectorsPerReconUnit
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|RU_ALL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|RU_NOTHING
operator|||
name|p
operator|->
name|startSector
operator|>
name|startSector
condition|)
block|{
comment|/* insert at front of 										 * list */
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
operator|=
name|MakeReconMapListElem
argument_list|(
name|startSector
argument_list|,
name|RF_MIN
argument_list|(
name|stopSector
argument_list|,
name|last_in_RU
argument_list|)
argument_list|,
operator|(
name|p
operator|==
name|RU_NOTHING
operator|)
condition|?
name|NULL
else|:
name|p
argument_list|)
expr_stmt|;
name|update_size
argument_list|(
name|mapPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* general case */
do|do
block|{
comment|/* search for place to insert */
name|pt
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|&&
operator|(
name|p
operator|->
name|startSector
operator|<
name|startSector
operator|)
condition|)
do|;
name|pt
operator|->
name|next
operator|=
name|MakeReconMapListElem
argument_list|(
name|startSector
argument_list|,
name|RF_MIN
argument_list|(
name|stopSector
argument_list|,
name|last_in_RU
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|update_size
argument_list|(
name|mapPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|compact_stat_entry
argument_list|(
name|raidPtr
argument_list|,
name|mapPtr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|startSector
operator|=
name|RF_MIN
argument_list|(
name|stopSector
argument_list|,
name|last_in_RU
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|mapPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * performs whatever list compactions can be done, and frees any space  * that is no longer necessary.  Assumes only that the list is sorted  * by startSector.  crunch_list() compacts a single list as much as possible,  * and the second block of code deletes the entire list if possible.  * crunch_list() is also called from MakeReconMapAccessList().  *  * When a recon unit is detected to be fully reconstructed, we set the  * corresponding bit in the parity stripe map so that the head follow  * code will not select this parity stripe again.  This is redundant (but  * harmless) when compact_stat_entry is called from the reconstruction code,  * but necessary when called from the user-write code.  *  *-----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compact_stat_entry
parameter_list|(
name|raidPtr
parameter_list|,
name|mapPtr
parameter_list|,
name|i
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|RF_SectorCount_t
name|sectorsPerReconUnit
init|=
name|mapPtr
operator|->
name|sectorsPerReconUnit
decl_stmt|;
name|RF_ReconMapListElem_t
modifier|*
name|p
init|=
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
decl_stmt|;
name|crunch_list
argument_list|(
name|mapPtr
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|startSector
operator|==
name|i
operator|*
name|sectorsPerReconUnit
operator|)
operator|&&
operator|(
name|p
operator|->
name|stopSector
operator|==
name|i
operator|*
name|sectorsPerReconUnit
operator|+
name|sectorsPerReconUnit
operator|-
literal|1
operator|)
condition|)
block|{
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
operator|=
name|RU_ALL
expr_stmt|;
name|mapPtr
operator|->
name|unitsLeft
operator|--
expr_stmt|;
name|FreeReconMapListElem
argument_list|(
name|mapPtr
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|crunch_list
parameter_list|(
name|mapPtr
parameter_list|,
name|listPtr
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|RF_ReconMapListElem_t
modifier|*
name|listPtr
decl_stmt|;
block|{
name|RF_ReconMapListElem_t
modifier|*
name|pt
decl_stmt|,
modifier|*
name|p
init|=
name|listPtr
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|pt
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|stopSector
operator|>=
name|p
operator|->
name|startSector
operator|-
literal|1
condition|)
block|{
name|pt
operator|->
name|stopSector
operator|=
name|RF_MAX
argument_list|(
name|pt
operator|->
name|stopSector
argument_list|,
name|p
operator|->
name|stopSector
argument_list|)
expr_stmt|;
name|pt
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|FreeReconMapListElem
argument_list|(
name|mapPtr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|pt
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * Allocate and fill a new list element  *  *-----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|RF_ReconMapListElem_t
modifier|*
name|MakeReconMapListElem
parameter_list|(
name|RF_SectorNum_t
name|startSector
parameter_list|,
name|RF_SectorNum_t
name|stopSector
parameter_list|,
name|RF_ReconMapListElem_t
modifier|*
name|next
parameter_list|)
block|{
name|RF_ReconMapListElem_t
modifier|*
name|p
decl_stmt|;
name|RF_Malloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
argument_list|)
argument_list|,
operator|(
name|RF_ReconMapListElem_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|startSector
operator|=
name|startSector
expr_stmt|;
name|p
operator|->
name|stopSector
operator|=
name|stopSector
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|next
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * Free a list element  *  *-----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|FreeReconMapListElem
parameter_list|(
name|mapPtr
parameter_list|,
name|p
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|RF_ReconMapListElem_t
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|mapPtr
condition|)
block|{
name|delta
operator|=
literal|0
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
argument_list|)
expr_stmt|;
name|update_size
argument_list|(
name|mapPtr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * Free an entire status structure.  Inefficient, but can be called at any time.  *  *-----------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|rf_FreeReconMap
parameter_list|(
name|mapPtr
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
block|{
name|RF_ReconMapListElem_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|RF_ReconUnitCount_t
name|numRUs
decl_stmt|;
name|RF_ReconUnitNum_t
name|i
decl_stmt|;
name|numRUs
operator|=
name|mapPtr
operator|->
name|sectorsInDisk
operator|/
name|mapPtr
operator|->
name|sectorsPerReconUnit
expr_stmt|;
if|if
condition|(
name|mapPtr
operator|->
name|sectorsInDisk
operator|%
name|mapPtr
operator|->
name|sectorsPerReconUnit
condition|)
name|numRUs
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRUs
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|RU_NOTHING
operator|&&
name|p
operator|!=
name|RU_ALL
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|RF_Free
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rf_mutex_destroy
argument_list|(
operator|&
name|mapPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|mapPtr
operator|->
name|status
argument_list|,
name|mapPtr
operator|->
name|totalRUs
operator|*
sizeof|sizeof
argument_list|(
name|RF_ReconMapListElem_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|mapPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconMap_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------  *  * returns nonzero if the indicated RU has been reconstructed already  *  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|rf_CheckRUReconstructed
parameter_list|(
name|mapPtr
parameter_list|,
name|startSector
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|RF_SectorNum_t
name|startSector
decl_stmt|;
block|{
name|RF_ReconMapListElem_t
modifier|*
name|l
decl_stmt|;
comment|/* used for searching */
name|RF_ReconUnitNum_t
name|i
decl_stmt|;
name|i
operator|=
name|startSector
operator|/
name|mapPtr
operator|->
name|sectorsPerReconUnit
expr_stmt|;
name|l
operator|=
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|l
operator|==
name|RU_ALL
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_ReconUnitCount_t
name|rf_UnitsLeftToReconstruct
parameter_list|(
name|mapPtr
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
block|{
name|RF_ASSERT
argument_list|(
name|mapPtr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapPtr
operator|->
name|unitsLeft
operator|)
return|;
block|}
end_function

begin_comment
comment|/* updates the size fields of a status descriptor */
end_comment

begin_function
specifier|static
name|void
name|update_size
parameter_list|(
name|mapPtr
parameter_list|,
name|size
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|mapPtr
operator|->
name|size
operator|+=
name|size
expr_stmt|;
name|mapPtr
operator|->
name|maxSize
operator|=
name|RF_MAX
argument_list|(
name|mapPtr
operator|->
name|size
argument_list|,
name|mapPtr
operator|->
name|maxSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PrintList
parameter_list|(
name|listPtr
parameter_list|)
name|RF_ReconMapListElem_t
modifier|*
name|listPtr
decl_stmt|;
block|{
while|while
condition|(
name|listPtr
condition|)
block|{
name|printf
argument_list|(
literal|"%d,%d -> "
argument_list|,
operator|(
name|int
operator|)
name|listPtr
operator|->
name|startSector
argument_list|,
operator|(
name|int
operator|)
name|listPtr
operator|->
name|stopSector
argument_list|)
expr_stmt|;
name|listPtr
operator|=
name|listPtr
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_PrintReconMap
parameter_list|(
name|raidPtr
parameter_list|,
name|mapPtr
parameter_list|,
name|frow
parameter_list|,
name|fcol
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|RF_RowCol_t
name|frow
decl_stmt|;
name|RF_RowCol_t
name|fcol
decl_stmt|;
block|{
name|RF_ReconUnitCount_t
name|numRUs
decl_stmt|;
name|RF_ReconMapListElem_t
modifier|*
name|p
decl_stmt|;
name|RF_ReconUnitNum_t
name|i
decl_stmt|;
name|numRUs
operator|=
name|mapPtr
operator|->
name|totalRUs
expr_stmt|;
if|if
condition|(
name|mapPtr
operator|->
name|sectorsInDisk
operator|%
name|mapPtr
operator|->
name|sectorsPerReconUnit
condition|)
name|numRUs
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRUs
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|mapPtr
operator|->
name|status
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|RU_ALL
condition|)
comment|/* printf("[%d] ALL\n",i) */
empty_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|RU_NOTHING
condition|)
block|{
name|printf
argument_list|(
literal|"%d: Unreconstructed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|PrintList
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|rf_PrintReconSchedule
parameter_list|(
name|mapPtr
parameter_list|,
name|starttime
parameter_list|)
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|struct
name|timeval
modifier|*
name|starttime
decl_stmt|;
block|{
specifier|static
name|int
name|old_pctg
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
name|diff
decl_stmt|;
name|int
name|new_pctg
decl_stmt|;
name|new_pctg
operator|=
literal|100
operator|-
operator|(
name|rf_UnitsLeftToReconstruct
argument_list|(
name|mapPtr
argument_list|)
operator|*
literal|100
operator|/
name|mapPtr
operator|->
name|totalRUs
operator|)
expr_stmt|;
if|if
condition|(
name|new_pctg
operator|!=
name|old_pctg
condition|)
block|{
name|RF_GETTIME
argument_list|(
name|tv
argument_list|)
expr_stmt|;
name|RF_TIMEVAL_DIFF
argument_list|(
name|starttime
argument_list|,
operator|&
name|tv
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d.%06d\n"
argument_list|,
operator|(
name|int
operator|)
name|new_pctg
argument_list|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|old_pctg
operator|=
name|new_pctg
expr_stmt|;
block|}
block|}
end_function

end_unit

