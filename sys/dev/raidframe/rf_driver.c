begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_driver.c,v 1.39 2000/12/15 02:12:58 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Greg Oster  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, Khalil Amiri, Claudson Bornstein, William V. Courtright II,  *         Robby Findler, Daniel Stodolsky, Rachad Youssef, Jim Zelenka  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/******************************************************************************  *  * rf_driver.c -- main setup, teardown, and access routines for the RAID driver  *  * all routines are prefixed with rf_ (raidframe), to avoid conficts.  *  ******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_aselect.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_states.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_freelist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_revent.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_nwayxor.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugprint.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_copyback.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_options.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_comment
comment|/* rad == RF_RaidAccessDesc_t */
end_comment

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_rad_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_RAD
value|128
end_define

begin_define
define|#
directive|define
name|RF_RAD_INC
value|16
end_define

begin_define
define|#
directive|define
name|RF_RAD_INITIAL
value|32
end_define

begin_comment
comment|/* debug variables */
end_comment

begin_decl_stmt
name|char
name|rf_panicbuf
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a buffer to hold an error msg when we panic */
end_comment

begin_comment
comment|/* main configuration routines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|raidframe_booted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rf_ConfigureDebug
parameter_list|(
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_debug_option
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|long
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_UnconfigureArray
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_rad
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clean_rad
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_ShutdownRDFreeList
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_ConfigureRDFreeList
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|RF_DECLARE_MUTEX
argument_list|(
argument|rf_printf_mutex
argument_list|)
end_macro

begin_comment
comment|/* debug only:  avoids interleaved 					 * printfs by different stripes */
end_comment

begin_define
define|#
directive|define
name|SIGNAL_QUIESCENT_COND
parameter_list|(
name|_raid_
parameter_list|)
value|wakeup(&((_raid_)->accesses_suspended))
end_define

begin_define
define|#
directive|define
name|WAIT_FOR_QUIESCENCE
parameter_list|(
name|_raid_
parameter_list|)
define|\
value|RF_LTSLEEP(&((_raid_)->accesses_suspended), PRIBIO, \ 		"raidframe quiesce", 0,&((_raid_)->access_suspend_mutex))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>
literal|500005
end_if

begin_define
define|#
directive|define
name|IO_BUF_ERR
parameter_list|(
name|bp
parameter_list|,
name|err
parameter_list|)
value|{ \ 	bp->bio_flags |= BIO_ERROR; \ 	bp->bio_resid = bp->bio_bcount; \ 	bp->bio_error = err; \ 	biodone(bp); \ };
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IO_BUF_ERR
parameter_list|(
name|bp
parameter_list|,
name|err
parameter_list|)
value|{ \ 	bp->b_flags |= B_ERROR; \ 	bp->b_resid = bp->b_bcount; \ 	bp->b_error = err; \ 	biodone(bp); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|configureCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of active configurations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|configInProgress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* configuration is in progress and code 				  * needs to be serialized. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|isconfigged
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is basic raidframe (non per-array) 				 * stuff configged */
end_comment

begin_macro
name|RF_DECLARE_STATIC_MUTEX
argument_list|(
argument|configureMutex
argument_list|)
end_macro

begin_comment
comment|/* used to lock the configuration 					 * stuff */
end_comment

begin_decl_stmt
specifier|static
name|RF_ShutdownList_t
modifier|*
name|globalShutdown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non array-specific 						 * stuff */
end_comment

begin_comment
comment|/* called at system boot time */
end_comment

begin_function
name|int
name|rf_BootRaidframe
parameter_list|()
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|raidframe_booted
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|raidframe_booted
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|configureMutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|configureCount
operator|=
literal|0
expr_stmt|;
name|isconfigged
operator|=
literal|0
expr_stmt|;
name|globalShutdown
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is really just for debugging user-level stuff: it  * frees up all memory, other RAIDframe resources which might otherwise  * be kept around. This is used with systems like "sentinel" to detect  * memory leaks.  */
end_comment

begin_function
name|int
name|rf_UnbootRaidframe
parameter_list|()
block|{
name|int
name|rc
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|configureCount
condition|)
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|raidframe_booted
operator|=
literal|0
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|rf_mutex_destroy
argument_list|(
operator|&
name|configureMutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to destroy mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called whenever an array is shutdown  */
end_comment

begin_function
specifier|static
name|void
name|rf_UnconfigureArray
parameter_list|()
block|{
name|int
name|rc
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|configureCount
operator|==
literal|0
condition|)
block|{
comment|/* if no active configurations, shut 					 * everything down */
name|isconfigged
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|rf_ShutdownList
argument_list|(
operator|&
name|globalShutdown
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"RAIDFRAME: unable to do global shutdown, rc=%d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* 	         * We must wait until now, because the AllocList module 	         * uses the DebugMem module. 	         */
if|if
condition|(
name|rf_memDebug
condition|)
name|rf_print_unfreed
argument_list|()
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to shut down an array.  */
end_comment

begin_function
name|int
name|rf_Shutdown
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|valid
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Attempt to shut down unconfigured RAIDframe driver.  Aborting shutdown\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*          * wait for outstanding IOs to land          * As described in rf_raid.h, we use the rad_freelist lock          * to protect the per-array info about outstanding descs          * since we need to do freelist locking anyway, and this          * cuts down on the amount of serialization we've got going          * on.          */
name|RF_FREELIST_DO_LOCK
argument_list|(
name|rf_rad_freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|waitShutdown
condition|)
block|{
name|RF_FREELIST_DO_UNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|raidPtr
operator|->
name|waitShutdown
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|raidPtr
operator|->
name|nAccOutstanding
condition|)
block|{
name|RF_WAIT_COND
argument_list|(
name|raidPtr
operator|->
name|outstandingCond
argument_list|,
name|RF_FREELIST_MUTEX_OF
argument_list|(
name|rf_rad_freelist
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RF_FREELIST_DO_UNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|)
expr_stmt|;
comment|/* Wait for any parity re-writes to stop... */
while|while
condition|(
name|raidPtr
operator|->
name|parity_rewrite_in_progress
condition|)
block|{
name|printf
argument_list|(
literal|"Waiting for parity re-write to exit...\n"
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|raidPtr
operator|->
name|parity_rewrite_in_progress
argument_list|,
name|PRIBIO
argument_list|,
literal|"rfprwshutdown"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|raidPtr
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|rf_update_component_labels
argument_list|(
name|raidPtr
argument_list|,
name|RF_FINAL_COMPONENT_UPDATE
argument_list|)
expr_stmt|;
name|rf_UnconfigureVnodes
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|rf_ShutdownList
argument_list|(
operator|&
name|raidPtr
operator|->
name|shutdownList
argument_list|)
expr_stmt|;
name|rf_UnconfigureArray
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DO_INIT_CONFIGURE
parameter_list|(
name|f
parameter_list|)
value|{ \ 	rc = f (&globalShutdown); \ 	if (rc) { \ 		RF_ERRORMSG2("RAIDFRAME: failed %s with %d\n", RF_STRING(f), rc); \ 		rf_ShutdownList(&globalShutdown); \ 		RF_LOCK_MUTEX(configureMutex); \ 		configInProgress = 0; \ 		configureCount--; \ 		RF_UNLOCK_MUTEX(configureMutex); \ 		return(rc); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DO_RAID_FAIL
parameter_list|()
value|{ \ 	rf_UnconfigureVnodes(raidPtr); \ 	rf_ShutdownList(&raidPtr->shutdownList); \ 	rf_UnconfigureArray(); \ }
end_define

begin_define
define|#
directive|define
name|DO_RAID_INIT_CONFIGURE
parameter_list|(
name|f
parameter_list|)
value|{ \ 	rc = f (&raidPtr->shutdownList, raidPtr, cfgPtr); \ 	if (rc) { \ 		RF_ERRORMSG2("RAIDFRAME: failed %s with %d\n", RF_STRING(f), rc); \ 		DO_RAID_FAIL(); \ 		return(rc); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DO_RAID_MUTEX
parameter_list|(
name|_m_
parameter_list|)
value|{ \ 	rc = rf_create_managed_mutex(&raidPtr->shutdownList, (_m_)); \ 	if (rc) { \ 		RF_ERRORMSG3("Unable to init mutex file %s line %d rc=%d\n", \ 			__FILE__, __LINE__, rc); \ 		DO_RAID_FAIL(); \ 		return(rc); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DO_RAID_COND
parameter_list|(
name|_c_
parameter_list|)
value|{ \ 	rc = rf_create_managed_cond(&raidPtr->shutdownList, (_c_)); \ 	if (rc) { \ 		RF_ERRORMSG3("Unable to init cond file %s line %d rc=%d\n", \ 			__FILE__, __LINE__, rc); \ 		DO_RAID_FAIL(); \ 		return(rc); \ 	} \ }
end_define

begin_function
name|int
name|rf_Configure
parameter_list|(
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|,
name|ac
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
block|{
name|RF_RowCol_t
name|row
decl_stmt|,
name|col
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
comment|/* XXX This check can probably be removed now, since  	   RAIDFRAME_CONFIGURE now checks to make sure that the 	   RAID set is not already valid 	*/
if|if
condition|(
name|raidPtr
operator|->
name|valid
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"RAIDframe configuration not shut down.  Aborting configure.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|configInProgress
operator|==
literal|1
condition|)
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|configureCount
operator|++
expr_stmt|;
if|if
condition|(
name|isconfigged
operator|==
literal|0
condition|)
block|{
name|configInProgress
operator|=
literal|1
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|rf_create_managed_mutex
argument_list|(
operator|&
name|globalShutdown
argument_list|,
operator|&
name|rf_printf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownList
argument_list|(
operator|&
name|globalShutdown
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* initialize globals */
name|printf
argument_list|(
literal|"RAIDFRAME: protectedSectors is %ld\n"
argument_list|,
name|rf_protectedSectors
argument_list|)
expr_stmt|;
name|rf_clear_debug_print_buffer
argument_list|()
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureAllocList
argument_list|)
expr_stmt|;
comment|/* 	         * Yes, this does make debugging general to the whole 	         * system instead of being array specific. Bummer, drag.   		 */
name|rf_ConfigureDebug
argument_list|(
name|cfgPtr
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDebugMem
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureAccessTrace
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureMapModule
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureReconEvent
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureCallback
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureMemChunk
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureRDFreeList
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureNWayXor
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureStripeLockFreeList
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureMCPair
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDAGs
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDAGFuncs
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDebugPrint
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureReconstruction
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureCopyback
argument_list|)
expr_stmt|;
name|DO_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDiskQueueSystem
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
name|isconfigged
operator|=
literal|1
expr_stmt|;
name|configInProgress
operator|=
literal|0
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|configureMutex
argument_list|)
expr_stmt|;
name|DO_RAID_MUTEX
argument_list|(
operator|&
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* set up the cleanup list.  Do this after ConfigureDebug so that 	 * value of memDebug will be set */
name|rf_MakeAllocList
argument_list|(
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|cleanupList
operator|==
name|NULL
condition|)
block|{
name|DO_RAID_FAIL
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
operator|&
name|raidPtr
operator|->
name|shutdownList
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_FreeAllocList
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|DO_RAID_FAIL
argument_list|()
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|raidPtr
operator|->
name|numRow
operator|=
name|cfgPtr
operator|->
name|numRow
expr_stmt|;
name|raidPtr
operator|->
name|numCol
operator|=
name|cfgPtr
operator|->
name|numCol
expr_stmt|;
name|raidPtr
operator|->
name|numSpare
operator|=
name|cfgPtr
operator|->
name|numSpare
expr_stmt|;
comment|/* XXX we don't even pretend to support more than one row in the 	 * kernel... */
if|if
condition|(
name|raidPtr
operator|->
name|numRow
operator|!=
literal|1
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Only one row supported in kernel.\n"
argument_list|)
expr_stmt|;
name|DO_RAID_FAIL
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|RF_CallocAndAdd
argument_list|(
name|raidPtr
operator|->
name|status
argument_list|,
name|raidPtr
operator|->
name|numRow
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_RowStatus_t
argument_list|)
argument_list|,
operator|(
name|RF_RowStatus_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|status
operator|==
name|NULL
condition|)
block|{
name|DO_RAID_FAIL
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|RF_CallocAndAdd
argument_list|(
name|raidPtr
operator|->
name|reconControl
argument_list|,
name|raidPtr
operator|->
name|numRow
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconCtrl_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_ReconCtrl_t
operator|*
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|reconControl
operator|==
name|NULL
condition|)
block|{
name|DO_RAID_FAIL
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|i
operator|++
control|)
block|{
name|raidPtr
operator|->
name|status
index|[
name|i
index|]
operator|=
name|rf_rs_optimal
expr_stmt|;
name|raidPtr
operator|->
name|reconControl
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureEngine
argument_list|)
expr_stmt|;
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureStripeLocks
argument_list|)
expr_stmt|;
name|DO_RAID_COND
argument_list|(
operator|&
name|raidPtr
operator|->
name|outstandingCond
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|nAccOutstanding
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|waitShutdown
operator|=
literal|0
expr_stmt|;
name|DO_RAID_MUTEX
argument_list|(
operator|&
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|DO_RAID_COND
argument_list|(
operator|&
name|raidPtr
operator|->
name|quiescent_cond
argument_list|)
expr_stmt|;
name|DO_RAID_COND
argument_list|(
operator|&
name|raidPtr
operator|->
name|waitForReconCond
argument_list|)
expr_stmt|;
name|DO_RAID_MUTEX
argument_list|(
operator|&
name|raidPtr
operator|->
name|recon_done_proc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
comment|/* We have an AutoConfig structure..  Don't do the 		   normal disk configuration... call the auto config 		   stuff */
name|rf_AutoConfigureDisks
argument_list|(
name|raidPtr
argument_list|,
name|cfgPtr
argument_list|,
name|ac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDisks
argument_list|)
expr_stmt|;
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureSpareDisks
argument_list|)
expr_stmt|;
block|}
comment|/* do this after ConfigureDisks& ConfigureSpareDisks to be sure dev 	 * no. is set */
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureDiskQueues
argument_list|)
expr_stmt|;
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigureLayout
argument_list|)
expr_stmt|;
name|DO_RAID_INIT_CONFIGURE
argument_list|(
name|rf_ConfigurePSStatus
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|col
operator|++
control|)
block|{
comment|/* 		         * XXX better distribution 		         */
name|raidPtr
operator|->
name|hist_diskreq
index|[
name|row
index|]
index|[
name|col
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|raidPtr
operator|->
name|numNewFailures
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|copyback_in_progress
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|parity_rewrite_in_progress
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|recon_in_progress
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|maxOutstanding
operator|=
name|cfgPtr
operator|->
name|maxOutstandingDiskReqs
expr_stmt|;
comment|/* autoconfigure and root_partition will actually get filled in  	   after the config is done */
name|raidPtr
operator|->
name|autoconfigure
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|root_partition
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|last_unit
operator|=
name|raidPtr
operator|->
name|raidid
expr_stmt|;
name|raidPtr
operator|->
name|config_order
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rf_keepAccTotals
condition|)
block|{
name|raidPtr
operator|->
name|keep_acc_totals
operator|=
literal|1
expr_stmt|;
block|}
name|rf_StartUserStats
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_rad
parameter_list|(
name|desc
parameter_list|)
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|desc
operator|->
name|mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|rf_cond_init
argument_list|(
operator|&
name|desc
operator|->
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init cond file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_mutex_destroy
argument_list|(
operator|&
name|desc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clean_rad
parameter_list|(
name|desc
parameter_list|)
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
block|{
name|rf_mutex_destroy
argument_list|(
operator|&
name|desc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|rf_cond_destroy
argument_list|(
operator|&
name|desc
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_ShutdownRDFreeList
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_FREELIST_DESTROY_CLEAN
argument_list|(
name|rf_rad_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_RaidAccessDesc_t
operator|*
operator|)
argument_list|,
name|clean_rad
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rf_ConfigureRDFreeList
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_rad_freelist
argument_list|,
name|RF_MAX_FREE_RAD
argument_list|,
name|RF_RAD_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_RaidAccessDesc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_rad_freelist
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownRDFreeList
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownRDFreeList
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|RF_FREELIST_PRIME_INIT
argument_list|(
name|rf_rad_freelist
argument_list|,
name|RF_RAD_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_RaidAccessDesc_t
operator|*
operator|)
argument_list|,
name|init_rad
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_RaidAccessDesc_t
modifier|*
name|rf_AllocRaidAccDesc
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|,
name|RF_RaidAddr_t
name|raidAddress
parameter_list|,
name|RF_SectorCount_t
name|numBlocks
parameter_list|,
name|caddr_t
name|bufPtr
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_DagHeader_t
modifier|*
modifier|*
name|paramDAG
parameter_list|,
name|RF_AccessStripeMapHeader_t
modifier|*
modifier|*
name|paramASM
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbF
function_decl|)
parameter_list|(
name|RF_Buf_t
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbA
parameter_list|,
name|RF_AccessState_t
modifier|*
name|states
parameter_list|)
block|{
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
name|RF_FREELIST_GET_INIT_NOUNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|,
name|desc
argument_list|,
name|next
argument_list|,
operator|(
name|RF_RaidAccessDesc_t
operator|*
operator|)
argument_list|,
name|init_rad
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|waitShutdown
condition|)
block|{
comment|/* 	         * Actually, we're shutting the array down. Free the desc 	         * and return NULL. 	         */
name|RF_FREELIST_DO_UNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|)
expr_stmt|;
name|RF_FREELIST_FREE_CLEAN
argument_list|(
name|rf_rad_freelist
argument_list|,
name|desc
argument_list|,
name|next
argument_list|,
name|clean_rad
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|raidPtr
operator|->
name|nAccOutstanding
operator|++
expr_stmt|;
name|RF_FREELIST_DO_UNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|)
expr_stmt|;
name|desc
operator|->
name|raidPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|raidPtr
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|desc
operator|->
name|raidAddress
operator|=
name|raidAddress
expr_stmt|;
name|desc
operator|->
name|numBlocks
operator|=
name|numBlocks
expr_stmt|;
name|desc
operator|->
name|bufPtr
operator|=
name|bufPtr
expr_stmt|;
name|desc
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|desc
operator|->
name|paramDAG
operator|=
name|paramDAG
expr_stmt|;
name|desc
operator|->
name|paramASM
operator|=
name|paramASM
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|desc
operator|->
name|states
operator|=
name|states
expr_stmt|;
name|desc
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|desc
operator|->
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|callbackFunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|RF_CBParam_t
argument_list|)
operator|)
name|cbF
expr_stmt|;
comment|/* XXX */
name|desc
operator|->
name|callbackArg
operator|=
name|cbA
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|head
operator|=
name|desc
expr_stmt|;
name|desc
operator|->
name|numPending
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|cleanupList
operator|=
name|NULL
expr_stmt|;
name|rf_MakeAllocList
argument_list|(
name|desc
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeRaidAccDesc
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|desc
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
name|RF_FREELIST_FREE_CLEAN_NOUNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|,
name|desc
argument_list|,
name|next
argument_list|,
name|clean_rad
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|nAccOutstanding
operator|--
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|waitShutdown
condition|)
block|{
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|outstandingCond
argument_list|)
expr_stmt|;
block|}
name|RF_FREELIST_DO_UNLOCK
argument_list|(
name|rf_rad_freelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  * Main routine for performing an access.  * Accesses are retried until a DAG can not be selected.  This occurs  * when either the DAG library is incomplete or there are too many  * failures in a parity group.  ********************************************************************/
end_comment

begin_function
name|int
name|rf_DoAccess
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|,
name|int
name|async_flag
parameter_list|,
name|RF_RaidAddr_t
name|raidAddress
parameter_list|,
name|RF_SectorCount_t
name|numBlocks
parameter_list|,
name|caddr_t
name|bufPtr
parameter_list|,
name|void
modifier|*
name|bp_in
parameter_list|,
name|RF_DagHeader_t
modifier|*
modifier|*
name|paramDAG
parameter_list|,
name|RF_AccessStripeMapHeader_t
modifier|*
modifier|*
name|paramASM
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_RaidAccessDesc_t
modifier|*
modifier|*
name|paramDesc
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbF
function_decl|)
parameter_list|(
name|RF_Buf_t
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbA
parameter_list|)
comment|/* type should be read or write async_flag should be RF_TRUE or RF_FALSE bp_in is a buf pointer.  void * to facilitate ignoring it outside the kernel */
block|{
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
name|caddr_t
name|lbufPtr
init|=
name|bufPtr
decl_stmt|;
name|RF_Buf_t
name|bp
init|=
operator|(
name|RF_Buf_t
operator|)
name|bp_in
decl_stmt|;
name|raidAddress
operator|+=
name|rf_raidSectorOffset
expr_stmt|;
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|valid
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"RAIDframe driver not successfully configured.  Rejecting access.\n"
argument_list|)
expr_stmt|;
name|IO_BUF_ERR
argument_list|(
name|bp
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rf_accessDebug
condition|)
block|{
name|printf
argument_list|(
literal|"logBytes is: %d %d %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|raidPtr
operator|->
name|logBytesPerSector
argument_list|,
operator|(
name|int
operator|)
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|numBlocks
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"raid%d: %s raidAddr %d (stripeid %d-%d) numBlocks %d (%d bytes) buf 0x%lx\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|type
operator|==
name|RF_IO_TYPE_READ
operator|)
condition|?
literal|"READ"
else|:
literal|"WRITE"
argument_list|,
operator|(
name|int
operator|)
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|rf_RaidAddressToStripeID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|raidAddress
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|rf_RaidAddressToStripeID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|raidAddress
operator|+
name|numBlocks
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|numBlocks
argument_list|,
operator|(
name|int
operator|)
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|numBlocks
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|bufPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raidAddress
operator|+
name|numBlocks
operator|>
name|raidPtr
operator|->
name|totalSectors
condition|)
block|{
name|printf
argument_list|(
literal|"DoAccess: raid addr %lu too large to access %lu sectors.  Max legal addr is %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|raidAddress
argument_list|,
operator|(
name|u_long
operator|)
name|numBlocks
argument_list|,
operator|(
name|u_long
operator|)
name|raidPtr
operator|->
name|totalSectors
argument_list|)
expr_stmt|;
name|IO_BUF_ERR
argument_list|(
name|bp
argument_list|,
name|ENOSPC
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|desc
operator|=
name|rf_AllocRaidAccDesc
argument_list|(
name|raidPtr
argument_list|,
name|type
argument_list|,
name|raidAddress
argument_list|,
name|numBlocks
argument_list|,
name|lbufPtr
argument_list|,
name|bp
argument_list|,
name|paramDAG
argument_list|,
name|paramASM
argument_list|,
name|flags
argument_list|,
name|cbF
argument_list|,
name|cbA
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|states
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|RF_ETIMER_START
argument_list|(
name|desc
operator|->
name|tracerec
operator|.
name|tot_timer
argument_list|)
expr_stmt|;
name|desc
operator|->
name|async_flag
operator|=
name|async_flag
expr_stmt|;
name|rf_ContinueRaidAccess
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* force the array into reconfigured mode without doing reconstruction */
end_comment

begin_function
name|int
name|rf_SetReconfiguredMode
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|col
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Can't set reconfigured mode in dedicated-spare array\n"
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|numFailures
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|=
name|rf_ds_dist_spared
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|=
name|rf_rs_reconfigured
expr_stmt|;
name|rf_update_component_labels
argument_list|(
name|raidPtr
argument_list|,
name|RF_NORMAL_COMPONENT_UPDATE
argument_list|)
expr_stmt|;
comment|/* install spare table only if declustering + distributed sparing 	 * architecture. */
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_BD_DECLUSTERED
condition|)
name|rf_InstallSpareTable
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|fail_row
decl_stmt|,
name|fail_col
decl_stmt|,
name|fail_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|delayed_recon
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rf_FailDisk
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|int
name|frow
parameter_list|,
name|int
name|fcol
parameter_list|,
name|int
name|initRecon
parameter_list|)
block|{
name|printf
argument_list|(
literal|"raid%d: Failing disk r%d c%d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|numFailures
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|frow
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
name|rf_update_component_labels
argument_list|(
name|raidPtr
argument_list|,
name|RF_NORMAL_COMPONENT_UPDATE
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|initRecon
condition|)
name|rf_ReconstructFailedDisk
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* releases a thread that is waiting for the array to become quiesced.  * access_suspend_mutex should be locked upon calling this  */
end_comment

begin_function
name|void
name|rf_SignalQuiescenceLock
parameter_list|(
name|raidPtr
parameter_list|,
name|reconDesc
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
block|{
if|if
condition|(
name|rf_quiesceDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Signalling quiescence lock\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|raidPtr
operator|->
name|access_suspend_release
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|waiting_for_quiescence
condition|)
block|{
name|SIGNAL_QUIESCENT_COND
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* suspends all new requests to the array.  No effect on accesses that are in flight.  */
end_comment

begin_function
name|int
name|rf_SuspendNewRequestsAndWait
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
if|if
condition|(
name|rf_quiesceDebug
condition|)
name|printf
argument_list|(
literal|"Suspending new reqs\n"
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|accesses_suspended
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|waiting_for_quiescence
operator|=
operator|(
name|raidPtr
operator|->
name|accs_in_flight
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|waiting_for_quiescence
condition|)
block|{
name|raidPtr
operator|->
name|access_suspend_release
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|raidPtr
operator|->
name|access_suspend_release
condition|)
block|{
name|printf
argument_list|(
literal|"Suspending: Waiting for Quiescence\n"
argument_list|)
expr_stmt|;
name|WAIT_FOR_QUIESCENCE
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|waiting_for_quiescence
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Quiescence reached..\n"
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|raidPtr
operator|->
name|waiting_for_quiescence
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wake up everyone waiting for quiescence to be released */
end_comment

begin_function
name|void
name|rf_ResumeNewRequests
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_CallbackDesc_t
modifier|*
name|t
decl_stmt|,
modifier|*
name|cb
decl_stmt|;
if|if
condition|(
name|rf_quiesceDebug
condition|)
name|printf
argument_list|(
literal|"Resuming new reqs\n"
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|accesses_suspended
operator|--
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|accesses_suspended
operator|==
literal|0
condition|)
name|cb
operator|=
name|raidPtr
operator|->
name|quiesce_wait_list
expr_stmt|;
else|else
name|cb
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|quiesce_wait_list
operator|=
name|NULL
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|cb
condition|)
block|{
name|t
operator|=
name|cb
expr_stmt|;
name|cb
operator|=
name|cb
operator|->
name|next
expr_stmt|;
call|(
name|t
operator|->
name|callbackFunc
call|)
argument_list|(
name|t
operator|->
name|callbackArg
argument_list|)
expr_stmt|;
name|rf_FreeCallbackDesc
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * debug routines  *  ****************************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|set_debug_option
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|RF_DebugName_t
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|rf_debugNames
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
operator|(
name|p
operator|->
name|ptr
operator|)
operator|=
name|val
expr_stmt|;
name|printf
argument_list|(
literal|"[Set debug variable %s to %ld]\n"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|RF_ERRORMSG1
argument_list|(
literal|"Unknown debug string \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* would like to use sscanf here, but apparently not available in kernel */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|rf_ConfigureDebug
parameter_list|(
name|cfgPtr
parameter_list|)
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|char
modifier|*
name|val_p
decl_stmt|,
modifier|*
name|name_p
decl_stmt|,
modifier|*
name|white_p
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rf_ResetDebugOptions
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cfgPtr
operator|->
name|debugVars
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|i
operator|<
name|RF_MAXDBGV
condition|;
name|i
operator|++
control|)
block|{
name|name_p
operator|=
name|rf_find_non_white
argument_list|(
operator|&
name|cfgPtr
operator|->
name|debugVars
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|white_p
operator|=
name|rf_find_white
argument_list|(
name|name_p
argument_list|)
expr_stmt|;
comment|/* skip to start of 2nd 							 * word */
name|val_p
operator|=
name|rf_find_non_white
argument_list|(
name|white_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val_p
operator|==
literal|'0'
operator|&&
operator|*
operator|(
name|val_p
operator|+
literal|1
operator|)
operator|==
literal|'x'
condition|)
name|val
operator|=
name|rf_htoi
argument_list|(
name|val_p
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|rf_atoi
argument_list|(
name|val_p
argument_list|)
expr_stmt|;
operator|*
name|white_p
operator|=
literal|'\0'
expr_stmt|;
name|set_debug_option
argument_list|(
name|name_p
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* performance monitoring stuff */
end_comment

begin_define
define|#
directive|define
name|TIMEVAL_TO_US
parameter_list|(
name|t
parameter_list|)
value|(((long) t.tv_sec) * 1000000L + (long) t.tv_usec)
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SIMULATE
argument_list|)
end_if

begin_comment
comment|/*  * Throughput stats currently only used in user-level RAIDframe  */
end_comment

begin_function
specifier|static
name|int
name|rf_InitThroughputStats
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* these used by user-level raidframe only */
name|rc
operator|=
name|rf_create_managed_mutex
argument_list|(
name|listp
argument_list|,
operator|&
name|raidPtr
operator|->
name|throughputstats
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|raidPtr
operator|->
name|throughputstats
operator|.
name|sum_io_us
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_ios
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_out_ios
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_StartThroughputStats
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_ios
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_out_ios
operator|++
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_out_ios
operator|==
literal|1
condition|)
name|RF_GETTIME
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|start
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_StopThroughputStats
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_out_ios
operator|--
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_out_ios
operator|==
literal|0
condition|)
block|{
name|RF_GETTIME
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|stop
argument_list|)
expr_stmt|;
name|RF_TIMEVAL_DIFF
argument_list|(
operator|&
name|raidPtr
operator|->
name|throughputstats
operator|.
name|start
argument_list|,
operator|&
name|raidPtr
operator|->
name|throughputstats
operator|.
name|stop
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|throughputstats
operator|.
name|sum_io_us
operator|+=
name|TIMEVAL_TO_US
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_PrintThroughputStats
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_out_ios
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|sum_io_us
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[Througphut: %8.2f IOs/second]\n"
argument_list|,
name|raidPtr
operator|->
name|throughputstats
operator|.
name|num_ios
operator|/
operator|(
name|raidPtr
operator|->
name|throughputstats
operator|.
name|sum_io_us
operator|/
literal|1000000.0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !KERNEL&& !SIMULATE */
end_comment

begin_function
name|void
name|rf_StartUserStats
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_GETTIME
argument_list|(
name|raidPtr
operator|->
name|userstats
operator|.
name|start
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|userstats
operator|.
name|sum_io_us
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|userstats
operator|.
name|num_ios
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|userstats
operator|.
name|num_sect_moved
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_StopUserStats
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_GETTIME
argument_list|(
name|raidPtr
operator|->
name|userstats
operator|.
name|stop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_UpdateUserStats
parameter_list|(
name|raidPtr
parameter_list|,
name|rt
parameter_list|,
name|numsect
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|rt
decl_stmt|;
comment|/* resp time in us */
name|int
name|numsect
decl_stmt|;
comment|/* number of sectors for this access */
block|{
name|raidPtr
operator|->
name|userstats
operator|.
name|sum_io_us
operator|+=
name|rt
expr_stmt|;
name|raidPtr
operator|->
name|userstats
operator|.
name|num_ios
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|userstats
operator|.
name|num_sect_moved
operator|+=
name|numsect
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_PrintUserStats
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|long
name|elapsed_us
decl_stmt|,
name|mbs
decl_stmt|,
name|mbs_frac
decl_stmt|;
name|struct
name|timeval
name|diff
decl_stmt|;
name|RF_TIMEVAL_DIFF
argument_list|(
operator|&
name|raidPtr
operator|->
name|userstats
operator|.
name|start
argument_list|,
operator|&
name|raidPtr
operator|->
name|userstats
operator|.
name|stop
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|elapsed_us
operator|=
name|TIMEVAL_TO_US
argument_list|(
name|diff
argument_list|)
expr_stmt|;
comment|/* 2000 sectors per megabyte, 10000000 microseconds per second */
if|if
condition|(
name|elapsed_us
condition|)
name|mbs
operator|=
operator|(
name|raidPtr
operator|->
name|userstats
operator|.
name|num_sect_moved
operator|/
literal|2000
operator|)
operator|/
operator|(
name|elapsed_us
operator|/
literal|1000000
operator|)
expr_stmt|;
else|else
name|mbs
operator|=
literal|0
expr_stmt|;
comment|/* this computes only the first digit of the fractional mb/s moved */
if|if
condition|(
name|elapsed_us
condition|)
block|{
name|mbs_frac
operator|=
operator|(
operator|(
name|raidPtr
operator|->
name|userstats
operator|.
name|num_sect_moved
operator|/
literal|200
operator|)
operator|/
operator|(
name|elapsed_us
operator|/
literal|1000000
operator|)
operator|)
operator|-
operator|(
name|mbs
operator|*
literal|10
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mbs_frac
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Number of I/Os:             %ld\n"
argument_list|,
name|raidPtr
operator|->
name|userstats
operator|.
name|num_ios
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Elapsed time (us):          %ld\n"
argument_list|,
name|elapsed_us
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"User I/Os per second:       %ld\n"
argument_list|,
name|RF_DB0_CHECK
argument_list|(
name|raidPtr
operator|->
name|userstats
operator|.
name|num_ios
argument_list|,
operator|(
name|elapsed_us
operator|/
literal|1000000
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Average user response time: %ld us\n"
argument_list|,
name|RF_DB0_CHECK
argument_list|(
name|raidPtr
operator|->
name|userstats
operator|.
name|sum_io_us
argument_list|,
name|raidPtr
operator|->
name|userstats
operator|.
name|num_ios
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Total sectors moved:        %ld\n"
argument_list|,
name|raidPtr
operator|->
name|userstats
operator|.
name|num_sect_moved
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Average access size (sect): %ld\n"
argument_list|,
name|RF_DB0_CHECK
argument_list|(
name|raidPtr
operator|->
name|userstats
operator|.
name|num_sect_moved
argument_list|,
name|raidPtr
operator|->
name|userstats
operator|.
name|num_ios
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Achieved data rate:         %ld.%ld MB/sec\n"
argument_list|,
name|mbs
argument_list|,
name|mbs_frac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_print_panic_message
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|rf_panicbuf
argument_list|,
literal|"raidframe error at line %d file %s"
argument_list|,
name|line
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_print_assert_panic_message
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|,
name|condition
parameter_list|)
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|condition
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|rf_panicbuf
argument_list|,
literal|"raidframe error at line %d file %s (failed asserting %s)\n"
argument_list|,
name|line
argument_list|,
name|file
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

