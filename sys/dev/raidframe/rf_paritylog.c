begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_paritylog.c,v 1.5 2000/01/07 03:41:01 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/* Code for manipulating in-core parity logs  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
end_if

begin_comment
comment|/*  * Append-only log for recording parity "update" and "overwrite" records  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_layout.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylog.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylogging.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylogDiskMgr.h>
end_include

begin_function
specifier|static
name|RF_CommonLogData_t
modifier|*
name|AllocParityLogCommonData
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_CommonLogData_t
modifier|*
name|common
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Return a struct for holding common parity log information from the 	 * free list (rf_parityLogDiskQueue.freeCommonList).  If the free list 	 * is empty, call RF_Malloc to create a new structure. NON-BLOCKING */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeCommonList
condition|)
block|{
name|common
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeCommonList
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeCommonList
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeCommonList
operator|->
name|next
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|common
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_CommonLogData_t
argument_list|)
argument_list|,
operator|(
name|RF_CommonLogData_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|common
operator|->
name|mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|common
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_CommonLogData_t
argument_list|)
argument_list|)
expr_stmt|;
name|common
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|common
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|common
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeParityLogCommonData
parameter_list|(
name|RF_CommonLogData_t
modifier|*
name|common
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
comment|/* Insert a single struct for holding parity log information (data) 	 * into the free list (rf_parityLogDiskQueue.freeCommonList). 	 * NON-BLOCKING */
name|raidPtr
operator|=
name|common
operator|->
name|raidPtr
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|common
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeCommonList
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeCommonList
operator|=
name|common
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RF_ParityLogData_t
modifier|*
name|AllocParityLogData
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
comment|/* Return a struct for holding parity log information from the free 	 * list (rf_parityLogDiskQueue.freeList).  If the free list is empty, 	 * call RF_Malloc to create a new structure. NON-BLOCKING */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeDataList
condition|)
block|{
name|data
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeDataList
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeDataList
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeDataList
operator|->
name|next
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ParityLogData_t
argument_list|)
argument_list|,
operator|(
name|RF_ParityLogData_t
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeParityLogData
parameter_list|(
name|RF_ParityLogData_t
modifier|*
name|data
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|nextItem
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
comment|/* Insert a linked list of structs for holding parity log information 	 * (data) into the free list (parityLogDiskQueue.freeList). 	 * NON-BLOCKING */
name|raidPtr
operator|=
name|data
operator|->
name|common
operator|->
name|raidPtr
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
condition|)
block|{
name|nextItem
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeDataList
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|freeDataList
operator|=
name|data
expr_stmt|;
name|data
operator|=
name|nextItem
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|EnqueueParityLogData
parameter_list|(
name|RF_ParityLogData_t
modifier|*
name|data
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|head
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
comment|/* Insert an in-core parity log (*data) into the head of a disk queue 	 * (*head, *tail). NON-BLOCKING */
name|raidPtr
operator|=
name|data
operator|->
name|common
operator|->
name|raidPtr
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[enqueueing parity log data, region %d, raidAddress %d, numSector %d]\n"
argument_list|,
name|data
operator|->
name|regionID
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|diskAddress
operator|.
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|diskAddress
operator|.
name|numSector
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|data
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|data
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|head
condition|)
block|{
comment|/* insert into head of queue */
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|data
expr_stmt|;
operator|*
name|head
operator|=
name|data
expr_stmt|;
block|}
else|else
block|{
comment|/* insert into empty list */
name|RF_ASSERT
argument_list|(
operator|*
name|head
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
name|tail
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|head
operator|=
name|data
expr_stmt|;
operator|*
name|tail
operator|=
name|data
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RF_ParityLogData_t
modifier|*
name|DequeueParityLogData
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|head
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|tail
parameter_list|,
name|int
name|ignoreLocks
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|data
decl_stmt|;
comment|/* Remove and return an in-core parity log from the tail of a disk 	 * queue (*head, *tail). NON-BLOCKING */
comment|/* remove from tail, preserving FIFO order */
if|if
condition|(
operator|!
name|ignoreLocks
condition|)
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|data
operator|=
operator|*
name|tail
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
if|if
condition|(
operator|*
name|head
operator|==
operator|*
name|tail
condition|)
block|{
comment|/* removing last item from queue */
operator|*
name|head
operator|=
name|NULL
expr_stmt|;
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tail
operator|=
operator|(
operator|*
name|tail
operator|)
operator|->
name|prev
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[dequeueing parity log data, region %d, raidAddress %d, numSector %d]\n"
argument_list|,
name|data
operator|->
name|regionID
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|diskAddress
operator|.
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|diskAddress
operator|.
name|numSector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|head
condition|)
block|{
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ignoreLocks
condition|)
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|RequeueParityLogData
parameter_list|(
name|RF_ParityLogData_t
modifier|*
name|data
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|head
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
comment|/* Insert an in-core parity log (*data) into the tail of a disk queue 	 * (*head, *tail). NON-BLOCKING */
name|raidPtr
operator|=
name|data
operator|->
name|common
operator|->
name|raidPtr
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[requeueing parity log data, region %d, raidAddress %d, numSector %d]\n"
argument_list|,
name|data
operator|->
name|regionID
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|diskAddress
operator|.
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|diskAddress
operator|.
name|numSector
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tail
condition|)
block|{
comment|/* append to tail of list */
name|data
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|data
expr_stmt|;
operator|*
name|tail
operator|=
name|data
expr_stmt|;
block|}
else|else
block|{
comment|/* inserting into an empty list */
operator|*
name|head
operator|=
name|data
expr_stmt|;
operator|*
name|tail
operator|=
name|data
expr_stmt|;
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|RF_ParityLogData_t
modifier|*
name|rf_CreateParityLogData
parameter_list|(
name|RF_ParityRecordType_t
name|operation
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|pda
parameter_list|,
name|caddr_t
name|bufPtr
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|int
function_decl|(
modifier|*
name|wakeFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|int
name|status
parameter_list|)
parameter_list|,
name|void
modifier|*
name|wakeArg
parameter_list|,
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
parameter_list|,
name|RF_Etimer_t
name|startTime
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|resultHead
init|=
name|NULL
decl_stmt|,
modifier|*
name|resultTail
init|=
name|NULL
decl_stmt|;
name|RF_CommonLogData_t
modifier|*
name|common
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|diskAddress
decl_stmt|;
name|int
name|boundary
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Return an initialized struct of info to be logged. Build one item 	 * per physical disk address, one item per region. 	 *  	 * NON-BLOCKING */
name|diskAddress
operator|=
name|pda
expr_stmt|;
name|common
operator|=
name|AllocParityLogCommonData
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|common
argument_list|)
expr_stmt|;
name|common
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|common
operator|->
name|bufPtr
operator|=
name|bufPtr
expr_stmt|;
name|common
operator|->
name|raidPtr
operator|=
name|raidPtr
expr_stmt|;
name|common
operator|->
name|wakeFunc
operator|=
name|wakeFunc
expr_stmt|;
name|common
operator|->
name|wakeArg
operator|=
name|wakeArg
expr_stmt|;
name|common
operator|->
name|tracerec
operator|=
name|tracerec
expr_stmt|;
name|common
operator|->
name|startTime
operator|=
name|startTime
expr_stmt|;
name|common
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[entering CreateParityLogData]\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|diskAddress
condition|)
block|{
name|common
operator|->
name|cnt
operator|++
expr_stmt|;
name|data
operator|=
name|AllocParityLogData
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|common
operator|=
name|common
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|regionID
operator|=
name|rf_MapRegionIDParityLogging
argument_list|(
name|raidPtr
argument_list|,
name|diskAddress
operator|->
name|startSector
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|regionID
operator|==
name|rf_MapRegionIDParityLogging
argument_list|(
name|raidPtr
argument_list|,
name|diskAddress
operator|->
name|startSector
operator|+
name|diskAddress
operator|->
name|numSector
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* disk address does not cross a region boundary */
name|data
operator|->
name|diskAddress
operator|=
operator|*
name|diskAddress
expr_stmt|;
name|data
operator|->
name|bufOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|offset
operator|+
name|diskAddress
operator|->
name|numSector
expr_stmt|;
name|EnqueueParityLogData
argument_list|(
name|data
argument_list|,
operator|&
name|resultHead
argument_list|,
operator|&
name|resultTail
argument_list|)
expr_stmt|;
comment|/* adjust disk address */
name|diskAddress
operator|=
name|diskAddress
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* disk address crosses a region boundary */
comment|/* find address where region is crossed */
name|boundary
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|data
operator|->
name|regionID
operator|==
name|rf_MapRegionIDParityLogging
argument_list|(
name|raidPtr
argument_list|,
name|diskAddress
operator|->
name|startSector
operator|+
name|boundary
argument_list|)
condition|)
name|boundary
operator|++
expr_stmt|;
comment|/* enter data before the boundary */
name|data
operator|->
name|diskAddress
operator|=
operator|*
name|diskAddress
expr_stmt|;
name|data
operator|->
name|diskAddress
operator|.
name|numSector
operator|=
name|boundary
expr_stmt|;
name|data
operator|->
name|bufOffset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|boundary
expr_stmt|;
name|EnqueueParityLogData
argument_list|(
name|data
argument_list|,
operator|&
name|resultHead
argument_list|,
operator|&
name|resultTail
argument_list|)
expr_stmt|;
comment|/* adjust disk address */
name|diskAddress
operator|->
name|startSector
operator|+=
name|boundary
expr_stmt|;
name|diskAddress
operator|->
name|numSector
operator|-=
name|boundary
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[leaving CreateParityLogData]\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|resultHead
operator|)
return|;
block|}
end_function

begin_function
name|RF_ParityLogData_t
modifier|*
name|rf_SearchAndDequeueParityLogData
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|int
name|regionID
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|head
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|tail
parameter_list|,
name|int
name|ignoreLocks
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|w
decl_stmt|;
comment|/* Remove and return an in-core parity log from a specified region 	 * (regionID). If a matching log is not found, return NULL. 	 *  	 * NON-BLOCKING. */
comment|/* walk backward through a list, looking for an entry with a matching 	 * region ID */
if|if
condition|(
operator|!
name|ignoreLocks
condition|)
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|w
operator|=
operator|(
operator|*
name|tail
operator|)
expr_stmt|;
while|while
condition|(
name|w
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|regionID
operator|==
name|regionID
condition|)
block|{
comment|/* remove an element from the list */
if|if
condition|(
name|w
operator|==
operator|*
name|tail
condition|)
block|{
if|if
condition|(
operator|*
name|head
operator|==
operator|*
name|tail
condition|)
block|{
comment|/* removing only element in the list */
operator|*
name|head
operator|=
name|NULL
expr_stmt|;
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* removing last item in the list */
operator|*
name|tail
operator|=
operator|(
operator|*
name|tail
operator|)
operator|->
name|prev
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|w
operator|==
operator|*
name|head
condition|)
block|{
comment|/* removing first item in the list */
operator|*
name|head
operator|=
operator|(
operator|*
name|head
operator|)
operator|->
name|next
expr_stmt|;
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* removing an item from the middle of 					 * the list */
name|w
operator|->
name|prev
operator|->
name|next
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|w
operator|->
name|next
operator|->
name|prev
operator|=
name|w
operator|->
name|prev
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[dequeueing parity log data, region %d, raidAddress %d, numSector %d]\n"
argument_list|,
name|w
operator|->
name|regionID
argument_list|,
operator|(
name|int
operator|)
name|w
operator|->
name|diskAddress
operator|.
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|w
operator|->
name|diskAddress
operator|.
name|numSector
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
else|else
name|w
operator|=
name|w
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ignoreLocks
condition|)
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|RF_ParityLogData_t
modifier|*
name|DequeueMatchingLogData
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|head
parameter_list|,
name|RF_ParityLogData_t
modifier|*
modifier|*
name|tail
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|logDataList
decl_stmt|,
modifier|*
name|logData
decl_stmt|;
name|int
name|regionID
decl_stmt|;
comment|/* Remove and return an in-core parity log from the tail of a disk 	 * queue (*head, *tail).  Then remove all matching (identical 	 * regionIDs) logData and return as a linked list. 	 *  	 * NON-BLOCKING */
name|logDataList
operator|=
name|DequeueParityLogData
argument_list|(
name|raidPtr
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|logDataList
condition|)
block|{
name|regionID
operator|=
name|logDataList
operator|->
name|regionID
expr_stmt|;
name|logData
operator|=
name|logDataList
expr_stmt|;
name|logData
operator|->
name|next
operator|=
name|rf_SearchAndDequeueParityLogData
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
name|logData
operator|->
name|next
condition|)
block|{
name|logData
operator|=
name|logData
operator|->
name|next
expr_stmt|;
name|logData
operator|->
name|next
operator|=
name|rf_SearchAndDequeueParityLogData
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|logDataList
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|RF_ParityLog_t
modifier|*
name|AcquireParityLog
parameter_list|(
name|RF_ParityLogData_t
modifier|*
name|logData
parameter_list|,
name|int
name|finish
parameter_list|)
block|{
name|RF_ParityLog_t
modifier|*
name|log
init|=
name|NULL
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
comment|/* Grab a log buffer from the pool and return it. If no buffers are 	 * available, return NULL. NON-BLOCKING */
name|raidPtr
operator|=
name|logData
operator|->
name|common
operator|->
name|raidPtr
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
condition|)
block|{
name|log
operator|=
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
expr_stmt|;
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
operator|=
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
operator|->
name|next
expr_stmt|;
name|log
operator|->
name|regionID
operator|=
name|logData
operator|->
name|regionID
expr_stmt|;
name|log
operator|->
name|numRecords
operator|=
literal|0
expr_stmt|;
name|log
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|logsInUse
operator|++
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|logsInUse
operator|>=
literal|0
operator|&&
name|raidPtr
operator|->
name|logsInUse
operator|<=
name|raidPtr
operator|->
name|numParityLogs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no logs available, so place ourselves on the queue of work 		 * waiting on log buffers this is done while 		 * parityLogPool.mutex is held, to ensure synchronization with 		 * ReleaseParityLogs. */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[blocked on log, region %d, finish %d]\n"
argument_list|,
name|logData
operator|->
name|regionID
argument_list|,
name|finish
argument_list|)
expr_stmt|;
if|if
condition|(
name|finish
condition|)
name|RequeueParityLogData
argument_list|(
name|logData
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockTail
argument_list|)
expr_stmt|;
else|else
name|EnqueueParityLogData
argument_list|(
name|logData
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockTail
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|log
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_ReleaseParityLogs
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ParityLog_t
modifier|*
name|firstLog
parameter_list|)
block|{
name|RF_ParityLogData_t
modifier|*
name|logDataList
decl_stmt|;
name|RF_ParityLog_t
modifier|*
name|log
decl_stmt|,
modifier|*
name|lastLog
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Insert a linked list of parity logs (firstLog) to the free list 	 * (parityLogPool.parityLogPool) 	 *  	 * NON-BLOCKING. */
name|RF_ASSERT
argument_list|(
name|firstLog
argument_list|)
expr_stmt|;
comment|/* Before returning logs to global free list, service all requests 	 * which are blocked on logs.  Holding mutexes for parityLogPool and 	 * parityLogDiskQueue forces synchronization with AcquireParityLog(). */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|logDataList
operator|=
name|DequeueMatchingLogData
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockTail
argument_list|)
expr_stmt|;
name|log
operator|=
name|firstLog
expr_stmt|;
if|if
condition|(
name|firstLog
condition|)
name|firstLog
operator|=
name|firstLog
operator|->
name|next
expr_stmt|;
name|log
operator|->
name|numRecords
operator|=
literal|0
expr_stmt|;
name|log
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|logDataList
operator|&&
name|log
condition|)
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rf_ParityLogAppend
argument_list|(
name|logDataList
argument_list|,
name|RF_TRUE
argument_list|,
operator|&
name|log
argument_list|,
name|RF_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[finishing up buf-blocked log data, region %d]\n"
argument_list|,
name|logDataList
operator|->
name|regionID
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
block|{
name|log
operator|=
name|firstLog
expr_stmt|;
if|if
condition|(
name|firstLog
condition|)
block|{
name|firstLog
operator|=
name|firstLog
operator|->
name|next
expr_stmt|;
name|log
operator|->
name|numRecords
operator|=
literal|0
expr_stmt|;
name|log
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|logDataList
operator|=
name|DequeueMatchingLogData
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|logBlockTail
argument_list|)
expr_stmt|;
block|}
comment|/* return remaining logs to pool */
if|if
condition|(
name|log
condition|)
block|{
name|log
operator|->
name|next
operator|=
name|firstLog
expr_stmt|;
name|firstLog
operator|=
name|log
expr_stmt|;
block|}
if|if
condition|(
name|firstLog
condition|)
block|{
name|lastLog
operator|=
name|firstLog
expr_stmt|;
name|raidPtr
operator|->
name|logsInUse
operator|--
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|logsInUse
operator|>=
literal|0
operator|&&
name|raidPtr
operator|->
name|logsInUse
operator|<=
name|raidPtr
operator|->
name|numParityLogs
argument_list|)
expr_stmt|;
while|while
condition|(
name|lastLog
operator|->
name|next
condition|)
block|{
name|lastLog
operator|=
name|lastLog
operator|->
name|next
expr_stmt|;
name|raidPtr
operator|->
name|logsInUse
operator|--
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|logsInUse
operator|>=
literal|0
operator|&&
name|raidPtr
operator|->
name|logsInUse
operator|<=
name|raidPtr
operator|->
name|numParityLogs
argument_list|)
expr_stmt|;
block|}
name|lastLog
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
expr_stmt|;
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
operator|=
name|firstLog
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|log
operator|=
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|parityLogs
expr_stmt|;
while|while
condition|(
name|log
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|log
operator|=
name|log
operator|->
name|next
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|cnt
operator|+
name|raidPtr
operator|->
name|logsInUse
operator|==
name|raidPtr
operator|->
name|numParityLogs
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogPool
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReintLog
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|int
name|regionID
parameter_list|,
name|RF_ParityLog_t
modifier|*
name|log
parameter_list|)
block|{
name|RF_ASSERT
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* Insert an in-core parity log (log) into the disk queue of 	 * reintegration work.  Set the flag (reintInProgress) for the 	 * specified region (regionID) to indicate that reintegration is in 	 * progress for this region. NON-BLOCKING */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintInProgress
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* cleared when reint 									 * complete */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[requesting reintegration of region %d]\n"
argument_list|,
name|log
operator|->
name|regionID
argument_list|)
expr_stmt|;
comment|/* move record to reintegration queue */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|log
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
operator|=
name|log
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FlushLog
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ParityLog_t
modifier|*
name|log
parameter_list|)
block|{
comment|/* insert a core log (log) into a list of logs 	 * (parityLogDiskQueue.flushQueue) waiting to be written to disk. 	 * NON-BLOCKING */
name|RF_ASSERT
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|numRecords
operator|==
name|raidPtr
operator|->
name|numSectorsPerLog
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* move log to flush queue */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|log
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
operator|=
name|log
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|DumpParityLogToDisk
parameter_list|(
name|int
name|finish
parameter_list|,
name|RF_ParityLogData_t
modifier|*
name|logData
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|diskCount
decl_stmt|,
name|regionID
init|=
name|logData
operator|->
name|regionID
decl_stmt|;
name|RF_ParityLog_t
modifier|*
name|log
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
name|logData
operator|->
name|common
operator|->
name|raidPtr
expr_stmt|;
comment|/* Move a core log to disk.  If the log disk is full, initiate 	 * reintegration. 	 *  	 * Return (0) if we can enqueue the dump immediately, otherwise return 	 * (1) to indicate we are blocked on reintegration and control of the 	 * thread should be relinquished. 	 *  	 * Caller must hold regionInfo[regionID].mutex 	 *  	 * NON-BLOCKING */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[dumping parity log to disk, region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
name|log
operator|=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|numRecords
operator|==
name|raidPtr
operator|->
name|numSectorsPerLog
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* if reintegration is in progress, must queue work */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintInProgress
condition|)
block|{
comment|/* Can not proceed since this region is currently being 		 * reintegrated. We can not block, so queue remaining work and 		 * return */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[region %d waiting on reintegration]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
comment|/* XXX not sure about the use of finish - shouldn't this 		 * always be "Enqueue"? */
if|if
condition|(
name|finish
condition|)
name|RequeueParityLogData
argument_list|(
name|logData
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockTail
argument_list|)
expr_stmt|;
else|else
name|EnqueueParityLogData
argument_list|(
name|logData
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockTail
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* relenquish control of this thread */
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|)
operator|<
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|capacity
condition|)
comment|/* IMPORTANT!! this loop bound assumes region disk holds an 		 * integral number of core logs */
block|{
comment|/* update disk map for this region */
name|diskCount
operator|=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numSectorsPerLog
condition|;
name|i
operator|++
control|)
block|{
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskMap
index|[
name|i
operator|+
name|diskCount
index|]
operator|.
name|operation
operator|=
name|log
operator|->
name|records
index|[
name|i
index|]
operator|.
name|operation
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskMap
index|[
name|i
operator|+
name|diskCount
index|]
operator|.
name|parityAddr
operator|=
name|log
operator|->
name|records
index|[
name|i
index|]
operator|.
name|parityAddr
expr_stmt|;
block|}
name|log
operator|->
name|diskOffset
operator|=
name|diskCount
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|+=
name|raidPtr
operator|->
name|numSectorsPerLog
expr_stmt|;
name|FlushLog
argument_list|(
name|raidPtr
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no room for log on disk, send it to disk manager and 		 * request reintegration */
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|==
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|capacity
argument_list|)
expr_stmt|;
name|ReintLog
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[finished dumping parity log to disk, region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_ParityLogAppend
parameter_list|(
name|RF_ParityLogData_t
modifier|*
name|logData
parameter_list|,
name|int
name|finish
parameter_list|,
name|RF_ParityLog_t
modifier|*
modifier|*
name|incomingLog
parameter_list|,
name|int
name|clearReintFlag
parameter_list|)
block|{
name|int
name|regionID
decl_stmt|,
name|logItem
decl_stmt|,
name|itemDone
decl_stmt|;
name|RF_ParityLogData_t
modifier|*
name|item
decl_stmt|;
name|int
name|punt
decl_stmt|,
name|done
init|=
name|RF_FALSE
decl_stmt|;
name|RF_ParityLog_t
modifier|*
name|log
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|int
function_decl|(
modifier|*
name|wakeFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
name|void
modifier|*
name|wakeArg
decl_stmt|;
comment|/* Add parity to the appropriate log, one sector at a time. This 	 * routine is called is called by dag functions ParityLogUpdateFunc 	 * and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING. 	 *  	 * Parity to be logged is contained in a linked-list (logData).  When 	 * this routine returns, every sector in the list will be in one of 	 * three places: 1) entered into the parity log 2) queued, waiting on 	 * reintegration 3) queued, waiting on a core log 	 *  	 * Blocked work is passed to the ParityLoggingDiskManager for completion. 	 * Later, as conditions which required the block are removed, the work 	 * reenters this routine with the "finish" parameter set to "RF_TRUE." 	 *  	 * NON-BLOCKING */
name|raidPtr
operator|=
name|logData
operator|->
name|common
operator|->
name|raidPtr
expr_stmt|;
comment|/* lock the region for the first item in logData */
name|RF_ASSERT
argument_list|(
name|logData
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|regionID
operator|=
name|logData
operator|->
name|regionID
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|loggingEnabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearReintFlag
condition|)
block|{
comment|/* Enable flushing for this region.  Holding both locks 		 * provides a synchronization barrier with DumpParityLogToDisk */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintInProgress
operator|==
name|RF_TRUE
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintInProgress
operator|=
name|RF_FALSE
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
comment|/* flushing is now 										 * enabled */
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
comment|/* process each item in logData */
while|while
condition|(
name|logData
condition|)
block|{
comment|/* remove an item from logData */
name|item
operator|=
name|logData
expr_stmt|;
name|logData
operator|=
name|logData
operator|->
name|next
expr_stmt|;
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|item
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[appending parity log data, region %d, raidAddress %d, numSector %d]\n"
argument_list|,
name|item
operator|->
name|regionID
argument_list|,
operator|(
name|int
operator|)
name|item
operator|->
name|diskAddress
operator|.
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|item
operator|->
name|diskAddress
operator|.
name|numSector
argument_list|)
expr_stmt|;
comment|/* see if we moved to a new region */
if|if
condition|(
name|regionID
operator|!=
name|item
operator|->
name|regionID
condition|)
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|regionID
operator|=
name|item
operator|->
name|regionID
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|loggingEnabled
argument_list|)
expr_stmt|;
block|}
name|punt
operator|=
name|RF_FALSE
expr_stmt|;
comment|/* Set to RF_TRUE if work is blocked.  This 				 * can happen in one of two ways: 1) no core 				 * log (AcquireParityLog) 2) waiting on 				 * reintegration (DumpParityLogToDisk) If punt 				 * is RF_TRUE, the dataItem was queued, so 				 * skip to next item. */
comment|/* process item, one sector at a time, until all sectors 		 * processed or we punt */
if|if
condition|(
name|item
operator|->
name|diskAddress
operator|.
name|numSector
operator|>
literal|0
condition|)
name|done
operator|=
name|RF_FALSE
expr_stmt|;
else|else
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|punt
operator|&&
operator|!
name|done
condition|)
block|{
comment|/* verify that a core log exists for this region */
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
condition|)
block|{
comment|/* Attempt to acquire a parity log. If 				 * acquisition fails, queue remaining work in 				 * data item and move to nextItem. */
if|if
condition|(
name|incomingLog
condition|)
if|if
condition|(
operator|*
name|incomingLog
condition|)
block|{
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|incomingLog
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
operator|*
name|incomingLog
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|->
name|regionID
operator|=
name|regionID
expr_stmt|;
operator|*
name|incomingLog
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
name|AcquireParityLog
argument_list|(
name|item
argument_list|,
name|finish
argument_list|)
expr_stmt|;
else|else
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
name|AcquireParityLog
argument_list|(
name|item
argument_list|,
name|finish
argument_list|)
expr_stmt|;
comment|/* Note: AcquireParityLog either returns a log 				 * or enqueues currentItem */
block|}
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
condition|)
name|punt
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* failed to find a core log */
else|else
block|{
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* verify that the log has room for new 				 * entries */
comment|/* if log is full, dump it to disk and grab a 				 * new log */
if|if
condition|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|->
name|numRecords
operator|==
name|raidPtr
operator|->
name|numSectorsPerLog
condition|)
block|{
comment|/* log is full, dump it to disk */
if|if
condition|(
name|DumpParityLogToDisk
argument_list|(
name|finish
argument_list|,
name|item
argument_list|)
condition|)
name|punt
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* dump unsuccessful, 								 * blocked on 								 * reintegration */
else|else
block|{
comment|/* dump was successful */
if|if
condition|(
name|incomingLog
condition|)
if|if
condition|(
operator|*
name|incomingLog
condition|)
block|{
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|incomingLog
operator|)
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
operator|*
name|incomingLog
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|->
name|regionID
operator|=
name|regionID
expr_stmt|;
operator|*
name|incomingLog
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
name|AcquireParityLog
argument_list|(
name|item
argument_list|,
name|finish
argument_list|)
expr_stmt|;
else|else
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
name|AcquireParityLog
argument_list|(
name|item
argument_list|,
name|finish
argument_list|)
expr_stmt|;
comment|/* if a core log is not 						 * available, must queue work 						 * and return */
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
condition|)
name|punt
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* blocked on log 									 * availability */
block|}
block|}
block|}
comment|/* if we didn't punt on this item, attempt to add a 			 * sector to the core log */
if|if
condition|(
operator|!
name|punt
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* at this point, we have a core log with 				 * enough room for a sector */
comment|/* copy a sector into the log */
name|log
operator|=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|numRecords
operator|<
name|raidPtr
operator|->
name|numSectorsPerLog
argument_list|)
expr_stmt|;
name|logItem
operator|=
name|log
operator|->
name|numRecords
operator|++
expr_stmt|;
name|log
operator|->
name|records
index|[
name|logItem
index|]
operator|.
name|parityAddr
operator|=
name|item
operator|->
name|diskAddress
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|records
index|[
name|logItem
index|]
operator|.
name|parityAddr
operator|.
name|startSector
operator|>=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|parityStartAddr
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|log
operator|->
name|records
index|[
name|logItem
index|]
operator|.
name|parityAddr
operator|.
name|startSector
operator|<
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|parityStartAddr
operator|+
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|numSectorsParity
argument_list|)
expr_stmt|;
name|log
operator|->
name|records
index|[
name|logItem
index|]
operator|.
name|parityAddr
operator|.
name|numSector
operator|=
literal|1
expr_stmt|;
name|log
operator|->
name|records
index|[
name|logItem
index|]
operator|.
name|operation
operator|=
name|item
operator|->
name|common
operator|->
name|operation
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|item
operator|->
name|common
operator|->
name|bufPtr
operator|+
operator|(
name|item
operator|->
name|bufOffset
operator|++
operator|*
operator|(
literal|1
operator|<<
name|item
operator|->
name|common
operator|->
name|raidPtr
operator|->
name|logBytesPerSector
operator|)
operator|)
operator|)
argument_list|,
name|log
operator|->
name|bufPtr
operator|+
operator|(
name|logItem
operator|*
operator|(
literal|1
operator|<<
name|item
operator|->
name|common
operator|->
name|raidPtr
operator|->
name|logBytesPerSector
operator|)
operator|)
argument_list|,
operator|(
literal|1
operator|<<
name|item
operator|->
name|common
operator|->
name|raidPtr
operator|->
name|logBytesPerSector
operator|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|diskAddress
operator|.
name|numSector
operator|--
expr_stmt|;
name|item
operator|->
name|diskAddress
operator|.
name|startSector
operator|++
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|diskAddress
operator|.
name|numSector
operator|==
literal|0
condition|)
name|done
operator|=
name|RF_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|punt
condition|)
block|{
comment|/* Processed this item completely, decrement count of 			 * items to be processed. */
name|RF_ASSERT
argument_list|(
name|item
operator|->
name|diskAddress
operator|.
name|numSector
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|item
operator|->
name|common
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|item
operator|->
name|common
operator|->
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|common
operator|->
name|cnt
operator|==
literal|0
condition|)
name|itemDone
operator|=
name|RF_TRUE
expr_stmt|;
else|else
name|itemDone
operator|=
name|RF_FALSE
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|item
operator|->
name|common
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|itemDone
condition|)
block|{
comment|/* Finished processing all log data for this 				 * IO Return structs to free list and invoke 				 * wakeup function. */
name|timer
operator|=
name|item
operator|->
name|common
operator|->
name|startTime
expr_stmt|;
comment|/* grab initial value of 									 * timer */
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|item
operator|->
name|common
operator|->
name|tracerec
operator|->
name|plog_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[waking process for region %d]\n"
argument_list|,
name|item
operator|->
name|regionID
argument_list|)
expr_stmt|;
name|wakeFunc
operator|=
name|item
operator|->
name|common
operator|->
name|wakeFunc
expr_stmt|;
name|wakeArg
operator|=
name|item
operator|->
name|common
operator|->
name|wakeArg
expr_stmt|;
name|FreeParityLogCommonData
argument_list|(
name|item
operator|->
name|common
argument_list|)
expr_stmt|;
name|FreeParityLogData
argument_list|(
name|item
argument_list|)
expr_stmt|;
call|(
name|wakeFunc
call|)
argument_list|(
name|wakeArg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|FreeParityLogData
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[exiting ParityLogAppend]\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_EnableParityLogging
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|int
name|regionID
decl_stmt|;
for|for
control|(
name|regionID
operator|=
literal|0
init|;
name|regionID
operator|<
name|rf_numParityRegions
condition|;
name|regionID
operator|++
control|)
block|{
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|loggingEnabled
operator|=
name|RF_TRUE
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[parity logging enabled]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

end_unit

