begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_evenodd_dagfuncs.c,v 1.7 2001/01/26 03:50:53 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: ChangMing Wu  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * Code for RAID-EVENODD  architecture.  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_EVENODD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd_dagfuncs.h>
end_include

begin_comment
comment|/* These redundant functions are for small write */
end_comment

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_EOSmallWritePFuncs
init|=
block|{
name|rf_RegularXorFunc
block|,
literal|"Regular Old-New P"
block|,
name|rf_SimpleXorFunc
block|,
literal|"Simple Old-New P"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_EOSmallWriteEFuncs
init|=
block|{
name|rf_RegularONEFunc
block|,
literal|"Regular Old-New E"
block|,
name|rf_SimpleONEFunc
block|,
literal|"Regular Old-New E"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These redundant functions are for degraded read */
end_comment

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_eoPRecoveryFuncs
init|=
block|{
name|rf_RecoveryXorFunc
block|,
literal|"Recovery Xr"
block|,
name|rf_RecoveryXorFunc
block|,
literal|"Recovery Xr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_eoERecoveryFuncs
init|=
block|{
name|rf_RecoveryEFunc
block|,
literal|"Recovery E Func"
block|,
name|rf_RecoveryEFunc
block|,
literal|"Recovery E Func"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************************************************************  *   the following encoding node functions is used in  EO_000_CreateLargeWriteDAG  **********************************************************************************************/
end_comment

begin_function
name|int
name|rf_RegularPEFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|rf_RegularESubroutine
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|results
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rf_RegularXorFunc
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* does the wakeup here! */
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX This was missing... GO */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/************************************************************************************************  *  For EO_001_CreateSmallWriteDAG, there are (i)RegularONEFunc() and (ii)SimpleONEFunc() to  *  be used. The previous case is when write access at least sectors of full stripe unit.  *  The later function is used when the write access two stripe units but with total sectors  *  less than sectors per SU. In this case, the access of parity and 'E' are shown as disconnected  *  areas in their stripe unit and  parity write and 'E' write are both devided into two distinct  *  writes( totally four). This simple old-new write and regular old-new write happen as in RAID-5  ************************************************************************************************/
end_comment

begin_comment
comment|/* Algorithm:      1. Store the difference of old data and new data in the Rod buffer.      2. then encode this buffer into the buffer which already have old 'E' information inside it, 	the result can be shown to be the new 'E' information.      3. xor the Wnd buffer into the difference buffer to recover the  original old data.    Here we have another alternative: to allocate a temporary buffer for storing the difference of    old data and new data, then encode temp buf into old 'E' buf to form new 'E', but this approach    take the same speed as the previous, and need more memory. */
end_comment

begin_function
name|int
name|rf_RegularONEFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|int
name|EpdaIndex
init|=
operator|(
name|node
operator|->
name|numParams
operator|-
literal|1
operator|)
operator|/
literal|2
operator|-
literal|1
decl_stmt|;
comment|/* the parameter of node 								 * where you can find 								 * e-pda */
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|suoffset
decl_stmt|,
name|length
decl_stmt|;
name|RF_RowCol_t
name|scol
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|EPDA
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|EpdaIndex
index|]
operator|.
name|p
decl_stmt|;
name|int
name|ESUOffset
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|EPDA
operator|->
name|startSector
argument_list|)
decl_stmt|;
comment|/* generally zero  */
name|RF_ASSERT
argument_list|(
name|EPDA
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|ESUOffset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* Xor the Wnd buffer into Rod buffer, the difference of old data and 	 * new data is stored in Rod buffer */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|EpdaIndex
condition|;
name|k
operator|+=
literal|2
control|)
block|{
name|length
operator|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|k
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_bxor
argument_list|(
name|node
operator|->
name|params
index|[
name|k
operator|+
name|EpdaIndex
operator|+
literal|3
index|]
operator|.
name|p
argument_list|,
name|node
operator|->
name|params
index|[
name|k
operator|+
literal|1
index|]
operator|.
name|p
argument_list|,
name|length
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* Start to encoding the buffer storing the difference of old data and 	 * new data into 'E' buffer  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EpdaIndex
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|node
operator|->
name|results
index|[
literal|0
index|]
condition|)
block|{
comment|/* results[0] is buf ptr 									 * of E */
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|srcbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|scol
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|destbuf
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
operator|)
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|suoffset
argument_list|)
expr_stmt|;
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|scol
argument_list|,
name|srcbuf
argument_list|,
name|RF_EO_MATRIX_DIM
operator|-
literal|2
argument_list|,
name|destbuf
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
comment|/* Recover the original old data to be used by parity encoding 	 * function in XorNode */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|EpdaIndex
condition|;
name|k
operator|+=
literal|2
control|)
block|{
name|length
operator|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|k
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_bxor
argument_list|(
name|node
operator|->
name|params
index|[
name|k
operator|+
name|EpdaIndex
operator|+
literal|3
index|]
operator|.
name|p
argument_list|,
name|node
operator|->
name|params
index|[
name|k
operator|+
literal|1
index|]
operator|.
name|p
argument_list|,
name|length
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX this was missing.. GO */
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|rf_SimpleONEFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|int
name|length
decl_stmt|;
name|RF_RowCol_t
name|scol
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|p
operator|)
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|length
operator|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|4
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
argument_list|)
expr_stmt|;
comment|/* this is a pda of 														 * writeDataNodes */
comment|/* bxor to buffer of readDataNodes */
name|retcode
operator|=
name|rf_bxor
argument_list|(
name|node
operator|->
name|params
index|[
literal|5
index|]
operator|.
name|p
argument_list|,
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|length
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* find out the corresponding colume in encoding matrix for 		 * write colume to be encoded into redundant disk 'E' */
name|scol
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|srcbuf
operator|=
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|destbuf
operator|=
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|p
expr_stmt|;
comment|/* Start encoding process */
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|scol
argument_list|,
name|srcbuf
argument_list|,
name|RF_EO_MATRIX_DIM
operator|-
literal|2
argument_list|,
name|destbuf
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|rf_bxor
argument_list|(
name|node
operator|->
name|params
index|[
literal|5
index|]
operator|.
name|p
argument_list|,
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|length
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
name|retcode
argument_list|)
operator|)
return|;
comment|/* call wake func 							 * explicitly since no 							 * I/O in this node */
block|}
end_function

begin_comment
comment|/****** called by rf_RegularPEFunc(node) and rf_RegularEFunc(node) in f.f. large write  ********/
end_comment

begin_function
name|void
name|rf_RegularESubroutine
parameter_list|(
name|node
parameter_list|,
name|ebuf
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|ebuf
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
name|i
decl_stmt|,
name|suoffset
decl_stmt|;
name|RF_RowCol_t
name|scol
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|ebuf
argument_list|)
expr_stmt|;
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|scol
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|srcbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|destbuf
operator|=
name|ebuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|suoffset
argument_list|)
expr_stmt|;
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|scol
argument_list|,
name|srcbuf
argument_list|,
name|RF_EO_MATRIX_DIM
operator|-
literal|2
argument_list|,
name|destbuf
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|xor_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************************  *			 Used in  EO_001_CreateLargeWriteDAG  ******************************************************************************************/
end_comment

begin_function
name|int
name|rf_RegularEFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|rf_RegularESubroutine
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX this was missing?.. GO */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*******************************************************************************************  * This degraded function allow only two case:  *  1. when write access the full failed stripe unit, then the access can be more than  *     one tripe units.  *  2. when write access only part of the failed SU, we assume accesses of more than  *     one stripe unit is not allowed so that the write can be dealt with like a  *     large write.  *  The following function is based on these assumptions. So except in the second case,  *  it looks the same as a large write encodeing function. But this is not exactly the  *  normal way for doing a degraded write, since raidframe have to break cases of access  *  other than the above two into smaller accesses. We may have to change  *  DegrESubroutin in the future.  *******************************************************************************************/
end_comment

begin_function
name|void
name|rf_DegrESubroutine
parameter_list|(
name|node
parameter_list|,
name|ebuf
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|ebuf
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
name|i
decl_stmt|,
name|suoffset
decl_stmt|,
name|failedSUOffset
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|RF_RowCol_t
name|scol
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|ebuf
argument_list|)
expr_stmt|;
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|scol
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|srcbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|destbuf
operator|=
name|ebuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|suoffset
operator|-
name|failedSUOffset
argument_list|)
expr_stmt|;
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|scol
argument_list|,
name|srcbuf
argument_list|,
name|RF_EO_MATRIX_DIM
operator|-
literal|2
argument_list|,
name|destbuf
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************************  * This function is used in case where one data disk failed and both redundant disks  * alive. It is used in the EO_100_CreateWriteDAG. Note: if there is another disk  * failed in the stripe but not accessed at this time, then we should, instead, use  * the rf_EOWriteDoubleRecoveryFunc().  **************************************************************************************/
end_comment

begin_function
name|int
name|rf_Degraded_100_EOFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|rf_DegrESubroutine
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|results
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rf_RecoveryXorFunc
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* does the wakeup here! */
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX this was missing... SHould these be 				 * void functions??? GO */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**************************************************************************************  * This function is to encode one sector in one of the data disks to the E disk.  * However, in evenodd this function can also be used as decoding function to recover  * data from dead disk in the case of parity failure and a single data failure.  **************************************************************************************/
end_comment

begin_function
name|void
name|rf_e_EncOneSect
parameter_list|(
name|RF_RowCol_t
name|srcLogicCol
parameter_list|,
name|char
modifier|*
name|srcSecbuf
parameter_list|,
name|RF_RowCol_t
name|destLogicCol
parameter_list|,
name|char
modifier|*
name|destSecbuf
parameter_list|,
name|int
name|bytesPerSector
parameter_list|)
block|{
name|int
name|S_index
decl_stmt|;
comment|/* index of the EU in the src col which need 				 * be Xored into all EUs in a dest sector */
name|int
name|numRowInEncMatix
init|=
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|1
decl_stmt|;
name|RF_RowCol_t
name|j
decl_stmt|,
name|indexInDest
decl_stmt|,
comment|/* row index of an encoding unit in 					 * the destination colume of encoding 					 * matrix */
name|indexInSrc
decl_stmt|;
comment|/* row index of an encoding unit in the source 				 * colume used for recovery */
name|int
name|bytesPerEU
init|=
name|bytesPerSector
operator|/
name|numRowInEncMatix
decl_stmt|;
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|int
name|shortsPerEU
init|=
name|bytesPerEU
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
decl_stmt|;
name|short
modifier|*
name|destShortBuf
decl_stmt|,
modifier|*
name|srcShortBuf1
decl_stmt|,
modifier|*
name|srcShortBuf2
decl_stmt|;
name|short
name|temp1
decl_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|int
name|longsPerEU
init|=
name|bytesPerEU
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
name|long
modifier|*
name|destLongBuf
decl_stmt|,
modifier|*
name|srcLongBuf1
decl_stmt|,
modifier|*
name|srcLongBuf2
decl_stmt|;
name|long
name|temp1
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|RF_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|==
literal|2
operator|||
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|bytesPerEU
operator|%
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|RF_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|8
operator|||
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|bytesPerEU
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|S_index
operator|=
name|rf_EO_Mod
argument_list|(
operator|(
name|RF_EO_MATRIX_DIM
operator|-
literal|1
operator|+
name|destLogicCol
operator|-
name|srcLogicCol
operator|)
argument_list|,
name|RF_EO_MATRIX_DIM
argument_list|)
expr_stmt|;
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|srcShortBuf1
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|srcSecbuf
operator|+
name|S_index
operator|*
name|bytesPerEU
operator|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|srcLongBuf1
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|srcSecbuf
operator|+
name|S_index
operator|*
name|bytesPerEU
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|indexInDest
operator|=
literal|0
init|;
name|indexInDest
operator|<
name|numRowInEncMatix
condition|;
name|indexInDest
operator|++
control|)
block|{
name|indexInSrc
operator|=
name|rf_EO_Mod
argument_list|(
operator|(
name|indexInDest
operator|+
name|destLogicCol
operator|-
name|srcLogicCol
operator|)
argument_list|,
name|RF_EO_MATRIX_DIM
argument_list|)
expr_stmt|;
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|destShortBuf
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|destSecbuf
operator|+
name|indexInDest
operator|*
name|bytesPerEU
operator|)
expr_stmt|;
name|srcShortBuf2
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|srcSecbuf
operator|+
name|indexInSrc
operator|*
name|bytesPerEU
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|shortsPerEU
condition|;
name|j
operator|++
control|)
block|{
name|temp1
operator|=
name|destShortBuf
index|[
name|j
index|]
operator|^
name|srcShortBuf1
index|[
name|j
index|]
expr_stmt|;
comment|/* note: S_index won't be at the end row for any src 			 * col! */
if|if
condition|(
name|indexInSrc
operator|!=
name|RF_EO_MATRIX_DIM
operator|-
literal|1
condition|)
name|destShortBuf
index|[
name|j
index|]
operator|=
operator|(
name|srcShortBuf2
index|[
name|j
index|]
operator|)
operator|^
name|temp1
expr_stmt|;
comment|/* if indexInSrc is at the end row, ie. 			 * RF_EO_MATRIX_DIM -1, then all elements are zero! */
else|else
name|destShortBuf
index|[
name|j
index|]
operator|=
name|temp1
expr_stmt|;
block|}
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|destLongBuf
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|destSecbuf
operator|+
name|indexInDest
operator|*
name|bytesPerEU
operator|)
expr_stmt|;
name|srcLongBuf2
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|srcSecbuf
operator|+
name|indexInSrc
operator|*
name|bytesPerEU
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|longsPerEU
condition|;
name|j
operator|++
control|)
block|{
name|temp1
operator|=
name|destLongBuf
index|[
name|j
index|]
operator|^
name|srcLongBuf1
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|indexInSrc
operator|!=
name|RF_EO_MATRIX_DIM
operator|-
literal|1
condition|)
name|destLongBuf
index|[
name|j
index|]
operator|=
operator|(
name|srcLongBuf2
index|[
name|j
index|]
operator|)
operator|^
name|temp1
expr_stmt|;
else|else
name|destLongBuf
index|[
name|j
index|]
operator|=
name|temp1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|rf_e_encToBuf
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|srcLogicCol
parameter_list|,
name|char
modifier|*
name|srcbuf
parameter_list|,
name|RF_RowCol_t
name|destLogicCol
parameter_list|,
name|char
modifier|*
name|destbuf
parameter_list|,
name|int
name|numSector
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bytesPerSector
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numSector
condition|;
name|i
operator|++
control|)
block|{
name|rf_e_EncOneSect
argument_list|(
name|srcLogicCol
argument_list|,
name|srcbuf
argument_list|,
name|destLogicCol
argument_list|,
name|destbuf
argument_list|,
name|bytesPerSector
argument_list|)
expr_stmt|;
name|srcbuf
operator|+=
name|bytesPerSector
expr_stmt|;
name|destbuf
operator|+=
name|bytesPerSector
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************************  * when parity die and one data die, We use second redundant information, 'E',  * to recover the data in dead disk. This function is used in the recovery node of  * for EO_110_CreateReadDAG  **************************************************************************************/
end_comment

begin_function
name|int
name|rf_RecoveryEFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|RF_RowCol_t
name|scol
decl_stmt|,
comment|/* source logical column */
name|fcol
init|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|raidAddress
argument_list|)
decl_stmt|;
comment|/* logical column of 									 * failed SU */
name|int
name|i
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
name|suoffset
decl_stmt|,
name|failedSUOffset
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
operator|->
name|numSector
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|==
name|rf_enable
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|node
operator|->
name|results
index|[
literal|0
index|]
condition|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|node
operator|->
name|numParams
operator|-
literal|4
condition|)
name|scol
operator|=
name|RF_EO_MATRIX_DIM
operator|-
literal|2
expr_stmt|;
comment|/* the colume of 									 * redundant E */
else|else
name|scol
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|srcbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|destbuf
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
operator|)
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|suoffset
operator|-
name|failedSUOffset
argument_list|)
expr_stmt|;
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|scol
argument_list|,
name|srcbuf
argument_list|,
name|fcol
argument_list|,
name|destbuf
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|xor_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* node execute successfully */
block|}
end_function

begin_comment
comment|/**************************************************************************************  * This function is used in the case where one data and the parity have filed.  * (in EO_110_CreateWriteDAG )  **************************************************************************************/
end_comment

begin_function
name|int
name|rf_EO_DegradedWriteEFunc
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
name|rf_DegrESubroutine
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX Yet another one!! GO */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**************************************************************************************  *  		THE FUNCTION IS FOR DOUBLE DEGRADED READ AND WRITE CASES  **************************************************************************************/
end_comment

begin_function
name|void
name|rf_doubleEOdecode
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|char
modifier|*
modifier|*
name|rrdbuf
parameter_list|,
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
name|RF_RowCol_t
modifier|*
name|fcol
parameter_list|,
name|char
modifier|*
name|pbuf
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|row
decl_stmt|;
name|int
name|rrdrow
decl_stmt|,
name|erow
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|int
name|bytesPerSector
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|numRowInEncMatix
init|=
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|1
decl_stmt|;
if|#
directive|if
literal|0
block|int     pcol = (RF_EO_MATRIX_DIM) - 1;
endif|#
directive|endif
name|int
name|ecol
init|=
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|2
decl_stmt|;
name|int
name|bytesPerEU
init|=
name|bytesPerSector
operator|/
name|numRowInEncMatix
decl_stmt|;
name|int
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|int
name|shortsPerEU
init|=
name|bytesPerEU
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
decl_stmt|;
name|short
modifier|*
name|rrdbuf_current
decl_stmt|,
modifier|*
name|pbuf_current
decl_stmt|,
modifier|*
name|ebuf_current
decl_stmt|;
name|short
modifier|*
name|dest_smaller
decl_stmt|,
modifier|*
name|dest_smaller_current
decl_stmt|,
modifier|*
name|dest_larger
decl_stmt|,
modifier|*
name|dest_larger_current
decl_stmt|;
name|short
modifier|*
name|temp
decl_stmt|;
name|short
modifier|*
name|P
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|bytesPerEU
operator|%
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|P
argument_list|,
name|bytesPerEU
argument_list|,
operator|(
name|short
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|temp
argument_list|,
name|bytesPerEU
argument_list|,
operator|(
name|short
operator|*
operator|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|int
name|longsPerEU
init|=
name|bytesPerEU
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
name|long
modifier|*
name|rrdbuf_current
decl_stmt|,
modifier|*
name|pbuf_current
decl_stmt|,
modifier|*
name|ebuf_current
decl_stmt|;
name|long
modifier|*
name|dest_smaller
decl_stmt|,
modifier|*
name|dest_smaller_current
decl_stmt|,
modifier|*
name|dest_larger
decl_stmt|,
modifier|*
name|dest_larger_current
decl_stmt|;
name|long
modifier|*
name|temp
decl_stmt|;
name|long
modifier|*
name|P
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|bytesPerEU
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|P
argument_list|,
name|bytesPerEU
argument_list|,
operator|(
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|temp
argument_list|,
name|bytesPerEU
argument_list|,
operator|(
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RF_ASSERT
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|dest
index|[
literal|0
index|]
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|dest
index|[
literal|1
index|]
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|P
argument_list|,
name|bytesPerEU
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
name|bytesPerEU
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
name|P
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* calculate the 'P' parameter, which, not parity, is the Xor of all 	 * elements in the last two column, ie. 'E' and 'parity' colume, see 	 * the Ref. paper by Blaum, et al 1993  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRowInEncMatix
condition|;
name|i
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
block|{
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|ebuf_current
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
name|ebuf
operator|)
operator|+
name|i
operator|*
name|shortsPerEU
operator|+
name|k
expr_stmt|;
name|pbuf_current
operator|=
operator|(
operator|(
name|short
operator|*
operator|)
name|pbuf
operator|)
operator|+
name|i
operator|*
name|shortsPerEU
operator|+
name|k
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|ebuf_current
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
name|ebuf
operator|)
operator|+
name|i
operator|*
name|longsPerEU
operator|+
name|k
expr_stmt|;
name|pbuf_current
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
name|pbuf
operator|)
operator|+
name|i
operator|*
name|longsPerEU
operator|+
name|k
expr_stmt|;
endif|#
directive|endif
name|P
index|[
name|k
index|]
operator|^=
operator|*
name|ebuf_current
expr_stmt|;
name|P
index|[
name|k
index|]
operator|^=
operator|*
name|pbuf_current
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|fcol
index|[
literal|0
index|]
operator|!=
name|fcol
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcol
index|[
literal|0
index|]
operator|<
name|fcol
index|[
literal|1
index|]
condition|)
block|{
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|dest_smaller
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|dest
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dest_larger
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|dest
index|[
literal|1
index|]
operator|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|dest_smaller
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|dest
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dest_larger
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|dest
index|[
literal|1
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
name|f1
operator|=
name|fcol
index|[
literal|0
index|]
expr_stmt|;
name|f2
operator|=
name|fcol
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|dest_smaller
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|dest
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|dest_larger
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|dest
index|[
literal|0
index|]
operator|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|dest_smaller
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|dest
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|dest_larger
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|dest
index|[
literal|0
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
name|f1
operator|=
name|fcol
index|[
literal|1
index|]
expr_stmt|;
name|f2
operator|=
name|fcol
index|[
literal|0
index|]
expr_stmt|;
block|}
name|row
operator|=
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|row
operator|=
name|rf_EO_Mod
argument_list|(
operator|(
name|row
operator|+
name|f1
operator|-
name|f2
operator|)
argument_list|,
name|RF_EO_MATRIX_DIM
argument_list|)
operator|)
operator|!=
operator|(
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|dest_larger_current
operator|=
name|dest_larger
operator|+
name|row
operator|*
name|shortsPerEU
expr_stmt|;
name|dest_smaller_current
operator|=
name|dest_smaller
operator|+
name|row
operator|*
name|shortsPerEU
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|dest_larger_current
operator|=
name|dest_larger
operator|+
name|row
operator|*
name|longsPerEU
expr_stmt|;
name|dest_smaller_current
operator|=
name|dest_smaller
operator|+
name|row
operator|*
name|longsPerEU
expr_stmt|;
endif|#
directive|endif
comment|/**    Do the diagonal recovery. Initially, temp[k] = (failed 1), 		       which is the failed data in the colume which has smaller col index. **/
comment|/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numDataCol
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|f1
operator|||
name|j
operator|==
name|f2
condition|)
continue|continue;
name|rrdrow
operator|=
name|rf_EO_Mod
argument_list|(
operator|(
name|row
operator|+
name|f2
operator|-
name|j
operator|)
argument_list|,
name|RF_EO_MATRIX_DIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrdrow
operator|!=
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|rrdbuf_current
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|rrdbuf
index|[
name|j
index|]
operator|)
operator|+
name|rrdrow
operator|*
name|shortsPerEU
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|rrdbuf_current
operator|+
name|k
operator|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|rrdbuf_current
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|rrdbuf
index|[
name|j
index|]
operator|)
operator|+
name|rrdrow
operator|*
name|longsPerEU
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|rrdbuf_current
operator|+
name|k
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't 		 * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed 		 * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal 		 * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle 		 * diagonal) ^ (failed 2)       */
name|erow
operator|=
name|rf_EO_Mod
argument_list|(
operator|(
name|row
operator|+
name|f2
operator|-
name|ecol
operator|)
argument_list|,
operator|(
name|RF_EO_MATRIX_DIM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|erow
operator|!=
operator|(
name|RF_EO_MATRIX_DIM
operator|)
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|ebuf_current
operator|=
operator|(
name|short
operator|*
operator|)
name|ebuf
operator|+
name|shortsPerEU
operator|*
name|erow
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|ebuf_current
operator|+
name|k
operator|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|ebuf_current
operator|=
operator|(
name|long
operator|*
operator|)
name|ebuf
operator|+
name|longsPerEU
operator|*
name|erow
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|ebuf_current
operator|+
name|k
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* step 3: ^P to obtain the failed data (failed 2).  P can be 		 * proved to be actually  (principle diagonal)  After this 		 * step, temp[k] = (failed 2), the failed data to be recovered */
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
name|P
index|[
name|k
index|]
expr_stmt|;
comment|/* Put the data to the destination buffer                              */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|dest_larger_current
index|[
name|k
index|]
operator|=
name|temp
index|[
name|k
index|]
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
name|P
index|[
name|k
index|]
expr_stmt|;
comment|/* Put the data to the destination buffer                              */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|dest_larger_current
index|[
name|k
index|]
operator|=
name|temp
index|[
name|k
index|]
expr_stmt|;
endif|#
directive|endif
comment|/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/
comment|/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data 		 * columes    */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numDataCol
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|f1
operator|||
name|j
operator|==
name|f2
condition|)
continue|continue;
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|rrdbuf_current
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|rrdbuf
index|[
name|j
index|]
operator|)
operator|+
name|row
operator|*
name|shortsPerEU
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|rrdbuf_current
operator|+
name|k
operator|)
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|rrdbuf_current
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|rrdbuf
index|[
name|j
index|]
operator|)
operator|+
name|row
operator|*
name|longsPerEU
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|rrdbuf_current
operator|+
name|k
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* step 2: ^A(row,m-1) */
comment|/* step 3: Put the data to the destination buffer                             	 */
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
name|pbuf_current
operator|=
operator|(
name|short
operator|*
operator|)
name|pbuf
operator|+
name|shortsPerEU
operator|*
name|row
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|pbuf_current
operator|+
name|k
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shortsPerEU
condition|;
name|k
operator|++
control|)
name|dest_smaller_current
index|[
name|k
index|]
operator|=
name|temp
index|[
name|k
index|]
expr_stmt|;
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
name|pbuf_current
operator|=
operator|(
name|long
operator|*
operator|)
name|pbuf
operator|+
name|longsPerEU
operator|*
name|row
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|temp
index|[
name|k
index|]
operator|^=
operator|*
operator|(
name|pbuf_current
operator|+
name|k
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|longsPerEU
condition|;
name|k
operator|++
control|)
name|dest_smaller_current
index|[
name|k
index|]
operator|=
name|temp
index|[
name|k
index|]
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
block|}
comment|/* Check if all Encoding Unit in the data buffer have been decoded, 	 * according EvenOdd theory, if "RF_EO_MATRIX_DIM" is a prime number, 	 * this algorithm will covered all buffer 				 */
name|RF_ASSERT
argument_list|(
name|count
operator|==
name|numRowInEncMatix
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|P
argument_list|,
name|bytesPerEU
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
name|bytesPerEU
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************************************** * 	This function is called by double degragded read * 	EO_200_CreateReadDAG * ***************************************************************************************/
end_comment

begin_function
name|int
name|rf_EvenOddDoubleRecoveryFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|ndataParam
init|=
literal|0
decl_stmt|;
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
init|=
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prm
decl_stmt|,
name|sector
decl_stmt|,
name|nresults
init|=
name|node
operator|->
name|numResults
decl_stmt|;
name|RF_SectorCount_t
name|secPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|unsigned
name|sosAddr
decl_stmt|;
name|int
name|two
init|=
literal|0
decl_stmt|,
name|mallc_one
init|=
literal|0
decl_stmt|,
name|mallc_two
init|=
literal|0
decl_stmt|;
comment|/* flags to indicate if 							 * memory is allocated */
name|int
name|bytesPerSector
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|ppda
decl_stmt|,
modifier|*
name|ppda2
decl_stmt|,
modifier|*
name|epda
decl_stmt|,
modifier|*
name|epda2
decl_stmt|,
modifier|*
name|pda
decl_stmt|,
modifier|*
name|pda0
decl_stmt|,
modifier|*
name|pda1
decl_stmt|,
name|npda
decl_stmt|;
name|RF_RowCol_t
name|fcol
index|[
literal|2
index|]
decl_stmt|,
name|fsuoff
index|[
literal|2
index|]
decl_stmt|,
name|fsuend
index|[
literal|2
index|]
decl_stmt|,
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|char
modifier|*
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ebuf
decl_stmt|,
modifier|*
name|pbuf
decl_stmt|,
modifier|*
name|dest
index|[
literal|2
index|]
decl_stmt|;
name|long
modifier|*
name|suoff
init|=
name|NULL
decl_stmt|,
modifier|*
name|suend
init|=
name|NULL
decl_stmt|,
modifier|*
name|prmToCol
init|=
name|NULL
decl_stmt|,
name|psuoff
decl_stmt|,
name|esuoff
decl_stmt|;
name|RF_SectorNum_t
name|startSector
decl_stmt|,
name|endSector
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* Find out the number of parameters which are pdas for data 	 * information */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|np
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
operator|)
operator|->
name|type
operator|!=
name|RF_PDA_TYPE_DATA
condition|)
block|{
name|ndataParam
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|RF_Malloc
argument_list|(
name|buf
argument_list|,
name|numDataCol
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndataParam
operator|!=
literal|0
condition|)
block|{
name|RF_Malloc
argument_list|(
name|suoff
argument_list|,
name|ndataParam
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
operator|(
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|suend
argument_list|,
name|ndataParam
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
operator|(
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|prmToCol
argument_list|,
name|ndataParam
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
operator|(
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|&&
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|numSector
operator|+
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|numSector
operator|<
name|secPerSU
operator|)
condition|)
block|{
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* currently, no support for this situation */
name|ppda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|6
index|]
operator|.
name|p
expr_stmt|;
name|ppda2
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|5
index|]
operator|.
name|p
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|ppda2
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
argument_list|)
expr_stmt|;
name|epda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|4
index|]
operator|.
name|p
expr_stmt|;
name|epda2
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|3
index|]
operator|.
name|p
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|epda2
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
argument_list|)
expr_stmt|;
name|two
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ppda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|4
index|]
operator|.
name|p
expr_stmt|;
name|epda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|3
index|]
operator|.
name|p
expr_stmt|;
name|psuoff
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|ppda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|esuoff
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|epda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|psuoff
operator|==
name|esuoff
argument_list|)
expr_stmt|;
block|}
comment|/*             the followings have three goals:             1. determine the startSector to begin decoding and endSector to end decoding.             2. determine the colume numbers of the two failed disks.             3. determine the offset and end offset of the access within each failed stripe unit.          */
if|if
condition|(
name|nresults
operator|==
literal|1
condition|)
block|{
comment|/* find the startSector to begin decoding */
name|pda
operator|=
name|node
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|pda
operator|->
name|bufPtr
argument_list|,
name|bytesPerSector
operator|*
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|fsuoff
index|[
literal|0
index|]
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|fsuend
index|[
literal|0
index|]
operator|=
name|fsuoff
index|[
literal|0
index|]
operator|+
name|pda
operator|->
name|numSector
expr_stmt|;
name|startSector
operator|=
name|fsuoff
index|[
literal|0
index|]
expr_stmt|;
name|endSector
operator|=
name|fsuend
index|[
literal|0
index|]
expr_stmt|;
comment|/* find out the column of failed disk being accessed */
name|fcol
index|[
literal|0
index|]
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* find out the other failed colume not accessed */
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
name|npda
operator|.
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|npda
operator|.
name|raidAddress
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|row
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|col
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|npda
operator|.
name|row
index|]
index|[
name|npda
operator|.
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
if|if
condition|(
name|i
operator|!=
name|fcol
index|[
literal|0
index|]
condition|)
break|break;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|<
name|numDataCol
argument_list|)
expr_stmt|;
name|fcol
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|nresults
operator|==
literal|2
argument_list|)
expr_stmt|;
name|pda0
operator|=
name|node
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
name|bzero
argument_list|(
name|pda0
operator|->
name|bufPtr
argument_list|,
name|bytesPerSector
operator|*
name|pda0
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda1
operator|=
name|node
operator|->
name|results
index|[
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
name|pda1
operator|->
name|bufPtr
argument_list|,
name|bytesPerSector
operator|*
name|pda1
operator|->
name|numSector
argument_list|)
expr_stmt|;
comment|/* determine the failed colume numbers of the two failed 		 * disks. */
name|fcol
index|[
literal|0
index|]
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda0
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|fcol
index|[
literal|1
index|]
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda1
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* determine the offset and end offset of the access within 		 * each failed stripe unit. */
name|fsuoff
index|[
literal|0
index|]
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda0
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|fsuend
index|[
literal|0
index|]
operator|=
name|fsuoff
index|[
literal|0
index|]
operator|+
name|pda0
operator|->
name|numSector
expr_stmt|;
name|fsuoff
index|[
literal|1
index|]
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda1
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|fsuend
index|[
literal|1
index|]
operator|=
name|fsuoff
index|[
literal|1
index|]
operator|+
name|pda1
operator|->
name|numSector
expr_stmt|;
comment|/* determine the startSector to begin decoding */
name|startSector
operator|=
name|RF_MIN
argument_list|(
name|pda0
operator|->
name|startSector
argument_list|,
name|pda1
operator|->
name|startSector
argument_list|)
expr_stmt|;
comment|/* determine the endSector to end decoding */
name|endSector
operator|=
name|RF_MAX
argument_list|(
name|fsuend
index|[
literal|0
index|]
argument_list|,
name|fsuend
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	      assign the beginning sector and the end sector for each parameter 	      find out the corresponding colume # for each parameter         */
for|for
control|(
name|prm
operator|=
literal|0
init|;
name|prm
operator|<
name|ndataParam
condition|;
name|prm
operator|++
control|)
block|{
name|pda
operator|=
name|node
operator|->
name|params
index|[
name|prm
index|]
operator|.
name|p
expr_stmt|;
name|suoff
index|[
name|prm
index|]
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|suend
index|[
name|prm
index|]
operator|=
name|suoff
index|[
name|prm
index|]
operator|+
name|pda
operator|->
name|numSector
expr_stmt|;
name|prmToCol
index|[
name|prm
index|]
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
block|}
comment|/* 'sector' is the sector for the current decoding algorithm. For each 	 * sector in the failed SU, find out the corresponding parameters that 	 * cover the current sector and that are needed for decoding of this 	 * sector in failed SU. 2.  Find out if sector is in the shadow of any 	 * accessed failed SU. If not, malloc a temporary space of a sector in 	 * size. */
for|for
control|(
name|sector
operator|=
name|startSector
init|;
name|sector
operator|<
name|endSector
condition|;
name|sector
operator|++
control|)
block|{
if|if
condition|(
name|nresults
operator|==
literal|2
condition|)
if|if
condition|(
operator|!
operator|(
name|fsuoff
index|[
literal|0
index|]
operator|<=
name|sector
operator|&&
name|sector
operator|<
name|fsuend
index|[
literal|0
index|]
operator|)
operator|&&
operator|!
operator|(
name|fsuoff
index|[
literal|1
index|]
operator|<=
name|sector
operator|&&
name|sector
operator|<
name|fsuend
index|[
literal|1
index|]
operator|)
condition|)
continue|continue;
for|for
control|(
name|prm
operator|=
literal|0
init|;
name|prm
operator|<
name|ndataParam
condition|;
name|prm
operator|++
control|)
if|if
condition|(
name|suoff
index|[
name|prm
index|]
operator|<=
name|sector
operator|&&
name|sector
operator|<
name|suend
index|[
name|prm
index|]
condition|)
name|buf
index|[
operator|(
name|prmToCol
index|[
name|prm
index|]
operator|)
index|]
operator|=
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|prm
index|]
operator|.
name|p
operator|)
operator|->
name|bufPtr
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sector
operator|-
name|suoff
index|[
name|prm
index|]
argument_list|)
expr_stmt|;
comment|/* find out if sector is in the shadow of any accessed failed 		 * SU. If yes, assign dest[0], dest[1] to point at suitable 		 * position of the buffer corresponding to failed SUs. if no, 		 * malloc a temporary space of a sector in size for 		 * destination of decoding. */
name|RF_ASSERT
argument_list|(
name|nresults
operator|==
literal|1
operator|||
name|nresults
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nresults
operator|==
literal|1
condition|)
block|{
name|dest
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
operator|)
operator|->
name|bufPtr
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sector
operator|-
name|fsuoff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Always malloc temp buffer to dest[1]  */
name|RF_Malloc
argument_list|(
name|dest
index|[
literal|1
index|]
argument_list|,
name|bytesPerSector
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dest
index|[
literal|1
index|]
argument_list|,
name|bytesPerSector
argument_list|)
expr_stmt|;
name|mallc_two
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fsuoff
index|[
literal|0
index|]
operator|<=
name|sector
operator|&&
name|sector
operator|<
name|fsuend
index|[
literal|0
index|]
condition|)
name|dest
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
operator|)
operator|->
name|bufPtr
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sector
operator|-
name|fsuoff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|RF_Malloc
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|,
name|bytesPerSector
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|,
name|bytesPerSector
argument_list|)
expr_stmt|;
name|mallc_one
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fsuoff
index|[
literal|1
index|]
operator|<=
name|sector
operator|&&
name|sector
operator|<
name|fsuend
index|[
literal|1
index|]
condition|)
name|dest
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|1
index|]
operator|)
operator|->
name|bufPtr
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sector
operator|-
name|fsuoff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|RF_Malloc
argument_list|(
name|dest
index|[
literal|1
index|]
argument_list|,
name|bytesPerSector
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dest
index|[
literal|1
index|]
argument_list|,
name|bytesPerSector
argument_list|)
expr_stmt|;
name|mallc_two
operator|=
literal|1
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|mallc_one
operator|==
literal|0
operator|||
name|mallc_two
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|pbuf
operator|=
name|ppda
operator|->
name|bufPtr
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sector
operator|-
name|psuoff
argument_list|)
expr_stmt|;
name|ebuf
operator|=
name|epda
operator|->
name|bufPtr
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sector
operator|-
name|esuoff
argument_list|)
expr_stmt|;
comment|/* 	         * After finish finding all needed sectors, call doubleEOdecode function for decoding 	         * one sector to destination. 	         */
name|rf_doubleEOdecode
argument_list|(
name|raidPtr
argument_list|,
name|buf
argument_list|,
name|dest
argument_list|,
name|fcol
argument_list|,
name|pbuf
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
comment|/* free all allocated memory, and mark flag to indicate no 		 * memory is being allocated */
if|if
condition|(
name|mallc_one
operator|==
literal|1
condition|)
name|RF_Free
argument_list|(
name|dest
index|[
literal|0
index|]
argument_list|,
name|bytesPerSector
argument_list|)
expr_stmt|;
if|if
condition|(
name|mallc_two
operator|==
literal|1
condition|)
name|RF_Free
argument_list|(
name|dest
index|[
literal|1
index|]
argument_list|,
name|bytesPerSector
argument_list|)
expr_stmt|;
name|mallc_one
operator|=
name|mallc_two
operator|=
literal|0
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|buf
argument_list|,
name|numDataCol
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndataParam
operator|!=
literal|0
condition|)
block|{
name|RF_Free
argument_list|(
name|suoff
argument_list|,
name|ndataParam
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|suend
argument_list|,
name|ndataParam
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|prmToCol
argument_list|,
name|ndataParam
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracerec
condition|)
block|{
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX is this even close!!?!?!!? GO */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* currently, only access of one of the two failed SU is allowed in this function.  * also, asmap->numStripeUnitsAccessed is limited to be one, the RaidFrame will break large access into  * many accesses of single stripe unit.  */
end_comment

begin_function
name|int
name|rf_EOWriteDoubleRecoveryFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
init|=
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_SectorNum_t
name|sector
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|,
name|scol
decl_stmt|;
name|int
name|prm
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RF_SectorCount_t
name|secPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|unsigned
name|sosAddr
decl_stmt|;
name|unsigned
name|bytesPerSector
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RF_int64
name|numbytes
decl_stmt|;
name|RF_SectorNum_t
name|startSector
decl_stmt|,
name|endSector
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|ppda
decl_stmt|,
modifier|*
name|epda
decl_stmt|,
modifier|*
name|pda
decl_stmt|,
modifier|*
name|fpda
decl_stmt|,
name|npda
decl_stmt|;
name|RF_RowCol_t
name|fcol
index|[
literal|2
index|]
decl_stmt|,
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* buf[0], buf[1], buf[2], ...etc. point to 				 * buffer storing data read from col0, col1, 				 * col2 */
name|char
modifier|*
name|ebuf
decl_stmt|,
modifier|*
name|pbuf
decl_stmt|,
modifier|*
name|dest
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|olddata
index|[
literal|2
index|]
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* currently only support this 						 * case, the other failed SU 						 * is not being accessed */
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|buf
argument_list|,
name|numDataCol
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|ppda
operator|=
name|node
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
comment|/* Instead of being buffers, node->results[0] 				 * and [1] are Ppda and Epda  */
name|epda
operator|=
name|node
operator|->
name|results
index|[
literal|1
index|]
expr_stmt|;
name|fpda
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
comment|/* First, recovery the failed old SU using EvenOdd double decoding      */
comment|/* determine the startSector and endSector for decoding */
name|startSector
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|fpda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|endSector
operator|=
name|startSector
operator|+
name|fpda
operator|->
name|numSector
expr_stmt|;
comment|/* Assign buf[col] pointers to point to each non-failed colume  and 	 * initialize the pbuf and ebuf to point at the beginning of each 	 * source buffers and destination buffers */
for|for
control|(
name|prm
operator|=
literal|0
init|;
name|prm
operator|<
name|numDataCol
operator|-
literal|2
condition|;
name|prm
operator|++
control|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|prm
index|]
operator|.
name|p
expr_stmt|;
name|col
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|buf
index|[
name|col
index|]
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
block|}
comment|/* pbuf and ebuf:  they will change values as double recovery decoding 	 * goes on */
name|pbuf
operator|=
name|ppda
operator|->
name|bufPtr
expr_stmt|;
name|ebuf
operator|=
name|epda
operator|->
name|bufPtr
expr_stmt|;
comment|/* find out the logical colume numbers in the encoding matrix of the 	 * two failed columes */
name|fcol
index|[
literal|0
index|]
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|fpda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* find out the other failed colume not accessed this time */
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
name|npda
operator|.
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|npda
operator|.
name|raidAddress
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|row
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|col
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|npda
operator|.
name|row
index|]
index|[
name|npda
operator|.
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
if|if
condition|(
name|i
operator|!=
name|fcol
index|[
literal|0
index|]
condition|)
break|break;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|<
name|numDataCol
argument_list|)
expr_stmt|;
name|fcol
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
comment|/* assign temporary space to put recovered failed SU */
name|numbytes
operator|=
name|fpda
operator|->
name|numSector
operator|*
name|bytesPerSector
expr_stmt|;
name|RF_Malloc
argument_list|(
name|olddata
index|[
literal|0
index|]
argument_list|,
name|numbytes
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|olddata
index|[
literal|1
index|]
argument_list|,
name|numbytes
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
name|olddata
index|[
literal|0
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
name|olddata
index|[
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
name|olddata
index|[
literal|0
index|]
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|olddata
index|[
literal|1
index|]
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
comment|/* Begin the recovery decoding, initially buf[j],  ebuf, pbuf, dest[j] 	 * have already pointed at the beginning of each source buffers and 	 * destination buffers */
for|for
control|(
name|sector
operator|=
name|startSector
operator|,
name|i
operator|=
literal|0
init|;
name|sector
operator|<
name|endSector
condition|;
name|sector
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|rf_doubleEOdecode
argument_list|(
name|raidPtr
argument_list|,
name|buf
argument_list|,
name|dest
argument_list|,
name|fcol
argument_list|,
name|pbuf
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numDataCol
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|j
operator|!=
name|fcol
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|j
operator|!=
name|fcol
index|[
literal|1
index|]
operator|)
condition|)
name|buf
index|[
name|j
index|]
operator|+=
name|bytesPerSector
expr_stmt|;
name|dest
index|[
literal|0
index|]
operator|+=
name|bytesPerSector
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|+=
name|bytesPerSector
expr_stmt|;
name|ebuf
operator|+=
name|bytesPerSector
expr_stmt|;
name|pbuf
operator|+=
name|bytesPerSector
expr_stmt|;
block|}
comment|/* after recovery, the buffer pointed by olddata[0] is the old failed 	 * data. With new writing data and this old data, use small write to 	 * calculate the new redundant informations */
comment|/* node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of 	 * Rrd; params[ PDAPerDisk*(numDataCol - 2), ... PDAPerDisk*numDataCol 	 * -1 ] are Pdas of Rp, ( Rp2 ), Re, ( Re2 ) ; params[ 	 * PDAPerDisk*numDataCol, ... PDAPerDisk*numDataCol 	 * +asmap->numStripeUnitsAccessed -asmap->numDataFailed-1] are Pdas of 	 * wudNodes; For current implementation, we assume the simplest case: 	 * asmap->numStripeUnitsAccessed == 1 and asmap->numDataFailed == 1 	 * ie. PDAPerDisk = 1 then node->params[numDataCol] must be the new 	 * data to be writen to the failed disk. We first bxor the new data 	 * into the old recovered data, then do the same things as small 	 * write. */
name|rf_bxor
argument_list|(
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|numDataCol
index|]
operator|.
name|p
operator|)
operator|->
name|bufPtr
argument_list|,
name|olddata
index|[
literal|0
index|]
argument_list|,
name|numbytes
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* do new 'E' calculation  */
comment|/* find out the corresponding colume in encoding matrix for write 	 * colume to be encoded into redundant disk 'E' */
name|scol
operator|=
name|rf_EUCol
argument_list|(
name|layoutPtr
argument_list|,
name|fpda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* olddata[0] now is source buffer pointer; epda->bufPtr is the dest 	 * buffer pointer               */
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|scol
argument_list|,
name|olddata
index|[
literal|0
index|]
argument_list|,
name|RF_EO_MATRIX_DIM
operator|-
literal|2
argument_list|,
name|epda
operator|->
name|bufPtr
argument_list|,
name|fpda
operator|->
name|numSector
argument_list|)
expr_stmt|;
comment|/* do new 'P' calculation  */
name|rf_bxor
argument_list|(
name|olddata
index|[
literal|0
index|]
argument_list|,
name|ppda
operator|->
name|bufPtr
argument_list|,
name|numbytes
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* Free the allocated buffer  */
name|RF_Free
argument_list|(
name|olddata
index|[
literal|0
index|]
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|olddata
index|[
literal|1
index|]
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|buf
argument_list|,
name|numDataCol
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracerec
condition|)
block|{
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_EVENODD> 0 */
end_comment

end_unit

