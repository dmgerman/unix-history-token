begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_stripelocks.c,v 1.6 2000/12/04 11:35:46 fvdl Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Mark Holland, Jim Zelenka  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * stripelocks.c -- code to lock stripes for read and write access  *  * The code distinguishes between read locks and write locks. There can be  * as many readers to given stripe as desired. When a write request comes  * in, no further readers are allowed to enter, and all subsequent requests  * are queued in FIFO order. When a the number of readers goes to zero, the  * writer is given the lock. When a writer releases the lock, the list of  * queued requests is scanned, and all readersq up to the next writer are  * given the lock.  *  * The lock table size must be one less than a power of two, but HASH_STRIPEID  * is the only function that requires this.  *  * The code now supports "range locks". When you ask to lock a stripe, you  * specify a range of addresses in that stripe that you want to lock. When  * you acquire the lock, you've locked only this range of addresses, and  * other threads can concurrently read/write any non-overlapping portions  * of the stripe. The "addresses" that you lock are abstract in that you  * can pass in anything you like.  The expectation is that you'll pass in  * the range of physical disk offsets of the parity bits you're planning  * to update. The idea behind this, of course, is to allow sub-stripe  * locking. The implementation is perhaps not the best imaginable; in the  * worst case a lock release is O(n^2) in the total number of outstanding  * requests to a given stripe.  Note that if you're striping with a  * stripe unit size equal to an entire disk (i.e. not striping), there will  * be only one stripe and you may spend some significant number of cycles  * searching through stripe lock descriptors.  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_stripelocks.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_freelist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugprint.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_define
define|#
directive|define
name|Dprintf1
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf2
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf3
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf4
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf5
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf6
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf7
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf8
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|)
value|rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),(void *)((unsigned long)h))
end_define

begin_define
define|#
directive|define
name|FLUSH
end_define

begin_define
define|#
directive|define
name|HASH_STRIPEID
parameter_list|(
name|_sid_
parameter_list|)
value|( (_sid_)& (rf_lockTableSize-1) )
end_define

begin_function_decl
specifier|static
name|void
name|AddToWaitersQueue
parameter_list|(
name|RF_LockTableEntry_t
modifier|*
name|lockTable
parameter_list|,
name|RF_StripeLockDesc_t
modifier|*
name|lockDesc
parameter_list|,
name|RF_LockReqDesc_t
modifier|*
name|lockReqDesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RF_StripeLockDesc_t
modifier|*
name|AllocStripeLockDesc
parameter_list|(
name|RF_StripeNum_t
name|stripeID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FreeStripeLockDesc
parameter_list|(
name|RF_StripeLockDesc_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PrintLockedStripes
parameter_list|(
name|RF_LockTableEntry_t
modifier|*
name|lockTable
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* determines if two ranges overlap.  always yields false if either start value is negative  */
end_comment

begin_define
define|#
directive|define
name|SINGLE_RANGE_OVERLAP
parameter_list|(
name|_strt1
parameter_list|,
name|_stop1
parameter_list|,
name|_strt2
parameter_list|,
name|_stop2
parameter_list|)
define|\
value|( (_strt1>= 0)&& (_strt2>= 0)&& (RF_MAX(_strt1, _strt2)<= RF_MIN(_stop1, _stop2)) )
end_define

begin_comment
comment|/* determines if any of the ranges specified in the two lock descriptors overlap each other */
end_comment

begin_define
define|#
directive|define
name|RANGE_OVERLAP
parameter_list|(
name|_cand
parameter_list|,
name|_pred
parameter_list|)
define|\
value|( SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,  (_pred)->start,  (_pred)->stop ) ||    \     SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2, (_pred)->start,  (_pred)->stop ) ||    \     SINGLE_RANGE_OVERLAP((_cand)->start,  (_cand)->stop,  (_pred)->start2, (_pred)->stop2) ||    \     SINGLE_RANGE_OVERLAP((_cand)->start2, (_cand)->stop2, (_pred)->start2, (_pred)->stop2) )
end_define

begin_comment
comment|/* Determines if a candidate lock request conflicts with a predecessor lock req.  * Note that the arguments are not interchangeable.  * The rules are:  *      a candidate read conflicts with a predecessor write if any ranges overlap  *      a candidate write conflicts with a predecessor read if any ranges overlap  *      a candidate write conflicts with a predecessor write if any ranges overlap  */
end_comment

begin_define
define|#
directive|define
name|STRIPELOCK_CONFLICT
parameter_list|(
name|_cand
parameter_list|,
name|_pred
parameter_list|)
define|\
value|RANGE_OVERLAP((_cand), (_pred))&&                                        \   ( ( (((_cand)->type == RF_IO_TYPE_READ)&& ((_pred)->type == RF_IO_TYPE_WRITE)) ||                      \       (((_cand)->type == RF_IO_TYPE_WRITE)&& ((_pred)->type == RF_IO_TYPE_READ)) ||                      \       (((_cand)->type == RF_IO_TYPE_WRITE)&& ((_pred)->type == RF_IO_TYPE_WRITE))                         \     )                                                                            \   )
end_define

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_stripelock_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_STRIPELOCK
value|128
end_define

begin_define
define|#
directive|define
name|RF_STRIPELOCK_INC
value|8
end_define

begin_define
define|#
directive|define
name|RF_STRIPELOCK_INITIAL
value|32
end_define

begin_function_decl
specifier|static
name|void
name|rf_ShutdownStripeLockFreeList
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_RaidShutdownStripeLocks
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownStripeLockFreeList
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_stripelock_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_StripeLockDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureStripeLockFreeList
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|unsigned
name|mask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_stripelock_freelist
argument_list|,
name|RF_MAX_FREE_STRIPELOCK
argument_list|,
name|RF_STRIPELOCK_INITIAL
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_StripeLockDesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownStripeLockFreeList
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownStripeLockFreeList
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|RF_FREELIST_PRIME
argument_list|(
name|rf_stripelock_freelist
argument_list|,
name|RF_STRIPELOCK_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_StripeLockDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mask
operator|=
literal|0x1
init|;
name|mask
condition|;
name|mask
operator|<<=
literal|1
control|)
if|if
condition|(
name|rf_lockTableSize
operator|==
name|mask
condition|)
break|break;
if|if
condition|(
operator|!
name|mask
condition|)
block|{
name|printf
argument_list|(
literal|"[WARNING:  lock table size must be a power of two.  Setting to %d.]\n"
argument_list|,
name|RF_DEFAULT_LOCK_TABLE_SIZE
argument_list|)
expr_stmt|;
name|rf_lockTableSize
operator|=
name|RF_DEFAULT_LOCK_TABLE_SIZE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_LockTableEntry_t
modifier|*
name|rf_MakeLockTable
parameter_list|()
block|{
name|RF_LockTableEntry_t
modifier|*
name|lockTable
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|RF_Calloc
argument_list|(
name|lockTable
argument_list|,
operator|(
operator|(
name|int
operator|)
name|rf_lockTableSize
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_LockTableEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_LockTableEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rf_lockTableSize
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|lockTable
index|[
name|i
index|]
operator|.
name|mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* XXX clean up other mutexes */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|lockTable
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_ShutdownStripeLocks
parameter_list|(
name|RF_LockTableEntry_t
modifier|*
name|lockTable
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|PrintLockedStripes
argument_list|(
name|lockTable
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rf_lockTableSize
condition|;
name|i
operator|++
control|)
block|{
name|rf_mutex_destroy
argument_list|(
operator|&
name|lockTable
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|lockTable
argument_list|,
name|rf_lockTableSize
operator|*
sizeof|sizeof
argument_list|(
name|RF_LockTableEntry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_RaidShutdownStripeLocks
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|arg
decl_stmt|;
name|rf_ShutdownStripeLocks
argument_list|(
name|raidPtr
operator|->
name|lockTable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureStripeLocks
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|raidPtr
operator|->
name|lockTable
operator|=
name|rf_MakeLockTable
argument_list|()
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|lockTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_RaidShutdownStripeLocks
argument_list|,
name|raidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownStripeLocks
argument_list|(
name|raidPtr
operator|->
name|lockTable
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns 0 if you've got the lock, and non-zero if you have to wait.  * if and only if you have to wait, we'll cause cbFunc to get invoked  * with cbArg when you are granted the lock.  We store a tag in *releaseTag  * that you need to give back to us when you release the lock.  */
end_comment

begin_function
name|int
name|rf_AcquireStripeLock
parameter_list|(
name|RF_LockTableEntry_t
modifier|*
name|lockTable
parameter_list|,
name|RF_StripeNum_t
name|stripeID
parameter_list|,
name|RF_LockReqDesc_t
modifier|*
name|lockReqDesc
parameter_list|)
block|{
name|RF_StripeLockDesc_t
modifier|*
name|lockDesc
decl_stmt|;
name|RF_LockReqDesc_t
modifier|*
name|p
decl_stmt|;
name|int
name|tid
init|=
literal|0
decl_stmt|,
name|hashval
init|=
name|HASH_STRIPEID
argument_list|(
name|stripeID
argument_list|)
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|lockReqDesc
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
if|if
condition|(
name|stripeID
operator|==
operator|-
literal|1
condition|)
name|Dprintf1
argument_list|(
literal|"[%d] Lock acquisition supressed (stripeID == -1)\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
block|{
name|Dprintf8
argument_list|(
literal|"[%d] Trying to acquire stripe lock table 0x%lx SID %ld type %c range %ld-%ld, range2 %ld-%ld hashval %d\n"
argument_list|,
name|tid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|,
name|stripeID
argument_list|,
name|lockReqDesc
operator|->
name|type
argument_list|,
name|lockReqDesc
operator|->
name|start
argument_list|,
name|lockReqDesc
operator|->
name|stop
argument_list|,
name|lockReqDesc
operator|->
name|start2
argument_list|,
name|lockReqDesc
operator|->
name|stop2
argument_list|)
expr_stmt|;
name|Dprintf3
argument_list|(
literal|"[%d] lock %ld hashval %d\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stripeID
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lockReqDesc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* just to be sure */
name|RF_LOCK_MUTEX
argument_list|(
name|lockTable
index|[
name|hashval
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|lockDesc
operator|=
name|lockTable
index|[
name|hashval
index|]
operator|.
name|descList
init|;
name|lockDesc
condition|;
name|lockDesc
operator|=
name|lockDesc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lockDesc
operator|->
name|stripeID
operator|==
name|stripeID
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|lockDesc
condition|)
block|{
comment|/* no entry in table => no one reading or 				 * writing */
name|lockDesc
operator|=
name|AllocStripeLockDesc
argument_list|(
name|stripeID
argument_list|)
expr_stmt|;
name|lockDesc
operator|->
name|next
operator|=
name|lockTable
index|[
name|hashval
index|]
operator|.
name|descList
expr_stmt|;
name|lockTable
index|[
name|hashval
index|]
operator|.
name|descList
operator|=
name|lockDesc
expr_stmt|;
if|if
condition|(
name|lockReqDesc
operator|->
name|type
operator|==
name|RF_IO_TYPE_WRITE
condition|)
name|lockDesc
operator|->
name|nWriters
operator|++
expr_stmt|;
name|lockDesc
operator|->
name|granted
operator|=
name|lockReqDesc
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf7
argument_list|(
literal|"[%d] no one waiting: lock %ld %c %ld-%ld %ld-%ld granted\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|lockReqDesc
operator|->
name|type
argument_list|,
name|lockReqDesc
operator|->
name|start
argument_list|,
name|lockReqDesc
operator|->
name|stop
argument_list|,
name|lockReqDesc
operator|->
name|start2
argument_list|,
name|lockReqDesc
operator|->
name|stop2
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lockReqDesc
operator|->
name|type
operator|==
name|RF_IO_TYPE_WRITE
condition|)
name|lockDesc
operator|->
name|nWriters
operator|++
expr_stmt|;
if|if
condition|(
name|lockDesc
operator|->
name|nWriters
operator|==
literal|0
condition|)
block|{
comment|/* no need to search any lists 						 * if there are no writers 						 * anywhere */
name|lockReqDesc
operator|->
name|next
operator|=
name|lockDesc
operator|->
name|granted
expr_stmt|;
name|lockDesc
operator|->
name|granted
operator|=
name|lockReqDesc
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf7
argument_list|(
literal|"[%d] no writers: lock %ld %c %ld-%ld %ld-%ld granted\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|lockReqDesc
operator|->
name|type
argument_list|,
name|lockReqDesc
operator|->
name|start
argument_list|,
name|lockReqDesc
operator|->
name|stop
argument_list|,
name|lockReqDesc
operator|->
name|start2
argument_list|,
name|lockReqDesc
operator|->
name|stop2
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* search the granted& waiting lists for a conflict. 			 * stop searching as soon as we find one */
name|retcode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lockDesc
operator|->
name|granted
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|STRIPELOCK_CONFLICT
argument_list|(
name|lockReqDesc
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|retcode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|retcode
condition|)
for|for
control|(
name|p
operator|=
name|lockDesc
operator|->
name|waitersH
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|STRIPELOCK_CONFLICT
argument_list|(
name|lockReqDesc
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|retcode
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|retcode
condition|)
block|{
name|lockReqDesc
operator|->
name|next
operator|=
name|lockDesc
operator|->
name|granted
expr_stmt|;
comment|/* no conflicts found => 									 * grant lock */
name|lockDesc
operator|->
name|granted
operator|=
name|lockReqDesc
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf7
argument_list|(
literal|"[%d] no conflicts: lock %ld %c %ld-%ld %ld-%ld granted\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|lockReqDesc
operator|->
name|type
argument_list|,
name|lockReqDesc
operator|->
name|start
argument_list|,
name|lockReqDesc
operator|->
name|stop
argument_list|,
name|lockReqDesc
operator|->
name|start2
argument_list|,
name|lockReqDesc
operator|->
name|stop2
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf6
argument_list|(
literal|"[%d] conflict: lock %ld %c %ld-%ld hashval=%d not granted\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|lockReqDesc
operator|->
name|type
argument_list|,
name|lockReqDesc
operator|->
name|start
argument_list|,
name|lockReqDesc
operator|->
name|stop
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
name|Dprintf3
argument_list|(
literal|"[%d] lock %ld retcode=%d\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
name|AddToWaitersQueue
argument_list|(
name|lockTable
argument_list|,
name|lockDesc
argument_list|,
name|lockReqDesc
argument_list|)
expr_stmt|;
comment|/* conflict => the 											 * current access must 											 * wait */
block|}
block|}
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|lockTable
index|[
name|hashval
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_ReleaseStripeLock
parameter_list|(
name|RF_LockTableEntry_t
modifier|*
name|lockTable
parameter_list|,
name|RF_StripeNum_t
name|stripeID
parameter_list|,
name|RF_LockReqDesc_t
modifier|*
name|lockReqDesc
parameter_list|)
block|{
name|RF_StripeLockDesc_t
modifier|*
name|lockDesc
decl_stmt|,
modifier|*
name|ld_t
decl_stmt|;
name|RF_LockReqDesc_t
modifier|*
name|lr
decl_stmt|,
modifier|*
name|lr_t
decl_stmt|,
modifier|*
name|callbacklist
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|RF_IoType_t
name|type
init|=
name|lockReqDesc
operator|->
name|type
decl_stmt|;
name|int
name|tid
init|=
literal|0
decl_stmt|,
name|hashval
init|=
name|HASH_STRIPEID
argument_list|(
name|stripeID
argument_list|)
decl_stmt|;
name|int
name|release_it
decl_stmt|,
name|consider_it
decl_stmt|;
name|RF_LockReqDesc_t
modifier|*
name|candidate
decl_stmt|,
modifier|*
name|candidate_t
decl_stmt|,
modifier|*
name|predecessor
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
if|if
condition|(
name|stripeID
operator|==
operator|-
literal|1
condition|)
name|Dprintf1
argument_list|(
literal|"[%d] Lock release supressed (stripeID == -1)\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
block|{
name|Dprintf8
argument_list|(
literal|"[%d] Releasing stripe lock on stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|lockReqDesc
operator|->
name|type
argument_list|,
name|lockReqDesc
operator|->
name|start
argument_list|,
name|lockReqDesc
operator|->
name|stop
argument_list|,
name|lockReqDesc
operator|->
name|start2
argument_list|,
name|lockReqDesc
operator|->
name|stop2
argument_list|,
name|lockTable
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stripeID
operator|==
operator|-
literal|1
condition|)
return|return;
name|RF_LOCK_MUTEX
argument_list|(
name|lockTable
index|[
name|hashval
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* find the stripe lock descriptor */
for|for
control|(
name|ld_t
operator|=
name|NULL
operator|,
name|lockDesc
operator|=
name|lockTable
index|[
name|hashval
index|]
operator|.
name|descList
init|;
name|lockDesc
condition|;
name|ld_t
operator|=
name|lockDesc
operator|,
name|lockDesc
operator|=
name|lockDesc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lockDesc
operator|->
name|stripeID
operator|==
name|stripeID
condition|)
break|break;
block|}
name|RF_ASSERT
argument_list|(
name|lockDesc
argument_list|)
expr_stmt|;
comment|/* major error to release a lock that doesn't 				 * exist */
comment|/* find the stripe lock request descriptor& delete it from the list */
for|for
control|(
name|lr_t
operator|=
name|NULL
operator|,
name|lr
operator|=
name|lockDesc
operator|->
name|granted
init|;
name|lr
condition|;
name|lr_t
operator|=
name|lr
operator|,
name|lr
operator|=
name|lr
operator|->
name|next
control|)
if|if
condition|(
name|lr
operator|==
name|lockReqDesc
condition|)
break|break;
name|RF_ASSERT
argument_list|(
name|lr
operator|&&
operator|(
name|lr
operator|==
name|lockReqDesc
operator|)
argument_list|)
expr_stmt|;
comment|/* major error to release a 						 * lock that hasn't been 						 * granted */
if|if
condition|(
name|lr_t
condition|)
name|lr_t
operator|->
name|next
operator|=
name|lr
operator|->
name|next
expr_stmt|;
else|else
block|{
name|RF_ASSERT
argument_list|(
name|lr
operator|==
name|lockDesc
operator|->
name|granted
argument_list|)
expr_stmt|;
name|lockDesc
operator|->
name|granted
operator|=
name|lr
operator|->
name|next
expr_stmt|;
block|}
name|lr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lockReqDesc
operator|->
name|type
operator|==
name|RF_IO_TYPE_WRITE
condition|)
name|lockDesc
operator|->
name|nWriters
operator|--
expr_stmt|;
comment|/* search through the waiters list to see if anyone needs to be woken 	 * up. for each such descriptor in the wait list, we check it against 	 * everything granted and against everything _in front_ of it in the 	 * waiters queue.  If it conflicts with none of these, we release it. 	 *  	 * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST HERE. 	 * This will roach the case where the callback tries to acquire a new 	 * lock in the same stripe.  There are some asserts to try and detect 	 * this. 	 *  	 * We apply 2 performance optimizations: (1) if releasing this lock 	 * results in no more writers to this stripe, we just release 	 * everybody waiting, since we place no restrictions on the number of 	 * concurrent reads. (2) we consider as candidates for wakeup only 	 * those waiters that have a range overlap with either the descriptor 	 * being woken up or with something in the callbacklist (i.e. 	 * something we've just now woken up). This allows us to avoid the 	 * long evaluation for some descriptors. */
name|callbacklist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lockDesc
operator|->
name|nWriters
operator|==
literal|0
condition|)
block|{
comment|/* performance tweak (1) */
while|while
condition|(
name|lockDesc
operator|->
name|waitersH
condition|)
block|{
name|lr
operator|=
name|lockDesc
operator|->
name|waitersH
expr_stmt|;
comment|/* delete from waiters 							 * list */
name|lockDesc
operator|->
name|waitersH
operator|=
name|lr
operator|->
name|next
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|lr
operator|->
name|type
operator|==
name|RF_IO_TYPE_READ
argument_list|)
expr_stmt|;
name|lr
operator|->
name|next
operator|=
name|lockDesc
operator|->
name|granted
expr_stmt|;
comment|/* add to granted list */
name|lockDesc
operator|->
name|granted
operator|=
name|lr
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
name|lr
operator|->
name|templink
argument_list|)
expr_stmt|;
name|lr
operator|->
name|templink
operator|=
name|callbacklist
expr_stmt|;
comment|/* put on callback list 							 * so that we'll invoke 							 * callback below */
name|callbacklist
operator|=
name|lr
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf8
argument_list|(
literal|"[%d] No writers: granting lock stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|lr
operator|->
name|type
argument_list|,
name|lr
operator|->
name|start
argument_list|,
name|lr
operator|->
name|stop
argument_list|,
name|lr
operator|->
name|start2
argument_list|,
name|lr
operator|->
name|stop2
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
block|}
name|lockDesc
operator|->
name|waitersT
operator|=
name|NULL
expr_stmt|;
comment|/* we've purged the whole 						 * waiters list */
block|}
else|else
for|for
control|(
name|candidate_t
operator|=
name|NULL
operator|,
name|candidate
operator|=
name|lockDesc
operator|->
name|waitersH
init|;
name|candidate
condition|;
control|)
block|{
comment|/* performance tweak (2) */
name|consider_it
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|RANGE_OVERLAP
argument_list|(
name|lockReqDesc
argument_list|,
name|candidate
argument_list|)
condition|)
name|consider_it
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|t
operator|=
name|callbacklist
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|templink
control|)
if|if
condition|(
name|RANGE_OVERLAP
argument_list|(
name|t
argument_list|,
name|candidate
argument_list|)
condition|)
block|{
name|consider_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|consider_it
condition|)
block|{
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf8
argument_list|(
literal|"[%d] No overlap: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|candidate
operator|->
name|type
argument_list|,
name|candidate
operator|->
name|start
argument_list|,
name|candidate
operator|->
name|stop
argument_list|,
name|candidate
operator|->
name|start2
argument_list|,
name|candidate
operator|->
name|stop2
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
name|candidate_t
operator|=
name|candidate
expr_stmt|;
name|candidate
operator|=
name|candidate
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* we have a candidate for release.  check to make 			 * sure it is not blocked by any granted locks */
name|release_it
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|predecessor
operator|=
name|lockDesc
operator|->
name|granted
init|;
name|predecessor
condition|;
name|predecessor
operator|=
name|predecessor
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STRIPELOCK_CONFLICT
argument_list|(
name|candidate
argument_list|,
name|predecessor
argument_list|)
condition|)
block|{
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf8
argument_list|(
literal|"[%d] Conflicts with granted lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|candidate
operator|->
name|type
argument_list|,
name|candidate
operator|->
name|start
argument_list|,
name|candidate
operator|->
name|stop
argument_list|,
name|candidate
operator|->
name|start2
argument_list|,
name|candidate
operator|->
name|stop2
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
name|release_it
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* now check to see if the candidate is blocked by any 			 * waiters that occur before it it the wait queue */
if|if
condition|(
name|release_it
condition|)
for|for
control|(
name|predecessor
operator|=
name|lockDesc
operator|->
name|waitersH
init|;
name|predecessor
operator|!=
name|candidate
condition|;
name|predecessor
operator|=
name|predecessor
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STRIPELOCK_CONFLICT
argument_list|(
name|candidate
argument_list|,
name|predecessor
argument_list|)
condition|)
block|{
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf8
argument_list|(
literal|"[%d] Conflicts with waiting lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|candidate
operator|->
name|type
argument_list|,
name|candidate
operator|->
name|start
argument_list|,
name|candidate
operator|->
name|stop
argument_list|,
name|candidate
operator|->
name|start2
argument_list|,
name|candidate
operator|->
name|stop2
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
name|release_it
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* release it if indicated */
if|if
condition|(
name|release_it
condition|)
block|{
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf8
argument_list|(
literal|"[%d] Granting lock to candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\n"
argument_list|,
name|tid
argument_list|,
name|stripeID
argument_list|,
name|candidate
operator|->
name|type
argument_list|,
name|candidate
operator|->
name|start
argument_list|,
name|candidate
operator|->
name|stop
argument_list|,
name|candidate
operator|->
name|start2
argument_list|,
name|candidate
operator|->
name|stop2
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
if|if
condition|(
name|candidate_t
condition|)
block|{
name|candidate_t
operator|->
name|next
operator|=
name|candidate
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lockDesc
operator|->
name|waitersT
operator|==
name|candidate
condition|)
name|lockDesc
operator|->
name|waitersT
operator|=
name|candidate_t
expr_stmt|;
comment|/* cannot be waitersH 											 * since candidate_t is 											 * not NULL */
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|candidate
operator|==
name|lockDesc
operator|->
name|waitersH
argument_list|)
expr_stmt|;
name|lockDesc
operator|->
name|waitersH
operator|=
name|lockDesc
operator|->
name|waitersH
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|lockDesc
operator|->
name|waitersH
condition|)
name|lockDesc
operator|->
name|waitersT
operator|=
name|NULL
expr_stmt|;
block|}
name|candidate
operator|->
name|next
operator|=
name|lockDesc
operator|->
name|granted
expr_stmt|;
comment|/* move it to the 									 * granted list */
name|lockDesc
operator|->
name|granted
operator|=
name|candidate
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
name|candidate
operator|->
name|templink
argument_list|)
expr_stmt|;
name|candidate
operator|->
name|templink
operator|=
name|callbacklist
expr_stmt|;
comment|/* put it on the list of 									 * things to be called 									 * after we release the 									 * mutex */
name|callbacklist
operator|=
name|candidate
expr_stmt|;
if|if
condition|(
operator|!
name|candidate_t
condition|)
name|candidate
operator|=
name|lockDesc
operator|->
name|waitersH
expr_stmt|;
else|else
name|candidate
operator|=
name|candidate_t
operator|->
name|next
expr_stmt|;
comment|/* continue with the 									 * rest of the list */
block|}
else|else
block|{
name|candidate_t
operator|=
name|candidate
expr_stmt|;
name|candidate
operator|=
name|candidate
operator|->
name|next
expr_stmt|;
comment|/* continue with the 								 * rest of the list */
block|}
block|}
comment|/* delete the descriptor if no one is waiting or active */
if|if
condition|(
operator|!
name|lockDesc
operator|->
name|granted
operator|&&
operator|!
name|lockDesc
operator|->
name|waitersH
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|lockDesc
operator|->
name|nWriters
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_stripeLockDebug
condition|)
block|{
name|Dprintf3
argument_list|(
literal|"[%d] Last lock released (table 0x%lx): deleting desc for stripeID %ld\n"
argument_list|,
name|tid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lockTable
argument_list|,
name|stripeID
argument_list|)
expr_stmt|;
name|FLUSH
expr_stmt|;
block|}
if|if
condition|(
name|ld_t
condition|)
name|ld_t
operator|->
name|next
operator|=
name|lockDesc
operator|->
name|next
expr_stmt|;
else|else
block|{
name|RF_ASSERT
argument_list|(
name|lockDesc
operator|==
name|lockTable
index|[
name|hashval
index|]
operator|.
name|descList
argument_list|)
expr_stmt|;
name|lockTable
index|[
name|hashval
index|]
operator|.
name|descList
operator|=
name|lockDesc
operator|->
name|next
expr_stmt|;
block|}
name|FreeStripeLockDesc
argument_list|(
name|lockDesc
argument_list|)
expr_stmt|;
name|lockDesc
operator|=
name|NULL
expr_stmt|;
comment|/* only for the ASSERT below */
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|lockTable
index|[
name|hashval
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* now that we've unlocked the mutex, invoke the callback on all the 	 * descriptors in the list */
name|RF_ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|callbacklist
operator|)
operator|&&
operator|(
operator|!
name|lockDesc
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* if we deleted the 							 * descriptor, we should 							 * have no callbacks to 							 * do */
for|for
control|(
name|candidate
operator|=
name|callbacklist
init|;
name|candidate
condition|;
control|)
block|{
name|t
operator|=
name|candidate
expr_stmt|;
name|candidate
operator|=
name|candidate
operator|->
name|templink
expr_stmt|;
name|t
operator|->
name|templink
operator|=
name|NULL
expr_stmt|;
call|(
name|t
operator|->
name|cbFunc
call|)
argument_list|(
name|t
operator|->
name|cbArg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* must have the indicated lock table mutex upon entry */
end_comment

begin_function
specifier|static
name|void
name|AddToWaitersQueue
parameter_list|(
name|RF_LockTableEntry_t
modifier|*
name|lockTable
parameter_list|,
name|RF_StripeLockDesc_t
modifier|*
name|lockDesc
parameter_list|,
name|RF_LockReqDesc_t
modifier|*
name|lockReqDesc
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* XXX fvdl -- unitialized use of 'tid' */
block|int     tid;  	if (rf_stripeLockDebug) { 		Dprintf3("[%d] Waiting on lock for stripe %ld table 0x%lx\n", tid, lockDesc->stripeID, (unsigned long) lockTable); 		FLUSH; 	}
endif|#
directive|endif
if|if
condition|(
operator|!
name|lockDesc
operator|->
name|waitersH
condition|)
block|{
name|lockDesc
operator|->
name|waitersH
operator|=
name|lockDesc
operator|->
name|waitersT
operator|=
name|lockReqDesc
expr_stmt|;
block|}
else|else
block|{
name|lockDesc
operator|->
name|waitersT
operator|->
name|next
operator|=
name|lockReqDesc
expr_stmt|;
name|lockDesc
operator|->
name|waitersT
operator|=
name|lockReqDesc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|RF_StripeLockDesc_t
modifier|*
name|AllocStripeLockDesc
parameter_list|(
name|RF_StripeNum_t
name|stripeID
parameter_list|)
block|{
name|RF_StripeLockDesc_t
modifier|*
name|p
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_stripelock_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_StripeLockDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|stripeID
operator|=
name|stripeID
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeStripeLockDesc
parameter_list|(
name|RF_StripeLockDesc_t
modifier|*
name|p
parameter_list|)
block|{
name|RF_FREELIST_FREE
argument_list|(
name|rf_stripelock_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PrintLockedStripes
parameter_list|(
name|lockTable
parameter_list|)
name|RF_LockTableEntry_t
modifier|*
name|lockTable
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|foundone
init|=
literal|0
decl_stmt|,
name|did
decl_stmt|;
name|RF_StripeLockDesc_t
modifier|*
name|p
decl_stmt|;
name|RF_LockReqDesc_t
modifier|*
name|q
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|rf_printf_mutex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Locked stripes:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rf_lockTableSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lockTable
index|[
name|i
index|]
operator|.
name|descList
condition|)
block|{
name|foundone
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lockTable
index|[
name|i
index|]
operator|.
name|descList
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"Stripe ID 0x%lx (%d) nWriters %d\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|stripeID
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|stripeID
argument_list|,
name|p
operator|->
name|nWriters
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|granted
operator|)
condition|)
name|printf
argument_list|(
literal|"Granted: (none)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Granted:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|did
operator|=
literal|1
operator|,
name|j
operator|=
literal|0
operator|,
name|q
operator|=
name|p
operator|->
name|granted
init|;
name|q
condition|;
name|j
operator|++
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"  %c(%ld-%ld"
argument_list|,
name|q
operator|->
name|type
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|start
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|start2
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|",%ld-%ld) "
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|start2
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|stop2
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&&
operator|!
operator|(
name|j
operator|%
literal|4
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|did
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|did
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|did
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|waitersH
operator|)
condition|)
name|printf
argument_list|(
literal|"Waiting: (none)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Waiting:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|did
operator|=
literal|1
operator|,
name|j
operator|=
literal|0
operator|,
name|q
operator|=
name|p
operator|->
name|waitersH
init|;
name|q
condition|;
name|j
operator|++
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"%c(%ld-%ld"
argument_list|,
name|q
operator|->
name|type
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|start
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|start2
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|",%ld-%ld) "
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|start2
argument_list|,
operator|(
name|long
operator|)
name|q
operator|->
name|stop2
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&&
operator|!
operator|(
name|j
operator|%
literal|4
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n         "
argument_list|)
expr_stmt|;
name|did
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|did
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|did
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|foundone
condition|)
name|printf
argument_list|(
literal|"(none)\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|rf_printf_mutex
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

