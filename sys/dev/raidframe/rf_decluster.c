begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_decluster.c,v 1.6 2001/01/26 04:40:03 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------  *  * rf_decluster.c -- code related to the declustered layout  *  * Created 10-21-92 (MCH)  *  * Nov 93:  adding support for distributed sparing.  This code is a little  *          complex:  the basic layout used is as follows:  *          let F = (v-1)/GCD(r,v-1).  The spare space for each set of  *          F consecutive fulltables is grouped together and placed after  *          that set of tables.  *                   +------------------------------+  *                   |        F fulltables          |  *                   |        Spare Space           |  *                   |        F fulltables          |  *                   |        Spare Space           |  *                   |            ...               |  *                   +------------------------------+  *  *--------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raidframe.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|rf_copyback_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug only */
end_comment

begin_comment
comment|/* found in rf_kintf.c */
end_comment

begin_function_decl
name|int
name|rf_GetSpareTableFromDaemon
parameter_list|(
name|RF_SparetWait_t
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_PARITY_DECLUSTERING
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_PARITY_DECLUSTERING_PQ
operator|>
literal|0
operator|)
end_if

begin_comment
comment|/* configuration code */
end_comment

begin_function
name|int
name|rf_ConfigureDeclustered
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|b
decl_stmt|,
name|v
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|,
name|lambda
decl_stmt|;
comment|/* block design params */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RF_RowCol_t
modifier|*
name|first_avail_slot
decl_stmt|;
name|RF_StripeCount_t
name|complete_FT_count
decl_stmt|,
name|numCompleteFullTablesPerDisk
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|RF_StripeCount_t
name|PUsPerDisk
decl_stmt|,
name|spareRegionDepthInPUs
decl_stmt|,
name|numCompleteSpareRegionsPerDisk
decl_stmt|,
name|extraPUsPerDisk
decl_stmt|;
name|RF_StripeCount_t
name|totSparePUsPerDisk
decl_stmt|;
name|RF_SectorNum_t
name|diskOffsetOfLastFullTableInSUs
decl_stmt|;
name|RF_SectorCount_t
name|SpareSpaceInSUs
decl_stmt|;
name|char
modifier|*
name|cfgBuf
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|cfgPtr
operator|->
name|layoutSpecific
operator|)
decl_stmt|;
name|RF_StripeNum_t
name|l
decl_stmt|,
name|SUID
decl_stmt|;
name|SUID
operator|=
name|l
operator|=
literal|0
expr_stmt|;
name|numCompleteSpareRegionsPerDisk
operator|=
literal|0
expr_stmt|;
comment|/* 1. create layout specific structure */
name|RF_MallocAndAdd
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeclusteredConfigInfo_t
argument_list|)
argument_list|,
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|layoutPtr
operator|->
name|layoutSpecificInfo
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
name|info
operator|->
name|SpareTable
operator|=
name|NULL
expr_stmt|;
comment|/* 2. extract parameters from the config structure */
if|if
condition|(
name|layoutPtr
operator|->
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|cfgBuf
argument_list|,
name|info
operator|->
name|sparemap_fname
argument_list|,
name|RF_SPAREMAP_NAME_LEN
argument_list|)
expr_stmt|;
block|}
name|cfgBuf
operator|+=
name|RF_SPAREMAP_NAME_LEN
expr_stmt|;
name|b
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|v
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|r
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|lambda
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|noRotate
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|cfgBuf
operator|)
expr_stmt|;
name|cfgBuf
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* the sparemaps are generated assuming that parity is rotated, so we 	 * issue a warning if both distributed sparing and no-rotate are on at 	 * the same time */
if|if
condition|(
operator|(
name|layoutPtr
operator|->
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
operator|&&
name|raidPtr
operator|->
name|noRotate
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Warning:  distributed sparing specified without parity rotation.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|numCol
operator|!=
name|v
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"RAID: config error: table element count (%d) not equal to no. of cols (%d)\n"
argument_list|,
name|v
argument_list|,
name|raidPtr
operator|->
name|numCol
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 3.  set up the values used in the mapping code */
name|info
operator|->
name|BlocksPerTable
operator|=
name|b
expr_stmt|;
name|info
operator|->
name|Lambda
operator|=
name|lambda
expr_stmt|;
name|info
operator|->
name|NumParityReps
operator|=
name|info
operator|->
name|groupSize
operator|=
name|k
expr_stmt|;
name|info
operator|->
name|SUsPerTable
operator|=
name|b
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* b blks, k-1 SUs each */
name|info
operator|->
name|SUsPerFullTable
operator|=
name|k
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
comment|/* rot k times */
name|info
operator|->
name|PUsPerBlock
operator|=
name|k
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|SUsPerBlock
operator|=
name|info
operator|->
name|PUsPerBlock
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|info
operator|->
name|TableDepthInPUs
operator|=
operator|(
name|b
operator|*
name|k
operator|)
operator|/
name|v
expr_stmt|;
name|info
operator|->
name|FullTableDepthInPUs
operator|=
name|info
operator|->
name|TableDepthInPUs
operator|*
name|k
expr_stmt|;
comment|/* k repetitions */
comment|/* used only in distributed sparing case */
name|info
operator|->
name|FullTablesPerSpareRegion
operator|=
operator|(
name|v
operator|-
literal|1
operator|)
operator|/
name|rf_gcd
argument_list|(
name|r
argument_list|,
name|v
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* (v-1)/gcd fulltables */
name|info
operator|->
name|TablesPerSpareRegion
operator|=
name|k
operator|*
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|=
operator|(
name|r
operator|*
name|info
operator|->
name|TablesPerSpareRegion
operator|/
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* check to make sure the block design is sufficiently small */
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|+
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|>
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\n"
argument_list|,
operator|(
name|int
operator|)
name|info
operator|->
name|FullTableDepthInPUs
argument_list|,
operator|(
name|int
operator|)
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
argument_list|,
operator|(
name|int
operator|)
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|>
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
argument_list|)
argument_list|, \
operator|(
name|int
operator|)
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* compute the size of each disk, and the number of tables in the last 	 * fulltable (which need not be complete) */
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
name|PUsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|spareRegionDepthInPUs
operator|=
operator|(
name|info
operator|->
name|TablesPerSpareRegion
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|+
operator|(
name|info
operator|->
name|TablesPerSpareRegion
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|)
operator|/
operator|(
name|v
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|SpareRegionDepthInSUs
operator|=
name|spareRegionDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|numCompleteSpareRegionsPerDisk
operator|=
name|PUsPerDisk
operator|/
name|spareRegionDepthInPUs
expr_stmt|;
name|info
operator|->
name|NumCompleteSRs
operator|=
name|numCompleteSpareRegionsPerDisk
expr_stmt|;
name|extraPUsPerDisk
operator|=
name|PUsPerDisk
operator|%
name|spareRegionDepthInPUs
expr_stmt|;
comment|/* assume conservatively that we need the full amount of spare 		 * space in one region in order to provide spares for the 		 * partial spare region at the end of the array.  We set "i" 		 * to the number of tables in the partial spare region.  This 		 * may actually include some fulltables. */
name|extraPUsPerDisk
operator|-=
operator|(
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
if|if
condition|(
name|extraPUsPerDisk
operator|<=
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|=
name|extraPUsPerDisk
operator|/
name|info
operator|->
name|TableDepthInPUs
expr_stmt|;
name|complete_FT_count
operator|=
name|raidPtr
operator|->
name|numRow
operator|*
operator|(
name|numCompleteSpareRegionsPerDisk
operator|*
operator|(
name|info
operator|->
name|TablesPerSpareRegion
operator|/
name|k
operator|)
operator|+
name|i
operator|/
name|k
operator|)
expr_stmt|;
name|info
operator|->
name|FullTableLimitSUID
operator|=
name|complete_FT_count
operator|*
name|info
operator|->
name|SUsPerFullTable
expr_stmt|;
name|info
operator|->
name|ExtraTablesPerDisk
operator|=
name|i
operator|%
name|k
expr_stmt|;
comment|/* note that in the last spare region, the spare space is 		 * complete even though data/parity space is not */
name|totSparePUsPerDisk
operator|=
operator|(
name|numCompleteSpareRegionsPerDisk
operator|+
literal|1
operator|)
operator|*
operator|(
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
name|info
operator|->
name|TotSparePUsPerDisk
operator|=
name|totSparePUsPerDisk
expr_stmt|;
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|=
operator|(
operator|(
name|complete_FT_count
operator|/
name|raidPtr
operator|->
name|numRow
operator|)
operator|*
name|info
operator|->
name|FullTableDepthInPUs
operator|+
comment|/* data& parity space */
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|+
name|totSparePUsPerDisk
comment|/* spare space */
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|layoutPtr
operator|->
name|dataStripeUnitsPerDisk
operator|=
operator|(
name|complete_FT_count
operator|*
name|info
operator|->
name|FullTableDepthInPUs
operator|+
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|)
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
operator|/
name|k
expr_stmt|;
block|}
else|else
block|{
comment|/* non-dist spare case:  force each disk to contain an 		 * integral number of tables */
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/=
operator|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*=
operator|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
comment|/* compute the number of tables in the last fulltable, which 		 * need not be complete */
name|complete_FT_count
operator|=
operator|(
operator|(
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|/
name|info
operator|->
name|FullTableDepthInPUs
operator|)
operator|*
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|info
operator|->
name|FullTableLimitSUID
operator|=
name|complete_FT_count
operator|*
name|info
operator|->
name|SUsPerFullTable
expr_stmt|;
name|info
operator|->
name|ExtraTablesPerDisk
operator|=
operator|(
operator|(
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|/
name|info
operator|->
name|TableDepthInPUs
operator|)
operator|%
name|k
expr_stmt|;
block|}
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
comment|/* find the disk offset of the stripe unit where the last fulltable 	 * starts */
name|numCompleteFullTablesPerDisk
operator|=
name|complete_FT_count
operator|/
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|diskOffsetOfLastFullTableInSUs
operator|=
name|numCompleteFullTablesPerDisk
operator|*
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
name|SpareSpaceInSUs
operator|=
name|numCompleteSpareRegionsPerDisk
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
name|diskOffsetOfLastFullTableInSUs
operator|+=
name|SpareSpaceInSUs
expr_stmt|;
name|info
operator|->
name|DiskOffsetOfLastSpareSpaceChunkInSUs
operator|=
name|diskOffsetOfLastFullTableInSUs
operator|+
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
block|}
name|info
operator|->
name|DiskOffsetOfLastFullTableInSUs
operator|=
name|diskOffsetOfLastFullTableInSUs
expr_stmt|;
name|info
operator|->
name|numCompleteFullTablesPerDisk
operator|=
name|numCompleteFullTablesPerDisk
expr_stmt|;
comment|/* 4.  create and initialize the lookup tables */
name|info
operator|->
name|LayoutTable
operator|=
name|rf_make_2d_array
argument_list|(
name|b
argument_list|,
name|k
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|LayoutTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|info
operator|->
name|OffsetTable
operator|=
name|rf_make_2d_array
argument_list|(
name|b
argument_list|,
name|k
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|OffsetTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|info
operator|->
name|BlockTable
operator|=
name|rf_make_2d_array
argument_list|(
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
argument_list|,
name|raidPtr
operator|->
name|numCol
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|BlockTable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|first_avail_slot
operator|=
name|rf_make_1d_array
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_avail_slot
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|*
name|cfgBuf
operator|++
expr_stmt|;
comment|/* initialize offset table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|info
operator|->
name|OffsetTable
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|first_avail_slot
index|[
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
index|]
expr_stmt|;
name|first_avail_slot
index|[
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
index|]
operator|++
expr_stmt|;
block|}
comment|/* initialize block table */
for|for
control|(
name|SUID
operator|=
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|layoutPtr
operator|->
name|SUsPerPU
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|info
operator|->
name|BlockTable
index|[
operator|(
name|info
operator|->
name|OffsetTable
index|[
name|i
index|]
index|[
name|j
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|+
name|l
index|]
index|[
name|info
operator|->
name|LayoutTable
index|[
name|i
index|]
index|[
name|j
index|]
index|]
operator|=
name|SUID
expr_stmt|;
block|}
name|SUID
operator|++
expr_stmt|;
block|}
block|}
name|rf_free_1d_array
argument_list|(
name|first_avail_slot
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* 5.  set up the remaining redundant-but-useful parameters */
name|raidPtr
operator|->
name|totalSectors
operator|=
operator|(
name|k
operator|*
name|complete_FT_count
operator|+
name|raidPtr
operator|->
name|numRow
operator|*
name|info
operator|->
name|ExtraTablesPerDisk
operator|)
operator|*
name|info
operator|->
name|SUsPerTable
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|numStripe
operator|=
operator|(
name|raidPtr
operator|->
name|totalSectors
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
operator|/
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* strange evaluation order below to try and minimize overflow 	 * problems */
name|layoutPtr
operator|->
name|dataSectorsPerStripe
operator|=
operator|(
name|k
operator|-
literal|1
operator|)
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|bytesPerStripeUnit
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|layoutPtr
operator|->
name|numDataCol
operator|=
name|k
operator|-
literal|1
expr_stmt|;
name|layoutPtr
operator|->
name|numParityCol
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* declustering with distributed sparing */
end_comment

begin_function_decl
specifier|static
name|void
name|rf_ShutdownDeclusteredDS
parameter_list|(
name|RF_ThreadArg_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownDeclusteredDS
parameter_list|(
name|arg
parameter_list|)
name|RF_ThreadArg_t
name|arg
decl_stmt|;
block|{
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|info
operator|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|SpareTable
condition|)
name|rf_FreeSpareTable
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureDeclusteredDS
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|rf_ConfigureDeclustered
argument_list|(
name|listp
argument_list|,
name|raidPtr
argument_list|,
name|cfgPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownDeclusteredDS
argument_list|,
name|raidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Got %d adding shutdown event for DeclusteredDS\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownDeclusteredDS
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_MapSectorDeclustered
parameter_list|(
name|raidPtr
parameter_list|,
name|raidSector
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|,
name|diskSector
parameter_list|,
name|remap
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidAddr_t
name|raidSector
decl_stmt|;
name|RF_RowCol_t
modifier|*
name|row
decl_stmt|;
name|RF_RowCol_t
modifier|*
name|col
decl_stmt|;
name|RF_SectorNum_t
modifier|*
name|diskSector
decl_stmt|;
name|int
name|remap
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|FullTableID
decl_stmt|,
name|FullTableOffset
decl_stmt|,
name|TableID
decl_stmt|,
name|TableOffset
decl_stmt|;
name|RF_StripeNum_t
name|BlockID
decl_stmt|,
name|BlockOffset
decl_stmt|,
name|RepIndex
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|,
name|outSU
decl_stmt|,
name|SpareRegion
init|=
literal|0
decl_stmt|,
name|SpareSpace
init|=
literal|0
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
comment|/* fulltable ID within array 						 * (across rows) */
if|if
condition|(
name|raidPtr
operator|->
name|numRow
operator|==
literal|1
condition|)
operator|*
name|row
operator|=
literal|0
expr_stmt|;
comment|/* avoid a mod and a div in the common case */
else|else
block|{
operator|*
name|row
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|FullTableID
operator|/=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
comment|/* convert to fulltable ID on 						 * this disk */
block|}
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
name|SpareRegion
operator|=
name|FullTableID
operator|/
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|SpareSpace
operator|=
name|SpareRegion
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
block|}
name|FullTableOffset
operator|=
name|SUID
operator|%
name|sus_per_fulltable
expr_stmt|;
name|TableID
operator|=
name|FullTableOffset
operator|/
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|TableOffset
operator|=
name|FullTableOffset
operator|-
name|TableID
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|BlockID
operator|=
name|TableOffset
operator|/
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockOffset
operator|=
name|TableOffset
operator|-
name|BlockID
operator|*
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockID
operator|%=
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
name|RepIndex
operator|=
name|info
operator|->
name|PUsPerBlock
operator|-
name|TableID
expr_stmt|;
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|noRotate
condition|)
name|BlockOffset
operator|+=
operator|(
operator|(
name|BlockOffset
operator|>=
name|RepIndex
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|col
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|BlockID
index|]
index|[
name|BlockOffset
index|]
expr_stmt|;
comment|/* remap to distributed spare space if indicated */
if|if
condition|(
name|remap
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
operator|*
name|row
index|]
index|[
operator|*
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_reconstructing
operator|||
name|raidPtr
operator|->
name|Disks
index|[
operator|*
name|row
index|]
index|[
operator|*
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_dist_spared
operator|||
operator|(
name|rf_copyback_in_progress
operator|&&
name|raidPtr
operator|->
name|Disks
index|[
operator|*
name|row
index|]
index|[
operator|*
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
operator|)
argument_list|)
expr_stmt|;
name|rf_remap_to_spare_space
argument_list|(
name|layoutPtr
argument_list|,
name|info
argument_list|,
operator|*
name|row
argument_list|,
name|FullTableID
argument_list|,
name|TableID
argument_list|,
name|BlockID
argument_list|,
operator|(
name|base_suid
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|SpareRegion
argument_list|,
name|col
argument_list|,
operator|&
name|outSU
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outSU
operator|=
name|base_suid
expr_stmt|;
name|outSU
operator|+=
name|FullTableID
operator|*
name|fulltable_depth
expr_stmt|;
comment|/* offs to strt of FT */
name|outSU
operator|+=
name|SpareSpace
expr_stmt|;
comment|/* skip rsvd spare space */
name|outSU
operator|+=
name|TableID
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* offs to strt of tble */
name|outSU
operator|+=
name|info
operator|->
name|OffsetTable
index|[
name|BlockID
index|]
index|[
name|BlockOffset
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* offs to the PU */
block|}
name|outSU
operator|+=
name|TableOffset
operator|/
operator|(
name|info
operator|->
name|BlocksPerTable
operator|*
name|info
operator|->
name|PUsPerBlock
operator|)
expr_stmt|;
comment|/* offs to the SU within 										 * a PU */
comment|/* convert SUs to sectors, and, if not aligned to SU boundary, add in 	 * offset to sector.  */
operator|*
name|diskSector
operator|=
name|outSU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
name|col
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* prototyping this inexplicably causes the compile of the layout table (rf_layout.c) to fail */
end_comment

begin_function
name|void
name|rf_MapParityDeclustered
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|FullTableID
decl_stmt|,
name|FullTableOffset
decl_stmt|,
name|TableID
decl_stmt|,
name|TableOffset
decl_stmt|;
name|RF_StripeNum_t
name|BlockID
decl_stmt|,
name|BlockOffset
decl_stmt|,
name|RepIndex
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|,
name|outSU
decl_stmt|,
name|SpareRegion
init|=
literal|0
decl_stmt|,
name|SpareSpace
init|=
literal|0
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
comment|/* compute row& (possibly) spare space exactly as before */
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|numRow
operator|==
literal|1
condition|)
operator|*
name|row
operator|=
literal|0
expr_stmt|;
comment|/* avoid a mod and a div in the common case */
else|else
block|{
operator|*
name|row
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|FullTableID
operator|/=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
comment|/* convert to fulltable ID on 						 * this disk */
block|}
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|)
block|{
name|SpareRegion
operator|=
name|FullTableID
operator|/
name|info
operator|->
name|FullTablesPerSpareRegion
expr_stmt|;
name|SpareSpace
operator|=
name|SpareRegion
operator|*
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
block|}
comment|/* compute BlockID and RepIndex exactly as before */
name|FullTableOffset
operator|=
name|SUID
operator|%
name|sus_per_fulltable
expr_stmt|;
name|TableID
operator|=
name|FullTableOffset
operator|/
name|info
operator|->
name|SUsPerTable
expr_stmt|;
name|TableOffset
operator|=
name|FullTableOffset
operator|-
name|TableID
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
comment|/* TableOffset     = FullTableOffset % info->SUsPerTable; */
comment|/* BlockID         = (TableOffset / info->PUsPerBlock) % 	 * info->BlocksPerTable; */
name|BlockID
operator|=
name|TableOffset
operator|/
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
comment|/* BlockOffset     = TableOffset % info->PUsPerBlock; */
name|BlockOffset
operator|=
name|TableOffset
operator|-
name|BlockID
operator|*
name|info
operator|->
name|PUsPerBlock
expr_stmt|;
name|BlockID
operator|%=
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
comment|/* the parity block is in the position indicated by RepIndex */
name|RepIndex
operator|=
operator|(
name|raidPtr
operator|->
name|noRotate
operator|)
condition|?
name|info
operator|->
name|PUsPerBlock
else|:
name|info
operator|->
name|PUsPerBlock
operator|-
name|TableID
expr_stmt|;
operator|*
name|col
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|BlockID
index|]
index|[
name|RepIndex
index|]
expr_stmt|;
if|if
condition|(
name|remap
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
operator|*
name|row
index|]
index|[
operator|*
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_reconstructing
operator|||
name|raidPtr
operator|->
name|Disks
index|[
operator|*
name|row
index|]
index|[
operator|*
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_dist_spared
operator|||
operator|(
name|rf_copyback_in_progress
operator|&&
name|raidPtr
operator|->
name|Disks
index|[
operator|*
name|row
index|]
index|[
operator|*
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
operator|)
argument_list|)
expr_stmt|;
name|rf_remap_to_spare_space
argument_list|(
name|layoutPtr
argument_list|,
name|info
argument_list|,
operator|*
name|row
argument_list|,
name|FullTableID
argument_list|,
name|TableID
argument_list|,
name|BlockID
argument_list|,
operator|(
name|base_suid
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|SpareRegion
argument_list|,
name|col
argument_list|,
operator|&
name|outSU
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* compute sector as before, except use RepIndex instead of 		 * BlockOffset */
name|outSU
operator|=
name|base_suid
expr_stmt|;
name|outSU
operator|+=
name|FullTableID
operator|*
name|fulltable_depth
expr_stmt|;
name|outSU
operator|+=
name|SpareSpace
expr_stmt|;
comment|/* skip rsvd spare space */
name|outSU
operator|+=
name|TableID
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|outSU
operator|+=
name|info
operator|->
name|OffsetTable
index|[
name|BlockID
index|]
index|[
name|RepIndex
index|]
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
block|}
name|outSU
operator|+=
name|TableOffset
operator|/
operator|(
name|info
operator|->
name|BlocksPerTable
operator|*
name|info
operator|->
name|PUsPerBlock
operator|)
expr_stmt|;
operator|*
name|diskSector
operator|=
name|outSU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
name|col
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns an array of ints identifying the disks that comprise the stripe containing the indicated address.  * the caller must _never_ attempt to modify this array.  */
end_comment

begin_function
name|void
name|rf_IdentifyStripeDeclustered
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|addr
parameter_list|,
name|RF_RowCol_t
modifier|*
modifier|*
name|diskids
parameter_list|,
name|RF_RowCol_t
modifier|*
name|outRow
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeCount_t
name|sus_per_fulltable
init|=
name|info
operator|->
name|SUsPerFullTable
decl_stmt|;
name|RF_StripeCount_t
name|fulltable_depth
init|=
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
decl_stmt|;
name|RF_StripeNum_t
name|base_suid
init|=
literal|0
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RF_StripeNum_t
name|stripeID
decl_stmt|,
name|FullTableID
decl_stmt|;
name|int
name|tableOffset
decl_stmt|;
name|rf_decluster_adjust_params
argument_list|(
name|layoutPtr
argument_list|,
operator|&
name|SUID
argument_list|,
operator|&
name|sus_per_fulltable
argument_list|,
operator|&
name|fulltable_depth
argument_list|,
operator|&
name|base_suid
argument_list|)
expr_stmt|;
name|FullTableID
operator|=
name|SUID
operator|/
name|sus_per_fulltable
expr_stmt|;
comment|/* fulltable ID within array 						 * (across rows) */
operator|*
name|outRow
operator|=
name|FullTableID
operator|%
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|stripeID
operator|=
name|rf_StripeUnitIDToStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|SUID
argument_list|)
expr_stmt|;
comment|/* find stripe offset 								 * into array */
name|tableOffset
operator|=
operator|(
name|stripeID
operator|%
name|info
operator|->
name|BlocksPerTable
operator|)
expr_stmt|;
comment|/* find offset into 								 * block design table */
operator|*
name|diskids
operator|=
name|info
operator|->
name|LayoutTable
index|[
name|tableOffset
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This returns the default head-separation limit, which is measured  * in "required units for reconstruction".  Each time a disk fetches  * a unit, it bumps a counter.  The head-sep code prohibits any disk  * from getting more than headSepLimit counter values ahead of any  * other.  *  * We assume here that the number of floating recon buffers is already  * set.  There are r stripes to be reconstructed in each table, and so  * if we have a total of B buffers, we can have at most B/r tables  * under recon at any one time.  In each table, lambda units are required  * from each disk, so given B buffers, the head sep limit has to be  * (lambda*B)/r units.  We subtract one to avoid weird boundary cases.  *  * for example, suppose were given 50 buffers, r=19, and lambda=4 as in  * the 20.5 design.  There are 19 stripes/table to be reconstructed, so  * we can have 50/19 tables concurrently under reconstruction, which means  * we can allow the fastest disk to get 50/19 tables ahead of the slower  * disk.  There are lambda "required units" for each disk, so the fastest  * disk can get 4*50/19 = 10 counter values ahead of the slowest.  *  * If numBufsToAccumulate is not 1, we need to limit the head sep further  * because multiple bufs will be required for each stripe under recon.  */
end_comment

begin_function
name|RF_HeadSepLimit_t
name|rf_GetDefaultHeadSepLimitDeclustered
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
return|return
operator|(
name|info
operator|->
name|Lambda
operator|*
name|raidPtr
operator|->
name|numFloatingReconBufs
operator|/
name|info
operator|->
name|TableDepthInPUs
operator|/
name|rf_numBufsToAccumulate
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns the default number of recon buffers to use.  The value  * is somewhat arbitrary...it's intended to be large enough to allow  * for a reasonably large head-sep limit, but small enough that you  * don't use up all your system memory with buffers.  */
end_comment

begin_function
name|int
name|rf_GetDefaultNumFloatingReconBuffersDeclustered
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
return|return
operator|(
literal|100
operator|*
name|rf_numBufsToAccumulate
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sectors in the last fulltable of the array need to be handled  * specially since this fulltable can be incomplete.  this function  * changes the values of certain params to handle this.  *  * the idea here is that MapSector et. al. figure out which disk the  * addressed unit lives on by computing the modulos of the unit number  * with the number of units per fulltable, table, etc.  In the last  * fulltable, there are fewer units per fulltable, so we need to adjust  * the number of user data units per fulltable to reflect this.  *  * so, we (1) convert the fulltable size and depth parameters to  * the size of the partial fulltable at the end, (2) compute the  * disk sector offset where this fulltable starts, and (3) convert  * the users stripe unit number from an offset into the array to  * an offset into the last fulltable.  */
end_comment

begin_function
name|void
name|rf_decluster_adjust_params
parameter_list|(
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_StripeNum_t
modifier|*
name|SUID
parameter_list|,
name|RF_StripeCount_t
modifier|*
name|sus_per_fulltable
parameter_list|,
name|RF_StripeCount_t
modifier|*
name|fulltable_depth
parameter_list|,
name|RF_StripeNum_t
modifier|*
name|base_suid
parameter_list|)
block|{
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
if|if
condition|(
operator|*
name|SUID
operator|>=
name|info
operator|->
name|FullTableLimitSUID
condition|)
block|{
comment|/* new full table size is size of last full table on disk */
operator|*
name|sus_per_fulltable
operator|=
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|SUsPerTable
expr_stmt|;
comment|/* new full table depth is corresponding depth */
operator|*
name|fulltable_depth
operator|=
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
comment|/* set up the new base offset */
operator|*
name|base_suid
operator|=
name|info
operator|->
name|DiskOffsetOfLastFullTableInSUs
expr_stmt|;
comment|/* convert users array address to an offset into the last 		 * fulltable */
operator|*
name|SUID
operator|-=
name|info
operator|->
name|FullTableLimitSUID
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * map a stripe ID to a parity stripe ID.  * See comment above RaidAddressToParityStripeID in layout.c.  */
end_comment

begin_function
name|void
name|rf_MapSIDToPSIDDeclustered
parameter_list|(
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_StripeNum_t
name|stripeID
parameter_list|,
name|RF_StripeNum_t
modifier|*
name|psID
parameter_list|,
name|RF_ReconUnitNum_t
modifier|*
name|which_ru
parameter_list|)
block|{
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|info
operator|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
expr_stmt|;
operator|*
name|psID
operator|=
operator|(
name|stripeID
operator|/
operator|(
name|layoutPtr
operator|->
name|SUsPerPU
operator|*
name|info
operator|->
name|BlocksPerTable
operator|)
operator|)
operator|*
name|info
operator|->
name|BlocksPerTable
operator|+
operator|(
name|stripeID
operator|%
name|info
operator|->
name|BlocksPerTable
operator|)
expr_stmt|;
operator|*
name|which_ru
operator|=
operator|(
name|stripeID
operator|%
operator|(
name|info
operator|->
name|BlocksPerTable
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|)
operator|/
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
operator|*
name|which_ru
operator|)
operator|<
name|layoutPtr
operator|->
name|SUsPerPU
operator|/
name|layoutPtr
operator|->
name|SUsPerRU
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from MapSector and MapParity to retarget an access at the spare unit.  * Modifies the "col" and "outSU" parameters only.  */
end_comment

begin_function
name|void
name|rf_remap_to_spare_space
parameter_list|(
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_StripeNum_t
name|FullTableID
parameter_list|,
name|RF_StripeNum_t
name|TableID
parameter_list|,
name|RF_SectorNum_t
name|BlockID
parameter_list|,
name|RF_StripeNum_t
name|base_suid
parameter_list|,
name|RF_StripeNum_t
name|SpareRegion
parameter_list|,
name|RF_RowCol_t
modifier|*
name|outCol
parameter_list|,
name|RF_StripeNum_t
modifier|*
name|outSU
parameter_list|)
block|{
name|RF_StripeNum_t
name|ftID
decl_stmt|,
name|spareTableStartSU
decl_stmt|,
name|TableInSpareRegion
decl_stmt|,
name|lastSROffset
decl_stmt|,
name|which_ft
decl_stmt|;
comment|/*          * note that FullTableID and hence SpareRegion may have gotten          * tweaked by rf_decluster_adjust_params. We detect this by          * noticing that base_suid is not 0.          */
if|if
condition|(
name|base_suid
operator|==
literal|0
condition|)
block|{
name|ftID
operator|=
name|FullTableID
expr_stmt|;
block|}
else|else
block|{
comment|/* 	         * There may be> 1.0 full tables in the last (i.e. partial) 	         * spare region.  find out which of these we're in. 	         */
name|lastSROffset
operator|=
name|info
operator|->
name|NumCompleteSRs
operator|*
name|info
operator|->
name|SpareRegionDepthInSUs
expr_stmt|;
name|which_ft
operator|=
operator|(
name|info
operator|->
name|DiskOffsetOfLastFullTableInSUs
operator|-
name|lastSROffset
operator|)
operator|/
operator|(
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
expr_stmt|;
comment|/* compute the actual full table ID */
name|ftID
operator|=
name|info
operator|->
name|DiskOffsetOfLastFullTableInSUs
operator|/
operator|(
name|info
operator|->
name|FullTableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
operator|)
operator|+
name|which_ft
expr_stmt|;
name|SpareRegion
operator|=
name|info
operator|->
name|NumCompleteSRs
expr_stmt|;
block|}
name|TableInSpareRegion
operator|=
operator|(
name|ftID
operator|*
name|info
operator|->
name|NumParityReps
operator|+
name|TableID
operator|)
operator|%
name|info
operator|->
name|TablesPerSpareRegion
expr_stmt|;
operator|*
name|outCol
operator|=
name|info
operator|->
name|SpareTable
index|[
name|TableInSpareRegion
index|]
index|[
name|BlockID
index|]
operator|.
name|spareDisk
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
name|outCol
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|spareTableStartSU
operator|=
operator|(
name|SpareRegion
operator|==
name|info
operator|->
name|NumCompleteSRs
operator|)
condition|?
name|info
operator|->
name|DiskOffsetOfLastFullTableInSUs
operator|+
name|info
operator|->
name|ExtraTablesPerDisk
operator|*
name|info
operator|->
name|TableDepthInPUs
operator|*
name|layoutPtr
operator|->
name|SUsPerPU
else|:
operator|(
name|SpareRegion
operator|+
literal|1
operator|)
operator|*
name|info
operator|->
name|SpareRegionDepthInSUs
operator|-
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
operator|*
name|outSU
operator|=
name|spareTableStartSU
operator|+
name|info
operator|->
name|SpareTable
index|[
name|TableInSpareRegion
index|]
index|[
name|BlockID
index|]
operator|.
name|spareBlockOffsetInSUs
expr_stmt|;
if|if
condition|(
operator|*
name|outSU
operator|>=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
condition|)
block|{
name|printf
argument_list|(
literal|"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\n"
argument_list|,
operator|(
name|long
operator|)
operator|*
name|outSU
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_PARITY_DECLUSTERING> 0)  || (RF_INCLUDE_PARITY_DECLUSTERING_PQ> 0) */
end_comment

begin_function
name|int
name|rf_InstallSpareTable
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|frow
parameter_list|,
name|RF_RowCol_t
name|fcol
parameter_list|)
block|{
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
name|RF_SparetWait_t
modifier|*
name|req
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|RF_Malloc
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
operator|(
name|RF_SparetWait_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|C
operator|=
name|raidPtr
operator|->
name|numCol
expr_stmt|;
name|req
operator|->
name|G
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|+
name|raidPtr
operator|->
name|Layout
operator|.
name|numParityCol
expr_stmt|;
name|req
operator|->
name|fcol
operator|=
name|fcol
expr_stmt|;
name|req
operator|->
name|SUsPerPU
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerPU
expr_stmt|;
name|req
operator|->
name|TablesPerSpareRegion
operator|=
name|info
operator|->
name|TablesPerSpareRegion
expr_stmt|;
name|req
operator|->
name|BlocksPerTable
operator|=
name|info
operator|->
name|BlocksPerTable
expr_stmt|;
name|req
operator|->
name|TableDepthInPUs
operator|=
name|info
operator|->
name|TableDepthInPUs
expr_stmt|;
name|req
operator|->
name|SpareSpaceDepthPerRegionInSUs
operator|=
name|info
operator|->
name|SpareSpaceDepthPerRegionInSUs
expr_stmt|;
name|retcode
operator|=
name|rf_GetSpareTableFromDaemon
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
name|retcode
argument_list|)
expr_stmt|;
comment|/* XXX -- fix this to recover gracefully -- 				 * XXX */
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invoked via ioctl to install a spare table in the kernel.  */
end_comment

begin_function
name|int
name|rf_SetSpareTable
parameter_list|(
name|raidPtr
parameter_list|,
name|data
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
name|RF_SpareTableEntry_t
modifier|*
modifier|*
name|ptrs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
decl_stmt|;
comment|/* what we need to copyin is a 2-d array, so first copyin the user 	 * pointers to the rows in the table */
name|RF_Malloc
argument_list|(
name|ptrs
argument_list|,
name|info
operator|->
name|TablesPerSpareRegion
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_SpareTableEntry_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptrs
argument_list|,
name|info
operator|->
name|TablesPerSpareRegion
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
return|return
operator|(
name|retcode
operator|)
return|;
comment|/* now allocate kernel space for the row pointers */
name|RF_Malloc
argument_list|(
name|info
operator|->
name|SpareTable
argument_list|,
name|info
operator|->
name|TablesPerSpareRegion
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_SpareTableEntry_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* now allocate kernel space for each row in the table, and copy it in 	 * from user space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|TablesPerSpareRegion
condition|;
name|i
operator|++
control|)
block|{
name|RF_Malloc
argument_list|(
name|info
operator|->
name|SpareTable
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|BlocksPerTable
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_SpareTableEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|copyin
argument_list|(
name|ptrs
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|SpareTable
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|BlocksPerTable
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|info
operator|->
name|SpareTable
operator|=
name|NULL
expr_stmt|;
comment|/* blow off the memory 							 * we've allocated */
return|return
operator|(
name|retcode
operator|)
return|;
block|}
block|}
comment|/* free up the temporary array we used */
name|RF_Free
argument_list|(
name|ptrs
argument_list|,
name|info
operator|->
name|TablesPerSpareRegion
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_ReconUnitCount_t
name|rf_GetNumSpareRUsDeclustered
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
operator|)
operator|->
name|TotSparePUsPerDisk
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeSpareTable
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_DeclusteredConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_DeclusteredConfigInfo_t
operator|*
operator|)
name|layoutPtr
operator|->
name|layoutSpecificInfo
decl_stmt|;
name|RF_SpareTableEntry_t
modifier|*
modifier|*
name|table
init|=
name|info
operator|->
name|SpareTable
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|TablesPerSpareRegion
condition|;
name|i
operator|++
control|)
block|{
name|RF_Free
argument_list|(
name|table
index|[
name|i
index|]
argument_list|,
name|info
operator|->
name|BlocksPerTable
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|table
argument_list|,
name|info
operator|->
name|TablesPerSpareRegion
operator|*
sizeof|sizeof
argument_list|(
name|RF_SpareTableEntry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|SpareTable
operator|=
operator|(
name|RF_SpareTableEntry_t
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

end_unit

