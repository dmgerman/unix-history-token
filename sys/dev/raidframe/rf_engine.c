begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_engine.c,v 1.10 2000/08/20 16:51:03 thorpej Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: William V. Courtright II, Mark Holland, Rachad Youssef  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/****************************************************************************  *                                                                          *  * engine.c -- code for DAG execution engine                                *  *                                                                          *  * Modified to work as follows (holland):                                   *  *   A user-thread calls into DispatchDAG, which fires off the nodes that   *  *   are direct successors to the header node.  DispatchDAG then returns,   *  *   and the rest of the I/O continues asynchronously.  As each node        *  *   completes, the node execution function calls FinishNode().  FinishNode *  *   scans the list of successors to the node and increments the antecedent *  *   counts.  Each node that becomes enabled is placed on a central node    *  *   queue.  A dedicated dag-execution thread grabs nodes off of this       *  *   queue and fires them.                                                  *  *                                                                          *  *   NULL nodes are never fired.                                            *  *                                                                          *  *   Terminator nodes are never fired, but rather cause the callback        *  *   associated with the DAG to be invoked.                                 *  *                                                                          *  *   If a node fails, the dag either rolls forward to the completion or     *  *   rolls back, undoing previously-completed nodes and fails atomically.   *  *   The direction of recovery is determined by the location of the failed  *  *   node in the graph.  If the failure occured before the commit node in   *  *   the graph, backward recovery is used.  Otherwise, forward recovery is  *  *   used.                                                                  *  *                                                                          *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_function_decl
specifier|static
name|void
name|DAGExecutionThread
parameter_list|(
name|RF_ThreadArg_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DO_INIT
parameter_list|(
name|_l_
parameter_list|,
name|_r_
parameter_list|)
value|{ \   int _rc; \   _rc = rf_create_managed_mutex(_l_,&(_r_)->node_queue_mutex); \   if (_rc) { \     return(_rc); \   } \   _rc = rf_create_managed_cond(_l_,&(_r_)->node_queue_cond); \   if (_rc) { \     return(_rc); \   } \ }
end_define

begin_comment
comment|/* synchronization primitives for this file.  DO_WAIT should be enclosed in a while loop. */
end_comment

begin_comment
comment|/*  * XXX Is this spl-ing really necessary?  */
end_comment

begin_define
define|#
directive|define
name|DO_LOCK
parameter_list|(
name|_r_
parameter_list|)
define|\
value|do { \ 	ks = splbio(); \ 	RF_LOCK_MUTEX((_r_)->node_queue_mutex); \ } while (0)
end_define

begin_define
define|#
directive|define
name|DO_UNLOCK
parameter_list|(
name|_r_
parameter_list|)
define|\
value|do { \ 	RF_UNLOCK_MUTEX((_r_)->node_queue_mutex); \ 	splx(ks); \ } while (0)
end_define

begin_define
define|#
directive|define
name|DO_WAIT
parameter_list|(
name|_r_
parameter_list|)
define|\
value|RF_WAIT_COND((_r_)->node_queue, (_r_)->node_queue_mutex)
end_define

begin_define
define|#
directive|define
name|DO_SIGNAL
parameter_list|(
name|_r_
parameter_list|)
define|\
value|RF_BROADCAST_COND((_r_)->node_queue)
end_define

begin_comment
comment|/* XXX RF_SIGNAL_COND? */
end_comment

begin_function_decl
specifier|static
name|void
name|rf_ShutdownEngine
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownEngine
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|raidPtr
operator|->
name|shutdown_engine
operator|=
literal|1
expr_stmt|;
name|DO_SIGNAL
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureEngine
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|DO_INIT
argument_list|(
name|listp
argument_list|,
name|raidPtr
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|node_queue
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|dags_in_flight
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|rf_init_managed_threadgroup
argument_list|(
name|listp
argument_list|,
operator|&
name|raidPtr
operator|->
name|engine_tg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* we create the execution thread only once per system boot. no need 	 * to check return code b/c the kernel panics if it can't create the 	 * thread. */
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Creating engine thread\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RF_CREATE_THREAD
argument_list|(
name|raidPtr
operator|->
name|engine_thread
argument_list|,
name|DAGExecutionThread
argument_list|,
name|raidPtr
argument_list|,
literal|"raid"
argument_list|)
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"RAIDFRAME: Unable to create engine thread\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Created engine thread\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|RF_THREADGROUP_STARTED
argument_list|(
operator|&
name|raidPtr
operator|->
name|engine_tg
argument_list|)
expr_stmt|;
comment|/* XXX something is missing here... */
ifdef|#
directive|ifdef
name|debug
name|printf
argument_list|(
literal|"Skipping the WAIT_START!!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
name|printf
argument_list|(
literal|"Waiting for DAG engine to start\n"
argument_list|)
expr_stmt|;
name|RF_THREADGROUP_WAIT_START
argument_list|(
operator|&
name|raidPtr
operator|->
name|engine_tg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* engine thread is now running and waiting for work */
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Engine thread running and waiting for events\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownEngine
argument_list|,
name|raidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownEngine
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|BranchDone
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* return true if forward execution is completed for a node and it's 	 * succedents */
switch|switch
condition|(
name|node
operator|->
name|status
condition|)
block|{
case|case
name|rf_wait
case|:
comment|/* should never be called in this state */
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
case|case
name|rf_fired
case|:
comment|/* node is currently executing, so we're not done */
return|return
operator|(
name|RF_FALSE
operator|)
return|;
case|case
name|rf_good
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
comment|/* for each succedent */
if|if
condition|(
operator|!
name|BranchDone
argument_list|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|)
condition|)
comment|/* recursively check 								 * branch */
return|return
name|RF_FALSE
return|;
return|return
name|RF_TRUE
return|;
comment|/* node and all succedent branches aren't in 				 * fired state */
break|break;
case|case
name|rf_bad
case|:
comment|/* succedents can't fire */
return|return
operator|(
name|RF_TRUE
operator|)
return|;
case|case
name|rf_recover
case|:
comment|/* should never be called in this state */
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
case|case
name|rf_undone
case|:
case|case
name|rf_panic
case|:
comment|/* XXX need to fix this case */
comment|/* for now, assume that we're done */
return|return
operator|(
name|RF_TRUE
operator|)
return|;
break|break;
default|default:
comment|/* illegal node status */
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|NodeReady
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
name|int
name|ready
decl_stmt|;
switch|switch
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
condition|)
block|{
case|case
name|rf_enable
case|:
case|case
name|rf_rollForward
case|:
if|if
condition|(
operator|(
name|node
operator|->
name|status
operator|==
name|rf_wait
operator|)
operator|&&
operator|(
name|node
operator|->
name|numAntecedents
operator|==
name|node
operator|->
name|numAntDone
operator|)
condition|)
name|ready
operator|=
name|RF_TRUE
expr_stmt|;
else|else
name|ready
operator|=
name|RF_FALSE
expr_stmt|;
break|break;
case|case
name|rf_rollBackward
case|:
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|numSuccDone
operator|<=
name|node
operator|->
name|numSuccedents
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|numSuccFired
operator|<=
name|node
operator|->
name|numSuccedents
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|numSuccFired
operator|<=
name|node
operator|->
name|numSuccDone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|status
operator|==
name|rf_good
operator|)
operator|&&
operator|(
name|node
operator|->
name|numSuccDone
operator|==
name|node
operator|->
name|numSuccedents
operator|)
condition|)
name|ready
operator|=
name|RF_TRUE
expr_stmt|;
else|else
name|ready
operator|=
name|RF_FALSE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Execution engine found illegal DAG status in NodeReady\n"
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ready
operator|)
return|;
block|}
end_function

begin_comment
comment|/* user context and dag-exec-thread context:  * Fire a node.  The node's status field determines which function, do or undo,  * to be fired.  * This routine assumes that the node's status field has alread been set to  * "fired" or "recover" to indicate the direction of execution.  */
end_comment

begin_function
specifier|static
name|void
name|FireNode
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|status
condition|)
block|{
case|case
name|rf_fired
case|:
comment|/* fire the do function of a node */
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Firing node 0x%lx (%s)\n"
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|node
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|RF_DAGNODE_FLAG_YIELD
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
comment|/* thread_block(); */
comment|/* printf("Need to block the thread here...\n");  */
comment|/* XXX thread_block is actually mentioned in 			 * /usr/include/vm/vm_extern.h */
else|#
directive|else
name|thread_block
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
operator|*
operator|(
name|node
operator|->
name|doFunc
operator|)
operator|)
operator|(
name|node
operator|)
expr_stmt|;
break|break;
case|case
name|rf_recover
case|:
comment|/* fire the undo function of a node */
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Firing (undo) node 0x%lx (%s)\n"
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|node
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|RF_DAGNODE_FLAG_YIELD
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
comment|/* thread_block(); */
comment|/* printf("Need to block the thread here...\n"); */
comment|/* XXX thread_block is actually mentioned in 			 * /usr/include/vm/vm_extern.h */
else|#
directive|else
name|thread_block
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
operator|(
name|node
operator|->
name|undoFunc
operator|)
operator|)
operator|(
name|node
operator|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* user context:  * Attempt to fire each node in a linear array.  * The entire list is fired atomically.  */
end_comment

begin_function
specifier|static
name|void
name|FireNodeArray
parameter_list|(
name|int
name|numNodes
parameter_list|,
name|RF_DagNode_t
modifier|*
modifier|*
name|nodeList
parameter_list|)
block|{
name|RF_DagStatus_t
name|dstat
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* first, mark all nodes which are ready to be fired */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numNodes
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|nodeList
index|[
name|i
index|]
expr_stmt|;
name|dstat
operator|=
name|node
operator|->
name|dagHdr
operator|->
name|status
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
name|node
operator|->
name|status
operator|==
name|rf_wait
operator|)
operator|||
operator|(
name|node
operator|->
name|status
operator|==
name|rf_good
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NodeReady
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dstat
operator|==
name|rf_enable
operator|)
operator|||
operator|(
name|dstat
operator|==
name|rf_rollForward
operator|)
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|status
operator|==
name|rf_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|commitNode
condition|)
name|node
operator|->
name|dagHdr
operator|->
name|numCommits
operator|++
expr_stmt|;
name|node
operator|->
name|status
operator|=
name|rf_fired
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|node
operator|->
name|numAntecedents
condition|;
name|j
operator|++
control|)
name|node
operator|->
name|antecedents
index|[
name|j
index|]
operator|->
name|numSuccFired
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|dstat
operator|==
name|rf_rollBackward
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|status
operator|==
name|rf_good
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|commitNode
operator|==
name|RF_FALSE
argument_list|)
expr_stmt|;
comment|/* only one commit node 										 * per graph */
name|node
operator|->
name|status
operator|=
name|rf_recover
expr_stmt|;
block|}
block|}
block|}
comment|/* now, fire the nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nodeList
index|[
name|i
index|]
operator|->
name|status
operator|==
name|rf_fired
operator|)
operator|||
operator|(
name|nodeList
index|[
name|i
index|]
operator|->
name|status
operator|==
name|rf_recover
operator|)
condition|)
name|FireNode
argument_list|(
name|nodeList
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* user context:  * Attempt to fire each node in a linked list.  * The entire list is fired atomically.  */
end_comment

begin_function
specifier|static
name|void
name|FireNodeList
parameter_list|(
name|RF_DagNode_t
modifier|*
name|nodeList
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|RF_DagStatus_t
name|dstat
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|nodeList
condition|)
block|{
comment|/* first, mark all nodes which are ready to be fired */
for|for
control|(
name|node
operator|=
name|nodeList
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|dstat
operator|=
name|node
operator|->
name|dagHdr
operator|->
name|status
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
name|node
operator|->
name|status
operator|==
name|rf_wait
operator|)
operator|||
operator|(
name|node
operator|->
name|status
operator|==
name|rf_good
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NodeReady
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dstat
operator|==
name|rf_enable
operator|)
operator|||
operator|(
name|dstat
operator|==
name|rf_rollForward
operator|)
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|status
operator|==
name|rf_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|commitNode
condition|)
name|node
operator|->
name|dagHdr
operator|->
name|numCommits
operator|++
expr_stmt|;
name|node
operator|->
name|status
operator|=
name|rf_fired
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|node
operator|->
name|numAntecedents
condition|;
name|j
operator|++
control|)
name|node
operator|->
name|antecedents
index|[
name|j
index|]
operator|->
name|numSuccFired
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|dstat
operator|==
name|rf_rollBackward
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|status
operator|==
name|rf_good
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|commitNode
operator|==
name|RF_FALSE
argument_list|)
expr_stmt|;
comment|/* only one commit node 											 * per graph */
name|node
operator|->
name|status
operator|=
name|rf_recover
expr_stmt|;
block|}
block|}
block|}
comment|/* now, fire the nodes */
for|for
control|(
name|node
operator|=
name|nodeList
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|status
operator|==
name|rf_fired
operator|)
operator|||
operator|(
name|node
operator|->
name|status
operator|==
name|rf_recover
operator|)
condition|)
name|FireNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* interrupt context:  * for each succedent  *    propagate required results from node to succedent  *    increment succedent's numAntDone  *    place newly-enable nodes on node queue for firing  *  * To save context switches, we don't place NIL nodes on the node queue,  * but rather just process them as if they had fired.  Note that NIL nodes  * that are the direct successors of the header will actually get fired by  * DispatchDAG, which is fine because no context switches are involved.  *  * Important:  when running at user level, this can be called by any  * disk thread, and so the increment and check of the antecedent count  * must be locked.  I used the node queue mutex and locked down the  * entire function, but this is certainly overkill.  */
end_comment

begin_function
specifier|static
name|void
name|PropagateResults
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|int
name|context
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|s
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ks
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|finishlist
init|=
name|NULL
decl_stmt|;
comment|/* a list of NIL nodes to be 						 * finished */
name|RF_DagNode_t
modifier|*
name|skiplist
init|=
name|NULL
decl_stmt|;
comment|/* list of nodes with failed truedata 					 * antecedents */
name|RF_DagNode_t
modifier|*
name|firelist
init|=
name|NULL
decl_stmt|;
comment|/* a list of nodes to be fired */
name|RF_DagNode_t
modifier|*
name|q
init|=
name|NULL
decl_stmt|,
modifier|*
name|qh
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|j
decl_stmt|,
name|skipNode
decl_stmt|;
name|raidPtr
operator|=
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
expr_stmt|;
name|DO_LOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* debug - validate fire counts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numAntecedents
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
operator|*
operator|(
name|node
operator|->
name|antecedents
operator|+
name|i
operator|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|a
operator|->
name|numSuccFired
operator|>=
name|a
operator|->
name|numSuccDone
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|a
operator|->
name|numSuccFired
operator|<=
name|a
operator|->
name|numSuccedents
argument_list|)
expr_stmt|;
name|a
operator|->
name|numSuccDone
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|node
operator|->
name|dagHdr
operator|->
name|status
condition|)
block|{
case|case
name|rf_enable
case|:
case|case
name|rf_rollForward
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|*
operator|(
name|node
operator|->
name|succedents
operator|+
name|i
operator|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|s
operator|->
name|status
operator|==
name|rf_wait
argument_list|)
expr_stmt|;
operator|(
name|s
operator|->
name|numAntDone
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|numAntDone
operator|==
name|s
operator|->
name|numAntecedents
condition|)
block|{
comment|/* look for NIL nodes */
if|if
condition|(
name|s
operator|->
name|doFunc
operator|==
name|rf_NullNodeFunc
condition|)
block|{
comment|/* don't fire NIL nodes, just process 					 * them */
name|s
operator|->
name|next
operator|=
name|finishlist
expr_stmt|;
name|finishlist
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* look to see if the node is to be 					 * skipped */
name|skipNode
operator|=
name|RF_FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|numAntecedents
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|antType
index|[
name|j
index|]
operator|==
name|rf_trueData
operator|)
operator|&&
operator|(
name|s
operator|->
name|antecedents
index|[
name|j
index|]
operator|->
name|status
operator|==
name|rf_bad
operator|)
condition|)
name|skipNode
operator|=
name|RF_TRUE
expr_stmt|;
if|if
condition|(
name|skipNode
condition|)
block|{
comment|/* this node has one or more 						 * failed true data 						 * dependencies, so skip it */
name|s
operator|->
name|next
operator|=
name|skiplist
expr_stmt|;
name|skiplist
operator|=
name|s
expr_stmt|;
block|}
elseif|else
comment|/* add s to list of nodes (q) 						 * to execute */
if|if
condition|(
name|context
operator|!=
name|RF_INTR_CONTEXT
condition|)
block|{
comment|/* we only have to 							 * enqueue if we're at 							 * intr context */
name|s
operator|->
name|next
operator|=
name|firelist
expr_stmt|;
comment|/* put node on a list to 										 * be fired after we 										 * unlock */
name|firelist
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* enqueue the node for 								 * the dag exec thread 								 * to fire */
name|RF_ASSERT
argument_list|(
name|NodeReady
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|q
operator|->
name|next
operator|=
name|s
expr_stmt|;
name|q
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|qh
operator|=
name|q
operator|=
name|s
expr_stmt|;
name|qh
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
comment|/* xfer our local list of nodes to the node queue */
name|q
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|node_queue
expr_stmt|;
name|raidPtr
operator|->
name|node_queue
operator|=
name|qh
expr_stmt|;
name|DO_SIGNAL
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
name|DO_UNLOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|skiplist
condition|;
name|skiplist
operator|=
name|next
control|)
block|{
name|next
operator|=
name|skiplist
operator|->
name|next
expr_stmt|;
name|skiplist
operator|->
name|status
operator|=
name|rf_skipped
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skiplist
operator|->
name|numAntecedents
condition|;
name|i
operator|++
control|)
block|{
name|skiplist
operator|->
name|antecedents
index|[
name|i
index|]
operator|->
name|numSuccFired
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|skiplist
operator|->
name|commitNode
condition|)
block|{
name|skiplist
operator|->
name|dagHdr
operator|->
name|numCommits
operator|++
expr_stmt|;
block|}
name|rf_FinishNode
argument_list|(
name|skiplist
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|finishlist
condition|;
name|finishlist
operator|=
name|next
control|)
block|{
comment|/* NIL nodes: no need to fire them */
name|next
operator|=
name|finishlist
operator|->
name|next
expr_stmt|;
name|finishlist
operator|->
name|status
operator|=
name|rf_good
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|finishlist
operator|->
name|numAntecedents
condition|;
name|i
operator|++
control|)
block|{
name|finishlist
operator|->
name|antecedents
index|[
name|i
index|]
operator|->
name|numSuccFired
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|finishlist
operator|->
name|commitNode
condition|)
name|finishlist
operator|->
name|dagHdr
operator|->
name|numCommits
operator|++
expr_stmt|;
comment|/* 		         * Okay, here we're calling rf_FinishNode() on nodes that 		         * have the null function as their work proc. Such a node 		         * could be the terminal node in a DAG. If so, it will 		         * cause the DAG to complete, which will in turn free 		         * memory used by the DAG, which includes the node in 		         * question. Thus, we must avoid referencing the node 		         * at all after calling rf_FinishNode() on it. 		         */
name|rf_FinishNode
argument_list|(
name|finishlist
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* recursive call */
block|}
comment|/* fire all nodes in firelist */
name|FireNodeList
argument_list|(
name|firelist
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_rollBackward
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numAntecedents
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
operator|*
operator|(
name|node
operator|->
name|antecedents
operator|+
name|i
operator|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|a
operator|->
name|status
operator|==
name|rf_good
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|a
operator|->
name|numSuccDone
operator|<=
name|a
operator|->
name|numSuccedents
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|a
operator|->
name|numSuccDone
operator|<=
name|a
operator|->
name|numSuccFired
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|numSuccDone
operator|==
name|a
operator|->
name|numSuccFired
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|undoFunc
operator|==
name|rf_NullNodeFunc
condition|)
block|{
comment|/* don't fire NIL nodes, just process 					 * them */
name|a
operator|->
name|next
operator|=
name|finishlist
expr_stmt|;
name|finishlist
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|!=
name|RF_INTR_CONTEXT
condition|)
block|{
comment|/* we only have to enqueue if 						 * we're at intr context */
name|a
operator|->
name|next
operator|=
name|firelist
expr_stmt|;
comment|/* put node on a list to 									 * be fired after we 									 * unlock */
name|firelist
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
comment|/* enqueue the node for 							 * the dag exec thread 							 * to fire */
name|RF_ASSERT
argument_list|(
name|NodeReady
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|q
operator|->
name|next
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|qh
operator|=
name|q
operator|=
name|a
expr_stmt|;
name|qh
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
comment|/* xfer our local list of nodes to the node queue */
name|q
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|node_queue
expr_stmt|;
name|raidPtr
operator|->
name|node_queue
operator|=
name|qh
expr_stmt|;
name|DO_SIGNAL
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
name|DO_UNLOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|finishlist
condition|;
name|finishlist
operator|=
name|next
control|)
block|{
comment|/* NIL nodes: no need to 							 * fire them */
name|next
operator|=
name|finishlist
operator|->
name|next
expr_stmt|;
name|finishlist
operator|->
name|status
operator|=
name|rf_good
expr_stmt|;
comment|/* 		         * Okay, here we're calling rf_FinishNode() on nodes that 		         * have the null function as their work proc. Such a node 		         * could be the first node in a DAG. If so, it will 		         * cause the DAG to complete, which will in turn free 		         * memory used by the DAG, which includes the node in 		         * question. Thus, we must avoid referencing the node 		         * at all after calling rf_FinishNode() on it. 		         */
name|rf_FinishNode
argument_list|(
name|finishlist
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* recursive call */
block|}
comment|/* fire all nodes in firelist */
name|FireNodeList
argument_list|(
name|firelist
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Engine found illegal DAG status in PropagateResults()\n"
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a fired node which has completed  */
end_comment

begin_function
specifier|static
name|void
name|ProcessNode
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|int
name|context
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|status
condition|)
block|{
case|case
name|rf_good
case|:
comment|/* normal case, don't need to do anything */
break|break;
case|case
name|rf_bad
case|:
if|if
condition|(
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|numCommits
operator|>
literal|0
operator|)
operator|||
operator|(
name|node
operator|->
name|dagHdr
operator|->
name|numCommitNodes
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|=
name|rf_rollForward
expr_stmt|;
comment|/* crossed commit 								 * barrier */
if|if
condition|(
name|rf_engineDebug
operator|||
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: node (%s) returned fail, rolling forward\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|->
name|dagHdr
operator|->
name|status
operator|=
name|rf_rollBackward
expr_stmt|;
comment|/* never reached commit 								 * barrier */
if|if
condition|(
name|rf_engineDebug
operator|||
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: node (%s) returned fail, rolling backward\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|rf_undone
case|:
comment|/* normal rollBackward case, don't need to do anything */
break|break;
case|case
name|rf_panic
case|:
comment|/* an undo node failed!!! */
name|printf
argument_list|(
literal|"UNDO of a node failed!!!/n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"node finished execution with an illegal status!!!\n"
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* enqueue node's succedents (antecedents if rollBackward) for 	 * execution */
name|PropagateResults
argument_list|(
name|node
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* user context or dag-exec-thread context:  * This is the first step in post-processing a newly-completed node.  * This routine is called by each node execution function to mark the node  * as complete and fire off any successors that have been enabled.  */
end_comment

begin_function
name|int
name|rf_FinishNode
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|int
name|context
parameter_list|)
block|{
comment|/* as far as I can tell, retcode is not used -wvcii */
name|int
name|retcode
init|=
name|RF_FALSE
decl_stmt|;
name|node
operator|->
name|dagHdr
operator|->
name|numNodesCompleted
operator|++
expr_stmt|;
name|ProcessNode
argument_list|(
name|node
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* user context:  * submit dag for execution, return non-zero if we have to wait for completion.  * if and only if we return non-zero, we'll cause cbFunc to get invoked with  * cbArg when the DAG has completed.  *  * for now we always return 1.  If the DAG does not cause any I/O, then the callback  * may get invoked before DispatchDAG returns.  There's code in state 5 of ContinueRaidAccess  * to handle this.  *  * All we do here is fire the direct successors of the header node.  The  * DAG execution thread does the rest of the dag processing.  */
end_comment

begin_function
name|int
name|rf_DispatchDAG
parameter_list|(
name|RF_DagHeader_t
modifier|*
name|dag
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbFunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbArg
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
name|dag
operator|->
name|raidPtr
expr_stmt|;
if|if
condition|(
name|dag
operator|->
name|tracerec
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|dag
operator|->
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_engineDebug
operator|||
name|rf_validateDAGDebug
condition|)
block|{
if|if
condition|(
name|rf_ValidateDAG
argument_list|(
name|dag
argument_list|)
condition|)
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Entering DispatchDAG\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|raidPtr
operator|->
name|dags_in_flight
operator|++
expr_stmt|;
comment|/* debug only:  blow off proper 					 * locking */
name|dag
operator|->
name|cbFunc
operator|=
name|cbFunc
expr_stmt|;
name|dag
operator|->
name|cbArg
operator|=
name|cbArg
expr_stmt|;
name|dag
operator|->
name|numNodesCompleted
operator|=
literal|0
expr_stmt|;
name|dag
operator|->
name|status
operator|=
name|rf_enable
expr_stmt|;
name|FireNodeArray
argument_list|(
name|dag
operator|->
name|numSuccedents
argument_list|,
name|dag
operator|->
name|succedents
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* dedicated kernel thread:  * the thread that handles all DAG node firing.  * To minimize locking and unlocking, we grab a copy of the entire node queue and then set the  * node queue to NULL before doing any firing of nodes.  This way we only have to release the  * lock once.  Of course, it's probably rare that there's more than one node in the queue at  * any one time, but it sometimes happens.  *  * In the kernel, this thread runs at spl0 and is not swappable.  I copied these  * characteristics from the aio_completion_thread.  */
end_comment

begin_function
specifier|static
name|void
name|DAGExecutionThread
parameter_list|(
name|RF_ThreadArg_t
name|arg
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nd
decl_stmt|,
modifier|*
name|local_nq
decl_stmt|,
modifier|*
name|term_nq
decl_stmt|,
modifier|*
name|fire_nq
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|ks
decl_stmt|;
name|raidPtr
operator|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|rf_engineDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Engine thread is running\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|RF_THREADGROUP_RUNNING
argument_list|(
operator|&
name|raidPtr
operator|->
name|engine_tg
argument_list|)
expr_stmt|;
name|DO_LOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|raidPtr
operator|->
name|shutdown_engine
condition|)
block|{
while|while
condition|(
name|raidPtr
operator|->
name|node_queue
operator|!=
name|NULL
condition|)
block|{
name|local_nq
operator|=
name|raidPtr
operator|->
name|node_queue
expr_stmt|;
name|fire_nq
operator|=
name|NULL
expr_stmt|;
name|term_nq
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|node_queue
operator|=
name|NULL
expr_stmt|;
name|DO_UNLOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* first, strip out the terminal nodes */
while|while
condition|(
name|local_nq
condition|)
block|{
name|nd
operator|=
name|local_nq
expr_stmt|;
name|local_nq
operator|=
name|local_nq
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|nd
operator|->
name|dagHdr
operator|->
name|status
condition|)
block|{
case|case
name|rf_enable
case|:
case|case
name|rf_rollForward
case|:
if|if
condition|(
name|nd
operator|->
name|numSuccedents
operator|==
literal|0
condition|)
block|{
comment|/* end of the dag, add to 						 * callback list */
name|nd
operator|->
name|next
operator|=
name|term_nq
expr_stmt|;
name|term_nq
operator|=
name|nd
expr_stmt|;
block|}
else|else
block|{
comment|/* not the end, add to the 						 * fire queue */
name|nd
operator|->
name|next
operator|=
name|fire_nq
expr_stmt|;
name|fire_nq
operator|=
name|nd
expr_stmt|;
block|}
break|break;
case|case
name|rf_rollBackward
case|:
if|if
condition|(
name|nd
operator|->
name|numAntecedents
operator|==
literal|0
condition|)
block|{
comment|/* end of the dag, add to the 						 * callback list */
name|nd
operator|->
name|next
operator|=
name|term_nq
expr_stmt|;
name|term_nq
operator|=
name|nd
expr_stmt|;
block|}
else|else
block|{
comment|/* not the end, add to the 						 * fire queue */
name|nd
operator|->
name|next
operator|=
name|fire_nq
expr_stmt|;
name|fire_nq
operator|=
name|nd
expr_stmt|;
block|}
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* execute callback of dags which have reached the 			 * terminal node */
while|while
condition|(
name|term_nq
condition|)
block|{
name|nd
operator|=
name|term_nq
expr_stmt|;
name|term_nq
operator|=
name|term_nq
operator|->
name|next
expr_stmt|;
name|nd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
call|(
name|nd
operator|->
name|dagHdr
operator|->
name|cbFunc
call|)
argument_list|(
name|nd
operator|->
name|dagHdr
operator|->
name|cbArg
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|dags_in_flight
operator|--
expr_stmt|;
comment|/* debug only */
block|}
comment|/* fire remaining nodes */
name|FireNodeList
argument_list|(
name|fire_nq
argument_list|)
expr_stmt|;
name|DO_LOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|raidPtr
operator|->
name|shutdown_engine
operator|&&
name|raidPtr
operator|->
name|node_queue
operator|==
name|NULL
condition|)
name|DO_WAIT
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
name|DO_UNLOCK
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|RF_THREADGROUP_DONE
argument_list|(
operator|&
name|raidPtr
operator|->
name|engine_tg
argument_list|)
expr_stmt|;
name|RF_THREAD_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

