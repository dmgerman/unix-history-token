begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_layout.c,v 1.9 2001/01/27 19:34:43 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/* rf_layout.c -- driver code dealing with layout and mapping issues  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_pq.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_declusterPQ.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid0.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid1.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid4.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid5.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_states.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_RAID5_RS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid5_rotatedspare.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_RAID5_RS> 0 */
end_comment

begin_if
if|#
directive|if
name|RF_INCLUDE_CHAINDECLUSTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_chaindecluster.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_CHAINDECLUSTER> 0 */
end_comment

begin_if
if|#
directive|if
name|RF_INCLUDE_INTERDECLUSTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_interdecluster.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_INTERDECLUSTER> 0 */
end_comment

begin_if
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylogging.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

begin_if
if|#
directive|if
name|RF_INCLUDE_EVENODD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_EVENODD> 0 */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconbuffer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconutil.h>
end_include

begin_comment
comment|/***********************************************************************  *  * the layout switch defines all the layouts that are supported.  *    fields are: layout ID, init routine, shutdown routine, map  *    sector, map parity, identify stripe, dag selection, map stripeid  *    to parity stripe id (optional), num faults tolerated, special  *    flags.  *  ***********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|RF_AccessState_t
name|DefaultStates
index|[]
init|=
block|{
name|rf_QuiesceState
block|,
name|rf_IncrAccessesCountState
block|,
name|rf_MapState
block|,
name|rf_LockState
block|,
name|rf_CreateDAGState
block|,
name|rf_ExecuteDAGState
block|,
name|rf_ProcessDAGState
block|,
name|rf_DecrAccessesCountState
block|,
name|rf_CleanupState
block|,
name|rf_LastState
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_NU
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|,
name|k
parameter_list|,
name|l
parameter_list|,
name|m
parameter_list|,
name|n
parameter_list|,
name|o
parameter_list|,
name|p
parameter_list|)
value|a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p
end_define

begin_comment
comment|/* Note that if you add any new RAID types to this list, that you must    also update the mapsw[] table in the raidctl sources */
end_comment

begin_decl_stmt
specifier|static
name|RF_LayoutSW_t
name|mapsw
index|[]
init|=
block|{
if|#
directive|if
name|RF_INCLUDE_PARITY_DECLUSTERING
operator|>
literal|0
comment|/* parity declustering */
block|{
literal|'T'
block|,
literal|"Parity declustering"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureDeclustered
argument_list|,
argument|rf_MapSectorDeclustered
argument_list|,
argument|rf_MapParityDeclustered
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeDeclustered
argument_list|,
argument|rf_RaidFiveDagSelect
argument_list|,
argument|rf_MapSIDToPSIDDeclustered
argument_list|,
argument|rf_GetDefaultHeadSepLimitDeclustered
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersDeclustered
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|RF_INCLUDE_PARITY_DECLUSTERING_DS
operator|>
literal|0
comment|/* parity declustering with distributed sparing */
block|{
literal|'D'
block|,
literal|"Distributed sparing parity declustering"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureDeclusteredDS
argument_list|,
argument|rf_MapSectorDeclustered
argument_list|,
argument|rf_MapParityDeclustered
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeDeclustered
argument_list|,
argument|rf_RaidFiveDagSelect
argument_list|,
argument|rf_MapSIDToPSIDDeclustered
argument_list|,
argument|rf_GetDefaultHeadSepLimitDeclustered
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersDeclustered
argument_list|,
argument|rf_GetNumSpareRUsDeclustered
argument_list|,
argument|rf_InstallSpareTable
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
argument|RF_DISTRIBUTE_SPARE | RF_BD_DECLUSTERED
argument_list|)
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|RF_INCLUDE_DECL_PQ
operator|>
literal|0
comment|/* declustered P+Q */
block|{
literal|'Q'
block|,
literal|"Declustered P+Q"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureDeclusteredPQ
argument_list|,
argument|rf_MapSectorDeclusteredPQ
argument_list|,
argument|rf_MapParityDeclusteredPQ
argument_list|,
argument|rf_MapQDeclusteredPQ
argument_list|,
argument|rf_IdentifyStripeDeclusteredPQ
argument_list|,
argument|rf_PQDagSelect
argument_list|,
argument|rf_MapSIDToPSIDDeclustered
argument_list|,
argument|rf_GetDefaultHeadSepLimitDeclustered
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersPQ
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|2
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_DECL_PQ> 0 */
if|#
directive|if
name|RF_INCLUDE_RAID5_RS
operator|>
literal|0
comment|/* RAID 5 with rotated sparing */
block|{
literal|'R'
block|,
literal|"RAID Level 5 rotated sparing"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureRAID5_RS
argument_list|,
argument|rf_MapSectorRAID5_RS
argument_list|,
argument|rf_MapParityRAID5_RS
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeRAID5_RS
argument_list|,
argument|rf_RaidFiveDagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID5_RS
argument_list|,
argument|rf_GetDefaultHeadSepLimitRAID5
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersRAID5
argument_list|,
argument|rf_GetNumSpareRUsRAID5_RS
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
argument|RF_DISTRIBUTE_SPARE
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_RAID5_RS> 0 */
if|#
directive|if
name|RF_INCLUDE_CHAINDECLUSTER
operator|>
literal|0
comment|/* Chained Declustering */
block|{
literal|'C'
block|,
literal|"Chained Declustering"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureChainDecluster
argument_list|,
argument|rf_MapSectorChainDecluster
argument_list|,
argument|rf_MapParityChainDecluster
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeChainDecluster
argument_list|,
argument|rf_RAIDCDagSelect
argument_list|,
argument|rf_MapSIDToPSIDChainDecluster
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_GetNumSpareRUsChainDecluster
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_CHAINDECLUSTER> 0 */
if|#
directive|if
name|RF_INCLUDE_INTERDECLUSTER
operator|>
literal|0
comment|/* Interleaved Declustering */
block|{
literal|'I'
block|,
literal|"Interleaved Declustering"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureInterDecluster
argument_list|,
argument|rf_MapSectorInterDecluster
argument_list|,
argument|rf_MapParityInterDecluster
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeInterDecluster
argument_list|,
argument|rf_RAIDIDagSelect
argument_list|,
argument|rf_MapSIDToPSIDInterDecluster
argument_list|,
argument|rf_GetDefaultHeadSepLimitInterDecluster
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersInterDecluster
argument_list|,
argument|rf_GetNumSpareRUsInterDecluster
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
argument|RF_DISTRIBUTE_SPARE
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_INTERDECLUSTER> 0 */
if|#
directive|if
name|RF_INCLUDE_RAID0
operator|>
literal|0
comment|/* RAID level 0 */
block|{
literal|'0'
block|,
literal|"RAID Level 0"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureRAID0
argument_list|,
argument|rf_MapSectorRAID0
argument_list|,
argument|rf_MapParityRAID0
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeRAID0
argument_list|,
argument|rf_RAID0DagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID0
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_VerifyParityRAID0
argument_list|,
literal|0
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_RAID0> 0 */
if|#
directive|if
name|RF_INCLUDE_RAID1
operator|>
literal|0
comment|/* RAID level 1 */
block|{
literal|'1'
block|,
literal|"RAID Level 1"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureRAID1
argument_list|,
argument|rf_MapSectorRAID1
argument_list|,
argument|rf_MapParityRAID1
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeRAID1
argument_list|,
argument|rf_RAID1DagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID1
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferRAID1
argument_list|,
argument|rf_VerifyParityRAID1
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_RAID1> 0 */
if|#
directive|if
name|RF_INCLUDE_RAID4
operator|>
literal|0
comment|/* RAID level 4 */
block|{
literal|'4'
block|,
literal|"RAID Level 4"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureRAID4
argument_list|,
argument|rf_MapSectorRAID4
argument_list|,
argument|rf_MapParityRAID4
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeRAID4
argument_list|,
argument|rf_RaidFiveDagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID4
argument_list|,
argument|rf_GetDefaultHeadSepLimitRAID4
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersRAID4
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_RAID4> 0 */
if|#
directive|if
name|RF_INCLUDE_RAID5
operator|>
literal|0
comment|/* RAID level 5 */
block|{
literal|'5'
block|,
literal|"RAID Level 5"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureRAID5
argument_list|,
argument|rf_MapSectorRAID5
argument_list|,
argument|rf_MapParityRAID5
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeRAID5
argument_list|,
argument|rf_RaidFiveDagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID5
argument_list|,
argument|rf_GetDefaultHeadSepLimitRAID5
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersRAID5
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|rf_VerifyParityBasic
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_RAID5> 0 */
if|#
directive|if
name|RF_INCLUDE_EVENODD
operator|>
literal|0
comment|/* Evenodd */
block|{
literal|'E'
block|,
literal|"EvenOdd"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureEvenOdd
argument_list|,
argument|rf_MapSectorRAID5
argument_list|,
argument|rf_MapParityEvenOdd
argument_list|,
argument|rf_MapEEvenOdd
argument_list|,
argument|rf_IdentifyStripeEvenOdd
argument_list|,
argument|rf_EODagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID5
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
comment|/* no reconstruction, yet */
argument|rf_VerifyParityEvenOdd
argument_list|,
literal|2
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_EVENODD> 0 */
if|#
directive|if
name|RF_INCLUDE_EVENODD
operator|>
literal|0
comment|/* Declustered Evenodd */
block|{
literal|'e'
block|,
literal|"Declustered EvenOdd"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureDeclusteredPQ
argument_list|,
argument|rf_MapSectorDeclusteredPQ
argument_list|,
argument|rf_MapParityDeclusteredPQ
argument_list|,
argument|rf_MapQDeclusteredPQ
argument_list|,
argument|rf_IdentifyStripeDeclusteredPQ
argument_list|,
argument|rf_EODagSelect
argument_list|,
argument|rf_MapSIDToPSIDRAID5
argument_list|,
argument|rf_GetDefaultHeadSepLimitDeclustered
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersPQ
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
comment|/* no reconstruction, yet */
argument|rf_VerifyParityEvenOdd
argument_list|,
literal|2
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_EVENODD> 0 */
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
comment|/* parity logging */
block|{
literal|'L'
block|,
literal|"Parity logging"
block|,
name|RF_NU
argument_list|(
argument|rf_ConfigureParityLogging
argument_list|,
argument|rf_MapSectorParityLogging
argument_list|,
argument|rf_MapParityParityLogging
argument_list|,
argument|NULL
argument_list|,
argument|rf_IdentifyStripeParityLogging
argument_list|,
argument|rf_ParityLoggingDagSelect
argument_list|,
argument|rf_MapSIDToPSIDParityLogging
argument_list|,
argument|rf_GetDefaultHeadSepLimitParityLogging
argument_list|,
argument|rf_GetDefaultNumFloatingReconBuffersParityLogging
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rf_SubmitReconBufferBasic
argument_list|,
argument|NULL
argument_list|,
literal|1
argument_list|,
argument|DefaultStates
argument_list|,
literal|0
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
comment|/* end-of-list marker */
block|{
literal|'\0'
block|,
name|NULL
block|,
name|RF_NU
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|RF_LayoutSW_t
modifier|*
name|rf_GetLayout
parameter_list|(
name|RF_ParityConfig_t
name|parityConfig
parameter_list|)
block|{
name|RF_LayoutSW_t
modifier|*
name|p
decl_stmt|;
comment|/* look up the specific layout */
for|for
control|(
name|p
operator|=
operator|&
name|mapsw
index|[
literal|0
index|]
init|;
name|p
operator|->
name|parityConfig
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|parityConfig
operator|==
name|parityConfig
condition|)
break|break;
if|if
condition|(
operator|!
name|p
operator|->
name|parityConfig
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|RF_ASSERT
argument_list|(
name|p
operator|->
name|parityConfig
operator|==
name|parityConfig
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * ConfigureLayout --  *  * read the configuration file and set up the RAID layout parameters.  * After reading common params, invokes the layout-specific  * configuration routine to finish the configuration.  *  ****************************************************************************/
end_comment

begin_function
name|int
name|rf_ConfigureLayout
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_ParityConfig_t
name|parityConfig
decl_stmt|;
name|RF_LayoutSW_t
modifier|*
name|p
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|=
name|cfgPtr
operator|->
name|sectPerSU
expr_stmt|;
name|layoutPtr
operator|->
name|SUsPerPU
operator|=
name|cfgPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|layoutPtr
operator|->
name|SUsPerRU
operator|=
name|cfgPtr
operator|->
name|SUsPerRU
expr_stmt|;
name|parityConfig
operator|=
name|cfgPtr
operator|->
name|parityConfig
expr_stmt|;
if|if
condition|(
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|<=
literal|0
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"raid%d: Invalid sectorsPerStripeUnit: %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|int
operator|)
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|=
name|raidPtr
operator|->
name|sectorsPerDisk
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|p
operator|=
name|rf_GetLayout
argument_list|(
name|parityConfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Unknown parity configuration '%c'"
argument_list|,
name|parityConfig
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|RF_ASSERT
argument_list|(
name|p
operator|->
name|parityConfig
operator|==
name|parityConfig
argument_list|)
expr_stmt|;
name|layoutPtr
operator|->
name|map
operator|=
name|p
expr_stmt|;
comment|/* initialize the specific layout */
name|retval
operator|=
call|(
name|p
operator|->
name|Configure
call|)
argument_list|(
name|listp
argument_list|,
name|raidPtr
argument_list|,
name|cfgPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|layoutPtr
operator|->
name|dataBytesPerStripe
operator|=
name|layoutPtr
operator|->
name|dataSectorsPerStripe
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
if|if
condition|(
name|rf_forceNumFloatingReconBufs
operator|>=
literal|0
condition|)
block|{
name|raidPtr
operator|->
name|numFloatingReconBufs
operator|=
name|rf_forceNumFloatingReconBufs
expr_stmt|;
block|}
else|else
block|{
name|raidPtr
operator|->
name|numFloatingReconBufs
operator|=
name|rf_GetDefaultNumFloatingReconBuffers
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_forceHeadSepLimit
operator|>=
literal|0
condition|)
block|{
name|raidPtr
operator|->
name|headSepLimit
operator|=
name|rf_forceHeadSepLimit
expr_stmt|;
block|}
else|else
block|{
name|raidPtr
operator|->
name|headSepLimit
operator|=
name|rf_GetDefaultHeadSepLimit
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"RAIDFRAME: Configure (%s): total number of sectors is %lu (%lu MB)\n"
argument_list|,
name|layoutPtr
operator|->
name|map
operator|->
name|configName
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|raidPtr
operator|->
name|totalSectors
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|raidPtr
operator|->
name|totalSectors
operator|/
literal|1024
operator|*
operator|(
literal|1
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
operator|)
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|headSepLimit
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"RAIDFRAME(%s): Using %ld floating recon bufs with head sep limit %ld\n"
argument_list|,
name|layoutPtr
operator|->
name|map
operator|->
name|configName
argument_list|,
operator|(
name|long
operator|)
name|raidPtr
operator|->
name|numFloatingReconBufs
argument_list|,
operator|(
name|long
operator|)
name|raidPtr
operator|->
name|headSepLimit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"RAIDFRAME(%s): Using %ld floating recon bufs with no head sep limit\n"
argument_list|,
name|layoutPtr
operator|->
name|map
operator|->
name|configName
argument_list|,
operator|(
name|long
operator|)
name|raidPtr
operator|->
name|numFloatingReconBufs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* typically there is a 1-1 mapping between stripes and parity stripes.  * however, the declustering code supports packing multiple stripes into  * a single parity stripe, so as to increase the size of the reconstruction  * unit without affecting the size of the stripe unit.  This routine finds  * the parity stripe identifier associated with a stripe ID.  There is also  * a RaidAddressToParityStripeID macro in layout.h  */
end_comment

begin_function
name|RF_StripeNum_t
name|rf_MapStripeIDToParityStripeID
parameter_list|(
name|layoutPtr
parameter_list|,
name|stripeID
parameter_list|,
name|which_ru
parameter_list|)
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|RF_StripeNum_t
name|stripeID
decl_stmt|;
name|RF_ReconUnitNum_t
modifier|*
name|which_ru
decl_stmt|;
block|{
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
comment|/* quick exit in the common case of SUsPerPU==1 */
if|if
condition|(
operator|(
name|layoutPtr
operator|->
name|SUsPerPU
operator|==
literal|1
operator|)
operator|||
operator|!
name|layoutPtr
operator|->
name|map
operator|->
name|MapSIDToPSID
condition|)
block|{
operator|*
name|which_ru
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|stripeID
operator|)
return|;
block|}
else|else
block|{
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapSIDToPSID
call|)
argument_list|(
name|layoutPtr
argument_list|,
name|stripeID
argument_list|,
operator|&
name|parityStripeID
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|parityStripeID
operator|)
return|;
block|}
end_function

end_unit

