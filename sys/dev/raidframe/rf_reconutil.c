begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_reconutil.c,v 1.3 1999/02/05 00:06:17 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/********************************************  * rf_reconutil.c -- reconstruction utilities  ********************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconutil.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconbuffer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid5_rotatedspare.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_interdecluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_chaindecluster.h>
end_include

begin_comment
comment|/*******************************************************************  * allocates/frees the reconstruction control information structures  *******************************************************************/
end_comment

begin_function
name|RF_ReconCtrl_t
modifier|*
name|rf_MakeReconControl
parameter_list|(
name|reconDesc
parameter_list|,
name|frow
parameter_list|,
name|fcol
parameter_list|,
name|srow
parameter_list|,
name|scol
parameter_list|)
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
name|RF_RowCol_t
name|frow
decl_stmt|;
comment|/* failed row and column */
name|RF_RowCol_t
name|fcol
decl_stmt|;
name|RF_RowCol_t
name|srow
decl_stmt|;
comment|/* identifies which spare we're using */
name|RF_RowCol_t
name|scol
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|reconDesc
operator|->
name|raidPtr
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_ReconUnitCount_t
name|RUsPerPU
init|=
name|layoutPtr
operator|->
name|SUsPerPU
operator|/
name|layoutPtr
operator|->
name|SUsPerRU
decl_stmt|;
name|RF_ReconUnitCount_t
name|numSpareRUs
decl_stmt|;
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|int
name|retcode
decl_stmt|,
name|rc
decl_stmt|;
name|RF_RowCol_t
name|i
decl_stmt|;
name|lp
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
comment|/* make and zero the global reconstruction structure and the per-disk 	 * structure */
name|RF_Calloc
argument_list|(
name|reconCtrlPtr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconCtrl_t
argument_list|)
argument_list|,
operator|(
name|RF_ReconCtrl_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Calloc
argument_list|(
name|reconCtrlPtr
operator|->
name|perDiskInfo
argument_list|,
name|raidPtr
operator|->
name|numCol
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PerDiskReconCtrl_t
argument_list|)
argument_list|,
operator|(
name|RF_PerDiskReconCtrl_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* this zeros it */
name|reconCtrlPtr
operator|->
name|reconDesc
operator|=
name|reconDesc
expr_stmt|;
name|reconCtrlPtr
operator|->
name|fcol
operator|=
name|fcol
expr_stmt|;
name|reconCtrlPtr
operator|->
name|spareRow
operator|=
name|srow
expr_stmt|;
name|reconCtrlPtr
operator|->
name|spareCol
operator|=
name|scol
expr_stmt|;
name|reconCtrlPtr
operator|->
name|lastPSID
operator|=
name|layoutPtr
operator|->
name|numStripe
operator|/
name|layoutPtr
operator|->
name|SUsPerPU
expr_stmt|;
name|reconCtrlPtr
operator|->
name|percentComplete
operator|=
literal|0
expr_stmt|;
comment|/* initialize each per-disk recon information structure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
block|{
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|reconCtrl
operator|=
name|reconCtrlPtr
expr_stmt|;
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|row
operator|=
name|frow
expr_stmt|;
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|col
operator|=
name|i
expr_stmt|;
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|curPSID
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* make it appear as if 								 * we just finished an 								 * RU */
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|ru_count
operator|=
name|RUsPerPU
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Get the number of spare units per disk and the sparemap in case 	 * spare is distributed  */
if|if
condition|(
name|lp
operator|->
name|GetNumSpareRUs
condition|)
block|{
name|numSpareRUs
operator|=
name|lp
operator|->
name|GetNumSpareRUs
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numSpareRUs
operator|=
literal|0
expr_stmt|;
block|}
comment|/*          * Not all distributed sparing archs need dynamic mappings          */
if|if
condition|(
name|lp
operator|->
name|InstallSpareTable
condition|)
block|{
name|retcode
operator|=
name|rf_InstallSpareTable
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|RF_PANIC
argument_list|()
expr_stmt|;
comment|/* XXX fix this */
block|}
block|}
comment|/* make the reconstruction map */
name|reconCtrlPtr
operator|->
name|reconMap
operator|=
name|rf_MakeReconMap
argument_list|(
name|raidPtr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|layoutPtr
operator|->
name|SUsPerRU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
name|raidPtr
operator|->
name|sectorsPerDisk
argument_list|,
name|numSpareRUs
argument_list|)
expr_stmt|;
comment|/* make the per-disk reconstruction buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
block|{
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|rbuf
operator|=
operator|(
name|i
operator|==
name|fcol
operator|)
condition|?
name|NULL
else|:
name|rf_MakeReconBuffer
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|i
argument_list|,
name|RF_RBUF_TYPE_EXCLUSIVE
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the event queue */
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|reconCtrlPtr
operator|->
name|eq_mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* XXX deallocate, cleanup */
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rc
operator|=
name|rf_cond_init
argument_list|(
operator|&
name|reconCtrlPtr
operator|->
name|eq_cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* XXX deallocate, cleanup */
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init cond file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|reconCtrlPtr
operator|->
name|eventQueue
operator|=
name|NULL
expr_stmt|;
name|reconCtrlPtr
operator|->
name|eq_count
operator|=
literal|0
expr_stmt|;
comment|/* make the floating recon buffers and append them to the free list */
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* XXX deallocate, cleanup */
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|reconCtrlPtr
operator|->
name|fullBufferList
operator|=
name|NULL
expr_stmt|;
name|reconCtrlPtr
operator|->
name|priorityList
operator|=
name|NULL
expr_stmt|;
name|reconCtrlPtr
operator|->
name|floatingRbufs
operator|=
name|NULL
expr_stmt|;
name|reconCtrlPtr
operator|->
name|committedRbufs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numFloatingReconBufs
condition|;
name|i
operator|++
control|)
block|{
name|rbuf
operator|=
name|rf_MakeReconBuffer
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|,
name|RF_RBUF_TYPE_FLOATING
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|next
operator|=
name|reconCtrlPtr
operator|->
name|floatingRbufs
expr_stmt|;
name|reconCtrlPtr
operator|->
name|floatingRbufs
operator|=
name|rbuf
expr_stmt|;
block|}
comment|/* create the parity stripe status table */
name|reconCtrlPtr
operator|->
name|pssTable
operator|=
name|rf_MakeParityStripeStatusTable
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* set the initial min head sep counter val */
name|reconCtrlPtr
operator|->
name|minHeadSepCounter
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|reconCtrlPtr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeReconControl
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
block|{
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|t
decl_stmt|;
name|RF_ReconUnitNum_t
name|i
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|reconCtrlPtr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|rbuf
condition|)
name|rf_FreeReconBuffer
argument_list|(
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|rbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numFloatingReconBufs
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|reconCtrlPtr
operator|->
name|floatingRbufs
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|reconCtrlPtr
operator|->
name|floatingRbufs
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|rf_FreeReconBuffer
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|rf_mutex_destroy
argument_list|(
operator|&
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|rf_mutex_destroy
argument_list|(
operator|&
name|reconCtrlPtr
operator|->
name|eq_mutex
argument_list|)
expr_stmt|;
name|rf_cond_destroy
argument_list|(
operator|&
name|reconCtrlPtr
operator|->
name|eq_cond
argument_list|)
expr_stmt|;
name|rf_FreeReconMap
argument_list|(
name|reconCtrlPtr
operator|->
name|reconMap
argument_list|)
expr_stmt|;
name|rf_FreeParityStripeStatusTable
argument_list|(
name|raidPtr
argument_list|,
name|reconCtrlPtr
operator|->
name|pssTable
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|reconCtrlPtr
operator|->
name|perDiskInfo
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|*
sizeof|sizeof
argument_list|(
name|RF_PerDiskReconCtrl_t
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|reconCtrlPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reconCtrlPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * computes the default head separation limit  *****************************************************************************/
end_comment

begin_function
name|RF_HeadSepLimit_t
name|rf_GetDefaultHeadSepLimit
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_HeadSepLimit_t
name|hsl
decl_stmt|;
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|GetDefaultHeadSepLimit
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hsl
operator|=
name|lp
operator|->
name|GetDefaultHeadSepLimit
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|hsl
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * computes the default number of floating recon buffers  *****************************************************************************/
end_comment

begin_function
name|int
name|rf_GetDefaultNumFloatingReconBuffers
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|int
name|nrb
decl_stmt|;
name|lp
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|GetDefaultNumFloatingReconBuffers
operator|==
name|NULL
condition|)
return|return
operator|(
literal|3
operator|*
name|raidPtr
operator|->
name|numCol
operator|)
return|;
name|nrb
operator|=
name|lp
operator|->
name|GetDefaultNumFloatingReconBuffers
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|nrb
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * creates and initializes a reconstruction buffer  *****************************************************************************/
end_comment

begin_function
name|RF_ReconBuffer_t
modifier|*
name|rf_MakeReconBuffer
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_RbufType_t
name|type
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|t
decl_stmt|;
name|u_int
name|recon_buffer_size
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|layoutPtr
operator|->
name|SUsPerRU
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|)
decl_stmt|;
name|RF_Malloc
argument_list|(
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconBuffer_t
argument_list|)
argument_list|,
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|t
operator|->
name|buffer
argument_list|,
name|recon_buffer_size
argument_list|,
operator|(
name|caddr_t
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|t
operator|->
name|arrived
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|raidPtr
operator|=
name|raidPtr
expr_stmt|;
name|t
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|t
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|t
operator|->
name|priority
operator|=
name|RF_IO_RECON_PRIORITY
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|pssPtr
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * frees a reconstruction buffer  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_FreeReconBuffer
parameter_list|(
name|rbuf
parameter_list|)
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|rbuf
operator|->
name|raidPtr
decl_stmt|;
name|u_int
name|recon_buffer_size
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerRU
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
decl_stmt|;
name|RF_Free
argument_list|(
name|rbuf
operator|->
name|arrived
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|rbuf
operator|->
name|buffer
argument_list|,
name|recon_buffer_size
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * debug only:  sanity check the number of floating recon bufs in use  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CheckFloatingRbufCount
parameter_list|(
name|raidPtr
parameter_list|,
name|dolock
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|dolock
decl_stmt|;
block|{
name|RF_ReconParityStripeStatus_t
modifier|*
name|p
decl_stmt|;
name|RF_PSStatusHeader_t
modifier|*
name|pssTable
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sum
init|=
literal|0
decl_stmt|;
name|RF_RowCol_t
name|frow
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|raidPtr
operator|->
name|reconControl
index|[
name|i
index|]
condition|)
block|{
name|frow
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|RF_ASSERT
argument_list|(
name|frow
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|pssTable
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|pssTable
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|pssTableSize
condition|;
name|i
operator|++
control|)
block|{
name|RF_LOCK_MUTEX
argument_list|(
name|pssTable
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pssTable
index|[
name|i
index|]
operator|.
name|chain
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|rbuf
operator|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|p
operator|->
name|rbuf
expr_stmt|;
if|if
condition|(
name|rbuf
operator|&&
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
name|rbuf
operator|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|p
operator|->
name|writeRbuf
expr_stmt|;
if|if
condition|(
name|rbuf
operator|&&
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p
operator|->
name|xorBufCount
condition|;
name|j
operator|++
control|)
block|{
name|rbuf
operator|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|p
operator|->
name|rbufsForXor
index|[
name|j
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
block|}
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|pssTable
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rbuf
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|floatingRbufs
init|;
name|rbuf
condition|;
name|rbuf
operator|=
name|rbuf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
block|}
for|for
control|(
name|rbuf
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|committedRbufs
init|;
name|rbuf
condition|;
name|rbuf
operator|=
name|rbuf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
block|}
for|for
control|(
name|rbuf
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|fullBufferList
init|;
name|rbuf
condition|;
name|rbuf
operator|=
name|rbuf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
block|}
for|for
control|(
name|rbuf
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|priorityList
init|;
name|rbuf
condition|;
name|rbuf
operator|=
name|rbuf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|sum
operator|++
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|sum
operator|==
name|raidPtr
operator|->
name|numFloatingReconBufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

