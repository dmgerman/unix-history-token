begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_dagffwr.c,v 1.5 2000/01/07 03:40:58 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, Daniel Stodolsky, William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * rf_dagff.c  *  * code for creating fault-free DAGs  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffwr.h>
end_include

begin_comment
comment|/******************************************************************************  *  * General comments on DAG creation:  *  * All DAGs in this file use roll-away error recovery.  Each DAG has a single  * commit node, usually called "Cmt."  If an error occurs before the Cmt node  * is reached, the execution engine will halt forward execution and work  * backward through the graph, executing the undo functions.  Assuming that  * each node in the graph prior to the Cmt node are undoable and atomic - or -  * does not make changes to permanent state, the graph will fail atomically.  * If an error occurs after the Cmt node executes, the engine will roll-forward  * through the graph, blindly executing nodes until it reaches the end.  * If a graph reaches the end, it is assumed to have completed successfully.  *  * A graph has only 1 Cmt node.  *  */
end_comment

begin_comment
comment|/******************************************************************************  *  * The following wrappers map the standard DAG creation interface to the  * DAG creation routines.  Additionally, these wrappers enable experimentation  * with new DAG structures by providing an extra level of indirection, allowing  * the DAG creation routines to be replaced at this single point.  */
end_comment

begin_function
name|void
name|rf_CreateNonRedundantWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|)
block|{
name|rf_CreateNonredundantDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
name|RF_IO_TYPE_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateRAID0WriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|)
block|{
name|rf_CreateNonredundantDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
name|RF_IO_TYPE_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateSmallWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
comment|/* "normal" rollaway */
name|rf_CommonCreateSmallWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
operator|&
name|rf_xorFuncs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateLargeWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
comment|/* "normal" rollaway */
name|rf_CommonCreateLargeWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
literal|1
argument_list|,
name|rf_RegularXorFunc
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * DAG creation code begins here  */
end_comment

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a large-write operation:  *  *           / Rod \           / Wnd \  * H -- block- Rod - Xor - Cmt - Wnd --- T  *           \ Rod /          \  Wnp /  *                             \[Wnq]/  *  * The XOR node also does the Q calculation in the P+Q architecture.  * All nodes are before the commit node (Cmt) are assumed to be atomic and  * undoable - or - they make no changes to permanent state.  *  * Rod = read old data  * Cmt = commit node  * Wnp = write new parity  * Wnd = write new data  * Wnq = write new "q"  * [] denotes optional segments in the graph  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (holds write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *              nfaults   - number of faults array can tolerate  *                          (equal to # redundancy units in stripe)  *              redfuncs  - list of redundancy generating functions  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CommonCreateLargeWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|int
name|nfaults
parameter_list|,
name|int
function_decl|(
modifier|*
name|redFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
parameter_list|,
name|int
name|allowBufferRecycle
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wndNodes
decl_stmt|,
modifier|*
name|rodNodes
decl_stmt|,
modifier|*
name|xorNode
decl_stmt|,
modifier|*
name|wnpNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|wnqNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|int
name|nWndNodes
decl_stmt|,
name|nRodNodes
decl_stmt|,
name|i
decl_stmt|,
name|nodeNum
decl_stmt|,
name|asmNum
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|new_asm_h
index|[
literal|2
index|]
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|char
modifier|*
name|sosBuffer
decl_stmt|,
modifier|*
name|eosBuffer
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|layoutPtr
operator|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
expr_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating large-write DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|dag_h
operator|->
name|creator
operator|=
literal|"LargeWriteDAG"
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* alloc the nodes: Wnd, xor, commit, block, term, and  Wnp */
name|nWndNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nWndNodes
operator|+
literal|4
operator|+
name|nfaults
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|wndNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWndNodes
expr_stmt|;
name|xorNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|wnpNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|wnqNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wnqNode
operator|=
name|NULL
expr_stmt|;
block|}
name|rf_MapUnaccessedPortionOfStripe
argument_list|(
name|raidPtr
argument_list|,
name|layoutPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|new_asm_h
argument_list|,
operator|&
name|nRodNodes
argument_list|,
operator|&
name|sosBuffer
argument_list|,
operator|&
name|eosBuffer
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
name|RF_CallocAndAdd
argument_list|(
name|rodNodes
argument_list|,
name|nRodNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rodNodes
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* begin node initialization */
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nRodNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nWndNodes
operator|+
name|nfaults
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nWndNodes
operator|+
name|nfaults
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize the Rod nodes */
for|for
control|(
name|nodeNum
operator|=
name|asmNum
operator|=
literal|0
init|;
name|asmNum
operator|<
literal|2
condition|;
name|asmNum
operator|++
control|)
block|{
if|if
condition|(
name|new_asm_h
index|[
name|asmNum
index|]
condition|)
block|{
name|pda
operator|=
name|new_asm_h
index|[
name|asmNum
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
expr_stmt|;
while|while
condition|(
name|pda
condition|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rodNodes
index|[
name|nodeNum
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|nodeNum
operator|++
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|RF_ASSERT
argument_list|(
name|nodeNum
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
comment|/* initialize the wnd nodes */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wndNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize the redundancy node */
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
name|rf_InitNode
argument_list|(
name|xorNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|redFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nRodNodes
argument_list|,
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
operator|+
literal|1
argument_list|,
name|nfaults
argument_list|,
name|dag_h
argument_list|,
literal|"Xr "
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf_InitNode
argument_list|(
name|xorNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|redFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
operator|+
literal|1
argument_list|,
name|nfaults
argument_list|,
name|dag_h
argument_list|,
literal|"Xr "
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
name|xorNode
operator|->
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buf ptr */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buf ptr */
block|}
comment|/* xor node needs to get at RAID information */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/*          * Look for an Rod node that reads a complete SU. If none, alloc a buffer          * to receive the parity info. Note that we can't use a new data buffer          * because it will not have gotten written when the xor occurs.          */
if|if
condition|(
name|allowBufferRecycle
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
operator|==
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|allowBufferRecycle
operator|)
operator|||
operator|(
name|i
operator|==
name|nRodNodes
operator|)
condition|)
block|{
name|RF_CallocAndAdd
argument_list|(
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
block|}
comment|/* initialize the Wnp node */
name|rf_InitNode
argument_list|(
name|wnpNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
comment|/* parityInfo must describe entire parity unit */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
comment|/* 	         * We never try to recycle a buffer for the Q calcuation 	         * in addition to the parity. This would cause two buffers 	         * to get smashed during the P and Q calculation, guaranteeing 	         * one would be wrong. 	         */
name|RF_CallocAndAdd
argument_list|(
name|xorNode
operator|->
name|results
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|wnqNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNode
operator|->
name|results
index|[
literal|1
index|]
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
comment|/* parityInfo must describe entire parity unit */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*          * Connect nodes to form graph.          */
comment|/* connect dag header to block node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
comment|/* connect the block node to the Rod nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numAntecedents
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rodNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|rodNodes
index|[
name|i
index|]
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect the Rod nodes to the Xor node */
name|RF_ASSERT
argument_list|(
name|rodNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|rodNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* connect the block node to the Xor node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the xor node to the commit node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect the commit node to the write nodes */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
name|nWndNodes
operator|+
name|nfaults
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|wnpNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|nWndNodes
index|]
operator|=
name|wnpNode
expr_stmt|;
name|wnpNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wnpNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|wnqNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|wnqNode
expr_stmt|;
name|wnqNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wnqNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* connect the write nodes to the term node */
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
name|nWndNodes
operator|+
name|nfaults
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|wnpNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wnpNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|nWndNodes
index|]
operator|=
name|wnpNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|nWndNodes
index|]
operator|=
name|rf_control
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|wnqNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|wnqNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a small-write operation (either raid 5 or pq),  * which is as follows:  *  * Hdr -> Nil -> Rop -> Xor -> Cmt ----> Wnp [Unp] --> Trm  *            \- Rod X      /     \----> Wnd [Und]-/  *           [\- Rod X     /       \---> Wnd [Und]-/]  *           [\- Roq -> Q /         \--> Wnq [Unq]-/]  *  * Rop = read old parity  * Rod = read old data  * Roq = read old "q"  * Cmt = commit node  * Und = unlock data disk  * Unp = unlock parity disk  * Unq = unlock q disk  * Wnp = write new parity  * Wnd = write new data  * Wnq = write new "q"  * [ ] denotes optional segments in the graph  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (holds write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *              pfuncs    - list of parity generating functions  *              qfuncs    - list of q generating functions  *  * A null qfuncs indicates single fault tolerant  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CommonCreateSmallWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|pfuncs
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|qfuncs
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|readDataNodes
decl_stmt|,
modifier|*
name|readParityNodes
decl_stmt|,
modifier|*
name|readQNodes
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|unlockDataNodes
decl_stmt|,
modifier|*
name|unlockParityNodes
decl_stmt|,
modifier|*
name|unlockQNodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|xorNodes
decl_stmt|,
modifier|*
name|qNodes
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|nodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|writeDataNodes
decl_stmt|,
modifier|*
name|writeParityNodes
decl_stmt|,
modifier|*
name|writeQNodes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nNodes
decl_stmt|,
name|totalNumNodes
decl_stmt|,
name|lu_flag
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
decl_stmt|,
argument_list|(
operator|*
name|undoFunc
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
decl_stmt|;
name|int
function_decl|(
modifier|*
name|qfunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|numDataNodes
decl_stmt|,
name|numParityNodes
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|;
name|long
name|nfaults
decl_stmt|;
name|nfaults
operator|=
name|qfuncs
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|lu_flag
operator|=
operator|(
name|rf_enableAtomicRMW
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* lock/unlock flag */
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
name|numDataNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|numParityNodes
operator|=
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating small-write DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|numDataNodes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"SmallWriteDAG"
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/*          * DAG creation occurs in four steps:          * 1. count the number of nodes in the DAG          * 2. create the nodes          * 3. initialize the nodes          * 4. connect the nodes          */
comment|/*          * Step 1. compute number of nodes in the graph          */
comment|/* number of nodes: a read and write for each data unit a redundancy 	 * computation node for each parity node (nfaults * nparity) a read 	 * and write for each parity unit a block and commit node (2) a 	 * terminate node if atomic RMW an unlock node for each data unit, 	 * redundancy unit */
name|totalNumNodes
operator|=
operator|(
literal|2
operator|*
name|numDataNodes
operator|)
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|+
operator|(
name|nfaults
operator|*
literal|2
operator|*
name|numParityNodes
operator|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
name|totalNumNodes
operator|+=
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
expr_stmt|;
block|}
comment|/*          * Step 2. create the nodes          */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|totalNumNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|readDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|readParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|writeDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|writeParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|xorNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
name|unlockDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|unlockParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
block|}
else|else
block|{
name|unlockDataNodes
operator|=
name|unlockParityNodes
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|readQNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|writeQNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|qNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
name|unlockQNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
block|}
else|else
block|{
name|unlockQNodes
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|readQNodes
operator|=
name|writeQNodes
operator|=
name|qNodes
operator|=
name|unlockQNodes
operator|=
name|NULL
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|totalNumNodes
argument_list|)
expr_stmt|;
comment|/*          * Step 3. initialize the nodes          */
comment|/* initialize block node (Nil) */
name|nNodes
operator|=
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize commit node (Cmt) */
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nNodes
argument_list|,
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize terminate node (Trm) */
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize nodes which read old data (Rod) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|readDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* physical disk addr desc */
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* buffer to hold old data */
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
condition|;
name|j
operator|++
control|)
block|{
name|readDataNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* initialize nodes which read old parity (Rop) */
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|readParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
name|numParityNodes
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rop"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* buffer to hold old parity */
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
condition|;
name|j
operator|++
control|)
block|{
name|readParityNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* initialize nodes which read old Q (Roq) */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|readQNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
name|numParityNodes
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Roq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* buffer to hold old Q */
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|readQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
condition|;
name|j
operator|++
control|)
block|{
name|readQNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize nodes which write new data (Wnd) */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|writeDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* physical disk addr desc */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* buffer holding new data to be written */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Und"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* physical disk addr desc */
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/*          * Initialize nodes which compute new parity and Q.          */
comment|/*          * We use the simple XOR func in the double-XOR case, and when          * we're accessing only a portion of one stripe unit. The distinction          * between the two is that the regular XOR func assumes that the targbuf          * is a full SU in size, and examines the pda associated with the buffer          * to decide where within the buffer to XOR the data, whereas          * the simple XOR func just XORs the data into the start of the buffer.          */
if|if
condition|(
operator|(
name|numParityNodes
operator|==
literal|2
operator|)
operator|||
operator|(
operator|(
name|numDataNodes
operator|==
literal|1
operator|)
operator|&&
operator|(
name|asmap
operator|->
name|totalSectorsAccessed
operator|<
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
operator|)
condition|)
block|{
name|func
operator|=
name|pfuncs
operator|->
name|simple
expr_stmt|;
name|undoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|name
operator|=
name|pfuncs
operator|->
name|SimpleName
expr_stmt|;
if|if
condition|(
name|qfuncs
condition|)
block|{
name|qfunc
operator|=
name|qfuncs
operator|->
name|simple
expr_stmt|;
name|qname
operator|=
name|qfuncs
operator|->
name|SimpleName
expr_stmt|;
block|}
else|else
block|{
name|qfunc
operator|=
name|NULL
expr_stmt|;
name|qname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|func
operator|=
name|pfuncs
operator|->
name|regular
expr_stmt|;
name|undoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|name
operator|=
name|pfuncs
operator|->
name|RegularName
expr_stmt|;
if|if
condition|(
name|qfuncs
condition|)
block|{
name|qfunc
operator|=
name|qfuncs
operator|->
name|regular
expr_stmt|;
name|qname
operator|=
name|qfuncs
operator|->
name|RegularName
expr_stmt|;
block|}
else|else
block|{
name|qfunc
operator|=
name|NULL
expr_stmt|;
name|qname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*          * Initialize the xor nodes: params are {pda,buf}          * from {Rod,Wnd,Rop} nodes, and raidPtr          */
if|if
condition|(
name|numParityNodes
operator|==
literal|2
condition|)
block|{
comment|/* double-xor case */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* note: no wakeup func for xor */
name|rf_InitNode
argument_list|(
operator|&
name|xorNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|func
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|numDataNodes
operator|+
name|numParityNodes
operator|)
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|6
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* use old parity buf as target buf */
name|xorNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
comment|/* note: no wakeup func for qor */
name|rf_InitNode
argument_list|(
operator|&
name|qNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|qfunc
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|numDataNodes
operator|+
name|numParityNodes
operator|)
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|qname
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|6
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* use old Q buf as target buf */
name|qNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* there is only one xor node in this case */
name|rf_InitNode
argument_list|(
operator|&
name|xorNodes
index|[
literal|0
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|func
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|numDataNodes
operator|+
name|numParityNodes
operator|)
argument_list|,
operator|(
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|xorNodes
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Rod and Rop nodes */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer ptr */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Wnd and Wnp nodes */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
comment|/* pda */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
comment|/* buffer ptr */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* xor node needs to get at RAID information */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|xorNodes
index|[
literal|0
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readParityNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|qNodes
index|[
literal|0
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|qfunc
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|numDataNodes
operator|+
name|numParityNodes
operator|)
argument_list|,
operator|(
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|qname
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Rod */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer ptr */
block|}
comment|/* and read old q */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|numDataNodes
operator|+
literal|0
index|]
operator|=
comment|/* pda */
name|readQNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|numDataNodes
operator|+
literal|1
index|]
operator|=
comment|/* buffer ptr */
name|readQNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Wnd nodes */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
comment|/* pda */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
comment|/* buffer ptr */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* xor node needs to get at RAID information */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|qNodes
index|[
literal|0
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readQNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
block|}
block|}
comment|/* initialize nodes which write new parity (Wnp) */
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|writeParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* param 1 (bufPtr) 							 * filled in by xor node */
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
expr_stmt|;
comment|/* buffer pointer for 										 * parity write 										 * operation */
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Unp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 								 * desc */
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize nodes which write new Q (Wnq) */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|writeQNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* param 1 (bufPtr) 								 * filled in by xor node */
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|qNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
expr_stmt|;
comment|/* buffer pointer for 										 * parity write 										 * operation */
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockQNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Unq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 									 * desc */
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/*          * Step 4. connect the nodes.          */
comment|/* connect header to block node */
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect block node to read old data nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|numParityNodes
operator|*
name|nfaults
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect block node to read old parity nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect block node to read old Q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readQNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readQNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
comment|/* connect read old data nodes to xor nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|xorNodes
index|[
name|j
index|]
operator|.
name|numAntecedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|xorNodes
index|[
name|j
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
comment|/* connect read old data nodes to q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|qNodes
index|[
name|j
index|]
operator|.
name|numAntecedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|numParityNodes
operator|+
name|j
index|]
operator|=
operator|&
name|qNodes
index|[
name|j
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
block|}
comment|/* connect read old parity nodes to xor nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|readParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|xorNodes
index|[
name|j
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
comment|/* connect read old q nodes to q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|readQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|qNodes
index|[
name|j
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readQNodes
index|[
name|i
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
block|}
comment|/* connect xor nodes to commit node */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|xorNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|xorNodes
index|[
name|i
index|]
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect q nodes to commit node */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|qNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
name|i
operator|+
name|numParityNodes
index|]
operator|=
operator|&
name|qNodes
index|[
name|i
index|]
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
name|i
operator|+
name|numParityNodes
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
comment|/* connect commit node to write nodes */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
operator|+
name|numDataNodes
index|]
operator|=
operator|&
name|writeParityNodes
index|[
name|i
index|]
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|writeQNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
operator|+
name|numDataNodes
operator|+
name|numParityNodes
index|]
operator|=
operator|&
name|writeQNodes
index|[
name|i
index|]
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new data nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to term node */
name|RF_ASSERT
argument_list|(
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|unlockDataNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
comment|/* connect write new data nodes to term node */
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new parity nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockParityNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeParityNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to term node */
name|RF_ASSERT
argument_list|(
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|unlockParityNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|writeParityNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new Q nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockQNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeQNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to unblock node */
name|RF_ASSERT
argument_list|(
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
operator|&
name|unlockQNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|writeQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
operator|&
name|writeQNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * create a write graph (fault-free or degraded) for RAID level 1  *  * Hdr -> Commit -> Wpd -> Nil -> Trm  *               -> Wsd ->  *  * The "Wpd" node writes data to the primary copy in the mirror pair  * The "Wsd" node writes data to the secondary copy in the mirror pair  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (holds write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CreateRaidOneWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wndNode
decl_stmt|,
modifier|*
name|wmirNode
decl_stmt|;
name|int
name|nWndNodes
decl_stmt|,
name|nWmirNodes
decl_stmt|,
name|i
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|pdaP
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating RAID level 1 write DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|dag_h
operator|->
name|creator
operator|=
literal|"RaidOneWriteDAG"
expr_stmt|;
comment|/* 2 implies access not SU aligned */
name|nWmirNodes
operator|=
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|nWndNodes
operator|=
operator|(
name|asmap
operator|->
name|physInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* alloc the Wnd nodes and the Wmir node */
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
condition|)
name|nWndNodes
operator|--
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|numParityFailed
operator|==
literal|1
condition|)
name|nWmirNodes
operator|--
expr_stmt|;
comment|/* total number of nodes = nWndNodes + nWmirNodes + (commit + unblock 	 * + terminator) */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nWndNodes
operator|+
name|nWmirNodes
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|wndNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWndNodes
expr_stmt|;
name|wmirNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWmirNodes
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|unblockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|i
operator|==
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
comment|/* this dag can commit immediately */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* initialize the commit, unblock, and term nodes */
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize the wnd nodes */
if|if
condition|(
name|nWndNodes
operator|>
literal|0
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wndNode
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wpd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the mirror nodes */
if|if
condition|(
name|nWmirNodes
operator|>
literal|0
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
name|pdaP
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWmirNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wmirNode
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wsd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pdaP
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
name|pdaP
operator|=
name|pdaP
operator|->
name|next
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pdaP
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* link the header node to the commit node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
comment|/* link the commit node to the write nodes */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNode
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNode
index|[
name|i
index|]
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWmirNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wmirNode
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
operator|+
name|nWndNodes
index|]
operator|=
operator|&
name|wmirNode
index|[
name|i
index|]
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link the write nodes to the unblock node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numAntecedents
operator|==
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNode
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNode
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWmirNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wmirNode
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
operator|+
name|nWndNodes
index|]
operator|=
operator|&
name|wmirNode
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
operator|+
name|nWndNodes
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link the unblock node to the term node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DAGs which have no commit points.  *  * The following DAGs are used in forward and backward error recovery experiments.  * They are identical to the DAGs above this comment with the exception that the  * the commit points have been removed.  */
end_comment

begin_function
name|void
name|rf_CommonCreateLargeWriteDAGFwd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|int
name|nfaults
parameter_list|,
name|int
function_decl|(
modifier|*
name|redFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
parameter_list|,
name|int
name|allowBufferRecycle
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wndNodes
decl_stmt|,
modifier|*
name|rodNodes
decl_stmt|,
modifier|*
name|xorNode
decl_stmt|,
modifier|*
name|wnpNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|wnqNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|syncNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|int
name|nWndNodes
decl_stmt|,
name|nRodNodes
decl_stmt|,
name|i
decl_stmt|,
name|nodeNum
decl_stmt|,
name|asmNum
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|new_asm_h
index|[
literal|2
index|]
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|char
modifier|*
name|sosBuffer
decl_stmt|,
modifier|*
name|eosBuffer
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|layoutPtr
operator|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
expr_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating large-write DAG]\n"
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"LargeWriteDAGFwd"
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* alloc the nodes: Wnd, xor, commit, block, term, and  Wnp */
name|nWndNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nWndNodes
operator|+
literal|4
operator|+
name|nfaults
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|wndNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWndNodes
expr_stmt|;
name|xorNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|wnpNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|syncNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|wnqNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wnqNode
operator|=
name|NULL
expr_stmt|;
block|}
name|rf_MapUnaccessedPortionOfStripe
argument_list|(
name|raidPtr
argument_list|,
name|layoutPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|new_asm_h
argument_list|,
operator|&
name|nRodNodes
argument_list|,
operator|&
name|sosBuffer
argument_list|,
operator|&
name|eosBuffer
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
name|RF_CallocAndAdd
argument_list|(
name|rodNodes
argument_list|,
name|nRodNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rodNodes
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* begin node initialization */
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nRodNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|syncNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nWndNodes
operator|+
literal|1
argument_list|,
name|nRodNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|syncNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nWndNodes
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nWndNodes
operator|+
name|nfaults
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize the Rod nodes */
for|for
control|(
name|nodeNum
operator|=
name|asmNum
operator|=
literal|0
init|;
name|asmNum
operator|<
literal|2
condition|;
name|asmNum
operator|++
control|)
block|{
if|if
condition|(
name|new_asm_h
index|[
name|asmNum
index|]
condition|)
block|{
name|pda
operator|=
name|new_asm_h
index|[
name|asmNum
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
expr_stmt|;
while|while
condition|(
name|pda
condition|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rodNodes
index|[
name|nodeNum
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|nodeNum
operator|++
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|RF_ASSERT
argument_list|(
name|nodeNum
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
comment|/* initialize the wnd nodes */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wndNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize the redundancy node */
name|rf_InitNode
argument_list|(
name|xorNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|redFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nfaults
argument_list|,
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
operator|+
literal|1
argument_list|,
name|nfaults
argument_list|,
name|dag_h
argument_list|,
literal|"Xr "
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buf ptr */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buf ptr */
block|}
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* xor node needs to get 									 * at RAID information */
comment|/* look for an Rod node that reads a complete SU.  If none, alloc a 	 * buffer to receive the parity info. Note that we can't use a new 	 * data buffer because it will not have gotten written when the xor 	 * occurs. */
if|if
condition|(
name|allowBufferRecycle
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
operator|==
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
condition|)
break|break;
block|}
if|if
condition|(
operator|(
operator|!
name|allowBufferRecycle
operator|)
operator|||
operator|(
name|i
operator|==
name|nRodNodes
operator|)
condition|)
block|{
name|RF_CallocAndAdd
argument_list|(
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
comment|/* initialize the Wnp node */
name|rf_InitNode
argument_list|(
name|wnpNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* parityInfo must 							 * describe entire 							 * parity unit */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
comment|/* we never try to recycle a buffer for the Q calcuation in 		 * addition to the parity. This would cause two buffers to get 		 * smashed during the P and Q calculation, guaranteeing one 		 * would be wrong. */
name|RF_CallocAndAdd
argument_list|(
name|xorNode
operator|->
name|results
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|wnqNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNode
operator|->
name|results
index|[
literal|1
index|]
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* parityInfo must 								 * describe entire 								 * parity unit */
block|}
comment|/* connect nodes to form graph */
comment|/* connect dag header to block node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
block|{
comment|/* connect the block node to the Rod nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|syncNode
operator|->
name|numAntecedents
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rodNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|rodNodes
index|[
name|i
index|]
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect the Rod nodes to the Nil node */
name|RF_ASSERT
argument_list|(
name|rodNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|syncNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|rodNodes
index|[
name|i
index|]
expr_stmt|;
name|syncNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* connect the block node to the Nil node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|syncNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|syncNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|syncNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the sync node to the Wnd nodes */
name|RF_ASSERT
argument_list|(
name|syncNode
operator|->
name|numSuccedents
operator|==
operator|(
literal|1
operator|+
name|nWndNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|syncNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the sync node to the Xor node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|syncNode
operator|->
name|succedents
index|[
name|nWndNodes
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect the xor node to the write parity node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numSuccedents
operator|==
name|nfaults
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|wnpNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|wnpNode
expr_stmt|;
name|wnpNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|wnpNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|wnqNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|succedents
index|[
literal|1
index|]
operator|=
name|wnqNode
expr_stmt|;
name|wnqNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|wnqNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* connect the write nodes to the term node */
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
name|nWndNodes
operator|+
name|nfaults
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|wnpNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wnpNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|nWndNodes
index|]
operator|=
name|wnpNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|nWndNodes
index|]
operator|=
name|rf_control
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|wnqNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|wnqNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a small-write operation (either raid 5 or pq),  * which is as follows:  *  * Hdr -> Nil -> Rop - Xor - Wnp [Unp] -- Trm  *            \- Rod X- Wnd [Und] -------/  *           [\- Rod X- Wnd [Und] ------/]  *           [\- Roq - Q --> Wnq [Unq]-/]  *  * Rop = read old parity  * Rod = read old data  * Roq = read old "q"  * Cmt = commit node  * Und = unlock data disk  * Unp = unlock parity disk  * Unq = unlock q disk  * Wnp = write new parity  * Wnd = write new data  * Wnq = write new "q"  * [ ] denotes optional segments in the graph  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (holds write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *              pfuncs    - list of parity generating functions  *              qfuncs    - list of q generating functions  *  * A null qfuncs indicates single fault tolerant  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CommonCreateSmallWriteDAGFwd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|pfuncs
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|qfuncs
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|readDataNodes
decl_stmt|,
modifier|*
name|readParityNodes
decl_stmt|,
modifier|*
name|readQNodes
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|unlockDataNodes
decl_stmt|,
modifier|*
name|unlockParityNodes
decl_stmt|,
modifier|*
name|unlockQNodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|xorNodes
decl_stmt|,
modifier|*
name|qNodes
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|nodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|writeDataNodes
decl_stmt|,
modifier|*
name|writeParityNodes
decl_stmt|,
modifier|*
name|writeQNodes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nNodes
decl_stmt|,
name|totalNumNodes
decl_stmt|,
name|lu_flag
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
decl_stmt|,
argument_list|(
operator|*
name|undoFunc
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
decl_stmt|;
name|int
function_decl|(
modifier|*
name|qfunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|numDataNodes
decl_stmt|,
name|numParityNodes
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|;
name|long
name|nfaults
decl_stmt|;
name|nfaults
operator|=
name|qfuncs
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|lu_flag
operator|=
operator|(
name|rf_enableAtomicRMW
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* lock/unlock flag */
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
name|numDataNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|numParityNodes
operator|=
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating small-write DAG]\n"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|numDataNodes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"SmallWriteDAGFwd"
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|qfunc
operator|=
name|NULL
expr_stmt|;
name|qname
operator|=
name|NULL
expr_stmt|;
comment|/* DAG creation occurs in four steps: 1. count the number of nodes in 	 * the DAG 2. create the nodes 3. initialize the nodes 4. connect the 	 * nodes */
comment|/* Step 1. compute number of nodes in the graph */
comment|/* number of nodes: a read and write for each data unit a redundancy 	 * computation node for each parity node (nfaults * nparity) a read 	 * and write for each parity unit a block node a terminate node if 	 * atomic RMW an unlock node for each data unit, redundancy unit */
name|totalNumNodes
operator|=
operator|(
literal|2
operator|*
name|numDataNodes
operator|)
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|+
operator|(
name|nfaults
operator|*
literal|2
operator|*
name|numParityNodes
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
name|totalNumNodes
operator|+=
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
expr_stmt|;
comment|/* Step 2. create the nodes */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|totalNumNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|readDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|readParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|writeDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|writeParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|xorNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
name|unlockDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|unlockParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
block|}
else|else
block|{
name|unlockDataNodes
operator|=
name|unlockParityNodes
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|readQNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|writeQNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|qNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
name|unlockQNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
block|}
else|else
block|{
name|unlockQNodes
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|readQNodes
operator|=
name|writeQNodes
operator|=
name|qNodes
operator|=
name|unlockQNodes
operator|=
name|NULL
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|totalNumNodes
argument_list|)
expr_stmt|;
comment|/* Step 3. initialize the nodes */
comment|/* initialize block node (Nil) */
name|nNodes
operator|=
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize terminate node (Trm) */
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize nodes which read old data (Rod) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|readDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
operator|(
name|numParityNodes
operator|*
name|nfaults
operator|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 							 * desc */
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* buffer to hold old 												 * data */
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
condition|;
name|j
operator|++
control|)
name|readDataNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* initialize nodes which read old parity (Rop) */
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|readParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
name|numParityNodes
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rop"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* buffer to hold old 													 * parity */
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
condition|;
name|j
operator|++
control|)
name|readParityNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize nodes which read old Q (Roq) */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|readQNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
name|numParityNodes
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Roq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* buffer to hold old Q */
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|readQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
condition|;
name|j
operator|++
control|)
name|readQNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* initialize nodes which write new data (Wnd) */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|writeDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 							 * desc */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
comment|/* buffer holding new 								 * data to be written */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Und"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 								 * desc */
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize nodes which compute new parity and Q */
comment|/* we use the simple XOR func in the double-XOR case, and when we're 	 * accessing only a portion of one stripe unit. the distinction 	 * between the two is that the regular XOR func assumes that the 	 * targbuf is a full SU in size, and examines the pda associated with 	 * the buffer to decide where within the buffer to XOR the data, 	 * whereas the simple XOR func just XORs the data into the start of 	 * the buffer. */
if|if
condition|(
operator|(
name|numParityNodes
operator|==
literal|2
operator|)
operator|||
operator|(
operator|(
name|numDataNodes
operator|==
literal|1
operator|)
operator|&&
operator|(
name|asmap
operator|->
name|totalSectorsAccessed
operator|<
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
operator|)
condition|)
block|{
name|func
operator|=
name|pfuncs
operator|->
name|simple
expr_stmt|;
name|undoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|name
operator|=
name|pfuncs
operator|->
name|SimpleName
expr_stmt|;
if|if
condition|(
name|qfuncs
condition|)
block|{
name|qfunc
operator|=
name|qfuncs
operator|->
name|simple
expr_stmt|;
name|qname
operator|=
name|qfuncs
operator|->
name|SimpleName
expr_stmt|;
block|}
block|}
else|else
block|{
name|func
operator|=
name|pfuncs
operator|->
name|regular
expr_stmt|;
name|undoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|name
operator|=
name|pfuncs
operator|->
name|RegularName
expr_stmt|;
if|if
condition|(
name|qfuncs
condition|)
block|{
name|qfunc
operator|=
name|qfuncs
operator|->
name|regular
expr_stmt|;
name|qname
operator|=
name|qfuncs
operator|->
name|RegularName
expr_stmt|;
block|}
block|}
comment|/* initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop} 	 * nodes, and raidPtr  */
if|if
condition|(
name|numParityNodes
operator|==
literal|2
condition|)
block|{
comment|/* double-xor case */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|xorNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|func
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
name|numParityNodes
argument_list|,
name|numParityNodes
operator|+
name|numDataNodes
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* no wakeup func for 																						 * xor */
name|xorNodes
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|6
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
comment|/* use old parity buf as 											 * target buf */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|qNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|qfunc
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
name|numParityNodes
argument_list|,
name|numParityNodes
operator|+
name|numDataNodes
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|qname
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* no wakeup func for 																							 * xor */
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|6
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
comment|/* use old Q buf as 											 * target buf */
block|}
block|}
block|}
else|else
block|{
comment|/* there is only one xor node in this case */
name|rf_InitNode
argument_list|(
operator|&
name|xorNodes
index|[
literal|0
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|func
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
name|numParityNodes
argument_list|,
name|numParityNodes
operator|+
name|numDataNodes
argument_list|,
operator|(
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|xorNodes
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Rod and Rop nodes */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Wnd and Wnp nodes */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
block|}
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* xor node needs to get 											 * at RAID information */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readParityNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|qNodes
index|[
literal|0
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|qfunc
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
name|numParityNodes
argument_list|,
name|numParityNodes
operator|+
name|numDataNodes
argument_list|,
operator|(
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|qname
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Rod */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
block|}
comment|/* and read old q */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|numDataNodes
operator|+
literal|0
index|]
operator|=
name|readQNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|numDataNodes
operator|+
literal|1
index|]
operator|=
name|readQNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Wnd nodes */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
block|}
name|qNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* xor node needs to get 												 * at RAID information */
name|qNodes
index|[
literal|0
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readQNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
block|}
block|}
comment|/* initialize nodes which write new parity (Wnp) */
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|writeParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
name|numParityNodes
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* param 1 (bufPtr) 							 * filled in by xor node */
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
expr_stmt|;
comment|/* buffer pointer for 										 * parity write 										 * operation */
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Unp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 								 * desc */
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize nodes which write new Q (Wnq) */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|writeQNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
name|numParityNodes
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* param 1 (bufPtr) 								 * filled in by xor node */
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|qNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
expr_stmt|;
comment|/* buffer pointer for 										 * parity write 										 * operation */
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockQNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Unq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 									 * desc */
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Step 4. connect the nodes */
comment|/* connect header to block node */
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect block node to read old data nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|numParityNodes
operator|*
name|nfaults
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect block node to read old parity nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect block node to read old Q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readQNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readQNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect read old data nodes to write new data nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
operator|(
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_antiData
expr_stmt|;
block|}
comment|/* connect read old data nodes to xor nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|xorNodes
index|[
name|j
index|]
operator|.
name|numAntecedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|1
operator|+
name|j
index|]
operator|=
operator|&
name|xorNodes
index|[
name|j
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
comment|/* connect read old data nodes to q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|qNodes
index|[
name|j
index|]
operator|.
name|numAntecedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|1
operator|+
name|numParityNodes
operator|+
name|j
index|]
operator|=
operator|&
name|qNodes
index|[
name|j
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* connect read old parity nodes to xor nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|xorNodes
index|[
name|j
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
comment|/* connect read old q nodes to q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
name|readQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|qNodes
index|[
name|j
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readQNodes
index|[
name|i
index|]
expr_stmt|;
name|qNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
comment|/* connect xor nodes to the write new parity nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|xorNodes
index|[
name|j
index|]
operator|.
name|numSuccedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|writeParityNodes
index|[
name|j
index|]
expr_stmt|;
name|writeParityNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|xorNodes
index|[
name|i
index|]
expr_stmt|;
name|writeParityNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
comment|/* connect q nodes to the write new q nodes */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|writeQNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
name|numParityNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|qNodes
index|[
name|j
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|qNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|writeQNodes
index|[
name|j
index|]
expr_stmt|;
name|writeQNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|qNodes
index|[
name|i
index|]
expr_stmt|;
name|writeQNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
block|}
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new data nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to term node */
name|RF_ASSERT
argument_list|(
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|unlockDataNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
comment|/* connect write new data nodes to term node */
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new parity nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockParityNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeParityNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to term node */
name|RF_ASSERT
argument_list|(
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unlockParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|unlockParityNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|writeParityNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new Q nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockQNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeQNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to unblock node */
name|RF_ASSERT
argument_list|(
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|unlockQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
operator|&
name|unlockQNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|writeQNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeQNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
operator|&
name|writeQNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|numParityNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * create a write graph (fault-free or degraded) for RAID level 1  *  * Hdr  Nil -> Wpd -> Nil -> Trm  *      Nil -> Wsd ->  *  * The "Wpd" node writes data to the primary copy in the mirror pair  * The "Wsd" node writes data to the secondary copy in the mirror pair  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (holds write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CreateRaidOneWriteDAGFwd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wndNode
decl_stmt|,
modifier|*
name|wmirNode
decl_stmt|;
name|int
name|nWndNodes
decl_stmt|,
name|nWmirNodes
decl_stmt|,
name|i
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|pdaP
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating RAID level 1 write DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|nWmirNodes
operator|=
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* 2 implies access not 							 * SU aligned */
name|nWndNodes
operator|=
operator|(
name|asmap
operator|->
name|physInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* alloc the Wnd nodes and the Wmir node */
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
condition|)
name|nWndNodes
operator|--
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|numParityFailed
operator|==
literal|1
condition|)
name|nWmirNodes
operator|--
expr_stmt|;
comment|/* total number of nodes = nWndNodes + nWmirNodes + (block + unblock + 	 * terminator) */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nWndNodes
operator|+
name|nWmirNodes
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|wndNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWndNodes
expr_stmt|;
name|wmirNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWmirNodes
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|unblockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|i
operator|==
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
comment|/* this dag can commit immediately */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* initialize the unblock and term nodes */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize the wnd nodes */
if|if
condition|(
name|nWndNodes
operator|>
literal|0
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wndNode
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wpd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the mirror nodes */
if|if
condition|(
name|nWmirNodes
operator|>
literal|0
condition|)
block|{
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
name|pdaP
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWmirNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wmirNode
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wsd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pdaP
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
name|pdaP
operator|=
name|pdaP
operator|->
name|next
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pdaP
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* link the header node to the block node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* link the block node to the write nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNode
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNode
index|[
name|i
index|]
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWmirNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wmirNode
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
operator|+
name|nWndNodes
index|]
operator|=
operator|&
name|wmirNode
index|[
name|i
index|]
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link the write nodes to the unblock node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numAntecedents
operator|==
operator|(
name|nWndNodes
operator|+
name|nWmirNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNode
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wndNode
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNode
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWmirNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wmirNode
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wmirNode
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
operator|+
name|nWndNodes
index|]
operator|=
operator|&
name|wmirNode
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
operator|+
name|nWndNodes
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link the unblock node to the term node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
return|return;
block|}
end_function

end_unit

