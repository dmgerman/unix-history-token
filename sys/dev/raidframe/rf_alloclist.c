begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_alloclist.c,v 1.4 1999/08/13 03:41:53 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/****************************************************************************  *  * Alloclist.c -- code to manipulate allocation lists  *  * an allocation list is just a list of AllocListElem structures.  Each  * such structure contains a fixed-size array of pointers.  Calling  * FreeAList() causes each pointer to be freed.  *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_macro
name|RF_DECLARE_STATIC_MUTEX
argument_list|(
argument|alist_mutex
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|fl_hit_count
decl_stmt|,
name|fl_miss_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RF_AllocListElem_t
modifier|*
name|al_free_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|al_free_list_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_AL_FREELIST_MAX
value|256
end_define

begin_define
define|#
directive|define
name|DO_FREE
parameter_list|(
name|_p
parameter_list|,
name|_sz
parameter_list|)
value|RF_Free((_p),(_sz))
end_define

begin_function_decl
specifier|static
name|void
name|rf_ShutdownAllocList
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownAllocList
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_AllocListElem_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
for|for
control|(
name|p
operator|=
name|al_free_list
init|;
name|p
condition|;
control|)
block|{
name|pt
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|DO_FREE
argument_list|(
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rf_mutex_destroy
argument_list|(
operator|&
name|alist_mutex
argument_list|)
expr_stmt|;
comment|/*         printf("Alloclist: Free list hit count %lu (%lu %%) miss count %lu (%lu %%)\n", 	       fl_hit_count, (100*fl_hit_count)/(fl_hit_count+fl_miss_count), 	       fl_miss_count, (100*fl_miss_count)/(fl_hit_count+fl_miss_count));         */
block|}
end_function

begin_function
name|int
name|rf_ConfigureAllocList
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|alist_mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|al_free_list
operator|=
name|NULL
expr_stmt|;
name|fl_hit_count
operator|=
name|fl_miss_count
operator|=
name|al_free_list_count
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownAllocList
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_mutex_destroy
argument_list|(
operator|&
name|alist_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* we expect the lists to have at most one or two elements, so we're willing  * to search for the end.  If you ever observe the lists growing longer,  * increase POINTERS_PER_ALLOC_LIST_ELEMENT.  */
end_comment

begin_function
name|void
name|rf_real_AddToAllocList
parameter_list|(
name|l
parameter_list|,
name|p
parameter_list|,
name|size
parameter_list|,
name|lockflag
parameter_list|)
name|RF_AllocListElem_t
modifier|*
name|l
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|lockflag
decl_stmt|;
block|{
name|RF_AllocListElem_t
modifier|*
name|newelem
decl_stmt|;
for|for
control|(
init|;
name|l
operator|->
name|next
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
name|RF_ASSERT
argument_list|(
name|l
operator|->
name|numPointers
operator|==
name|RF_POINTERS_PER_ALLOC_LIST_ELEMENT
argument_list|)
expr_stmt|;
comment|/* find end of list */
name|RF_ASSERT
argument_list|(
name|l
operator|->
name|numPointers
operator|>=
literal|0
operator|&&
name|l
operator|->
name|numPointers
operator|<=
name|RF_POINTERS_PER_ALLOC_LIST_ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|numPointers
operator|==
name|RF_POINTERS_PER_ALLOC_LIST_ELEMENT
condition|)
block|{
name|newelem
operator|=
name|rf_real_MakeAllocList
argument_list|(
name|lockflag
argument_list|)
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|newelem
expr_stmt|;
name|l
operator|=
name|newelem
expr_stmt|;
block|}
name|l
operator|->
name|pointers
index|[
name|l
operator|->
name|numPointers
index|]
operator|=
name|p
expr_stmt|;
name|l
operator|->
name|sizes
index|[
name|l
operator|->
name|numPointers
index|]
operator|=
name|size
expr_stmt|;
name|l
operator|->
name|numPointers
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* we use the debug_mem_mutex here because we need to lock it anyway to call free.  * this is probably a bug somewhere else in the code, but when I call malloc/free  * outside of any lock I have endless trouble with malloc appearing to return the  * same pointer twice.  Since we have to lock it anyway, we might as well use it  * as the lock around the al_free_list.  Note that we can't call Free with the  * debug_mem_mutex locked.  */
end_comment

begin_function
name|void
name|rf_FreeAllocList
parameter_list|(
name|l
parameter_list|)
name|RF_AllocListElem_t
modifier|*
name|l
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|temp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|l
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|RF_ASSERT
argument_list|(
name|p
operator|->
name|numPointers
operator|>=
literal|0
operator|&&
name|p
operator|->
name|numPointers
operator|<=
name|RF_POINTERS_PER_ALLOC_LIST_ELEMENT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|numPointers
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|p
operator|->
name|pointers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|p
operator|->
name|pointers
index|[
name|i
index|]
argument_list|,
name|p
operator|->
name|sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|l
condition|)
block|{
name|temp
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|al_free_list_count
operator|>
name|RF_AL_FREELIST_MAX
condition|)
block|{
name|DO_FREE
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|->
name|next
operator|=
name|al_free_list
expr_stmt|;
name|al_free_list
operator|=
name|temp
expr_stmt|;
name|al_free_list_count
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|RF_AllocListElem_t
modifier|*
name|rf_real_MakeAllocList
parameter_list|(
name|lockflag
parameter_list|)
name|int
name|lockflag
decl_stmt|;
block|{
name|RF_AllocListElem_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|al_free_list
condition|)
block|{
name|fl_hit_count
operator|++
expr_stmt|;
name|p
operator|=
name|al_free_list
expr_stmt|;
name|al_free_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|al_free_list_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fl_miss_count
operator|++
expr_stmt|;
name|RF_Malloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AllocListElem_t
argument_list|)
argument_list|,
operator|(
name|RF_AllocListElem_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* no allocation locking 											 * in kernel, so this is 											 * fine */
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AllocListElem_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

