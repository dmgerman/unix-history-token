begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_evenodd.c,v 1.4 2000/01/07 03:40:59 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chang-Ming Wu  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*****************************************************************************************  *  * rf_evenodd.c -- implements EVENODD array architecture  *  ****************************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_EVENODD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_pq.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_evenodd_dags.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|RF_EvenOddConfigInfo_s
block|{
name|RF_RowCol_t
modifier|*
modifier|*
name|stripeIdentifier
decl_stmt|;
comment|/* filled in at config time& used by 					 * IdentifyStripe */
block|}
name|RF_EvenOddConfigInfo_t
typedef|;
end_typedef

begin_function
name|int
name|rf_ConfigureEvenOdd
parameter_list|(
name|listp
parameter_list|,
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_EvenOddConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|RF_RowCol_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|startdisk
decl_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_EvenOddConfigInfo_t
argument_list|)
argument_list|,
operator|(
name|RF_EvenOddConfigInfo_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
name|layoutPtr
operator|->
name|layoutSpecificInfo
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|numRow
operator|==
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|stripeIdentifier
operator|=
name|rf_make_2d_array
argument_list|(
name|raidPtr
operator|->
name|numCol
argument_list|,
name|raidPtr
operator|->
name|numCol
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
name|startdisk
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|j
operator|++
control|)
block|{
name|info
operator|->
name|stripeIdentifier
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|startdisk
operator|+
name|j
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|startdisk
operator|-=
literal|2
operator|)
operator|<
literal|0
condition|)
name|startdisk
operator|+=
name|raidPtr
operator|->
name|numCol
expr_stmt|;
block|}
comment|/* fill in the remaining layout parameters */
name|layoutPtr
operator|->
name|numStripe
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
expr_stmt|;
name|layoutPtr
operator|->
name|bytesPerStripeUnit
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|layoutPtr
operator|->
name|numDataCol
operator|=
name|raidPtr
operator|->
name|numCol
operator|-
literal|2
expr_stmt|;
comment|/* ORIG: 							 * layoutPtr->numDataCol 							 * = raidPtr->numCol-1;  */
if|#
directive|if
name|RF_EO_MATRIX_DIM
operator|>
literal|17
if|if
condition|(
name|raidPtr
operator|->
name|numCol
operator|<=
literal|17
condition|)
block|{
name|printf
argument_list|(
literal|"Number of stripe units in a parity stripe is smaller than 17. Please\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"be 17 to increase performance. \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elif|#
directive|elif
name|RF_EO_MATRIX_DIM
operator|==
literal|17
if|if
condition|(
name|raidPtr
operator|->
name|numCol
operator|>
literal|17
condition|)
block|{
name|printf
argument_list|(
literal|"Number of stripe units in a parity stripe is bigger than 17. Please\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"be 257 for encoding and decoding functions to work. \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|layoutPtr
operator|->
name|dataSectorsPerStripe
operator|=
name|layoutPtr
operator|->
name|numDataCol
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|numParityCol
operator|=
literal|2
expr_stmt|;
name|layoutPtr
operator|->
name|dataStripeUnitsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
expr_stmt|;
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|raidPtr
operator|->
name|totalSectors
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
name|layoutPtr
operator|->
name|numDataCol
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_GetDefaultNumFloatingReconBuffersEvenOdd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
return|return
operator|(
literal|20
operator|)
return|;
block|}
end_function

begin_function
name|RF_HeadSepLimit_t
name|rf_GetDefaultHeadSepLimitEvenOdd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
return|return
operator|(
literal|10
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_IdentifyStripeEvenOdd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|addr
parameter_list|,
name|RF_RowCol_t
modifier|*
modifier|*
name|diskids
parameter_list|,
name|RF_RowCol_t
modifier|*
name|outRow
parameter_list|)
block|{
name|RF_StripeNum_t
name|stripeID
init|=
name|rf_RaidAddressToStripeID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RF_EvenOddConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_EvenOddConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
operator|*
name|outRow
operator|=
literal|0
expr_stmt|;
operator|*
name|diskids
operator|=
name|info
operator|->
name|stripeIdentifier
index|[
name|stripeID
operator|%
name|raidPtr
operator|->
name|numCol
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The layout of stripe unit on the disks are:      c0 c1 c2 c3 c4   						     0  1  2  E  P 						     5  E  P  3  4 						     P  6  7  8  E 	 					    10 11  E  P  9 						     E  P 12 13 14 						     ....    We use the MapSectorRAID5 to map data information because the routine can be shown to map exactly   the layout of data stripe unit as shown above although we have 2 redundant information now.   But for E and P, we use rf_MapEEvenOdd and rf_MapParityEvenOdd which are different method from raid-5. */
end_comment

begin_function
name|void
name|rf_MapParityEvenOdd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|endSUIDofthisStrip
init|=
operator|(
name|SUID
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|+
literal|1
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|-
literal|1
decl_stmt|;
operator|*
name|row
operator|=
literal|0
expr_stmt|;
operator|*
name|col
operator|=
operator|(
name|endSUIDofthisStrip
operator|+
literal|2
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|diskSector
operator|=
operator|(
name|SUID
operator|/
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_MapEEvenOdd
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_StripeNum_t
name|endSUIDofthisStrip
init|=
operator|(
name|SUID
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|+
literal|1
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|-
literal|1
decl_stmt|;
operator|*
name|row
operator|=
literal|0
expr_stmt|;
operator|*
name|col
operator|=
operator|(
name|endSUIDofthisStrip
operator|+
literal|1
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|diskSector
operator|=
operator|(
name|SUID
operator|/
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|+
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_EODagSelect
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_VoidFuncPtr
modifier|*
name|createFunc
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|unsigned
name|ndfail
init|=
name|asmap
operator|->
name|numDataFailed
decl_stmt|;
name|unsigned
name|npfail
init|=
name|asmap
operator|->
name|numParityFailed
operator|+
name|asmap
operator|->
name|numQFailed
decl_stmt|;
name|unsigned
name|ntfail
init|=
name|npfail
operator|+
name|ndfail
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntfail
operator|>
literal|2
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"more than two disks failed in a single group!  Aborting I/O operation.\n"
argument_list|)
expr_stmt|;
comment|/* *infoFunc = */
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* ok, we can do this I/O */
if|if
condition|(
name|type
operator|==
name|RF_IO_TYPE_READ
condition|)
block|{
switch|switch
condition|(
name|ndfail
condition|)
block|{
case|case
literal|0
case|:
comment|/* fault free read */
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateFaultFreeReadDAG
expr_stmt|;
comment|/* same as raid 5 */
break|break;
case|case
literal|1
case|:
comment|/* lost a single data unit */
comment|/* two cases: (1) parity is not lost. do a normal raid 			 * 5 reconstruct read. (2) parity is lost. do a 			 * reconstruct read using "e". */
if|if
condition|(
name|ntfail
operator|==
literal|2
condition|)
block|{
comment|/* also lost redundancy */
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_110_CreateReadDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_101_CreateReadDAG
expr_stmt|;
block|}
else|else
block|{
comment|/* P and E are ok. But is there a failure in 				 * some unaccessed data unit? */
if|if
condition|(
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
operator|==
literal|2
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_200_CreateReadDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_100_CreateReadDAG
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* *createFunc = rf_EO_200_CreateReadDAG; */
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|/* a write */
switch|switch
condition|(
name|ntfail
condition|)
block|{
case|case
literal|0
case|:
comment|/* fault free */
if|if
condition|(
name|rf_suppressLocksAndLargeWrites
operator|||
operator|(
operator|(
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|<=
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
operator|)
operator|&&
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|!=
literal|1
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|asmap
operator|->
name|qInfo
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|||
name|rf_CheckStripeForFailures
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
operator|)
condition|)
block|{
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EOCreateSmallWriteDAG
expr_stmt|;
block|}
else|else
block|{
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EOCreateLargeWriteDAG
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* single disk fault */
if|if
condition|(
name|npfail
operator|==
literal|1
condition|)
block|{
name|RF_ASSERT
argument_list|(
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
operator|)
operator|||
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
condition|)
block|{
comment|/* q died, treat like 										 * normal mode raid5 										 * write. */
if|if
condition|(
operator|(
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|<=
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|||
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_001_CreateSmallWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_001_CreateLargeWriteDAG
expr_stmt|;
block|}
else|else
block|{
comment|/* parity died, small write only updating Q */
if|if
condition|(
operator|(
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|<=
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|qInfo
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|||
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_010_CreateSmallWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_010_CreateLargeWriteDAG
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* data missing. Do a P reconstruct write if 				 * only a single data unit is lost in the 				 * stripe, otherwise a reconstruct write which 				 * employnig both P and E units. */
if|if
condition|(
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_200_CreateWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
comment|/* No direct support for 								 * this case now, like 								 * that in Raid-5  */
block|}
else|else
block|{
if|if
condition|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|!=
literal|1
operator|&&
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|numSector
operator|!=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
condition|)
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
comment|/* No direct support for 								 * this case now, like 								 * that in Raid-5  */
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_100_CreateWriteDAG
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
comment|/* two disk faults */
switch|switch
condition|(
name|npfail
condition|)
block|{
case|case
literal|2
case|:
comment|/* both p and q dead */
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_011_CreateWriteDAG
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* either p or q and dead data */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_DATA
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
operator|)
operator|||
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
condition|)
block|{
if|if
condition|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|!=
literal|1
operator|&&
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|numSector
operator|!=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
condition|)
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
comment|/* In both PQ and 								 * EvenOdd, no direct 								 * support for this case 								 * now, like that in 								 * Raid-5  */
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_101_CreateWriteDAG
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|!=
literal|1
operator|&&
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|numSector
operator|!=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
condition|)
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
comment|/* No direct support for 								 * this case, like that 								 * in Raid-5  */
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_EO_110_CreateWriteDAG
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* double data loss */
comment|/* if(asmap->failedPDAs[0]->numSector + 			 * asmap->failedPDAs[1]->numSector == 2 * 			 * layoutPtr->sectorsPerStripeUnit ) createFunc = 			 * rf_EOCreateLargeWriteDAG; else    							 */
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
comment|/* currently, in Evenodd, No 						 * support for simultaneous 						 * access of both failed SUs */
break|break;
block|}
break|break;
default|default:
comment|/* more than 2 disk faults */
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|rf_VerifyParityEvenOdd
parameter_list|(
name|raidPtr
parameter_list|,
name|raidAddr
parameter_list|,
name|parityPDA
parameter_list|,
name|correct_it
parameter_list|,
name|flags
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidAddr_t
name|raidAddr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|parityPDA
decl_stmt|;
name|int
name|correct_it
decl_stmt|;
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_RaidAddr_t
name|startAddr
init|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|)
decl_stmt|;
name|RF_SectorCount_t
name|numsector
init|=
name|parityPDA
operator|->
name|numSector
decl_stmt|;
name|int
name|numbytes
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|numsector
argument_list|)
decl_stmt|;
name|int
name|bytesPerStripe
init|=
name|numbytes
operator|*
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|rd_dag_h
decl_stmt|,
modifier|*
name|wr_dag_h
decl_stmt|;
comment|/* read, write dag */
name|RF_DagNode_t
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|wrBlock
decl_stmt|,
modifier|*
name|wrUnblock
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|alloclist
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|char
modifier|*
name|pbuf
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end_p
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|redundantbuf2
decl_stmt|;
name|int
name|redundantTwoErr
init|=
literal|0
decl_stmt|,
name|redundantOneErr
init|=
literal|0
decl_stmt|;
name|int
name|parity_cant_correct
init|=
name|RF_FALSE
decl_stmt|,
name|red2_cant_correct
init|=
name|RF_FALSE
decl_stmt|,
name|parity_corrected
init|=
name|RF_FALSE
decl_stmt|,
name|red2_corrected
init|=
name|RF_FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_StripeNum_t
name|psID
init|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|,
operator|&
name|which_ru
argument_list|)
decl_stmt|;
name|int
name|stripeWidth
init|=
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
decl_stmt|;
name|RF_AccTraceEntry_t
name|tracerec
decl_stmt|;
name|RF_MCPair_t
modifier|*
name|mcpair
decl_stmt|;
name|retcode
operator|=
name|RF_PARITY_OKAY
expr_stmt|;
name|mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|rf_MakeAllocList
argument_list|(
name|alloclist
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|buf
argument_list|,
name|numbytes
operator|*
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|pbuf
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
comment|/* use calloc to make 									 * sure buffer is zeroed */
name|end_p
operator|=
name|buf
operator|+
name|bytesPerStripe
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|redundantbuf2
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
comment|/* use calloc to make 										 * sure buffer is zeroed */
name|rd_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
name|stripeWidth
argument_list|,
name|numbytes
argument_list|,
name|buf
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
literal|"Rod"
argument_list|,
name|alloclist
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
name|blockNode
operator|=
name|rd_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|unblockNode
operator|=
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
comment|/* map the stripe and fill in the PDAs in the dag */
name|asm_h
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|startAddr
argument_list|,
name|layoutPtr
operator|->
name|dataSectorsPerStripe
argument_list|,
name|buf
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|asmap
operator|=
name|asm_h
operator|->
name|stripeMap
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* no way to verify parity if disk is 					 * dead.  return w/ good status */
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
operator|!
name|asmap
operator|->
name|parityInfo
operator|->
name|next
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|asmap
operator|->
name|parityInfo
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|asmap
operator|->
name|parityInfo
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|blockNode
operator|->
name|succedents
index|[
name|layoutPtr
operator|->
name|numDataCol
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
name|asmap
operator|->
name|qInfo
operator|->
name|next
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|asmap
operator|->
name|qInfo
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|qInfo
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|asmap
operator|->
name|qInfo
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* if disk is dead, b/c no reconstruction is implemented right now, 	 * the function "rf_TryToRedirectPDA" always return one, which cause 	 * go to out and return w/ good status   */
name|blockNode
operator|->
name|succedents
index|[
name|layoutPtr
operator|->
name|numDataCol
operator|+
literal|1
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
comment|/* fire off the DAG */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|rd_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"Parity verify read dag:\n"
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|rd_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DispatchDAG
argument_list|(
name|rd_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|mcpair
operator|->
name|cond
argument_list|,
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to verify parity:  can't read the stripe\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RF_PARITY_COULD_NOT_VERIFY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|p
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|p
operator|<
name|end_p
condition|;
name|p
operator|+=
name|numbytes
operator|,
name|i
operator|++
control|)
block|{
name|rf_e_encToBuf
argument_list|(
name|raidPtr
argument_list|,
name|i
argument_list|,
name|p
argument_list|,
name|RF_EO_MATRIX_DIM
operator|-
literal|2
argument_list|,
name|redundantbuf2
argument_list|,
name|numsector
argument_list|)
expr_stmt|;
comment|/* the corresponding columes in EvenOdd encoding Matrix for 		 * these p pointers which point to the databuffer in a full 		 * stripe are sequentially from 0 to layoutPtr->numDataCol-1 */
name|rf_bxor
argument_list|(
name|p
argument_list|,
name|pbuf
argument_list|,
name|numbytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|layoutPtr
operator|->
name|numDataCol
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbytes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pbuf
index|[
name|i
index|]
operator|!=
name|buf
index|[
name|bytesPerStripe
operator|+
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|correct_it
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Parity verify error: byte %d of parity is 0x%x should be 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|u_char
operator|)
name|buf
index|[
name|bytesPerStripe
operator|+
name|i
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|pbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|redundantOneErr
operator|=
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbytes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|redundantbuf2
index|[
name|i
index|]
operator|!=
name|buf
index|[
name|bytesPerStripe
operator|+
name|numbytes
operator|+
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|correct_it
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Parity verify error: byte %d of second redundant information is 0x%x should be 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|u_char
operator|)
name|buf
index|[
name|bytesPerStripe
operator|+
name|numbytes
operator|+
name|i
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|redundantbuf2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|redundantTwoErr
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|redundantOneErr
operator|||
name|redundantTwoErr
condition|)
name|retcode
operator|=
name|RF_PARITY_BAD
expr_stmt|;
comment|/* correct the first redundant disk, ie parity if it is error    */
if|if
condition|(
name|redundantOneErr
operator|&&
name|correct_it
condition|)
block|{
name|wr_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
name|pbuf
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
literal|"Wnp"
argument_list|,
name|alloclist
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
name|wrBlock
operator|=
name|wr_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|wrUnblock
operator|=
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|wr_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"Parity verify write dag:\n"
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DispatchDAG
argument_list|(
name|wr_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|mcpair
operator|->
name|cond
argument_list|,
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to correct parity in VerifyParity:  can't write the stripe\n"
argument_list|)
expr_stmt|;
name|parity_cant_correct
operator|=
name|RF_TRUE
expr_stmt|;
block|}
else|else
block|{
name|parity_corrected
operator|=
name|RF_TRUE
expr_stmt|;
block|}
name|rf_FreeDAG
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|redundantTwoErr
operator|&&
name|correct_it
condition|)
block|{
name|wr_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
name|redundantbuf2
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
literal|"Wnred2"
argument_list|,
name|alloclist
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
name|wrBlock
operator|=
name|wr_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|wrUnblock
operator|=
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|wr_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"Dag of write new second redundant information in parity verify :\n"
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DispatchDAG
argument_list|(
name|wr_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|mcpair
operator|->
name|cond
argument_list|,
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to correct second redundant information in VerifyParity:  can't write the stripe\n"
argument_list|)
expr_stmt|;
name|red2_cant_correct
operator|=
name|RF_TRUE
expr_stmt|;
block|}
else|else
block|{
name|red2_corrected
operator|=
name|RF_TRUE
expr_stmt|;
block|}
name|rf_FreeDAG
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|redundantOneErr
operator|&&
name|parity_cant_correct
operator|)
operator|||
operator|(
name|redundantTwoErr
operator|&&
name|red2_cant_correct
operator|)
condition|)
name|retcode
operator|=
name|RF_PARITY_COULD_NOT_CORRECT
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RF_PARITY_BAD
operator|)
operator|&&
name|parity_corrected
operator|&&
name|red2_corrected
condition|)
name|retcode
operator|=
name|RF_PARITY_CORRECTED
expr_stmt|;
name|out
label|:
name|rf_FreeAccessStripeMap
argument_list|(
name|asm_h
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|alloclist
argument_list|)
expr_stmt|;
name|rf_FreeDAG
argument_list|(
name|rd_dag_h
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|mcpair
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_EVENODD> 0 */
end_comment

end_unit

