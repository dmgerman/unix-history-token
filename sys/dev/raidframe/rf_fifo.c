begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_fifo.c,v 1.5 2000/03/04 03:27:13 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/***************************************************  *  * rf_fifo.c --  prioritized fifo queue code.  * There are only two priority levels: hi and lo.  *  * Aug 4, 1994, adapted from raidSim version (MCH)  *  ***************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_stripelocks.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_layout.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_fifo.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_options.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_comment
comment|/* just malloc a header, zero it (via calloc), and return it */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
modifier|*
name|rf_FifoCreate
parameter_list|(
name|sectPerDisk
parameter_list|,
name|clList
parameter_list|,
name|listp
parameter_list|)
name|RF_SectorCount_t
name|sectPerDisk
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|clList
decl_stmt|;
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|RF_FifoHeader_t
modifier|*
name|q
decl_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|q
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_FifoHeader_t
argument_list|)
argument_list|,
operator|(
name|RF_FifoHeader_t
operator|*
operator|)
argument_list|,
name|clList
argument_list|)
expr_stmt|;
name|q
operator|->
name|hq_count
operator|=
name|q
operator|->
name|lq_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|q
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FifoEnqueue
parameter_list|(
name|q_in
parameter_list|,
name|elem
parameter_list|,
name|priority
parameter_list|)
name|void
modifier|*
name|q_in
decl_stmt|;
name|RF_DiskQueueData_t
modifier|*
name|elem
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
name|RF_FifoHeader_t
modifier|*
name|q
init|=
operator|(
name|RF_FifoHeader_t
operator|*
operator|)
name|q_in
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|priority
operator|==
name|RF_IO_NORMAL_PRIORITY
operator|||
name|priority
operator|==
name|RF_IO_LOW_PRIORITY
argument_list|)
expr_stmt|;
name|elem
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|priority
operator|==
name|RF_IO_NORMAL_PRIORITY
condition|)
block|{
if|if
condition|(
operator|!
name|q
operator|->
name|hq_tail
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|hq_count
operator|==
literal|0
operator|&&
name|q
operator|->
name|hq_head
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|hq_head
operator|=
name|q
operator|->
name|hq_tail
operator|=
name|elem
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|hq_count
operator|!=
literal|0
operator|&&
name|q
operator|->
name|hq_head
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|hq_tail
operator|->
name|next
operator|=
name|elem
expr_stmt|;
name|q
operator|->
name|hq_tail
operator|=
name|elem
expr_stmt|;
block|}
name|q
operator|->
name|hq_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|elem
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_fifoDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: fifo: ENQ lopri\n"
argument_list|,
name|elem
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q
operator|->
name|lq_tail
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|lq_count
operator|==
literal|0
operator|&&
name|q
operator|->
name|lq_head
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|lq_head
operator|=
name|q
operator|->
name|lq_tail
operator|=
name|elem
expr_stmt|;
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|lq_count
operator|!=
literal|0
operator|&&
name|q
operator|->
name|lq_head
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|lq_tail
operator|->
name|next
operator|=
name|elem
expr_stmt|;
name|q
operator|->
name|lq_tail
operator|=
name|elem
expr_stmt|;
block|}
name|q
operator|->
name|lq_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|q
operator|->
name|hq_count
operator|+
name|q
operator|->
name|lq_count
operator|)
operator|!=
name|elem
operator|->
name|queue
operator|->
name|queueLength
condition|)
block|{
name|printf
argument_list|(
literal|"Queue lengths differ!: %d %d %d\n"
argument_list|,
name|q
operator|->
name|hq_count
argument_list|,
name|q
operator|->
name|lq_count
argument_list|,
operator|(
name|int
operator|)
name|elem
operator|->
name|queue
operator|->
name|queueLength
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d %d %d\n"
argument_list|,
operator|(
name|int
operator|)
name|elem
operator|->
name|queue
operator|->
name|numOutstanding
argument_list|,
operator|(
name|int
operator|)
name|elem
operator|->
name|queue
operator|->
name|maxOutstanding
argument_list|,
operator|(
name|int
operator|)
name|elem
operator|->
name|queue
operator|->
name|row
argument_list|,
operator|(
name|int
operator|)
name|elem
operator|->
name|queue
operator|->
name|col
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
operator|(
name|q
operator|->
name|hq_count
operator|+
name|q
operator|->
name|lq_count
operator|)
operator|==
name|elem
operator|->
name|queue
operator|->
name|queueLength
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|RF_DiskQueueData_t
modifier|*
name|rf_FifoDequeue
parameter_list|(
name|q_in
parameter_list|)
name|void
modifier|*
name|q_in
decl_stmt|;
block|{
name|RF_FifoHeader_t
modifier|*
name|q
init|=
operator|(
name|RF_FifoHeader_t
operator|*
operator|)
name|q_in
decl_stmt|;
name|RF_DiskQueueData_t
modifier|*
name|nd
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|hq_head
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|hq_count
operator|!=
literal|0
operator|&&
name|q
operator|->
name|hq_tail
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nd
operator|=
name|q
operator|->
name|hq_head
expr_stmt|;
name|q
operator|->
name|hq_head
operator|=
name|q
operator|->
name|hq_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|hq_head
condition|)
name|q
operator|->
name|hq_tail
operator|=
name|NULL
expr_stmt|;
name|nd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|hq_count
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|lq_head
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|lq_count
operator|!=
literal|0
operator|&&
name|q
operator|->
name|lq_tail
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nd
operator|=
name|q
operator|->
name|lq_head
expr_stmt|;
name|q
operator|->
name|lq_head
operator|=
name|q
operator|->
name|lq_head
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|lq_head
condition|)
name|q
operator|->
name|lq_tail
operator|=
name|NULL
expr_stmt|;
name|nd
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|lq_count
operator|--
expr_stmt|;
if|if
condition|(
name|rf_fifoDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: fifo: DEQ lopri %lx\n"
argument_list|,
name|nd
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|long
operator|)
name|nd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|RF_ASSERT
argument_list|(
name|q
operator|->
name|hq_count
operator|==
literal|0
operator|&&
name|q
operator|->
name|lq_count
operator|==
literal|0
operator|&&
name|q
operator|->
name|hq_tail
operator|==
name|NULL
operator|&&
name|q
operator|->
name|lq_tail
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|nd
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|nd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return ptr to item at head of queue.  Used to examine request  * info without actually dequeueing the request.  */
end_comment

begin_function
name|RF_DiskQueueData_t
modifier|*
name|rf_FifoPeek
parameter_list|(
name|void
modifier|*
name|q_in
parameter_list|)
block|{
name|RF_DiskQueueData_t
modifier|*
name|headElement
init|=
name|NULL
decl_stmt|;
name|RF_FifoHeader_t
modifier|*
name|q
init|=
operator|(
name|RF_FifoHeader_t
operator|*
operator|)
name|q_in
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|hq_head
condition|)
name|headElement
operator|=
name|q
operator|->
name|hq_head
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|lq_head
condition|)
name|headElement
operator|=
name|q
operator|->
name|lq_head
expr_stmt|;
return|return
operator|(
name|headElement
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We sometimes need to promote a low priority access to a regular priority access.  * Currently, this is only used when the user wants to write a stripe which is currently  * under reconstruction.  * This routine will promote all accesses tagged with the indicated parityStripeID from  * the low priority queue to the end of the normal priority queue.  * We assume the queue is locked upon entry.  */
end_comment

begin_function
name|int
name|rf_FifoPromote
parameter_list|(
name|q_in
parameter_list|,
name|parityStripeID
parameter_list|,
name|which_ru
parameter_list|)
name|void
modifier|*
name|q_in
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
block|{
name|RF_FifoHeader_t
modifier|*
name|q
init|=
operator|(
name|RF_FifoHeader_t
operator|*
operator|)
name|q_in
decl_stmt|;
name|RF_DiskQueueData_t
modifier|*
name|lp
init|=
name|q
operator|->
name|lq_head
decl_stmt|,
modifier|*
name|pt
init|=
name|NULL
decl_stmt|;
comment|/* lp = lo-pri queue 								 * pointer, pt = trailer */
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|lp
condition|)
block|{
comment|/* search for the indicated parity stripe in the low-pri queue */
if|if
condition|(
name|lp
operator|->
name|parityStripeID
operator|==
name|parityStripeID
operator|&&
name|lp
operator|->
name|which_ru
operator|==
name|which_ru
condition|)
block|{
comment|/* printf("FifoPromote:  promoting access for psid 			 * %ld\n",parityStripeID); */
if|if
condition|(
name|pt
condition|)
name|pt
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
comment|/* delete an entry other 							 * than the first */
else|else
name|q
operator|->
name|lq_head
operator|=
name|lp
operator|->
name|next
expr_stmt|;
comment|/* delete the head entry */
if|if
condition|(
operator|!
name|q
operator|->
name|lq_head
condition|)
name|q
operator|->
name|lq_tail
operator|=
name|NULL
expr_stmt|;
comment|/* we deleted the only 							 * entry */
elseif|else
if|if
condition|(
name|lp
operator|==
name|q
operator|->
name|lq_tail
condition|)
name|q
operator|->
name|lq_tail
operator|=
name|pt
expr_stmt|;
comment|/* we deleted the tail 								 * entry */
name|lp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|lq_count
operator|--
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|hq_tail
condition|)
block|{
name|q
operator|->
name|hq_tail
operator|->
name|next
operator|=
name|lp
expr_stmt|;
name|q
operator|->
name|hq_tail
operator|=
name|lp
expr_stmt|;
block|}
comment|/* append to hi-priority queue */
else|else
block|{
name|q
operator|->
name|hq_head
operator|=
name|q
operator|->
name|hq_tail
operator|=
name|lp
expr_stmt|;
block|}
name|q
operator|->
name|hq_count
operator|++
expr_stmt|;
comment|/* UpdateShortestSeekFinishTimeForced(lp->requestPtr, 			 * lp->diskState); */
comment|/* deal with this later, if ever */
name|lp
operator|=
operator|(
name|pt
operator|)
condition|?
name|pt
operator|->
name|next
else|:
name|q
operator|->
name|lq_head
expr_stmt|;
comment|/* reset low-pri pointer 								 * and continue */
name|retval
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pt
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* sanity check.  delete this if you ever put more than one entry in 	 * the low-pri queue */
name|RF_ASSERT
argument_list|(
name|retval
operator|==
literal|0
operator|||
name|retval
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

