begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_reconstruct.c,v 1.27 2001/01/26 02:16:24 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/************************************************************  *  * rf_reconstruct.c -- code to perform on-line reconstruction  *  ************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconutil.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_revent.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconbuffer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_freelist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugprint.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_comment
comment|/* setting these to -1 causes them to be set to their default values if not set by debug options */
end_comment

begin_define
define|#
directive|define
name|Dprintf
parameter_list|(
name|s
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf1
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf2
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf3
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf4
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf5
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf6
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),NULL,NULL)
end_define

begin_define
define|#
directive|define
name|Dprintf7
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),(void *)((unsigned long)c),(void *)((unsigned long)d),(void *)((unsigned long)e),(void *)((unsigned long)f),(void *)((unsigned long)g),NULL)
end_define

begin_define
define|#
directive|define
name|DDprintf1
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),NULL,NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_define
define|#
directive|define
name|DDprintf2
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|if (rf_reconDebug) rf_debug_printf(s,(void *)((unsigned long)a),(void *)((unsigned long)b),NULL,NULL,NULL,NULL,NULL,NULL)
end_define

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_recond_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_RECOND
value|4
end_define

begin_define
define|#
directive|define
name|RF_RECOND_INC
value|1
end_define

begin_function_decl
specifier|static
name|RF_RaidReconDesc_t
modifier|*
name|AllocRaidReconDesc
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_RaidDisk_t
modifier|*
name|spareDiskPtr
parameter_list|,
name|int
name|numDisksDone
parameter_list|,
name|RF_RowCol_t
name|srow
parameter_list|,
name|RF_RowCol_t
name|scol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FreeReconDesc
parameter_list|(
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ProcessReconEvent
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|frow
parameter_list|,
name|RF_ReconEvent_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IssueNextReadRequest
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TryToRead
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ComputePSDiskOffsets
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_StripeNum_t
name|psid
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|outDiskOffset
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|outFailedDiskSectorOffset
parameter_list|,
name|RF_RowCol_t
modifier|*
name|spRow
parameter_list|,
name|RF_RowCol_t
modifier|*
name|spCol
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|spOffset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IssueNextWriteRequest
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ReconReadDoneProc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ReconWriteDoneProc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CheckForNewMinHeadSep
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_HeadSepLimit_t
name|hsCtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CheckHeadSeparation
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_HeadSepLimit_t
name|hsCtr
parameter_list|,
name|RF_ReconUnitNum_t
name|which_ru
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CheckForcedOrBlockedReconstruction
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
parameter_list|,
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_StripeNum_t
name|psid
parameter_list|,
name|RF_ReconUnitNum_t
name|which_ru
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ForceReconReadDoneProc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_ShutdownReconstruction
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|RF_ReconDoneProc_s
block|{
name|void
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|RF_ReconDoneProc_t
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_rdp_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_RDP
value|4
end_define

begin_define
define|#
directive|define
name|RF_RDP_INC
value|1
end_define

begin_function
specifier|static
name|void
name|SignalReconDone
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_ReconDoneProc_t
modifier|*
name|p
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|recon_done_proc_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|raidPtr
operator|->
name|recon_done_procs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|proc
argument_list|(
name|raidPtr
argument_list|,
name|p
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|recon_done_proc_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_RegisterReconDoneProc
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|void
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|RF_ReconDoneProc_t
modifier|*
modifier|*
name|handlep
parameter_list|)
block|{
name|RF_ReconDoneProc_t
modifier|*
name|p
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_rdp_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_ReconDoneProc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|p
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|p
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|recon_done_proc_mutex
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|recon_done_procs
expr_stmt|;
name|raidPtr
operator|->
name|recon_done_procs
operator|=
name|p
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|recon_done_proc_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlep
condition|)
operator|*
name|handlep
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  *  * sets up the parameters that will be used by the reconstruction process  * currently there are none, except for those that the layout-specific  * configuration (e.g. rf_ConfigureDeclustered) routine sets up.  *  * in the kernel, we fire off the recon thread.  *  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|rf_ShutdownReconstruction
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_recond_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_RaidReconDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_rdp_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_ReconDoneProc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureReconstruction
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_recond_freelist
argument_list|,
name|RF_MAX_FREE_RECOND
argument_list|,
name|RF_RECOND_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_RaidReconDesc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_recond_freelist
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_rdp_freelist
argument_list|,
name|RF_MAX_FREE_RDP
argument_list|,
name|RF_RDP_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconDoneProc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_rdp_freelist
operator|==
name|NULL
condition|)
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_recond_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_RaidReconDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownReconstruction
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownReconstruction
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|RF_RaidReconDesc_t
modifier|*
name|AllocRaidReconDesc
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|,
name|spareDiskPtr
parameter_list|,
name|numDisksDone
parameter_list|,
name|srow
parameter_list|,
name|scol
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|spareDiskPtr
decl_stmt|;
name|int
name|numDisksDone
decl_stmt|;
name|RF_RowCol_t
name|srow
decl_stmt|;
name|RF_RowCol_t
name|scol
decl_stmt|;
block|{
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_recond_freelist
argument_list|,
name|reconDesc
argument_list|,
name|next
argument_list|,
operator|(
name|RF_RaidReconDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|reconDesc
operator|->
name|raidPtr
operator|=
name|raidPtr
expr_stmt|;
name|reconDesc
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|reconDesc
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|reconDesc
operator|->
name|spareDiskPtr
operator|=
name|spareDiskPtr
expr_stmt|;
name|reconDesc
operator|->
name|numDisksDone
operator|=
name|numDisksDone
expr_stmt|;
name|reconDesc
operator|->
name|srow
operator|=
name|srow
expr_stmt|;
name|reconDesc
operator|->
name|scol
operator|=
name|scol
expr_stmt|;
name|reconDesc
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|reconDesc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FreeReconDesc
parameter_list|(
name|reconDesc
parameter_list|)
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
block|{
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|printf
argument_list|(
literal|"RAIDframe: %lu recon event waits, %lu recon delays\n"
argument_list|,
operator|(
name|long
operator|)
name|reconDesc
operator|->
name|numReconEventWaits
argument_list|,
operator|(
name|long
operator|)
name|reconDesc
operator|->
name|numReconExecDelays
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
name|printf
argument_list|(
literal|"RAIDframe: %lu max exec ticks\n"
argument_list|,
operator|(
name|long
operator|)
name|reconDesc
operator|->
name|maxReconExecTicks
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|RF_RECON_STATS
operator|>
literal|0
operator|)
operator|||
name|defined
argument_list|(
name|KERNEL
argument_list|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (RF_RECON_STATS> 0) || KERNEL */
name|RF_FREELIST_FREE
argument_list|(
name|rf_recond_freelist
argument_list|,
name|reconDesc
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * primary routine to reconstruct a failed disk.  This should be called from  * within its own thread.  It won't return until reconstruction completes,  * fails, or is aborted.  *****************************************************************************/
end_comment

begin_function
name|int
name|rf_ReconstructFailedDisk
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
block|{
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|lp
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|SubmitReconBuffer
condition|)
block|{
comment|/* 	         * The current infrastructure only supports reconstructing one 	         * disk at a time for each array. 	         */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|raidPtr
operator|->
name|reconInProgress
condition|)
block|{
name|RF_WAIT_COND
argument_list|(
name|raidPtr
operator|->
name|waitForReconCond
argument_list|,
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|raidPtr
operator|->
name|reconInProgress
operator|++
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|rf_ReconstructFailedDiskBasic
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|reconInProgress
operator|--
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"RECON: no way to reconstruct failed disk for arch %c\n"
argument_list|,
name|lp
operator|->
name|parityConfig
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
block|}
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|waitForReconCond
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|raidPtr
operator|->
name|waitForReconCond
argument_list|)
expr_stmt|;
comment|/* XXX Methinks this will be 						 * needed at some point... GO */
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_ReconstructFailedDiskBasic
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|c_label
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|spareDiskPtr
init|=
name|NULL
decl_stmt|;
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
name|RF_RowCol_t
name|srow
decl_stmt|,
name|scol
decl_stmt|;
name|int
name|numDisksDone
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
name|RF_Malloc
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_label
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rf_ReconstructInPlace: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* first look for a spare drive onto which to reconstruct the data */
comment|/* spare disk descriptors are stored in row 0.  This may have to 	 * change eventually */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|!=
name|rf_rs_degraded
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Unable to reconstruct disk at row %d col %d because status not degraded\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|srow
operator|=
name|row
expr_stmt|;
name|scol
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|srow
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scol
operator|=
name|raidPtr
operator|->
name|numCol
init|;
name|scol
operator|<
name|raidPtr
operator|->
name|numCol
operator|+
name|raidPtr
operator|->
name|numSpare
condition|;
name|scol
operator|++
control|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|srow
index|]
index|[
name|scol
index|]
operator|.
name|status
operator|==
name|rf_ds_spare
condition|)
block|{
name|spareDiskPtr
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
name|srow
index|]
index|[
name|scol
index|]
expr_stmt|;
name|spareDiskPtr
operator|->
name|status
operator|=
name|rf_ds_used_spare
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|spareDiskPtr
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Unable to reconstruct disk at row %d col %d because no spares are available\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"RECON: initiating reconstruction on row %d col %d -> spare at row %d col %d\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|srow
argument_list|,
name|scol
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reconDesc
operator|=
name|AllocRaidReconDesc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|spareDiskPtr
argument_list|,
name|numDisksDone
argument_list|,
name|srow
argument_list|,
name|scol
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|reconDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|reconDesc
expr_stmt|;
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|reconDesc
operator|->
name|hsStallCount
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|numReconExecDelays
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|numReconEventWaits
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
name|reconDesc
operator|->
name|reconExecTimerRunning
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|reconExecTicks
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|maxReconExecTicks
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|rf_ContinueReconstructFailedDisk
argument_list|(
name|reconDesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
comment|/* fix up the component label */
comment|/* Don't actually need the read here.. */
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|srow
index|]
index|[
name|scol
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|srow
index|]
index|[
name|scol
index|]
operator|.
name|ci_vp
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|raid_init_component_label
argument_list|(
name|raidPtr
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|c_label
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|c_label
operator|->
name|column
operator|=
name|col
expr_stmt|;
name|c_label
operator|->
name|clean
operator|=
name|RF_RAID_DIRTY
expr_stmt|;
name|c_label
operator|->
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
name|c_label
operator|->
name|partitionSize
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|srow
index|]
index|[
name|scol
index|]
operator|.
name|partitionSize
expr_stmt|;
comment|/* We've just done a rebuild based on all the other 		   disks, so at this point the parity is known to be 		   clean, even if it wasn't before. */
comment|/* XXX doesn't hold for RAID 6!! */
name|raidPtr
operator|->
name|parity_good
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
comment|/* XXXX MORE NEEDED HERE */
name|raidwrite_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|srow
index|]
index|[
name|scol
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|srow
index|]
index|[
name|scol
index|]
operator|.
name|ci_vp
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*      Allow reconstructing a disk in-place -- i.e. component /dev/sd2e goes AWOL,    and you don't get a spare until the next Monday.  With this function     (and hot-swappable drives) you can now put your new disk containing     /dev/sd2e on the bus, scsictl it alive, and then use raidctl(8) to    rebuild the data "on the spot".  */
end_comment

begin_function
name|int
name|rf_ReconstructInPlace
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
name|spareDiskPtr
init|=
name|NULL
decl_stmt|;
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|badDisk
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|c_label
decl_stmt|;
name|int
name|numDisksDone
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|RF_Malloc
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_label
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rf_ReconstructInPlace: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|lp
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|SubmitReconBuffer
condition|)
block|{
comment|/* 	         * The current infrastructure only supports reconstructing one 	         * disk at a time for each array. 	         */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
operator|)
operator|&&
operator|(
name|raidPtr
operator|->
name|numFailures
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* XXX 0 above shouldn't be constant!!! */
comment|/* some component other than this has failed. 			   Let's not make things worse than they already 			   are... */
name|printf
argument_list|(
literal|"RAIDFRAME: Unable to reconstruct to disk at:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Row: %d Col: %d   Too many failures.\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_reconstructing
condition|)
block|{
name|printf
argument_list|(
literal|"RAIDFRAME: Unable to reconstruct to disk at:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Row: %d Col: %d   Reconstruction already occuring!\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|!=
name|rf_ds_failed
condition|)
block|{
comment|/* "It's gone..." */
name|raidPtr
operator|->
name|numFailures
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
name|rf_update_component_labels
argument_list|(
name|raidPtr
argument_list|,
name|RF_NORMAL_COMPONENT_UPDATE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|raidPtr
operator|->
name|reconInProgress
condition|)
block|{
name|RF_WAIT_COND
argument_list|(
name|raidPtr
operator|->
name|waitForReconCond
argument_list|,
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|raidPtr
operator|->
name|reconInProgress
operator|++
expr_stmt|;
comment|/* first look for a spare drive onto which to reconstruct  		   the data.  spare disk descriptors are stored in row 0.  		   This may have to change eventually */
comment|/* Actually, we don't care if it's failed or not...  		   On a RAID set with correct parity, this function 		   should be callable on any component without ill affects. */
comment|/* RF_ASSERT(raidPtr->Disks[row][col].status == rf_ds_failed); 		 */
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Unable to reconstruct to disk at row %d col %d: operation not supported for RF_DISTRIBUTE_SPARE\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|reconInProgress
operator|--
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* XXX need goop here to see if the disk is alive, 		   and, if not, make it so...  */
name|badDisk
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
expr_stmt|;
comment|/* This device may have been opened successfully the  		   first time. Close it before trying to open it again.. */
if|if
condition|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Closed the open device: %s\n"
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
name|vp
operator|=
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
expr_stmt|;
name|ac
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|auto_configured
expr_stmt|;
name|rf_close_component
argument_list|(
name|raidPtr
argument_list|,
name|vp
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* note that this disk was *not* auto_configured (any longer)*/
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|auto_configured
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"About to (re-)open the device for rebuilding: %s\n"
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|raid_getcomponentsize
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: rebuilding: raidlookup on device: %s failed: %d!\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|devname
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
comment|/* XXX the component isn't responding properly...  			   must be still dead :-( */
name|raidPtr
operator|->
name|reconInProgress
operator|--
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
name|spareDiskPtr
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
expr_stmt|;
name|spareDiskPtr
operator|->
name|status
operator|=
name|rf_ds_used_spare
expr_stmt|;
name|printf
argument_list|(
literal|"RECON: initiating in-place reconstruction on\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       row %d col %d -> spare at row %d col %d\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reconDesc
operator|=
name|AllocRaidReconDesc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|spareDiskPtr
argument_list|,
name|numDisksDone
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|reconDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|reconDesc
expr_stmt|;
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|reconDesc
operator|->
name|hsStallCount
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|numReconExecDelays
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|numReconEventWaits
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
name|reconDesc
operator|->
name|reconExecTimerRunning
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|reconExecTicks
operator|=
literal|0
expr_stmt|;
name|reconDesc
operator|->
name|maxReconExecTicks
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|rf_ContinueReconstructFailedDisk
argument_list|(
name|reconDesc
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|reconInProgress
operator|--
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"RECON: no way to reconstruct failed disk for arch %c\n"
argument_list|,
name|lp
operator|->
name|parityConfig
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
comment|/* Need to set these here, as at this point it'll be claiming 		   that the disk is in rf_ds_spared!  But we know better :-) */
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|=
name|rf_rs_optimal
expr_stmt|;
comment|/* fix up the component label */
comment|/* Don't actually need the read here.. */
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|raid_init_component_label
argument_list|(
name|raidPtr
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|c_label
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|c_label
operator|->
name|column
operator|=
name|col
expr_stmt|;
comment|/* We've just done a rebuild based on all the other 		   disks, so at this point the parity is known to be 		   clean, even if it wasn't before. */
comment|/* XXX doesn't hold for RAID 6!! */
name|raidPtr
operator|->
name|parity_good
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|waitForReconCond
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|raidPtr
operator|->
name|waitForReconCond
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_ContinueReconstructFailedDisk
parameter_list|(
name|reconDesc
parameter_list|)
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|reconDesc
operator|->
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
init|=
name|reconDesc
operator|->
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
init|=
name|reconDesc
operator|->
name|col
decl_stmt|;
name|RF_RowCol_t
name|srow
init|=
name|reconDesc
operator|->
name|srow
decl_stmt|;
name|RF_RowCol_t
name|scol
init|=
name|reconDesc
operator|->
name|scol
decl_stmt|;
name|RF_ReconMap_t
modifier|*
name|mapPtr
decl_stmt|;
name|RF_ReconEvent_t
modifier|*
name|event
decl_stmt|;
name|struct
name|timeval
name|etime
decl_stmt|,
name|elpsd
decl_stmt|;
name|unsigned
name|long
name|xor_s
decl_stmt|,
name|xor_resid_us
decl_stmt|;
name|int
name|retcode
decl_stmt|,
name|i
decl_stmt|,
name|ds
decl_stmt|;
switch|switch
condition|(
name|reconDesc
operator|->
name|state
condition|)
block|{
case|case
literal|0
case|:
name|raidPtr
operator|->
name|accumXorTimeUs
operator|=
literal|0
expr_stmt|;
comment|/* create one trace record per physical disk */
name|RF_Malloc
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_AccTraceEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* quiesce the array prior to starting recon.  this is needed 		 * to assure no nasty interactions with pending user writes. 		 * We need to do this before we change the disk or row status. */
name|reconDesc
operator|->
name|state
operator|=
literal|1
expr_stmt|;
name|Dprintf
argument_list|(
literal|"RECON: begin request suspend\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_SuspendNewRequestsAndWait
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|Dprintf
argument_list|(
literal|"RECON: end request suspend\n"
argument_list|)
expr_stmt|;
name|rf_StartUserStats
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* zero out the stats kept on 						 * user accs */
comment|/* fall through to state 1 */
case|case
literal|1
case|:
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* create the reconstruction control pointer and install it in 		 * the right slot */
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|=
name|rf_MakeReconControl
argument_list|(
name|reconDesc
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|srow
argument_list|,
name|scol
argument_list|)
expr_stmt|;
name|mapPtr
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|=
name|rf_rs_reconstructing
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|=
name|rf_ds_reconstructing
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|spareRow
operator|=
name|srow
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|spareCol
operator|=
name|scol
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_GETTIME
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|starttime
argument_list|)
expr_stmt|;
comment|/* now start up the actual reconstruction: issue a read for 		 * each surviving disk */
name|reconDesc
operator|->
name|numDisksDone
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|col
condition|)
block|{
comment|/* find and issue the next I/O on the 				 * indicated disk */
if|if
condition|(
name|IssueNextReadRequest
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|Dprintf2
argument_list|(
literal|"RECON: done issuing for r%d c%d\n"
argument_list|,
name|row
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reconDesc
operator|->
name|numDisksDone
operator|++
expr_stmt|;
block|}
block|}
block|}
case|case
literal|2
case|:
name|Dprintf
argument_list|(
literal|"RECON: resume requests\n"
argument_list|)
expr_stmt|;
name|rf_ResumeNewRequests
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|reconDesc
operator|->
name|state
operator|=
literal|3
expr_stmt|;
case|case
literal|3
case|:
comment|/* process reconstruction events until all disks report that 		 * they've completed all work */
name|mapPtr
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
expr_stmt|;
while|while
condition|(
name|reconDesc
operator|->
name|numDisksDone
operator|<
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
condition|)
block|{
name|event
operator|=
name|rf_GetNextReconEvent
argument_list|(
name|reconDesc
argument_list|,
name|row
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_ContinueReconstructFailedDisk
argument_list|,
name|reconDesc
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ProcessReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|event
argument_list|)
condition|)
name|reconDesc
operator|->
name|numDisksDone
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|numRUsTotal
operator|=
name|mapPtr
operator|->
name|totalRUs
expr_stmt|;
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|numRUsComplete
operator|=
name|mapPtr
operator|->
name|totalRUs
operator|-
name|rf_UnitsLeftToReconstruct
argument_list|(
name|mapPtr
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|percentComplete
operator|=
operator|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|numRUsComplete
operator|*
literal|100
operator|/
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|numRUsTotal
operator|)
expr_stmt|;
if|if
condition|(
name|rf_prReconSched
condition|)
block|{
name|rf_PrintReconSchedule
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|,
operator|&
operator|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|starttime
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|reconDesc
operator|->
name|state
operator|=
literal|4
expr_stmt|;
case|case
literal|4
case|:
name|mapPtr
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
expr_stmt|;
if|if
condition|(
name|rf_reconDebug
condition|)
block|{
name|printf
argument_list|(
literal|"RECON: all reads completed\n"
argument_list|)
expr_stmt|;
block|}
comment|/* at this point all the reads have completed.  We now wait 		 * for any pending writes to complete, and then we're done */
while|while
condition|(
name|rf_UnitsLeftToReconstruct
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|)
operator|>
literal|0
condition|)
block|{
name|event
operator|=
name|rf_GetNextReconEvent
argument_list|(
name|reconDesc
argument_list|,
name|row
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_ContinueReconstructFailedDisk
argument_list|,
name|reconDesc
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|event
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ProcessReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|/* ignore return code */
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|percentComplete
operator|=
literal|100
operator|-
operator|(
name|rf_UnitsLeftToReconstruct
argument_list|(
name|mapPtr
argument_list|)
operator|*
literal|100
operator|/
name|mapPtr
operator|->
name|totalRUs
operator|)
expr_stmt|;
if|if
condition|(
name|rf_prReconSched
condition|)
block|{
name|rf_PrintReconSchedule
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|,
operator|&
operator|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|starttime
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|reconDesc
operator|->
name|state
operator|=
literal|5
expr_stmt|;
case|case
literal|5
case|:
comment|/* Success:  mark the dead disk as reconstructed.  We quiesce 		 * the array here to assure no nasty interactions with pending 		 * user accesses when we free up the psstatus structure as 		 * part of FreeReconControl() */
name|reconDesc
operator|->
name|state
operator|=
literal|6
expr_stmt|;
name|retcode
operator|=
name|rf_SuspendNewRequestsAndWait
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|rf_StopUserStats
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|rf_PrintUserStats
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* print out the stats on user 						 * accs accumulated during 						 * recon */
comment|/* fall through to state 6 */
case|case
literal|6
case|:
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|numFailures
operator|--
expr_stmt|;
name|ds
operator|=
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|status
operator|=
operator|(
name|ds
operator|)
condition|?
name|rf_ds_dist_spared
else|:
name|rf_ds_spared
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|=
operator|(
name|ds
operator|)
condition|?
name|rf_rs_reconfigured
else|:
name|rf_rs_optimal
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_GETTIME
argument_list|(
name|etime
argument_list|)
expr_stmt|;
name|RF_TIMEVAL_DIFF
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|starttime
operator|)
argument_list|,
operator|&
name|etime
argument_list|,
operator|&
name|elpsd
argument_list|)
expr_stmt|;
comment|/* XXX -- why is state 7 different from state 6 if there is no 		 * return() here? -- XXX Note that I set elpsd above& use it 		 * below, so if you put a return here you'll have to fix this. 		 * (also, FreeReconControl is called below) */
case|case
literal|7
case|:
name|rf_ResumeNewRequests
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reconstruction of disk at row %d col %d completed\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|xor_s
operator|=
name|raidPtr
operator|->
name|accumXorTimeUs
operator|/
literal|1000000
expr_stmt|;
name|xor_resid_us
operator|=
name|raidPtr
operator|->
name|accumXorTimeUs
operator|%
literal|1000000
expr_stmt|;
name|printf
argument_list|(
literal|"Recon time was %d.%06d seconds, accumulated XOR time was %ld us (%ld.%06ld)\n"
argument_list|,
operator|(
name|int
operator|)
name|elpsd
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|elpsd
operator|.
name|tv_usec
argument_list|,
name|raidPtr
operator|->
name|accumXorTimeUs
argument_list|,
name|xor_s
argument_list|,
name|xor_resid_us
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  (start time %d sec %d usec, end time %d sec %d usec)\n"
argument_list|,
operator|(
name|int
operator|)
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|starttime
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|starttime
operator|.
name|tv_usec
argument_list|,
operator|(
name|int
operator|)
name|etime
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|etime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|printf
argument_list|(
literal|"Total head-sep stall count was %d\n"
argument_list|,
operator|(
name|int
operator|)
name|reconDesc
operator|->
name|hsStallCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
name|rf_FreeReconControl
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
name|FreeReconDesc
argument_list|(
name|reconDesc
argument_list|)
expr_stmt|;
block|}
name|SignalReconDone
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * do the right thing upon each reconstruction event.  * returns nonzero if and only if there is nothing left unread on the   * indicated disk  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ProcessReconEvent
parameter_list|(
name|raidPtr
parameter_list|,
name|frow
parameter_list|,
name|event
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|frow
decl_stmt|;
name|RF_ReconEvent_t
modifier|*
name|event
decl_stmt|;
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|,
name|submitblocked
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerRU
decl_stmt|;
name|Dprintf1
argument_list|(
literal|"RECON: ProcessReconEvent type %d\n"
argument_list|,
name|event
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|type
condition|)
block|{
comment|/* a read I/O has completed */
case|case
name|RF_REVENT_READDONE
case|:
name|rbuf
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|perDiskInfo
index|[
name|event
operator|->
name|col
index|]
operator|.
name|rbuf
expr_stmt|;
name|Dprintf3
argument_list|(
literal|"RECON: READDONE EVENT: row %d col %d psid %ld\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|)
expr_stmt|;
name|Dprintf7
argument_list|(
literal|"RECON: done read  psid %ld buf %lx  %02x %02x %02x %02x %02x\n"
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|buffer
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rf_FreeDiskQueueData
argument_list|(
operator|(
name|RF_DiskQueueData_t
operator|*
operator|)
name|rbuf
operator|->
name|arg
argument_list|)
expr_stmt|;
name|submitblocked
operator|=
name|rf_SubmitReconBuffer
argument_list|(
name|rbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Dprintf1
argument_list|(
literal|"RECON: submitblocked=%d\n"
argument_list|,
name|submitblocked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|submitblocked
condition|)
name|retcode
operator|=
name|IssueNextReadRequest
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
break|break;
comment|/* a write I/O has completed */
case|case
name|RF_REVENT_WRITEDONE
case|:
if|if
condition|(
name|rf_floatingRbufDebug
condition|)
block|{
name|rf_CheckFloatingRbufCount
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sectorsPerRU
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerRU
expr_stmt|;
name|rbuf
operator|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|event
operator|->
name|arg
expr_stmt|;
name|rf_FreeDiskQueueData
argument_list|(
operator|(
name|RF_DiskQueueData_t
operator|*
operator|)
name|rbuf
operator|->
name|arg
argument_list|)
expr_stmt|;
name|Dprintf3
argument_list|(
literal|"RECON: WRITEDONE EVENT: psid %d ru %d (%d %% complete)\n"
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|percentComplete
argument_list|)
expr_stmt|;
name|rf_ReconMapUpdate
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|reconMap
argument_list|,
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|,
name|rbuf
operator|->
name|failedDiskSectorOffset
operator|+
name|sectorsPerRU
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rf_RemoveFromActiveReconTable
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
block|{
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|numFullReconBuffers
operator|--
expr_stmt|;
name|rf_ReleaseFloatingReconBuffer
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|rbuf
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbuf
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FORCED
condition|)
name|rf_FreeReconBuffer
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
else|else
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RF_REVENT_BUFCLEAR
case|:
comment|/* A buffer-stall condition has been 					 * cleared */
name|Dprintf2
argument_list|(
literal|"RECON: BUFCLEAR EVENT: row %d col %d\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
name|submitblocked
operator|=
name|rf_SubmitReconBuffer
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|perDiskInfo
index|[
name|event
operator|->
name|col
index|]
operator|.
name|rbuf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|event
operator|->
name|arg
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
name|submitblocked
argument_list|)
expr_stmt|;
comment|/* we wouldn't have gotten the 						 * BUFCLEAR event if we 						 * couldn't submit */
name|retcode
operator|=
name|IssueNextReadRequest
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
break|break;
case|case
name|RF_REVENT_BLOCKCLEAR
case|:
comment|/* A user-write reconstruction 					 * blockage has been cleared */
name|DDprintf2
argument_list|(
literal|"RECON: BLOCKCLEAR EVENT: row %d col %d\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|TryToRead
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
break|break;
case|case
name|RF_REVENT_HEADSEPCLEAR
case|:
comment|/* A max-head-separation 					 * reconstruction blockage has been 					 * cleared */
name|Dprintf2
argument_list|(
literal|"RECON: HEADSEPCLEAR EVENT: row %d col %d\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|TryToRead
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
break|break;
comment|/* a buffer has become ready to write */
case|case
name|RF_REVENT_BUFREADY
case|:
name|Dprintf2
argument_list|(
literal|"RECON: BUFREADY EVENT: row %d col %d\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|IssueNextWriteRequest
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_floatingRbufDebug
condition|)
block|{
name|rf_CheckFloatingRbufCount
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* we need to skip the current RU entirely because it got 		 * recon'd while we were waiting for something else to happen */
case|case
name|RF_REVENT_SKIP
case|:
name|DDprintf2
argument_list|(
literal|"RECON: SKIP EVENT: row %d col %d\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|IssueNextReadRequest
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
break|break;
comment|/* a forced-reconstruction read access has completed.  Just 		 * submit the buffer */
case|case
name|RF_REVENT_FORCEDREADDONE
case|:
name|rbuf
operator|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|event
operator|->
name|arg
expr_stmt|;
name|rf_FreeDiskQueueData
argument_list|(
operator|(
name|RF_DiskQueueData_t
operator|*
operator|)
name|rbuf
operator|->
name|arg
argument_list|)
expr_stmt|;
name|DDprintf2
argument_list|(
literal|"RECON: FORCEDREADDONE EVENT: row %d col %d\n"
argument_list|,
name|frow
argument_list|,
name|event
operator|->
name|col
argument_list|)
expr_stmt|;
name|submitblocked
operator|=
name|rf_SubmitReconBuffer
argument_list|(
name|rbuf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
name|submitblocked
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|rf_FreeReconEventDesc
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * find the next thing that's needed on the indicated disk, and issue  * a read request for it.  We assume that the reconstruction buffer  * associated with this process is free to receive the data.  If  * reconstruction is blocked on the indicated RU, we issue a  * blockage-release request instead of a physical disk read request.  * If the current disk gets too far ahead of the others, we issue a  * head-separation wait request and return.  *  * ctrl->{ru_count, curPSID, diskOffset} and  * rbuf->failedDiskSectorOffset are maintained to point to the unit  * we're currently accessing.  Note that this deviates from the  * standard C idiom of having counters point to the next thing to be  * accessed.  This allows us to easily retry when we're blocked by  * head separation or reconstruction-blockage events.  *  * returns nonzero if and only if there is nothing left unread on the  * indicated disk  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|IssueNextReadRequest
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
block|{
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
init|=
operator|&
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|perDiskInfo
index|[
name|col
index|]
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
init|=
name|ctrl
operator|->
name|rbuf
decl_stmt|;
name|RF_ReconUnitCount_t
name|RUsPerPU
init|=
name|layoutPtr
operator|->
name|SUsPerPU
operator|/
name|layoutPtr
operator|->
name|SUsPerRU
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerRU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|*
name|layoutPtr
operator|->
name|SUsPerRU
decl_stmt|;
name|int
name|do_new_check
init|=
literal|0
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|,
name|status
decl_stmt|;
comment|/* if we are currently the slowest disk, mark that we have to do a new 	 * check */
if|if
condition|(
name|ctrl
operator|->
name|headSepCounter
operator|<=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|minHeadSepCounter
condition|)
name|do_new_check
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ctrl
operator|->
name|ru_count
operator|++
expr_stmt|;
if|if
condition|(
name|ctrl
operator|->
name|ru_count
operator|<
name|RUsPerPU
condition|)
block|{
name|ctrl
operator|->
name|diskOffset
operator|+=
name|sectorsPerRU
expr_stmt|;
name|rbuf
operator|->
name|failedDiskSectorOffset
operator|+=
name|sectorsPerRU
expr_stmt|;
block|}
else|else
block|{
name|ctrl
operator|->
name|curPSID
operator|++
expr_stmt|;
name|ctrl
operator|->
name|ru_count
operator|=
literal|0
expr_stmt|;
comment|/* code left over from when head-sep was based on 			 * parity stripe id */
if|if
condition|(
name|ctrl
operator|->
name|curPSID
operator|>=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|lastPSID
condition|)
block|{
name|CheckForNewMinHeadSep
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
operator|++
operator|(
name|ctrl
operator|->
name|headSepCounter
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* finito! */
block|}
comment|/* find the disk offsets of the start of the parity 			 * stripe on both the current disk and the failed 			 * disk. skip this entire parity stripe if either disk 			 * does not appear in the indicated PS */
name|status
operator|=
name|ComputePSDiskOffsets
argument_list|(
name|raidPtr
argument_list|,
name|ctrl
operator|->
name|curPSID
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
operator|&
name|ctrl
operator|->
name|diskOffset
argument_list|,
operator|&
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|,
operator|&
name|rbuf
operator|->
name|spRow
argument_list|,
operator|&
name|rbuf
operator|->
name|spCol
argument_list|,
operator|&
name|rbuf
operator|->
name|spOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|ctrl
operator|->
name|ru_count
operator|=
name|RUsPerPU
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|rbuf
operator|->
name|which_ru
operator|=
name|ctrl
operator|->
name|ru_count
expr_stmt|;
comment|/* skip this RU if it's already been reconstructed */
if|if
condition|(
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|,
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|)
condition|)
block|{
name|Dprintf2
argument_list|(
literal|"Skipping psid %ld ru %d: already reconstructed\n"
argument_list|,
name|ctrl
operator|->
name|curPSID
argument_list|,
name|ctrl
operator|->
name|ru_count
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|ctrl
operator|->
name|headSepCounter
operator|++
expr_stmt|;
if|if
condition|(
name|do_new_check
condition|)
name|CheckForNewMinHeadSep
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|ctrl
operator|->
name|headSepCounter
argument_list|)
expr_stmt|;
comment|/* update min if needed */
comment|/* at this point, we have definitely decided what to do, and we have 	 * only to see if we can actually do it now */
name|rbuf
operator|->
name|parityStripeID
operator|=
name|ctrl
operator|->
name|curPSID
expr_stmt|;
name|rbuf
operator|->
name|which_ru
operator|=
name|ctrl
operator|->
name|ru_count
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|reconacc
operator|=
literal|1
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|TryToRead
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tries to issue the next read on the indicated disk.  We may be  * blocked by (a) the heads being too far apart, or (b) recon on the  * indicated RU being blocked due to a write by a user thread.  In  * this case, we issue a head-sep or blockage wait request, which will  * cause this same routine to be invoked again later when the blockage  * has cleared.    */
end_comment

begin_function
specifier|static
name|int
name|TryToRead
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
block|{
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
init|=
operator|&
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|perDiskInfo
index|[
name|col
index|]
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerRU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerRU
decl_stmt|;
name|RF_StripeNum_t
name|psid
init|=
name|ctrl
operator|->
name|curPSID
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
init|=
name|ctrl
operator|->
name|ru_count
decl_stmt|;
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
name|int
name|status
decl_stmt|,
name|created
init|=
literal|0
decl_stmt|;
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
comment|/* if the current disk is too far ahead of the others, issue a 	 * head-separation wait and return */
if|if
condition|(
name|CheckHeadSeparation
argument_list|(
name|raidPtr
argument_list|,
name|ctrl
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|ctrl
operator|->
name|headSepCounter
argument_list|,
name|which_ru
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|RF_LOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
name|pssPtr
operator|=
name|rf_LookupRUStatus
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|pssTable
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|,
name|RF_PSS_CREATE
argument_list|,
operator|&
name|created
argument_list|)
expr_stmt|;
comment|/* if recon is blocked on the indicated parity stripe, issue a 	 * block-wait request and return. this also must mark the indicated RU 	 * in the stripe as under reconstruction if not blocked. */
name|status
operator|=
name|CheckForcedOrBlockedReconstruction
argument_list|(
name|raidPtr
argument_list|,
name|pssPtr
argument_list|,
name|ctrl
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RF_PSS_RECON_BLOCKED
condition|)
block|{
name|Dprintf2
argument_list|(
literal|"RECON: Stalling psid %ld ru %d: recon blocked\n"
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|RF_PSS_FORCED_ON_WRITE
condition|)
block|{
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|NULL
argument_list|,
name|RF_REVENT_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* make one last check to be sure that the indicated RU didn't get 	 * reconstructed while we were waiting for something else to happen. 	 * This is unfortunate in that it causes us to make this check twice 	 * in the normal case.  Might want to make some attempt to re-work 	 * this so that we only do this check if we've definitely blocked on 	 * one of the above checks.  When this condition is detected, we may 	 * have just created a bogus status entry, which we need to delete. */
if|if
condition|(
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|,
name|ctrl
operator|->
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|)
condition|)
block|{
name|Dprintf2
argument_list|(
literal|"RECON: Skipping psid %ld ru %d: prior recon after stall\n"
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|created
condition|)
name|rf_PSStatusDelete
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|pssTable
argument_list|,
name|pssPtr
argument_list|)
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|NULL
argument_list|,
name|RF_REVENT_SKIP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* found something to read.  issue the I/O */
name|Dprintf5
argument_list|(
literal|"RECON: Read for psid %ld on row %d col %d offset %ld buf %lx\n"
argument_list|,
name|psid
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|ctrl
operator|->
name|diskOffset
argument_list|,
name|ctrl
operator|->
name|rbuf
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|specific
operator|.
name|recon
operator|.
name|recon_start_to_fetch_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
comment|/* should be ok to use a NULL proc pointer here, all the bufs we use 	 * should be in kernel space */
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_READ
argument_list|,
name|ctrl
operator|->
name|diskOffset
argument_list|,
name|sectorsPerRU
argument_list|,
name|ctrl
operator|->
name|rbuf
operator|->
name|buffer
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|,
name|ReconReadDoneProc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctrl
argument_list|,
name|NULL
argument_list|,
operator|&
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|col
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* XXX -- fix this -- XXX */
name|ctrl
operator|->
name|rbuf
operator|->
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
name|raidPtr
operator|->
name|Queues
index|[
name|row
index|]
index|[
name|col
index|]
argument_list|,
name|req
argument_list|,
name|RF_IO_RECON_PRIORITY
argument_list|)
expr_stmt|;
name|pssPtr
operator|->
name|issued
index|[
name|col
index|]
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a parity stripe ID, we want to find out whether both the  * current disk and the failed disk exist in that parity stripe.  If  * not, we want to skip this whole PS.  If so, we want to find the  * disk offset of the start of the PS on both the current disk and the  * failed disk.  *  * this works by getting a list of disks comprising the indicated  * parity stripe, and searching the list for the current and failed  * disks.  Once we've decided they both exist in the parity stripe, we  * need to decide whether each is data or parity, so that we'll know  * which mapping function to call to get the corresponding disk  * offsets.  *  * this is kind of unpleasant, but doing it this way allows the  * reconstruction code to use parity stripe IDs rather than physical  * disks address to march through the failed disk, which greatly  * simplifies a lot of code, as well as eliminating the need for a  * reverse-mapping function.  I also think it will execute faster,  * since the calls to the mapping module are kept to a minimum.  *  * ASSUMES THAT THE STRIPE IDENTIFIER IDENTIFIES THE DISKS COMPRISING  * THE STRIPE IN THE CORRECT ORDER */
end_comment

begin_function
specifier|static
name|int
name|ComputePSDiskOffsets
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
comment|/* raid descriptor */
name|RF_StripeNum_t
name|psid
parameter_list|,
comment|/* parity stripe identifier */
name|RF_RowCol_t
name|row
parameter_list|,
comment|/* row and column of disk to find the offsets 				 * for */
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|outDiskOffset
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|outFailedDiskSectorOffset
parameter_list|,
name|RF_RowCol_t
modifier|*
name|spRow
parameter_list|,
comment|/* OUT: row,col of spare unit for failed unit */
name|RF_RowCol_t
modifier|*
name|spCol
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|spOffset
parameter_list|)
block|{
comment|/* OUT: offset into disk containing spare unit */
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_RowCol_t
name|fcol
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|fcol
decl_stmt|;
name|RF_RaidAddr_t
name|sosRaidAddress
decl_stmt|;
comment|/* start-of-stripe */
name|RF_RowCol_t
modifier|*
name|diskids
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|i_offset
decl_stmt|,
name|j_offset
decl_stmt|;
name|RF_RowCol_t
name|prow
decl_stmt|,
name|pcol
decl_stmt|;
name|int
name|testcol
decl_stmt|,
name|testrow
decl_stmt|;
name|RF_RowCol_t
name|stripe
decl_stmt|;
name|RF_SectorNum_t
name|poffset
decl_stmt|;
name|char
name|i_is_parity
init|=
literal|0
decl_stmt|,
name|j_is_parity
init|=
literal|0
decl_stmt|;
name|RF_RowCol_t
name|stripeWidth
init|=
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
decl_stmt|;
comment|/* get a listing of the disks comprising that stripe */
name|sosRaidAddress
operator|=
name|rf_ParityStripeIDToRaidAddress
argument_list|(
name|layoutPtr
argument_list|,
name|psid
argument_list|)
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|IdentifyStripe
call|)
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
argument_list|,
operator|&
name|diskids
argument_list|,
operator|&
name|stripe
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|diskids
argument_list|)
expr_stmt|;
comment|/* reject this entire parity stripe if it does not contain the 	 * indicated disk or it does not contain the failed disk */
if|if
condition|(
name|row
operator|!=
name|stripe
condition|)
goto|goto
name|skipit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stripeWidth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|col
operator|==
name|diskids
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|stripeWidth
condition|)
goto|goto
name|skipit
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|stripeWidth
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fcol
operator|==
name|diskids
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|stripeWidth
condition|)
block|{
goto|goto
name|skipit
goto|;
block|}
comment|/* find out which disk the parity is on */
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
argument_list|,
operator|&
name|prow
argument_list|,
operator|&
name|pcol
argument_list|,
operator|&
name|poffset
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
comment|/* find out if either the current RU or the failed RU is parity */
comment|/* also, if the parity occurs in this stripe prior to the data and/or 	 * failed col, we need to decrement i and/or j */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|stripeWidth
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|diskids
index|[
name|k
index|]
operator|==
name|pcol
condition|)
break|break;
name|RF_ASSERT
argument_list|(
name|k
operator|<
name|stripeWidth
argument_list|)
expr_stmt|;
name|i_offset
operator|=
name|i
expr_stmt|;
name|j_offset
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|i
condition|)
name|i_offset
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
name|i
condition|)
block|{
name|i_is_parity
operator|=
literal|1
expr_stmt|;
name|i_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* set offsets to zero to disable multiply 				 * below */
if|if
condition|(
name|k
operator|<
name|j
condition|)
name|j_offset
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
name|j
condition|)
block|{
name|j_is_parity
operator|=
literal|1
expr_stmt|;
name|j_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* at this point, [ij]_is_parity tells us whether the [current,failed] 	 * disk is parity at the start of this RU, and, if data, "[ij]_offset" 	 * tells us how far into the stripe the [current,failed] disk is. */
comment|/* call the mapping routine to get the offset into the current disk, 	 * repeat for failed disk. */
if|if
condition|(
name|i_is_parity
condition|)
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
operator|+
name|i_offset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
operator|&
name|testrow
argument_list|,
operator|&
name|testcol
argument_list|,
name|outDiskOffset
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
else|else
name|layoutPtr
operator|->
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
operator|+
name|i_offset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
operator|&
name|testrow
argument_list|,
operator|&
name|testcol
argument_list|,
name|outDiskOffset
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|row
operator|==
name|testrow
operator|&&
name|col
operator|==
name|testcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|j_is_parity
condition|)
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
operator|+
name|j_offset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
operator|&
name|testrow
argument_list|,
operator|&
name|testcol
argument_list|,
name|outFailedDiskSectorOffset
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
else|else
name|layoutPtr
operator|->
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
operator|+
name|j_offset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
operator|&
name|testrow
argument_list|,
operator|&
name|testcol
argument_list|,
name|outFailedDiskSectorOffset
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|row
operator|==
name|testrow
operator|&&
name|fcol
operator|==
name|testcol
argument_list|)
expr_stmt|;
comment|/* now locate the spare unit for the failed unit */
if|if
condition|(
name|layoutPtr
operator|->
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
if|if
condition|(
name|j_is_parity
condition|)
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
operator|+
name|j_offset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
name|spRow
argument_list|,
name|spCol
argument_list|,
name|spOffset
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
else|else
name|layoutPtr
operator|->
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
operator|+
name|j_offset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
name|spRow
argument_list|,
name|spCol
argument_list|,
name|spOffset
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|spRow
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|spareRow
expr_stmt|;
operator|*
name|spCol
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|spareCol
expr_stmt|;
operator|*
name|spOffset
operator|=
operator|*
name|outFailedDiskSectorOffset
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|skipit
label|:
name|Dprintf3
argument_list|(
literal|"RECON: Skipping psid %ld: nothing needed from r%d c%d\n"
argument_list|,
name|psid
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this is called when a buffer has become ready to write to the replacement disk */
end_comment

begin_function
specifier|static
name|int
name|IssueNextWriteRequest
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerRU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|*
name|layoutPtr
operator|->
name|SUsPerRU
decl_stmt|;
name|RF_RowCol_t
name|fcol
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|fcol
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
name|rbuf
operator|=
name|rf_GetFullReconBuffer
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
comment|/* there must be one available, or we wouldn't 				 * have gotten the event that sent us here */
name|RF_ASSERT
argument_list|(
name|rbuf
operator|->
name|pssPtr
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|pssPtr
operator|->
name|writeRbuf
operator|=
name|rbuf
expr_stmt|;
name|rbuf
operator|->
name|pssPtr
operator|=
name|NULL
expr_stmt|;
name|Dprintf7
argument_list|(
literal|"RECON: New write (r %d c %d offs %d) for psid %ld ru %d (failed disk offset %ld) buf %lx\n"
argument_list|,
name|rbuf
operator|->
name|spRow
argument_list|,
name|rbuf
operator|->
name|spCol
argument_list|,
name|rbuf
operator|->
name|spOffset
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|,
name|rbuf
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|Dprintf6
argument_list|(
literal|"RECON: new write psid %ld   %02x %02x %02x %02x %02x\n"
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* should be ok to use a NULL b_proc here b/c all addrs should be in 	 * kernel space */
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_WRITE
argument_list|,
name|rbuf
operator|->
name|spOffset
argument_list|,
name|sectorsPerRU
argument_list|,
name|rbuf
operator|->
name|buffer
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
name|ReconWriteDoneProc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rbuf
argument_list|,
name|NULL
argument_list|,
operator|&
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|fcol
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* XXX -- fix this -- XXX */
name|rbuf
operator|->
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
name|raidPtr
operator|->
name|Queues
index|[
name|rbuf
operator|->
name|spRow
index|]
index|[
name|rbuf
operator|->
name|spCol
index|]
argument_list|,
name|req
argument_list|,
name|RF_IO_RECON_PRIORITY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this gets called upon the completion of a reconstruction read  * operation the arg is a pointer to the per-disk reconstruction  * control structure for the process that just finished a read.  *  * called at interrupt context in the kernel, so don't do anything  * illegal here.    */
end_comment

begin_function
specifier|static
name|int
name|ReconReadDoneProc
parameter_list|(
name|arg
parameter_list|,
name|status
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
init|=
operator|(
name|RF_PerDiskReconCtrl_t
operator|*
operator|)
name|arg
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|ctrl
operator|->
name|reconCtrl
operator|->
name|reconDesc
operator|->
name|raidPtr
decl_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* 	         * XXX 	         */
name|printf
argument_list|(
literal|"Recon read failed!\n"
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|ctrl
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|ctrl
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|ctrl
operator|->
name|col
index|]
operator|.
name|specific
operator|.
name|recon
operator|.
name|recon_fetch_to_return_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|ctrl
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|ctrl
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|ctrl
operator|->
name|row
argument_list|,
name|ctrl
operator|->
name|col
argument_list|,
name|NULL
argument_list|,
name|RF_REVENT_READDONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this gets called upon the completion of a reconstruction write operation.  * the arg is a pointer to the rbuf that was just written  *  * called at interrupt context in the kernel, so don't do anything illegal here.  */
end_comment

begin_function
specifier|static
name|int
name|ReconWriteDoneProc
parameter_list|(
name|arg
parameter_list|,
name|status
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|RF_ReconBuffer_t
modifier|*
name|rbuf
init|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|arg
decl_stmt|;
name|Dprintf2
argument_list|(
literal|"Reconstruction completed on psid %ld ru %d\n"
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|printf
argument_list|(
literal|"Recon write failed!\n"
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr,"Recon 							 * write failed!\n"); */
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|rf_CauseReconEvent
argument_list|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|rbuf
operator|->
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|,
name|arg
argument_list|,
name|RF_REVENT_WRITEDONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * computes a new minimum head sep, and wakes up anyone who needs to  * be woken as a result   */
end_comment

begin_function
specifier|static
name|void
name|CheckForNewMinHeadSep
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|hsCtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_HeadSepLimit_t
name|hsCtr
decl_stmt|;
block|{
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
decl_stmt|;
name|RF_HeadSepLimit_t
name|new_min
decl_stmt|;
name|RF_RowCol_t
name|i
decl_stmt|;
name|RF_CallbackDesc_t
modifier|*
name|p
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|hsCtr
operator|>=
name|reconCtrlPtr
operator|->
name|minHeadSepCounter
argument_list|)
expr_stmt|;
comment|/* from the definition 								 * of a minimum */
name|RF_LOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|new_min
operator|=
operator|~
operator|(
literal|1L
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* 0x7FFF....FFF */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|reconCtrlPtr
operator|->
name|fcol
condition|)
block|{
if|if
condition|(
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|headSepCounter
operator|<
name|new_min
condition|)
name|new_min
operator|=
name|reconCtrlPtr
operator|->
name|perDiskInfo
index|[
name|i
index|]
operator|.
name|headSepCounter
expr_stmt|;
block|}
comment|/* set the new minimum and wake up anyone who can now run again */
if|if
condition|(
name|new_min
operator|!=
name|reconCtrlPtr
operator|->
name|minHeadSepCounter
condition|)
block|{
name|reconCtrlPtr
operator|->
name|minHeadSepCounter
operator|=
name|new_min
expr_stmt|;
name|Dprintf1
argument_list|(
literal|"RECON:  new min head pos counter val is %ld\n"
argument_list|,
name|new_min
argument_list|)
expr_stmt|;
while|while
condition|(
name|reconCtrlPtr
operator|->
name|headSepCBList
condition|)
block|{
if|if
condition|(
name|reconCtrlPtr
operator|->
name|headSepCBList
operator|->
name|callbackArg
operator|.
name|v
operator|>
name|new_min
condition|)
break|break;
name|p
operator|=
name|reconCtrlPtr
operator|->
name|headSepCBList
expr_stmt|;
name|reconCtrlPtr
operator|->
name|headSepCBList
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|p
operator|->
name|row
argument_list|,
name|p
operator|->
name|col
argument_list|,
name|NULL
argument_list|,
name|RF_REVENT_HEADSEPCLEAR
argument_list|)
expr_stmt|;
name|rf_FreeCallbackDesc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * checks to see that the maximum head separation will not be violated  * if we initiate a reconstruction I/O on the indicated disk.  * Limiting the maximum head separation between two disks eliminates  * the nasty buffer-stall conditions that occur when one disk races  * ahead of the others and consumes all of the floating recon buffers.  * This code is complex and unpleasant but it's necessary to avoid  * some very nasty, albeit fairly rare, reconstruction behavior.  *  * returns non-zero if and only if we have to stop working on the  * indicated disk due to a head-separation delay.    */
end_comment

begin_function
specifier|static
name|int
name|CheckHeadSeparation
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_HeadSepLimit_t
name|hsCtr
parameter_list|,
name|RF_ReconUnitNum_t
name|which_ru
parameter_list|)
block|{
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
decl_stmt|;
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* if we're too far ahead of the slowest disk, stop working on this 	 * disk until the slower ones catch up.  We do this by scheduling a 	 * wakeup callback for the time when the slowest disk has caught up. 	 * We define "caught up" with 20% hysteresis, i.e. the head separation 	 * must have fallen to at most 80% of the max allowable head 	 * separation before we'll wake up. 	 *  	 */
name|RF_LOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|headSepLimit
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ctrl
operator|->
name|headSepCounter
operator|-
name|reconCtrlPtr
operator|->
name|minHeadSepCounter
operator|)
operator|>
name|raidPtr
operator|->
name|headSepLimit
operator|)
condition|)
block|{
name|Dprintf6
argument_list|(
literal|"raid%d: RECON: head sep stall: row %d col %d hsCtr %ld minHSCtr %ld limit %ld\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|ctrl
operator|->
name|headSepCounter
argument_list|,
name|reconCtrlPtr
operator|->
name|minHeadSepCounter
argument_list|,
name|raidPtr
operator|->
name|headSepLimit
argument_list|)
expr_stmt|;
name|cb
operator|=
name|rf_AllocCallbackDesc
argument_list|()
expr_stmt|;
comment|/* the minHeadSepCounter value we have to get to before we'll 		 * wake up.  build in 20% hysteresis. */
name|cb
operator|->
name|callbackArg
operator|.
name|v
operator|=
operator|(
name|ctrl
operator|->
name|headSepCounter
operator|-
name|raidPtr
operator|->
name|headSepLimit
operator|+
name|raidPtr
operator|->
name|headSepLimit
operator|/
literal|5
operator|)
expr_stmt|;
name|cb
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|cb
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* insert this callback descriptor into the sorted list of 		 * pending head-sep callbacks */
name|p
operator|=
name|reconCtrlPtr
operator|->
name|headSepCBList
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|reconCtrlPtr
operator|->
name|headSepCBList
operator|=
name|cb
expr_stmt|;
elseif|else
if|if
condition|(
name|cb
operator|->
name|callbackArg
operator|.
name|v
operator|<
name|p
operator|->
name|callbackArg
operator|.
name|v
condition|)
block|{
name|cb
operator|->
name|next
operator|=
name|reconCtrlPtr
operator|->
name|headSepCBList
expr_stmt|;
name|reconCtrlPtr
operator|->
name|headSepCBList
operator|=
name|cb
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|pt
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
init|;
name|p
operator|&&
operator|(
name|p
operator|->
name|callbackArg
operator|.
name|v
operator|<
name|cb
operator|->
name|callbackArg
operator|.
name|v
operator|)
condition|;
name|pt
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|cb
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|pt
operator|->
name|next
operator|=
name|cb
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|ctrl
operator|->
name|reconCtrl
operator|->
name|reconDesc
operator|->
name|hsStallCount
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * checks to see if reconstruction has been either forced or blocked  * by a user operation.  if forced, we skip this RU entirely.  else if  * blocked, put ourselves on the wait list.  else return 0.  *  * ASSUMES THE PSS MUTEX IS LOCKED UPON ENTRY   */
end_comment

begin_function
specifier|static
name|int
name|CheckForcedOrBlockedReconstruction
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
parameter_list|,
name|RF_PerDiskReconCtrl_t
modifier|*
name|ctrl
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|RF_StripeNum_t
name|psid
parameter_list|,
name|RF_ReconUnitNum_t
name|which_ru
parameter_list|)
block|{
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_FORCED_ON_READ
operator|)
operator|||
operator|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_FORCED_ON_WRITE
operator|)
condition|)
name|retcode
operator|=
name|RF_PSS_FORCED_ON_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_RECON_BLOCKED
condition|)
block|{
name|Dprintf4
argument_list|(
literal|"RECON: row %d col %d blocked at psid %ld ru %d\n"
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|cb
operator|=
name|rf_AllocCallbackDesc
argument_list|()
expr_stmt|;
comment|/* append ourselves to 							 * the blockage-wait 							 * list */
name|cb
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|cb
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|pssPtr
operator|->
name|blockWaitList
expr_stmt|;
name|pssPtr
operator|->
name|blockWaitList
operator|=
name|cb
expr_stmt|;
name|retcode
operator|=
name|RF_PSS_RECON_BLOCKED
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retcode
condition|)
name|pssPtr
operator|->
name|flags
operator||=
name|RF_PSS_UNDER_RECON
expr_stmt|;
comment|/* mark this RU as under 							 * reconstruction */
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * if reconstruction is currently ongoing for the indicated stripeID,  * reconstruction is forced to completion and we return non-zero to  * indicate that the caller must wait.  If not, then reconstruction is  * blocked on the indicated stripe and the routine returns zero.  If  * and only if we return non-zero, we'll cause the cbFunc to get  * invoked with the cbArg when the reconstruction has completed.    */
end_comment

begin_decl_stmt
name|int
name|rf_ForceOrBlockRecon
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|cbFunc
argument_list|,
name|cbArg
argument_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|cbFunc
function_decl|)
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|cbArg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RF_RowCol_t
name|row
init|=
name|asmap
operator|->
name|physInfo
operator|->
name|row
decl_stmt|;
comment|/* which row of the array 						 * we're working on */
name|RF_StripeNum_t
name|stripeID
init|=
name|asmap
operator|->
name|stripeID
decl_stmt|;
comment|/* the stripe ID we're 							 * forcing recon on */
name|RF_SectorCount_t
name|sectorsPerRU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerRU
decl_stmt|;
comment|/* num sects in one RU */
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
comment|/* a pointer to the parity 						 * stripe status structure */
name|RF_StripeNum_t
name|psid
decl_stmt|;
comment|/* parity stripe id */
name|RF_SectorNum_t
name|offset
decl_stmt|,
name|fd_offset
decl_stmt|;
comment|/* disk offset, failed-disk 						 * offset */
name|RF_RowCol_t
modifier|*
name|diskids
decl_stmt|;
name|RF_RowCol_t
name|stripe
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
comment|/* RU within parity stripe */
name|RF_RowCol_t
name|fcol
decl_stmt|,
name|diskno
decl_stmt|,
name|i
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|new_rbuf
decl_stmt|;
comment|/* ptr to newly allocated rbufs */
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
comment|/* disk I/O req to be enqueued */
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|;
name|int
name|created
init|=
literal|0
decl_stmt|,
name|nPromoted
decl_stmt|;
name|psid
operator|=
name|rf_MapStripeIDToParityStripeID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|stripeID
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|RF_LOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
name|pssPtr
operator|=
name|rf_LookupRUStatus
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|pssTable
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|,
name|RF_PSS_CREATE
operator||
name|RF_PSS_RECON_BLOCKED
argument_list|,
operator|&
name|created
argument_list|)
expr_stmt|;
comment|/* if recon is not ongoing on this PS, just return */
if|if
condition|(
operator|!
operator|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_UNDER_RECON
operator|)
condition|)
block|{
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* otherwise, we have to wait for reconstruction to complete on this 	 * RU. */
comment|/* In order to avoid waiting for a potentially large number of 	 * low-priority accesses to complete, we force a normal-priority (i.e. 	 * not low-priority) reconstruction on this RU. */
if|if
condition|(
operator|!
operator|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_FORCED_ON_WRITE
operator|)
operator|&&
operator|!
operator|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_FORCED_ON_READ
operator|)
condition|)
block|{
name|DDprintf1
argument_list|(
literal|"Forcing recon on psid %ld\n"
argument_list|,
name|psid
argument_list|)
expr_stmt|;
name|pssPtr
operator|->
name|flags
operator||=
name|RF_PSS_FORCED_ON_WRITE
expr_stmt|;
comment|/* mark this RU as under 								 * forced recon */
name|pssPtr
operator|->
name|flags
operator|&=
operator|~
name|RF_PSS_RECON_BLOCKED
expr_stmt|;
comment|/* clear the blockage 							 * that we just set */
name|fcol
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|fcol
expr_stmt|;
comment|/* get a listing of the disks comprising the indicated stripe */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|IdentifyStripe
call|)
argument_list|(
name|raidPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|diskids
argument_list|,
operator|&
name|stripe
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|row
operator|==
name|stripe
argument_list|)
expr_stmt|;
comment|/* For previously issued reads, elevate them to normal 		 * priority.  If the I/O has already completed, it won't be 		 * found in the queue, and hence this will be a no-op. For 		 * unissued reads, allocate buffers and issue new reads.  The 		 * fact that we've set the FORCED bit means that the regular 		 * recon procs will not re-issue these reqs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|+
name|raidPtr
operator|->
name|Layout
operator|.
name|numParityCol
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|diskno
operator|=
name|diskids
index|[
name|i
index|]
operator|)
operator|!=
name|fcol
condition|)
block|{
if|if
condition|(
name|pssPtr
operator|->
name|issued
index|[
name|diskno
index|]
condition|)
block|{
name|nPromoted
operator|=
name|rf_DiskIOPromote
argument_list|(
operator|&
name|raidPtr
operator|->
name|Queues
index|[
name|row
index|]
index|[
name|diskno
index|]
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_reconDebug
operator|&&
name|nPromoted
condition|)
name|printf
argument_list|(
literal|"raid%d: promoted read from row %d col %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|row
argument_list|,
name|diskno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_rbuf
operator|=
name|rf_MakeReconBuffer
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|diskno
argument_list|,
name|RF_RBUF_TYPE_FORCED
argument_list|)
expr_stmt|;
comment|/* create new buf */
name|ComputePSDiskOffsets
argument_list|(
name|raidPtr
argument_list|,
name|psid
argument_list|,
name|row
argument_list|,
name|diskno
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|fd_offset
argument_list|,
operator|&
name|new_rbuf
operator|->
name|spRow
argument_list|,
operator|&
name|new_rbuf
operator|->
name|spCol
argument_list|,
operator|&
name|new_rbuf
operator|->
name|spOffset
argument_list|)
expr_stmt|;
comment|/* find offsets& spare 													 * location */
name|new_rbuf
operator|->
name|parityStripeID
operator|=
name|psid
expr_stmt|;
comment|/* fill in the buffer */
name|new_rbuf
operator|->
name|which_ru
operator|=
name|which_ru
expr_stmt|;
name|new_rbuf
operator|->
name|failedDiskSectorOffset
operator|=
name|fd_offset
expr_stmt|;
name|new_rbuf
operator|->
name|priority
operator|=
name|RF_IO_NORMAL_PRIORITY
expr_stmt|;
comment|/* use NULL b_proc b/c all addrs 					 * should be in kernel space */
name|req
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_READ
argument_list|,
name|offset
operator|+
name|which_ru
operator|*
name|sectorsPerRU
argument_list|,
name|sectorsPerRU
argument_list|,
name|new_rbuf
operator|->
name|buffer
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|ForceReconReadDoneProc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_rbuf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* XXX -- fix this -- 							 * XXX */
name|new_rbuf
operator|->
name|arg
operator|=
name|req
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
name|raidPtr
operator|->
name|Queues
index|[
name|row
index|]
index|[
name|diskno
index|]
argument_list|,
name|req
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
comment|/* enqueue the I/O */
name|Dprintf3
argument_list|(
literal|"raid%d: Issued new read req on row %d col %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|row
argument_list|,
name|diskno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the write is sitting in the disk queue, elevate its 		 * priority */
if|if
condition|(
name|rf_DiskIOPromote
argument_list|(
operator|&
name|raidPtr
operator|->
name|Queues
index|[
name|row
index|]
index|[
name|fcol
index|]
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|)
condition|)
name|printf
argument_list|(
literal|"raid%d: promoted write to row %d col %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|row
argument_list|,
name|fcol
argument_list|)
expr_stmt|;
block|}
comment|/* install a callback descriptor to be invoked when recon completes on 	 * this parity stripe. */
name|cb
operator|=
name|rf_AllocCallbackDesc
argument_list|()
expr_stmt|;
comment|/* XXX the following is bogus.. These functions don't really match!! 	 * GO */
name|cb
operator|->
name|callbackFunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|RF_CBParam_t
argument_list|)
operator|)
name|cbFunc
expr_stmt|;
name|cb
operator|->
name|callbackArg
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|cbArg
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|pssPtr
operator|->
name|procWaitList
expr_stmt|;
name|pssPtr
operator|->
name|procWaitList
operator|=
name|cb
expr_stmt|;
name|DDprintf2
argument_list|(
literal|"raid%d: Waiting for forced recon on psid %ld\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|psid
argument_list|)
expr_stmt|;
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* called upon the completion of a forced reconstruction read.  * all we do is schedule the FORCEDREADONE event.  * called at interrupt context in the kernel, so don't do anything illegal here.  */
end_comment

begin_function
specifier|static
name|void
name|ForceReconReadDoneProc
parameter_list|(
name|arg
parameter_list|,
name|status
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|RF_ReconBuffer_t
modifier|*
name|rbuf
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|printf
argument_list|(
literal|"Forced recon read failed!\n"
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr,"Forced 							 *  recon read 							 * failed!\n"); */
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|rf_CauseReconEvent
argument_list|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|rbuf
operator|->
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rbuf
argument_list|,
name|RF_REVENT_FORCEDREADDONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* releases a block on the reconstruction of the indicated stripe */
end_comment

begin_function
name|int
name|rf_UnblockRecon
parameter_list|(
name|raidPtr
parameter_list|,
name|asmap
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
block|{
name|RF_RowCol_t
name|row
init|=
name|asmap
operator|->
name|origRow
decl_stmt|;
name|RF_StripeNum_t
name|stripeID
init|=
name|asmap
operator|->
name|stripeID
decl_stmt|;
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_StripeNum_t
name|psid
decl_stmt|;
name|int
name|created
init|=
literal|0
decl_stmt|;
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|;
name|psid
operator|=
name|rf_MapStripeIDToParityStripeID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|stripeID
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|RF_LOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
name|pssPtr
operator|=
name|rf_LookupRUStatus
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|pssTable
argument_list|,
name|psid
argument_list|,
name|which_ru
argument_list|,
name|RF_PSS_NONE
argument_list|,
operator|&
name|created
argument_list|)
expr_stmt|;
comment|/* When recon is forced, the pss desc can get deleted before we get 	 * back to unblock recon. But, this can _only_ happen when recon is 	 * forced. It would be good to put some kind of sanity check here, but 	 * how to decide if recon was just forced or not? */
if|if
condition|(
operator|!
name|pssPtr
condition|)
block|{
comment|/* printf("Warning: no pss descriptor upon unblock on psid %ld 		 * RU %d\n",psid,which_ru); */
if|if
condition|(
name|rf_reconDebug
operator|||
name|rf_pssDebug
condition|)
name|printf
argument_list|(
literal|"Warning: no pss descriptor upon unblock on psid %ld RU %d\n"
argument_list|,
operator|(
name|long
operator|)
name|psid
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pssPtr
operator|->
name|blockCount
operator|--
expr_stmt|;
name|Dprintf3
argument_list|(
literal|"raid%d: unblocking recon on psid %ld: blockcount is %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|psid
argument_list|,
name|pssPtr
operator|->
name|blockCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|pssPtr
operator|->
name|blockCount
operator|==
literal|0
condition|)
block|{
comment|/* if recon blockage has been released */
comment|/* unblock recon before calling CauseReconEvent in case 		 * CauseReconEvent causes us to try to issue a new read before 		 * returning here. */
name|pssPtr
operator|->
name|flags
operator|&=
operator|~
name|RF_PSS_RECON_BLOCKED
expr_stmt|;
while|while
condition|(
name|pssPtr
operator|->
name|blockWaitList
condition|)
block|{
comment|/* spin through the block-wait list and 			   release all the waiters */
name|cb
operator|=
name|pssPtr
operator|->
name|blockWaitList
expr_stmt|;
name|pssPtr
operator|->
name|blockWaitList
operator|=
name|cb
operator|->
name|next
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|cb
operator|->
name|row
argument_list|,
name|cb
operator|->
name|col
argument_list|,
name|NULL
argument_list|,
name|RF_REVENT_BLOCKCLEAR
argument_list|)
expr_stmt|;
name|rf_FreeCallbackDesc
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|pssPtr
operator|->
name|flags
operator|&
name|RF_PSS_UNDER_RECON
operator|)
condition|)
block|{
comment|/* if no recon was requested while recon was blocked */
name|rf_PSStatusDelete
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|pssTable
argument_list|,
name|pssPtr
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|psid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

