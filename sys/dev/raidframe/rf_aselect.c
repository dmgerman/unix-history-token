begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_aselect.c,v 1.3 1999/02/05 00:06:06 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*****************************************************************************  *  * aselect.c -- algorithm selection code  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_comment
comment|/* the function below is not used... so don't define it! */
end_comment

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|TransferDagMemory
parameter_list|(
name|RF_DagHeader_t
modifier|*
parameter_list|,
name|RF_DagHeader_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|InitHdrNode
parameter_list|(
name|RF_DagHeader_t
modifier|*
modifier|*
parameter_list|,
name|RF_Raid_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|UpdateNodeHdrPtr
parameter_list|(
name|RF_DagHeader_t
modifier|*
parameter_list|,
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rf_SelectAlgorithm
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
parameter_list|,
name|RF_RaidAccessFlags_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************  *  * Create and Initialiaze a dag header and termination node  *  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|InitHdrNode
parameter_list|(
name|hdr
parameter_list|,
name|raidPtr
parameter_list|,
name|memChunkEnable
parameter_list|)
name|RF_DagHeader_t
modifier|*
modifier|*
name|hdr
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|memChunkEnable
decl_stmt|;
block|{
comment|/* create and initialize dag hdr */
operator|*
name|hdr
operator|=
name|rf_AllocDAGHeader
argument_list|()
expr_stmt|;
name|rf_MakeAllocList
argument_list|(
operator|(
operator|*
name|hdr
operator|)
operator|->
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|hdr
operator|)
operator|->
name|allocList
operator|==
name|NULL
condition|)
block|{
name|rf_FreeDAGHeader
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
operator|*
name|hdr
operator|)
operator|->
name|status
operator|=
name|rf_enable
expr_stmt|;
operator|(
operator|*
name|hdr
operator|)
operator|->
name|numSuccedents
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|hdr
operator|)
operator|->
name|raidPtr
operator|=
name|raidPtr
expr_stmt|;
operator|(
operator|*
name|hdr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * Transfer allocation list and mem chunks from one dag to another  *  *****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_comment
comment|/* the function below is not used... so don't define it! */
end_comment

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|TransferDagMemory
parameter_list|(
name|daga
parameter_list|,
name|dagb
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|daga
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dagb
decl_stmt|;
block|{
name|RF_AccessStripeMapHeader_t
modifier|*
name|end
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|memChunksXfrd
init|=
literal|0
decl_stmt|,
name|xtraChunksXfrd
init|=
literal|0
decl_stmt|;
comment|/* transfer allocList from dagb to daga */
for|for
control|(
name|p
operator|=
name|dagb
operator|->
name|allocList
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|numPointers
condition|;
name|i
operator|++
control|)
block|{
name|rf_AddToAllocList
argument_list|(
name|daga
operator|->
name|allocList
argument_list|,
name|p
operator|->
name|pointers
index|[
name|i
index|]
argument_list|,
name|p
operator|->
name|sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|pointers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|sizes
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|numPointers
operator|=
literal|0
expr_stmt|;
block|}
comment|/* transfer chunks from dagb to daga */
while|while
condition|(
operator|(
name|memChunksXfrd
operator|+
name|xtraChunksXfrd
operator|<
name|dagb
operator|->
name|chunkIndex
operator|+
name|dagb
operator|->
name|xtraChunkIndex
operator|)
operator|&&
operator|(
name|daga
operator|->
name|chunkIndex
operator|<
name|RF_MAXCHUNKS
operator|)
condition|)
block|{
comment|/* stuff chunks into daga's memChunk array */
if|if
condition|(
name|memChunksXfrd
operator|<
name|dagb
operator|->
name|chunkIndex
condition|)
block|{
name|daga
operator|->
name|memChunk
index|[
name|daga
operator|->
name|chunkIndex
operator|++
index|]
operator|=
name|dagb
operator|->
name|memChunk
index|[
name|memChunksXfrd
index|]
expr_stmt|;
name|dagb
operator|->
name|memChunk
index|[
name|memChunksXfrd
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|daga
operator|->
name|memChunk
index|[
name|daga
operator|->
name|xtraChunkIndex
operator|++
index|]
operator|=
name|dagb
operator|->
name|xtraMemChunk
index|[
name|xtraChunksXfrd
index|]
expr_stmt|;
name|dagb
operator|->
name|xtraMemChunk
index|[
name|xtraChunksXfrd
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* use escape hatch to hold excess chunks */
while|while
condition|(
name|memChunksXfrd
operator|+
name|xtraChunksXfrd
operator|<
name|dagb
operator|->
name|chunkIndex
operator|+
name|dagb
operator|->
name|xtraChunkIndex
condition|)
block|{
if|if
condition|(
name|memChunksXfrd
operator|<
name|dagb
operator|->
name|chunkIndex
condition|)
block|{
name|daga
operator|->
name|xtraMemChunk
index|[
name|daga
operator|->
name|xtraChunkIndex
operator|++
index|]
operator|=
name|dagb
operator|->
name|memChunk
index|[
name|memChunksXfrd
index|]
expr_stmt|;
name|dagb
operator|->
name|memChunk
index|[
name|memChunksXfrd
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|daga
operator|->
name|xtraMemChunk
index|[
name|daga
operator|->
name|xtraChunkIndex
operator|++
index|]
operator|=
name|dagb
operator|->
name|xtraMemChunk
index|[
name|xtraChunksXfrd
index|]
expr_stmt|;
name|dagb
operator|->
name|xtraMemChunk
index|[
name|xtraChunksXfrd
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|RF_ASSERT
argument_list|(
operator|(
name|memChunksXfrd
operator|==
name|dagb
operator|->
name|chunkIndex
operator|)
operator|&&
operator|(
name|xtraChunksXfrd
operator|==
name|dagb
operator|->
name|xtraChunkIndex
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|daga
operator|->
name|chunkIndex
operator|<=
name|RF_MAXCHUNKS
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|daga
operator|->
name|xtraChunkIndex
operator|<=
name|daga
operator|->
name|xtraChunkCnt
argument_list|)
expr_stmt|;
name|dagb
operator|->
name|chunkIndex
operator|=
literal|0
expr_stmt|;
name|dagb
operator|->
name|xtraChunkIndex
operator|=
literal|0
expr_stmt|;
comment|/* transfer asmList from dagb to daga */
if|if
condition|(
name|dagb
operator|->
name|asmList
condition|)
block|{
if|if
condition|(
name|daga
operator|->
name|asmList
condition|)
block|{
name|end
operator|=
name|daga
operator|->
name|asmList
expr_stmt|;
while|while
condition|(
name|end
operator|->
name|next
condition|)
name|end
operator|=
name|end
operator|->
name|next
expr_stmt|;
name|end
operator|->
name|next
operator|=
name|dagb
operator|->
name|asmList
expr_stmt|;
block|}
else|else
name|daga
operator|->
name|asmList
operator|=
name|dagb
operator|->
name|asmList
expr_stmt|;
name|dagb
operator|->
name|asmList
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_comment
comment|/*****************************************************************************************  *  * Ensure that all node->dagHdr fields in a dag are consistent  *  * IMPORTANT: This routine recursively searches all succedents of the node.  If a  * succedent is encountered whose dagHdr ptr does not require adjusting, that node's  * succedents WILL NOT BE EXAMINED.  *  ****************************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|UpdateNodeHdrPtr
parameter_list|(
name|hdr
parameter_list|,
name|node
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|hdr
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|hdr
operator|!=
name|NULL
operator|&&
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|dagHdr
operator|!=
name|hdr
condition|)
name|UpdateNodeHdrPtr
argument_list|(
name|hdr
argument_list|,
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|node
operator|->
name|dagHdr
operator|=
name|hdr
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * Create a DAG to do a read or write operation.  *  * create an array of dagLists, one list per parity stripe.  * return the lists in the array desc->dagArray.  *  * Normally, each list contains one dag for the entire stripe.  In some  * tricky cases, we break this into multiple dags, either one per stripe  * unit or one per block (sector).  When this occurs, these dags are returned  * as a linked list (dagList) which is executed sequentially (to preserve  * atomic parity updates in the stripe).  *  * dags which operate on independent parity goups (stripes) are returned in  * independent dagLists (distinct elements in desc->dagArray) and may be  * executed concurrently.  *  * Finally, if the SelectionFunc fails to create a dag for a block, we punt  * and return 1.  *  * The above process is performed in two phases:  *   1) create an array(s) of creation functions (eg stripeFuncs)  *   2) create dags and concatenate/merge to form the final dag.  *  * Because dag's are basic blocks (single entry, single exit, unconditional  * control flow, we can add the following optimizations (future work):  *   first-pass optimizer to allow max concurrency (need all data dependencies)  *   second-pass optimizer to eliminate common subexpressions (need true  *                         data dependencies)  *   third-pass optimizer to eliminate dead code (need true data dependencies)  *****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|MAXNSTRIPES
value|5
end_define

begin_function
name|int
name|rf_SelectAlgorithm
parameter_list|(
name|desc
parameter_list|,
name|flags
parameter_list|)
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
block|{
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
init|=
name|desc
operator|->
name|asmap
decl_stmt|;
name|RF_IoType_t
name|type
init|=
name|desc
operator|->
name|type
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|void
modifier|*
name|bp
init|=
name|desc
operator|->
name|bp
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
init|=
name|asm_h
operator|->
name|stripeMap
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asm_p
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dag_h
init|=
name|NULL
decl_stmt|,
modifier|*
name|tempdag_h
decl_stmt|,
modifier|*
name|lastdag_h
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|RF_VoidFuncPtr
modifier|*
name|stripeFuncs
decl_stmt|,
name|normalStripeFuncs
index|[
name|MAXNSTRIPES
index|]
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asm_up
decl_stmt|,
modifier|*
name|asm_bp
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
modifier|*
modifier|*
name|asmh_u
decl_stmt|,
modifier|*
name|endASMList
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
modifier|*
modifier|*
name|asmh_b
decl_stmt|;
name|RF_VoidFuncPtr
modifier|*
modifier|*
name|stripeUnitFuncs
decl_stmt|,
name|uFunc
decl_stmt|;
name|RF_VoidFuncPtr
modifier|*
modifier|*
name|blockFuncs
decl_stmt|,
name|bFunc
decl_stmt|;
name|int
name|numStripesBailed
init|=
literal|0
decl_stmt|,
name|cantCreateDAGs
init|=
name|RF_FALSE
decl_stmt|;
name|int
name|numStripeUnitsBailed
init|=
literal|0
decl_stmt|;
name|int
name|stripeNum
decl_stmt|,
name|numUnitDags
init|=
literal|0
decl_stmt|,
name|stripeUnitNum
decl_stmt|,
name|numBlockDags
init|=
literal|0
decl_stmt|;
name|RF_StripeNum_t
name|numStripeUnits
decl_stmt|;
name|RF_SectorNum_t
name|numBlocks
decl_stmt|;
name|RF_RaidAddr_t
name|address
decl_stmt|;
name|int
name|length
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|physPtr
decl_stmt|;
name|caddr_t
name|buffer
decl_stmt|;
name|lastdag_h
operator|=
name|NULL
expr_stmt|;
name|asmh_u
operator|=
name|asmh_b
operator|=
name|NULL
expr_stmt|;
name|stripeUnitFuncs
operator|=
name|NULL
expr_stmt|;
name|blockFuncs
operator|=
name|NULL
expr_stmt|;
comment|/* get an array of dag-function creation pointers, try to avoid 	 * calling malloc */
if|if
condition|(
name|asm_h
operator|->
name|numStripes
operator|<=
name|MAXNSTRIPES
condition|)
name|stripeFuncs
operator|=
name|normalStripeFuncs
expr_stmt|;
else|else
name|RF_Calloc
argument_list|(
name|stripeFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|,
operator|(
name|RF_VoidFuncPtr
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* walk through the asm list once collecting information */
comment|/* attempt to find a single creation function for each stripe */
name|desc
operator|->
name|numStripes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|asm_p
operator|=
name|asmap
init|;
name|asm_p
condition|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|numStripes
operator|++
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|SelectionFunc
call|)
argument_list|(
name|raidPtr
argument_list|,
name|type
argument_list|,
name|asm_p
argument_list|,
operator|&
name|stripeFuncs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* check to see if we found a creation func for this stripe */
if|if
condition|(
name|stripeFuncs
index|[
name|i
index|]
operator|==
operator|(
name|RF_VoidFuncPtr
operator|)
name|NULL
condition|)
block|{
comment|/* could not find creation function for entire stripe 			 * so, let's see if we can find one for each stripe 			 * unit in the stripe */
if|if
condition|(
name|numStripesBailed
operator|==
literal|0
condition|)
block|{
comment|/* one stripe map header for each stripe we 				 * bail on */
name|RF_Malloc
argument_list|(
name|asmh_u
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
argument_list|)
operator|*
name|asm_h
operator|->
name|numStripes
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* create an array of ptrs to arrays of 				 * stripeFuncs */
name|RF_Calloc
argument_list|(
name|stripeUnitFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|,
operator|(
name|RF_VoidFuncPtr
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* create an array of creation funcs (called 			 * stripeFuncs) for this stripe */
name|numStripeUnits
operator|=
name|asm_p
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|RF_Calloc
argument_list|(
name|stripeUnitFuncs
index|[
name|numStripesBailed
index|]
argument_list|,
name|numStripeUnits
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|,
operator|(
name|RF_VoidFuncPtr
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|asmh_u
index|[
name|numStripesBailed
index|]
argument_list|,
name|numStripeUnits
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* lookup array of stripeUnitFuncs for this stripe */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|physPtr
operator|=
name|asm_p
operator|->
name|physInfo
init|;
name|physPtr
condition|;
name|physPtr
operator|=
name|physPtr
operator|->
name|next
operator|,
name|j
operator|++
control|)
block|{
comment|/* remap for series of single stripe-unit 				 * accesses */
name|address
operator|=
name|physPtr
operator|->
name|raidAddress
expr_stmt|;
name|length
operator|=
name|physPtr
operator|->
name|numSector
expr_stmt|;
name|buffer
operator|=
name|physPtr
operator|->
name|bufPtr
expr_stmt|;
name|asmh_u
index|[
name|numStripesBailed
index|]
index|[
name|j
index|]
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|address
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|asm_up
operator|=
name|asmh_u
index|[
name|numStripesBailed
index|]
index|[
name|j
index|]
operator|->
name|stripeMap
expr_stmt|;
comment|/* get the creation func for this stripe unit */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|SelectionFunc
call|)
argument_list|(
name|raidPtr
argument_list|,
name|type
argument_list|,
name|asm_up
argument_list|,
operator|&
operator|(
name|stripeUnitFuncs
index|[
name|numStripesBailed
index|]
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* check to see if we found a creation func 				 * for this stripe unit */
if|if
condition|(
name|stripeUnitFuncs
index|[
name|numStripesBailed
index|]
index|[
name|j
index|]
operator|==
operator|(
name|RF_VoidFuncPtr
operator|)
name|NULL
condition|)
block|{
comment|/* could not find creation function 					 * for stripe unit so, let's see if we 					 * can find one for each block in the 					 * stripe unit */
if|if
condition|(
name|numStripeUnitsBailed
operator|==
literal|0
condition|)
block|{
comment|/* one stripe map header for 						 * each stripe unit we bail on */
name|RF_Malloc
argument_list|(
name|asmh_b
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
argument_list|)
operator|*
name|asm_h
operator|->
name|numStripes
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* create an array of ptrs to 						 * arrays of blockFuncs */
name|RF_Calloc
argument_list|(
name|blockFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|,
operator|(
name|RF_VoidFuncPtr
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* create an array of creation funcs 					 * (called blockFuncs) for this stripe 					 * unit */
name|numBlocks
operator|=
name|physPtr
operator|->
name|numSector
expr_stmt|;
name|numBlockDags
operator|+=
name|numBlocks
expr_stmt|;
name|RF_Calloc
argument_list|(
name|blockFuncs
index|[
name|numStripeUnitsBailed
index|]
argument_list|,
name|numBlocks
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|,
operator|(
name|RF_VoidFuncPtr
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|asmh_b
index|[
name|numStripeUnitsBailed
index|]
argument_list|,
name|numBlocks
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* lookup array of blockFuncs for this 					 * stripe unit */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numBlocks
condition|;
name|k
operator|++
control|)
block|{
comment|/* remap for series of single 						 * stripe-unit accesses */
name|address
operator|=
name|physPtr
operator|->
name|raidAddress
operator|+
name|k
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
name|buffer
operator|=
name|physPtr
operator|->
name|bufPtr
operator|+
operator|(
name|k
operator|*
operator|(
literal|1
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
operator|)
operator|)
expr_stmt|;
name|asmh_b
index|[
name|numStripeUnitsBailed
index|]
index|[
name|k
index|]
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|address
argument_list|,
name|length
argument_list|,
name|buffer
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|asm_bp
operator|=
name|asmh_b
index|[
name|numStripeUnitsBailed
index|]
index|[
name|k
index|]
operator|->
name|stripeMap
expr_stmt|;
comment|/* get the creation func for 						 * this stripe unit */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|SelectionFunc
call|)
argument_list|(
name|raidPtr
argument_list|,
name|type
argument_list|,
name|asm_bp
argument_list|,
operator|&
operator|(
name|blockFuncs
index|[
name|numStripeUnitsBailed
index|]
index|[
name|k
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* check to see if we found a 						 * creation func for this 						 * stripe unit */
if|if
condition|(
name|blockFuncs
index|[
name|numStripeUnitsBailed
index|]
index|[
name|k
index|]
operator|==
name|NULL
condition|)
name|cantCreateDAGs
operator|=
name|RF_TRUE
expr_stmt|;
block|}
name|numStripeUnitsBailed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numUnitDags
operator|++
expr_stmt|;
block|}
block|}
name|RF_ASSERT
argument_list|(
name|j
operator|==
name|numStripeUnits
argument_list|)
expr_stmt|;
name|numStripesBailed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cantCreateDAGs
condition|)
block|{
comment|/* free memory and punt */
if|if
condition|(
name|asm_h
operator|->
name|numStripes
operator|>
name|MAXNSTRIPES
condition|)
name|RF_Free
argument_list|(
name|stripeFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numStripesBailed
operator|>
literal|0
condition|)
block|{
name|stripeNum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|asm_p
operator|=
name|asmap
init|;
name|asm_p
condition|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|stripeFuncs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|numStripeUnits
operator|=
name|asm_p
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numStripeUnits
condition|;
name|j
operator|++
control|)
name|rf_FreeAccessStripeMap
argument_list|(
name|asmh_u
index|[
name|stripeNum
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|asmh_u
index|[
name|stripeNum
index|]
argument_list|,
name|numStripeUnits
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|stripeUnitFuncs
index|[
name|stripeNum
index|]
argument_list|,
name|numStripeUnits
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
name|stripeNum
operator|++
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|stripeNum
operator|==
name|numStripesBailed
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|stripeUnitFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|asmh_u
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* begin dag creation */
name|stripeNum
operator|=
literal|0
expr_stmt|;
name|stripeUnitNum
operator|=
literal|0
expr_stmt|;
comment|/* create an array of dagLists and fill them in */
name|RF_CallocAndAdd
argument_list|(
name|desc
operator|->
name|dagArray
argument_list|,
name|desc
operator|->
name|numStripes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagList_t
argument_list|)
argument_list|,
operator|(
name|RF_DagList_t
operator|*
operator|)
argument_list|,
name|desc
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|asm_p
operator|=
name|asmap
init|;
name|asm_p
condition|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
comment|/* grab dag header for this stripe */
name|dag_h
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|desc
operator|=
name|desc
expr_stmt|;
if|if
condition|(
name|stripeFuncs
index|[
name|i
index|]
operator|==
operator|(
name|RF_VoidFuncPtr
operator|)
name|NULL
condition|)
block|{
comment|/* use bailout functions for this stripe */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|physPtr
operator|=
name|asm_p
operator|->
name|physInfo
init|;
name|physPtr
condition|;
name|physPtr
operator|=
name|physPtr
operator|->
name|next
operator|,
name|j
operator|++
control|)
block|{
name|uFunc
operator|=
name|stripeUnitFuncs
index|[
name|stripeNum
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|uFunc
operator|==
operator|(
name|RF_VoidFuncPtr
operator|)
name|NULL
condition|)
block|{
comment|/* use bailout functions for 						 * this stripe unit */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|physPtr
operator|->
name|numSector
condition|;
name|k
operator|++
control|)
block|{
comment|/* create a dag for 							 * this block */
name|InitHdrNode
argument_list|(
operator|&
name|tempdag_h
argument_list|,
name|raidPtr
argument_list|,
name|rf_useMemChunks
argument_list|)
expr_stmt|;
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|numDags
operator|++
expr_stmt|;
if|if
condition|(
name|dag_h
operator|==
name|NULL
condition|)
block|{
name|dag_h
operator|=
name|tempdag_h
expr_stmt|;
block|}
else|else
block|{
name|lastdag_h
operator|->
name|next
operator|=
name|tempdag_h
expr_stmt|;
block|}
name|lastdag_h
operator|=
name|tempdag_h
expr_stmt|;
name|bFunc
operator|=
name|blockFuncs
index|[
name|stripeUnitNum
index|]
index|[
name|k
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|bFunc
argument_list|)
expr_stmt|;
name|asm_bp
operator|=
name|asmh_b
index|[
name|stripeUnitNum
index|]
index|[
name|k
index|]
operator|->
name|stripeMap
expr_stmt|;
call|(
modifier|*
name|bFunc
call|)
argument_list|(
name|raidPtr
argument_list|,
name|asm_bp
argument_list|,
name|tempdag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|tempdag_h
operator|->
name|allocList
argument_list|)
expr_stmt|;
block|}
name|stripeUnitNum
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* create a dag for this unit */
name|InitHdrNode
argument_list|(
operator|&
name|tempdag_h
argument_list|,
name|raidPtr
argument_list|,
name|rf_useMemChunks
argument_list|)
expr_stmt|;
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|numDags
operator|++
expr_stmt|;
if|if
condition|(
name|dag_h
operator|==
name|NULL
condition|)
block|{
name|dag_h
operator|=
name|tempdag_h
expr_stmt|;
block|}
else|else
block|{
name|lastdag_h
operator|->
name|next
operator|=
name|tempdag_h
expr_stmt|;
block|}
name|lastdag_h
operator|=
name|tempdag_h
expr_stmt|;
name|asm_up
operator|=
name|asmh_u
index|[
name|stripeNum
index|]
index|[
name|j
index|]
operator|->
name|stripeMap
expr_stmt|;
call|(
modifier|*
name|uFunc
call|)
argument_list|(
name|raidPtr
argument_list|,
name|asm_up
argument_list|,
name|tempdag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|tempdag_h
operator|->
name|allocList
argument_list|)
expr_stmt|;
block|}
block|}
name|RF_ASSERT
argument_list|(
name|j
operator|==
name|asm_p
operator|->
name|numStripeUnitsAccessed
argument_list|)
expr_stmt|;
comment|/* merge linked bailout dag to existing dag 				 * collection */
name|stripeNum
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a dag for this parity stripe */
name|InitHdrNode
argument_list|(
operator|&
name|tempdag_h
argument_list|,
name|raidPtr
argument_list|,
name|rf_useMemChunks
argument_list|)
expr_stmt|;
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|numDags
operator|++
expr_stmt|;
if|if
condition|(
name|dag_h
operator|==
name|NULL
condition|)
block|{
name|dag_h
operator|=
name|tempdag_h
expr_stmt|;
block|}
else|else
block|{
name|lastdag_h
operator|->
name|next
operator|=
name|tempdag_h
expr_stmt|;
block|}
name|lastdag_h
operator|=
name|tempdag_h
expr_stmt|;
operator|(
name|stripeFuncs
index|[
name|i
index|]
operator|)
operator|(
name|raidPtr
operator|,
name|asm_p
operator|,
name|tempdag_h
operator|,
name|bp
operator|,
name|flags
operator|,
name|tempdag_h
operator|->
name|allocList
operator|)
expr_stmt|;
block|}
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
operator|=
name|dag_h
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|desc
operator|->
name|numStripes
argument_list|)
expr_stmt|;
comment|/* free memory */
if|if
condition|(
name|asm_h
operator|->
name|numStripes
operator|>
name|MAXNSTRIPES
condition|)
name|RF_Free
argument_list|(
name|stripeFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numStripesBailed
operator|>
literal|0
operator|)
operator|||
operator|(
name|numStripeUnitsBailed
operator|>
literal|0
operator|)
condition|)
block|{
name|stripeNum
operator|=
literal|0
expr_stmt|;
name|stripeUnitNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dag_h
operator|->
name|asmList
condition|)
block|{
name|endASMList
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
while|while
condition|(
name|endASMList
operator|->
name|next
condition|)
name|endASMList
operator|=
name|endASMList
operator|->
name|next
expr_stmt|;
block|}
else|else
name|endASMList
operator|=
name|NULL
expr_stmt|;
comment|/* walk through io, stripe by stripe */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|asm_p
operator|=
name|asmap
init|;
name|asm_p
condition|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|stripeFuncs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|numStripeUnits
operator|=
name|asm_p
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
comment|/* walk through stripe, stripe unit by 					 * stripe unit */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|physPtr
operator|=
name|asm_p
operator|->
name|physInfo
init|;
name|physPtr
condition|;
name|physPtr
operator|=
name|physPtr
operator|->
name|next
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|stripeUnitFuncs
index|[
name|stripeNum
index|]
index|[
name|j
index|]
operator|==
name|NULL
condition|)
block|{
name|numBlocks
operator|=
name|physPtr
operator|->
name|numSector
expr_stmt|;
comment|/* walk through stripe 							 * unit, block by 							 * block */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numBlocks
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|dag_h
operator|->
name|asmList
operator|==
name|NULL
condition|)
block|{
name|dag_h
operator|->
name|asmList
operator|=
name|asmh_b
index|[
name|stripeUnitNum
index|]
index|[
name|k
index|]
expr_stmt|;
name|endASMList
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
block|}
else|else
block|{
name|endASMList
operator|->
name|next
operator|=
name|asmh_b
index|[
name|stripeUnitNum
index|]
index|[
name|k
index|]
expr_stmt|;
name|endASMList
operator|=
name|endASMList
operator|->
name|next
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|asmh_b
index|[
name|stripeUnitNum
index|]
argument_list|,
name|numBlocks
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|blockFuncs
index|[
name|stripeUnitNum
index|]
argument_list|,
name|numBlocks
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
name|stripeUnitNum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dag_h
operator|->
name|asmList
operator|==
name|NULL
condition|)
block|{
name|dag_h
operator|->
name|asmList
operator|=
name|asmh_u
index|[
name|stripeNum
index|]
index|[
name|j
index|]
expr_stmt|;
name|endASMList
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
block|}
else|else
block|{
name|endASMList
operator|->
name|next
operator|=
name|asmh_u
index|[
name|stripeNum
index|]
index|[
name|j
index|]
expr_stmt|;
name|endASMList
operator|=
name|endASMList
operator|->
name|next
expr_stmt|;
block|}
block|}
name|RF_Free
argument_list|(
name|asmh_u
index|[
name|stripeNum
index|]
argument_list|,
name|numStripeUnits
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|stripeUnitFuncs
index|[
name|stripeNum
index|]
argument_list|,
name|numStripeUnits
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
name|stripeNum
operator|++
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|stripeNum
operator|==
name|numStripesBailed
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|stripeUnitFuncs
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|asmh_u
argument_list|,
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numStripeUnitsBailed
operator|>
literal|0
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|stripeUnitNum
operator|==
name|numStripeUnitsBailed
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|blockFuncs
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|*
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_VoidFuncPtr
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|asmh_b
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|*
name|asm_h
operator|->
name|numStripes
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

