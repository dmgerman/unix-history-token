begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_disks.c,v 1.34 2000/12/05 01:35:56 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Greg Oster  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/***************************************************************  * rf_disks.c -- code to perform operations on the actual disks  ***************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_alloclist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_options.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_bsd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_function_decl
specifier|static
name|int
name|rf_AllocDiskStructures
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|RF_Config_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_print_label_status
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|RF_ComponentLabel_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_check_label_vitals
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|RF_ComponentLabel_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DPRINTF6
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|if (rf_diskDebug) printf(a,b,c,d,e,f)
end_define

begin_define
define|#
directive|define
name|DPRINTF7
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
value|if (rf_diskDebug) printf(a,b,c,d,e,f,g)
end_define

begin_comment
comment|/**************************************************************************  *  * initialize the disks comprising the array  *  * We want the spare disks to have regular row,col numbers so that we can   * easily substitue a spare for a failed disk.  But, the driver code assumes   * throughout that the array contains numRow by numCol _non-spare_ disks, so   * it's not clear how to fit in the spares.  This is an unfortunate holdover  * from raidSim.  The quick and dirty fix is to make row zero bigger than the   * rest, and put all the spares in it.  This probably needs to get changed   * eventually.  *  **************************************************************************/
end_comment

begin_function
name|int
name|rf_ConfigureDisks
parameter_list|(
name|listp
parameter_list|,
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
decl_stmt|;
name|RF_SectorCount_t
name|min_numblks
init|=
operator|(
name|RF_SectorCount_t
operator|)
literal|0x7FFFFFFFFFFFLL
decl_stmt|;
name|RF_RowCol_t
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|bs
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|count
decl_stmt|,
name|foundone
init|=
literal|0
decl_stmt|,
name|numFailuresThisRow
decl_stmt|;
name|int
name|force
decl_stmt|;
name|force
operator|=
name|cfgPtr
operator|->
name|force
expr_stmt|;
name|ret
operator|=
name|rf_AllocDiskStructures
argument_list|(
name|raidPtr
argument_list|,
name|cfgPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|disks
operator|=
name|raidPtr
operator|->
name|Disks
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
name|numFailuresThisRow
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|ret
operator|=
name|rf_ConfigureDisk
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|cfgPtr
operator|->
name|devnames
index|[
name|r
index|]
index|[
name|c
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
argument_list|,
operator|&
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|!=
name|rf_ds_optimal
condition|)
block|{
name|numFailuresThisRow
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|numBlocks
operator|<
name|min_numblks
condition|)
name|min_numblks
operator|=
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|numBlocks
expr_stmt|;
name|DPRINTF7
argument_list|(
literal|"Disk at row %d col %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n"
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|devname
argument_list|,
operator|(
name|long
name|int
operator|)
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|numBlocks
argument_list|,
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|blockSize
argument_list|,
operator|(
name|long
name|int
operator|)
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|numBlocks
operator|*
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|blockSize
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX fix for n-fault tolerant */
comment|/* XXX this should probably check to see how many failures 		   we can handle for this configuration! */
if|if
condition|(
name|numFailuresThisRow
operator|>
literal|0
condition|)
name|raidPtr
operator|->
name|status
index|[
name|r
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
block|}
comment|/* all disks must be the same size& have the same block size, bs must 	 * be a power of 2 */
name|bs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|foundone
operator|=
name|r
operator|=
literal|0
init|;
operator|!
name|foundone
operator|&&
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
operator|!
name|foundone
operator|&&
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
name|bs
operator|=
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|blockSize
expr_stmt|;
name|foundone
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|foundone
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"RAIDFRAME: Did not find any live disks in the array.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
condition|;
name|i
operator|<<=
literal|1
control|)
if|if
condition|(
name|bs
operator|&
name|i
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Error: block size on disks (%d) must be a power of 2\n"
argument_list|,
name|bs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|rf_CheckLabels
argument_list|(
name|raidPtr
argument_list|,
name|cfgPtr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: There were fatal errors\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Fatal errors being ignored.\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|blockSize
operator|!=
name|bs
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Error: block size of disk at r %d c %d different from disk at r 0 c 0\n"
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|numBlocks
operator|!=
name|min_numblks
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"WARNING: truncating disk at r %d c %d to %d blocks\n"
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
operator|(
name|int
operator|)
name|min_numblks
argument_list|)
expr_stmt|;
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|numBlocks
operator|=
name|min_numblks
expr_stmt|;
block|}
block|}
block|}
block|}
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|min_numblks
expr_stmt|;
name|raidPtr
operator|->
name|logBytesPerSector
operator|=
name|ffs
argument_list|(
name|bs
argument_list|)
operator|-
literal|1
expr_stmt|;
name|raidPtr
operator|->
name|bytesPerSector
operator|=
name|bs
expr_stmt|;
name|raidPtr
operator|->
name|sectorMask
operator|=
name|bs
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|rf_UnconfigureVnodes
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * set up the data structures describing the spare disks in the array  * recall from the above comment that the spare disk descriptors are stored  * in row zero, which is specially expanded to hold them.  ****************************************************************************/
end_comment

begin_function
name|int
name|rf_ConfigureSpareDisks
parameter_list|(
name|listp
parameter_list|,
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|int
name|bs
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|disks
decl_stmt|;
name|int
name|num_spares_done
decl_stmt|;
name|num_spares_done
operator|=
literal|0
expr_stmt|;
comment|/* The space for the spares should have already been allocated by 	 * ConfigureDisks() */
name|disks
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numSpare
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|rf_ConfigureDisk
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|cfgPtr
operator|->
name|spare_names
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|&
name|disks
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|disks
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|rf_ds_optimal
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Warning: spare disk %s failed TUR\n"
argument_list|,
operator|&
name|cfgPtr
operator|->
name|spare_names
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|disks
index|[
name|i
index|]
operator|.
name|status
operator|=
name|rf_ds_spare
expr_stmt|;
comment|/* change status to 							 * spare */
name|DPRINTF6
argument_list|(
literal|"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n"
argument_list|,
name|i
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|devname
argument_list|,
operator|(
name|long
name|int
operator|)
name|disks
index|[
name|i
index|]
operator|.
name|numBlocks
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|blockSize
argument_list|,
operator|(
name|long
name|int
operator|)
name|disks
index|[
name|i
index|]
operator|.
name|numBlocks
operator|*
name|disks
index|[
name|i
index|]
operator|.
name|blockSize
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
name|num_spares_done
operator|++
expr_stmt|;
block|}
comment|/* check sizes and block sizes on spare disks */
name|bs
operator|=
literal|1
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numSpare
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|disks
index|[
name|i
index|]
operator|.
name|blockSize
operator|!=
name|bs
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Block size of %d on spare disk %s is not the same as on other disks (%d)\n"
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|blockSize
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|devname
argument_list|,
name|bs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|disks
index|[
name|i
index|]
operator|.
name|numBlocks
operator|<
name|raidPtr
operator|->
name|sectorsPerDisk
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\n"
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|devname
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|blockSize
argument_list|,
operator|(
name|long
name|int
operator|)
name|raidPtr
operator|->
name|sectorsPerDisk
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
name|disks
index|[
name|i
index|]
operator|.
name|numBlocks
operator|>
name|raidPtr
operator|->
name|sectorsPerDisk
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Warning: truncating spare disk %s to %ld blocks\n"
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|devname
argument_list|,
operator|(
name|long
name|int
operator|)
name|raidPtr
operator|->
name|sectorsPerDisk
argument_list|)
expr_stmt|;
name|disks
index|[
name|i
index|]
operator|.
name|numBlocks
operator|=
name|raidPtr
operator|->
name|sectorsPerDisk
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* Release the hold on the main components.  We've failed to allocate 	 * a spare, and since we're failing, we need to free things..  		  	 XXX failing to allocate a spare is *not* that big of a deal...  	 We *can* survive without it, if need be, esp. if we get hot 	 adding working.    	 If we don't fail out here, then we need a way to remove this spare...  	 that should be easier to do here than if we are "live"...   	 */
name|rf_UnconfigureVnodes
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rf_AllocDiskStructures
parameter_list|(
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|r
decl_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|disks
argument_list|,
name|raidPtr
operator|->
name|numRow
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_RaidDisk_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_RaidDisk_t
operator|*
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|disks
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|raidPtr
operator|->
name|Disks
operator|=
name|disks
expr_stmt|;
comment|/* get space for the device-specific stuff... */
name|RF_CallocAndAdd
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
argument_list|,
name|raidPtr
operator|->
name|numRow
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|raidcinfo
operator|*
argument_list|)
argument_list|,
operator|(
expr|struct
name|raidcinfo
operator|*
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|raid_cinfo
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
comment|/* We allocate RF_MAXSPARE on the first row so that we 		   have room to do hot-swapping of spares */
name|RF_CallocAndAdd
argument_list|(
name|disks
index|[
name|r
index|]
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|+
operator|(
operator|(
name|r
operator|==
literal|0
operator|)
condition|?
name|RF_MAXSPARE
else|:
literal|0
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_RaidDisk_t
argument_list|)
argument_list|,
operator|(
name|RF_RaidDisk_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|disks
index|[
name|r
index|]
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* get more space for device specific stuff.. */
name|RF_CallocAndAdd
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|+
operator|(
operator|(
name|r
operator|==
literal|0
operator|)
condition|?
name|raidPtr
operator|->
name|numSpare
else|:
literal|0
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|raidcinfo
argument_list|)
argument_list|,
operator|(
expr|struct
name|raidcinfo
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|rf_UnconfigureVnodes
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* configure a single disk during auto-configuration at boot */
end_comment

begin_function
name|int
name|rf_AutoConfigureDisks
parameter_list|(
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|,
name|auto_config
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|auto_config
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|diskPtr
decl_stmt|;
name|RF_RowCol_t
name|r
decl_stmt|,
name|c
decl_stmt|;
name|RF_SectorCount_t
name|min_numblks
init|=
operator|(
name|RF_SectorCount_t
operator|)
literal|0x7FFFFFFFFFFFLL
decl_stmt|;
name|int
name|bs
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|numFailuresThisRow
decl_stmt|;
name|int
name|force
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|int
name|parity_good
decl_stmt|;
name|int
name|mod_counter
decl_stmt|;
name|int
name|mod_counter_found
decl_stmt|;
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Starting autoconfiguration of RAID set...\n"
argument_list|)
expr_stmt|;
name|force
operator|=
name|cfgPtr
operator|->
name|force
expr_stmt|;
name|ret
operator|=
name|rf_AllocDiskStructures
argument_list|(
name|raidPtr
argument_list|,
name|cfgPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
name|disks
operator|=
name|raidPtr
operator|->
name|Disks
expr_stmt|;
comment|/* assume the parity will be fine.. */
name|parity_good
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
comment|/* Check for mod_counters that are too low */
name|mod_counter_found
operator|=
literal|0
expr_stmt|;
name|mod_counter
operator|=
literal|0
expr_stmt|;
name|ac
operator|=
name|auto_config
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mod_counter_found
operator|==
literal|0
condition|)
block|{
name|mod_counter
operator|=
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
expr_stmt|;
name|mod_counter_found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
operator|>
name|mod_counter
condition|)
block|{
name|mod_counter
operator|=
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
expr_stmt|;
block|}
block|}
name|ac
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* clear the general purpose flag */
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
name|bs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
name|numFailuresThisRow
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|diskPtr
operator|=
operator|&
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
comment|/* find this row/col in the autoconfig */
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Looking for %d,%d in autoconfig\n"
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ac
operator|=
name|auto_config
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ac
operator|->
name|clabel
operator|==
name|NULL
condition|)
block|{
comment|/* big-time bad news. */
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|ac
operator|->
name|clabel
operator|->
name|row
operator|==
name|r
operator|)
operator|&&
operator|(
name|ac
operator|->
name|clabel
operator|->
name|column
operator|==
name|c
operator|)
operator|&&
operator|(
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
operator|==
name|mod_counter
operator|)
condition|)
block|{
comment|/* it's this one... */
comment|/* flag it as 'used', so we don't 					   free it later. */
name|ac
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Found: %s at %d,%d\n"
argument_list|,
name|ac
operator|->
name|devname
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|==
name|NULL
condition|)
block|{
comment|/* we didn't find an exact match with a  				   correct mod_counter above... can we 				   find one with an incorrect mod_counter 				   to use instead?  (this one, if we find 				   it, will be marked as failed once the  				   set configures)  				*/
name|ac
operator|=
name|auto_config
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ac
operator|->
name|clabel
operator|==
name|NULL
condition|)
block|{
comment|/* big-time bad news. */
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|ac
operator|->
name|clabel
operator|->
name|row
operator|==
name|r
operator|)
operator|&&
operator|(
name|ac
operator|->
name|clabel
operator|->
name|column
operator|==
name|c
operator|)
condition|)
block|{
comment|/* it's this one...  						   flag it as 'used', so we  						   don't free it later. */
name|ac
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Found(low mod_counter): %s at %d,%d\n"
argument_list|,
name|ac
operator|->
name|devname
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
comment|/* Found it.  Configure it.. */
name|diskPtr
operator|->
name|blockSize
operator|=
name|ac
operator|->
name|clabel
operator|->
name|blockSize
expr_stmt|;
name|diskPtr
operator|->
name|numBlocks
operator|=
name|ac
operator|->
name|clabel
operator|->
name|numBlocks
expr_stmt|;
comment|/* Note: rf_protectedSectors is already  				   factored into numBlocks here */
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
operator|=
name|ac
operator|->
name|vp
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_dev
operator|=
name|ac
operator|->
name|dev
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_label
argument_list|,
name|ac
operator|->
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ac
operator|->
name|clabel
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|diskPtr
operator|->
name|devname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|ac
operator|->
name|devname
argument_list|)
expr_stmt|;
comment|/* note the fact that this component was 				   autoconfigured.  You'll need this info 				   later.  Trust me :) */
name|diskPtr
operator|->
name|auto_configured
operator|=
literal|1
expr_stmt|;
name|diskPtr
operator|->
name|dev
operator|=
name|ac
operator|->
name|dev
expr_stmt|;
comment|/*  				 * we allow the user to specify that 				 * only a fraction of the disks should 				 * be used this is just for debug: it 				 * speeds up the parity scan  				 */
name|diskPtr
operator|->
name|numBlocks
operator|=
name|diskPtr
operator|->
name|numBlocks
operator|*
name|rf_sizePercentage
operator|/
literal|100
expr_stmt|;
comment|/* XXX these will get set multiple times,  				   but since we're autoconfiguring, they'd 				   better be always the same each time! 				   If not, this is the least of your worries */
name|bs
operator|=
name|diskPtr
operator|->
name|blockSize
expr_stmt|;
name|min_numblks
operator|=
name|diskPtr
operator|->
name|numBlocks
expr_stmt|;
comment|/* this gets done multiple times, but that's 				   fine -- the serial number will be the same 				   for all components, guaranteed */
name|raidPtr
operator|->
name|serial_number
operator|=
name|ac
operator|->
name|clabel
operator|->
name|serial_number
expr_stmt|;
comment|/* check the last time the label 				   was modified */
if|if
condition|(
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
operator|!=
name|mod_counter
condition|)
block|{
comment|/* Even though we've filled in all 					   of the above, we don't trust 					   this component since it's  					   modification counter is not 					   in sync with the rest, and we really 					   consider it to be failed.  */
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|numFailuresThisRow
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ac
operator|->
name|clabel
operator|->
name|clean
operator|!=
name|RF_RAID_CLEAN
condition|)
block|{
name|parity_good
operator|=
name|RF_RAID_DIRTY
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Didn't find it at all!!  				   Component must really be dead */
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|sprintf
argument_list|(
name|disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|devname
argument_list|,
literal|"component%d"
argument_list|,
name|r
operator|*
name|raidPtr
operator|->
name|numCol
operator|+
name|c
argument_list|)
expr_stmt|;
name|numFailuresThisRow
operator|++
expr_stmt|;
block|}
block|}
comment|/* XXX fix for n-fault tolerant */
comment|/* XXX this should probably check to see how many failures 		   we can handle for this configuration! */
if|if
condition|(
name|numFailuresThisRow
operator|>
literal|0
condition|)
name|raidPtr
operator|->
name|status
index|[
name|r
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
block|}
comment|/* close the device for the ones that didn't get used */
name|ac
operator|=
name|auto_config
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ac
operator|->
name|flag
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|vn_lock
argument_list|(
name|ac
operator|->
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|vn_lock
argument_list|(
name|ac
operator|->
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|raidPtr
operator|->
name|engine_thread
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VOP_CLOSE
argument_list|(
name|ac
operator|->
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ac
operator|->
name|vp
argument_list|)
expr_stmt|;
name|ac
operator|->
name|vp
operator|=
name|NULL
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Released %s from auto-config set.\n"
argument_list|,
name|ac
operator|->
name|devname
argument_list|)
expr_stmt|;
block|}
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
name|raidPtr
operator|->
name|mod_counter
operator|=
name|mod_counter
expr_stmt|;
comment|/* note the state of the parity, if any */
name|raidPtr
operator|->
name|parity_good
operator|=
name|parity_good
expr_stmt|;
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|min_numblks
expr_stmt|;
name|raidPtr
operator|->
name|logBytesPerSector
operator|=
name|ffs
argument_list|(
name|bs
argument_list|)
operator|-
literal|1
expr_stmt|;
name|raidPtr
operator|->
name|bytesPerSector
operator|=
name|bs
expr_stmt|;
name|raidPtr
operator|->
name|sectorMask
operator|=
name|bs
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|rf_UnconfigureVnodes
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* configure a single disk in the array */
end_comment

begin_function
name|int
name|rf_ConfigureDisk
parameter_list|(
name|raidPtr
parameter_list|,
name|buf
parameter_list|,
name|diskPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|diskPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|rf_find_non_white
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* strip off the newline */
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|diskPtr
operator|->
name|devname
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Let's start by claiming the component is fine and well... */
name|diskPtr
operator|->
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_dev
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|raid_getcomponentsize
argument_list|(
name|raidPtr
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"raidlookup on device: %s failed!\n"
argument_list|,
name|diskPtr
operator|->
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
comment|/* the component isn't there... must be dead :-( */
name|diskPtr
operator|->
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_print_label_status
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|column
parameter_list|,
name|dev_name
parameter_list|,
name|ci_label
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|column
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|ci_label
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"raid%d: Component %s being configured at row: %d col: %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|dev_name
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         Row: %d Column: %d Num Rows: %d Num Columns: %d\n"
argument_list|,
name|ci_label
operator|->
name|row
argument_list|,
name|ci_label
operator|->
name|column
argument_list|,
name|ci_label
operator|->
name|num_rows
argument_list|,
name|ci_label
operator|->
name|num_columns
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         Version: %d Serial Number: %d Mod Counter: %d\n"
argument_list|,
name|ci_label
operator|->
name|version
argument_list|,
name|ci_label
operator|->
name|serial_number
argument_list|,
name|ci_label
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         Clean: %s Status: %d\n"
argument_list|,
name|ci_label
operator|->
name|clean
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|ci_label
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rf_check_label_vitals
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|column
parameter_list|,
name|dev_name
parameter_list|,
name|ci_label
parameter_list|,
name|serial_number
parameter_list|,
name|mod_counter
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|column
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|ci_label
decl_stmt|;
name|int
name|serial_number
decl_stmt|;
name|int
name|mod_counter
decl_stmt|;
block|{
name|int
name|fatal_error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|serial_number
operator|!=
name|ci_label
operator|->
name|serial_number
condition|)
block|{
name|printf
argument_list|(
literal|"%s has a different serial number: %d %d\n"
argument_list|,
name|dev_name
argument_list|,
name|serial_number
argument_list|,
name|ci_label
operator|->
name|serial_number
argument_list|)
expr_stmt|;
name|fatal_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mod_counter
operator|!=
name|ci_label
operator|->
name|mod_counter
condition|)
block|{
name|printf
argument_list|(
literal|"%s has a different modfication count: %d %d\n"
argument_list|,
name|dev_name
argument_list|,
name|mod_counter
argument_list|,
name|ci_label
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|!=
name|ci_label
operator|->
name|row
condition|)
block|{
name|printf
argument_list|(
literal|"Row out of alignment for: %s\n"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|fatal_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|!=
name|ci_label
operator|->
name|column
condition|)
block|{
name|printf
argument_list|(
literal|"Column out of alignment for: %s\n"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|fatal_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|numRow
operator|!=
name|ci_label
operator|->
name|num_rows
condition|)
block|{
name|printf
argument_list|(
literal|"Number of rows do not match for: %s\n"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|fatal_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|numCol
operator|!=
name|ci_label
operator|->
name|num_columns
condition|)
block|{
name|printf
argument_list|(
literal|"Number of columns do not match for: %s\n"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
name|fatal_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ci_label
operator|->
name|clean
operator|==
literal|0
condition|)
block|{
comment|/* it's not clean, but that's not fatal */
name|printf
argument_list|(
literal|"%s is not clean!\n"
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fatal_error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*      rf_CheckLabels() - check all the component labels for consistency.    Return an error if there is anything major amiss.   */
end_comment

begin_function
name|int
name|rf_CheckLabels
parameter_list|(
name|raidPtr
parameter_list|,
name|cfgPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|cfgPtr
decl_stmt|;
block|{
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|ci_label
decl_stmt|;
name|int
name|serial_number
init|=
literal|0
decl_stmt|;
name|int
name|mod_number
init|=
literal|0
decl_stmt|;
name|int
name|fatal_error
init|=
literal|0
decl_stmt|;
name|int
name|mod_values
index|[
literal|4
index|]
decl_stmt|;
name|int
name|mod_count
index|[
literal|4
index|]
decl_stmt|;
name|int
name|ser_values
index|[
literal|4
index|]
decl_stmt|;
name|int
name|ser_count
index|[
literal|4
index|]
decl_stmt|;
name|int
name|num_ser
decl_stmt|;
name|int
name|num_mod
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|hosed_row
decl_stmt|;
name|int
name|hosed_column
decl_stmt|;
name|int
name|too_fatal
decl_stmt|;
name|int
name|parity_good
decl_stmt|;
name|int
name|force
decl_stmt|;
name|hosed_row
operator|=
operator|-
literal|1
expr_stmt|;
name|hosed_column
operator|=
operator|-
literal|1
expr_stmt|;
name|too_fatal
operator|=
literal|0
expr_stmt|;
name|force
operator|=
name|cfgPtr
operator|->
name|force
expr_stmt|;
comment|/*  	   We're going to try to be a little intelligent here.  If one  	   component's label is bogus, and we can identify that it's the 	   *only* one that's gone, we'll mark it as "failed" and allow 	   the configuration to proceed.  This will be the *only* case 	   that we'll proceed if there would be (otherwise) fatal errors. 	    	   Basically we simply keep a count of how many components had 	   what serial number.  If all but one agree, we simply mark 	   the disagreeing component as being failed, and allow  	   things to come up "normally". 	    	   We do this first for serial numbers, and then for "mod_counter".  	 */
name|num_ser
operator|=
literal|0
expr_stmt|;
name|num_mod
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
operator|&&
operator|!
name|fatal_error
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|ci_label
operator|=
operator|&
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_label
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ser
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ser_values
index|[
name|i
index|]
operator|==
name|ci_label
operator|->
name|serial_number
condition|)
block|{
name|ser_count
index|[
name|i
index|]
operator|++
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|ser_values
index|[
name|num_ser
index|]
operator|=
name|ci_label
operator|->
name|serial_number
expr_stmt|;
name|ser_count
index|[
name|num_ser
index|]
operator|=
literal|1
expr_stmt|;
name|num_ser
operator|++
expr_stmt|;
if|if
condition|(
name|num_ser
operator|>
literal|2
condition|)
block|{
name|fatal_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_mod
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mod_values
index|[
name|i
index|]
operator|==
name|ci_label
operator|->
name|mod_counter
condition|)
block|{
name|mod_count
index|[
name|i
index|]
operator|++
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|mod_values
index|[
name|num_mod
index|]
operator|=
name|ci_label
operator|->
name|mod_counter
expr_stmt|;
name|mod_count
index|[
name|num_mod
index|]
operator|=
literal|1
expr_stmt|;
name|num_mod
operator|++
expr_stmt|;
if|if
condition|(
name|num_mod
operator|>
literal|2
condition|)
block|{
name|fatal_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"raid%d: Summary of serial numbers:\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ser
condition|;
name|i
operator|++
control|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"%d %d\n"
argument_list|,
name|ser_values
index|[
name|i
index|]
argument_list|,
name|ser_count
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"raid%d: Summary of mod counters:\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_mod
condition|;
name|i
operator|++
control|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"%d %d\n"
argument_list|,
name|mod_values
index|[
name|i
index|]
argument_list|,
name|mod_count
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|serial_number
operator|=
name|ser_values
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|num_ser
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|ser_count
index|[
literal|0
index|]
operator|==
literal|1
operator|)
operator|||
operator|(
name|ser_count
index|[
literal|1
index|]
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Locate the maverick component */
if|if
condition|(
name|ser_count
index|[
literal|1
index|]
operator|>
name|ser_count
index|[
literal|0
index|]
condition|)
block|{
name|serial_number
operator|=
name|ser_values
index|[
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|ci_label
operator|=
operator|&
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_label
expr_stmt|;
if|if
condition|(
name|serial_number
operator|!=
name|ci_label
operator|->
name|serial_number
condition|)
block|{
name|hosed_row
operator|=
name|r
expr_stmt|;
name|hosed_column
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"Hosed component: %s\n"
argument_list|,
operator|&
name|cfgPtr
operator|->
name|devnames
index|[
name|hosed_row
index|]
index|[
name|hosed_column
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|/* we'll fail this component, as if there are 				   other major errors, we arn't forcing things 				   and we'll abort the config anyways */
name|raidPtr
operator|->
name|Disks
index|[
name|hosed_row
index|]
index|[
name|hosed_column
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|raidPtr
operator|->
name|numFailures
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|hosed_row
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
block|}
block|}
else|else
block|{
name|too_fatal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cfgPtr
operator|->
name|parityConfig
operator|==
literal|'0'
condition|)
block|{
comment|/* We've identified two different serial numbers.  			   RAID 0 can't cope with that, so we'll punt */
name|too_fatal
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* record the serial number for later.  If we bail later, setting 	   this doesn't matter, otherwise we've got the best guess at the  	   correct serial number */
name|raidPtr
operator|->
name|serial_number
operator|=
name|serial_number
expr_stmt|;
name|mod_number
operator|=
name|mod_values
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|num_mod
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|mod_count
index|[
literal|0
index|]
operator|==
literal|1
operator|)
operator|||
operator|(
name|mod_count
index|[
literal|1
index|]
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Locate the maverick component */
if|if
condition|(
name|mod_count
index|[
literal|1
index|]
operator|>
name|mod_count
index|[
literal|0
index|]
condition|)
block|{
name|mod_number
operator|=
name|mod_values
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mod_count
index|[
literal|1
index|]
operator|<
name|mod_count
index|[
literal|0
index|]
condition|)
block|{
name|mod_number
operator|=
name|mod_values
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* counts of different modification values 				   are the same.   Assume greater value is  				   the correct one, all other things  				   considered */
if|if
condition|(
name|mod_values
index|[
literal|0
index|]
operator|>
name|mod_values
index|[
literal|1
index|]
condition|)
block|{
name|mod_number
operator|=
name|mod_values
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|mod_number
operator|=
name|mod_values
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
operator|&&
operator|!
name|too_fatal
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|ci_label
operator|=
operator|&
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_label
expr_stmt|;
if|if
condition|(
name|mod_number
operator|!=
name|ci_label
operator|->
name|mod_counter
condition|)
block|{
if|if
condition|(
operator|(
name|hosed_row
operator|==
name|r
operator|)
operator|&&
operator|(
name|hosed_column
operator|==
name|c
operator|)
condition|)
block|{
comment|/* same one.  Can 							   deal with it.  */
block|}
else|else
block|{
name|hosed_row
operator|=
name|r
expr_stmt|;
name|hosed_column
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|num_ser
operator|!=
literal|1
condition|)
block|{
name|too_fatal
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|printf
argument_list|(
literal|"Hosed component: %s\n"
argument_list|,
operator|&
name|cfgPtr
operator|->
name|devnames
index|[
name|hosed_row
index|]
index|[
name|hosed_column
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
block|{
comment|/* we'll fail this component, as if there are 				   other major errors, we arn't forcing things 				   and we'll abort the config anyways */
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|hosed_row
index|]
index|[
name|hosed_column
index|]
operator|.
name|status
operator|!=
name|rf_ds_failed
condition|)
block|{
name|raidPtr
operator|->
name|Disks
index|[
name|hosed_row
index|]
index|[
name|hosed_column
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|raidPtr
operator|->
name|numFailures
operator|++
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|hosed_row
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|too_fatal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cfgPtr
operator|->
name|parityConfig
operator|==
literal|'0'
condition|)
block|{
comment|/* We've identified two different mod counters. 			   RAID 0 can't cope with that, so we'll punt */
name|too_fatal
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|raidPtr
operator|->
name|mod_counter
operator|=
name|mod_number
expr_stmt|;
if|if
condition|(
name|too_fatal
condition|)
block|{
comment|/* we've had both a serial number mismatch, and a mod_counter 		   mismatch -- and they involved two different components!! 		   Bail -- make things fail so that the user must force 		   the issue... */
name|hosed_row
operator|=
operator|-
literal|1
expr_stmt|;
name|hosed_column
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_ser
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Too many different serial numbers!\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_mod
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Too many different mod counters!\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
comment|/* we start by assuming the parity will be good, and flee from 	   that notion at the slightest sign of trouble */
name|parity_good
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|dev_name
operator|=
operator|&
name|cfgPtr
operator|->
name|devnames
index|[
name|r
index|]
index|[
name|c
index|]
index|[
literal|0
index|]
expr_stmt|;
name|ci_label
operator|=
operator|&
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_label
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|==
name|hosed_row
operator|)
operator|&&
operator|(
name|c
operator|==
name|hosed_column
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Ignoring %s\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf_print_label_status
argument_list|(
name|raidPtr
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|dev_name
argument_list|,
name|ci_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_check_label_vitals
argument_list|(
name|raidPtr
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|dev_name
argument_list|,
name|ci_label
argument_list|,
name|serial_number
argument_list|,
name|mod_number
argument_list|)
condition|)
block|{
name|fatal_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ci_label
operator|->
name|clean
operator|!=
name|RF_RAID_CLEAN
condition|)
block|{
name|parity_good
operator|=
name|RF_RAID_DIRTY
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fatal_error
condition|)
block|{
name|parity_good
operator|=
name|RF_RAID_DIRTY
expr_stmt|;
block|}
comment|/* we note the state of the parity */
name|raidPtr
operator|->
name|parity_good
operator|=
name|parity_good
expr_stmt|;
return|return
operator|(
name|fatal_error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_add_hot_spare
parameter_list|(
name|raidPtr
parameter_list|,
name|sparePtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_SingleComponent_t
modifier|*
name|sparePtr
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
name|disks
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
name|spareQueues
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|bs
decl_stmt|;
name|int
name|spare_number
decl_stmt|;
if|#
directive|if
literal|0
block|printf("Just in rf_add_hot_spare: %d\n",raidPtr->numSpare); 	printf("Num col: %d\n",raidPtr->numCol);
endif|#
directive|endif
if|if
condition|(
name|raidPtr
operator|->
name|numSpare
operator|>=
name|RF_MAXSPARE
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Too many spares: %d\n"
argument_list|,
name|raidPtr
operator|->
name|numSpare
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* the beginning of the spares... */
name|disks
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
index|]
expr_stmt|;
name|spare_number
operator|=
name|raidPtr
operator|->
name|numSpare
expr_stmt|;
name|ret
operator|=
name|rf_ConfigureDisk
argument_list|(
name|raidPtr
argument_list|,
name|sparePtr
operator|->
name|component_name
argument_list|,
operator|&
name|disks
index|[
name|spare_number
index|]
argument_list|,
literal|0
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|+
name|spare_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|disks
index|[
name|spare_number
index|]
operator|.
name|status
operator|!=
name|rf_ds_optimal
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Warning: spare disk %s failed TUR\n"
argument_list|,
name|sparePtr
operator|->
name|component_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|else
block|{
name|disks
index|[
name|spare_number
index|]
operator|.
name|status
operator|=
name|rf_ds_spare
expr_stmt|;
name|DPRINTF6
argument_list|(
literal|"Spare Disk %d: dev %s numBlocks %ld blockSize %d (%ld MB)\n"
argument_list|,
name|spare_number
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|devname
argument_list|,
operator|(
name|long
name|int
operator|)
name|disks
index|[
name|spare_number
index|]
operator|.
name|numBlocks
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|blockSize
argument_list|,
operator|(
name|long
name|int
operator|)
name|disks
index|[
name|spare_number
index|]
operator|.
name|numBlocks
operator|*
name|disks
index|[
name|spare_number
index|]
operator|.
name|blockSize
operator|/
literal|1024
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
comment|/* check sizes and block sizes on the spare disk */
name|bs
operator|=
literal|1
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
if|if
condition|(
name|disks
index|[
name|spare_number
index|]
operator|.
name|blockSize
operator|!=
name|bs
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Block size of %d on spare disk %s is not the same as on other disks (%d)\n"
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|blockSize
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|devname
argument_list|,
name|bs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|disks
index|[
name|spare_number
index|]
operator|.
name|numBlocks
operator|<
name|raidPtr
operator|->
name|sectorsPerDisk
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Spare disk %s (%d blocks) is too small to serve as a spare (need %ld blocks)\n"
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|devname
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|blockSize
argument_list|,
operator|(
name|long
name|int
operator|)
name|raidPtr
operator|->
name|sectorsPerDisk
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|else
block|{
if|if
condition|(
name|disks
index|[
name|spare_number
index|]
operator|.
name|numBlocks
operator|>
name|raidPtr
operator|->
name|sectorsPerDisk
condition|)
block|{
name|RF_ERRORMSG2
argument_list|(
literal|"Warning: truncating spare disk %s to %ld blocks\n"
argument_list|,
name|disks
index|[
name|spare_number
index|]
operator|.
name|devname
argument_list|,
operator|(
name|long
name|int
operator|)
name|raidPtr
operator|->
name|sectorsPerDisk
argument_list|)
expr_stmt|;
name|disks
index|[
name|spare_number
index|]
operator|.
name|numBlocks
operator|=
name|raidPtr
operator|->
name|sectorsPerDisk
expr_stmt|;
block|}
block|}
name|spareQueues
operator|=
operator|&
name|raidPtr
operator|->
name|Queues
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
index|]
expr_stmt|;
name|ret
operator|=
name|rf_ConfigureDiskQueue
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|spareQueues
index|[
name|spare_number
index|]
argument_list|,
literal|0
argument_list|,
name|raidPtr
operator|->
name|numCol
operator|+
name|spare_number
argument_list|,
name|raidPtr
operator|->
name|qType
argument_list|,
name|raidPtr
operator|->
name|sectorsPerDisk
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
operator|+
name|spare_number
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|maxOutstanding
argument_list|,
operator|&
name|raidPtr
operator|->
name|shutdownList
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|numSpare
operator|++
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_remove_hot_spare
parameter_list|(
name|raidPtr
parameter_list|,
name|sparePtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_SingleComponent_t
modifier|*
name|sparePtr
decl_stmt|;
block|{
name|int
name|spare_number
decl_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|numSpare
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No spares to remove!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|spare_number
operator|=
name|sparePtr
operator|->
name|column
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX not implemented yet */
if|#
directive|if
literal|0
block|if (spare_number< 0 || spare_number> raidPtr->numSpare) { 		return(EINVAL); 	}
comment|/* verify that this spare isn't in use... */
comment|/* it's gone.. */
block|raidPtr->numSpare--;  	return(0);
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|rf_delete_component
parameter_list|(
name|raidPtr
parameter_list|,
name|component
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_SingleComponent_t
modifier|*
name|component
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
name|disks
decl_stmt|;
if|if
condition|(
operator|(
name|component
operator|->
name|row
operator|<
literal|0
operator|)
operator|||
operator|(
name|component
operator|->
name|row
operator|>=
name|raidPtr
operator|->
name|numRow
operator|)
operator|||
operator|(
name|component
operator|->
name|column
operator|<
literal|0
operator|)
operator|||
operator|(
name|component
operator|->
name|column
operator|>=
name|raidPtr
operator|->
name|numCol
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|disks
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
name|component
operator|->
name|row
index|]
index|[
name|component
operator|->
name|column
index|]
expr_stmt|;
comment|/* 1. This component must be marked as 'failed' */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Not implemented yet. */
block|}
end_function

begin_function
name|int
name|rf_incorporate_hot_spare
parameter_list|(
name|raidPtr
parameter_list|,
name|component
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_SingleComponent_t
modifier|*
name|component
decl_stmt|;
block|{
comment|/* Issues here include how to 'move' this in if there is IO  	   taking place (e.g. component queues and such) */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Not implemented yet. */
block|}
end_function

end_unit

