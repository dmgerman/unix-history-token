begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_chaindecluster.c,v 1.6 2001/01/26 04:27:16 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Khalil Amiri  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/******************************************************************************  *  * rf_chaindecluster.c -- implements chained declustering  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_CHAINDECLUSTER
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_chaindecluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|RF_ChaindeclusterConfigInfo_s
block|{
name|RF_RowCol_t
modifier|*
modifier|*
name|stripeIdentifier
decl_stmt|;
comment|/* filled in at config time and used 					 * by IdentifyStripe */
name|RF_StripeCount_t
name|numSparingRegions
decl_stmt|;
name|RF_StripeCount_t
name|stripeUnitsPerSparingRegion
decl_stmt|;
name|RF_SectorNum_t
name|mirrorStripeOffset
decl_stmt|;
block|}
name|RF_ChaindeclusterConfigInfo_t
typedef|;
end_typedef

begin_function
name|int
name|rf_ConfigureChainDecluster
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_StripeCount_t
name|num_used_stripeUnitsPerDisk
decl_stmt|;
name|RF_ChaindeclusterConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|RF_RowCol_t
name|i
decl_stmt|;
comment|/* create a Chained Declustering configuration structure */
name|RF_MallocAndAdd
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ChaindeclusterConfigInfo_t
argument_list|)
argument_list|,
operator|(
name|RF_ChaindeclusterConfigInfo_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|layoutPtr
operator|->
name|layoutSpecificInfo
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
comment|/* fill in the config structure.  */
name|info
operator|->
name|stripeIdentifier
operator|=
name|rf_make_2d_array
argument_list|(
name|raidPtr
operator|->
name|numCol
argument_list|,
literal|2
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|stripeIdentifier
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|stripeIdentifier
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|i
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
name|info
operator|->
name|stripeIdentifier
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|numRow
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* fill in the remaining layout parameters */
name|num_used_stripeUnitsPerDisk
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|-
operator|(
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|%
operator|(
literal|2
operator|*
name|raidPtr
operator|->
name|numCol
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
name|info
operator|->
name|numSparingRegions
operator|=
name|num_used_stripeUnitsPerDisk
operator|/
operator|(
literal|2
operator|*
name|raidPtr
operator|->
name|numCol
operator|-
literal|2
operator|)
expr_stmt|;
name|info
operator|->
name|stripeUnitsPerSparingRegion
operator|=
name|raidPtr
operator|->
name|numCol
operator|*
operator|(
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
expr_stmt|;
name|info
operator|->
name|mirrorStripeOffset
operator|=
name|info
operator|->
name|numSparingRegions
operator|*
operator|(
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
expr_stmt|;
name|layoutPtr
operator|->
name|numStripe
operator|=
name|info
operator|->
name|numSparingRegions
operator|*
name|info
operator|->
name|stripeUnitsPerSparingRegion
expr_stmt|;
name|layoutPtr
operator|->
name|bytesPerStripeUnit
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|layoutPtr
operator|->
name|numDataCol
operator|=
literal|1
expr_stmt|;
name|layoutPtr
operator|->
name|dataSectorsPerStripe
operator|=
name|layoutPtr
operator|->
name|numDataCol
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|numParityCol
operator|=
literal|1
expr_stmt|;
name|layoutPtr
operator|->
name|dataStripeUnitsPerDisk
operator|=
name|num_used_stripeUnitsPerDisk
expr_stmt|;
name|raidPtr
operator|->
name|sectorsPerDisk
operator|=
name|num_used_stripeUnitsPerDisk
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|raidPtr
operator|->
name|totalSectors
operator|=
operator|(
name|layoutPtr
operator|->
name|numStripe
operator|)
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|=
name|raidPtr
operator|->
name|sectorsPerDisk
operator|/
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_ReconUnitCount_t
name|rf_GetNumSpareRUsChainDecluster
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_ChaindeclusterConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_ChaindeclusterConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
comment|/*          * The layout uses two stripe units per disk as spare within each          * sparing region.          */
return|return
operator|(
literal|2
operator|*
name|info
operator|->
name|numSparingRegions
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Maps to the primary copy of the data, i.e. the first mirror pair */
end_comment

begin_function
name|void
name|rf_MapSectorChainDecluster
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_ChaindeclusterConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_ChaindeclusterConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_SectorNum_t
name|index_within_region
decl_stmt|,
name|index_within_disk
decl_stmt|;
name|RF_StripeNum_t
name|sparing_region_id
decl_stmt|;
name|int
name|col_before_remap
decl_stmt|;
operator|*
name|row
operator|=
literal|0
expr_stmt|;
name|sparing_region_id
operator|=
name|SUID
operator|/
name|info
operator|->
name|stripeUnitsPerSparingRegion
expr_stmt|;
name|index_within_region
operator|=
name|SUID
operator|%
name|info
operator|->
name|stripeUnitsPerSparingRegion
expr_stmt|;
name|index_within_disk
operator|=
name|index_within_region
operator|/
name|raidPtr
operator|->
name|numCol
expr_stmt|;
name|col_before_remap
operator|=
name|SUID
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
if|if
condition|(
operator|!
name|remap
condition|)
block|{
operator|*
name|col
operator|=
name|col_before_remap
expr_stmt|;
operator|*
name|diskSector
operator|=
operator|(
name|index_within_disk
operator|+
operator|(
operator|(
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
operator|*
name|sparing_region_id
operator|)
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remap sector to spare space... */
operator|*
name|diskSector
operator|=
name|sparing_region_id
operator|*
operator|(
name|raidPtr
operator|->
name|numCol
operator|+
literal|1
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
name|index_within_disk
operator|=
name|index_within_region
operator|/
name|raidPtr
operator|->
name|numCol
expr_stmt|;
if|if
condition|(
name|index_within_disk
operator|<
name|col_before_remap
condition|)
operator|*
name|col
operator|=
name|index_within_disk
expr_stmt|;
elseif|else
if|if
condition|(
name|index_within_disk
operator|==
name|raidPtr
operator|->
name|numCol
operator|-
literal|2
condition|)
block|{
operator|*
name|col
operator|=
operator|(
name|col_before_remap
operator|+
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|diskSector
operator|+=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
block|}
else|else
operator|*
name|col
operator|=
operator|(
name|index_within_disk
operator|+
literal|2
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Maps to the second copy of the mirror pair, which is chain declustered. The second copy is contained    in the next disk (mod numCol) after the disk containing the primary copy.    The offset into the disk is one-half disk down */
end_comment

begin_function
name|void
name|rf_MapParityChainDecluster
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_ChaindeclusterConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_ChaindeclusterConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_SectorNum_t
name|index_within_region
decl_stmt|,
name|index_within_disk
decl_stmt|;
name|RF_StripeNum_t
name|sparing_region_id
decl_stmt|;
name|int
name|col_before_remap
decl_stmt|;
operator|*
name|row
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|remap
condition|)
block|{
operator|*
name|col
operator|=
name|SUID
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|col
operator|=
operator|(
operator|*
name|col
operator|+
literal|1
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|diskSector
operator|=
name|info
operator|->
name|mirrorStripeOffset
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|SUID
operator|/
name|raidPtr
operator|->
name|numCol
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remap parity to spare space ... */
name|sparing_region_id
operator|=
name|SUID
operator|/
name|info
operator|->
name|stripeUnitsPerSparingRegion
expr_stmt|;
name|index_within_region
operator|=
name|SUID
operator|%
name|info
operator|->
name|stripeUnitsPerSparingRegion
expr_stmt|;
name|index_within_disk
operator|=
name|index_within_region
operator|/
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|diskSector
operator|=
name|sparing_region_id
operator|*
operator|(
name|raidPtr
operator|->
name|numCol
operator|+
literal|1
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|raidPtr
operator|->
name|numCol
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
operator|*
name|diskSector
operator|+=
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
name|col_before_remap
operator|=
name|SUID
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
if|if
condition|(
name|index_within_disk
operator|<
name|col_before_remap
condition|)
operator|*
name|col
operator|=
name|index_within_disk
expr_stmt|;
elseif|else
if|if
condition|(
name|index_within_disk
operator|==
name|raidPtr
operator|->
name|numCol
operator|-
literal|2
condition|)
block|{
operator|*
name|col
operator|=
operator|(
name|col_before_remap
operator|+
literal|2
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|diskSector
operator|-=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
block|}
else|else
operator|*
name|col
operator|=
operator|(
name|index_within_disk
operator|+
literal|2
operator|)
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rf_IdentifyStripeChainDecluster
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|addr
parameter_list|,
name|RF_RowCol_t
modifier|*
modifier|*
name|diskids
parameter_list|,
name|RF_RowCol_t
modifier|*
name|outRow
parameter_list|)
block|{
name|RF_ChaindeclusterConfigInfo_t
modifier|*
name|info
init|=
operator|(
name|RF_ChaindeclusterConfigInfo_t
operator|*
operator|)
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
name|RF_StripeNum_t
name|SUID
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
name|SUID
operator|=
name|addr
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
name|col
operator|=
name|SUID
operator|%
name|raidPtr
operator|->
name|numCol
expr_stmt|;
operator|*
name|outRow
operator|=
literal|0
expr_stmt|;
operator|*
name|diskids
operator|=
name|info
operator|->
name|stripeIdentifier
index|[
name|col
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_MapSIDToPSIDChainDecluster
parameter_list|(
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_StripeNum_t
name|stripeID
parameter_list|,
name|RF_StripeNum_t
modifier|*
name|psID
parameter_list|,
name|RF_ReconUnitNum_t
modifier|*
name|which_ru
parameter_list|)
block|{
operator|*
name|which_ru
operator|=
literal|0
expr_stmt|;
operator|*
name|psID
operator|=
name|stripeID
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * select a graph to perform a single-stripe access  *  * Parameters:  raidPtr    - description of the physical array  *              type       - type of operation (read or write) requested  *              asmap      - logical& physical addresses for this access  *              createFunc - function to use to create the graph (return value)  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_RAIDCDagSelect
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_VoidFuncPtr
modifier|*
name|createFunc
parameter_list|)
if|#
directive|if
literal|0
function|void    (**createFunc) (RF_Raid_t *, RF_AccessStripeMap_t *,             RF_DagHeader_t *, void *, RF_RaidAccessFlags_t,             RF_AllocListElem_t *)
endif|#
directive|endif
block|{
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|numRow
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|+
name|asmap
operator|->
name|numParityFailed
operator|>
literal|1
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Multiple disks failed in a single group!  Aborting I/O operation.\n"
argument_list|)
expr_stmt|;
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
operator|*
name|createFunc
operator|=
operator|(
name|type
operator|==
name|RF_IO_TYPE_READ
operator|)
condition|?
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateFaultFreeReadDAG
else|:
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateRaidOneWriteDAG
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RF_IO_TYPE_READ
condition|)
block|{
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|status
index|[
literal|0
index|]
operator|==
name|rf_rs_degraded
operator|)
operator|||
operator|(
name|raidPtr
operator|->
name|status
index|[
literal|0
index|]
operator|==
name|rf_rs_reconstructing
operator|)
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateRaidCDegradedReadDAG
expr_stmt|;
comment|/* array status is 											 * degraded, implement 											 * workload shifting */
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateMirrorPartitionReadDAG
expr_stmt|;
comment|/* array status not 											 * degraded, so use 											 * mirror partition dag */
block|}
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateRaidOneWriteDAG
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_CHAINDECLUSTER> 0) */
end_comment

end_unit

