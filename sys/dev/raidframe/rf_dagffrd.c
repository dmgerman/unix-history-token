begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_dagffrd.c,v 1.4 2000/01/07 03:40:58 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, Daniel Stodolsky, William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * rf_dagffrd.c  *  * code for creating fault-free read DAGs  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_comment
comment|/******************************************************************************  *  * General comments on DAG creation:  *  * All DAGs in this file use roll-away error recovery.  Each DAG has a single  * commit node, usually called "Cmt."  If an error occurs before the Cmt node  * is reached, the execution engine will halt forward execution and work  * backward through the graph, executing the undo functions.  Assuming that  * each node in the graph prior to the Cmt node are undoable and atomic - or -  * does not make changes to permanent state, the graph will fail atomically.  * If an error occurs after the Cmt node executes, the engine will roll-forward  * through the graph, blindly executing nodes until it reaches the end.  * If a graph reaches the end, it is assumed to have completed successfully.  *  * A graph has only 1 Cmt node.  *  */
end_comment

begin_comment
comment|/******************************************************************************  *  * The following wrappers map the standard DAG creation interface to the  * DAG creation routines.  Additionally, these wrappers enable experimentation  * with new DAG structures by providing an extra level of indirection, allowing  * the DAG creation routines to be replaced at this single point.  */
end_comment

begin_function
name|void
name|rf_CreateFaultFreeReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|rf_CreateNonredundantDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
name|RF_IO_TYPE_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * DAG creation code begins here  */
end_comment

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a nonredundant read or write of data within one  * stripe.  * For reads, this DAG is as follows:  *  *                   /---- read ----\  *    Header -- Block ---- read ---- Commit -- Terminate  *                   \---- read ----/  *  * For writes, this DAG is as follows:  *  *                    /---- write ----\  *    Header -- Commit ---- write ---- Block -- Terminate  *                    \---- write ----/  *  * There is one disk node per stripe unit accessed, and all disk nodes are in  * parallel.  *  * Tricky point here:  The first disk node (read or write) is created  * normally.  Subsequent disk nodes are created by copying the first one,  * and modifying a few params.  The "succedents" and "antecedents" fields are  * _not_ re-created in each node, but rather left pointing to the same array  * that was malloc'd when the first node was created.  Thus, it's essential  * that when this DAG is freed, the succedents and antecedents fields be freed  * in ONLY ONE of the read nodes.  This does not apply to the "params" field  * because it is recreated for each READ node.  *  * Note that normal-priority accesses do not need to be tagged with their  * parity stripe ID, because they will never be promoted.  Hence, I've  * commented-out the code to do this, and marked it with UNNEEDED.  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CreateNonredundantDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|diskNodes
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
name|asmap
operator|->
name|physInfo
decl_stmt|;
name|int
argument_list|(
operator|*
name|doFunc
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
decl_stmt|,
argument_list|(
operator|*
name|undoFunc
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|totalNumNodes
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|n
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"NonredundantDAG"
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RF_IO_TYPE_READ
case|:
name|doFunc
operator|=
name|rf_DiskReadFunc
expr_stmt|;
name|undoFunc
operator|=
name|rf_DiskReadUndoFunc
expr_stmt|;
name|name
operator|=
literal|"R  "
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating non-redundant read DAG]\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RF_IO_TYPE_WRITE
case|:
name|doFunc
operator|=
name|rf_DiskWriteFunc
expr_stmt|;
name|undoFunc
operator|=
name|rf_DiskWriteUndoFunc
expr_stmt|;
name|name
operator|=
literal|"W  "
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating non-redundant write DAG]\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
comment|/*          * For reads, the dag can not commit until the block node is reached.          * for writes, the dag commits immediately.          */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/*          * Node count:          * 1 block node          * n data reads (or writes)          * 1 commit node          * 1 terminator node          */
name|RF_ASSERT
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|totalNumNodes
operator|=
name|n
operator|+
literal|3
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|totalNumNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|diskNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|n
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|totalNumNodes
argument_list|)
expr_stmt|;
comment|/* initialize nodes */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RF_IO_TYPE_READ
case|:
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
name|RF_IO_TYPE_WRITE
case|:
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|n
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|diskNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|doFunc
argument_list|,
name|undoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
comment|/* parity stripe id is not necessary */
name|diskNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/*          * Connect nodes.          */
comment|/* connect hdr to block node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RF_IO_TYPE_READ
condition|)
block|{
comment|/* connecting a nonredundant read DAG */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
name|n
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* connect block node to each read node */
name|RF_ASSERT
argument_list|(
name|diskNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|diskNodes
index|[
name|i
index|]
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect each read node to the commit node */
name|RF_ASSERT
argument_list|(
name|diskNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|diskNodes
index|[
name|i
index|]
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the commit node to the term node */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
comment|/* connecting a nonredundant write DAG */
comment|/* connect the block node to the commit node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
name|n
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
name|n
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* connect the commit node to each write node */
name|RF_ASSERT
argument_list|(
name|diskNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|diskNodes
index|[
name|i
index|]
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect each write node to the term node */
name|RF_ASSERT
argument_list|(
name|diskNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|diskNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|diskNodes
index|[
name|i
index|]
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * Create a fault-free read DAG for RAID level 1  *  * Hdr -> Nil -> Rmir -> Cmt -> Trm  *  * The "Rmir" node schedules a read from the disk in the mirror pair with the  * shortest disk queue.  the proper queue is selected at Rmir execution.  this  * deferred mapping is unlike other archs in RAIDframe which generally fix  * mapping at DAG creation time.  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (for holding read data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|CreateMirrorReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|int
function_decl|(
modifier|*
name|readfunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|readNodes
decl_stmt|,
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|data_pda
init|=
name|asmap
operator|->
name|physInfo
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|parity_pda
init|=
name|asmap
operator|->
name|parityInfo
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|totalNumNodes
decl_stmt|;
name|n
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"RaidOneReadDAG"
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating RAID level 1 read DAG]\n"
argument_list|)
expr_stmt|;
block|}
comment|/*          * This dag can not commit until the commit node is reached          * errors prior to the commit point imply the dag has failed.          */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/*          * Node count:          * n data reads          * 1 block node          * 1 commit node          * 1 terminator node          */
name|RF_ASSERT
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|totalNumNodes
operator|=
name|n
operator|+
literal|3
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|totalNumNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|readNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|n
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|totalNumNodes
argument_list|)
expr_stmt|;
comment|/* initialize nodes */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|data_pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|parity_pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|readNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|readfunc
argument_list|,
name|rf_DiskReadMirrorUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rmir"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|data_pda
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|data_pda
operator|->
name|bufPtr
expr_stmt|;
comment|/* parity stripe id is not necessary */
name|readNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|p
operator|=
literal|0
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|.
name|p
operator|=
name|parity_pda
expr_stmt|;
name|data_pda
operator|=
name|data_pda
operator|->
name|next
expr_stmt|;
name|parity_pda
operator|=
name|parity_pda
operator|->
name|next
expr_stmt|;
block|}
comment|/*          * Connect nodes          */
comment|/* connect hdr to block node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect block node to read nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|readNodes
index|[
name|i
index|]
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect read nodes to commit node */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readNodes
index|[
name|i
index|]
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect commit node to term node */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateMirrorIdleReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|CreateMirrorReadDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
name|rf_DiskReadMirrorIdleFunc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateMirrorPartitionReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|CreateMirrorReadDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
name|rf_DiskReadMirrorPartitionFunc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

