begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_dagdegrd.c,v 1.7 2001/01/26 14:06:16 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, Daniel Stodolsky, William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * rf_dagdegrd.c  *  * code for creating degraded read DAGs  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_comment
comment|/******************************************************************************  *  * General comments on DAG creation:  *  * All DAGs in this file use roll-away error recovery.  Each DAG has a single  * commit node, usually called "Cmt."  If an error occurs before the Cmt node  * is reached, the execution engine will halt forward execution and work  * backward through the graph, executing the undo functions.  Assuming that  * each node in the graph prior to the Cmt node are undoable and atomic - or -  * does not make changes to permanent state, the graph will fail atomically.  * If an error occurs after the Cmt node executes, the engine will roll-forward  * through the graph, blindly executing nodes until it reaches the end.  * If a graph reaches the end, it is assumed to have completed successfully.  *  * A graph has only 1 Cmt node.  *  */
end_comment

begin_comment
comment|/******************************************************************************  *  * The following wrappers map the standard DAG creation interface to the  * DAG creation routines.  Additionally, these wrappers enable experimentation  * with new DAG structures by providing an extra level of indirection, allowing  * the DAG creation routines to be replaced at this single point.  */
end_comment

begin_function
name|void
name|rf_CreateRaidFiveDegradedReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|rf_CreateDegradedReadDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
operator|&
name|rf_xorRecoveryFuncs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * DAG creation code begins here  */
end_comment

begin_comment
comment|/******************************************************************************  * Create a degraded read DAG for RAID level 1  *  * Hdr -> Nil -> R(p/s)d -> Commit -> Trm  *  * The "Rd" node reads data from the surviving disk in the mirror pair  *   Rpd - read of primary copy  *   Rsd - read of secondary copy  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (for holding write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CreateRaidOneDegradedReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|rdNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
name|useMirror
decl_stmt|,
name|i
decl_stmt|;
name|useMirror
operator|=
literal|0
expr_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating RAID level 1 degraded read DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|dag_h
operator|->
name|creator
operator|=
literal|"RaidOneDegradedReadDAG"
expr_stmt|;
comment|/* alloc the Wnd nodes and the Wmir node */
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|0
condition|)
name|useMirror
operator|=
name|RF_FALSE
expr_stmt|;
else|else
name|useMirror
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* total number of nodes = 1 + (block + commit + terminator) */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|rdNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* this dag can not commit until the commit node is reached.   errors 	 * prior to the commit point imply the dag has failed and must be 	 * retried */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* initialize the block, commit, and terminator nodes */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* parityInfo must describe entire parity unit */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize the data node */
if|if
condition|(
operator|!
name|useMirror
condition|)
block|{
comment|/* read primary copy of data */
name|rf_InitNode
argument_list|(
name|rdNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rpd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read secondary copy of data */
name|rf_InitNode
argument_list|(
name|rdNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rsd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
comment|/* connect header to block node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect block node to rdnode */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rdNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|rdNode
expr_stmt|;
name|rdNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rdNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect rdnode to commit node */
name|RF_ASSERT
argument_list|(
name|rdNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rdNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|rdNode
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect commit node to terminator */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a degraded-mode read of data within one stripe.  * This DAG is as follows:  *  * Hdr -> Block -> Rud -> Xor -> Cmt -> T  *              -> Rrd ->  *              -> Rp -->  *  * Each R node is a successor of the L node  * One successor arc from each R node goes to C, and the other to X  * There is one Rud for each chunk of surviving user data requested by the  * user, and one Rrd for each chunk of surviving user data _not_ being read by  * the user  * R = read, ud = user data, rd = recovery (surviving) data, p = parity  * X = XOR, C = Commit, T = terminate  *  * The block node guarantees a single source node.  *  * Note:  The target buffer for the XOR node is set to the actual user buffer  * where the failed data is supposed to end up.  This buffer is zero'd by the  * code here.  Thus, if you create a degraded read dag, use it, and then  * re-use, you have to be sure to zero the target buffer prior to the re-use.  *  * The recfunc argument at the end specifies the name and function used for  * the redundancy  * recovery function.  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CreateDegradedReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|recFunc
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|rudNodes
decl_stmt|,
modifier|*
name|rrdNodes
decl_stmt|,
modifier|*
name|xorNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|rpNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|int
name|nNodes
decl_stmt|,
name|nRrdNodes
decl_stmt|,
name|nRudNodes
decl_stmt|,
name|nXorBufs
decl_stmt|,
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|paramNum
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerSU
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|char
modifier|*
name|overlappingPDAs
decl_stmt|;
comment|/* a temporary array of flags */
name|RF_AccessStripeMapHeader_t
modifier|*
name|new_asm_h
index|[
literal|2
index|]
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|parityPDA
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|char
modifier|*
name|rpBuf
decl_stmt|;
name|layoutPtr
operator|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
expr_stmt|;
comment|/* failedPDA points to the pda within the asm that targets the failed 	 * disk */
name|failedPDA
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|sectorsPerSU
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating degraded read DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"DegradedReadDAG"
expr_stmt|;
comment|/*          * generate two ASMs identifying the surviving data we need          * in order to recover the lost data          */
comment|/* overlappingPDAs array must be zero'd */
name|RF_Calloc
argument_list|(
name|overlappingPDAs
argument_list|,
name|asmap
operator|->
name|numStripeUnitsAccessed
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|rf_GenerateFailedAccessASMs
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|failedPDA
argument_list|,
name|dag_h
argument_list|,
name|new_asm_h
argument_list|,
operator|&
name|nXorBufs
argument_list|,
operator|&
name|rpBuf
argument_list|,
name|overlappingPDAs
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/*          * create all the nodes at once          *          * -1 because no access is generated for the failed pda          */
name|nRudNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|-
literal|1
expr_stmt|;
name|nRrdNodes
operator|=
operator|(
operator|(
name|new_asm_h
index|[
literal|0
index|]
operator|)
condition|?
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|new_asm_h
index|[
literal|1
index|]
operator|)
condition|?
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
else|:
literal|0
operator|)
expr_stmt|;
name|nNodes
operator|=
literal|5
operator|+
name|nRudNodes
operator|+
name|nRrdNodes
expr_stmt|;
comment|/* lock, unlock, xor, Rp, Rud, 						 * Rrd */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|xorNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|rpNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|rudNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nRudNodes
expr_stmt|;
name|rrdNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nRrdNodes
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|nNodes
argument_list|)
expr_stmt|;
comment|/* initialize nodes */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
comment|/* this dag can not commit until the commit node is reached errors 	 * prior to the commit point imply the dag has failed */
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nRudNodes
operator|+
name|nRrdNodes
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|xorNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|recFunc
operator|->
name|simple
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nRudNodes
operator|+
name|nRrdNodes
operator|+
literal|1
argument_list|,
literal|2
operator|*
name|nXorBufs
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|recFunc
operator|->
name|SimpleName
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* fill in the Rud nodes */
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRudNodes
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pda
operator|==
name|failedPDA
condition|)
block|{
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
name|rf_InitNode
argument_list|(
operator|&
name|rudNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rud"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the Rrd nodes */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_asm_h
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|pda
operator|=
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|i
operator|<
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rrdNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rrd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_asm_h
index|[
literal|1
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|pda
operator|=
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|j
operator|<
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
condition|;
name|j
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rrd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* make a PDA for the parity unit */
name|RF_MallocAndAdd
argument_list|(
name|parityPDA
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|parityPDA
operator|->
name|row
operator|=
name|asmap
operator|->
name|parityInfo
operator|->
name|row
expr_stmt|;
name|parityPDA
operator|->
name|col
operator|=
name|asmap
operator|->
name|parityInfo
operator|->
name|col
expr_stmt|;
name|parityPDA
operator|->
name|startSector
operator|=
operator|(
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|startSector
operator|/
name|sectorsPerSU
operator|)
operator|*
name|sectorsPerSU
operator|)
operator|+
operator|(
name|failedPDA
operator|->
name|startSector
operator|%
name|sectorsPerSU
operator|)
expr_stmt|;
name|parityPDA
operator|->
name|numSector
operator|=
name|failedPDA
operator|->
name|numSector
expr_stmt|;
comment|/* initialize the Rp node */
name|rf_InitNode
argument_list|(
name|rpNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rp "
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rpNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|parityPDA
expr_stmt|;
name|rpNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rpBuf
expr_stmt|;
name|rpNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rpNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
comment|/*          * the last and nastiest step is to assign all          * the parameters of the Xor node          */
name|paramNum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* all the Rrd nodes need to be xored together */
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|=
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|=
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRudNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* any Rud nodes that overlap the failed access need to be 		 * xored in */
if|if
condition|(
name|overlappingPDAs
index|[
name|i
index|]
condition|)
block|{
name|RF_MallocAndAdd
argument_list|(
name|pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rudNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
argument_list|,
name|pda
argument_list|,
name|RF_RESTRICT_DOBUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
block|}
block|}
name|RF_Free
argument_list|(
name|overlappingPDAs
argument_list|,
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install parity pda as last set of params to be xor'd */
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|parityPDA
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|rpBuf
expr_stmt|;
comment|/*          * the last 2 params to the recovery xor node are          * the failed PDA and the raidPtr          */
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|failedPDA
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|paramNum
operator|==
literal|2
operator|*
name|nXorBufs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/*          * The xor node uses results[0] as the target buffer.          * Set pointer and zero the buffer. In the kernel, this          * may be a user buffer in which case we have to remap it.          */
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|failedPDA
operator|->
name|bufPtr
expr_stmt|;
name|RF_BZERO
argument_list|(
name|bp
argument_list|,
name|failedPDA
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
operator|->
name|numSector
argument_list|)
argument_list|)
expr_stmt|;
comment|/* connect nodes to form graph */
comment|/* connect the header to the block node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect the block node to the read nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
operator|(
literal|1
operator|+
name|nRrdNodes
operator|+
name|nRudNodes
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rpNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|rpNode
expr_stmt|;
name|rpNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rpNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rrdNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|1
operator|+
name|i
index|]
operator|=
operator|&
name|rrdNodes
index|[
name|i
index|]
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRudNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rudNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|1
operator|+
name|nRrdNodes
operator|+
name|i
index|]
operator|=
operator|&
name|rudNodes
index|[
name|i
index|]
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the read nodes to the xor node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numAntecedents
operator|==
operator|(
literal|1
operator|+
name|nRrdNodes
operator|+
name|nRudNodes
operator|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rpNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rpNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|rpNode
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rrdNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
literal|1
operator|+
name|i
index|]
operator|=
operator|&
name|rrdNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
literal|1
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRudNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rudNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rudNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
literal|1
operator|+
name|nRrdNodes
operator|+
name|i
index|]
operator|=
operator|&
name|rudNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
literal|1
operator|+
name|nRrdNodes
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* connect the xor node to the commit node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect the termNode to the commit node */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_CHAINDECLUSTER
operator|>
literal|0
operator|)
end_if

begin_comment
comment|/******************************************************************************  * Create a degraded read DAG for Chained Declustering  *  * Hdr -> Nil -> R(p/s)d -> Cmt -> Trm  *  * The "Rd" node reads data from the surviving disk in the mirror pair  *   Rpd - read of primary copy  *   Rsd - read of secondary copy  *  * Parameters:  raidPtr   - description of the physical array  *              asmap     - logical& physical addresses for this access  *              bp        - buffer ptr (for holding write data)  *              flags     - general flags (e.g. disk locking)  *              allocList - list of memory allocated in DAG creation  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CreateRaidCDegradedReadDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|rdNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|int
name|useMirror
decl_stmt|,
name|i
decl_stmt|,
name|shiftable
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
if|if
condition|(
operator|(
name|asmap
operator|->
name|numDataFailed
operator|+
name|asmap
operator|->
name|numParityFailed
operator|)
operator|==
literal|0
condition|)
block|{
name|shiftable
operator|=
name|RF_TRUE
expr_stmt|;
block|}
else|else
block|{
name|shiftable
operator|=
name|RF_FALSE
expr_stmt|;
block|}
name|useMirror
operator|=
literal|0
expr_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[Creating RAID C degraded read DAG]\n"
argument_list|)
expr_stmt|;
block|}
name|dag_h
operator|->
name|creator
operator|=
literal|"RaidCDegradedReadDAG"
expr_stmt|;
comment|/* alloc the Wnd nodes and the Wmir node */
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|0
condition|)
name|useMirror
operator|=
name|RF_FALSE
expr_stmt|;
else|else
name|useMirror
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* total number of nodes = 1 + (block + commit + terminator) */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|rdNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/*          * This dag can not commit until the commit node is reached.          * Errors prior to the commit point imply the dag has failed          * and must be retried.          */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* initialize the block, commit, and terminator nodes */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* parityInfo must describe entire parity unit */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize the data node */
if|if
condition|(
operator|!
name|useMirror
condition|)
block|{
name|rf_InitNode
argument_list|(
name|rdNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rpd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|shiftable
operator|&&
name|rf_compute_workload_shift
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|)
condition|)
block|{
comment|/* shift this read to the next disk in line */
name|rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read primary copy */
name|rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* read secondary copy of data */
name|rf_InitNode
argument_list|(
name|rdNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rsd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
comment|/* connect header to block node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect block node to rdnode */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rdNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|rdNode
expr_stmt|;
name|rdNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rdNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect rdnode to commit node */
name|RF_ASSERT
argument_list|(
name|rdNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rdNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|rdNode
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect commit node to terminator */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_CHAINDECLUSTER> 0) */
end_comment

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_DECL_PQ
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_RAID6
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_EVENODD
operator|>
literal|0
operator|)
end_if

begin_comment
comment|/*  * XXX move this elsewhere?  */
end_comment

begin_function
name|void
name|rf_DD_GenerateFailedAccessASMs
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|pdap
parameter_list|,
name|int
modifier|*
name|nNodep
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|pqpdap
parameter_list|,
name|int
modifier|*
name|nPQNodep
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|PDAPerDisk
decl_stmt|,
name|i
decl_stmt|;
name|RF_SectorCount_t
name|secPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|int
name|state
decl_stmt|;
name|RF_SectorNum_t
name|suoff
decl_stmt|,
name|suend
decl_stmt|;
name|unsigned
name|firstDataCol
decl_stmt|,
name|napdas
decl_stmt|,
name|count
decl_stmt|;
name|RF_SectorNum_t
name|fone_start
decl_stmt|,
name|fone_end
decl_stmt|,
name|ftwo_start
init|=
literal|0
decl_stmt|,
name|ftwo_end
init|=
literal|0
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|fone
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|ftwo
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda_p
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|phys_p
decl_stmt|;
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|;
comment|/* determine how many pda's we will have to generate per unaccess 	 * stripe. If there is only one failed data unit, it is one; if two, 	 * possibly two, depending wether they overlap. */
name|fone_start
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|fone
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|fone_end
operator|=
name|fone_start
operator|+
name|fone
operator|->
name|numSector
expr_stmt|;
define|#
directive|define
name|CONS_PDA
parameter_list|(
define|if,start,num) \   pda_p->row = asmap->if->row;    pda_p->col = asmap->if->col; \   pda_p->startSector = ((asmap->if->startSector / secPerSU) * secPerSU) + start; \   pda_p->numSector = num; \   pda_p->next = NULL; \   RF_MallocAndAdd(pda_p->bufPtr,rf_RaidAddressToByte(raidPtr,num),(char *), allocList)
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
condition|)
block|{
name|PDAPerDisk
operator|=
literal|1
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
operator|*
name|pqpdap
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|=
operator|*
name|pqpdap
expr_stmt|;
comment|/* build p */
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
comment|/* build q */
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
block|}
else|else
block|{
name|ftwo_start
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|ftwo
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|ftwo_end
operator|=
name|ftwo_start
operator|+
name|ftwo
operator|->
name|numSector
expr_stmt|;
if|if
condition|(
name|fone
operator|->
name|numSector
operator|+
name|ftwo
operator|->
name|numSector
operator|>
name|secPerSU
condition|)
block|{
name|PDAPerDisk
operator|=
literal|1
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
operator|*
name|pqpdap
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|=
operator|*
name|pqpdap
expr_stmt|;
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
literal|0
argument_list|,
name|secPerSU
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
literal|0
argument_list|,
name|secPerSU
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
block|}
else|else
block|{
name|PDAPerDisk
operator|=
literal|2
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
comment|/* four of them, fone, then ftwo */
name|RF_MallocAndAdd
argument_list|(
operator|*
name|pqpdap
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|=
operator|*
name|pqpdap
expr_stmt|;
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
name|ftwo_start
argument_list|,
name|ftwo
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
name|ftwo_start
argument_list|,
name|ftwo
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
block|}
block|}
comment|/* figure out number of nonaccessed pda */
name|napdas
operator|=
name|PDAPerDisk
operator|*
operator|(
name|numDataCol
operator|-
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|-
operator|(
name|ftwo
operator|==
name|NULL
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
operator|*
name|nPQNodep
operator|=
name|PDAPerDisk
expr_stmt|;
comment|/* sweep over the over accessed pda's, figuring out the number of 	 * additional pda's to generate. Of course, skip the failed ones */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pda_p
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|pda_p
condition|;
name|pda_p
operator|=
name|pda_p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|pda_p
operator|==
name|fone
operator|)
operator|||
operator|(
name|pda_p
operator|==
name|ftwo
operator|)
condition|)
continue|continue;
name|suoff
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda_p
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|suend
operator|=
name|suoff
operator|+
name|pda_p
operator|->
name|numSector
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|1
case|:
comment|/* one failed PDA to overlap */
comment|/* if a PDA doesn't contain the failed unit, it can 			 * only miss the start or end, not both */
if|if
condition|(
operator|(
name|suoff
operator|>
name|fone_start
operator|)
operator|||
operator|(
name|suend
operator|<
name|fone_end
operator|)
condition|)
name|count
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* whole stripe */
if|if
condition|(
name|suoff
condition|)
comment|/* leak at begining */
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|suend
operator|<
name|numDataCol
condition|)
comment|/* leak at end */
name|count
operator|++
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* two disjoint units */
if|if
condition|(
operator|(
name|suoff
operator|>
name|fone_start
operator|)
operator|||
operator|(
name|suend
operator|<
name|fone_end
operator|)
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|suoff
operator|>
name|ftwo_start
operator|)
operator|||
operator|(
name|suend
operator|<
name|ftwo_end
operator|)
condition|)
name|count
operator|++
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
block|}
name|napdas
operator|+=
name|count
expr_stmt|;
operator|*
name|nNodep
operator|=
name|napdas
expr_stmt|;
if|if
condition|(
name|napdas
operator|==
literal|0
condition|)
return|return;
comment|/* short circuit */
comment|/* allocate up our list of pda's */
name|RF_CallocAndAdd
argument_list|(
name|pda_p
argument_list|,
name|napdas
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
operator|*
name|pdap
operator|=
name|pda_p
expr_stmt|;
comment|/* linkem together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|napdas
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|pda_p
index|[
name|i
index|]
operator|.
name|next
operator|=
name|pda_p
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* march through the one's up to the first accessed disk */
name|firstDataCol
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|physInfo
operator|->
name|raidAddress
argument_list|)
operator|%
name|numDataCol
expr_stmt|;
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|firstDataCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pda_p
operator|-
operator|(
operator|*
name|pdap
operator|)
operator|)
operator|==
name|napdas
condition|)
continue|continue;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|pda_p
operator|->
name|row
index|]
index|[
name|pda_p
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|1
case|:
comment|/* fone */
name|pda_p
operator|->
name|numSector
operator|=
name|fone
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|fone_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* full stripe */
name|pda_p
operator|->
name|numSector
operator|=
name|secPerSU
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|secPerSU
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* two slabs */
name|pda_p
operator|->
name|numSector
operator|=
name|fone
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|fone_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|numSector
operator|=
name|ftwo
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|ftwo_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|ftwo_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|pda_p
operator|++
expr_stmt|;
block|}
comment|/* march through the touched stripe units */
for|for
control|(
name|phys_p
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|phys_p
condition|;
name|phys_p
operator|=
name|phys_p
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|phys_p
operator|==
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|phys_p
operator|==
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|)
condition|)
continue|continue;
name|suoff
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|phys_p
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|suend
operator|=
name|suoff
operator|+
name|phys_p
operator|->
name|numSector
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|1
case|:
comment|/* single buffer */
if|if
condition|(
name|suoff
operator|>
name|fone_start
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|suend
operator|>=
name|fone_end
argument_list|)
expr_stmt|;
comment|/* The data read starts after the mapped 				 * access, snip off the begining */
name|pda_p
operator|->
name|numSector
operator|=
name|suoff
operator|-
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|fone_start
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suend
operator|<
name|fone_end
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|suoff
operator|<=
name|fone_start
argument_list|)
expr_stmt|;
comment|/* The data read stops before the end of the 				 * failed access, extend */
name|pda_p
operator|->
name|numSector
operator|=
name|fone_end
operator|-
name|suend
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|suend
expr_stmt|;
comment|/* off by one? */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* whole stripe unit */
name|RF_ASSERT
argument_list|(
operator|(
name|suoff
operator|==
literal|0
operator|)
operator|||
operator|(
name|suend
operator|==
name|secPerSU
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|suend
operator|<
name|secPerSU
condition|)
block|{
comment|/* short read, snip from end 						 * on */
name|pda_p
operator|->
name|numSector
operator|=
name|secPerSU
operator|-
name|suend
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|suend
expr_stmt|;
comment|/* off by one? */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suoff
operator|>
literal|0
condition|)
block|{
comment|/* short at front */
name|pda_p
operator|->
name|numSector
operator|=
name|suoff
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* two nonoverlapping failures */
if|if
condition|(
operator|(
name|suoff
operator|>
name|fone_start
operator|)
operator|||
operator|(
name|suend
operator|<
name|fone_end
operator|)
condition|)
block|{
if|if
condition|(
name|suoff
operator|>
name|fone_start
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|suend
operator|>=
name|fone_end
argument_list|)
expr_stmt|;
comment|/* The data read starts after the 					 * mapped access, snip off the 					 * begining */
name|pda_p
operator|->
name|numSector
operator|=
name|suoff
operator|-
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|fone_start
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suend
operator|<
name|fone_end
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|suoff
operator|<=
name|fone_start
argument_list|)
expr_stmt|;
comment|/* The data read stops before the end 					 * of the failed access, extend */
name|pda_p
operator|->
name|numSector
operator|=
name|fone_end
operator|-
name|suend
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|suend
expr_stmt|;
comment|/* off by one? */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|suoff
operator|>
name|ftwo_start
operator|)
operator|||
operator|(
name|suend
operator|<
name|ftwo_end
operator|)
condition|)
block|{
if|if
condition|(
name|suoff
operator|>
name|ftwo_start
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|suend
operator|>=
name|ftwo_end
argument_list|)
expr_stmt|;
comment|/* The data read starts after the 					 * mapped access, snip off the 					 * begining */
name|pda_p
operator|->
name|numSector
operator|=
name|suoff
operator|-
name|ftwo_start
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|ftwo_start
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suend
operator|<
name|ftwo_end
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|suoff
operator|<=
name|ftwo_start
argument_list|)
expr_stmt|;
comment|/* The data read stops before the end 					 * of the failed access, extend */
name|pda_p
operator|->
name|numSector
operator|=
name|ftwo_end
operator|-
name|suend
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
operator|+
name|suend
expr_stmt|;
comment|/* off by one? */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* after the last accessed disk */
for|for
control|(
init|;
name|i
operator|<
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pda_p
operator|-
operator|(
operator|*
name|pdap
operator|)
operator|)
operator|==
name|napdas
condition|)
continue|continue;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|pda_p
operator|->
name|row
index|]
index|[
name|pda_p
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|1
case|:
comment|/* fone */
name|pda_p
operator|->
name|numSector
operator|=
name|fone
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|fone_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* full stripe */
name|pda_p
operator|->
name|numSector
operator|=
name|secPerSU
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|secPerSU
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* two slabs */
name|pda_p
operator|->
name|numSector
operator|=
name|fone
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|fone_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|numSector
operator|=
name|ftwo
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|ftwo_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|ftwo_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|pda_p
operator|++
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda_p
operator|-
operator|*
name|pdap
operator|==
name|napdas
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|INIT_DISK_NODE
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
define|\
value|rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 2,1,4,0, dag_h, name, allocList); \ (node)->succedents[0] = unblockNode; \ (node)->succedents[1] = recoveryNode; \ (node)->antecedents[0] = blockNode; \ (node)->antType[0] = rf_control
end_define

begin_define
define|#
directive|define
name|DISK_NODE_PARAMS
parameter_list|(
name|_node_
parameter_list|,
name|_p_
parameter_list|)
define|\
value|(_node_).params[0].p = _p_ ; \   (_node_).params[1].p = (_p_)->bufPtr; \   (_node_).params[2].v = parityStripeID; \   (_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru)
end_define

begin_function
name|void
name|rf_DoubleDegRead
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|char
modifier|*
name|redundantReadNodeName
parameter_list|,
name|char
modifier|*
name|recoveryNodeName
parameter_list|,
name|int
function_decl|(
modifier|*
name|recovFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|rudNodes
decl_stmt|,
modifier|*
name|rrdNodes
decl_stmt|,
modifier|*
name|recoveryNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|rpNodes
decl_stmt|,
modifier|*
name|rqNodes
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|pqPDAs
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|npdas
decl_stmt|;
name|int
name|nNodes
decl_stmt|,
name|nRrdNodes
decl_stmt|,
name|nRudNodes
decl_stmt|,
name|i
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|int
name|nReadNodes
decl_stmt|,
name|nPQNodes
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDAtwo
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
init|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
decl_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating Double Degraded Read DAG]\n"
argument_list|)
expr_stmt|;
name|rf_DD_GenerateFailedAccessASMs
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
operator|&
name|npdas
argument_list|,
operator|&
name|nRrdNodes
argument_list|,
operator|&
name|pqPDAs
argument_list|,
operator|&
name|nPQNodes
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|nRudNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|-
operator|(
name|asmap
operator|->
name|numDataFailed
operator|)
expr_stmt|;
name|nReadNodes
operator|=
name|nRrdNodes
operator|+
name|nRudNodes
operator|+
literal|2
operator|*
name|nPQNodes
expr_stmt|;
name|nNodes
operator|=
literal|4
comment|/* block, unblock, recovery, term */
operator|+
name|nReadNodes
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|unblockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|recoveryNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|rudNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nRudNodes
expr_stmt|;
name|rrdNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nRrdNodes
expr_stmt|;
name|rpNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nPQNodes
expr_stmt|;
name|rqNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nPQNodes
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|nNodes
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"DoubleDegRead"
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
comment|/* unblock */
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|1
index|]
operator|=
name|recoveryNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|1
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* init the block and unblock nodes */
comment|/* The block node has all nodes except itself, unblock and recovery as 	 * successors. Similarly for predecessors of the unblock. */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nReadNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nReadNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nReadNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
name|rudNodes
operator|+
name|i
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
name|rudNodes
operator|+
name|i
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
comment|/* The recovery node has all the reads as predecessors, and the term 	 * node as successors. It gets a pda as a param from each of the read 	 * nodes plus the raidPtr. For each failed unit is has a result pda. */
name|rf_InitNode
argument_list|(
name|recoveryNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|recovFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
comment|/* succesors */
name|nReadNodes
argument_list|,
comment|/* preds */
name|nReadNodes
operator|+
literal|2
argument_list|,
comment|/* params */
name|asmap
operator|->
name|numDataFailed
argument_list|,
comment|/* results */
name|dag_h
argument_list|,
name|recoveryNodeName
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|recoveryNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nReadNodes
condition|;
name|i
operator|++
control|)
block|{
name|recoveryNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
name|rudNodes
operator|+
name|i
expr_stmt|;
name|recoveryNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* build the read nodes, then come back and fill in recovery params 	 * and results */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRudNodes
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|pda
operator|==
name|failedPDA
operator|)
operator|||
operator|(
name|pda
operator|==
name|failedPDAtwo
operator|)
condition|)
continue|continue;
name|INIT_DISK_NODE
argument_list|(
name|rudNodes
operator|+
name|i
argument_list|,
literal|"Rud"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rudNodes
index|[
name|i
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|pda
operator|=
name|npdas
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|INIT_DISK_NODE
argument_list|(
name|rrdNodes
operator|+
name|i
argument_list|,
literal|"Rrd"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rrdNodes
index|[
name|i
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
block|}
comment|/* redundancy pdas */
name|pda
operator|=
name|pqPDAs
expr_stmt|;
name|INIT_DISK_NODE
argument_list|(
name|rpNodes
argument_list|,
literal|"Rp"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rpNodes
index|[
literal|0
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|INIT_DISK_NODE
argument_list|(
name|rqNodes
argument_list|,
name|redundantReadNodeName
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rqNodes
index|[
literal|0
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
if|if
condition|(
name|nPQNodes
operator|==
literal|2
condition|)
block|{
name|pda
operator|++
expr_stmt|;
name|INIT_DISK_NODE
argument_list|(
name|rpNodes
operator|+
literal|1
argument_list|,
literal|"Rp"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rpNodes
index|[
literal|1
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|INIT_DISK_NODE
argument_list|(
name|rqNodes
operator|+
literal|1
argument_list|,
name|redundantReadNodeName
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rqNodes
index|[
literal|1
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
block|}
comment|/* fill in recovery node params */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nReadNodes
condition|;
name|i
operator|++
control|)
name|recoveryNode
operator|->
name|params
index|[
name|i
index|]
operator|=
name|rudNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|recoveryNode
operator|->
name|params
index|[
name|i
operator|++
index|]
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|raidPtr
expr_stmt|;
name|recoveryNode
operator|->
name|params
index|[
name|i
operator|++
index|]
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|asmap
expr_stmt|;
name|recoveryNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|failedPDA
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|2
condition|)
name|recoveryNode
operator|->
name|results
index|[
literal|1
index|]
operator|=
name|failedPDAtwo
expr_stmt|;
comment|/* zero fill the target data buffers? */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_DECL_PQ> 0) || (RF_INCLUDE_RAID6> 0) || (RF_INCLUDE_EVENODD> 0) */
end_comment

end_unit

