begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_raid1.c,v 1.5 2000/01/08 22:57:30 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*****************************************************************************  *  * rf_raid1.c -- implements RAID Level 1  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid1.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_layout.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconbuffer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|RF_Raid1ConfigInfo_s
block|{
name|RF_RowCol_t
modifier|*
modifier|*
name|stripeIdentifier
decl_stmt|;
block|}
name|RF_Raid1ConfigInfo_t
typedef|;
end_typedef

begin_comment
comment|/* start of day code specific to RAID level 1 */
end_comment

begin_function
name|int
name|rf_ConfigureRAID1
parameter_list|(
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_Config_t
modifier|*
name|cfgPtr
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_Raid1ConfigInfo_t
modifier|*
name|info
decl_stmt|;
name|RF_RowCol_t
name|i
decl_stmt|;
comment|/* create a RAID level 1 configuration structure */
name|RF_MallocAndAdd
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Raid1ConfigInfo_t
argument_list|)
argument_list|,
operator|(
name|RF_Raid1ConfigInfo_t
operator|*
operator|)
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|layoutPtr
operator|->
name|layoutSpecificInfo
operator|=
operator|(
name|void
operator|*
operator|)
name|info
expr_stmt|;
comment|/* ... and fill it in. */
name|info
operator|->
name|stripeIdentifier
operator|=
name|rf_make_2d_array
argument_list|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
argument_list|,
literal|2
argument_list|,
name|raidPtr
operator|->
name|cleanupList
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|stripeIdentifier
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|stripeIdentifier
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
literal|2
operator|*
name|i
operator|)
expr_stmt|;
name|info
operator|->
name|stripeIdentifier
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|(
literal|2
operator|*
name|i
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|numRow
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* this implementation of RAID level 1 uses one row of numCol disks 	 * and allows multiple (numCol / 2) stripes per row.  A stripe 	 * consists of a single data unit and a single parity (mirror) unit. 	 * stripe id = raidAddr / stripeUnitSize */
name|raidPtr
operator|->
name|totalSectors
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|numStripe
operator|=
name|layoutPtr
operator|->
name|stripeUnitsPerDisk
operator|*
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
expr_stmt|;
name|layoutPtr
operator|->
name|dataSectorsPerStripe
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
name|layoutPtr
operator|->
name|bytesPerStripeUnit
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|layoutPtr
operator|->
name|numDataCol
operator|=
literal|1
expr_stmt|;
name|layoutPtr
operator|->
name|numParityCol
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns the physical disk location of the primary copy in the mirror pair */
end_comment

begin_function
name|void
name|rf_MapSectorRAID1
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_RowCol_t
name|mirrorPair
init|=
name|SUID
operator|%
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
decl_stmt|;
operator|*
name|row
operator|=
literal|0
expr_stmt|;
operator|*
name|col
operator|=
literal|2
operator|*
name|mirrorPair
expr_stmt|;
operator|*
name|diskSector
operator|=
operator|(
operator|(
name|SUID
operator|/
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
operator|+
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map Parity  *  * returns the physical disk location of the secondary copy in the mirror  * pair  */
end_comment

begin_function
name|void
name|rf_MapParityRAID1
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidSector
parameter_list|,
name|RF_RowCol_t
modifier|*
name|row
parameter_list|,
name|RF_RowCol_t
modifier|*
name|col
parameter_list|,
name|RF_SectorNum_t
modifier|*
name|diskSector
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|RF_StripeNum_t
name|SUID
init|=
name|raidSector
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_RowCol_t
name|mirrorPair
init|=
name|SUID
operator|%
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
decl_stmt|;
operator|*
name|row
operator|=
literal|0
expr_stmt|;
operator|*
name|col
operator|=
operator|(
literal|2
operator|*
name|mirrorPair
operator|)
operator|+
literal|1
expr_stmt|;
operator|*
name|diskSector
operator|=
operator|(
operator|(
name|SUID
operator|/
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
operator|)
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
operator|+
operator|(
name|raidSector
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* IdentifyStripeRAID1  *  * returns a list of disks for a given redundancy group  */
end_comment

begin_function
name|void
name|rf_IdentifyStripeRAID1
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|addr
parameter_list|,
name|RF_RowCol_t
modifier|*
modifier|*
name|diskids
parameter_list|,
name|RF_RowCol_t
modifier|*
name|outRow
parameter_list|)
block|{
name|RF_StripeNum_t
name|stripeID
init|=
name|rf_RaidAddressToStripeID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RF_Raid1ConfigInfo_t
modifier|*
name|info
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|layoutSpecificInfo
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|stripeID
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|addr
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|outRow
operator|=
literal|0
expr_stmt|;
operator|*
name|diskids
operator|=
name|info
operator|->
name|stripeIdentifier
index|[
name|stripeID
operator|%
operator|(
name|raidPtr
operator|->
name|numCol
operator|/
literal|2
operator|)
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|*
name|diskids
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MapSIDToPSIDRAID1  *  * maps a logical stripe to a stripe in the redundant array  */
end_comment

begin_function
name|void
name|rf_MapSIDToPSIDRAID1
parameter_list|(
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_StripeNum_t
name|stripeID
parameter_list|,
name|RF_StripeNum_t
modifier|*
name|psID
parameter_list|,
name|RF_ReconUnitNum_t
modifier|*
name|which_ru
parameter_list|)
block|{
operator|*
name|which_ru
operator|=
literal|0
expr_stmt|;
operator|*
name|psID
operator|=
name|stripeID
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * select a graph to perform a single-stripe access  *  * Parameters:  raidPtr    - description of the physical array  *              type       - type of operation (read or write) requested  *              asmap      - logical& physical addresses for this access  *              createFunc - name of function to use to create the graph  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_RAID1DagSelect
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_VoidFuncPtr
modifier|*
name|createFunc
parameter_list|)
block|{
name|RF_RowCol_t
name|frow
decl_stmt|,
name|fcol
decl_stmt|,
name|or
decl_stmt|,
name|oc
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
decl_stmt|;
name|int
name|prior_recon
decl_stmt|;
name|RF_RowStatus_t
name|rstat
decl_stmt|;
name|RF_SectorNum_t
name|oo
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|+
name|asmap
operator|->
name|numParityFailed
operator|>
literal|1
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Multiple disks failed in a single group!  Aborting I/O operation.\n"
argument_list|)
expr_stmt|;
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|+
name|asmap
operator|->
name|numParityFailed
condition|)
block|{
comment|/* 	         * We've got a fault. Re-map to spare space, iff applicable. 	         * Shouldn't the arch-independent code do this for us? 	         * Anyway, it turns out if we don't do this here, then when 	         * we're reconstructing, writes go only to the surviving 	         * original disk, and aren't reflected on the reconstructed 	         * spare. Oops. --jimz 	         */
name|failedPDA
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
name|frow
operator|=
name|failedPDA
operator|->
name|row
expr_stmt|;
name|fcol
operator|=
name|failedPDA
operator|->
name|col
expr_stmt|;
name|rstat
operator|=
name|raidPtr
operator|->
name|status
index|[
name|frow
index|]
expr_stmt|;
name|prior_recon
operator|=
operator|(
name|rstat
operator|==
name|rf_rs_reconfigured
operator|)
operator|||
operator|(
operator|(
name|rstat
operator|==
name|rf_rs_reconstructing
operator|)
condition|?
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|frow
index|]
operator|->
name|reconMap
argument_list|,
name|failedPDA
operator|->
name|startSector
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|prior_recon
condition|)
block|{
name|or
operator|=
name|frow
expr_stmt|;
name|oc
operator|=
name|fcol
expr_stmt|;
name|oo
operator|=
name|failedPDA
operator|->
name|startSector
expr_stmt|;
comment|/* 		         * If we did distributed sparing, we'd monkey with that here. 		         * But we don't, so we'll 		         */
name|failedPDA
operator|->
name|row
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|spareRow
expr_stmt|;
name|failedPDA
operator|->
name|col
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|spareCol
expr_stmt|;
comment|/* 		         * Redirect other components, iff necessary. This looks 		         * pretty suspicious to me, but it's what the raid5 		         * DAG select does. 		         */
if|if
condition|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|failedPDA
operator|==
name|asmap
operator|->
name|parityInfo
condition|)
block|{
name|failedPDA
operator|->
name|next
operator|->
name|row
operator|=
name|failedPDA
operator|->
name|row
expr_stmt|;
name|failedPDA
operator|->
name|next
operator|->
name|col
operator|=
name|failedPDA
operator|->
name|col
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|failedPDA
operator|==
name|asmap
operator|->
name|parityInfo
operator|->
name|next
condition|)
block|{
name|asmap
operator|->
name|parityInfo
operator|->
name|row
operator|=
name|failedPDA
operator|->
name|row
expr_stmt|;
name|asmap
operator|->
name|parityInfo
operator|->
name|col
operator|=
name|failedPDA
operator|->
name|col
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rf_dagDebug
operator|||
name|rf_mapDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|type
argument_list|,
name|or
argument_list|,
name|oc
argument_list|,
operator|(
name|long
operator|)
name|oo
argument_list|,
name|failedPDA
operator|->
name|row
argument_list|,
name|failedPDA
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|failedPDA
operator|->
name|startSector
argument_list|)
expr_stmt|;
block|}
name|asmap
operator|->
name|numDataFailed
operator|=
name|asmap
operator|->
name|numParityFailed
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|RF_IO_TYPE_READ
condition|)
block|{
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|0
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateMirrorIdleReadDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateRaidOneDegradedReadDAG
expr_stmt|;
block|}
else|else
block|{
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateRaidOneWriteDAG
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rf_VerifyParityRAID1
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidAddr_t
name|raidAddr
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|parityPDA
parameter_list|,
name|int
name|correct_it
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|)
block|{
name|int
name|nbytes
decl_stmt|,
name|bcount
decl_stmt|,
name|stripeWidth
decl_stmt|,
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nbad
decl_stmt|,
modifier|*
name|bbufs
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|wrBlock
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|rd_dag_h
decl_stmt|,
modifier|*
name|wr_dag_h
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|allocList
decl_stmt|;
name|RF_AccTraceEntry_t
name|tracerec
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|aasm
decl_stmt|;
name|RF_SectorCount_t
name|nsector
decl_stmt|;
name|RF_RaidAddr_t
name|startAddr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|RF_StripeNum_t
name|psID
decl_stmt|;
name|RF_MCPair_t
modifier|*
name|mcpair
decl_stmt|;
name|layoutPtr
operator|=
operator|&
name|raidPtr
operator|->
name|Layout
expr_stmt|;
name|startAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|)
expr_stmt|;
name|nsector
operator|=
name|parityPDA
operator|->
name|numSector
expr_stmt|;
name|nbytes
operator|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|nsector
argument_list|)
expr_stmt|;
name|psID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|asm_h
operator|=
name|NULL
expr_stmt|;
name|rd_dag_h
operator|=
name|wr_dag_h
operator|=
name|NULL
expr_stmt|;
name|mcpair
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|RF_PARITY_COULD_NOT_VERIFY
expr_stmt|;
name|rf_MakeAllocList
argument_list|(
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocList
operator|==
name|NULL
condition|)
return|return
operator|(
name|RF_PARITY_COULD_NOT_VERIFY
operator|)
return|;
name|mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
if|if
condition|(
name|mcpair
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|RF_ASSERT
argument_list|(
name|layoutPtr
operator|->
name|numDataCol
operator|==
name|layoutPtr
operator|->
name|numParityCol
argument_list|)
expr_stmt|;
name|stripeWidth
operator|=
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
expr_stmt|;
name|bcount
operator|=
name|nbytes
operator|*
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
operator|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|buf
argument_list|,
name|bcount
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 parity verify: buf=%lx bcount=%d (%lx - %lx)\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|long
operator|)
name|buf
argument_list|,
name|bcount
argument_list|,
operator|(
name|long
operator|)
name|buf
argument_list|,
operator|(
name|long
operator|)
name|buf
operator|+
name|bcount
argument_list|)
expr_stmt|;
block|}
comment|/*          * Generate a DAG which will read the entire stripe- then we can          * just compare data chunks versus "parity" chunks.          */
name|rd_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
name|stripeWidth
argument_list|,
name|nbytes
argument_list|,
name|buf
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd_dag_h
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|blockNode
operator|=
name|rd_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|unblockNode
operator|=
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
comment|/*          * Map the access to physical disk addresses (PDAs)- this will          * get us both a list of data addresses, and "parity" addresses          * (which are really mirror copies).          */
name|asm_h
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|startAddr
argument_list|,
name|layoutPtr
operator|->
name|dataSectorsPerStripe
argument_list|,
name|buf
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|aasm
operator|=
name|asm_h
operator|->
name|stripeMap
expr_stmt|;
name|buf1
operator|=
name|buf
expr_stmt|;
comment|/*          * Loop through the data blocks, setting up read nodes for each.          */
for|for
control|(
name|pda
operator|=
name|aasm
operator|->
name|physInfo
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* cannot verify parity with dead disk */
goto|goto
name|done
goto|;
block|}
name|pda
operator|->
name|bufPtr
operator|=
name|buf1
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|buf1
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|buf1
operator|+=
name|nbytes
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/*          * keep i, buf1 running          *          * Loop through parity blocks, setting up read nodes for each.          */
for|for
control|(
name|pda
operator|=
name|aasm
operator|->
name|parityInfo
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* cannot verify parity with dead disk */
goto|goto
name|done
goto|;
block|}
name|pda
operator|->
name|bufPtr
operator|=
name|buf1
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|buf1
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|buf1
operator|+=
name|nbytes
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|rd_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 parity verify read dag:\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|rd_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DispatchDAG
argument_list|(
name|rd_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
name|mcpair
operator|->
name|flag
operator|==
literal|0
condition|)
block|{
name|RF_WAIT_MCPAIR
argument_list|(
name|mcpair
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to verify raid1 parity: can't read stripe\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|RF_PARITY_COULD_NOT_VERIFY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*          * buf1 is the beginning of the data blocks chunk          * buf2 is the beginning of the parity blocks chunk          */
name|buf1
operator|=
name|buf
expr_stmt|;
name|buf2
operator|=
name|buf
operator|+
operator|(
name|nbytes
operator|*
name|layoutPtr
operator|->
name|numDataCol
operator|)
expr_stmt|;
name|ret
operator|=
name|RF_PARITY_OKAY
expr_stmt|;
comment|/*          * bbufs is "bad bufs"- an array whose entries are the data          * column numbers where we had miscompares. (That is, column 0          * and column 1 of the array are mirror copies, and are considered          * "data column 0" for this purpose).          */
name|RF_MallocAndAdd
argument_list|(
name|bbufs
argument_list|,
name|layoutPtr
operator|->
name|numParityCol
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|nbad
operator|=
literal|0
expr_stmt|;
comment|/*          * Check data vs "parity" (mirror copy).          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 parity verify %d bytes: i=%d buf1=%lx buf2=%lx buf=%lx\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|nbytes
argument_list|,
name|i
argument_list|,
operator|(
name|long
operator|)
name|buf1
argument_list|,
operator|(
name|long
operator|)
name|buf2
argument_list|,
operator|(
name|long
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|bcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|rf_verifyParityDebug
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nbytes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buf1
index|[
name|j
index|]
operator|!=
name|buf2
index|[
name|j
index|]
condition|)
break|break;
block|}
name|printf
argument_list|(
literal|"psid=%ld j=%d\n"
argument_list|,
operator|(
name|long
operator|)
name|psID
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"buf1 %02x %02x %02x %02x %02x\n"
argument_list|,
name|buf1
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|buf1
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|buf1
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|buf1
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|buf1
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"buf2 %02x %02x %02x %02x %02x\n"
argument_list|,
name|buf2
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|buf2
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|buf2
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|buf2
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|buf2
index|[
literal|4
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1: found bad parity, i=%d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 		         * Parity is bad. Keep track of which columns were bad. 		         */
if|if
condition|(
name|bbufs
condition|)
name|bbufs
index|[
name|nbad
index|]
operator|=
name|i
expr_stmt|;
name|nbad
operator|++
expr_stmt|;
name|ret
operator|=
name|RF_PARITY_BAD
expr_stmt|;
block|}
name|buf1
operator|+=
name|nbytes
expr_stmt|;
name|buf2
operator|+=
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ret
operator|!=
name|RF_PARITY_OKAY
operator|)
operator|&&
name|correct_it
condition|)
block|{
name|ret
operator|=
name|RF_PARITY_COULD_NOT_CORRECT
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 parity verify: parity not correct\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bbufs
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	         * Make a DAG with one write node for each bad unit. We'll simply 	         * write the contents of the data unit onto the parity unit for 	         * correction. (It's possible that the mirror copy was the correct 	         * copy, and that we're spooging good data by writing bad over it, 	         * but there's no way we can know that. 	         */
name|wr_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
name|nbad
argument_list|,
name|nbytes
argument_list|,
name|buf
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
literal|"Wnp"
argument_list|,
name|allocList
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_dag_h
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|wrBlock
operator|=
name|wr_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	         * Fill in a write node for each bad compare. 	         */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbad
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
operator|+
name|layoutPtr
operator|->
name|numDataCol
expr_stmt|;
name|pda
operator|=
name|blockNode
operator|->
name|succedents
index|[
name|j
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|pda
operator|->
name|bufPtr
operator|=
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|wr_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Parity verify write dag:\n"
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* fire off the write DAG */
name|rf_DispatchDAG
argument_list|(
name|wr_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mcpair
operator|->
name|flag
condition|)
block|{
name|RF_WAIT_COND
argument_list|(
name|mcpair
operator|->
name|cond
argument_list|,
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to correct RAID1 parity in VerifyParity\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ret
operator|=
name|RF_PARITY_CORRECTED
expr_stmt|;
block|}
name|done
label|:
comment|/*          * All done. We might've gotten here without doing part of the function,          * so cleanup what we have to and return our running status.          */
if|if
condition|(
name|asm_h
condition|)
name|rf_FreeAccessStripeMap
argument_list|(
name|asm_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd_dag_h
condition|)
name|rf_FreeDAG
argument_list|(
name|rd_dag_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_dag_h
condition|)
name|rf_FreeDAG
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcpair
condition|)
name|rf_FreeMCPair
argument_list|(
name|mcpair
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 parity verify, returning %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_SubmitReconBufferRAID1
parameter_list|(
name|rbuf
parameter_list|,
name|keep_it
parameter_list|,
name|use_committed
parameter_list|)
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
comment|/* the recon buffer to submit */
name|int
name|keep_it
decl_stmt|;
comment|/* whether we can keep this buffer or we have 				 * to return it */
name|int
name|use_committed
decl_stmt|;
comment|/* whether to use a committed or an available 				 * recon buffer */
block|{
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|int
name|retcode
decl_stmt|,
name|created
decl_stmt|;
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|t
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|caddr_t
name|ta
decl_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|created
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|=
name|rbuf
operator|->
name|raidPtr
expr_stmt|;
name|layoutPtr
operator|=
operator|&
name|raidPtr
operator|->
name|Layout
expr_stmt|;
name|reconCtrlPtr
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|rbuf
operator|->
name|row
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rbuf
operator|->
name|col
operator|!=
name|reconCtrlPtr
operator|->
name|fcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_reconbufferDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 reconbuffer submission r%d c%d psid %ld ru%d (failed offset %ld)\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_reconDebug
condition|)
block|{
name|printf
argument_list|(
literal|"RAID1 reconbuffer submit psid %ld buf %lx\n"
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RAID1 psid %ld   %02x %02x %02x %02x %02x\n"
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|0
index|]
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|1
index|]
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|2
index|]
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|3
index|]
argument_list|,
name|rbuf
operator|->
name|buffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|pssPtr
operator|=
name|rf_LookupRUStatus
argument_list|(
name|raidPtr
argument_list|,
name|reconCtrlPtr
operator|->
name|pssTable
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
name|RF_PSS_NONE
argument_list|,
operator|&
name|created
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pssPtr
argument_list|)
expr_stmt|;
comment|/* if it didn't exist, we wouldn't have gotten 				 * an rbuf for it */
comment|/*          * Since this is simple mirroring, the first submission for a stripe is also          * treated as the last.          */
name|t
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|keep_it
condition|)
block|{
if|if
condition|(
name|rf_reconbufferDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 rbuf submission: keeping rbuf\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|rbuf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|use_committed
condition|)
block|{
if|if
condition|(
name|rf_reconbufferDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 rbuf submission: using committed rbuf\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|reconCtrlPtr
operator|->
name|committedRbufs
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|reconCtrlPtr
operator|->
name|committedRbufs
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reconCtrlPtr
operator|->
name|floatingRbufs
condition|)
block|{
if|if
condition|(
name|rf_reconbufferDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 rbuf submission: using floating rbuf\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|reconCtrlPtr
operator|->
name|floatingRbufs
expr_stmt|;
name|reconCtrlPtr
operator|->
name|floatingRbufs
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rf_reconbufferDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 rbuf submission: waiting for rbuf\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
operator|(
name|keep_it
operator|==
literal|0
operator|)
operator|&&
operator|(
name|use_committed
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|procsInBufWait
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|procsInBufWait
operator|==
operator|(
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|raidPtr
operator|->
name|numFullReconBuffers
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* ruh-ro */
name|RF_ERRORMSG
argument_list|(
literal|"Buffer wait deadlock\n"
argument_list|)
expr_stmt|;
name|rf_PrintPSStatusTable
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|pssPtr
operator|->
name|flags
operator||=
name|RF_PSS_BUFFERWAIT
expr_stmt|;
name|cb
operator|=
name|rf_AllocCallbackDesc
argument_list|()
expr_stmt|;
name|cb
operator|->
name|row
operator|=
name|rbuf
operator|->
name|row
expr_stmt|;
name|cb
operator|->
name|col
operator|=
name|rbuf
operator|->
name|col
expr_stmt|;
name|cb
operator|->
name|callbackArg
operator|.
name|v
operator|=
name|rbuf
operator|->
name|parityStripeID
expr_stmt|;
name|cb
operator|->
name|callbackArg2
operator|.
name|v
operator|=
name|rbuf
operator|->
name|which_ru
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|reconCtrlPtr
operator|->
name|bufferWaitList
operator|==
name|NULL
condition|)
block|{
comment|/* we are the wait list- lucky us */
name|reconCtrlPtr
operator|->
name|bufferWaitList
operator|=
name|cb
expr_stmt|;
block|}
else|else
block|{
comment|/* append to wait list */
for|for
control|(
name|p
operator|=
name|reconCtrlPtr
operator|->
name|bufferWaitList
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|cb
expr_stmt|;
block|}
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|!=
name|rbuf
condition|)
block|{
name|t
operator|->
name|row
operator|=
name|rbuf
operator|->
name|row
expr_stmt|;
name|t
operator|->
name|col
operator|=
name|reconCtrlPtr
operator|->
name|fcol
expr_stmt|;
name|t
operator|->
name|parityStripeID
operator|=
name|rbuf
operator|->
name|parityStripeID
expr_stmt|;
name|t
operator|->
name|which_ru
operator|=
name|rbuf
operator|->
name|which_ru
expr_stmt|;
name|t
operator|->
name|failedDiskSectorOffset
operator|=
name|rbuf
operator|->
name|failedDiskSectorOffset
expr_stmt|;
name|t
operator|->
name|spRow
operator|=
name|rbuf
operator|->
name|spRow
expr_stmt|;
name|t
operator|->
name|spCol
operator|=
name|rbuf
operator|->
name|spCol
expr_stmt|;
name|t
operator|->
name|spOffset
operator|=
name|rbuf
operator|->
name|spOffset
expr_stmt|;
comment|/* Swap buffers. DANCE! */
name|ta
operator|=
name|t
operator|->
name|buffer
expr_stmt|;
name|t
operator|->
name|buffer
operator|=
name|rbuf
operator|->
name|buffer
expr_stmt|;
name|rbuf
operator|->
name|buffer
operator|=
name|ta
expr_stmt|;
block|}
comment|/*          * Use the rbuf we've been given as the target.          */
name|RF_ASSERT
argument_list|(
name|pssPtr
operator|->
name|rbuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pssPtr
operator|->
name|rbuf
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|count
operator|=
literal|1
expr_stmt|;
comment|/*          * Below, we use 1 for numDataCol (which is equal to the count in the          * previous line), so we'll always be done.          */
name|rf_CheckForFullRbuf
argument_list|(
name|raidPtr
argument_list|,
name|reconCtrlPtr
argument_list|,
name|pssPtr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_reconbufferDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: RAID1 rbuf submission: returning %d\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

end_unit

