begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_dagutils.c,v 1.6 1999/12/09 02:26:09 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Mark Holland, William V. Courtright II, Jim Zelenka  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/******************************************************************************  *  * rf_dagutils.c -- utility routines for manipulating dags  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_freelist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_define
define|#
directive|define
name|SNUM_DIFF
parameter_list|(
name|_a_
parameter_list|,
name|_b_
parameter_list|)
value|(((_a_)>(_b_))?((_a_)-(_b_)):((_b_)-(_a_)))
end_define

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_xorFuncs
init|=
block|{
name|rf_RegularXorFunc
block|,
literal|"Reg Xr"
block|,
name|rf_SimpleXorFunc
block|,
literal|"Simple Xr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_xorRecoveryFuncs
init|=
block|{
name|rf_RecoveryXorFunc
block|,
literal|"Recovery Xr"
block|,
name|rf_RecoveryXorFunc
block|,
literal|"Recovery Xr"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rf_RecurPrintDAG
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_PrintDAG
parameter_list|(
name|RF_DagHeader_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_ValidateBranch
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|RF_DagNode_t
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_ValidateBranchVisitedBits
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_ValidateVisitedBits
parameter_list|(
name|RF_DagHeader_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************  *  * InitNode - initialize a dag node  *  * the size of the propList array is always the same as that of the  * successors array.  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_InitNode
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|RF_NodeStatus_t
name|initstatus
parameter_list|,
name|int
name|commit
parameter_list|,
name|int
function_decl|(
modifier|*
name|doFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|undoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|wakeFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|int
name|status
parameter_list|)
parameter_list|,
name|int
name|nSucc
parameter_list|,
name|int
name|nAnte
parameter_list|,
name|int
name|nParam
parameter_list|,
name|int
name|nResult
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|hdr
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|alist
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|ptrs
decl_stmt|;
name|int
name|nptrs
decl_stmt|;
if|if
condition|(
name|nAnte
operator|>
name|RF_MAX_ANTECEDENTS
condition|)
name|RF_PANIC
argument_list|()
expr_stmt|;
name|node
operator|->
name|status
operator|=
name|initstatus
expr_stmt|;
name|node
operator|->
name|commitNode
operator|=
name|commit
expr_stmt|;
name|node
operator|->
name|doFunc
operator|=
name|doFunc
expr_stmt|;
name|node
operator|->
name|undoFunc
operator|=
name|undoFunc
expr_stmt|;
name|node
operator|->
name|wakeFunc
operator|=
name|wakeFunc
expr_stmt|;
name|node
operator|->
name|numParams
operator|=
name|nParam
expr_stmt|;
name|node
operator|->
name|numResults
operator|=
name|nResult
expr_stmt|;
name|node
operator|->
name|numAntecedents
operator|=
name|nAnte
expr_stmt|;
name|node
operator|->
name|numAntDone
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|numSuccedents
operator|=
name|nSucc
expr_stmt|;
name|node
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|dagHdr
operator|=
name|hdr
expr_stmt|;
name|node
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
comment|/* allocate all the pointers with one call to malloc */
name|nptrs
operator|=
name|nSucc
operator|+
name|nAnte
operator|+
name|nResult
operator|+
name|nSucc
expr_stmt|;
if|if
condition|(
name|nptrs
operator|<=
name|RF_DAG_PTRCACHESIZE
condition|)
block|{
comment|/* 	         * The dag_ptrs field of the node is basically some scribble 	         * space to be used here. We could get rid of it, and always 	         * allocate the range of pointers, but that's expensive. So, 	         * we pick a "common case" size for the pointer cache. Hopefully, 	         * we'll find that: 	         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by 	         *     only a little bit (least efficient case) 	         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE 	         *     (wasted memory) 	         */
name|ptrs
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|node
operator|->
name|dag_ptrs
expr_stmt|;
block|}
else|else
block|{
name|RF_CallocAndAdd
argument_list|(
name|ptrs
argument_list|,
name|nptrs
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
argument_list|,
name|alist
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|succedents
operator|=
operator|(
name|nSucc
operator|)
condition|?
operator|(
name|RF_DagNode_t
operator|*
operator|*
operator|)
name|ptrs
else|:
name|NULL
expr_stmt|;
name|node
operator|->
name|antecedents
operator|=
operator|(
name|nAnte
operator|)
condition|?
operator|(
name|RF_DagNode_t
operator|*
operator|*
operator|)
operator|(
name|ptrs
operator|+
name|nSucc
operator|)
else|:
name|NULL
expr_stmt|;
name|node
operator|->
name|results
operator|=
operator|(
name|nResult
operator|)
condition|?
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
name|ptrs
operator|+
name|nSucc
operator|+
name|nAnte
operator|)
else|:
name|NULL
expr_stmt|;
name|node
operator|->
name|propList
operator|=
operator|(
name|nSucc
operator|)
condition|?
operator|(
name|RF_PropHeader_t
operator|*
operator|*
operator|)
operator|(
name|ptrs
operator|+
name|nSucc
operator|+
name|nAnte
operator|+
name|nResult
operator|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|nParam
condition|)
block|{
if|if
condition|(
name|nParam
operator|<=
name|RF_DAG_PARAMCACHESIZE
condition|)
block|{
name|node
operator|->
name|params
operator|=
operator|(
name|RF_DagParam_t
operator|*
operator|)
name|node
operator|->
name|dag_params
expr_stmt|;
block|}
else|else
block|{
name|RF_CallocAndAdd
argument_list|(
name|node
operator|->
name|params
argument_list|,
name|nParam
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagParam_t
argument_list|)
argument_list|,
operator|(
name|RF_DagParam_t
operator|*
operator|)
argument_list|,
name|alist
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|node
operator|->
name|params
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * allocation and deallocation routines  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_FreeDAG
parameter_list|(
name|dag_h
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
block|{
name|RF_AccessStripeMapHeader_t
modifier|*
name|asmap
decl_stmt|,
modifier|*
name|t_asmap
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|nextDag
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|dag_h
condition|)
block|{
name|nextDag
operator|=
name|dag_h
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dag_h
operator|->
name|memChunk
index|[
name|i
index|]
operator|&&
name|i
operator|<
name|RF_MAXCHUNKS
condition|;
name|i
operator|++
control|)
block|{
comment|/* release mem chunks */
name|rf_ReleaseMemChunk
argument_list|(
name|dag_h
operator|->
name|memChunk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|memChunk
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|dag_h
operator|->
name|chunkIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_h
operator|->
name|xtraChunkCnt
operator|>
literal|0
condition|)
block|{
comment|/* free xtraMemChunks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dag_h
operator|->
name|xtraMemChunk
index|[
name|i
index|]
operator|&&
name|i
operator|<
name|dag_h
operator|->
name|xtraChunkIndex
condition|;
name|i
operator|++
control|)
block|{
name|rf_ReleaseMemChunk
argument_list|(
name|dag_h
operator|->
name|xtraMemChunk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|xtraMemChunk
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|dag_h
operator|->
name|xtraChunkIndex
argument_list|)
expr_stmt|;
comment|/* free ptrs to xtraMemChunks */
name|RF_Free
argument_list|(
name|dag_h
operator|->
name|xtraMemChunk
argument_list|,
name|dag_h
operator|->
name|xtraChunkCnt
operator|*
sizeof|sizeof
argument_list|(
name|RF_ChunkDesc_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rf_FreeAllocList
argument_list|(
name|dag_h
operator|->
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|asmap
operator|=
name|dag_h
operator|->
name|asmList
init|;
name|asmap
condition|;
control|)
block|{
name|t_asmap
operator|=
name|asmap
expr_stmt|;
name|asmap
operator|=
name|asmap
operator|->
name|next
expr_stmt|;
name|rf_FreeAccessStripeMap
argument_list|(
name|t_asmap
argument_list|)
expr_stmt|;
block|}
name|rf_FreeDAGHeader
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
name|dag_h
operator|=
name|nextDag
expr_stmt|;
block|}
block|}
end_function

begin_function
name|RF_PropHeader_t
modifier|*
name|rf_MakePropListEntry
parameter_list|(
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|int
name|resultNum
parameter_list|,
name|int
name|paramNum
parameter_list|,
name|RF_PropHeader_t
modifier|*
name|next
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_PropHeader_t
modifier|*
name|p
decl_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PropHeader_t
argument_list|)
argument_list|,
operator|(
name|RF_PropHeader_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|p
operator|->
name|resultNum
operator|=
name|resultNum
expr_stmt|;
name|p
operator|->
name|paramNum
operator|=
name|paramNum
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|next
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_dagh_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_DAGH
value|128
end_define

begin_define
define|#
directive|define
name|RF_DAGH_INC
value|16
end_define

begin_define
define|#
directive|define
name|RF_DAGH_INITIAL
value|32
end_define

begin_function_decl
specifier|static
name|void
name|rf_ShutdownDAGs
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownDAGs
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_dagh_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_DagHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureDAGs
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_dagh_freelist
argument_list|,
name|RF_MAX_FREE_DAGH
argument_list|,
name|RF_DAGH_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagHeader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_dagh_freelist
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownDAGs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownDAGs
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|RF_FREELIST_PRIME
argument_list|(
name|rf_dagh_freelist
argument_list|,
name|RF_DAGH_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_DagHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_DagHeader_t
modifier|*
name|rf_AllocDAGHeader
parameter_list|()
block|{
name|RF_DagHeader_t
modifier|*
name|dh
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_dagh_freelist
argument_list|,
name|dh
argument_list|,
name|next
argument_list|,
operator|(
name|RF_DagHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dh
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagHeader_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeDAGHeader
parameter_list|(
name|RF_DagHeader_t
modifier|*
name|dh
parameter_list|)
block|{
name|RF_FREELIST_FREE
argument_list|(
name|rf_dagh_freelist
argument_list|,
name|dh
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* allocates a buffer big enough to hold the data described by pda */
end_comment

begin_function
name|void
modifier|*
name|rf_AllocBuffer
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|pda
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|p
argument_list|,
name|pda
operator|->
name|numSector
operator|<<
name|raidPtr
operator|->
name|logBytesPerSector
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * debug routines  *  *****************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|rf_NodeStatusString
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|status
condition|)
block|{
case|case
name|rf_wait
case|:
return|return
operator|(
literal|"wait"
operator|)
return|;
case|case
name|rf_fired
case|:
return|return
operator|(
literal|"fired"
operator|)
return|;
case|case
name|rf_good
case|:
return|return
operator|(
literal|"good"
operator|)
return|;
case|case
name|rf_bad
case|:
return|return
operator|(
literal|"bad"
operator|)
return|;
default|default:
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|rf_PrintNodeInfoString
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
function_decl|(
modifier|*
name|df
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
init|=
name|node
operator|->
name|doFunc
function_decl|;
name|int
name|i
decl_stmt|,
name|lk
decl_stmt|,
name|unlk
decl_stmt|;
name|void
modifier|*
name|bufPtr
decl_stmt|;
if|if
condition|(
operator|(
name|df
operator|==
name|rf_DiskReadFunc
operator|)
operator|||
operator|(
name|df
operator|==
name|rf_DiskWriteFunc
operator|)
operator|||
operator|(
name|df
operator|==
name|rf_DiskReadMirrorIdleFunc
operator|)
operator|||
operator|(
name|df
operator|==
name|rf_DiskReadMirrorPartitionFunc
operator|)
condition|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|bufPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|lk
operator|=
name|RF_EXTRACT_LOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|unlk
operator|=
name|RF_EXTRACT_UNLOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
operator|(
name|lk
operator|&&
name|unlk
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r %d c %d offs %ld nsect %d buf 0x%lx %s\n"
argument_list|,
name|pda
operator|->
name|row
argument_list|,
name|pda
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|pda
operator|->
name|startSector
argument_list|,
operator|(
name|int
operator|)
name|pda
operator|->
name|numSector
argument_list|,
operator|(
name|long
operator|)
name|bufPtr
argument_list|,
operator|(
name|lk
operator|)
condition|?
literal|"LOCK"
else|:
operator|(
operator|(
name|unlk
operator|)
condition|?
literal|"UNLK"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|df
operator|==
name|rf_DiskUnlockFunc
condition|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|lk
operator|=
name|RF_EXTRACT_LOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|unlk
operator|=
name|RF_EXTRACT_UNLOCK_FLAG
argument_list|(
name|node
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|!
operator|(
name|lk
operator|&&
name|unlk
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r %d c %d %s\n"
argument_list|,
name|pda
operator|->
name|row
argument_list|,
name|pda
operator|->
name|col
argument_list|,
operator|(
name|lk
operator|)
condition|?
literal|"LOCK"
else|:
operator|(
operator|(
name|unlk
operator|)
condition|?
literal|"UNLK"
else|:
literal|"nop"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|df
operator|==
name|rf_SimpleXorFunc
operator|)
operator|||
operator|(
name|df
operator|==
name|rf_RegularXorFunc
operator|)
operator|||
operator|(
name|df
operator|==
name|rf_RecoveryXorFunc
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"result buf 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|bufPtr
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"    buf 0x%lx r%d c%d offs %ld nsect %d\n"
argument_list|,
operator|(
name|long
operator|)
name|bufPtr
argument_list|,
name|pda
operator|->
name|row
argument_list|,
name|pda
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|pda
operator|->
name|startSector
argument_list|,
operator|(
name|int
operator|)
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
if|if
condition|(
name|df
operator|==
name|rf_ParityLogOverwriteFunc
operator|||
name|df
operator|==
name|rf_ParityLogUpdateFunc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|bufPtr
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|printf
argument_list|(
literal|" r%d c%d offs %ld nsect %d buf 0x%lx\n"
argument_list|,
name|pda
operator|->
name|row
argument_list|,
name|pda
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|pda
operator|->
name|startSector
argument_list|,
operator|(
name|int
operator|)
name|pda
operator|->
name|numSector
argument_list|,
operator|(
name|long
operator|)
name|bufPtr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
if|if
condition|(
operator|(
name|df
operator|==
name|rf_TerminateFunc
operator|)
operator|||
operator|(
name|df
operator|==
name|rf_NullNodeFunc
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_RecurPrintDAG
parameter_list|(
name|node
parameter_list|,
name|depth
parameter_list|,
name|unvisited
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|unvisited
decl_stmt|;
block|{
name|char
modifier|*
name|anttype
decl_stmt|;
name|int
name|i
decl_stmt|;
name|node
operator|->
name|visited
operator|=
operator|(
name|unvisited
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"(%d) %d C%d %s: %s,s%d %d/%d,a%d/%d,p%d,r%d S{"
argument_list|,
name|depth
argument_list|,
name|node
operator|->
name|nodeNum
argument_list|,
name|node
operator|->
name|commitNode
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|rf_NodeStatusString
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|numSuccedents
argument_list|,
name|node
operator|->
name|numSuccFired
argument_list|,
name|node
operator|->
name|numSuccDone
argument_list|,
name|node
operator|->
name|numAntecedents
argument_list|,
name|node
operator|->
name|numAntDone
argument_list|,
name|node
operator|->
name|numParams
argument_list|,
name|node
operator|->
name|numResults
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d%s"
argument_list|,
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|nodeNum
argument_list|,
operator|(
operator|(
name|i
operator|==
name|node
operator|->
name|numSuccedents
operator|-
literal|1
operator|)
condition|?
literal|"\0"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"} A{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numAntecedents
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|node
operator|->
name|antType
index|[
name|i
index|]
condition|)
block|{
case|case
name|rf_trueData
case|:
name|anttype
operator|=
literal|"T"
expr_stmt|;
break|break;
case|case
name|rf_antiData
case|:
name|anttype
operator|=
literal|"A"
expr_stmt|;
break|break;
case|case
name|rf_outputData
case|:
name|anttype
operator|=
literal|"O"
expr_stmt|;
break|break;
case|case
name|rf_control
case|:
name|anttype
operator|=
literal|"C"
expr_stmt|;
break|break;
default|default:
name|anttype
operator|=
literal|"?"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%d(%s)%s"
argument_list|,
name|node
operator|->
name|antecedents
index|[
name|i
index|]
operator|->
name|nodeNum
argument_list|,
name|anttype
argument_list|,
operator|(
name|i
operator|==
name|node
operator|->
name|numAntecedents
operator|-
literal|1
operator|)
condition|?
literal|"\0"
else|:
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}; "
argument_list|)
expr_stmt|;
name|rf_PrintNodeInfoString
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|visited
operator|==
name|unvisited
condition|)
name|rf_RecurPrintDAG
argument_list|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|unvisited
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rf_PrintDAG
parameter_list|(
name|dag_h
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
block|{
name|int
name|unvisited
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|status
decl_stmt|;
comment|/* set dag status */
switch|switch
condition|(
name|dag_h
operator|->
name|status
condition|)
block|{
case|case
name|rf_enable
case|:
name|status
operator|=
literal|"enable"
expr_stmt|;
break|break;
case|case
name|rf_rollForward
case|:
name|status
operator|=
literal|"rollForward"
expr_stmt|;
break|break;
case|case
name|rf_rollBackward
case|:
name|status
operator|=
literal|"rollBackward"
expr_stmt|;
break|break;
default|default:
name|status
operator|=
literal|"illegal!"
expr_stmt|;
break|break;
block|}
comment|/* find out if visited bits are currently set or clear */
name|unvisited
operator|=
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|visited
expr_stmt|;
name|printf
argument_list|(
literal|"DAG type:  %s\n"
argument_list|,
name|dag_h
operator|->
name|creator
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"format is (depth) num commit type: status,nSucc nSuccFired/nSuccDone,nAnte/nAnteDone,nParam,nResult S{x} A{x(type)};  info\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(0) %d Hdr: %s, s%d, (commit %d/%d) S{"
argument_list|,
name|dag_h
operator|->
name|nodeNum
argument_list|,
name|status
argument_list|,
name|dag_h
operator|->
name|numSuccedents
argument_list|,
name|dag_h
operator|->
name|numCommitNodes
argument_list|,
name|dag_h
operator|->
name|numCommits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dag_h
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d%s"
argument_list|,
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|nodeNum
argument_list|,
operator|(
operator|(
name|i
operator|==
name|dag_h
operator|->
name|numSuccedents
operator|-
literal|1
operator|)
condition|?
literal|"\0"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dag_h
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|visited
operator|==
name|unvisited
condition|)
name|rf_RecurPrintDAG
argument_list|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|unvisited
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* assigns node numbers */
end_comment

begin_function
name|int
name|rf_AssignNodeNums
parameter_list|(
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|)
block|{
name|int
name|unvisited
decl_stmt|,
name|i
decl_stmt|,
name|nnum
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|nnum
operator|=
literal|0
expr_stmt|;
name|unvisited
operator|=
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|visited
expr_stmt|;
name|dag_h
operator|->
name|nodeNum
operator|=
name|nnum
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dag_h
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|visited
operator|==
name|unvisited
condition|)
block|{
name|nnum
operator|=
name|rf_RecurAssignNodeNums
argument_list|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|nnum
argument_list|,
name|unvisited
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nnum
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_RecurAssignNodeNums
parameter_list|(
name|node
parameter_list|,
name|num
parameter_list|,
name|unvisited
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|unvisited
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|node
operator|->
name|visited
operator|=
operator|(
name|unvisited
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|node
operator|->
name|nodeNum
operator|=
name|num
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|visited
operator|==
name|unvisited
condition|)
block|{
name|num
operator|=
name|rf_RecurAssignNodeNums
argument_list|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|num
argument_list|,
name|unvisited
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_comment
comment|/* set the header pointers in each node to "newptr" */
end_comment

begin_function
name|void
name|rf_ResetDAGHeaderPointers
parameter_list|(
name|dag_h
parameter_list|,
name|newptr
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|newptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dag_h
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|dagHdr
operator|!=
name|newptr
condition|)
name|rf_RecurResetDAGHeaderPointers
argument_list|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|newptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_RecurResetDAGHeaderPointers
parameter_list|(
name|node
parameter_list|,
name|newptr
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|newptr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|node
operator|->
name|dagHdr
operator|=
name|newptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|dagHdr
operator|!=
name|newptr
condition|)
name|rf_RecurResetDAGHeaderPointers
argument_list|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|newptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_PrintDAGList
parameter_list|(
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|dag_h
condition|;
name|dag_h
operator|=
name|dag_h
operator|->
name|next
control|)
block|{
name|rf_AssignNodeNums
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nDAG %d IN LIST:\n"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|rf_PrintDAG
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rf_ValidateBranch
parameter_list|(
name|node
parameter_list|,
name|scount
parameter_list|,
name|acount
parameter_list|,
name|nodes
parameter_list|,
name|unvisited
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|int
modifier|*
name|scount
decl_stmt|;
name|int
modifier|*
name|acount
decl_stmt|;
name|RF_DagNode_t
modifier|*
modifier|*
name|nodes
decl_stmt|;
name|int
name|unvisited
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* construct an array of node pointers indexed by node num */
name|node
operator|->
name|visited
operator|=
operator|(
name|unvisited
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|nodes
index|[
name|node
operator|->
name|nodeNum
index|]
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: next pointer in node is not NULL\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|status
operator|!=
name|rf_wait
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: Node status is not wait\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|numAntDone
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: numAntDone is not zero\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|doFunc
operator|==
name|rf_TerminateFunc
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|numSuccedents
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: Terminator node has succedents\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|node
operator|->
name|numSuccedents
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: Non-terminator node has no succedents\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|succedents
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: succedent %d of node %s is NULL\n"
argument_list|,
name|i
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
name|scount
index|[
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|nodeNum
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numAntecedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|antecedents
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: antecedent %d of node %s is NULL\n"
argument_list|,
name|i
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
name|acount
index|[
name|node
operator|->
name|antecedents
index|[
name|i
index|]
operator|->
name|nodeNum
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|visited
operator|==
name|unvisited
condition|)
block|{
if|if
condition|(
name|rf_ValidateBranch
argument_list|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|scount
argument_list|,
name|acount
argument_list|,
name|nodes
argument_list|,
name|unvisited
argument_list|)
condition|)
block|{
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_ValidateBranchVisitedBits
parameter_list|(
name|node
parameter_list|,
name|unvisited
parameter_list|,
name|rl
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|int
name|unvisited
decl_stmt|;
name|int
name|rl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|visited
operator|==
name|unvisited
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"node=%lx node->succedents[%d] is NULL\n"
argument_list|,
operator|(
name|long
operator|)
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rf_ValidateBranchVisitedBits
argument_list|(
name|node
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|unvisited
argument_list|,
name|rl
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* NOTE:  never call this on a big dag, because it is exponential  * in execution time  */
end_comment

begin_function
specifier|static
name|void
name|rf_ValidateVisitedBits
parameter_list|(
name|dag
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|dag
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|unvisited
decl_stmt|;
name|unvisited
operator|=
name|dag
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|visited
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dag
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dag
operator|->
name|succedents
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dag=%lx dag->succedents[%d] is NULL\n"
argument_list|,
operator|(
name|long
operator|)
name|dag
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rf_ValidateBranchVisitedBits
argument_list|(
name|dag
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|unvisited
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* validate a DAG.  _at entry_ verify that:  *   -- numNodesCompleted is zero  *   -- node queue is null  *   -- dag status is rf_enable  *   -- next pointer is null on every node  *   -- all nodes have status wait  *   -- numAntDone is zero in all nodes  *   -- terminator node has zero successors  *   -- no other node besides terminator has zero successors  *   -- no successor or antecedent pointer in a node is NULL  *   -- number of times that each node appears as a successor of another node  *      is equal to the antecedent count on that node  *   -- number of times that each node appears as an antecedent of another node  *      is equal to the succedent count on that node  *   -- what else?  */
end_comment

begin_function
name|int
name|rf_ValidateDAG
parameter_list|(
name|dag_h
parameter_list|)
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nodecount
decl_stmt|;
name|int
modifier|*
name|scount
decl_stmt|,
modifier|*
name|acount
decl_stmt|;
comment|/* per-node successor and antecedent counts */
name|RF_DagNode_t
modifier|*
modifier|*
name|nodes
decl_stmt|;
comment|/* array of ptrs to nodes in dag */
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|unvisited
decl_stmt|;
name|int
name|commitNodeCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rf_validateVisitedDebug
condition|)
name|rf_ValidateVisitedBits
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|dag_h
operator|->
name|numNodesCompleted
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: num nodes completed is %d, should be 0\n"
argument_list|,
name|dag_h
operator|->
name|numNodesCompleted
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_bad
goto|;
block|}
if|if
condition|(
name|dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: not enabled\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_bad
goto|;
block|}
if|if
condition|(
name|dag_h
operator|->
name|numCommits
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: numCommits != 0 (%d)\n"
argument_list|,
name|dag_h
operator|->
name|numCommits
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_bad
goto|;
block|}
if|if
condition|(
name|dag_h
operator|->
name|numSuccedents
operator|!=
literal|1
condition|)
block|{
comment|/* currently, all dags must have only one succedent */
name|printf
argument_list|(
literal|"INVALID DAG: numSuccedents !1 (%d)\n"
argument_list|,
name|dag_h
operator|->
name|numSuccedents
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_bad
goto|;
block|}
name|nodecount
operator|=
name|rf_AssignNodeNums
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
name|unvisited
operator|=
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|visited
expr_stmt|;
name|RF_Calloc
argument_list|(
name|scount
argument_list|,
name|nodecount
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Calloc
argument_list|(
name|acount
argument_list|,
name|nodecount
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_Calloc
argument_list|(
name|nodes
argument_list|,
name|nodecount
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dag_h
operator|->
name|numSuccedents
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|visited
operator|==
name|unvisited
operator|)
operator|&&
name|rf_ValidateBranch
argument_list|(
name|dag_h
operator|->
name|succedents
index|[
name|i
index|]
argument_list|,
name|scount
argument_list|,
name|acount
argument_list|,
name|nodes
argument_list|,
name|unvisited
argument_list|)
condition|)
block|{
name|retcode
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* start at 1 to skip the header node */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nodecount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|commitNode
condition|)
name|commitNodeCount
operator|++
expr_stmt|;
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|doFunc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: node %s has an undefined doFunc\n"
argument_list|,
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_out
goto|;
block|}
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|undoFunc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: node %s has an undefined doFunc\n"
argument_list|,
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_out
goto|;
block|}
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|numAntecedents
operator|!=
name|scount
index|[
name|nodes
index|[
name|i
index|]
operator|->
name|nodeNum
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: node %s has %d antecedents but appears as a succedent %d times\n"
argument_list|,
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|nodes
index|[
name|i
index|]
operator|->
name|numAntecedents
argument_list|,
name|scount
index|[
name|nodes
index|[
name|i
index|]
operator|->
name|nodeNum
index|]
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_out
goto|;
block|}
if|if
condition|(
name|nodes
index|[
name|i
index|]
operator|->
name|numSuccedents
operator|!=
name|acount
index|[
name|nodes
index|[
name|i
index|]
operator|->
name|nodeNum
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: node %s has %d succedents but appears as an antecedent %d times\n"
argument_list|,
name|nodes
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|nodes
index|[
name|i
index|]
operator|->
name|numSuccedents
argument_list|,
name|acount
index|[
name|nodes
index|[
name|i
index|]
operator|->
name|nodeNum
index|]
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_out
goto|;
block|}
block|}
if|if
condition|(
name|dag_h
operator|->
name|numCommitNodes
operator|!=
name|commitNodeCount
condition|)
block|{
name|printf
argument_list|(
literal|"INVALID DAG: incorrect commit node count.  hdr->numCommitNodes (%d) found (%d) commit nodes in graph\n"
argument_list|,
name|dag_h
operator|->
name|numCommitNodes
argument_list|,
name|commitNodeCount
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|validate_dag_out
goto|;
block|}
name|validate_dag_out
label|:
name|RF_Free
argument_list|(
name|scount
argument_list|,
name|nodecount
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|acount
argument_list|,
name|nodecount
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|nodes
argument_list|,
name|nodecount
operator|*
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
name|rf_PrintDAGList
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_validateVisitedDebug
condition|)
name|rf_ValidateVisitedBits
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
name|validate_dag_bad
label|:
name|rf_PrintDAGList
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * misc construction routines  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_redirect_asm
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|)
block|{
name|int
name|ds
init|=
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|row
init|=
name|asmap
operator|->
name|physInfo
operator|->
name|row
decl_stmt|;
name|int
name|fcol
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|fcol
decl_stmt|;
name|int
name|srow
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|spareRow
decl_stmt|;
name|int
name|scol
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|spareCol
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|==
name|rf_rs_reconstructing
argument_list|)
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pda
operator|->
name|col
operator|==
name|fcol
condition|)
block|{
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
if|if
condition|(
operator|!
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
condition|)
block|{
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* printf("Remapped data for large write\n"); */
if|if
condition|(
name|ds
condition|)
block|{
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|,
operator|&
name|pda
operator|->
name|row
argument_list|,
operator|&
name|pda
operator|->
name|col
argument_list|,
operator|&
name|pda
operator|->
name|startSector
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pda
operator|->
name|row
operator|=
name|srow
expr_stmt|;
name|pda
operator|->
name|col
operator|=
name|scol
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pda
operator|->
name|col
operator|==
name|fcol
condition|)
block|{
if|if
condition|(
name|rf_dagDebug
condition|)
block|{
if|if
condition|(
operator|!
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|reconMap
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
condition|)
block|{
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ds
condition|)
block|{
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|,
operator|&
name|pda
operator|->
name|row
argument_list|,
operator|&
name|pda
operator|->
name|col
argument_list|,
operator|&
name|pda
operator|->
name|startSector
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pda
operator|->
name|row
operator|=
name|srow
expr_stmt|;
name|pda
operator|->
name|col
operator|=
name|scol
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* this routine allocates read buffers and generates stripe maps for the  * regions of the array from the start of the stripe to the start of the  * access, and from the end of the access to the end of the stripe.  It also  * computes and returns the number of DAG nodes needed to read all this data.  * Note that this routine does the wrong thing if the access is fully  * contained within one stripe unit, so we RF_ASSERT against this case at the  * start.  */
end_comment

begin_function
name|void
name|rf_MapUnaccessedPortionOfStripe
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
comment|/* in: layout information */
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
comment|/* in: access stripe map */
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
comment|/* in: header of the dag to create */
name|RF_AccessStripeMapHeader_t
modifier|*
modifier|*
name|new_asm_h
parameter_list|,
comment|/* in: ptr to array of 2 						 * headers, to be filled in */
name|int
modifier|*
name|nRodNodes
parameter_list|,
comment|/* out: num nodes to be generated to read 				 * unaccessed data */
name|char
modifier|*
modifier|*
name|sosBuffer
parameter_list|,
comment|/* out: pointers to newly allocated buffer */
name|char
modifier|*
modifier|*
name|eosBuffer
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_RaidAddr_t
name|sosRaidAddress
decl_stmt|,
name|eosRaidAddress
decl_stmt|;
name|RF_SectorNum_t
name|sosNumSector
decl_stmt|,
name|eosNumSector
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|>
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* generate an access map for the region of the array from start of 	 * stripe to start of access */
name|new_asm_h
index|[
literal|0
index|]
operator|=
name|new_asm_h
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|nRodNodes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rf_RaidAddressStripeAligned
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
condition|)
block|{
name|sosRaidAddress
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|sosNumSector
operator|=
name|asmap
operator|->
name|raidAddress
operator|-
name|sosRaidAddress
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
operator|*
name|sosBuffer
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|sosNumSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|new_asm_h
index|[
literal|0
index|]
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|sosRaidAddress
argument_list|,
name|sosNumSector
argument_list|,
operator|*
name|sosBuffer
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
name|dag_h
operator|->
name|asmList
operator|=
name|new_asm_h
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nRodNodes
operator|+=
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* we're totally within one stripe here */
if|if
condition|(
name|asmap
operator|->
name|flags
operator|&
name|RF_ASM_REDIR_LARGE_WRITE
condition|)
name|rf_redirect_asm
argument_list|(
name|raidPtr
argument_list|,
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
argument_list|)
expr_stmt|;
block|}
comment|/* generate an access map for the region of the array from end of 	 * access to end of stripe */
if|if
condition|(
operator|!
name|rf_RaidAddressStripeAligned
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|endRaidAddress
argument_list|)
condition|)
block|{
name|eosRaidAddress
operator|=
name|asmap
operator|->
name|endRaidAddress
expr_stmt|;
name|eosNumSector
operator|=
name|rf_RaidAddressOfNextStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|eosRaidAddress
argument_list|)
operator|-
name|eosRaidAddress
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
operator|*
name|eosBuffer
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|eosNumSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|new_asm_h
index|[
literal|1
index|]
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|eosRaidAddress
argument_list|,
name|eosNumSector
argument_list|,
operator|*
name|eosBuffer
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|next
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
name|dag_h
operator|->
name|asmList
operator|=
name|new_asm_h
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|nRodNodes
operator|+=
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* we're totally within one stripe here */
if|if
condition|(
name|asmap
operator|->
name|flags
operator|&
name|RF_ASM_REDIR_LARGE_WRITE
condition|)
name|rf_redirect_asm
argument_list|(
name|raidPtr
argument_list|,
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* returns non-zero if the indicated ranges of stripe unit offsets overlap */
end_comment

begin_function
name|int
name|rf_PDAOverlap
parameter_list|(
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|src
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|dest
parameter_list|)
block|{
name|RF_SectorNum_t
name|soffs
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|src
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|RF_SectorNum_t
name|doffs
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|startSector
argument_list|)
decl_stmt|;
comment|/* use -1 to be sure we stay within SU */
name|RF_SectorNum_t
name|send
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|src
operator|->
name|startSector
operator|+
name|src
operator|->
name|numSector
operator|-
literal|1
argument_list|)
decl_stmt|;
name|RF_SectorNum_t
name|dend
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|startSector
operator|+
name|dest
operator|->
name|numSector
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|RF_MAX
argument_list|(
name|soffs
argument_list|,
name|doffs
argument_list|)
operator|<=
name|RF_MIN
argument_list|(
name|send
argument_list|,
name|dend
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* GenerateFailedAccessASMs  *  * this routine figures out what portion of the stripe needs to be read  * to effect the degraded read or write operation.  It's primary function  * is to identify everything required to recover the data, and then  * eliminate anything that is already being accessed by the user.  *  * The main result is two new ASMs, one for the region from the start of the  * stripe to the start of the access, and one for the region from the end of  * the access to the end of the stripe.  These ASMs describe everything that  * needs to be read to effect the degraded access.  Other results are:  *    nXorBufs -- the total number of buffers that need to be XORed together to  *                recover the lost data,  *    rpBufPtr -- ptr to a newly-allocated buffer to hold the parity.  If NULL  *                at entry, not allocated.  *    overlappingPDAs --  *                describes which of the non-failed PDAs in the user access  *                overlap data that needs to be read to effect recovery.  *                overlappingPDAs[i]==1 if and only if, neglecting the failed  *                PDA, the ith pda in the input asm overlaps data that needs  *                to be read for recovery.  */
end_comment

begin_comment
comment|/* in: asm - ASM for the actual access, one stripe only */
end_comment

begin_comment
comment|/* in: faildPDA - which component of the access has failed */
end_comment

begin_comment
comment|/* in: dag_h - header of the DAG we're going to create */
end_comment

begin_comment
comment|/* out: new_asm_h - the two new ASMs */
end_comment

begin_comment
comment|/* out: nXorBufs - the total number of xor bufs required */
end_comment

begin_comment
comment|/* out: rpBufPtr - a buffer for the parity read */
end_comment

begin_function
name|void
name|rf_GenerateFailedAccessASMs
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|RF_AccessStripeMapHeader_t
modifier|*
modifier|*
name|new_asm_h
parameter_list|,
name|int
modifier|*
name|nXorBufs
parameter_list|,
name|char
modifier|*
modifier|*
name|rpBufPtr
parameter_list|,
name|char
modifier|*
name|overlappingPDAs
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
comment|/* s=start, e=end, s=stripe, a=access, f=failed, su=stripe unit */
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|,
name|sosEndAddr
decl_stmt|,
name|eosStartAddr
decl_stmt|,
name|eosAddr
decl_stmt|;
name|RF_SectorCount_t
name|numSect
index|[
literal|2
index|]
decl_stmt|,
name|numParitySect
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|char
modifier|*
name|rdBuf
decl_stmt|,
modifier|*
name|bufP
decl_stmt|;
name|int
name|foundit
decl_stmt|,
name|i
decl_stmt|;
name|bufP
operator|=
name|NULL
expr_stmt|;
name|foundit
operator|=
literal|0
expr_stmt|;
comment|/* first compute the following raid addresses: start of stripe, 	 * (sosAddr) MIN(start of access, start of failed SU),   (sosEndAddr) 	 * MAX(end of access, end of failed SU),       (eosStartAddr) end of 	 * stripe (i.e. start of next stripe)   (eosAddr) */
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|sosEndAddr
operator|=
name|RF_MIN
argument_list|(
name|asmap
operator|->
name|raidAddress
argument_list|,
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|raidAddress
argument_list|)
argument_list|)
expr_stmt|;
name|eosStartAddr
operator|=
name|RF_MAX
argument_list|(
name|asmap
operator|->
name|endRaidAddress
argument_list|,
name|rf_RaidAddressOfNextStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|raidAddress
argument_list|)
argument_list|)
expr_stmt|;
name|eosAddr
operator|=
name|rf_RaidAddressOfNextStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* now generate access stripe maps for each of the above regions of 	 * the stripe.  Use a dummy (NULL) buf ptr for now */
name|new_asm_h
index|[
literal|0
index|]
operator|=
operator|(
name|sosAddr
operator|!=
name|sosEndAddr
operator|)
condition|?
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|sosAddr
argument_list|,
name|sosEndAddr
operator|-
name|sosAddr
argument_list|,
name|NULL
argument_list|,
name|RF_DONT_REMAP
argument_list|)
else|:
name|NULL
expr_stmt|;
name|new_asm_h
index|[
literal|1
index|]
operator|=
operator|(
name|eosStartAddr
operator|!=
name|eosAddr
operator|)
condition|?
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|eosStartAddr
argument_list|,
name|eosAddr
operator|-
name|eosStartAddr
argument_list|,
name|NULL
argument_list|,
name|RF_DONT_REMAP
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* walk through the PDAs and range-restrict each SU to the region of 	 * the SU touched on the failed PDA.  also compute total data buffer 	 * space requirements in this step.  Ignore the parity for now. */
name|numSect
index|[
literal|0
index|]
operator|=
name|numSect
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_asm_h
index|[
literal|0
index|]
condition|)
block|{
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
name|dag_h
operator|->
name|asmList
operator|=
name|new_asm_h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
argument_list|,
name|pda
argument_list|,
name|RF_RESTRICT_NOBUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|numSect
index|[
literal|0
index|]
operator|+=
name|pda
operator|->
name|numSector
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_asm_h
index|[
literal|1
index|]
condition|)
block|{
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|next
operator|=
name|dag_h
operator|->
name|asmList
expr_stmt|;
name|dag_h
operator|->
name|asmList
operator|=
name|new_asm_h
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
argument_list|,
name|pda
argument_list|,
name|RF_RESTRICT_NOBUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|numSect
index|[
literal|1
index|]
operator|+=
name|pda
operator|->
name|numSector
expr_stmt|;
block|}
block|}
name|numParitySect
operator|=
name|failedPDA
operator|->
name|numSector
expr_stmt|;
comment|/* allocate buffer space for the data& parity we have to read to 	 * recover from the failure */
if|if
condition|(
name|numSect
index|[
literal|0
index|]
operator|+
name|numSect
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|rpBufPtr
operator|)
condition|?
name|numParitySect
else|:
literal|0
operator|)
condition|)
block|{
comment|/* don't allocate parity 										 * buf if not needed */
name|RF_MallocAndAdd
argument_list|(
name|rdBuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|numSect
index|[
literal|0
index|]
operator|+
name|numSect
index|[
literal|1
index|]
operator|+
name|numParitySect
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|bufP
operator|=
name|rdBuf
expr_stmt|;
if|if
condition|(
name|rf_degDagDebug
condition|)
name|printf
argument_list|(
literal|"Newly allocated buffer (%d bytes) is 0x%lx\n"
argument_list|,
operator|(
name|int
operator|)
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|numSect
index|[
literal|0
index|]
operator|+
name|numSect
index|[
literal|1
index|]
operator|+
name|numParitySect
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bufP
argument_list|)
expr_stmt|;
block|}
comment|/* now walk through the pdas one last time and assign buffer pointers 	 * (ugh!).  Again, ignore the parity.  also, count nodes to find out 	 * how many bufs need to be xored together */
operator|(
operator|*
name|nXorBufs
operator|)
operator|=
literal|1
expr_stmt|;
comment|/* in read case, 1 is for parity.  In write 				 * case, 1 is for failed data */
if|if
condition|(
name|new_asm_h
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|pda
operator|=
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|pda
operator|->
name|bufPtr
operator|=
name|bufP
expr_stmt|;
name|bufP
operator|+=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
operator|*
name|nXorBufs
operator|+=
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
block|}
if|if
condition|(
name|new_asm_h
index|[
literal|1
index|]
condition|)
block|{
for|for
control|(
name|pda
operator|=
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|pda
operator|->
name|bufPtr
operator|=
name|bufP
expr_stmt|;
name|bufP
operator|+=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|nXorBufs
operator|)
operator|+=
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
block|}
if|if
condition|(
name|rpBufPtr
condition|)
operator|*
name|rpBufPtr
operator|=
name|bufP
expr_stmt|;
comment|/* the rest of the buffer is for 					 * parity */
comment|/* the last step is to figure out how many more distinct buffers need 	 * to get xor'd to produce the missing unit.  there's one for each 	 * user-data read node that overlaps the portion of the failed unit 	 * being accessed */
for|for
control|(
name|foundit
operator|=
name|i
operator|=
literal|0
operator|,
name|pda
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pda
operator|==
name|failedPDA
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|foundit
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rf_PDAOverlap
argument_list|(
name|layoutPtr
argument_list|,
name|pda
argument_list|,
name|failedPDA
argument_list|)
condition|)
block|{
name|overlappingPDAs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|nXorBufs
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|foundit
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"GenerateFailedAccessASMs: did not find failedPDA in asm list\n"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf_degDagDebug
condition|)
block|{
if|if
condition|(
name|new_asm_h
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"First asm:\n"
argument_list|)
expr_stmt|;
name|rf_PrintFullAccessStripeMap
argument_list|(
name|new_asm_h
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_asm_h
index|[
literal|1
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"Second asm:\n"
argument_list|)
expr_stmt|;
name|rf_PrintFullAccessStripeMap
argument_list|(
name|new_asm_h
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* adjusts the offset and number of sectors in the destination pda so that  * it covers at most the region of the SU covered by the source PDA.  This  * is exclusively a restriction:  the number of sectors indicated by the  * target PDA can only shrink.  *  * For example:  s = sectors within SU indicated by source PDA  *               d = sectors within SU indicated by dest PDA  *               r = results, stored in dest PDA  *  * |--------------- one stripe unit ---------------------|  * |           sssssssssssssssssssssssssssssssss         |  * |    ddddddddddddddddddddddddddddddddddddddddddddd    |  * |           rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr         |  *  * Another example:  *  * |--------------- one stripe unit ---------------------|  * |           sssssssssssssssssssssssssssssssss         |  * |    ddddddddddddddddddddddd                          |  * |           rrrrrrrrrrrrrrrr                          |  *  */
end_comment

begin_function
name|void
name|rf_RangeRestrictPDA
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|src
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|dest
parameter_list|,
name|int
name|dobuffer
parameter_list|,
name|int
name|doraidaddr
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_SectorNum_t
name|soffs
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|src
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|RF_SectorNum_t
name|doffs
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|RF_SectorNum_t
name|send
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|src
operator|->
name|startSector
operator|+
name|src
operator|->
name|numSector
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|/* use -1 to be sure we 													 * stay within SU */
name|RF_SectorNum_t
name|dend
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|startSector
operator|+
name|dest
operator|->
name|numSector
operator|-
literal|1
argument_list|)
decl_stmt|;
name|RF_SectorNum_t
name|subAddr
init|=
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|startSector
argument_list|)
decl_stmt|;
comment|/* stripe unit boundary */
name|dest
operator|->
name|startSector
operator|=
name|subAddr
operator|+
name|RF_MAX
argument_list|(
name|soffs
argument_list|,
name|doffs
argument_list|)
expr_stmt|;
name|dest
operator|->
name|numSector
operator|=
name|subAddr
operator|+
name|RF_MIN
argument_list|(
name|send
argument_list|,
name|dend
argument_list|)
operator|+
literal|1
operator|-
name|dest
operator|->
name|startSector
expr_stmt|;
if|if
condition|(
name|dobuffer
condition|)
name|dest
operator|->
name|bufPtr
operator|+=
operator|(
name|soffs
operator|>
name|doffs
operator|)
condition|?
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|soffs
operator|-
name|doffs
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|doraidaddr
condition|)
block|{
name|dest
operator|->
name|raidAddress
operator|=
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|raidAddress
argument_list|)
operator|+
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|dest
operator|->
name|startSector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Want the highest of these primes to be the largest one  * less than the max expected number of columns (won't hurt  * to be too small or too large, but won't be optimal, either)  * --jimz  */
end_comment

begin_define
define|#
directive|define
name|NLOWPRIMES
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|lowprimes
index|[
name|NLOWPRIMES
index|]
init|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|17
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************  * compute the workload shift factor.  (chained declustering)  *  * return nonzero if access should shift to secondary, otherwise,  * access is to primary  *****************************************************************************/
end_comment

begin_function
name|int
name|rf_compute_workload_shift
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|pda
parameter_list|)
block|{
comment|/*          * variables:          *  d   = column of disk containing primary          *  f   = column of failed disk          *  n   = number of disks in array          *  sd  = "shift distance" (number of columns that d is to the right of f)          *  row = row of array the access is in          *  v   = numerator of redirection ratio          *  k   = denominator of redirection ratio          */
name|RF_RowCol_t
name|d
decl_stmt|,
name|f
decl_stmt|,
name|sd
decl_stmt|,
name|row
decl_stmt|,
name|n
decl_stmt|;
name|int
name|k
decl_stmt|,
name|v
decl_stmt|,
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|row
operator|=
name|pda
operator|->
name|row
expr_stmt|;
name|n
operator|=
name|raidPtr
operator|->
name|numCol
expr_stmt|;
comment|/* assign column of primary copy to d */
name|d
operator|=
name|pda
operator|->
name|col
expr_stmt|;
comment|/* assign column of dead disk to f */
for|for
control|(
name|f
operator|=
literal|0
init|;
operator|(
operator|(
operator|!
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|f
index|]
operator|.
name|status
argument_list|)
operator|)
operator|&&
operator|(
name|f
operator|<
name|n
operator|)
operator|)
condition|;
name|f
operator|++
control|)
empty_stmt|;
name|RF_ASSERT
argument_list|(
name|f
operator|<
name|n
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|f
operator|!=
name|d
argument_list|)
expr_stmt|;
name|sd
operator|=
operator|(
name|f
operator|>
name|d
operator|)
condition|?
operator|(
name|n
operator|+
name|d
operator|-
name|f
operator|)
else|:
operator|(
name|d
operator|-
name|f
operator|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|sd
operator|<
name|n
argument_list|)
expr_stmt|;
comment|/*          * v of every k accesses should be redirected          *          * v/k := (n-1-sd)/(n-1)          */
name|v
operator|=
operator|(
name|n
operator|-
literal|1
operator|-
name|sd
operator|)
expr_stmt|;
name|k
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/*          * XXX          * Is this worth it?          *          * Now reduce the fraction, by repeatedly factoring          * out primes (just like they teach in elementary school!)          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLOWPRIMES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lowprimes
index|[
name|i
index|]
operator|>
name|v
condition|)
break|break;
while|while
condition|(
operator|(
operator|(
name|v
operator|%
name|lowprimes
index|[
name|i
index|]
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|k
operator|%
name|lowprimes
index|[
name|i
index|]
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|v
operator|/=
name|lowprimes
index|[
name|i
index|]
expr_stmt|;
name|k
operator|/=
name|lowprimes
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|raidPtr
operator|->
name|hist_diskreq
index|[
name|row
index|]
index|[
name|d
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|hist_diskreq
index|[
name|row
index|]
index|[
name|d
index|]
operator|>
name|v
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* do not redirect */
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* redirect */
block|}
if|#
directive|if
literal|0
block|printf("d=%d f=%d sd=%d v=%d k=%d ret=%d h=%d\n", d, f, sd, v, k, ret, 	    raidPtr->hist_diskreq[row][d]);
endif|#
directive|endif
if|if
condition|(
name|raidPtr
operator|->
name|hist_diskreq
index|[
name|row
index|]
index|[
name|d
index|]
operator|>=
name|k
condition|)
block|{
comment|/* reset counter */
name|raidPtr
operator|->
name|hist_diskreq
index|[
name|row
index|]
index|[
name|d
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disk selection routines  */
end_comment

begin_comment
comment|/*  * Selects the disk with the shortest queue from a mirror pair.  * Both the disk I/Os queued in RAIDframe as well as those at the physical  * disk are counted as members of the "queue"  */
end_comment

begin_function
name|void
name|rf_SelectMirrorDiskIdle
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|rowData
decl_stmt|,
name|colData
decl_stmt|,
name|rowMirror
decl_stmt|,
name|colMirror
decl_stmt|;
name|int
name|dataQueueLength
decl_stmt|,
name|mirrorQueueLength
decl_stmt|,
name|usemirror
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|data_pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|mirror_pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|4
index|]
operator|.
name|p
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|tmp_pda
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
init|=
name|raidPtr
operator|->
name|Disks
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
modifier|*
name|dqs
init|=
name|raidPtr
operator|->
name|Queues
decl_stmt|,
modifier|*
name|dataQueue
decl_stmt|,
modifier|*
name|mirrorQueue
decl_stmt|;
comment|/* return the [row col] of the disk with the shortest queue */
name|rowData
operator|=
name|data_pda
operator|->
name|row
expr_stmt|;
name|colData
operator|=
name|data_pda
operator|->
name|col
expr_stmt|;
name|rowMirror
operator|=
name|mirror_pda
operator|->
name|row
expr_stmt|;
name|colMirror
operator|=
name|mirror_pda
operator|->
name|col
expr_stmt|;
name|dataQueue
operator|=
operator|&
operator|(
name|dqs
index|[
name|rowData
index|]
index|[
name|colData
index|]
operator|)
expr_stmt|;
name|mirrorQueue
operator|=
operator|&
operator|(
name|dqs
index|[
name|rowMirror
index|]
index|[
name|colMirror
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RF_LOCK_QUEUES_TO_READ_LEN
name|RF_LOCK_QUEUE_MUTEX
argument_list|(
name|dataQueue
argument_list|,
literal|"SelectMirrorDiskIdle"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_LOCK_QUEUES_TO_READ_LEN */
name|dataQueueLength
operator|=
name|dataQueue
operator|->
name|queueLength
operator|+
name|dataQueue
operator|->
name|numOutstanding
expr_stmt|;
ifdef|#
directive|ifdef
name|RF_LOCK_QUEUES_TO_READ_LEN
name|RF_UNLOCK_QUEUE_MUTEX
argument_list|(
name|dataQueue
argument_list|,
literal|"SelectMirrorDiskIdle"
argument_list|)
expr_stmt|;
name|RF_LOCK_QUEUE_MUTEX
argument_list|(
name|mirrorQueue
argument_list|,
literal|"SelectMirrorDiskIdle"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_LOCK_QUEUES_TO_READ_LEN */
name|mirrorQueueLength
operator|=
name|mirrorQueue
operator|->
name|queueLength
operator|+
name|mirrorQueue
operator|->
name|numOutstanding
expr_stmt|;
ifdef|#
directive|ifdef
name|RF_LOCK_QUEUES_TO_READ_LEN
name|RF_UNLOCK_QUEUE_MUTEX
argument_list|(
name|mirrorQueue
argument_list|,
literal|"SelectMirrorDiskIdle"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_LOCK_QUEUES_TO_READ_LEN */
name|usemirror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|rowMirror
index|]
index|[
name|colMirror
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|rowData
index|]
index|[
name|colData
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|usemirror
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raidPtr
operator|->
name|parity_good
operator|==
name|RF_RAID_DIRTY
condition|)
block|{
comment|/* Trust only the main disk */
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dataQueueLength
operator|<
name|mirrorQueueLength
condition|)
block|{
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mirrorQueueLength
operator|<
name|dataQueueLength
condition|)
block|{
name|usemirror
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* queues are equal length. attempt 						 * cleverness. */
if|if
condition|(
name|SNUM_DIFF
argument_list|(
name|dataQueue
operator|->
name|last_deq_sector
argument_list|,
name|data_pda
operator|->
name|startSector
argument_list|)
operator|<=
name|SNUM_DIFF
argument_list|(
name|mirrorQueue
operator|->
name|last_deq_sector
argument_list|,
name|mirror_pda
operator|->
name|startSector
argument_list|)
condition|)
block|{
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|usemirror
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usemirror
condition|)
block|{
comment|/* use mirror (parity) disk, swap params 0& 4 */
name|tmp_pda
operator|=
name|data_pda
expr_stmt|;
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|mirror_pda
expr_stmt|;
name|node
operator|->
name|params
index|[
literal|4
index|]
operator|.
name|p
operator|=
name|tmp_pda
expr_stmt|;
block|}
else|else
block|{
comment|/* use data disk, leave param 0 unchanged */
block|}
comment|/* printf("dataQueueLength %d, mirrorQueueLength 	 * %d\n",dataQueueLength, mirrorQueueLength); */
block|}
end_function

begin_comment
comment|/*  * Do simple partitioning. This assumes that  * the data and parity disks are laid out identically.  */
end_comment

begin_function
name|void
name|rf_SelectMirrorDiskPartition
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|dagHdr
operator|->
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|rowData
decl_stmt|,
name|colData
decl_stmt|,
name|rowMirror
decl_stmt|,
name|colMirror
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|data_pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|mirror_pda
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|4
index|]
operator|.
name|p
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|tmp_pda
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
init|=
name|raidPtr
operator|->
name|Disks
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
modifier|*
name|dqs
init|=
name|raidPtr
operator|->
name|Queues
decl_stmt|,
modifier|*
name|dataQueue
decl_stmt|,
modifier|*
name|mirrorQueue
decl_stmt|;
name|int
name|usemirror
decl_stmt|;
comment|/* return the [row col] of the disk with the shortest queue */
name|rowData
operator|=
name|data_pda
operator|->
name|row
expr_stmt|;
name|colData
operator|=
name|data_pda
operator|->
name|col
expr_stmt|;
name|rowMirror
operator|=
name|mirror_pda
operator|->
name|row
expr_stmt|;
name|colMirror
operator|=
name|mirror_pda
operator|->
name|col
expr_stmt|;
name|dataQueue
operator|=
operator|&
operator|(
name|dqs
index|[
name|rowData
index|]
index|[
name|colData
index|]
operator|)
expr_stmt|;
name|mirrorQueue
operator|=
operator|&
operator|(
name|dqs
index|[
name|rowMirror
index|]
index|[
name|colMirror
index|]
operator|)
expr_stmt|;
name|usemirror
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|rowMirror
index|]
index|[
name|colMirror
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|rowData
index|]
index|[
name|colData
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|usemirror
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raidPtr
operator|->
name|parity_good
operator|==
name|RF_RAID_DIRTY
condition|)
block|{
comment|/* Trust only the main disk */
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data_pda
operator|->
name|startSector
operator|<
operator|(
name|disks
index|[
name|rowData
index|]
index|[
name|colData
index|]
operator|.
name|numBlocks
operator|/
literal|2
operator|)
condition|)
block|{
name|usemirror
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|usemirror
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|usemirror
condition|)
block|{
comment|/* use mirror (parity) disk, swap params 0& 4 */
name|tmp_pda
operator|=
name|data_pda
expr_stmt|;
name|node
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|mirror_pda
expr_stmt|;
name|node
operator|->
name|params
index|[
literal|4
index|]
operator|.
name|p
operator|=
name|tmp_pda
expr_stmt|;
block|}
else|else
block|{
comment|/* use data disk, leave param 0 unchanged */
block|}
block|}
end_function

end_unit

