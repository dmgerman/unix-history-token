begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_pqdegdags.c,v 1.5 1999/08/15 02:36:40 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Daniel Stodolsky  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * rf_pqdegdags.c  * Degraded mode dags for double fault cases. */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_DECL_PQ
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_RAID6
operator|>
literal|0
operator|)
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_pqdegdags.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_pq.h>
end_include

begin_function_decl
specifier|static
name|void
name|applyPDA
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|pda
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|ppda
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|qpda
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*    Two data drives have failed, and we are doing a read that covers one of them.    We may also be reading some of the surviving drives.    *****************************************************************************************  *  * creates a DAG to perform a degraded-mode read of data within one stripe.  * This DAG is as follows:  *  *                                      Hdr  *                                       |  *                                     Block  *                       /         /           \         \     \   \  *                      Rud  ...  Rud         Rrd  ...  Rrd    Rp  Rq  *                      | \       | \         | \       | \    | \ | \  *  *                                 |                 |  *                              Unblock              X  *                                  \               /  *                                   ------ T ------  *  * Each R node is a successor of the L node  * One successor arc from each R node goes to U, and the other to X  * There is one Rud for each chunk of surviving user data requested by the user,  * and one Rrd for each chunk of surviving user data _not_ being read by the user  * R = read, ud = user data, rd = recovery (surviving) data, p = P data, q = Qdata  * X = pq recovery node, T = terminate  *  * The block& unblock nodes are leftovers from a previous version.  They  * do nothing, but I haven't deleted them because it would be a tremendous  * effort to put them back in.  *  * Note:  The target buffer for the XOR node is set to the actual user buffer where the  * failed data is supposed to end up.  This buffer is zero'd by the code here.  Thus,  * if you create a degraded read dag, use it, and then re-use, you have to be sure to  * zero the target buffer prior to the re-use.  *  * Every buffer read is passed to the pq recovery node, whose job it is to sort out whats  * needs and what's not.  ****************************************************************************************/
end_comment

begin_comment
comment|/*   init a disk node with 2 successors and one predecessor */
end_comment

begin_define
define|#
directive|define
name|INIT_DISK_NODE
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
define|\
value|rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 2,1,4,0, dag_h, name, allocList); \ (node)->succedents[0] = unblockNode; \ (node)->succedents[1] = recoveryNode; \ (node)->antecedents[0] = blockNode; \ (node)->antType[0] = rf_control
end_define

begin_define
define|#
directive|define
name|DISK_NODE_PARAMS
parameter_list|(
name|_node_
parameter_list|,
name|_p_
parameter_list|)
define|\
value|(_node_).params[0].p = _p_ ; \   (_node_).params[1].p = (_p_)->bufPtr; \   (_node_).params[2].v = parityStripeID; \   (_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru)
end_define

begin_define
define|#
directive|define
name|DISK_NODE_PDA
parameter_list|(
name|node
parameter_list|)
value|((node)->params[0].p)
end_define

begin_macro
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_PQ_DoubleDegRead
argument_list|)
end_macro

begin_block
block|{
name|rf_DoubleDegRead
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
literal|"Rq"
argument_list|,
literal|"PQ Recovery"
argument_list|,
name|rf_PQDoubleRecoveryFunc
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|applyPDA
parameter_list|(
name|raidPtr
parameter_list|,
name|pda
parameter_list|,
name|ppda
parameter_list|,
name|qpda
parameter_list|,
name|bp
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|ppda
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|qpda
decl_stmt|;
name|void
modifier|*
name|bp
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_RaidAddr_t
name|s0off
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|ppda
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|RF_SectorCount_t
name|s0len
init|=
name|ppda
operator|->
name|numSector
decl_stmt|,
name|len
decl_stmt|;
name|RF_SectorNum_t
name|suoffset
decl_stmt|;
name|unsigned
name|coeff
decl_stmt|;
name|char
modifier|*
name|pbuf
init|=
name|ppda
operator|->
name|bufPtr
decl_stmt|;
name|char
modifier|*
name|qbuf
init|=
name|qpda
operator|->
name|bufPtr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|len
operator|=
name|pda
operator|->
name|numSector
expr_stmt|;
comment|/* see if pda intersects a recovery pda */
if|if
condition|(
operator|(
name|suoffset
operator|<
name|s0off
operator|+
name|s0len
operator|)
operator|&&
operator|(
name|suoffset
operator|+
name|len
operator|>
name|s0off
operator|)
condition|)
block|{
name|buf
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
if|if
condition|(
name|suoffset
operator|<
name|s0off
condition|)
block|{
name|delta
operator|=
name|s0off
operator|-
name|suoffset
expr_stmt|;
name|buf
operator|+=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|suoffset
operator|=
name|s0off
expr_stmt|;
name|len
operator|-=
name|delta
expr_stmt|;
block|}
if|if
condition|(
name|suoffset
operator|>
name|s0off
condition|)
block|{
name|delta
operator|=
name|suoffset
operator|-
name|s0off
expr_stmt|;
name|pbuf
operator|+=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|qbuf
operator|+=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|suoffset
operator|+
name|len
operator|)
operator|>
operator|(
name|s0len
operator|+
name|s0off
operator|)
condition|)
name|len
operator|=
name|s0len
operator|+
name|s0off
operator|-
name|suoffset
expr_stmt|;
comment|/* src, dest, len */
name|rf_bxor
argument_list|(
name|buf
argument_list|,
name|pbuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|len
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* dest, src, len, coeff */
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qbuf
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|buf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|len
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    Recover data in the case of a double failure. There can be two    result buffers, one for each chunk of data trying to be recovered.    The params are pda's that have not been range restricted or otherwise    politely massaged - this should be done here. The last params are the    pdas of P and Q, followed by the raidPtr. The list can look like     pda, pda, ... , p pda, q pda, raidptr, asm     or     pda, pda, ... , p_1 pda, p_2 pda, q_1 pda, q_2 pda, raidptr, asm     depending on wether two chunks of recovery data were required.     The second condition only arises if there are two failed buffers    whose lengths do not add up a stripe unit. */
end_comment

begin_function
name|int
name|rf_PQDoubleRecoveryFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
init|=
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|d
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|coeff
decl_stmt|;
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|,
name|suoffset
decl_stmt|;
name|RF_SectorCount_t
name|len
decl_stmt|,
name|secPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|two
init|=
literal|0
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|ppda
decl_stmt|,
modifier|*
name|ppda2
decl_stmt|,
modifier|*
name|qpda
decl_stmt|,
modifier|*
name|qpda2
decl_stmt|,
modifier|*
name|pda
decl_stmt|,
name|npda
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|&&
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|numSector
operator|+
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|numSector
operator|<
name|secPerSU
operator|)
condition|)
block|{
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ppda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|6
index|]
operator|.
name|p
expr_stmt|;
name|ppda2
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|5
index|]
operator|.
name|p
expr_stmt|;
name|qpda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|4
index|]
operator|.
name|p
expr_stmt|;
name|qpda2
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|3
index|]
operator|.
name|p
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|6
operator|)
expr_stmt|;
name|two
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ppda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|4
index|]
operator|.
name|p
expr_stmt|;
name|qpda
operator|=
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|3
index|]
operator|.
name|p
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|4
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|pda
operator|=
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|buf
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|len
operator|=
name|pda
operator|->
name|numSector
expr_stmt|;
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
comment|/* see if pda intersects a recovery pda */
name|applyPDA
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|,
name|ppda
argument_list|,
name|qpda
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|two
condition|)
name|applyPDA
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|,
name|ppda
argument_list|,
name|qpda
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* ok, we got the parity back to the point where we can recover. We 	 * now need to determine the coeff of the columns that need to be 	 * recovered. We can also only need to recover a single stripe unit. */
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* only a single stripe unit 						 * to recover. */
name|pda
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* need to determine the column of the other failed disk */
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
name|npda
operator|.
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|npda
operator|.
name|raidAddress
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|row
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|col
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|npda
operator|.
name|row
index|]
index|[
name|npda
operator|.
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
if|if
condition|(
name|i
operator|!=
name|coeff
condition|)
break|break;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|<
name|numDataCol
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|two
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* recover the data. Since we need only want to recover one 		 * column, we overwrite the parity with the other one. */
if|if
condition|(
name|coeff
operator|<
name|i
condition|)
comment|/* recovering 'a' */
name|rf_PQ_recover
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|pda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
comment|/* recovering 'b' */
name|rf_PQ_recover
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|pda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|i
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
else|else
name|RF_PANIC
argument_list|()
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracerec
condition|)
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_PQWriteDoubleRecoveryFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
comment|/* The situation: 	 *  	 * We are doing a write that hits only one failed data unit. The other 	 * failed data unit is not being overwritten, so we need to generate 	 * it. 	 *  	 * For the moment, we assume all the nonfailed data being written is in 	 * the shadow of the failed data unit. (i.e,, either a single data 	 * unit write or the entire failed stripe unit is being overwritten. ) 	 *  	 * Recovery strategy: apply the recovery data to the parity and q. Use P 	 *& Q to recover the second failed data unit in P. Zero fill Q, then 	 * apply the recovered data to p. Then apply the data being written to 	 * the failed drive. Then walk through the surviving drives, applying 	 * new data when it exists, othewise the recovery data. Quite a mess. 	 *  	 *  	 * The params 	 *  	 * read pda0, read pda1, ... read pda (numDataCol-3), write pda0, ... , 	 * write pda (numStripeUnitAccess - numDataFailed), failed pda, 	 * raidPtr, asmap */
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
init|=
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|;
name|unsigned
name|coeff
decl_stmt|;
name|RF_StripeCount_t
name|secPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|ppda
decl_stmt|,
modifier|*
name|qpda
decl_stmt|,
modifier|*
name|pda
decl_stmt|,
name|npda
decl_stmt|;
name|int
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|numResults
operator|==
literal|2
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|ppda
operator|=
name|node
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
name|qpda
operator|=
name|node
operator|->
name|results
index|[
literal|1
index|]
expr_stmt|;
comment|/* apply the recovery data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|applyPDA
argument_list|(
name|raidPtr
argument_list|,
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
argument_list|,
name|ppda
argument_list|,
name|qpda
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* determine the other failed data unit */
name|pda
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* need to determine the column of the other failed disk */
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
name|npda
operator|.
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|npda
operator|.
name|raidAddress
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|row
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|col
operator|)
argument_list|,
operator|&
operator|(
name|npda
operator|.
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|npda
operator|.
name|row
index|]
index|[
name|npda
operator|.
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
if|if
condition|(
name|i
operator|!=
name|coeff
condition|)
break|break;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|<
name|numDataCol
argument_list|)
expr_stmt|;
comment|/* recover the data. The column we want to recover we write over the 	 * parity. The column we don't care about we dump in q. */
if|if
condition|(
name|coeff
operator|<
name|i
condition|)
comment|/* recovering 'a' */
name|rf_PQ_recover
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
comment|/* recovering 'b' */
name|rf_PQ_recover
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|i
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
comment|/* OK. The valid data is in P. Zero fill Q, then inc it into it. */
name|bzero
argument_list|(
name|qpda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|qpda
operator|->
name|numSector
argument_list|)
argument_list|)
expr_stmt|;
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ppda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|qpda
operator|->
name|numSector
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* now apply all the write data to the buffer */
comment|/* single stripe unit write case: the failed data is only thing we are 	 * writing. */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* dest, src, len, coeff */
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpda
operator|->
name|bufPtr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|qpda
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
name|rf_bxor
argument_list|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|bufPtr
argument_list|,
name|ppda
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|ppda
operator|->
name|numSector
argument_list|)
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* now apply all the recovery data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|applyPDA
argument_list|(
name|raidPtr
argument_list|,
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
argument_list|,
name|ppda
argument_list|,
name|qpda
argument_list|,
name|node
operator|->
name|dagHdr
operator|->
name|bp
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracerec
condition|)
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_PQ_DDLargeWrite
argument_list|)
end_macro

begin_block
block|{
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*    Two lost data unit write case.     There are really two cases here:     (1) The write completely covers the two lost data units.        In that case, a reconstruct write that doesn't write the        failed data units will do the correct thing. So in this case,        the dag looks like              full stripe read of surviving data units (not being overwriten) 	    write new data (ignoring failed units)   compute P&Q 	                                             write P&Q      (2) The write does not completely cover both failed data units        (but touches at least one of them). Then we need to do the        equivalent of a reconstruct read to recover the missing data        unit from the other stripe.         For any data we are writing that is not in the "shadow"        of the failed units, we need to do a four cycle update.        PANIC on this case. for now  */
end_comment

begin_macro
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_PQ_200_CreateWriteDAG
argument_list|)
end_macro

begin_block
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|sum
decl_stmt|;
name|int
name|nf
init|=
name|asmap
operator|->
name|numDataFailed
decl_stmt|;
name|sum
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|numSector
expr_stmt|;
if|if
condition|(
name|nf
operator|==
literal|2
condition|)
name|sum
operator|+=
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|numSector
expr_stmt|;
if|if
condition|(
operator|(
name|nf
operator|==
literal|2
operator|)
operator|&&
operator|(
name|sum
operator|==
operator|(
literal|2
operator|*
name|sectorsPerSU
operator|)
operator|)
condition|)
block|{
comment|/* large write case */
name|rf_PQ_DDLargeWrite
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|nf
operator|==
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|)
operator|||
operator|(
name|sum
operator|>=
name|sectorsPerSU
operator|)
condition|)
block|{
comment|/* small write case, no user data not in shadow */
name|rf_PQ_DDSimpleSmallWrite
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
return|return;
block|}
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_PQ_DDSimpleSmallWrite
argument_list|)
end_macro

begin_block
block|{
name|rf_DoubleDegSmallWrite
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
literal|"Rq"
argument_list|,
literal|"Wq"
argument_list|,
literal|"PQ Recovery"
argument_list|,
name|rf_PQWriteDoubleRecoveryFunc
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_DECL_PQ> 0) || 				 * (RF_INCLUDE_RAID6> 0) */
end_comment

end_unit

