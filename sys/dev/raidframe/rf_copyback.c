begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_copyback.c,v 1.15 2001/01/26 02:16:24 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*****************************************************************************************  *  * copyback.c -- code to copy reconstructed data back from spare space to  *               the replaced disk.  *  * the code operates using callbacks on the I/Os to continue with the next  * unit to be copied back.  We do this because a simple loop containing blocking I/Os  * will not work in the simulator.  *  ****************************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500005
end_if

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_utils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_copyback.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_decluster.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_define
define|#
directive|define
name|RF_COPYBACK_DATA
value|0
end_define

begin_define
define|#
directive|define
name|RF_COPYBACK_PARITY
value|1
end_define

begin_decl_stmt
name|int
name|rf_copyback_in_progress
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|rf_CopybackReadDoneProc
parameter_list|(
name|RF_CopybackDesc_t
modifier|*
name|desc
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_CopybackWriteDoneProc
parameter_list|(
name|RF_CopybackDesc_t
modifier|*
name|desc
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_CopybackOne
parameter_list|(
name|RF_CopybackDesc_t
modifier|*
name|desc
parameter_list|,
name|int
name|typ
parameter_list|,
name|RF_RaidAddr_t
name|addr
parameter_list|,
name|RF_RowCol_t
name|testRow
parameter_list|,
name|RF_RowCol_t
name|testCol
parameter_list|,
name|RF_SectorNum_t
name|testOffs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_CopybackComplete
parameter_list|(
name|RF_CopybackDesc_t
modifier|*
name|desc
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|rf_ConfigureCopyback
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|rf_copyback_in_progress
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_comment
comment|/* do a complete copyback */
end_comment

begin_function
name|void
name|rf_CopybackReconstructedData
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|c_label
decl_stmt|;
name|int
name|done
decl_stmt|,
name|retcode
decl_stmt|;
name|RF_CopybackDesc_t
modifier|*
name|desc
decl_stmt|;
name|RF_RowCol_t
name|frow
decl_stmt|,
name|fcol
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|badDisk
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|databuf
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|RF_Malloc
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_label
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rf_CopybackReconstructedData: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
operator|=
literal|0
expr_stmt|;
name|fcol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|frow
operator|=
literal|0
init|;
name|frow
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|frow
operator|++
control|)
block|{
for|for
control|(
name|fcol
operator|=
literal|0
init|;
name|fcol
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|fcol
operator|++
control|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|status
operator|==
name|rf_ds_dist_spared
operator|||
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|status
operator|==
name|rf_ds_spared
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
if|if
condition|(
name|frow
operator|==
name|raidPtr
operator|->
name|numRow
condition|)
block|{
name|printf
argument_list|(
literal|"COPYBACK:  no disks need copyback\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|badDisk
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
expr_stmt|;
comment|/* This device may have been opened successfully the first time. Close 	 * it before trying to open it again.. */
if|if
condition|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_vp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Closed the open device: %s\n"
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
name|vp
operator|=
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_vp
expr_stmt|;
name|ac
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|auto_configured
expr_stmt|;
name|rf_close_component
argument_list|(
name|raidPtr
argument_list|,
name|vp
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_vp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* note that this disk was *not* auto_configured (any longer) */
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|auto_configured
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"About to (re-)open the device: %s\n"
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|raid_getcomponentsize
argument_list|(
name|raidPtr
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|printf
argument_list|(
literal|"COPYBACK: raidlookup on device: %s failed: %d!\n"
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|devname
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
comment|/* XXX the component isn't responding properly... must be 		 * still dead :-( */
return|return;
block|}
if|#
directive|if
literal|0
comment|/* This is the way it was done before the CAM stuff was removed */
block|if (rf_extract_ids(badDisk->devname,&bus,&targ,&lun)) { 		printf("COPYBACK: unable to extract bus, target, lun from devname %s\n", 		    badDisk->devname); 		return; 	}
comment|/* TUR the disk that's marked as bad to be sure that it's actually 	 * alive */
block|rf_SCSI_AllocTUR(&tur_op); 	retcode = rf_SCSI_DoTUR(tur_op, bus, targ, lun, badDisk->dev); 	rf_SCSI_FreeDiskOp(tur_op, 0);
endif|#
directive|endif
if|if
condition|(
name|retcode
condition|)
block|{
name|printf
argument_list|(
literal|"COPYBACK: target disk failed TUR\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get a buffer to hold one SU  */
name|RF_Malloc
argument_list|(
name|databuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* create a descriptor */
name|RF_Malloc
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|,
operator|(
name|RF_CopybackDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|raidPtr
operator|=
name|raidPtr
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|frow
operator|=
name|frow
expr_stmt|;
name|desc
operator|->
name|fcol
operator|=
name|fcol
expr_stmt|;
name|desc
operator|->
name|spRow
operator|=
name|badDisk
operator|->
name|spareRow
expr_stmt|;
name|desc
operator|->
name|spCol
operator|=
name|badDisk
operator|->
name|spareCol
expr_stmt|;
name|desc
operator|->
name|stripeAddr
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|sectPerSU
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
name|desc
operator|->
name|sectPerStripe
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
expr_stmt|;
name|desc
operator|->
name|databuf
operator|=
name|databuf
expr_stmt|;
name|desc
operator|->
name|mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"COPYBACK: Quiescing the array\n"
argument_list|)
expr_stmt|;
comment|/* quiesce the array, since we don't want to code support for user 	 * accs here */
name|rf_SuspendNewRequestsAndWait
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* adjust state of the array and of the disks */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|desc
operator|->
name|frow
index|]
index|[
name|desc
operator|->
name|fcol
index|]
operator|.
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
name|raidPtr
operator|->
name|status
index|[
name|desc
operator|->
name|frow
index|]
operator|=
name|rf_rs_optimal
expr_stmt|;
name|rf_copyback_in_progress
operator|=
literal|1
expr_stmt|;
comment|/* debug only */
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"COPYBACK: Beginning\n"
argument_list|)
expr_stmt|;
name|RF_GETTIME
argument_list|(
name|desc
operator|->
name|starttime
argument_list|)
expr_stmt|;
name|rf_ContinueCopyback
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* Data has been restored.  Fix up the component label. */
comment|/* Don't actually need the read here.. */
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_vp
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|raid_init_component_label
argument_list|(
name|raidPtr
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|c_label
operator|->
name|row
operator|=
name|frow
expr_stmt|;
name|c_label
operator|->
name|column
operator|=
name|fcol
expr_stmt|;
name|c_label
operator|->
name|partitionSize
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|partitionSize
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|ci_vp
argument_list|,
name|c_label
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|c_label
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * invoked via callback after a copyback I/O has completed to  * continue on with the next one  */
end_comment

begin_function
name|void
name|rf_ContinueCopyback
parameter_list|(
name|desc
parameter_list|)
name|RF_CopybackDesc_t
modifier|*
name|desc
decl_stmt|;
block|{
name|RF_SectorNum_t
name|testOffs
decl_stmt|,
name|stripeAddr
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_RaidAddr_t
name|addr
decl_stmt|;
name|RF_RowCol_t
name|testRow
decl_stmt|,
name|testCol
decl_stmt|;
name|int
name|old_pctg
decl_stmt|,
name|new_pctg
decl_stmt|,
name|done
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
name|diff
decl_stmt|;
name|old_pctg
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|stripeAddr
operator|=
name|desc
operator|->
name|stripeAddr
expr_stmt|;
name|desc
operator|->
name|raidPtr
operator|->
name|copyback_stripes_done
operator|=
name|stripeAddr
operator|/
name|desc
operator|->
name|sectPerStripe
expr_stmt|;
if|if
condition|(
name|rf_prReconSched
condition|)
block|{
name|old_pctg
operator|=
literal|100
operator|*
name|desc
operator|->
name|stripeAddr
operator|/
name|raidPtr
operator|->
name|totalSectors
expr_stmt|;
block|}
name|desc
operator|->
name|stripeAddr
operator|+=
name|desc
operator|->
name|sectPerStripe
expr_stmt|;
if|if
condition|(
name|rf_prReconSched
condition|)
block|{
name|new_pctg
operator|=
literal|100
operator|*
name|desc
operator|->
name|stripeAddr
operator|/
name|raidPtr
operator|->
name|totalSectors
expr_stmt|;
if|if
condition|(
name|new_pctg
operator|!=
name|old_pctg
condition|)
block|{
name|RF_GETTIME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|RF_TIMEVAL_DIFF
argument_list|(
operator|&
name|desc
operator|->
name|starttime
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d.%06d\n"
argument_list|,
name|new_pctg
argument_list|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stripeAddr
operator|>=
name|raidPtr
operator|->
name|totalSectors
condition|)
block|{
name|rf_CopybackComplete
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* walk through the current stripe, su-by-su */
for|for
control|(
name|done
operator|=
literal|0
operator|,
name|addr
operator|=
name|stripeAddr
init|;
name|addr
operator|<
name|stripeAddr
operator|+
name|desc
operator|->
name|sectPerStripe
condition|;
name|addr
operator|+=
name|desc
operator|->
name|sectPerSU
control|)
block|{
comment|/* map the SU, disallowing remap to spare space */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|addr
argument_list|,
operator|&
name|testRow
argument_list|,
operator|&
name|testCol
argument_list|,
operator|&
name|testOffs
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|testRow
operator|==
name|desc
operator|->
name|frow
operator|&&
name|testCol
operator|==
name|desc
operator|->
name|fcol
condition|)
block|{
name|rf_CopybackOne
argument_list|(
name|desc
argument_list|,
name|RF_COPYBACK_DATA
argument_list|,
name|addr
argument_list|,
name|testRow
argument_list|,
name|testCol
argument_list|,
name|testOffs
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* we didn't find the failed disk in the data part. 			 * check parity. */
comment|/* map the parity for this stripe, disallowing remap 			 * to spare space */
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|stripeAddr
argument_list|,
operator|&
name|testRow
argument_list|,
operator|&
name|testCol
argument_list|,
operator|&
name|testOffs
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|testRow
operator|==
name|desc
operator|->
name|frow
operator|&&
name|testCol
operator|==
name|desc
operator|->
name|fcol
condition|)
block|{
name|rf_CopybackOne
argument_list|(
name|desc
argument_list|,
name|RF_COPYBACK_PARITY
argument_list|,
name|stripeAddr
argument_list|,
name|testRow
argument_list|,
name|testCol
argument_list|,
name|testOffs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check to see if the last read/write pair failed */
if|if
condition|(
name|desc
operator|->
name|status
condition|)
block|{
name|rf_CopybackComplete
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we didn't find any units to copy back in this stripe. 		 * Continue with the next one */
block|}
block|}
end_function

begin_comment
comment|/* copyback one unit */
end_comment

begin_function
specifier|static
name|void
name|rf_CopybackOne
parameter_list|(
name|desc
parameter_list|,
name|typ
parameter_list|,
name|addr
parameter_list|,
name|testRow
parameter_list|,
name|testCol
parameter_list|,
name|testOffs
parameter_list|)
name|RF_CopybackDesc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|typ
decl_stmt|;
name|RF_RaidAddr_t
name|addr
decl_stmt|;
name|RF_RowCol_t
name|testRow
decl_stmt|;
name|RF_RowCol_t
name|testCol
decl_stmt|;
name|RF_SectorNum_t
name|testOffs
decl_stmt|;
block|{
name|RF_SectorCount_t
name|sectPerSU
init|=
name|desc
operator|->
name|sectPerSU
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|spRow
init|=
name|desc
operator|->
name|spRow
decl_stmt|;
name|RF_RowCol_t
name|spCol
init|=
name|desc
operator|->
name|spCol
decl_stmt|;
name|RF_SectorNum_t
name|spOffs
decl_stmt|;
comment|/* find the spare spare location for this SU */
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
if|if
condition|(
name|typ
operator|==
name|RF_COPYBACK_DATA
condition|)
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|addr
argument_list|,
operator|&
name|spRow
argument_list|,
operator|&
name|spCol
argument_list|,
operator|&
name|spOffs
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
else|else
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapParity
argument_list|(
name|raidPtr
argument_list|,
name|addr
argument_list|,
operator|&
name|spRow
argument_list|,
operator|&
name|spCol
argument_list|,
operator|&
name|spOffs
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spOffs
operator|=
name|testOffs
expr_stmt|;
block|}
comment|/* create reqs to read the old location& write the new */
name|desc
operator|->
name|readreq
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_READ
argument_list|,
name|spOffs
argument_list|,
name|sectPerSU
argument_list|,
name|desc
operator|->
name|databuf
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|rf_CopybackReadDoneProc
argument_list|,
name|desc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
name|RF_DISKQUEUE_DATA_FLAGS_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|desc
operator|->
name|writereq
operator|=
name|rf_CreateDiskQueueData
argument_list|(
name|RF_IO_TYPE_WRITE
argument_list|,
name|testOffs
argument_list|,
name|sectPerSU
argument_list|,
name|desc
operator|->
name|databuf
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|rf_CopybackWriteDoneProc
argument_list|,
name|desc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|raidPtr
argument_list|,
name|RF_DISKQUEUE_DATA_FLAGS_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|desc
operator|->
name|frow
operator|=
name|testRow
expr_stmt|;
name|desc
operator|->
name|fcol
operator|=
name|testCol
expr_stmt|;
comment|/* enqueue the read.  the write will go out as part of the callback on 	 * the read. at user-level& in the kernel, wait for the read-write 	 * pair to complete. in the simulator, just return, since everything 	 * will happen as callbacks */
name|RF_LOCK_MUTEX
argument_list|(
name|desc
operator|->
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|desc
operator|->
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DiskIOEnqueue
argument_list|(
operator|&
name|raidPtr
operator|->
name|Queues
index|[
name|spRow
index|]
index|[
name|spCol
index|]
argument_list|,
name|desc
operator|->
name|readreq
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|desc
operator|->
name|mcpair
operator|->
name|flag
condition|)
block|{
name|RF_WAIT_MCPAIR
argument_list|(
name|desc
operator|->
name|mcpair
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|desc
operator|->
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|rf_FreeDiskQueueData
argument_list|(
name|desc
operator|->
name|readreq
argument_list|)
expr_stmt|;
name|rf_FreeDiskQueueData
argument_list|(
name|desc
operator|->
name|writereq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called at interrupt context when the read has completed.  just send out the write */
end_comment

begin_function
specifier|static
name|int
name|rf_CopybackReadDoneProc
parameter_list|(
name|desc
parameter_list|,
name|status
parameter_list|)
name|RF_CopybackDesc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|status
condition|)
block|{
comment|/* invoke the callback with bad status */
name|printf
argument_list|(
literal|"COPYBACK: copyback read failed.  Aborting.\n"
argument_list|)
expr_stmt|;
call|(
name|desc
operator|->
name|writereq
operator|->
name|CompleteFunc
call|)
argument_list|(
name|desc
argument_list|,
operator|-
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rf_DiskIOEnqueue
argument_list|(
operator|&
operator|(
name|desc
operator|->
name|raidPtr
operator|->
name|Queues
index|[
name|desc
operator|->
name|frow
index|]
index|[
name|desc
operator|->
name|fcol
index|]
operator|)
argument_list|,
name|desc
operator|->
name|writereq
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* called at interrupt context when the write has completed.  * at user level& in the kernel, wake up the copyback thread.  * in the simulator, invoke the next copyback directly.  * can't free diskqueuedata structs in the kernel b/c we're at interrupt context.  */
end_comment

begin_function
specifier|static
name|int
name|rf_CopybackWriteDoneProc
parameter_list|(
name|desc
parameter_list|,
name|status
parameter_list|)
name|RF_CopybackDesc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|status
operator|&&
name|status
operator|!=
operator|-
literal|100
condition|)
block|{
name|printf
argument_list|(
literal|"COPYBACK: copyback write failed.  Aborting.\n"
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|rf_MCPairWakeupFunc
argument_list|(
name|desc
operator|->
name|mcpair
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* invoked when the copyback has completed */
end_comment

begin_function
specifier|static
name|void
name|rf_CopybackComplete
parameter_list|(
name|desc
parameter_list|,
name|status
parameter_list|)
name|RF_CopybackDesc_t
modifier|*
name|desc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
name|diff
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|parityConfig
operator|==
literal|'D'
argument_list|)
expr_stmt|;
name|rf_FreeSpareTable
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raidPtr
operator|->
name|Disks
index|[
name|desc
operator|->
name|spRow
index|]
index|[
name|desc
operator|->
name|spCol
index|]
operator|.
name|status
operator|=
name|rf_ds_spare
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_GETTIME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|RF_TIMEVAL_DIFF
argument_list|(
operator|&
name|desc
operator|->
name|starttime
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Copyback time was %d.%06d seconds\n"
argument_list|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"COPYBACK: Failure.\n"
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|desc
operator|->
name|databuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|desc
operator|->
name|sectPerSU
argument_list|)
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|desc
operator|->
name|mcpair
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|rf_copyback_in_progress
operator|=
literal|0
expr_stmt|;
name|rf_ResumeNewRequests
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

