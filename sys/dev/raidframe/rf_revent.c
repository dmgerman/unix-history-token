begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_revent.c,v 1.9 2000/09/21 01:45:46 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author:  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * revent.c -- reconstruction event handling code  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_revent.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_freelist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_revent_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_REVENT
value|128
end_define

begin_define
define|#
directive|define
name|RF_REVENT_INC
value|8
end_define

begin_define
define|#
directive|define
name|RF_REVENT_INITIAL
value|8
end_define

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|DO_WAIT
parameter_list|(
name|_rc
parameter_list|)
define|\
value|RF_LTSLEEP(&(_rc)->eventQueue, PRIBIO,  "raidframe eventq", \ 		0,&((_rc)->eq_mutex))
end_define

begin_define
define|#
directive|define
name|DO_SIGNAL
parameter_list|(
name|_rc
parameter_list|)
value|wakeup(&(_rc)->eventQueue)
end_define

begin_function_decl
specifier|static
name|void
name|rf_ShutdownReconEvent
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RF_ReconEvent_t
modifier|*
name|GetReconEventDesc
parameter_list|(
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|RF_Revent_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownReconEvent
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_revent_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_ReconEvent_t
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureReconEvent
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_revent_freelist
argument_list|,
name|RF_MAX_FREE_REVENT
argument_list|,
name|RF_REVENT_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ReconEvent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_revent_freelist
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownReconEvent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownReconEvent
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|RF_FREELIST_PRIME
argument_list|(
name|rf_revent_freelist
argument_list|,
name|RF_REVENT_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_ReconEvent_t
operator|*
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns the next reconstruction event, blocking the calling thread  * until one becomes available.  will now return null if it is blocked  * or will return an event if it is not */
end_comment

begin_decl_stmt
name|RF_ReconEvent_t
modifier|*
name|rf_GetNextReconEvent
argument_list|(
name|reconDesc
argument_list|,
name|row
argument_list|,
name|continueFunc
argument_list|,
name|continueArg
argument_list|)
name|RF_RaidReconDesc_t
modifier|*
name|reconDesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RowCol_t
name|row
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|continueFunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|continueArg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|reconDesc
operator|->
name|raidPtr
decl_stmt|;
name|RF_ReconCtrl_t
modifier|*
name|rctrl
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
decl_stmt|;
name|RF_ReconEvent_t
modifier|*
name|event
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|row
operator|>=
literal|0
operator|&&
name|row
operator|<=
name|raidPtr
operator|->
name|numRow
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|rctrl
operator|->
name|eq_mutex
argument_list|)
expr_stmt|;
comment|/* q null and count==0 must be equivalent conditions */
name|RF_ASSERT
argument_list|(
operator|(
name|rctrl
operator|->
name|eventQueue
operator|==
name|NULL
operator|)
operator|==
operator|(
name|rctrl
operator|->
name|eq_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|rctrl
operator|->
name|continueFunc
operator|=
name|continueFunc
expr_stmt|;
name|rctrl
operator|->
name|continueArg
operator|=
name|continueArg
expr_stmt|;
comment|/* mpsleep timeout value: secs = timo_val/hz.  'ticks' here is 	   defined as cycle-counter ticks, not softclock ticks */
define|#
directive|define
name|MAX_RECON_EXEC_USECS
value|(100 * 1000)
comment|/* 100 ms */
define|#
directive|define
name|RECON_DELAY_MS
value|25
define|#
directive|define
name|RECON_TIMO
value|((RECON_DELAY_MS * hz) / 1000)
comment|/* we are not pre-emptible in the kernel, but we don't want to run 	 * forever.  If we run w/o blocking for more than MAX_RECON_EXEC_TICKS 	 * ticks of the cycle counter, delay for RECON_DELAY before 	 * continuing. this may murder us with context switches, so we may 	 * need to increase both the MAX...TICKS and the RECON_DELAY_MS. */
if|if
condition|(
name|reconDesc
operator|->
name|reconExecTimerRunning
condition|)
block|{
name|int
name|status
decl_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|reconDesc
operator|->
name|recon_exec_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|reconDesc
operator|->
name|recon_exec_timer
argument_list|)
expr_stmt|;
name|reconDesc
operator|->
name|reconExecTicks
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|reconDesc
operator|->
name|recon_exec_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconDesc
operator|->
name|reconExecTicks
operator|>
name|reconDesc
operator|->
name|maxReconExecTicks
condition|)
name|reconDesc
operator|->
name|maxReconExecTicks
operator|=
name|reconDesc
operator|->
name|reconExecTicks
expr_stmt|;
if|if
condition|(
name|reconDesc
operator|->
name|reconExecTicks
operator|>=
name|MAX_RECON_EXEC_USECS
condition|)
block|{
comment|/* we've been running too long.  delay for 			 * RECON_DELAY_MS */
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|reconDesc
operator|->
name|numReconExecDelays
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
name|status
operator|=
name|RF_LTSLEEP
argument_list|(
operator|&
name|reconDesc
operator|->
name|reconExecTicks
argument_list|,
name|PRIBIO
argument_list|,
literal|"recon delay"
argument_list|,
name|RECON_TIMO
argument_list|,
operator|&
name|rctrl
operator|->
name|eq_mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|status
operator|==
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
name|reconDesc
operator|->
name|reconExecTicks
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|rctrl
operator|->
name|eventQueue
condition|)
block|{
if|#
directive|if
name|RF_RECON_STATS
operator|>
literal|0
name|reconDesc
operator|->
name|numReconEventWaits
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* RF_RECON_STATS> 0 */
name|DO_WAIT
argument_list|(
name|rctrl
argument_list|)
expr_stmt|;
name|reconDesc
operator|->
name|reconExecTicks
operator|=
literal|0
expr_stmt|;
comment|/* we've just waited */
block|}
name|reconDesc
operator|->
name|reconExecTimerRunning
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|RF_ETIMER_VAL_US
argument_list|(
name|reconDesc
operator|->
name|recon_exec_timer
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* it moved!!  reset the timer. */
name|RF_ETIMER_START
argument_list|(
name|reconDesc
operator|->
name|recon_exec_timer
argument_list|)
expr_stmt|;
block|}
name|event
operator|=
name|rctrl
operator|->
name|eventQueue
expr_stmt|;
name|rctrl
operator|->
name|eventQueue
operator|=
name|event
operator|->
name|next
expr_stmt|;
name|event
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|rctrl
operator|->
name|eq_count
operator|--
expr_stmt|;
comment|/* q null and count==0 must be equivalent conditions */
name|RF_ASSERT
argument_list|(
operator|(
name|rctrl
operator|->
name|eventQueue
operator|==
name|NULL
operator|)
operator|==
operator|(
name|rctrl
operator|->
name|eq_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|rctrl
operator|->
name|eq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|event
operator|)
return|;
block|}
end_block

begin_comment
comment|/* enqueues a reconstruction event on the indicated queue */
end_comment

begin_function
name|void
name|rf_CauseReconEvent
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|,
name|arg
parameter_list|,
name|type
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|RF_Revent_t
name|type
decl_stmt|;
block|{
name|RF_ReconCtrl_t
modifier|*
name|rctrl
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
decl_stmt|;
name|RF_ReconEvent_t
modifier|*
name|event
init|=
name|GetReconEventDesc
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|RF_REVENT_BUFCLEAR
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|col
operator|!=
name|rctrl
operator|->
name|fcol
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|row
operator|>=
literal|0
operator|&&
name|row
operator|<=
name|raidPtr
operator|->
name|numRow
operator|&&
name|col
operator|>=
literal|0
operator|&&
name|col
operator|<=
name|raidPtr
operator|->
name|numCol
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|rctrl
operator|->
name|eq_mutex
argument_list|)
expr_stmt|;
comment|/* q null and count==0 must be equivalent conditions */
name|RF_ASSERT
argument_list|(
operator|(
name|rctrl
operator|->
name|eventQueue
operator|==
name|NULL
operator|)
operator|==
operator|(
name|rctrl
operator|->
name|eq_count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|event
operator|->
name|next
operator|=
name|rctrl
operator|->
name|eventQueue
expr_stmt|;
name|rctrl
operator|->
name|eventQueue
operator|=
name|event
expr_stmt|;
name|rctrl
operator|->
name|eq_count
operator|++
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|rctrl
operator|->
name|eq_mutex
argument_list|)
expr_stmt|;
name|DO_SIGNAL
argument_list|(
name|rctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* allocates and initializes a recon event descriptor */
end_comment

begin_function
specifier|static
name|RF_ReconEvent_t
modifier|*
name|GetReconEventDesc
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|,
name|arg
parameter_list|,
name|type
parameter_list|)
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_RowCol_t
name|col
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|RF_Revent_t
name|type
decl_stmt|;
block|{
name|RF_ReconEvent_t
modifier|*
name|t
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_revent_freelist
argument_list|,
name|t
argument_list|,
name|next
argument_list|,
operator|(
name|RF_ReconEvent_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|t
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|t
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeReconEventDesc
parameter_list|(
name|event
parameter_list|)
name|RF_ReconEvent_t
modifier|*
name|event
decl_stmt|;
block|{
name|RF_FREELIST_FREE
argument_list|(
name|rf_revent_freelist
argument_list|,
name|event
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

