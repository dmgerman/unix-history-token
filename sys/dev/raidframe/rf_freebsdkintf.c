begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Scott Long<scottl@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*	$NetBSD: rf_netbsdkintf.c,v 1.105 2001/04/05 02:48:51 oster Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1996, 1997, 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Greg Oster; Jason R. Thorpe.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990, 1993  *      The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Utah $Hdr: cd.c 1.6 90/11/28$  *  *      @(#)cd.c        8.2 (Berkeley) 11/16/93  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Mark Holland, Jim Zelenka  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/***********************************************************  *  * rf_kintf.c -- the kernel interface routines for RAIDframe  *  ***********************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|"opt_raid.h"
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raidframe.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_copyback.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagflags.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_options.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugprint.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_configure.h>
end_include

begin_macro
name|RF_DECLARE_STATIC_MUTEX
argument_list|(
argument|rf_sparet_wait_mutex
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|RF_SparetWait_t
modifier|*
name|rf_sparet_wait_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requests to install a 						 * spare table */
end_comment

begin_decl_stmt
specifier|static
name|RF_SparetWait_t
modifier|*
name|rf_sparet_resp_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* responses from 						 * installation process */
end_comment

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|KernelWakeupFunc
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|InitBP
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|unsigned
name|rw_flag
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|RF_SectorNum_t
name|startSect
parameter_list|,
name|RF_SectorCount_t
name|numSect
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|void
function_decl|(
modifier|*
name|cbFunc
function_decl|)
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbArg
parameter_list|,
name|int
name|logBytesPerSector
parameter_list|,
name|struct
name|proc
modifier|*
name|b_proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|raid_softc
modifier|*
name|raidinit
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|rf_search_label
argument_list|(
name|dev_t
argument_list|,
expr|struct
name|disklabel
operator|*
argument_list|,
name|RF_AutoConfig_t
operator|*
operator|*
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|raid_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|raidattach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|disk_open_t
name|raidopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|disk_close_t
name|raidclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|disk_ioctl_t
name|raidioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|disk_strategy_t
name|raidstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_open_t
name|raidctlopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_close_t
name|raidctlclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_ioctl_t
name|raidctlioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|raidctl_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|raidctlopen
block|,
operator|.
name|d_close
operator|=
name|raidctlclose
block|,
operator|.
name|d_ioctl
operator|=
name|raidctlioctl
block|,
operator|.
name|d_name
operator|=
literal|"raidctl"
block|,
operator|.
name|d_maj
operator|=
literal|201
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pilfered from ccd.c  */
end_comment

begin_struct
struct|struct
name|raidbuf
block|{
name|struct
name|bio
name|rf_buf
decl_stmt|;
comment|/* new I/O buf.  MUST BE FIRST!!! */
name|struct
name|bio
modifier|*
name|rf_obp
decl_stmt|;
comment|/* ptr. to original I/O buf */
name|int
name|rf_flags
decl_stmt|;
comment|/* misc. flags */
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
comment|/* the request that this was part of.. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RAIDGETBUF
parameter_list|(
name|sc
parameter_list|)
value|uma_zalloc((sc)->sc_cbufpool, M_NOWAIT)
end_define

begin_define
define|#
directive|define
name|RAIDPUTBUF
parameter_list|(
name|sc
parameter_list|,
name|cbp
parameter_list|)
value|uma_zfree((sc)->sc_cbufpool, cbp)
end_define

begin_define
define|#
directive|define
name|RF_MAX_ARRAYS
value|32
end_define

begin_comment
comment|/* Raid control device */
end_comment

begin_struct
struct|struct
name|raidctl_softc
block|{
name|dev_t
name|sc_dev
decl_stmt|;
comment|/* Device node */
name|int
name|sc_flags
decl_stmt|;
comment|/* flags */
name|int
name|sc_numraid
decl_stmt|;
comment|/* Number of configured raid devices */
name|struct
name|raid_softc
modifier|*
name|sc_raiddevs
index|[
name|RF_MAX_ARRAYS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|raid_softc
block|{
name|dev_t
name|sc_parent_dev
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
comment|/* flags */
name|int
name|sc_busycount
decl_stmt|;
comment|/* How many times are we opened? */
name|size_t
name|sc_size
decl_stmt|;
comment|/* size of the raid device */
name|dev_t
name|sc_parent
decl_stmt|;
comment|/* Parent device */
name|struct
name|disk
name|sc_disk
decl_stmt|;
comment|/* generic disk device info */
name|uma_zone_t
name|sc_cbufpool
decl_stmt|;
comment|/* component buffer pool */
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
comment|/* Raid information struct */
name|struct
name|bio_queue_head
name|bio_queue
decl_stmt|;
comment|/* used for the device queue */
block|}
struct|;
end_struct

begin_comment
comment|/* sc_flags */
end_comment

begin_define
define|#
directive|define
name|RAIDF_OPEN
value|0x01
end_define

begin_comment
comment|/* unit has been initialized */
end_comment

begin_define
define|#
directive|define
name|RAIDF_WLABEL
value|0x02
end_define

begin_comment
comment|/* label area is writable */
end_comment

begin_define
define|#
directive|define
name|RAIDF_LABELLING
value|0x04
end_define

begin_comment
comment|/* unit is currently being labelled */
end_comment

begin_define
define|#
directive|define
name|RAIDF_WANTED
value|0x40
end_define

begin_comment
comment|/* someone is waiting to obtain a lock */
end_comment

begin_define
define|#
directive|define
name|RAIDF_LOCKED
value|0x80
end_define

begin_comment
comment|/* unit is locked */
end_comment

begin_comment
comment|/*   * Allow RAIDOUTSTANDING number of simultaneous IO's to this RAID device.   * Be aware that large numbers can allow the driver to consume a lot of   * kernel memory, especially on writes, and in degraded mode reads.  *   * For example: with a stripe width of 64 blocks (32k) and 5 disks,   * a single 64K write will typically require 64K for the old data,   * 64K for the old parity, and 64K for the new parity, for a total   * of 192K (if the parity buffer is not re-used immediately).  * Even it if is used immedately, that's still 128K, which when multiplied  * by say 10 requests, is 1280K, *on top* of the 640K of incoming data.  *   * Now in degraded mode, for example, a 64K read on the above setup may  * require data reconstruction, which will require *all* of the 4 remaining   * disks to participate -- 4 * 32K/disk == 128K again.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RAIDOUTSTANDING
end_ifndef

begin_define
define|#
directive|define
name|RAIDOUTSTANDING
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|raidgetdefaultlabel
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|struct
name|raid_softc
modifier|*
parameter_list|,
name|struct
name|disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|raidlock
parameter_list|(
name|struct
name|raid_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|raidunlock
parameter_list|(
name|struct
name|raid_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_markalldirty
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dev_t
name|raidctl_dev
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|rf_ReconThread
parameter_list|(
name|struct
name|rf_recon_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX what I want is: */
end_comment

begin_comment
comment|/*void rf_ReconThread(RF_Raid_t *raidPtr);  */
end_comment

begin_function_decl
name|void
name|rf_RewriteParityThread
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rf_CopybackThread
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rf_ReconstructInPlaceThread
parameter_list|(
name|struct
name|rf_recon_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rf_buildroothack
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|raidctl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RF_AutoConfig_t
modifier|*
name|rf_find_raid_components
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|RF_ConfigSet_t
modifier|*
name|rf_create_auto_sets
parameter_list|(
name|RF_AutoConfig_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_does_it_fit
parameter_list|(
name|RF_ConfigSet_t
modifier|*
parameter_list|,
name|RF_AutoConfig_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rf_reasonable_label
parameter_list|(
name|RF_ComponentLabel_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rf_create_configuration
parameter_list|(
name|RF_AutoConfig_t
modifier|*
parameter_list|,
name|RF_Config_t
modifier|*
parameter_list|,
name|RF_Raid_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rf_set_autoconfig
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rf_set_rootpartition
parameter_list|(
name|RF_Raid_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rf_release_all_vps
parameter_list|(
name|RF_ConfigSet_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rf_cleanup_config_set
parameter_list|(
name|RF_ConfigSet_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rf_have_enough_components
parameter_list|(
name|RF_ConfigSet_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rf_auto_config_set
parameter_list|(
name|RF_ConfigSet_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|raidctl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|raidgetunit
parameter_list|(
name|struct
name|raidctl_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|raidshutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|raidattach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
init|=
name|NULL
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|ac_list
decl_stmt|;
comment|/* autoconfig list */
name|RF_ConfigSet_t
modifier|*
name|config_sets
decl_stmt|;
name|int
name|autoconfig
init|=
literal|0
decl_stmt|;
comment|/* This is where all the initialization stuff gets done. */
if|if
condition|(
name|rf_mutex_init
argument_list|(
operator|&
name|rf_sparet_wait_mutex
argument_list|,
name|__FUNCTION__
argument_list|)
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"RAIDframe: failed to initialize mutexes\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rf_sparet_wait_queue
operator|=
name|rf_sparet_resp_queue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rf_BootRaidframe
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Serious error booting RAIDframe!!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Kernelized RAIDframe activated\n"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|parent_sc
argument_list|,
expr|struct
name|raidctl_softc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parent_sc
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_sc
operator|==
name|NULL
condition|)
block|{
name|RF_PANIC
argument_list|()
expr_stmt|;
return|return;
block|}
name|parent_sc
operator|->
name|sc_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|raidctl_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"raidctl"
argument_list|)
expr_stmt|;
name|parent_sc
operator|->
name|sc_dev
operator|->
name|si_drv1
operator|=
name|parent_sc
expr_stmt|;
name|raidctl_dev
operator|=
name|parent_sc
operator|->
name|sc_dev
expr_stmt|;
if|#
directive|if
name|RAID_AUTOCONFIG
name|autoconfig
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|autoconfig
condition|)
block|{
comment|/* 1. locate all RAID components on the system */
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Searching for raid components...\n"
argument_list|)
expr_stmt|;
name|ac_list
operator|=
name|rf_find_raid_components
argument_list|()
expr_stmt|;
if|if
condition|(
name|ac_list
operator|==
name|NULL
condition|)
return|return;
comment|/* 2. sort them into their respective sets */
name|config_sets
operator|=
name|rf_create_auto_sets
argument_list|(
name|ac_list
argument_list|)
expr_stmt|;
comment|/* 3. evaluate each set and configure the valid ones 		   This gets done in rf_buildroothack() */
comment|/* schedule the creation of the thread to do the  		   "/ on RAID" stuff */
name|rf_buildroothack
argument_list|(
name|config_sets
argument_list|,
name|parent_sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|kthread_create(rf_buildroothack,config_sets);
endif|#
directive|endif
comment|/* RAID_AUTOCONFIG */
block|}
block|}
end_function

begin_function
name|void
name|rf_buildroothack
parameter_list|(
name|arg
parameter_list|,
name|parent_sc
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
decl_stmt|;
block|{
name|RF_ConfigSet_t
modifier|*
name|config_sets
init|=
name|arg
decl_stmt|;
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
name|RF_ConfigSet_t
modifier|*
name|next_cset
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|int
name|raidID
decl_stmt|;
name|int
name|rootID
decl_stmt|;
name|int
name|num_root
decl_stmt|;
name|rootID
operator|=
literal|0
expr_stmt|;
name|num_root
operator|=
literal|0
expr_stmt|;
name|cset
operator|=
name|config_sets
expr_stmt|;
while|while
condition|(
name|cset
operator|!=
name|NULL
condition|)
block|{
name|next_cset
operator|=
name|cset
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|rf_have_enough_components
argument_list|(
name|cset
argument_list|)
operator|&&
name|cset
operator|->
name|ac
operator|->
name|clabel
operator|->
name|autoconfigure
operator|==
literal|1
condition|)
block|{
name|retcode
operator|=
name|rf_auto_config_set
argument_list|(
name|cset
argument_list|,
operator|&
name|raidID
argument_list|,
name|parent_sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retcode
condition|)
block|{
if|if
condition|(
name|cset
operator|->
name|rootable
condition|)
block|{
name|rootID
operator|=
name|raidID
expr_stmt|;
name|num_root
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The autoconfig didn't work :( */
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Autoconfig failed with code %d"
literal|"for raid%d\n"
argument_list|,
name|retcode
argument_list|,
name|raidID
argument_list|)
expr_stmt|;
name|rf_release_all_vps
argument_list|(
name|cset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* we're not autoconfiguring this set...   			   release the associated resources */
name|rf_release_all_vps
argument_list|(
name|cset
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup */
name|rf_cleanup_config_set
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|cset
operator|=
name|next_cset
expr_stmt|;
block|}
if|if
condition|(
name|boothowto
operator|&
name|RB_ASKNAME
condition|)
block|{
comment|/* We don't auto-config... */
block|}
else|else
block|{
comment|/* They didn't ask, and we found something bootable... */
if|#
directive|if
literal|0
block|if (num_root == 1) { 			booted_device =&raidrootdev[rootID];  		} else if (num_root> 1) {
comment|/* we can't guess.. require the user to answer... */
block|boothowto |= RB_ASKNAME; 		}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|int
name|raidctlopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
decl_stmt|;
name|parent_sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
operator|(
name|parent_sc
operator|->
name|sc_flags
operator|&
name|RAIDF_OPEN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|parent_sc
operator|->
name|sc_flags
operator||=
name|RAIDF_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|raidctlclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
decl_stmt|;
name|parent_sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|parent_sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RAIDF_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|raidctlioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
decl_stmt|;
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|RF_Config_t
modifier|*
name|u_cfg
decl_stmt|,
modifier|*
name|k_cfg
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|u_char
modifier|*
name|specific_buf
decl_stmt|;
name|u_int
name|unit
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|parent_sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* configure the system */
case|case
name|RAIDFRAME_CONFIGURE
case|:
comment|/* copy-in the configuration information */
comment|/* data points to a pointer to the configuration structure */
name|u_cfg
operator|=
operator|*
operator|(
operator|(
name|RF_Config_t
operator|*
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|,
operator|(
name|RF_Config_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k_cfg
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|retcode
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|u_cfg
argument_list|,
operator|(
name|caddr_t
operator|)
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|RF_Free
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"raidctlioctl: retcode=%d copyin.1\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
comment|/* allocate a buffer for the layout-specific data, and copy it 		 * in */
if|if
condition|(
name|k_cfg
operator|->
name|layoutSpecificSize
condition|)
block|{
if|if
condition|(
name|k_cfg
operator|->
name|layoutSpecificSize
operator|>
literal|10000
condition|)
block|{
comment|/* sanity check */
name|RF_Free
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|RF_Malloc
argument_list|(
name|specific_buf
argument_list|,
name|k_cfg
operator|->
name|layoutSpecificSize
argument_list|,
operator|(
name|u_char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|specific_buf
operator|==
name|NULL
condition|)
block|{
name|RF_Free
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|retcode
operator|=
name|copyin
argument_list|(
name|k_cfg
operator|->
name|layoutSpecific
argument_list|,
operator|(
name|caddr_t
operator|)
name|specific_buf
argument_list|,
name|k_cfg
operator|->
name|layoutSpecificSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|RF_Free
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|specific_buf
argument_list|,
name|k_cfg
operator|->
name|layoutSpecificSize
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"raidctlioctl: retcode=%d "
literal|"copyin.2\n"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
block|}
else|else
name|specific_buf
operator|=
name|NULL
expr_stmt|;
name|k_cfg
operator|->
name|layoutSpecific
operator|=
name|specific_buf
expr_stmt|;
comment|/* should do some kind of sanity check on the configuration. 		 * Store the sum of all the bytes in the last byte? */
comment|/* configure the system */
name|RF_Malloc
argument_list|(
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|raidPtr
argument_list|)
argument_list|,
operator|(
name|RF_Raid_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"No memory for raid device\n"
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|ENOMEM
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Raid_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Request a unit number for this soon-to-be device. */
name|unit
operator|=
name|raidgetunit
argument_list|(
name|parent_sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Cannot allocate raid unit\n"
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|raidPtr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|raidPtr
operator|->
name|raidid
operator|=
name|unit
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|rf_Configure
argument_list|(
name|raidPtr
argument_list|,
name|k_cfg
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* allow this many simultaneous IO's to  			   this RAID device */
name|raidPtr
operator|->
name|openings
operator|=
name|RAIDOUTSTANDING
expr_stmt|;
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|unit
index|]
operator|=
name|raidinit
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Could not create raid device\n"
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|raidPtr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|parent_sc
operator|->
name|sc_numraid
operator|++
expr_stmt|;
operator|(
operator|(
expr|struct
name|raid_softc
operator|*
operator|)
name|raidPtr
operator|->
name|sc
operator|)
operator|->
name|sc_parent_dev
operator|=
name|dev
expr_stmt|;
name|rf_markalldirty
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|RF_Free
argument_list|(
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|raidPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* free the buffers.  No return code here. */
if|if
condition|(
name|k_cfg
operator|->
name|layoutSpecificSize
condition|)
block|{
name|RF_Free
argument_list|(
name|specific_buf
argument_list|,
name|k_cfg
operator|->
name|layoutSpecificSize
argument_list|)
expr_stmt|;
block|}
name|RF_Free
argument_list|(
name|k_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAIDFRAME_SHUTDOWN
case|:
name|unit
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|>=
name|RF_MAX_ARRAYS
operator|)
operator|||
operator|(
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|unit
index|]
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|raidlock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|retcode
operator|)
return|;
comment|/* 		 * If somebody has a partition mounted, we shouldn't 		 * shutdown. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RAIDF_OPEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|raidunlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Shutting down RAIDframe engine\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_Shutdown
argument_list|(
name|sc
operator|->
name|raidPtr
argument_list|)
expr_stmt|;
name|RF_THREADGROUP_WAIT_STOP
argument_list|(
operator|&
name|sc
operator|->
name|raidPtr
operator|->
name|engine_tg
argument_list|)
expr_stmt|;
name|disk_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_disk
argument_list|)
expr_stmt|;
name|raidunlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX Need to be able to destroy the zone */
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_cbufpool
argument_list|)
expr_stmt|;
name|parent_sc
operator|->
name|sc_numraid
operator|--
expr_stmt|;
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|RF_Free
argument_list|(
name|sc
operator|->
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|raidPtr
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retcode
operator|=
name|ENOIOCTL
expr_stmt|;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|raidopen
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|dp
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|raidlock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dp
operator|=
operator|&
name|sc
operator|->
name|sc_disk
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Opening raid device %s%d\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_unit
argument_list|)
expr_stmt|;
comment|/* Generate overall disklabel */
name|raidgetdefaultlabel
argument_list|(
name|sc
operator|->
name|raidPtr
argument_list|,
name|sc
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_busycount
operator|==
literal|0
condition|)
block|{
comment|/* First one... mark things as dirty... Note that we *MUST* 		 have done a configure before this.  I DO NOT WANT TO BE 		 SCRIBBLING TO RANDOM COMPONENTS UNTIL IT'S BEEN DETERMINED 		 THAT THEY BELONG TOGETHER!!!!! */
comment|/* XXX should check to see if we're only open for reading 		   here... If so, we needn't do this, but then need some 		   other way of keeping track of what's happened.. */
name|rf_markalldirty
argument_list|(
name|sc
operator|->
name|raidPtr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|RAIDF_OPEN
expr_stmt|;
block|}
comment|/* Prevent this unit from being unconfigured while open. */
name|sc
operator|->
name|sc_busycount
operator|++
expr_stmt|;
name|raidunlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|raidclose
parameter_list|(
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|dp
operator|->
name|d_drv1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|raidlock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|sc_busycount
operator|--
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_busycount
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RAIDF_OPEN
expr_stmt|;
name|rf_update_component_labels
argument_list|(
name|sc
operator|->
name|raidPtr
argument_list|,
name|RF_FINAL_COMPONENT_UPDATE
argument_list|)
expr_stmt|;
block|}
name|raidunlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|raidstrategy
parameter_list|(
name|bp
parameter_list|)
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|struct
name|raid_softc
modifier|*
name|sc
init|=
name|bp
operator|->
name|bio_disk
operator|->
name|d_drv1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|raidPtr
operator|=
name|sc
operator|->
name|raidPtr
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|==
name|NULL
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|ENODEV
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|valid
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|ENODEV
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"b_bcount is zero..\n"
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
comment|/* stuff it onto our queue. XXX locking? */
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|raidstart
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|raidioctl
parameter_list|(
name|dp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|td
parameter_list|)
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
name|diskPtr
decl_stmt|;
name|RF_AccTotals_t
modifier|*
name|totals
decl_stmt|;
name|RF_DeviceConfig_t
modifier|*
name|d_cfg
decl_stmt|,
modifier|*
modifier|*
name|ucfgp
decl_stmt|;
name|struct
name|rf_recon_req
modifier|*
name|rrcopy
decl_stmt|,
modifier|*
name|rr
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|ci_label
decl_stmt|;
name|RF_SingleComponent_t
modifier|*
name|sparePtr
decl_stmt|,
modifier|*
name|componentPtr
decl_stmt|;
name|RF_SingleComponent_t
modifier|*
name|hot_spare
decl_stmt|,
modifier|*
name|component
decl_stmt|;
name|RF_ProgressInfo_t
name|progressInfo
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|row
decl_stmt|,
name|column
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|d
decl_stmt|;
name|sc
operator|=
name|dp
operator|->
name|d_drv1
expr_stmt|;
name|raidPtr
operator|=
name|sc
operator|->
name|raidPtr
expr_stmt|;
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"raidioctl: %s%d %ld\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RAIDFRAME_GET_COMPONENT_LABEL
case|:
comment|/* need to read the component label for the disk indicated 		   by row,column in clabel */
comment|/* For practice, let's get it directly fromdisk, rather  		   than from the in-core copy */
name|RF_Malloc
argument_list|(
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|=
name|clabel
operator|->
name|row
expr_stmt|;
name|column
operator|=
name|clabel
operator|->
name|column
expr_stmt|;
if|if
condition|(
operator|(
name|row
operator|<
literal|0
operator|)
operator|||
operator|(
name|row
operator|>=
name|raidPtr
operator|->
name|numRow
operator|)
operator|||
operator|(
name|column
operator|<
literal|0
operator|)
operator|||
operator|(
name|column
operator|>=
name|raidPtr
operator|->
name|numCol
operator|+
name|raidPtr
operator|->
name|numSpare
operator|)
condition|)
block|{
name|RF_Free
argument_list|(
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|ci_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|clabel
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_SET_COMPONENT_LABEL
case|:
name|clabel
operator|=
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
name|data
expr_stmt|;
comment|/* XXX check the label for valid stuff... */
comment|/* Note that some things *should not* get modified -- 		   the user should be re-initing the labels instead of  		   trying to patch things. 		   */
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Got component label:\n"
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Version: %d\n"
argument_list|,
name|clabel
operator|->
name|version
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Serial Number: %d\n"
argument_list|,
name|clabel
operator|->
name|serial_number
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Mod counter: %d\n"
argument_list|,
name|clabel
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Row: %d\n"
argument_list|,
name|clabel
operator|->
name|row
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Column: %d\n"
argument_list|,
name|clabel
operator|->
name|column
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Num Rows: %d\n"
argument_list|,
name|clabel
operator|->
name|num_rows
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Num Columns: %d\n"
argument_list|,
name|clabel
operator|->
name|num_columns
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Clean: %d\n"
argument_list|,
name|clabel
operator|->
name|clean
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Status: %d\n"
argument_list|,
name|clabel
operator|->
name|status
argument_list|)
expr_stmt|;
name|row
operator|=
name|clabel
operator|->
name|row
expr_stmt|;
name|column
operator|=
name|clabel
operator|->
name|column
expr_stmt|;
if|if
condition|(
operator|(
name|row
operator|<
literal|0
operator|)
operator|||
operator|(
name|row
operator|>=
name|raidPtr
operator|->
name|numRow
operator|)
operator|||
operator|(
name|column
operator|<
literal|0
operator|)
operator|||
operator|(
name|column
operator|>=
name|raidPtr
operator|->
name|numCol
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* XXX this isn't allowed to do anything for now :-) */
comment|/* XXX and before it is, we need to fill in the rest 		   of the fields!?!?!?! */
if|#
directive|if
literal|0
block|raidwrite_component_label(                              raidPtr->Disks[row][column].dev,  			    raidPtr->raid_cinfo[row][column].ci_vp,  			    clabel );
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_INIT_LABELS
case|:
name|MALLOC
argument_list|(
name|ci_label
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|clabel
operator|=
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
name|data
expr_stmt|;
comment|/*  		   we only want the serial number from 		   the above.  We get all the rest of the information 		   from the config that was used to create this RAID 		   set.  		   */
name|raidPtr
operator|->
name|serial_number
operator|=
name|clabel
operator|->
name|serial_number
expr_stmt|;
name|raid_init_component_label
argument_list|(
name|raidPtr
argument_list|,
name|ci_label
argument_list|)
expr_stmt|;
name|ci_label
operator|->
name|serial_number
operator|=
name|clabel
operator|->
name|serial_number
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|row
operator|++
control|)
block|{
name|ci_label
operator|->
name|row
operator|=
name|row
expr_stmt|;
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|column
operator|++
control|)
block|{
name|diskPtr
operator|=
operator|&
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|RF_DEAD_DISK
argument_list|(
name|diskPtr
operator|->
name|status
argument_list|)
condition|)
block|{
name|ci_label
operator|->
name|partitionSize
operator|=
name|diskPtr
operator|->
name|partitionSize
expr_stmt|;
name|ci_label
operator|->
name|column
operator|=
name|column
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|ci_vp
argument_list|,
name|ci_label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|FREE
argument_list|(
name|ci_label
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_SET_AUTOCONFIG
case|:
name|d
operator|=
name|rf_set_autoconfig
argument_list|(
name|raidPtr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"New autoconfig value is: %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_SET_ROOT
case|:
name|d
operator|=
name|rf_set_rootpartition
argument_list|(
name|raidPtr
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"New rootpartition value is: %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
comment|/* initialize all parity */
case|case
name|RAIDFRAME_REWRITEPARITY
case|:
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* Parity for RAID 0 is trivially correct */
name|raidPtr
operator|->
name|parity_good
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|parity_rewrite_in_progress
operator|==
literal|1
condition|)
block|{
comment|/* Re-write is already in progress! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|retcode
operator|=
name|RF_CREATE_THREAD
argument_list|(
name|raidPtr
operator|->
name|parity_rewrite_thread
argument_list|,
name|rf_RewriteParityThread
argument_list|,
name|raidPtr
argument_list|,
literal|"raid_parity"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_ADD_HOT_SPARE
case|:
name|MALLOC
argument_list|(
name|hot_spare
argument_list|,
name|RF_SingleComponent_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sparePtr
operator|=
operator|(
name|RF_SingleComponent_t
operator|*
operator|)
name|data
expr_stmt|;
name|memcpy
argument_list|(
name|hot_spare
argument_list|,
name|sparePtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_add_hot_spare
argument_list|(
name|raidPtr
argument_list|,
name|hot_spare
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hot_spare
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_REMOVE_HOT_SPARE
case|:
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_DELETE_COMPONENT
case|:
name|MALLOC
argument_list|(
name|component
argument_list|,
name|RF_SingleComponent_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|componentPtr
operator|=
operator|(
name|RF_SingleComponent_t
operator|*
operator|)
name|data
expr_stmt|;
name|memcpy
argument_list|(
name|component
argument_list|,
name|componentPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_delete_component
argument_list|(
name|raidPtr
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_INCORPORATE_HOT_SPARE
case|:
name|MALLOC
argument_list|(
name|component
argument_list|,
name|RF_SingleComponent_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|componentPtr
operator|=
operator|(
name|RF_SingleComponent_t
operator|*
operator|)
name|data
expr_stmt|;
name|memcpy
argument_list|(
name|component
argument_list|,
name|componentPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|rf_incorporate_hot_spare
argument_list|(
name|raidPtr
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_REBUILD_IN_PLACE
case|:
name|MALLOC
argument_list|(
name|component
argument_list|,
name|RF_SingleComponent_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* Can't do this on a RAID 0!! */
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|recon_in_progress
operator|==
literal|1
condition|)
block|{
comment|/* a reconstruct is already in progress! */
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|componentPtr
operator|=
operator|(
name|RF_SingleComponent_t
operator|*
operator|)
name|data
expr_stmt|;
name|memcpy
argument_list|(
name|component
argument_list|,
name|componentPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_SingleComponent_t
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|=
name|component
operator|->
name|row
expr_stmt|;
name|column
operator|=
name|component
operator|->
name|column
expr_stmt|;
name|unit
operator|=
name|raidPtr
operator|->
name|raidid
expr_stmt|;
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"raid%d Rebuild: %d %d\n"
argument_list|,
name|unit
argument_list|,
name|row
argument_list|,
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|row
operator|<
literal|0
operator|)
operator|||
operator|(
name|row
operator|>=
name|raidPtr
operator|->
name|numRow
operator|)
operator|||
operator|(
name|column
operator|<
literal|0
operator|)
operator|||
operator|(
name|column
operator|>=
name|raidPtr
operator|->
name|numCol
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|RF_Malloc
argument_list|(
name|rrcopy
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrcopy
argument_list|)
argument_list|,
operator|(
expr|struct
name|rf_recon_req
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrcopy
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rrcopy
operator|->
name|raidPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|raidPtr
expr_stmt|;
name|rrcopy
operator|->
name|row
operator|=
name|row
expr_stmt|;
name|rrcopy
operator|->
name|col
operator|=
name|column
expr_stmt|;
name|retcode
operator|=
name|RF_CREATE_THREAD
argument_list|(
name|raidPtr
operator|->
name|recon_thread
argument_list|,
name|rf_ReconstructInPlaceThread
argument_list|,
name|rrcopy
argument_list|,
literal|"raid_reconip"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|component
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_GET_UNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|raidPtr
operator|->
name|raidid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_GET_INFO
case|:
if|if
condition|(
operator|!
name|raidPtr
operator|->
name|valid
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|ucfgp
operator|=
operator|(
name|RF_DeviceConfig_t
operator|*
operator|*
operator|)
name|data
expr_stmt|;
name|RF_Malloc
argument_list|(
name|d_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeviceConfig_t
argument_list|)
argument_list|,
operator|(
name|RF_DeviceConfig_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeviceConfig_t
argument_list|)
argument_list|)
expr_stmt|;
name|d_cfg
operator|->
name|rows
operator|=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|d_cfg
operator|->
name|cols
operator|=
name|raidPtr
operator|->
name|numCol
expr_stmt|;
name|d_cfg
operator|->
name|ndevs
operator|=
name|raidPtr
operator|->
name|numRow
operator|*
name|raidPtr
operator|->
name|numCol
expr_stmt|;
if|if
condition|(
name|d_cfg
operator|->
name|ndevs
operator|>=
name|RF_MAX_DISKS
condition|)
block|{
name|RF_Free
argument_list|(
name|d_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeviceConfig_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|d_cfg
operator|->
name|nspares
operator|=
name|raidPtr
operator|->
name|numSpare
expr_stmt|;
if|if
condition|(
name|d_cfg
operator|->
name|nspares
operator|>=
name|RF_MAX_DISKS
condition|)
block|{
name|RF_Free
argument_list|(
name|d_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeviceConfig_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|d_cfg
operator|->
name|maxqdepth
operator|=
name|raidPtr
operator|->
name|maxQueueDepth
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_cfg
operator|->
name|rows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d_cfg
operator|->
name|cols
condition|;
name|j
operator|++
control|)
block|{
name|d_cfg
operator|->
name|devs
index|[
name|d
index|]
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
name|d_cfg
operator|->
name|cols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_cfg
operator|->
name|nspares
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|d_cfg
operator|->
name|spares
index|[
name|i
index|]
operator|=
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|retcode
operator|=
name|copyout
argument_list|(
name|d_cfg
argument_list|,
operator|*
name|ucfgp
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeviceConfig_t
argument_list|)
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|d_cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DeviceConfig_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_CHECK_PARITY
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|raidPtr
operator|->
name|parity_good
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_RESET_ACCTOTALS
case|:
name|bzero
argument_list|(
operator|&
name|raidPtr
operator|->
name|acc_totals
argument_list|,
sizeof|sizeof
argument_list|(
name|raidPtr
operator|->
name|acc_totals
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_GET_ACCTOTALS
case|:
name|totals
operator|=
operator|(
name|RF_AccTotals_t
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|totals
operator|=
name|raidPtr
operator|->
name|acc_totals
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_KEEP_ACCTOTALS
case|:
name|raidPtr
operator|->
name|keep_acc_totals
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_GET_SIZE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|raidPtr
operator|->
name|totalSectors
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* fail a disk& optionally start reconstruction */
case|case
name|RAIDFRAME_FAIL_DISK
case|:
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* Can't do this on a RAID 0!! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|rr
operator|=
operator|(
expr|struct
name|rf_recon_req
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|rr
operator|->
name|row
operator|<
literal|0
operator|||
name|rr
operator|->
name|row
operator|>=
name|raidPtr
operator|->
name|numRow
operator|||
name|rr
operator|->
name|col
operator|<
literal|0
operator|||
name|rr
operator|->
name|col
operator|>=
name|raidPtr
operator|->
name|numCol
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"%s%d: Failing the disk: row: %d col: %d\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_unit
argument_list|,
name|rr
operator|->
name|row
argument_list|,
name|rr
operator|->
name|col
argument_list|)
expr_stmt|;
comment|/* make a copy of the recon request so that we don't rely on 		 * the user's buffer */
name|RF_Malloc
argument_list|(
name|rrcopy
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrcopy
argument_list|)
argument_list|,
operator|(
expr|struct
name|rf_recon_req
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrcopy
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bcopy
argument_list|(
name|rr
argument_list|,
name|rrcopy
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr
argument_list|)
argument_list|)
expr_stmt|;
name|rrcopy
operator|->
name|raidPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|raidPtr
expr_stmt|;
name|retcode
operator|=
name|RF_CREATE_THREAD
argument_list|(
name|raidPtr
operator|->
name|recon_thread
argument_list|,
name|rf_ReconThread
argument_list|,
name|rrcopy
argument_list|,
literal|"raid_recon"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* invoke a copyback operation after recon on whatever disk 		 * needs it, if any */
case|case
name|RAIDFRAME_COPYBACK
case|:
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* This makes no sense on a RAID 0!! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|copyback_in_progress
operator|==
literal|1
condition|)
block|{
comment|/* Copyback is already in progress! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|retcode
operator|=
name|RF_CREATE_THREAD
argument_list|(
name|raidPtr
operator|->
name|copyback_thread
argument_list|,
name|rf_CopybackThread
argument_list|,
name|raidPtr
argument_list|,
literal|"raid_copyback"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
comment|/* return the percentage completion of reconstruction */
case|case
name|RAIDFRAME_CHECK_RECON_STATUS
case|:
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* This makes no sense on a RAID 0, so tell the 			   user it's done. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|row
operator|=
literal|0
expr_stmt|;
comment|/* XXX we only consider a single row... */
if|if
condition|(
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|!=
name|rf_rs_reconstructing
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|percentComplete
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_CHECK_RECON_STATUS_EXT
case|:
name|row
operator|=
literal|0
expr_stmt|;
comment|/* XXX we only consider a single row... */
if|if
condition|(
name|raidPtr
operator|->
name|status
index|[
name|row
index|]
operator|!=
name|rf_rs_reconstructing
condition|)
block|{
name|progressInfo
operator|.
name|remaining
operator|=
literal|0
expr_stmt|;
name|progressInfo
operator|.
name|completed
operator|=
literal|100
expr_stmt|;
name|progressInfo
operator|.
name|total
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|progressInfo
operator|.
name|total
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|numRUsTotal
expr_stmt|;
name|progressInfo
operator|.
name|completed
operator|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
operator|->
name|numRUsComplete
expr_stmt|;
name|progressInfo
operator|.
name|remaining
operator|=
name|progressInfo
operator|.
name|total
operator|-
name|progressInfo
operator|.
name|completed
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|progressInfo
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ProgressInfo_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_CHECK_PARITYREWRITE_STATUS
case|:
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* This makes no sense on a RAID 0, so tell the 			   user it's done. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|parity_rewrite_in_progress
operator|==
literal|1
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
operator|*
name|raidPtr
operator|->
name|parity_rewrite_stripes_done
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|numStripe
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_CHECK_PARITYREWRITE_STATUS_EXT
case|:
if|if
condition|(
name|raidPtr
operator|->
name|parity_rewrite_in_progress
operator|==
literal|1
condition|)
block|{
name|progressInfo
operator|.
name|total
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|numStripe
expr_stmt|;
name|progressInfo
operator|.
name|completed
operator|=
name|raidPtr
operator|->
name|parity_rewrite_stripes_done
expr_stmt|;
name|progressInfo
operator|.
name|remaining
operator|=
name|progressInfo
operator|.
name|total
operator|-
name|progressInfo
operator|.
name|completed
expr_stmt|;
block|}
else|else
block|{
name|progressInfo
operator|.
name|remaining
operator|=
literal|0
expr_stmt|;
name|progressInfo
operator|.
name|completed
operator|=
literal|100
expr_stmt|;
name|progressInfo
operator|.
name|total
operator|=
literal|100
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|progressInfo
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ProgressInfo_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
case|case
name|RAIDFRAME_CHECK_COPYBACK_STATUS
case|:
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* This makes no sense on a RAID 0 */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|copyback_in_progress
operator|==
literal|1
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
operator|*
name|raidPtr
operator|->
name|copyback_stripes_done
operator|/
name|raidPtr
operator|->
name|Layout
operator|.
name|numStripe
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|100
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RAIDFRAME_CHECK_COPYBACK_STATUS_EXT
case|:
if|if
condition|(
name|raidPtr
operator|->
name|copyback_in_progress
operator|==
literal|1
condition|)
block|{
name|progressInfo
operator|.
name|total
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|numStripe
expr_stmt|;
name|progressInfo
operator|.
name|completed
operator|=
name|raidPtr
operator|->
name|copyback_stripes_done
expr_stmt|;
name|progressInfo
operator|.
name|remaining
operator|=
name|progressInfo
operator|.
name|total
operator|-
name|progressInfo
operator|.
name|completed
expr_stmt|;
block|}
else|else
block|{
name|progressInfo
operator|.
name|remaining
operator|=
literal|0
expr_stmt|;
name|progressInfo
operator|.
name|completed
operator|=
literal|100
expr_stmt|;
name|progressInfo
operator|.
name|total
operator|=
literal|100
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|progressInfo
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ProgressInfo_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
comment|/* the sparetable daemon calls this to wait for the kernel to 		 * need a spare table. this ioctl does not return until a 		 * spare table is needed. XXX -- calling mpsleep here in the 		 * ioctl code is almost certainly wrong and evil. -- XXX XXX 		 * -- I should either compute the spare table in the kernel, 		 * or have a different -- XXX XXX -- interface (a different 		 * character device) for delivering the table     -- XXX */
if|#
directive|if
literal|0
block|case RAIDFRAME_SPARET_WAIT: 		RF_LOCK_MUTEX(rf_sparet_wait_mutex); 		while (!rf_sparet_wait_queue) 			mpsleep(&rf_sparet_wait_queue, (PZERO + 1) | PCATCH, "sparet wait", 0, (void *) simple_lock_addr(rf_sparet_wait_mutex), MS_LOCK_SIMPLE); 		waitreq = rf_sparet_wait_queue; 		rf_sparet_wait_queue = rf_sparet_wait_queue->next; 		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);
comment|/* structure assignment */
block|*((RF_SparetWait_t *) data) = *waitreq;	  		RF_Free(waitreq, sizeof(*waitreq)); 		return (0);
comment|/* wakes up a process waiting on SPARET_WAIT and puts an error 		 * code in it that will cause the dameon to exit */
block|case RAIDFRAME_ABORT_SPARET_WAIT: 		RF_Malloc(waitreq, sizeof(*waitreq), (RF_SparetWait_t *)); 		waitreq->fcol = -1; 		RF_LOCK_MUTEX(rf_sparet_wait_mutex); 		waitreq->next = rf_sparet_wait_queue; 		rf_sparet_wait_queue = waitreq; 		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex); 		wakeup(&rf_sparet_wait_queue); 		return (0);
comment|/* used by the spare table daemon to deliver a spare table 		 * into the kernel */
block|case RAIDFRAME_SEND_SPARET:
comment|/* install the spare table */
block|retcode = rf_SetSpareTable(raidPtr, *(void **) data);
comment|/* respond to the requestor.  the return status of the spare 		 * table installation is passed in the "fcol" field */
block|RF_Malloc(waitreq, sizeof(*waitreq), (RF_SparetWait_t *)); 		waitreq->fcol = retcode; 		RF_LOCK_MUTEX(rf_sparet_wait_mutex); 		waitreq->next = rf_sparet_resp_queue; 		rf_sparet_resp_queue = waitreq; 		wakeup(&rf_sparet_resp_queue); 		RF_UNLOCK_MUTEX(rf_sparet_wait_mutex);  		return (retcode);
endif|#
directive|endif
default|default:
name|retcode
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
comment|/* fall through to the os-specific code below */
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* raidinit -- complete the rest of the initialization for the    RAIDframe device.  */
end_comment

begin_function
specifier|static
name|struct
name|raid_softc
modifier|*
name|raidinit
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|RF_Malloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|raid_softc
argument_list|)
argument_list|,
operator|(
expr|struct
name|raid_softc
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"No memory for raid device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|raidPtr
operator|=
name|raidPtr
expr_stmt|;
comment|/* XXX Should check return code here */
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cbufpool
operator|=
name|uma_zcreate
argument_list|(
literal|"raidpl"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|raidbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX There may be a weird interaction here between this, and 	 * protectedSectors, as used in RAIDframe.  */
name|sc
operator|->
name|sc_size
operator|=
name|raidPtr
operator|->
name|totalSectors
expr_stmt|;
comment|/* Create the disk device */
name|sc
operator|->
name|sc_disk
operator|.
name|d_open
operator|=
name|raidopen
expr_stmt|;
name|sc
operator|->
name|sc_disk
operator|.
name|d_close
operator|=
name|raidclose
expr_stmt|;
name|sc
operator|->
name|sc_disk
operator|.
name|d_ioctl
operator|=
name|raidioctl
expr_stmt|;
name|sc
operator|->
name|sc_disk
operator|.
name|d_strategy
operator|=
name|raidstrategy
expr_stmt|;
name|sc
operator|->
name|sc_disk
operator|.
name|d_drv1
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_disk
operator|.
name|d_maxsize
operator|=
name|DFLTPHYS
expr_stmt|;
name|sc
operator|->
name|sc_disk
operator|.
name|d_name
operator|=
literal|"raid"
expr_stmt|;
name|disk_create
argument_list|(
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|&
name|sc
operator|->
name|sc_disk
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wake up the daemon& tell it to get us a spare table  * XXX  * the entries in the queues should be tagged with the raidPtr  * so that in the extremely rare case that two recons happen at once,   * we know for which device were requesting a spare table  * XXX  *   * XXX This code is not currently used. GO  */
end_comment

begin_function
name|int
name|rf_GetSpareTableFromDaemon
parameter_list|(
name|req
parameter_list|)
name|RF_SparetWait_t
modifier|*
name|req
decl_stmt|;
block|{
name|int
name|retcode
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|rf_sparet_wait_mutex
argument_list|)
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|rf_sparet_wait_queue
expr_stmt|;
name|rf_sparet_wait_queue
operator|=
name|req
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rf_sparet_wait_queue
argument_list|)
expr_stmt|;
comment|/* mpsleep unlocks the mutex */
while|while
condition|(
operator|!
name|rf_sparet_resp_queue
condition|)
block|{
name|tsleep
argument_list|(
operator|&
name|rf_sparet_resp_queue
argument_list|,
name|PRIBIO
argument_list|,
literal|"raidframe getsparetable"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|req
operator|=
name|rf_sparet_resp_queue
expr_stmt|;
name|rf_sparet_resp_queue
operator|=
name|req
operator|->
name|next
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|rf_sparet_wait_mutex
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|req
operator|->
name|fcol
expr_stmt|;
name|RF_Free
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this is not the same req as we 					 * alloc'd */
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* a wrapper around rf_DoAccess that extracts appropriate info from the   * bp& passes it down.  * any calls originating in the kernel must use non-blocking I/O  * do some extra sanity checking to return "appropriate" error values for  * certain conditions (to make some standard utilities work)  *   * Formerly known as: rf_DoAccessKernel  */
end_comment

begin_function
name|void
name|raidstart
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_SectorCount_t
name|num_blocks
decl_stmt|,
name|pb
decl_stmt|,
name|sum
decl_stmt|;
name|RF_RaidAddr_t
name|raid_addr
decl_stmt|;
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|blocknum
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|retcode
decl_stmt|,
name|do_async
decl_stmt|;
name|unit
operator|=
name|raidPtr
operator|->
name|raidid
expr_stmt|;
name|sc
operator|=
name|raidPtr
operator|->
name|sc
expr_stmt|;
comment|/* quick check to see if anything has died recently */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|numNewFailures
operator|>
literal|0
condition|)
block|{
name|raidPtr
operator|->
name|numNewFailures
operator|--
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|rf_update_component_labels
argument_list|(
name|raidPtr
argument_list|,
name|RF_NORMAL_COMPONENT_UPDATE
argument_list|)
expr_stmt|;
block|}
else|else
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* Check to see if we're at the limit... */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|raidPtr
operator|->
name|openings
operator|>
literal|0
condition|)
block|{
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* get the next item, if any, from the queue */
if|if
condition|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* nothing more to do */
return|return;
block|}
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|bio_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Ok, for the bp we have here, bp->b_blkno is relative to the 		 * partition.. Need to make it absolute to the underlying  		 * device.. */
name|blocknum
operator|=
name|bp
operator|->
name|bio_blkno
expr_stmt|;
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"Blocks: %ld, %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|,
operator|(
name|long
operator|)
name|blocknum
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"bp->bio_bcount = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"bp->bio_resid = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|bio_resid
argument_list|)
expr_stmt|;
comment|/* *THIS* is where we adjust what block we're going to...  		 * but DO NOT TOUCH bp->bio_blkno!!! */
name|raid_addr
operator|=
name|blocknum
expr_stmt|;
name|num_blocks
operator|=
name|bp
operator|->
name|bio_bcount
operator|>>
name|raidPtr
operator|->
name|logBytesPerSector
expr_stmt|;
name|pb
operator|=
operator|(
name|bp
operator|->
name|bio_bcount
operator|&
name|raidPtr
operator|->
name|sectorMask
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sum
operator|=
name|raid_addr
operator|+
name|num_blocks
operator|+
name|pb
expr_stmt|;
if|if
condition|(
name|rf_debugKernelAccess
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"raid_addr=0x%x sum=%d num_blocks=%d(+%d) "
literal|"(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|raid_addr
argument_list|,
operator|(
name|int
operator|)
name|sum
argument_list|,
operator|(
name|int
operator|)
name|num_blocks
argument_list|,
operator|(
name|int
operator|)
name|pb
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|bio_resid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sum
operator|>
name|raidPtr
operator|->
name|totalSectors
operator|)
operator|||
operator|(
name|sum
operator|<
name|raid_addr
operator|)
operator|||
operator|(
name|sum
operator|<
name|num_blocks
operator|)
operator|||
operator|(
name|sum
operator|<
name|pb
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|ENOSPC
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * XXX rf_DoAccess() should do this, not just DoAccessKernel() 		 */
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|&
name|raidPtr
operator|->
name|sectorMask
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"Calling DoAccess..\n"
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|openings
operator|--
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 		 * Everything is async. 		 */
name|do_async
operator|=
literal|1
expr_stmt|;
comment|/* XXX we're still at splbio() here... do we *really*  		   need to be? */
comment|/* don't ever condition on bp->bio_cmd& BIO_WRITE.   		 * always condition on BIO_READ instead */
name|retcode
operator|=
name|rf_DoAccess
argument_list|(
name|raidPtr
argument_list|,
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
operator|)
condition|?
name|RF_IO_TYPE_READ
else|:
name|RF_IO_TYPE_WRITE
argument_list|,
name|do_async
argument_list|,
name|raid_addr
argument_list|,
name|num_blocks
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RF_DAG_NONBLOCKING_IO
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* invoke an I/O from kernel mode.  Disk queue should be locked upon entry */
end_comment

begin_function
name|int
name|rf_DispatchKernelIO
parameter_list|(
name|queue
parameter_list|,
name|req
parameter_list|)
name|RF_DiskQueue_t
modifier|*
name|queue
decl_stmt|;
name|RF_DiskQueueData_t
modifier|*
name|req
decl_stmt|;
block|{
name|int
name|op
init|=
operator|(
name|req
operator|->
name|type
operator|==
name|RF_IO_TYPE_READ
operator|)
condition|?
name|BIO_READ
else|:
name|BIO_WRITE
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|raidbuf
modifier|*
name|raidbp
init|=
name|NULL
decl_stmt|;
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
comment|/* XXX along with the vnode, we also need the softc associated with 	 * this device.. */
name|req
operator|->
name|queue
operator|=
name|queue
expr_stmt|;
name|sc
operator|=
name|queue
operator|->
name|raidPtr
operator|->
name|sc
expr_stmt|;
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"DispatchKernelIO %s\n"
argument_list|,
name|sc
operator|->
name|sc_disk
operator|.
name|d_name
argument_list|)
expr_stmt|;
name|bp
operator|=
name|req
operator|->
name|bp
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX when there is a physical disk failure, someone is passing us a 	 * buffer that contains old stuff!!  Attempt to deal with this problem 	 * without taking a performance hit... (not sure where the real bug 	 * is.  It's buried in RAIDframe somewhere) :-(  GO ) */
if|if
condition|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ERROR
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|raidbp
operator|=
name|RAIDGETBUF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|raidbp
operator|->
name|rf_flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX not really used anywhere... */
comment|/* 	 * context for raidiodone 	 */
name|raidbp
operator|->
name|rf_obp
operator|=
name|bp
expr_stmt|;
name|raidbp
operator|->
name|req
operator|=
name|req
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|LIST_INIT(&raidbp->rf_buf.b_dep);
endif|#
directive|endif
switch|switch
condition|(
name|req
operator|->
name|type
condition|)
block|{
case|case
name|RF_IO_TYPE_NOP
case|:
comment|/* used primarily to unlock a locked queue */
comment|/* XXX need to do something extra here.. */
comment|/* I'm leaving this in, as I've never actually seen it used, 		 * and I'd like folks to report it... GO */
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"WAKEUP CALLED\n"
argument_list|)
expr_stmt|;
name|queue
operator|->
name|numOutstanding
operator|++
expr_stmt|;
comment|/* XXX need to glue the original buffer into this?  */
name|KernelWakeupFunc
argument_list|(
operator|&
name|raidbp
operator|->
name|rf_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RF_IO_TYPE_READ
case|:
case|case
name|RF_IO_TYPE_WRITE
case|:
if|if
condition|(
name|req
operator|->
name|tracerec
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|req
operator|->
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
name|InitBP
argument_list|(
operator|&
name|raidbp
operator|->
name|rf_buf
argument_list|,
name|queue
operator|->
name|rf_cinfo
operator|->
name|ci_vp
argument_list|,
name|op
operator||
name|bp
operator|->
name|bio_cmd
argument_list|,
name|queue
operator|->
name|rf_cinfo
operator|->
name|ci_dev
argument_list|,
name|req
operator|->
name|sectorOffset
argument_list|,
name|req
operator|->
name|numSector
argument_list|,
name|req
operator|->
name|buf
argument_list|,
name|KernelWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|req
argument_list|,
name|queue
operator|->
name|raidPtr
operator|->
name|logBytesPerSector
argument_list|,
name|req
operator|->
name|b_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_debugKernelAccess
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"dispatch: bp->bio_blkno = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|)
expr_stmt|;
block|}
name|queue
operator|->
name|numOutstanding
operator|++
expr_stmt|;
name|queue
operator|->
name|last_deq_sector
operator|=
name|req
operator|->
name|sectorOffset
expr_stmt|;
comment|/* acc wouldn't have been let in if there were any pending 		 * reqs at any other priority */
name|queue
operator|->
name|curPriority
operator|=
name|req
operator|->
name|priority
expr_stmt|;
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"Going for %c to %s%d row %d col %d\n"
argument_list|,
name|req
operator|->
name|type
argument_list|,
name|sc
operator|->
name|sc_disk
operator|.
name|d_name
argument_list|,
name|sc
operator|->
name|sc_disk
operator|.
name|d_unit
argument_list|,
name|queue
operator|->
name|row
argument_list|,
name|queue
operator|->
name|col
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"sector %d count %d (%d bytes) %d\n"
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|sectorOffset
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|numSector
argument_list|,
call|(
name|int
call|)
argument_list|(
name|req
operator|->
name|numSector
operator|<<
name|queue
operator|->
name|raidPtr
operator|->
name|logBytesPerSector
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|queue
operator|->
name|raidPtr
operator|->
name|logBytesPerSector
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|if ((raidbp->rf_buf.bio_cmd& BIO_READ) == 0) { 			raidbp->rf_buf.b_vp->v_numoutput++; 		}
endif|#
directive|endif
name|BIO_STRATEGY
argument_list|(
operator|&
name|raidbp
operator|->
name|rf_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad req->type in rf_DispatchKernelIO"
argument_list|)
expr_stmt|;
block|}
name|rf_printf
argument_list|(
literal|3
argument_list|,
literal|"Exiting from DispatchKernelIO\n"
argument_list|)
expr_stmt|;
comment|/* splx(s); */
comment|/* want to test this */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the callback function associated with an I/O invoked from    kernel code.  */
end_comment

begin_function
specifier|static
name|void
name|KernelWakeupFunc
parameter_list|(
name|vbp
parameter_list|)
name|struct
name|bio
modifier|*
name|vbp
decl_stmt|;
block|{
name|RF_DiskQueueData_t
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
name|RF_DiskQueue_t
modifier|*
name|queue
decl_stmt|;
name|struct
name|raidbuf
modifier|*
name|raidbp
init|=
operator|(
expr|struct
name|raidbuf
operator|*
operator|)
name|vbp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"recovering the request queue:\n"
argument_list|)
expr_stmt|;
name|req
operator|=
name|raidbp
operator|->
name|req
expr_stmt|;
name|bp
operator|=
name|raidbp
operator|->
name|rf_obp
expr_stmt|;
name|queue
operator|=
operator|(
name|RF_DiskQueue_t
operator|*
operator|)
name|req
operator|->
name|queue
expr_stmt|;
name|sc
operator|=
name|queue
operator|->
name|raidPtr
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|raidbp
operator|->
name|rf_buf
operator|.
name|bio_flags
operator|&
name|BIO_ERROR
condition|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|raidbp
operator|->
name|rf_buf
operator|.
name|bio_error
condition|?
name|raidbp
operator|->
name|rf_buf
operator|.
name|bio_error
else|:
name|EIO
expr_stmt|;
block|}
comment|/* XXX methinks this could be wrong... */
if|#
directive|if
literal|1
name|bp
operator|->
name|bio_resid
operator|=
name|raidbp
operator|->
name|rf_buf
operator|.
name|bio_resid
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|req
operator|->
name|tracerec
condition|)
block|{
name|RF_ETIMER_STOP
argument_list|(
name|req
operator|->
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|req
operator|->
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|rf_tracing_mutex
argument_list|)
expr_stmt|;
name|req
operator|->
name|tracerec
operator|->
name|diskwait_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|req
operator|->
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
name|req
operator|->
name|tracerec
operator|->
name|phys_io_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|req
operator|->
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
name|req
operator|->
name|tracerec
operator|->
name|num_phys_ios
operator|++
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|rf_tracing_mutex
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|bio_bcount
operator|=
name|raidbp
operator|->
name|rf_buf
operator|.
name|bio_bcount
expr_stmt|;
comment|/* XXXX ? */
comment|/* XXX Ok, let's get aggressive... If BIO_ERROR is set, let's go 	 * ballistic, and mark the component as hosed... */
if|if
condition|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ERROR
condition|)
block|{
comment|/* Mark the disk as dead */
comment|/* but only mark it once... */
if|if
condition|(
name|queue
operator|->
name|raidPtr
operator|->
name|Disks
index|[
name|queue
operator|->
name|row
index|]
index|[
name|queue
operator|->
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"%s%d: IO Error.  Marking %s as "
literal|"failed.\n"
argument_list|,
name|sc
operator|->
name|sc_disk
operator|.
name|d_name
argument_list|,
name|sc
operator|->
name|sc_disk
operator|.
name|d_unit
argument_list|,
name|queue
operator|->
name|raidPtr
operator|->
name|Disks
index|[
name|queue
operator|->
name|row
index|]
index|[
name|queue
operator|->
name|col
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
name|queue
operator|->
name|raidPtr
operator|->
name|Disks
index|[
name|queue
operator|->
name|row
index|]
index|[
name|queue
operator|->
name|col
index|]
operator|.
name|status
operator|=
name|rf_ds_failed
expr_stmt|;
name|queue
operator|->
name|raidPtr
operator|->
name|status
index|[
name|queue
operator|->
name|row
index|]
operator|=
name|rf_rs_degraded
expr_stmt|;
name|queue
operator|->
name|raidPtr
operator|->
name|numFailures
operator|++
expr_stmt|;
name|queue
operator|->
name|raidPtr
operator|->
name|numNewFailures
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Disk is already dead... */
comment|/* printf("Disk already marked as dead!\n"); */
block|}
block|}
name|RAIDPUTBUF
argument_list|(
name|sc
argument_list|,
name|raidbp
argument_list|)
expr_stmt|;
name|rf_DiskIOComplete
argument_list|(
name|queue
argument_list|,
name|req
argument_list|,
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ERROR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
call|(
name|req
operator|->
name|CompleteFunc
call|)
argument_list|(
name|req
operator|->
name|argument
argument_list|,
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ERROR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialize a buf structure for doing an I/O in the kernel.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|InitBP
argument_list|(
name|bp
argument_list|,
name|b_vp
argument_list|,
name|rw_flag
argument_list|,
name|dev
argument_list|,
name|startSect
argument_list|,
name|numSect
argument_list|,
name|buf
argument_list|,
name|cbFunc
argument_list|,
name|cbArg
argument_list|,
name|logBytesPerSector
argument_list|,
name|b_proc
argument_list|)
decl|struct
name|bio
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|b_vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|rw_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_SectorNum_t
name|startSect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_SectorCount_t
name|numSect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|buf
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|cbFunc
function_decl|)
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|cbArg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logBytesPerSector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|b_proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* bp->b_flags       = B_PHYS | rw_flag; */
name|bp
operator|->
name|bio_cmd
operator|=
name|rw_flag
expr_stmt|;
comment|/* XXX need B_PHYS here too? */
name|bp
operator|->
name|bio_bcount
operator|=
name|numSect
operator|<<
name|logBytesPerSector
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|bp->bio_bufsize = bp->bio_bcount;
endif|#
directive|endif
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_dev
operator|=
name|dev
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|buf
expr_stmt|;
name|bp
operator|->
name|bio_blkno
operator|=
name|startSect
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
comment|/* XXX is this right!?!?!! */
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bp->bio_bcount is zero in InitBP!!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	bp->b_proc = b_proc; 	bp->b_vp = b_vp; */
name|bp
operator|->
name|bio_done
operator|=
name|cbFunc
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|raidgetdefaultlabel
parameter_list|(
name|raidPtr
parameter_list|,
name|sc
parameter_list|,
name|dp
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Building a default label...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"raidgetdefaultlabel(): dp is NULL\n"
argument_list|)
expr_stmt|;
comment|/* fabricate a label... */
name|dp
operator|->
name|d_mediasize
operator|=
name|raidPtr
operator|->
name|totalSectors
operator|*
name|raidPtr
operator|->
name|bytesPerSector
expr_stmt|;
name|dp
operator|->
name|d_sectorsize
operator|=
name|raidPtr
operator|->
name|bytesPerSector
expr_stmt|;
name|dp
operator|->
name|d_fwsectors
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|dataSectorsPerStripe
expr_stmt|;
name|dp
operator|->
name|d_fwheads
operator|=
literal|4
operator|*
name|raidPtr
operator|->
name|numCol
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup the provided name in the filesystem.  If the file exists,  * is a valid block device, and isn't being used by anyone else,  * set *vpp to the file's vnode.  * You'll find the original of this in ccd.c  */
end_comment

begin_function
name|int
name|raidlookup
parameter_list|(
name|path
parameter_list|,
name|td
parameter_list|,
name|vpp
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
comment|/* result */
block|{
name|struct
name|nameidata
modifier|*
name|nd
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|va
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|MALLOC
argument_list|(
name|nd
argument_list|,
expr|struct
name|nameidata
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nameidata
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|va
argument_list|,
expr|struct
name|vattr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vattr
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|==
name|NULL
operator|)
operator|||
operator|(
name|va
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Out of memory?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Sanity check the p_fd fields.  This is really just a hack */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|||
operator|!
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
condition|)
name|printf
argument_list|(
literal|"Warning: p_fd fields not set\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
condition|)
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|=
name|rootvnode
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
condition|)
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|=
name|rootvnode
expr_stmt|;
name|NDINIT
argument_list|(
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|path
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_open
argument_list|(
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rf_printf
argument_list|(
literal|2
argument_list|,
literal|"RAIDframe: vn_open returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|end1
goto|;
block|}
name|vp
operator|=
name|nd
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"raidlookup() vp->v_usecount= %d\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|va
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"raidlookup() VOP_GETATTR returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* XXX: eventually we should handle VREG, too. */
if|if
condition|(
name|va
operator|->
name|va_type
operator|!=
name|VCHR
condition|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Returning ENOTBLK\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTBLK
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|end
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|end1
label|:
name|FREE
argument_list|(
name|nd
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|va
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait interruptibly for an exclusive lock.  *  * XXX  * Several drivers do this; it should be abstracted and made MP-safe.  * (Hmm... where have we seen this warning before :->  GO )  */
end_comment

begin_function
specifier|static
name|int
name|raidlock
parameter_list|(
name|sc
parameter_list|)
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RAIDF_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|RAIDF_WANTED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"raidlck"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|RAIDF_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock and wake up any waiters.  */
end_comment

begin_function
specifier|static
name|void
name|raidunlock
parameter_list|(
name|sc
parameter_list|)
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RAIDF_LOCKED
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|RAIDF_WANTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|RAIDF_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|RF_COMPONENT_INFO_OFFSET
value|16384
end_define

begin_comment
comment|/* bytes */
end_comment

begin_define
define|#
directive|define
name|RF_COMPONENT_INFO_SIZE
value|1024
end_define

begin_comment
comment|/* bytes */
end_comment

begin_function
name|int
name|raidmarkclean
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|vnode
modifier|*
name|b_vp
parameter_list|,
name|int
name|mod_counter
parameter_list|)
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|MALLOC
argument_list|(
name|clabel
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"raidmarkclean: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|raidread_component_label
argument_list|(
name|dev
argument_list|,
name|b_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|clabel
operator|->
name|mod_counter
operator|=
name|mod_counter
expr_stmt|;
name|clabel
operator|->
name|clean
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|dev
argument_list|,
name|b_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|raidmarkdirty
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|vnode
modifier|*
name|b_vp
parameter_list|,
name|int
name|mod_counter
parameter_list|)
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|MALLOC
argument_list|(
name|clabel
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"raidmarkclean: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|raidread_component_label
argument_list|(
name|dev
argument_list|,
name|b_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|clabel
operator|->
name|mod_counter
operator|=
name|mod_counter
expr_stmt|;
name|clabel
operator|->
name|clean
operator|=
name|RF_RAID_DIRTY
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|dev
argument_list|,
name|b_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|raidread_component_label
parameter_list|(
name|dev
parameter_list|,
name|b_vp
parameter_list|,
name|clabel
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|vnode
modifier|*
name|b_vp
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* XXX should probably ensure that we don't try to do this if 	   someone has changed rf_protected_sectors. */
if|if
condition|(
name|b_vp
operator|==
name|NULL
condition|)
block|{
comment|/* For whatever reason, this component is not valid. 		   Don't try to read a component label from it. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* get a block of the appropriate size... */
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|RF_COMPONENT_INFO_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
comment|/* get our ducks in a row for the read */
name|bp
operator|->
name|b_blkno
operator|=
name|RF_COMPONENT_INFO_OFFSET
operator|/
name|DEV_BSIZE
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|RF_COMPONENT_INFO_SIZE
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|RF_COMPONENT_INFO_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
name|DEV_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|bufwait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|memcpy
argument_list|(
name|clabel
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|rf_print_component_label( clabel );
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
literal|0
block|rf_printf(0, "Failed to read RAID component label!\n");
endif|#
directive|endif
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|raidwrite_component_label
parameter_list|(
name|dev
parameter_list|,
name|b_vp
parameter_list|,
name|clabel
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|vnode
modifier|*
name|b_vp
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* get a block of the appropriate size... */
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|RF_COMPONENT_INFO_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
comment|/* get our ducks in a row for the write */
name|bp
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|RF_COMPONENT_INFO_OFFSET
operator|/
name|DEV_BSIZE
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|RF_COMPONENT_INFO_SIZE
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|RF_COMPONENT_INFO_SIZE
operator|/
name|DEV_BSIZE
expr_stmt|;
name|memset
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
literal|0
argument_list|,
name|RF_COMPONENT_INFO_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|clabel
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|)
expr_stmt|;
name|DEV_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|bufwait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
literal|1
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Failed to write RAID component info!\n"
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"b_error= %d\n"
argument_list|,
name|bp
operator|->
name|b_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_markalldirty
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|MALLOC
argument_list|(
name|clabel
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rf_markalldirty: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|raidPtr
operator|->
name|mod_counter
operator|++
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
comment|/* we don't want to touch (at all) a disk that has 			   failed */
if|if
condition|(
operator|!
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|->
name|status
operator|==
name|rf_ds_spared
condition|)
block|{
comment|/* XXX do something special...  					 but whatever you do, don't  					 try to access it!! */
block|}
else|else
block|{
if|#
directive|if
literal|0
block|clabel->status =  					raidPtr->Disks[r][c].status; 				raidwrite_component_label(  					raidPtr->Disks[r][c].dev, 					raidPtr->raid_cinfo[r][c].ci_vp, 					clabel);
endif|#
directive|endif
name|raidmarkdirty
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
argument_list|,
name|raidPtr
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* printf("Component labels marked dirty.\n"); */
if|#
directive|if
literal|0
block|for( c = 0; c< raidPtr->numSpare ; c++) { 		sparecol = raidPtr->numCol + c; 		if (raidPtr->Disks[r][sparecol].status == rf_ds_used_spare) {
comment|/*   			   XXX this is where we get fancy and map this spare 			   into it's correct spot in the array.  			 */
comment|/*  			    			   we claim this disk is "optimal" if it's  			   rf_ds_used_spare, as that means it should be  			   directly substitutable for the disk it replaced.  			   We note that too...  			 */
block|for(i=0;i<raidPtr->numRow;i++) { 				for(j=0;j<raidPtr->numCol;j++) { 					if ((raidPtr->Disks[i][j].spareRow ==  					     r)&& 					    (raidPtr->Disks[i][j].spareCol == 					     sparecol)) { 						srow = r; 						scol = sparecol; 						break; 					} 				} 			} 			 			raidread_component_label(  				      raidPtr->Disks[r][sparecol].dev, 				      raidPtr->raid_cinfo[r][sparecol].ci_vp,&clabel);
comment|/* make sure status is noted */
block|clabel.version = RF_COMPONENT_LABEL_VERSION;  			clabel.mod_counter = raidPtr->mod_counter; 			clabel.serial_number = raidPtr->serial_number; 			clabel.row = srow; 			clabel.column = scol; 			clabel.num_rows = raidPtr->numRow; 			clabel.num_columns = raidPtr->numCol; 			clabel.clean = RF_RAID_DIRTY;
comment|/* changed in a bit*/
block|clabel.status = rf_ds_optimal; 			raidwrite_component_label( 				      raidPtr->Disks[r][sparecol].dev, 				      raidPtr->raid_cinfo[r][sparecol].ci_vp,&clabel); 			raidmarkclean( raidPtr->Disks[r][sparecol].dev,  			              raidPtr->raid_cinfo[r][sparecol].ci_vp); 		} 	}
endif|#
directive|endif
name|FREE
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_update_component_labels
parameter_list|(
name|raidPtr
parameter_list|,
name|final
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|final
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|int
name|sparecol
decl_stmt|;
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|srow
decl_stmt|,
name|scol
decl_stmt|;
name|srow
operator|=
operator|-
literal|1
expr_stmt|;
name|scol
operator|=
operator|-
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|clabel
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rf_update_component_labels: Out of memory?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX should do extra checks to make sure things really are clean,  	   rather than blindly setting the clean bit... */
name|raidPtr
operator|->
name|mod_counter
operator|++
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
comment|/* make sure status is noted */
name|clabel
operator|->
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
comment|/* bump the counter */
name|clabel
operator|->
name|mod_counter
operator|=
name|raidPtr
operator|->
name|mod_counter
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|final
operator|==
name|RF_FINAL_COMPONENT_UPDATE
condition|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|parity_good
operator|==
name|RF_RAID_CLEAN
condition|)
block|{
name|raidmarkclean
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
argument_list|,
name|raidPtr
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* else we don't touch it.. */
block|}
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numSpare
condition|;
name|c
operator|++
control|)
block|{
name|sparecol
operator|=
name|raidPtr
operator|->
name|numCol
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|status
operator|==
name|rf_ds_used_spare
condition|)
block|{
comment|/*  			    			   we claim this disk is "optimal" if it's  			   rf_ds_used_spare, as that means it should be  			   directly substitutable for the disk it replaced.  			   We note that too...  			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|Disks
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|spareRow
operator|==
literal|0
operator|)
operator|&&
operator|(
name|raidPtr
operator|->
name|Disks
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|spareCol
operator|==
name|sparecol
operator|)
condition|)
block|{
name|srow
operator|=
name|i
expr_stmt|;
name|scol
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* XXX shouldn't *really* need this... */
name|raidread_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|ci_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
comment|/* make sure status is noted */
name|raid_init_component_label
argument_list|(
name|raidPtr
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|clabel
operator|->
name|mod_counter
operator|=
name|raidPtr
operator|->
name|mod_counter
expr_stmt|;
name|clabel
operator|->
name|row
operator|=
name|srow
expr_stmt|;
name|clabel
operator|->
name|column
operator|=
name|scol
expr_stmt|;
name|clabel
operator|->
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|ci_vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|final
operator|==
name|RF_FINAL_COMPONENT_UPDATE
condition|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|parity_good
operator|==
name|RF_RAID_CLEAN
condition|)
block|{
name|raidmarkclean
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|dev
argument_list|,
name|raidPtr
operator|->
name|raid_cinfo
index|[
literal|0
index|]
index|[
name|sparecol
index|]
operator|.
name|ci_vp
argument_list|,
name|raidPtr
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|FREE
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Component labels updated\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_close_component
parameter_list|(
name|raidPtr
parameter_list|,
name|vp
parameter_list|,
name|auto_configured
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|auto_configured
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|raidPtr
operator|->
name|engine_thread
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|auto_configured
operator|==
literal|1
condition|)
block|{
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vn_close
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"vnode was NULL\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rf_UnconfigureVnodes
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|acd
decl_stmt|;
comment|/* We take this opportunity to close the vnodes like we should.. */
name|td
operator|=
name|raidPtr
operator|->
name|engine_thread
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|c
operator|++
control|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Closing vnode for row: %d col: %d\n"
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|vp
operator|=
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
expr_stmt|;
name|acd
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|auto_configured
expr_stmt|;
name|rf_close_component
argument_list|(
name|raidPtr
argument_list|,
name|vp
argument_list|,
name|acd
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|ci_vp
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|r
index|]
index|[
name|c
index|]
operator|.
name|auto_configured
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|raidPtr
operator|->
name|numSpare
condition|;
name|r
operator|++
control|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Closing vnode for spare: %d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|vp
operator|=
name|raidPtr
operator|->
name|raid_cinfo
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
operator|+
name|r
index|]
operator|.
name|ci_vp
expr_stmt|;
name|acd
operator|=
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
operator|+
name|r
index|]
operator|.
name|auto_configured
expr_stmt|;
name|rf_close_component
argument_list|(
name|raidPtr
argument_list|,
name|vp
argument_list|,
name|acd
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
operator|+
name|r
index|]
operator|.
name|ci_vp
operator|=
name|NULL
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
literal|0
index|]
index|[
name|raidPtr
operator|->
name|numCol
operator|+
name|r
index|]
operator|.
name|auto_configured
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rf_ReconThread
parameter_list|(
name|req
parameter_list|)
name|struct
name|rf_recon_req
modifier|*
name|req
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|raidPtr
operator|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|req
operator|->
name|raidPtr
expr_stmt|;
name|raidPtr
operator|->
name|recon_in_progress
operator|=
literal|1
expr_stmt|;
name|rf_FailDisk
argument_list|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|req
operator|->
name|raidPtr
argument_list|,
name|req
operator|->
name|row
argument_list|,
name|req
operator|->
name|col
argument_list|,
operator|(
operator|(
name|req
operator|->
name|flags
operator|&
name|RF_FDFLAGS_RECON
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX get rid of this! we don't need it at all.. */
name|RF_Free
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* That's all... */
name|RF_THREAD_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* does not return */
block|}
end_function

begin_function
name|void
name|rf_RewriteParityThread
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|int
name|retcode
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|parity_rewrite_in_progress
operator|=
literal|1
expr_stmt|;
name|retcode
operator|=
name|rf_RewriteParity
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"raid%d: Error re-writing parity!\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set the clean bit!  If we shutdown correctly, 		   the clean bit on each component label will get 		   set */
name|raidPtr
operator|->
name|parity_good
operator|=
name|RF_RAID_CLEAN
expr_stmt|;
block|}
name|raidPtr
operator|->
name|parity_rewrite_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* Anyone waiting for us to stop?  If so, inform them... */
if|if
condition|(
name|raidPtr
operator|->
name|waitShutdown
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|raidPtr
operator|->
name|parity_rewrite_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* That's all... */
name|RF_THREAD_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* does not return */
block|}
end_function

begin_function
name|void
name|rf_CopybackThread
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|copyback_in_progress
operator|=
literal|1
expr_stmt|;
name|rf_CopybackReconstructedData
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|copyback_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* That's all... */
name|RF_THREAD_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* does not return */
block|}
end_function

begin_function
name|void
name|rf_ReconstructInPlaceThread
parameter_list|(
name|req
parameter_list|)
name|struct
name|rf_recon_req
modifier|*
name|req
decl_stmt|;
block|{
name|int
name|retcode
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|raidPtr
operator|=
name|req
operator|->
name|raidPtr
expr_stmt|;
name|raidPtr
operator|->
name|recon_in_progress
operator|=
literal|1
expr_stmt|;
name|retcode
operator|=
name|rf_ReconstructInPlace
argument_list|(
name|raidPtr
argument_list|,
name|req
operator|->
name|row
argument_list|,
name|req
operator|->
name|col
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_in_progress
operator|=
literal|0
expr_stmt|;
comment|/* That's all... */
name|RF_THREAD_EXIT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* does not return */
block|}
end_function

begin_function
name|RF_AutoConfig_t
modifier|*
name|rf_find_raid_components
parameter_list|()
block|{
name|RF_AutoConfig_t
modifier|*
name|ac_list
init|=
name|NULL
decl_stmt|;
if|#
directive|if
literal|0
comment|/* XXX GEOM */
block|struct vnode *vp; 	struct disklabel *label; 	struct diskslice *slice; 	struct diskslices *slices; 	struct disk *disk; 	struct thread *td; 	dev_t dev; 	char *devname; 	int error, j; 	int nslices;  	td = curthread;  	MALLOC(label, struct disklabel *, sizeof(struct disklabel), 	    M_RAIDFRAME, M_NOWAIT|M_ZERO); 	MALLOC(slices, struct diskslices *, sizeof(struct diskslices), 	    M_RAIDFRAME, M_NOWAIT|M_ZERO); 	if ((label == NULL) || (slices == NULL)) { 		printf("rf_find_raid_components: Out of Memory?\n"); 		return (NULL); 	}
comment|/* initialize the AutoConfig list */
block|ac_list = NULL;
comment|/* we begin by trolling through *all* the disk devices on the system */
block|disk = NULL; 	while ((disk = disk_enumerate(disk))) {
comment|/* we don't care about floppies... */
block|devname = disk->d_dev->si_name; 		if (!strncmp(devname, "fd", 2) || 		    !strncmp(devname, "cd", 2) || 		    !strncmp(devname, "acd", 3)) 			continue;  		rf_printf(1, "Examining %s\n", disk->d_dev->si_name); 		if (bdevvp(disk->d_dev,&vp)) 			panic("RAIDframe can't alloc vnode"); 		vref(vp);  		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td); 		error = VOP_OPEN(vp, FREAD, td->td_ucred, td, -1); 		VOP_UNLOCK(vp, 0, td); 		if (error) { 			vput(vp); 			continue; 		}  		error = VOP_IOCTL(vp, DIOCGSLICEINFO, (caddr_t)slices, 		    FREAD, td->td_ucred, td); 		VOP_CLOSE(vp, FREAD | FWRITE, td->td_ucred, td); 		vrele(vp); 		if (error) {
comment|/* No slice table. */
block|continue; 		}  		nslices = slices->dss_nslices; 		if ((nslices == 0) || (nslices> MAX_SLICES)) 			continue;
comment|/* Iterate through the slices */
block|for (j = 1; j< nslices; j++) {  			rf_printf(1, "Examining slice %d\n", j); 			slice =&slices->dss_slices[j - 1]; 			dev = dkmodslice(disk->d_dev, j); 			if (bdevvp(dev,&vp)) 				panic("RAIDframe can't alloc vnode");  			vref(vp); 			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, td); 			error = VOP_OPEN(vp, FREAD, td->td_ucred, td, -1); 			VOP_UNLOCK(vp, 0, td); 			if (error) { 				continue; 			}  			error = VOP_IOCTL(vp, DIOCGDINFO, (caddr_t)label, 			    FREAD, td->td_ucred, td); 			VOP_CLOSE(vp, FREAD | FWRITE, td->td_ucred, td); 			vrele(vp); 			if (error) 				continue;  			rf_search_label(dev, label,&ac_list); 		} 	}  	FREE(label, M_RAIDFRAME); 	FREE(slices, M_RAIDFRAME);
endif|#
directive|endif
return|return
operator|(
name|ac_list
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_search_label
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|disklabel
modifier|*
name|label
parameter_list|,
name|RF_AutoConfig_t
modifier|*
modifier|*
name|ac_list
parameter_list|)
block|{
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|dev_t
name|dev1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|good_one
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* Iterate through the partitions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|label
operator|->
name|d_npartitions
condition|;
name|i
operator|++
control|)
block|{
comment|/* We only support partitions marked as RAID */
if|if
condition|(
name|label
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_fstype
operator|!=
name|FS_RAID
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* GEOM */
block|dev1 = dkmodpart(dev, i);
else|#
directive|else
name|dev1
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev1
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"dev1 == null\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bdevvp
argument_list|(
name|dev1
argument_list|,
operator|&
name|vp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"RAIDframe can't alloc vnode"
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Whatever... */
continue|continue;
block|}
name|good_one
operator|=
literal|0
expr_stmt|;
name|clabel
operator|=
operator|(
name|RF_ComponentLabel_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|clabel
operator|==
name|NULL
condition|)
block|{
comment|/* XXX CLEANUP HERE */
name|panic
argument_list|(
literal|"RAID autoconfig: no memory!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|raidread_component_label
argument_list|(
name|dev1
argument_list|,
name|vp
argument_list|,
name|clabel
argument_list|)
condition|)
block|{
comment|/* Got the label.  Is it reasonable? */
if|if
condition|(
name|rf_reasonable_label
argument_list|(
name|clabel
argument_list|)
operator|&&
operator|(
name|clabel
operator|->
name|partitionSize
operator|<=
name|label
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|)
condition|)
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Component on: %s: %d\n"
argument_list|,
name|dev1
operator|->
name|si_name
argument_list|,
name|label
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
argument_list|)
expr_stmt|;
name|rf_print_component_label
argument_list|(
name|clabel
argument_list|)
expr_stmt|;
comment|/* if it's reasonable, add it, else ignore it */
name|ac
operator|=
operator|(
name|RF_AutoConfig_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RF_AutoConfig_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|NULL
condition|)
block|{
comment|/* XXX should panic? */
name|panic
argument_list|(
literal|"RAID autoconfig: no memory!\n"
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|ac
operator|->
name|devname
argument_list|,
literal|"%s"
argument_list|,
name|dev
operator|->
name|si_name
argument_list|)
expr_stmt|;
name|ac
operator|->
name|dev
operator|=
name|dev1
expr_stmt|;
name|ac
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|ac
operator|->
name|clabel
operator|=
name|clabel
expr_stmt|;
name|ac
operator|->
name|next
operator|=
operator|*
name|ac_list
expr_stmt|;
operator|*
name|ac_list
operator|=
name|ac
expr_stmt|;
name|good_one
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|good_one
condition|)
block|{
comment|/* cleanup */
name|free
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rf_reasonable_label
parameter_list|(
name|clabel
parameter_list|)
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|clabel
operator|->
name|version
operator|==
name|RF_COMPONENT_LABEL_VERSION_1
operator|)
operator|||
operator|(
name|clabel
operator|->
name|version
operator|==
name|RF_COMPONENT_LABEL_VERSION
operator|)
operator|)
operator|&&
operator|(
operator|(
name|clabel
operator|->
name|clean
operator|==
name|RF_RAID_CLEAN
operator|)
operator|||
operator|(
name|clabel
operator|->
name|clean
operator|==
name|RF_RAID_DIRTY
operator|)
operator|)
operator|&&
name|clabel
operator|->
name|row
operator|>=
literal|0
operator|&&
name|clabel
operator|->
name|column
operator|>=
literal|0
operator|&&
name|clabel
operator|->
name|num_rows
operator|>
literal|0
operator|&&
name|clabel
operator|->
name|num_columns
operator|>
literal|0
operator|&&
name|clabel
operator|->
name|row
operator|<
name|clabel
operator|->
name|num_rows
operator|&&
name|clabel
operator|->
name|column
operator|<
name|clabel
operator|->
name|num_columns
operator|&&
name|clabel
operator|->
name|blockSize
operator|>
literal|0
operator|&&
name|clabel
operator|->
name|numBlocks
operator|>
literal|0
condition|)
block|{
comment|/* label looks reasonable enough... */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_print_component_label
parameter_list|(
name|clabel
parameter_list|)
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
block|{
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   Row: %d Column: %d Num Rows: %d Num Columns: %d\n"
argument_list|,
name|clabel
operator|->
name|row
argument_list|,
name|clabel
operator|->
name|column
argument_list|,
name|clabel
operator|->
name|num_rows
argument_list|,
name|clabel
operator|->
name|num_columns
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   Version: %d Serial Number: %d Mod Counter: %d\n"
argument_list|,
name|clabel
operator|->
name|version
argument_list|,
name|clabel
operator|->
name|serial_number
argument_list|,
name|clabel
operator|->
name|mod_counter
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   Clean: %s Status: %d\n"
argument_list|,
name|clabel
operator|->
name|clean
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|clabel
operator|->
name|status
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   sectPerSU: %d SUsPerPU: %d SUsPerRU: %d\n"
argument_list|,
name|clabel
operator|->
name|sectPerSU
argument_list|,
name|clabel
operator|->
name|SUsPerPU
argument_list|,
name|clabel
operator|->
name|SUsPerRU
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   RAID Level: %c  blocksize: %d numBlocks: %d\n"
argument_list|,
operator|(
name|char
operator|)
name|clabel
operator|->
name|parityConfig
argument_list|,
name|clabel
operator|->
name|blockSize
argument_list|,
name|clabel
operator|->
name|numBlocks
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   Autoconfig: %s\n"
argument_list|,
name|clabel
operator|->
name|autoconfigure
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   Contains root partition: %s\n"
argument_list|,
name|clabel
operator|->
name|root_partition
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"   Last configured as: raid%d\n"
argument_list|,
name|clabel
operator|->
name|last_unit
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|rf_printf(1, "   Config order: %d\n", clabel->config_order);
endif|#
directive|endif
block|}
end_function

begin_function
name|RF_ConfigSet_t
modifier|*
name|rf_create_auto_sets
parameter_list|(
name|ac_list
parameter_list|)
name|RF_AutoConfig_t
modifier|*
name|ac_list
decl_stmt|;
block|{
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|RF_ConfigSet_t
modifier|*
name|config_sets
decl_stmt|;
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|ac_next
decl_stmt|;
name|config_sets
operator|=
name|NULL
expr_stmt|;
comment|/* Go through the AutoConfig list, and figure out which components 	   belong to what sets.  */
name|ac
operator|=
name|ac_list
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
comment|/* we're going to putz with ac->next, so save it here 		   for use at the end of the loop */
name|ac_next
operator|=
name|ac
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|config_sets
operator|==
name|NULL
condition|)
block|{
comment|/* will need at least this one... */
name|config_sets
operator|=
operator|(
name|RF_ConfigSet_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RF_ConfigSet_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_sets
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"rf_create_auto_sets: No memory!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* this one is easy :) */
name|config_sets
operator|->
name|ac
operator|=
name|ac
expr_stmt|;
name|config_sets
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|config_sets
operator|->
name|rootable
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* which set does this component fit into? */
name|cset
operator|=
name|config_sets
expr_stmt|;
while|while
condition|(
name|cset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rf_does_it_fit
argument_list|(
name|cset
argument_list|,
name|ac
argument_list|)
condition|)
block|{
comment|/* looks like it matches... */
name|ac
operator|->
name|next
operator|=
name|cset
operator|->
name|ac
expr_stmt|;
name|cset
operator|->
name|ac
operator|=
name|ac
expr_stmt|;
break|break;
block|}
name|cset
operator|=
name|cset
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cset
operator|==
name|NULL
condition|)
block|{
comment|/* didn't find a match above... new set..*/
name|cset
operator|=
operator|(
name|RF_ConfigSet_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RF_ConfigSet_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cset
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"rf_create_auto_sets: No memory!\n"
argument_list|)
expr_stmt|;
block|}
name|cset
operator|->
name|ac
operator|=
name|ac
expr_stmt|;
name|ac
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cset
operator|->
name|next
operator|=
name|config_sets
expr_stmt|;
name|cset
operator|->
name|rootable
operator|=
literal|0
expr_stmt|;
name|config_sets
operator|=
name|cset
expr_stmt|;
block|}
block|}
name|ac
operator|=
name|ac_next
expr_stmt|;
block|}
return|return
operator|(
name|config_sets
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rf_does_it_fit
parameter_list|(
name|cset
parameter_list|,
name|ac
parameter_list|)
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel1
decl_stmt|,
modifier|*
name|clabel2
decl_stmt|;
comment|/* If this one matches the *first* one in the set, that's good 	   enough, since the other members of the set would have been 	   through here too... */
comment|/* note that we are not checking partitionSize here..  	   Note that we are also not checking the mod_counters here. 	   If everything else matches execpt the mod_counter, that's  	   good enough for this test.  We will deal with the mod_counters 	   a little later in the autoconfiguration process.    	    (clabel1->mod_counter == clabel2->mod_counter)&&  	   The reason we don't check for this is that failed disks 	   will have lower modification counts.  If those disks are 	   not added to the set they used to belong to, then they will 	   form their own set, which may result in 2 different sets, 	   for example, competing to be configured at raid0, and 	   perhaps competing to be the root filesystem set.  If the 	   wrong ones get configured, or both attempt to become /, 	   weird behaviour and or serious lossage will occur.  Thus we 	   need to bring them into the fold here, and kick them out at 	   a later point.  	*/
name|clabel1
operator|=
name|cset
operator|->
name|ac
operator|->
name|clabel
expr_stmt|;
name|clabel2
operator|=
name|ac
operator|->
name|clabel
expr_stmt|;
if|if
condition|(
operator|(
name|clabel1
operator|->
name|version
operator|==
name|clabel2
operator|->
name|version
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|serial_number
operator|==
name|clabel2
operator|->
name|serial_number
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|num_rows
operator|==
name|clabel2
operator|->
name|num_rows
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|num_columns
operator|==
name|clabel2
operator|->
name|num_columns
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|sectPerSU
operator|==
name|clabel2
operator|->
name|sectPerSU
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|SUsPerPU
operator|==
name|clabel2
operator|->
name|SUsPerPU
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|SUsPerRU
operator|==
name|clabel2
operator|->
name|SUsPerRU
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|parityConfig
operator|==
name|clabel2
operator|->
name|parityConfig
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|maxOutstanding
operator|==
name|clabel2
operator|->
name|maxOutstanding
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|blockSize
operator|==
name|clabel2
operator|->
name|blockSize
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|numBlocks
operator|==
name|clabel2
operator|->
name|numBlocks
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|autoconfigure
operator|==
name|clabel2
operator|->
name|autoconfigure
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|root_partition
operator|==
name|clabel2
operator|->
name|root_partition
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|last_unit
operator|==
name|clabel2
operator|->
name|last_unit
operator|)
operator|&&
operator|(
name|clabel1
operator|->
name|config_order
operator|==
name|clabel2
operator|->
name|config_order
operator|)
condition|)
block|{
comment|/* if it get's here, it almost *has* to be a match */
block|}
else|else
block|{
comment|/* it's not consistent with somebody in the set..  		   punt */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* all was fine.. it must fit... */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_have_enough_components
parameter_list|(
name|cset
parameter_list|)
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
block|{
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|auto_config
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|num_rows
decl_stmt|;
name|int
name|num_cols
decl_stmt|;
name|int
name|num_missing
decl_stmt|;
name|int
name|mod_counter
decl_stmt|;
name|int
name|mod_counter_found
decl_stmt|;
name|int
name|even_pair_failed
decl_stmt|;
name|char
name|parity_type
decl_stmt|;
comment|/* check to see that we have enough 'live' components 	   of this set.  If so, we can configure it if necessary */
name|num_rows
operator|=
name|cset
operator|->
name|ac
operator|->
name|clabel
operator|->
name|num_rows
expr_stmt|;
name|num_cols
operator|=
name|cset
operator|->
name|ac
operator|->
name|clabel
operator|->
name|num_columns
expr_stmt|;
name|parity_type
operator|=
name|cset
operator|->
name|ac
operator|->
name|clabel
operator|->
name|parityConfig
expr_stmt|;
comment|/* XXX Check for duplicate components!?!?!? */
comment|/* Determine what the mod_counter is supposed to be for this set. */
name|mod_counter_found
operator|=
literal|0
expr_stmt|;
name|mod_counter
operator|=
literal|0
expr_stmt|;
name|ac
operator|=
name|cset
operator|->
name|ac
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mod_counter_found
operator|==
literal|0
condition|)
block|{
name|mod_counter
operator|=
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
expr_stmt|;
name|mod_counter_found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
operator|>
name|mod_counter
condition|)
block|{
name|mod_counter
operator|=
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
expr_stmt|;
block|}
block|}
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
name|num_missing
operator|=
literal|0
expr_stmt|;
name|auto_config
operator|=
name|cset
operator|->
name|ac
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|num_rows
condition|;
name|r
operator|++
control|)
block|{
name|even_pair_failed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|num_cols
condition|;
name|c
operator|++
control|)
block|{
name|ac
operator|=
name|auto_config
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ac
operator|->
name|clabel
operator|->
name|row
operator|==
name|r
operator|)
operator|&&
operator|(
name|ac
operator|->
name|clabel
operator|->
name|column
operator|==
name|c
operator|)
operator|&&
operator|(
name|ac
operator|->
name|clabel
operator|->
name|mod_counter
operator|==
name|mod_counter
operator|)
condition|)
block|{
comment|/* it's this one... */
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Found: %s at %d,%d\n"
argument_list|,
name|ac
operator|->
name|devname
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|==
name|NULL
condition|)
block|{
comment|/* Didn't find one here! */
comment|/* special case for RAID 1, especially 				   where there are more than 2 				   components (where RAIDframe treats 				   things a little differently :( ) */
if|if
condition|(
name|parity_type
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|c
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
comment|/* even component */
name|even_pair_failed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* odd component.  If                                                     we're failed, and                                                     so is the even                                                     component, it's                                                     "Good Night, Charlie" */
if|if
condition|(
name|even_pair_failed
operator|==
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* normal accounting */
name|num_missing
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|parity_type
operator|==
literal|'1'
operator|)
operator|&&
operator|(
name|c
operator|%
literal|2
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Just did an even component, and we didn't 				   bail.. reset the even_pair_failed flag,  				   and go on to the next component.... */
name|even_pair_failed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|clabel
operator|=
name|cset
operator|->
name|ac
operator|->
name|clabel
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|clabel
operator|->
name|parityConfig
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|num_missing
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|clabel
operator|->
name|parityConfig
operator|==
literal|'4'
operator|)
operator|&&
operator|(
name|num_missing
operator|>
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|clabel
operator|->
name|parityConfig
operator|==
literal|'5'
operator|)
operator|&&
operator|(
name|num_missing
operator|>
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* XXX this needs to be made *much* more general */
comment|/* Too many failures */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* otherwise, all is well, and we've got enough to take a kick 	   at autoconfiguring this set */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_create_configuration
parameter_list|(
name|ac
parameter_list|,
name|config
parameter_list|,
name|raidPtr
parameter_list|)
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|RF_Config_t
modifier|*
name|config
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|int
name|i
decl_stmt|;
name|clabel
operator|=
name|ac
operator|->
name|clabel
expr_stmt|;
comment|/* 1. Fill in the common stuff */
name|config
operator|->
name|numRow
operator|=
name|clabel
operator|->
name|num_rows
expr_stmt|;
name|config
operator|->
name|numCol
operator|=
name|clabel
operator|->
name|num_columns
expr_stmt|;
name|config
operator|->
name|numSpare
operator|=
literal|0
expr_stmt|;
comment|/* XXX should this be set here? */
name|config
operator|->
name|sectPerSU
operator|=
name|clabel
operator|->
name|sectPerSU
expr_stmt|;
name|config
operator|->
name|SUsPerPU
operator|=
name|clabel
operator|->
name|SUsPerPU
expr_stmt|;
name|config
operator|->
name|SUsPerRU
operator|=
name|clabel
operator|->
name|SUsPerRU
expr_stmt|;
name|config
operator|->
name|parityConfig
operator|=
name|clabel
operator|->
name|parityConfig
expr_stmt|;
comment|/* XXX... */
name|strcpy
argument_list|(
name|config
operator|->
name|diskQueueType
argument_list|,
literal|"fifo"
argument_list|)
expr_stmt|;
name|config
operator|->
name|maxOutstandingDiskReqs
operator|=
name|clabel
operator|->
name|maxOutstanding
expr_stmt|;
name|config
operator|->
name|layoutSpecificSize
operator|=
literal|0
expr_stmt|;
comment|/* XXX ? */
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
comment|/* row/col values will be in range due to the checks 		   in reasonable_label() */
name|strcpy
argument_list|(
name|config
operator|->
name|devnames
index|[
name|ac
operator|->
name|clabel
operator|->
name|row
index|]
index|[
name|ac
operator|->
name|clabel
operator|->
name|column
index|]
argument_list|,
name|ac
operator|->
name|devname
argument_list|)
expr_stmt|;
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RF_MAXDBGV
condition|;
name|i
operator|++
control|)
block|{
name|config
operator|->
name|debugVars
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rf_set_autoconfig
parameter_list|(
name|raidPtr
parameter_list|,
name|new_value
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|new_value
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|row
decl_stmt|,
name|column
decl_stmt|;
name|MALLOC
argument_list|(
name|clabel
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|autoconfigure
operator|=
name|new_value
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|column
operator|++
control|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
name|dev
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|dev
expr_stmt|;
name|vp
operator|=
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|ci_vp
expr_stmt|;
name|raidread_component_label
argument_list|(
name|dev
argument_list|,
name|vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|clabel
operator|->
name|autoconfigure
operator|=
name|new_value
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|dev
argument_list|,
name|vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|FREE
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_value
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_set_rootpartition
parameter_list|(
name|raidPtr
parameter_list|,
name|new_value
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|int
name|new_value
decl_stmt|;
block|{
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|row
decl_stmt|,
name|column
decl_stmt|;
name|MALLOC
argument_list|(
name|clabel
argument_list|,
name|RF_ComponentLabel_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ComponentLabel_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|root_partition
operator|=
name|new_value
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|raidPtr
operator|->
name|numRow
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
name|raidPtr
operator|->
name|numCol
condition|;
name|column
operator|++
control|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|status
operator|==
name|rf_ds_optimal
condition|)
block|{
name|dev
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|dev
expr_stmt|;
name|vp
operator|=
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|column
index|]
operator|.
name|ci_vp
expr_stmt|;
name|raidread_component_label
argument_list|(
name|dev
argument_list|,
name|vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
name|clabel
operator|->
name|root_partition
operator|=
name|new_value
expr_stmt|;
name|raidwrite_component_label
argument_list|(
name|dev
argument_list|,
name|vp
argument_list|,
name|clabel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|FREE
argument_list|(
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_value
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_release_all_vps
parameter_list|(
name|cset
parameter_list|)
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
block|{
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|ac
operator|=
name|cset
operator|->
name|ac
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
comment|/* Close the vp, and give it back */
if|if
condition|(
name|ac
operator|->
name|vp
condition|)
block|{
name|VOP_CLOSE
argument_list|(
name|ac
operator|->
name|vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ac
operator|->
name|vp
argument_list|)
expr_stmt|;
name|ac
operator|->
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
name|ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rf_cleanup_config_set
parameter_list|(
name|cset
parameter_list|)
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
block|{
name|RF_AutoConfig_t
modifier|*
name|ac
decl_stmt|;
name|RF_AutoConfig_t
modifier|*
name|next_ac
decl_stmt|;
name|ac
operator|=
name|cset
operator|->
name|ac
expr_stmt|;
while|while
condition|(
name|ac
operator|!=
name|NULL
condition|)
block|{
name|next_ac
operator|=
name|ac
operator|->
name|next
expr_stmt|;
comment|/* nuke the label */
name|free
argument_list|(
name|ac
operator|->
name|clabel
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
comment|/* cleanup the config structure */
name|free
argument_list|(
name|ac
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
comment|/* "next.." */
name|ac
operator|=
name|next_ac
expr_stmt|;
block|}
comment|/* and, finally, nuke the config set */
name|free
argument_list|(
name|cset
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|raid_init_component_label
parameter_list|(
name|raidPtr
parameter_list|,
name|clabel
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ComponentLabel_t
modifier|*
name|clabel
decl_stmt|;
block|{
comment|/* current version number */
name|clabel
operator|->
name|version
operator|=
name|RF_COMPONENT_LABEL_VERSION
expr_stmt|;
name|clabel
operator|->
name|serial_number
operator|=
name|raidPtr
operator|->
name|serial_number
expr_stmt|;
name|clabel
operator|->
name|mod_counter
operator|=
name|raidPtr
operator|->
name|mod_counter
expr_stmt|;
name|clabel
operator|->
name|num_rows
operator|=
name|raidPtr
operator|->
name|numRow
expr_stmt|;
name|clabel
operator|->
name|num_columns
operator|=
name|raidPtr
operator|->
name|numCol
expr_stmt|;
name|clabel
operator|->
name|clean
operator|=
name|RF_RAID_DIRTY
expr_stmt|;
comment|/* not clean */
name|clabel
operator|->
name|status
operator|=
name|rf_ds_optimal
expr_stmt|;
comment|/* "It's good!" */
name|clabel
operator|->
name|sectPerSU
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
name|clabel
operator|->
name|SUsPerPU
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerPU
expr_stmt|;
name|clabel
operator|->
name|SUsPerRU
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerRU
expr_stmt|;
name|clabel
operator|->
name|blockSize
operator|=
name|raidPtr
operator|->
name|bytesPerSector
expr_stmt|;
name|clabel
operator|->
name|numBlocks
operator|=
name|raidPtr
operator|->
name|sectorsPerDisk
expr_stmt|;
comment|/* XXX not portable */
name|clabel
operator|->
name|parityConfig
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|parityConfig
expr_stmt|;
name|clabel
operator|->
name|maxOutstanding
operator|=
name|raidPtr
operator|->
name|maxOutstanding
expr_stmt|;
name|clabel
operator|->
name|autoconfigure
operator|=
name|raidPtr
operator|->
name|autoconfigure
expr_stmt|;
name|clabel
operator|->
name|root_partition
operator|=
name|raidPtr
operator|->
name|root_partition
expr_stmt|;
name|clabel
operator|->
name|last_unit
operator|=
name|raidPtr
operator|->
name|raidid
expr_stmt|;
name|clabel
operator|->
name|config_order
operator|=
name|raidPtr
operator|->
name|config_order
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_auto_config_set
parameter_list|(
name|cset
parameter_list|,
name|unit
parameter_list|,
name|parent_sc
parameter_list|)
name|RF_ConfigSet_t
modifier|*
name|cset
decl_stmt|;
name|int
modifier|*
name|unit
decl_stmt|;
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
decl_stmt|;
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_Config_t
modifier|*
name|config
decl_stmt|;
name|int
name|raidID
decl_stmt|;
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"RAIDframe autoconfigure\n"
argument_list|)
expr_stmt|;
operator|*
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 1. Create a config structure */
name|config
operator|=
operator|(
name|RF_Config_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RF_Config_t
argument_list|)
argument_list|,
name|M_RAIDFRAME
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Out of mem at rf_auto_config_set\n"
argument_list|)
expr_stmt|;
comment|/* XXX do something more intelligent here. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* XXX raidID needs to be set correctly.. */
comment|/*  	   2. Figure out what RAID ID this one is supposed to live at  	   See if we can get the same RAID dev that it was configured 	   on last time..  	*/
name|raidID
operator|=
name|cset
operator|->
name|ac
operator|->
name|clabel
operator|->
name|last_unit
expr_stmt|;
if|if
condition|(
name|raidID
operator|<
literal|0
condition|)
block|{
comment|/* let's not wander off into lala land. */
name|raidID
operator|=
name|raidgetunit
argument_list|(
name|parent_sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raidID
operator|=
name|raidgetunit
argument_list|(
name|parent_sc
argument_list|,
name|raidID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|raidID
operator|<
literal|0
condition|)
block|{
comment|/* punt... */
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Unable to auto configure this set!\n"
argument_list|)
expr_stmt|;
name|rf_printf
argument_list|(
literal|1
argument_list|,
literal|"Out of RAID devs!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Configuring raid%d:\n"
argument_list|,
name|raidID
argument_list|)
expr_stmt|;
name|RF_Malloc
argument_list|(
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|raidPtr
argument_list|)
argument_list|,
operator|(
name|RF_Raid_t
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Out of mem at rf_auto_config_set\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Raid_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX all this stuff should be done SOMEWHERE ELSE! */
name|raidPtr
operator|->
name|raidid
operator|=
name|raidID
expr_stmt|;
name|raidPtr
operator|->
name|openings
operator|=
name|RAIDOUTSTANDING
expr_stmt|;
comment|/* 3. Build the configuration structure */
name|rf_create_configuration
argument_list|(
name|cset
operator|->
name|ac
argument_list|,
name|config
argument_list|,
name|raidPtr
argument_list|)
expr_stmt|;
comment|/* 4. Do the configuration */
name|retcode
operator|=
name|rf_Configure
argument_list|(
name|raidPtr
argument_list|,
name|config
argument_list|,
name|cset
operator|->
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|raidID
index|]
operator|=
name|raidinit
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|raidID
index|]
operator|==
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Could not create RAID device\n"
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|raidPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_Raid_t
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|parent_sc
operator|->
name|sc_numraid
operator|++
expr_stmt|;
operator|(
operator|(
expr|struct
name|raid_softc
operator|*
operator|)
name|raidPtr
operator|->
name|sc
operator|)
operator|->
name|sc_parent_dev
operator|=
name|parent_sc
operator|->
name|sc_dev
expr_stmt|;
name|rf_markalldirty
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|autoconfigure
operator|=
literal|1
expr_stmt|;
comment|/* XXX do this here? */
if|if
condition|(
name|cset
operator|->
name|ac
operator|->
name|clabel
operator|->
name|root_partition
operator|==
literal|1
condition|)
block|{
comment|/* everything configured just fine.  Make a note 			   that this set is eligible to be root. */
name|cset
operator|->
name|rootable
operator|=
literal|1
expr_stmt|;
comment|/* XXX do this here? */
name|raidPtr
operator|->
name|root_partition
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 5. Cleanup */
name|free
argument_list|(
name|config
argument_list|,
name|M_RAIDFRAME
argument_list|)
expr_stmt|;
operator|*
name|unit
operator|=
name|raidID
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_disk_unbusy
parameter_list|(
name|desc
parameter_list|)
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
block|{
name|struct
name|raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|sc
operator|=
name|desc
operator|->
name|raidPtr
operator|->
name|sc
expr_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|desc
operator|->
name|bp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the next available unit number from the bitmap.  You can also request  * a particular unit number by passing it in the second arg.  If it's not  * available, then grab the next free one.  Return -1 if none are available.  */
end_comment

begin_function
specifier|static
name|int
name|raidgetunit
parameter_list|(
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|id
operator|>=
name|RF_MAX_ARRAYS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|id
init|;
name|i
operator|<
name|RF_MAX_ARRAYS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|raidshutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|raidctl_softc
modifier|*
name|parent_sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|parent_sc
operator|=
name|raidctl_dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|parent_sc
operator|->
name|sc_numraid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|XXX_KTHREAD_EXIT_RACE
return|return
operator|(
name|EBUSY
operator|)
return|;
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RF_MAX_ARRAYS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parent_sc
operator|->
name|sc_raiddevs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|rf_printf
argument_list|(
literal|0
argument_list|,
literal|"Shutting down raid%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|raidctlioctl
argument_list|(
name|raidctl_dev
argument_list|,
name|RAIDFRAME_SHUTDOWN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|parent_sc
operator|->
name|sc_numraid
operator|==
literal|0
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
block|}
name|destroy_dev
argument_list|(
name|raidctl_dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|raid_getcomponentsize
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RowCol_t
name|row
parameter_list|,
name|RF_RowCol_t
name|col
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|RF_Thread_t
name|td
decl_stmt|;
name|off_t
name|mediasize
decl_stmt|;
name|u_int
name|secsize
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|td
operator|=
name|raidPtr
operator|->
name|engine_thread
expr_stmt|;
name|retcode
operator|=
name|raidlookup
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|devname
argument_list|,
name|td
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: rebuilding: raidlookup on device: %s failed: %d!\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|,
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|devname
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
comment|/* XXX the component isn't responding properly...  		   must be still dead :-( */
name|raidPtr
operator|->
name|reconInProgress
operator|--
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
else|else
block|{
comment|/* Ok, so we can at least do a lookup...  		   How about actually getting a vp for it? */
if|if
condition|(
operator|(
name|retcode
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|rf_getucred
argument_list|(
name|td
argument_list|)
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|raidPtr
operator|->
name|reconInProgress
operator|--
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
name|retcode
operator|=
name|VOP_IOCTL
argument_list|(
name|vp
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|secsize
argument_list|,
name|FREAD
argument_list|,
name|rf_getucred
argument_list|(
name|td
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
return|return
operator|(
name|retcode
operator|)
return|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|blockSize
operator|=
name|secsize
expr_stmt|;
name|retcode
operator|=
name|VOP_IOCTL
argument_list|(
name|vp
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mediasize
argument_list|,
name|FREAD
argument_list|,
name|rf_getucred
argument_list|(
name|td
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
return|return
operator|(
name|retcode
operator|)
return|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|numBlocks
operator|=
name|mediasize
operator|/
name|secsize
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_vp
operator|=
name|vp
expr_stmt|;
name|raidPtr
operator|->
name|raid_cinfo
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|ci_dev
operator|=
name|udev2dev
argument_list|(
name|va
operator|.
name|va_rdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|dev
operator|=
name|udev2dev
argument_list|(
name|va
operator|.
name|va_rdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we allow the user to specify that only a  		   fraction of the disks should be used this is  		   just for debug:  it speeds up 		 * the parity scan */
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|numBlocks
operator|=
name|raidPtr
operator|->
name|Disks
index|[
name|row
index|]
index|[
name|col
index|]
operator|.
name|numBlocks
operator|*
name|rf_sizePercentage
operator|/
literal|100
expr_stmt|;
block|}
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|raid_modevent
parameter_list|(
name|mod
parameter_list|,
name|type
parameter_list|,
name|data
parameter_list|)
name|module_t
name|mod
decl_stmt|;
name|int
name|type
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|raidattach
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_SHUTDOWN
case|:
name|error
operator|=
name|raidshutdown
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|moduledata_t
name|raid_mod
init|=
block|{
literal|"raidframe"
block|,
operator|(
name|modeventhand_t
operator|)
name|raid_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|raidframe
argument_list|,
name|raid_mod
argument_list|,
name|SI_SUB_RAID
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

