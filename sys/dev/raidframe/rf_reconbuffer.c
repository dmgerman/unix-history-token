begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_reconbuffer.c,v 1.5 2001/01/27 20:10:49 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/***************************************************  *  * rf_reconbuffer.c -- reconstruction buffer manager  *  ***************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconbuffer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugprint.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_revent.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_reconutil.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_nwayxor.h>
end_include

begin_define
define|#
directive|define
name|Dprintf1
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
value|if (rf_reconbufferDebug) printf(s,a)
end_define

begin_define
define|#
directive|define
name|Dprintf2
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|if (rf_reconbufferDebug) printf(s,a,b)
end_define

begin_define
define|#
directive|define
name|Dprintf3
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|if (rf_reconbufferDebug) printf(s,a,b,c)
end_define

begin_define
define|#
directive|define
name|Dprintf4
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|if (rf_reconbufferDebug) printf(s,a,b,c,d)
end_define

begin_define
define|#
directive|define
name|Dprintf5
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|if (rf_reconbufferDebug) printf(s,a,b,c,d,e)
end_define

begin_comment
comment|/*****************************************************************************  *  * Submit a reconstruction buffer to the manager for XOR.  We can only  * submit a buffer if (1) we can xor into an existing buffer, which  * means we don't have to acquire a new one, (2) we can acquire a  * floating recon buffer, or (3) the caller has indicated that we are  * allowed to keep the submitted buffer.  *  * Returns non-zero if and only if we were not able to submit.  * In this case, we append the current disk ID to the wait list on the  * indicated RU, so that it will be re-enabled when we acquire a buffer   * for this RU.  *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * nWayXorFuncs[i] is a pointer to a function that will xor "i"  * bufs into the accumulating sum.  */
end_comment

begin_decl_stmt
specifier|static
name|RF_VoidFuncPtr
name|nWayXorFuncs
index|[]
init|=
block|{
name|NULL
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor1
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor2
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor3
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor4
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor5
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor6
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor7
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor8
block|,
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_nWayXor9
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rf_SubmitReconBuffer
parameter_list|(
name|rbuf
parameter_list|,
name|keep_it
parameter_list|,
name|use_committed
parameter_list|)
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
comment|/* the recon buffer to submit */
name|int
name|keep_it
decl_stmt|;
comment|/* whether we can keep this buffer or we have 				 * to return it */
name|int
name|use_committed
decl_stmt|;
comment|/* whether to use a committed or an available 				 * recon buffer */
block|{
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|lp
operator|=
name|rbuf
operator|->
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
name|rc
operator|=
name|lp
operator|->
name|SubmitReconBuffer
argument_list|(
name|rbuf
argument_list|,
name|keep_it
argument_list|,
name|use_committed
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_SubmitReconBufferBasic
parameter_list|(
name|rbuf
parameter_list|,
name|keep_it
parameter_list|,
name|use_committed
parameter_list|)
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
comment|/* the recon buffer to submit */
name|int
name|keep_it
decl_stmt|;
comment|/* whether we can keep this buffer or we have 				 * to return it */
name|int
name|use_committed
decl_stmt|;
comment|/* whether to use a committed or an available 				 * recon buffer */
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|rbuf
operator|->
name|raidPtr
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|rbuf
operator|->
name|row
index|]
decl_stmt|;
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|targetRbuf
decl_stmt|,
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
comment|/* temporary rbuf 							 * pointers */
name|caddr_t
name|ta
decl_stmt|;
comment|/* temporary data buffer pointer */
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|,
name|created
init|=
literal|0
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
comment|/* makes no sense to have a submission from the failed disk */
name|RF_ASSERT
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|rbuf
operator|->
name|col
operator|!=
name|reconCtrlPtr
operator|->
name|fcol
argument_list|)
expr_stmt|;
name|Dprintf5
argument_list|(
literal|"RECON: submission by row %d col %d for psid %ld ru %d (failed offset %ld)\n"
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|failedDiskSectorOffset
argument_list|)
expr_stmt|;
name|RF_LOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|pssPtr
operator|=
name|rf_LookupRUStatus
argument_list|(
name|raidPtr
argument_list|,
name|reconCtrlPtr
operator|->
name|pssTable
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|,
name|RF_PSS_NONE
argument_list|,
operator|&
name|created
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pssPtr
argument_list|)
expr_stmt|;
comment|/* if it didn't exist, we wouldn't have gotten 				 * an rbuf for it */
comment|/* check to see if enough buffers have accumulated to do an XOR.  If 	 * so, there's no need to acquire a floating rbuf.  Before we can do 	 * any XORing, we must have acquired a destination buffer.  If we 	 * have, then we can go ahead and do the XOR if (1) including this 	 * buffer, enough bufs have accumulated, or (2) this is the last 	 * submission for this stripe. Otherwise, we have to go acquire a 	 * floating rbuf. */
name|targetRbuf
operator|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|pssPtr
operator|->
name|rbuf
expr_stmt|;
if|if
condition|(
operator|(
name|targetRbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|pssPtr
operator|->
name|xorBufCount
operator|==
name|rf_numBufsToAccumulate
operator|-
literal|1
operator|)
operator|||
operator|(
name|targetRbuf
operator|->
name|count
operator|+
name|pssPtr
operator|->
name|xorBufCount
operator|+
literal|1
operator|==
name|layoutPtr
operator|->
name|numDataCol
operator|)
operator|)
condition|)
block|{
name|pssPtr
operator|->
name|rbufsForXor
index|[
name|pssPtr
operator|->
name|xorBufCount
operator|++
index|]
operator|=
name|rbuf
expr_stmt|;
comment|/* install this buffer */
name|Dprintf3
argument_list|(
literal|"RECON: row %d col %d invoking a %d-way XOR\n"
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|,
name|pssPtr
operator|->
name|xorBufCount
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_MultiWayReconXor
argument_list|(
name|raidPtr
argument_list|,
name|pssPtr
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|accumXorTimeUs
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keep_it
condition|)
block|{
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|xor_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|specific
operator|.
name|recon
operator|.
name|recon_return_to_submit_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|rf_LogTraceRec
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
argument_list|)
expr_stmt|;
block|}
name|rf_CheckForFullRbuf
argument_list|(
name|raidPtr
argument_list|,
name|reconCtrlPtr
argument_list|,
name|pssPtr
argument_list|,
name|layoutPtr
operator|->
name|numDataCol
argument_list|)
expr_stmt|;
comment|/* if use_committed is on, we _must_ consume a buffer off the 		 * committed list. */
if|if
condition|(
name|use_committed
condition|)
block|{
name|t
operator|=
name|reconCtrlPtr
operator|->
name|committedRbufs
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|reconCtrlPtr
operator|->
name|committedRbufs
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|rf_ReleaseFloatingReconBuffer
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keep_it
condition|)
block|{
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
name|rf_FreeReconBuffer
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* set the value of "t", which we'll use as the rbuf from here on */
if|if
condition|(
name|keep_it
condition|)
block|{
name|t
operator|=
name|rbuf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|use_committed
condition|)
block|{
comment|/* if a buffer has been committed to 					 * us, use it */
name|t
operator|=
name|reconCtrlPtr
operator|->
name|committedRbufs
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|reconCtrlPtr
operator|->
name|committedRbufs
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reconCtrlPtr
operator|->
name|floatingRbufs
condition|)
block|{
name|t
operator|=
name|reconCtrlPtr
operator|->
name|floatingRbufs
expr_stmt|;
name|reconCtrlPtr
operator|->
name|floatingRbufs
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If we weren't able to acquire a buffer, append to the end of the 	 * buf list in the recon ctrl struct. */
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|RF_ASSERT
argument_list|(
operator|!
name|keep_it
operator|&&
operator|!
name|use_committed
argument_list|)
expr_stmt|;
name|Dprintf2
argument_list|(
literal|"RECON: row %d col %d failed to acquire floating rbuf\n"
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|procsInBufWait
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|raidPtr
operator|->
name|procsInBufWait
operator|==
name|raidPtr
operator|->
name|numCol
operator|-
literal|1
operator|)
operator|&&
operator|(
name|raidPtr
operator|->
name|numFullReconBuffers
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Buffer wait deadlock detected.  Exiting.\n"
argument_list|)
expr_stmt|;
name|rf_PrintPSStatusTable
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|pssPtr
operator|->
name|flags
operator||=
name|RF_PSS_BUFFERWAIT
expr_stmt|;
name|cb
operator|=
name|rf_AllocCallbackDesc
argument_list|()
expr_stmt|;
comment|/* append to buf wait list in 						 * recon ctrl structure */
name|cb
operator|->
name|row
operator|=
name|rbuf
operator|->
name|row
expr_stmt|;
name|cb
operator|->
name|col
operator|=
name|rbuf
operator|->
name|col
expr_stmt|;
name|cb
operator|->
name|callbackArg
operator|.
name|v
operator|=
name|rbuf
operator|->
name|parityStripeID
expr_stmt|;
name|cb
operator|->
name|callbackArg2
operator|.
name|v
operator|=
name|rbuf
operator|->
name|which_ru
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|reconCtrlPtr
operator|->
name|bufferWaitList
condition|)
name|reconCtrlPtr
operator|->
name|bufferWaitList
operator|=
name|cb
expr_stmt|;
else|else
block|{
comment|/* might want to maintain head/tail pointers 				 * here rather than search for end of list */
for|for
control|(
name|p
operator|=
name|reconCtrlPtr
operator|->
name|bufferWaitList
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|cb
expr_stmt|;
block|}
name|retcode
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|Dprintf2
argument_list|(
literal|"RECON: row %d col %d acquired rbuf\n"
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|specific
operator|.
name|recon
operator|.
name|recon_return_to_submit_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
operator|.
name|recon_timer
argument_list|)
expr_stmt|;
name|rf_LogTraceRec
argument_list|(
name|raidPtr
argument_list|,
operator|&
name|raidPtr
operator|->
name|recon_tracerecs
index|[
name|rbuf
operator|->
name|col
index|]
argument_list|)
expr_stmt|;
comment|/* initialize the buffer */
if|if
condition|(
name|t
operator|!=
name|rbuf
condition|)
block|{
name|t
operator|->
name|row
operator|=
name|rbuf
operator|->
name|row
expr_stmt|;
name|t
operator|->
name|col
operator|=
name|reconCtrlPtr
operator|->
name|fcol
expr_stmt|;
name|t
operator|->
name|parityStripeID
operator|=
name|rbuf
operator|->
name|parityStripeID
expr_stmt|;
name|t
operator|->
name|which_ru
operator|=
name|rbuf
operator|->
name|which_ru
expr_stmt|;
name|t
operator|->
name|failedDiskSectorOffset
operator|=
name|rbuf
operator|->
name|failedDiskSectorOffset
expr_stmt|;
name|t
operator|->
name|spRow
operator|=
name|rbuf
operator|->
name|spRow
expr_stmt|;
name|t
operator|->
name|spCol
operator|=
name|rbuf
operator|->
name|spCol
expr_stmt|;
name|t
operator|->
name|spOffset
operator|=
name|rbuf
operator|->
name|spOffset
expr_stmt|;
name|ta
operator|=
name|t
operator|->
name|buffer
expr_stmt|;
name|t
operator|->
name|buffer
operator|=
name|rbuf
operator|->
name|buffer
expr_stmt|;
name|rbuf
operator|->
name|buffer
operator|=
name|ta
expr_stmt|;
comment|/* swap buffers */
block|}
comment|/* the first installation always gets installed as the destination 	 * buffer. subsequent installations get stacked up to allow for 	 * multi-way XOR */
if|if
condition|(
operator|!
name|pssPtr
operator|->
name|rbuf
condition|)
block|{
name|pssPtr
operator|->
name|rbuf
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pssPtr
operator|->
name|rbufsForXor
index|[
name|pssPtr
operator|->
name|xorBufCount
operator|++
index|]
operator|=
name|t
expr_stmt|;
comment|/* install this buffer */
name|rf_CheckForFullRbuf
argument_list|(
name|raidPtr
argument_list|,
name|reconCtrlPtr
argument_list|,
name|pssPtr
argument_list|,
name|layoutPtr
operator|->
name|numDataCol
argument_list|)
expr_stmt|;
comment|/* the buffer is full if 											 * G=2 */
name|out
label|:
name|RF_UNLOCK_PSS_MUTEX
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|parityStripeID
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_MultiWayReconXor
parameter_list|(
name|raidPtr
parameter_list|,
name|pssPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
comment|/* the pss descriptor for this 						 * parity stripe */
block|{
name|int
name|i
decl_stmt|,
name|numBufs
init|=
name|pssPtr
operator|->
name|xorBufCount
decl_stmt|;
name|int
name|numBytes
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|*
name|raidPtr
operator|->
name|Layout
operator|.
name|SUsPerRU
argument_list|)
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
modifier|*
name|rbufs
init|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|*
operator|)
name|pssPtr
operator|->
name|rbufsForXor
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|targetRbuf
init|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|pssPtr
operator|->
name|rbuf
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|pssPtr
operator|->
name|rbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|numBufs
operator|>
literal|0
operator|&&
name|numBufs
operator|<
name|RF_PS_MAX_BUFS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
ifndef|#
directive|ifndef
name|__NetBSD__
ifndef|#
directive|ifndef
name|__FreeBSD__
name|thread_block
argument_list|()
expr_stmt|;
comment|/* yield the processor before doing a big XOR */
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* _KERNEL */
comment|/*          * XXX          *          * What if more than 9 bufs?          */
name|nWayXorFuncs
index|[
name|numBufs
index|]
operator|(
name|pssPtr
operator|->
name|rbufsForXor
operator|,
name|targetRbuf
operator|,
name|numBytes
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
expr_stmt|;
comment|/* release all the reconstruction buffers except the last one, which 	 * belongs to the disk whose submission caused this XOR to take place */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numBufs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rbufs
index|[
name|i
index|]
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FLOATING
condition|)
name|rf_ReleaseFloatingReconBuffer
argument_list|(
name|raidPtr
argument_list|,
name|rbufs
index|[
name|i
index|]
operator|->
name|row
argument_list|,
name|rbufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rbufs
index|[
name|i
index|]
operator|->
name|type
operator|==
name|RF_RBUF_TYPE_FORCED
condition|)
name|rf_FreeReconBuffer
argument_list|(
name|rbufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|targetRbuf
operator|->
name|count
operator|+=
name|pssPtr
operator|->
name|xorBufCount
expr_stmt|;
name|pssPtr
operator|->
name|xorBufCount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* removes one full buffer from one of the full-buffer lists and returns it.  *  * ASSUMES THE RB_MUTEX IS UNLOCKED AT ENTRY.  */
end_comment

begin_function
name|RF_ReconBuffer_t
modifier|*
name|rf_GetFullReconBuffer
parameter_list|(
name|reconCtrlPtr
parameter_list|)
name|RF_ReconCtrl_t
modifier|*
name|reconCtrlPtr
decl_stmt|;
block|{
name|RF_ReconBuffer_t
modifier|*
name|p
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|reconCtrlPtr
operator|->
name|priorityList
operator|)
operator|!=
name|NULL
condition|)
block|{
name|reconCtrlPtr
operator|->
name|priorityList
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|reconCtrlPtr
operator|->
name|fullBufferList
operator|)
operator|!=
name|NULL
condition|)
block|{
name|reconCtrlPtr
operator|->
name|fullBufferList
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|RF_UNLOCK_MUTEX
argument_list|(
name|reconCtrlPtr
operator|->
name|rb_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* if the reconstruction buffer is full, move it to the full list,  * which is maintained sorted by failed disk sector offset  *  * ASSUMES THE RB_MUTEX IS LOCKED AT ENTRY.  */
end_comment

begin_function
name|int
name|rf_CheckForFullRbuf
parameter_list|(
name|raidPtr
parameter_list|,
name|reconCtrl
parameter_list|,
name|pssPtr
parameter_list|,
name|numDataCol
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ReconCtrl_t
modifier|*
name|reconCtrl
decl_stmt|;
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
name|int
name|numDataCol
decl_stmt|;
block|{
name|RF_ReconBuffer_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pt
decl_stmt|,
modifier|*
name|rbuf
init|=
operator|(
name|RF_ReconBuffer_t
operator|*
operator|)
name|pssPtr
operator|->
name|rbuf
decl_stmt|;
if|if
condition|(
name|rbuf
operator|->
name|count
operator|==
name|numDataCol
condition|)
block|{
name|raidPtr
operator|->
name|numFullReconBuffers
operator|++
expr_stmt|;
name|Dprintf2
argument_list|(
literal|"RECON: rbuf for psid %ld ru %d has filled\n"
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reconCtrl
operator|->
name|fullBufferList
operator|||
operator|(
name|rbuf
operator|->
name|failedDiskSectorOffset
operator|<
name|reconCtrl
operator|->
name|fullBufferList
operator|->
name|failedDiskSectorOffset
operator|)
condition|)
block|{
name|Dprintf2
argument_list|(
literal|"RECON: rbuf for psid %ld ru %d is head of list\n"
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|next
operator|=
name|reconCtrl
operator|->
name|fullBufferList
expr_stmt|;
name|reconCtrl
operator|->
name|fullBufferList
operator|=
name|rbuf
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|pt
operator|=
name|reconCtrl
operator|->
name|fullBufferList
operator|,
name|p
operator|=
name|pt
operator|->
name|next
init|;
name|p
operator|&&
name|p
operator|->
name|failedDiskSectorOffset
operator|<
name|rbuf
operator|->
name|failedDiskSectorOffset
condition|;
name|pt
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|rbuf
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|pt
operator|->
name|next
operator|=
name|rbuf
expr_stmt|;
name|Dprintf2
argument_list|(
literal|"RECON: rbuf for psid %ld ru %d is in list\n"
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|pssPtr->writeRbuf = pssPtr->rbuf;
comment|/* DEBUG ONLY:  we like 							 * to be able to find 							 * this rbuf while it's 							 * awaiting write */
else|#
directive|else
name|rbuf
operator|->
name|pssPtr
operator|=
name|pssPtr
expr_stmt|;
endif|#
directive|endif
name|pssPtr
operator|->
name|rbuf
operator|=
name|NULL
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|rbuf
operator|->
name|row
argument_list|,
name|rbuf
operator|->
name|col
argument_list|,
name|NULL
argument_list|,
name|RF_REVENT_BUFREADY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* release a floating recon buffer for someone else to use.  * assumes the rb_mutex is LOCKED at entry  */
end_comment

begin_function
name|void
name|rf_ReleaseFloatingReconBuffer
parameter_list|(
name|raidPtr
parameter_list|,
name|row
parameter_list|,
name|rbuf
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RowCol_t
name|row
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
block|{
name|RF_ReconCtrl_t
modifier|*
name|rcPtr
init|=
name|raidPtr
operator|->
name|reconControl
index|[
name|row
index|]
decl_stmt|;
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|;
name|Dprintf2
argument_list|(
literal|"RECON: releasing rbuf for psid %ld ru %d\n"
argument_list|,
operator|(
name|long
operator|)
name|rbuf
operator|->
name|parityStripeID
argument_list|,
name|rbuf
operator|->
name|which_ru
argument_list|)
expr_stmt|;
comment|/* if anyone is waiting on buffers, wake one of them up.  They will 	 * subsequently wake up anyone else waiting on their RU */
if|if
condition|(
name|rcPtr
operator|->
name|bufferWaitList
condition|)
block|{
name|rbuf
operator|->
name|next
operator|=
name|rcPtr
operator|->
name|committedRbufs
expr_stmt|;
name|rcPtr
operator|->
name|committedRbufs
operator|=
name|rbuf
expr_stmt|;
name|cb
operator|=
name|rcPtr
operator|->
name|bufferWaitList
expr_stmt|;
name|rcPtr
operator|->
name|bufferWaitList
operator|=
name|cb
operator|->
name|next
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|cb
operator|->
name|row
argument_list|,
name|cb
operator|->
name|col
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|RF_REVENT_BUFCLEAR
argument_list|)
expr_stmt|;
comment|/* arg==1 => we've 												 * committed a buffer */
name|rf_FreeCallbackDesc
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|procsInBufWait
operator|--
expr_stmt|;
block|}
else|else
block|{
name|rbuf
operator|->
name|next
operator|=
name|rcPtr
operator|->
name|floatingRbufs
expr_stmt|;
name|rcPtr
operator|->
name|floatingRbufs
operator|=
name|rbuf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* release any disk that is waiting on a buffer for the indicated RU.  * assumes the rb_mutex is LOCKED at entry  */
end_comment

begin_function
name|void
name|rf_ReleaseBufferWaiters
parameter_list|(
name|raidPtr
parameter_list|,
name|pssPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_ReconParityStripeStatus_t
modifier|*
name|pssPtr
decl_stmt|;
block|{
name|RF_CallbackDesc_t
modifier|*
name|cb1
decl_stmt|,
modifier|*
name|cb
init|=
name|pssPtr
operator|->
name|bufWaitList
decl_stmt|;
name|Dprintf2
argument_list|(
literal|"RECON: releasing buf waiters for psid %ld ru %d\n"
argument_list|,
operator|(
name|long
operator|)
name|pssPtr
operator|->
name|parityStripeID
argument_list|,
name|pssPtr
operator|->
name|which_ru
argument_list|)
expr_stmt|;
name|pssPtr
operator|->
name|flags
operator|&=
operator|~
name|RF_PSS_BUFFERWAIT
expr_stmt|;
while|while
condition|(
name|cb
condition|)
block|{
name|cb1
operator|=
name|cb
operator|->
name|next
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
name|raidPtr
argument_list|,
name|cb
operator|->
name|row
argument_list|,
name|cb
operator|->
name|col
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|RF_REVENT_BUFCLEAR
argument_list|)
expr_stmt|;
comment|/* arg==0 => we haven't 												 * committed a buffer */
name|rf_FreeCallbackDesc
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|=
name|cb1
expr_stmt|;
block|}
name|pssPtr
operator|->
name|bufWaitList
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* when reconstruction is forced on an RU, there may be some disks waiting to  * acquire a buffer for that RU.  Since we allocate a new buffer as part of  * the forced-reconstruction process, we no longer have to wait for any  * buffers, so we wakeup any waiter that we find in the bufferWaitList  *  * assumes the rb_mutex is LOCKED at entry  */
end_comment

begin_function
name|void
name|rf_ReleaseBufferWaiter
parameter_list|(
name|rcPtr
parameter_list|,
name|rbuf
parameter_list|)
name|RF_ReconCtrl_t
modifier|*
name|rcPtr
decl_stmt|;
name|RF_ReconBuffer_t
modifier|*
name|rbuf
decl_stmt|;
block|{
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|,
modifier|*
name|cbt
decl_stmt|;
for|for
control|(
name|cbt
operator|=
name|NULL
operator|,
name|cb
operator|=
name|rcPtr
operator|->
name|bufferWaitList
init|;
name|cb
condition|;
name|cbt
operator|=
name|cb
operator|,
name|cb
operator|=
name|cb
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|cb
operator|->
name|callbackArg
operator|.
name|v
operator|==
name|rbuf
operator|->
name|parityStripeID
operator|)
operator|&&
operator|(
name|cb
operator|->
name|callbackArg2
operator|.
name|v
operator|==
name|rbuf
operator|->
name|which_ru
operator|)
condition|)
block|{
name|Dprintf2
argument_list|(
literal|"RECON: Dropping row %d col %d from buffer wait list\n"
argument_list|,
name|cb
operator|->
name|row
argument_list|,
name|cb
operator|->
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbt
condition|)
name|cbt
operator|->
name|next
operator|=
name|cb
operator|->
name|next
expr_stmt|;
else|else
name|rcPtr
operator|->
name|bufferWaitList
operator|=
name|cb
operator|->
name|next
expr_stmt|;
name|rf_CauseReconEvent
argument_list|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|rbuf
operator|->
name|raidPtr
argument_list|,
name|cb
operator|->
name|row
argument_list|,
name|cb
operator|->
name|col
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|RF_REVENT_BUFREADY
argument_list|)
expr_stmt|;
comment|/* arg==0 => no 																 * committed buffer */
name|rf_FreeCallbackDesc
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

end_unit

