begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_parityloggingdags.c,v 1.4 2000/01/07 03:41:04 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
end_if

begin_comment
comment|/*   DAGs specific to parity logging are created here  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylog.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityloggingdags.h>
end_include

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a large-write operation:  *  *         / Rod \     / Wnd \  * H -- NIL- Rod - NIL - Wnd ------ NIL - T  *         \ Rod /     \ Xor - Lpo /  *  * The writes are not done until the reads complete because if they were done in  * parallel, a failure on one of the reads could leave the parity in an inconsistent  * state, so that the retry with a new DAG would produce erroneous parity.  *  * Note:  this DAG has the nasty property that none of the buffers allocated for reading  *        old data can be freed until the XOR node fires.  Need to fix this.  *  * The last two arguments are the number of faults tolerated, and function for the  * redundancy calculation. The undo for the redundancy calc is assumed to be null  *  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CommonCreateParityLoggingLargeWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|int
name|nfaults
parameter_list|,
name|int
function_decl|(
modifier|*
name|redFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wndNodes
decl_stmt|,
modifier|*
name|rodNodes
init|=
name|NULL
decl_stmt|,
modifier|*
name|syncNode
decl_stmt|,
modifier|*
name|xorNode
decl_stmt|,
modifier|*
name|lpoNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|int
name|nWndNodes
decl_stmt|,
name|nRodNodes
decl_stmt|,
name|i
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|new_asm_h
index|[
literal|2
index|]
decl_stmt|;
name|int
name|nodeNum
decl_stmt|,
name|asmNum
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|char
modifier|*
name|sosBuffer
decl_stmt|,
modifier|*
name|eosBuffer
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
init|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
decl_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating parity-logging large-write DAG]\n"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|nfaults
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* this arch only single fault tolerant */
name|dag_h
operator|->
name|creator
operator|=
literal|"ParityLoggingLargeWriteDAG"
expr_stmt|;
comment|/* alloc the Wnd nodes, the xor node, and the Lpo node */
name|nWndNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nWndNodes
operator|+
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|wndNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWndNodes
expr_stmt|;
name|xorNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|lpoNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|syncNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|unblockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
name|nWndNodes
operator|+
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|rf_MapUnaccessedPortionOfStripe
argument_list|(
name|raidPtr
argument_list|,
name|layoutPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|new_asm_h
argument_list|,
operator|&
name|nRodNodes
argument_list|,
operator|&
name|sosBuffer
argument_list|,
operator|&
name|eosBuffer
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRodNodes
operator|>
literal|0
condition|)
name|RF_CallocAndAdd
argument_list|(
name|rodNodes
argument_list|,
name|nRodNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* begin node initialization */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nRodNodes
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nWndNodes
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|syncNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nWndNodes
operator|+
literal|1
argument_list|,
name|nRodNodes
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize the Rod nodes */
for|for
control|(
name|nodeNum
operator|=
name|asmNum
operator|=
literal|0
init|;
name|asmNum
operator|<
literal|2
condition|;
name|asmNum
operator|++
control|)
block|{
if|if
condition|(
name|new_asm_h
index|[
name|asmNum
index|]
condition|)
block|{
name|pda
operator|=
name|new_asm_h
index|[
name|asmNum
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
expr_stmt|;
while|while
condition|(
name|pda
condition|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rodNodes
index|[
name|nodeNum
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rodNodes
index|[
name|nodeNum
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|nodeNum
operator|++
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|RF_ASSERT
argument_list|(
name|nodeNum
operator|==
name|nRodNodes
argument_list|)
expr_stmt|;
comment|/* initialize the wnd nodes */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|wndNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize the redundancy node */
name|rf_InitNode
argument_list|(
name|xorNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|redFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
literal|"Xr "
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buf ptr */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buf ptr */
block|}
name|xorNode
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|nWndNodes
operator|+
name|nRodNodes
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* xor node needs to get 									 * at RAID information */
comment|/* look for an Rod node that reads a complete SU.  If none, alloc a 	 * buffer to receive the parity info. Note that we can't use a new 	 * data buffer because it will not have gotten written when the xor 	 * occurs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|)
operator|->
name|numSector
operator|==
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nRodNodes
condition|)
block|{
name|RF_CallocAndAdd
argument_list|(
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|rodNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
block|}
comment|/* initialize the Lpo node */
name|rf_InitNode
argument_list|(
name|lpoNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_ParityLogOverwriteFunc
argument_list|,
name|rf_ParityLogOverwriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Lpo"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|lpoNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|lpoNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* parityInfo must 							 * describe entire 							 * parity unit */
comment|/* connect nodes to form graph */
comment|/* connect dag header to block node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect the block node to the Rod nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
name|nRodNodes
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rodNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|rodNodes
index|[
name|i
index|]
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rodNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the block node to the sync node */
comment|/* necessary if nRodNodes == 0 */
name|RF_ASSERT
argument_list|(
name|syncNode
operator|->
name|numAntecedents
operator|==
name|nRodNodes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|nRodNodes
index|]
operator|=
name|syncNode
expr_stmt|;
name|syncNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|syncNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect the Rod nodes to the syncNode */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRodNodes
condition|;
name|i
operator|++
control|)
block|{
name|rodNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|syncNode
operator|->
name|antecedents
index|[
literal|1
operator|+
name|i
index|]
operator|=
operator|&
name|rodNodes
index|[
name|i
index|]
expr_stmt|;
name|syncNode
operator|->
name|antType
index|[
literal|1
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the sync node to the xor node */
name|RF_ASSERT
argument_list|(
name|syncNode
operator|->
name|numSuccedents
operator|==
name|nWndNodes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|syncNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
comment|/* carry forward from sync */
comment|/* connect the sync node to the Wnd nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|syncNode
operator|->
name|succedents
index|[
literal|1
operator|+
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|syncNode
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the xor node to the Lpo node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|lpoNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|lpoNode
expr_stmt|;
name|lpoNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|lpoNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
comment|/* connect the Wnd nodes to the unblock node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numAntecedents
operator|==
name|nWndNodes
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect the Lpo node to the unblock node */
name|RF_ASSERT
argument_list|(
name|lpoNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lpoNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|nWndNodes
index|]
operator|=
name|lpoNode
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|nWndNodes
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unblock node to terminator */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  *  * creates a DAG to perform a small-write operation (either raid 5 or pq), which is as follows:  *  *                                     Header  *                                       |  *                                     Block  *                                 / |  ... \   \  *                                /  |       \   \  *                             Rod  Rod      Rod  Rop  *                             | \ /| \    / |  \/ |  *                             |    |        |  /\ |  *                             Wnd  Wnd      Wnd   X  *                              |    \       /     |  *                              |     \     /      |  *                               \     \   /      Lpo  *                                \     \ /       /  *                                 +-> Unblock<-+  *                                       |  *                                       T  *  *  * R = Read, W = Write, X = Xor, o = old, n = new, d = data, p = parity.  * When the access spans a stripe unit boundary and is less than one SU in size, there will  * be two Rop -- X -- Wnp branches.  I call this the "double-XOR" case.  * The second output from each Rod node goes to the X node.  In the double-XOR  * case, there are exactly 2 Rod nodes, and each sends one output to one X node.  * There is one Rod -- Wnd -- T branch for each stripe unit being updated.  *  * The block and unblock nodes are unused.  See comment above CreateFaultFreeReadDAG.  *  * Note:  this DAG ignores all the optimizations related to making the RMWs atomic.  *        it also has the nasty property that none of the buffers allocated for reading  *        old data& parity can be freed until the XOR node fires.  Need to fix this.  *  * A null qfuncs indicates single fault tolerant  *****************************************************************************/
end_comment

begin_function
name|void
name|rf_CommonCreateParityLoggingSmallWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|pfuncs
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|qfuncs
parameter_list|)
block|{
name|RF_DagNode_t
modifier|*
name|xorNodes
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|nodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|readDataNodes
decl_stmt|,
modifier|*
name|readParityNodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|writeDataNodes
decl_stmt|,
modifier|*
name|lpuNodes
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|unlockDataNodes
init|=
name|NULL
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
init|=
name|asmap
operator|->
name|physInfo
decl_stmt|;
name|int
name|numDataNodes
init|=
name|asmap
operator|->
name|numStripeUnitsAccessed
decl_stmt|;
name|int
name|numParityNodes
init|=
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|)
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nNodes
decl_stmt|,
name|totalNumNodes
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
name|node
argument_list|)
decl_stmt|,
argument_list|(
operator|*
name|undoFunc
argument_list|)
argument_list|(
name|RF_DagNode_t
operator|*
name|node
argument_list|)
decl_stmt|;
name|int
function_decl|(
modifier|*
name|qfunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
function_decl|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|qname
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
init|=
name|rf_RaidAddressToParityStripeID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
decl_stmt|;
name|long
name|nfaults
init|=
name|qfuncs
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|lu_flag
init|=
operator|(
name|rf_enableAtomicRMW
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* lock/unlock flag */
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating parity-logging small-write DAG]\n"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|numDataNodes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|nfaults
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"ParityLoggingSmallWriteDAG"
expr_stmt|;
comment|/* DAG creation occurs in three steps: 1. count the number of nodes in 	 * the DAG 2. create the nodes 3. initialize the nodes 4. connect the 	 * nodes */
comment|/* Step 1. compute number of nodes in the graph */
comment|/* number of nodes: a read and write for each data unit a redundancy 	 * computation node for each parity node a read and Lpu for each 	 * parity unit a block and unblock node (2) a terminator node if 	 * atomic RMW an unlock node for each data unit, redundancy unit */
name|totalNumNodes
operator|=
operator|(
literal|2
operator|*
name|numDataNodes
operator|)
operator|+
name|numParityNodes
operator|+
operator|(
literal|2
operator|*
name|numParityNodes
operator|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
name|totalNumNodes
operator|+=
name|numDataNodes
expr_stmt|;
name|nNodes
operator|=
name|numDataNodes
operator|+
name|numParityNodes
expr_stmt|;
name|dag_h
operator|->
name|numCommitNodes
operator|=
name|numDataNodes
operator|+
name|numParityNodes
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
comment|/* Step 2. create the nodes */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|totalNumNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|unblockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|readDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|readParityNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|writeDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
name|lpuNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|xorNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numParityNodes
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
name|unlockDataNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|numDataNodes
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|totalNumNodes
argument_list|)
expr_stmt|;
comment|/* Step 3. initialize the nodes */
comment|/* initialize block node (Nil) */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize unblock node (Nil) */
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize terminatory node (Trm) */
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* initialize nodes which read old data (Rod) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|readDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
name|nNodes
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rod"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 							 * desc */
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* buffer to hold old 												 * data */
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
name|lu_flag
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* initialize nodes which read old parity (Rop) */
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|readParityNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
name|nNodes
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rop"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|rf_AllocBuffer
argument_list|(
name|raidPtr
argument_list|,
name|dag_h
argument_list|,
name|pda
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* buffer to hold old 													 * parity */
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|propList
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize nodes which write new data (Wnd) */
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|writeDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
name|nNodes
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 							 * desc */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
comment|/* buffer holding new 								 * data to be written */
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* initialize node to unlock the disk queue */
name|rf_InitNode
argument_list|(
operator|&
name|unlockDataNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskUnlockFunc
argument_list|,
name|rf_DiskUnlockUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Und"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* physical disk addr 								 * desc */
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
name|lu_flag
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* initialize nodes which compute new parity */
comment|/* we use the simple XOR func in the double-XOR case, and when we're 	 * accessing only a portion of one stripe unit. the distinction 	 * between the two is that the regular XOR func assumes that the 	 * targbuf is a full SU in size, and examines the pda associated with 	 * the buffer to decide where within the buffer to XOR the data, 	 * whereas the simple XOR func just XORs the data into the start of 	 * the buffer. */
if|if
condition|(
operator|(
name|numParityNodes
operator|==
literal|2
operator|)
operator|||
operator|(
operator|(
name|numDataNodes
operator|==
literal|1
operator|)
operator|&&
operator|(
name|asmap
operator|->
name|totalSectorsAccessed
operator|<
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
operator|)
operator|)
condition|)
block|{
name|func
operator|=
name|pfuncs
operator|->
name|simple
expr_stmt|;
name|undoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|name
operator|=
name|pfuncs
operator|->
name|SimpleName
expr_stmt|;
if|if
condition|(
name|qfuncs
condition|)
block|{
name|qfunc
operator|=
name|qfuncs
operator|->
name|simple
expr_stmt|;
name|qname
operator|=
name|qfuncs
operator|->
name|SimpleName
expr_stmt|;
block|}
block|}
else|else
block|{
name|func
operator|=
name|pfuncs
operator|->
name|regular
expr_stmt|;
name|undoFunc
operator|=
name|rf_NullNodeUndoFunc
expr_stmt|;
name|name
operator|=
name|pfuncs
operator|->
name|RegularName
expr_stmt|;
if|if
condition|(
name|qfuncs
condition|)
block|{
name|qfunc
operator|=
name|qfuncs
operator|->
name|regular
expr_stmt|;
name|qname
operator|=
name|qfuncs
operator|->
name|RegularName
expr_stmt|;
block|}
block|}
comment|/* initialize the xor nodes: params are {pda,buf} from {Rod,Wnd,Rop} 	 * nodes, and raidPtr  */
if|if
condition|(
name|numParityNodes
operator|==
literal|2
condition|)
block|{
comment|/* double-xor case */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|xorNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|func
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nNodes
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* no wakeup func for 																	 * xor */
name|xorNodes
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|6
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readParityNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
comment|/* use old parity buf as 											 * target buf */
block|}
block|}
else|else
block|{
comment|/* there is only one xor node in this case */
name|rf_InitNode
argument_list|(
operator|&
name|xorNodes
index|[
literal|0
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|func
argument_list|,
name|undoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nNodes
argument_list|,
operator|(
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|xorNodes
index|[
literal|0
index|]
operator|.
name|flags
operator||=
name|RF_DAGNODE_FLAG_YIELD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Rod and Rop nodes */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|readDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* set up params related to Wnd and Wnp nodes */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|0
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
comment|/* pda */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|=
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
comment|/* buffer pointer */
block|}
name|xorNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|2
operator|*
operator|(
name|numDataNodes
operator|+
name|numDataNodes
operator|+
literal|1
operator|)
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
comment|/* xor node needs to get 											 * at RAID information */
name|xorNodes
index|[
literal|0
index|]
operator|.
name|results
index|[
literal|0
index|]
operator|=
name|readParityNodes
index|[
literal|0
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
block|}
comment|/* initialize the log node(s) */
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|lpuNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_ParityLogUpdateFunc
argument_list|,
name|rf_ParityLogUpdateUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Lpu"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|lpuNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
comment|/* PhysDiskAddr of parity */
name|lpuNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNodes
index|[
name|i
index|]
operator|.
name|results
index|[
literal|0
index|]
expr_stmt|;
comment|/* buffer pointer to 									 * parity */
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* Step 4. connect the nodes */
comment|/* connect header to block node */
name|RF_ASSERT
argument_list|(
name|dag_h
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* connect block node to read old data nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
operator|(
name|numDataNodes
operator|+
name|numParityNodes
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect block node to read old parity nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|readParityNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect read old data nodes to write new data nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numDataNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|j
index|]
operator|.
name|numAntecedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|j
index|]
expr_stmt|;
name|writeDataNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
name|writeDataNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_antiData
expr_stmt|;
else|else
name|writeDataNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
comment|/* connect read old data nodes to xor nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|xorNodes
index|[
name|j
index|]
operator|.
name|numAntecedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
name|readDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|numDataNodes
operator|+
name|j
index|]
operator|=
operator|&
name|xorNodes
index|[
name|j
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|readDataNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* connect read old parity nodes to write new data nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|readParityNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
name|numDataNodes
operator|+
name|numParityNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numDataNodes
condition|;
name|j
operator|++
control|)
block|{
name|readParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|j
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|j
index|]
expr_stmt|;
name|writeDataNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|writeDataNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
comment|/* connect read old parity nodes to xor nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numParityNodes
condition|;
name|j
operator|++
control|)
block|{
name|readParityNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
name|numDataNodes
operator|+
name|j
index|]
operator|=
operator|&
name|xorNodes
index|[
name|j
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|readParityNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNodes
index|[
name|j
index|]
operator|.
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* connect xor nodes to write new parity nodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|xorNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|lpuNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|lpuNodes
index|[
name|i
index|]
expr_stmt|;
name|lpuNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|xorNodes
index|[
name|i
index|]
expr_stmt|;
name|lpuNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataNodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lu_flag
condition|)
block|{
comment|/* connect write new data nodes to unlock nodes */
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
operator|&
name|unlockDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* connect unlock nodes to unblock node */
name|RF_ASSERT
argument_list|(
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numAntecedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
name|unlockDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|unlockDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
else|else
block|{
comment|/* connect write new data nodes to unblock node */
name|RF_ASSERT
argument_list|(
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numAntecedents
operator|==
operator|(
name|numDataNodes
operator|+
operator|(
name|nfaults
operator|*
name|numParityNodes
operator|)
operator|)
argument_list|)
expr_stmt|;
name|writeDataNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|writeDataNodes
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
block|}
comment|/* connect write new parity nodes to unblock node */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numParityNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|lpuNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lpuNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
operator|&
name|lpuNodes
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|numDataNodes
operator|+
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* connect unblock node to terminator */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateParityLoggingSmallWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|pfuncs
parameter_list|,
name|RF_RedFuncs_t
modifier|*
name|qfuncs
parameter_list|)
block|{
name|dag_h
operator|->
name|creator
operator|=
literal|"ParityLoggingSmallWriteDAG"
expr_stmt|;
name|rf_CommonCreateParityLoggingSmallWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
operator|&
name|rf_xorFuncs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_CreateParityLoggingLargeWriteDAG
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|int
name|nfaults
parameter_list|,
name|int
function_decl|(
modifier|*
name|redFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|dag_h
operator|->
name|creator
operator|=
literal|"ParityLoggingSmallWriteDAG"
expr_stmt|;
name|rf_CommonCreateParityLoggingLargeWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
literal|1
argument_list|,
name|rf_RegularXorFunc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

end_unit

