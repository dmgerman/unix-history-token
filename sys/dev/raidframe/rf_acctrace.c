begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_acctrace.c,v 1.4 1999/08/13 03:41:52 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*****************************************************************************  *  * acctrace.c -- code to support collecting information about each access  *  *****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_acctrace.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_hist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_decl_stmt
specifier|static
name|long
name|numTracesSoFar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|accessTraceBufCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RF_AccTraceEntry_t
modifier|*
name|access_tracebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|traceCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rf_stopCollectingTraces
decl_stmt|;
end_decl_stmt

begin_macro
name|RF_DECLARE_MUTEX
argument_list|(
argument|rf_tracing_mutex
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rf_trace_fd
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rf_ShutdownAccessTrace
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownAccessTrace
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
if|if
condition|(
name|rf_accessTraceBufSize
condition|)
block|{
if|if
condition|(
name|accessTraceBufCount
condition|)
name|rf_FlushAccessTraceBuf
argument_list|()
expr_stmt|;
name|RF_Free
argument_list|(
name|access_tracebuf
argument_list|,
name|rf_accessTraceBufSize
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rf_mutex_destroy
argument_list|(
operator|&
name|rf_tracing_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureAccessTrace
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|numTracesSoFar
operator|=
name|accessTraceBufCount
operator|=
name|rf_stopCollectingTraces
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rf_accessTraceBufSize
condition|)
block|{
name|RF_Malloc
argument_list|(
name|access_tracebuf
argument_list|,
name|rf_accessTraceBufSize
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_AccTraceEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|accessTraceBufCount
operator|=
literal|0
expr_stmt|;
block|}
name|traceCount
operator|=
literal|0
expr_stmt|;
name|numTracesSoFar
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|rf_tracing_mutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownAccessTrace
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_accessTraceBufSize
condition|)
block|{
name|RF_Free
argument_list|(
name|access_tracebuf
argument_list|,
name|rf_accessTraceBufSize
operator|*
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
name|rf_mutex_destroy
argument_list|(
operator|&
name|rf_tracing_mutex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* install a trace record.  cause a flush to disk or to the trace collector daemon  * if the trace buffer is at least 1/2 full.  */
end_comment

begin_function
name|void
name|rf_LogTraceRec
parameter_list|(
name|raid
parameter_list|,
name|rec
parameter_list|)
name|RF_Raid_t
modifier|*
name|raid
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|rec
decl_stmt|;
block|{
name|RF_AccTotals_t
modifier|*
name|acc
init|=
operator|&
name|raid
operator|->
name|acc_totals
decl_stmt|;
if|#
directive|if
literal|0
block|RF_Etimer_t timer; 	int     i, n;
endif|#
directive|endif
if|if
condition|(
name|rf_stopCollectingTraces
operator|||
operator|(
operator|(
name|rf_maxNumTraces
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|numTracesSoFar
operator|>=
name|rf_maxNumTraces
operator|)
operator|)
condition|)
return|return;
comment|/* update AccTotals for this device */
if|if
condition|(
operator|!
name|raid
operator|->
name|keep_acc_totals
condition|)
return|return;
name|acc
operator|->
name|num_log_ents
operator|++
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|reconacc
condition|)
block|{
name|acc
operator|->
name|recon_start_to_fetch_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|recon
operator|.
name|recon_start_to_fetch_us
expr_stmt|;
name|acc
operator|->
name|recon_fetch_to_return_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|recon
operator|.
name|recon_fetch_to_return_us
expr_stmt|;
name|acc
operator|->
name|recon_return_to_submit_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|recon
operator|.
name|recon_return_to_submit_us
expr_stmt|;
name|acc
operator|->
name|recon_num_phys_ios
operator|+=
name|rec
operator|->
name|num_phys_ios
expr_stmt|;
name|acc
operator|->
name|recon_phys_io_us
operator|+=
name|rec
operator|->
name|phys_io_us
expr_stmt|;
name|acc
operator|->
name|recon_diskwait_us
operator|+=
name|rec
operator|->
name|diskwait_us
expr_stmt|;
name|acc
operator|->
name|recon_reccount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RF_HIST_ADD
argument_list|(
name|acc
operator|->
name|tot_hist
argument_list|,
name|rec
operator|->
name|total_us
argument_list|)
expr_stmt|;
name|RF_HIST_ADD
argument_list|(
name|acc
operator|->
name|dw_hist
argument_list|,
name|rec
operator|->
name|diskwait_us
argument_list|)
expr_stmt|;
comment|/* count of physical ios which are too big.  often due to 		 * thermal recalibration */
comment|/* if bigvals> 0, you should probably ignore this data set */
if|if
condition|(
name|rec
operator|->
name|diskwait_us
operator|>
literal|100000
condition|)
name|acc
operator|->
name|bigvals
operator|++
expr_stmt|;
name|acc
operator|->
name|total_us
operator|+=
name|rec
operator|->
name|total_us
expr_stmt|;
name|acc
operator|->
name|suspend_ovhd_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|suspend_ovhd_us
expr_stmt|;
name|acc
operator|->
name|map_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|map_us
expr_stmt|;
name|acc
operator|->
name|lock_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|lock_us
expr_stmt|;
name|acc
operator|->
name|dag_create_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|dag_create_us
expr_stmt|;
name|acc
operator|->
name|dag_retry_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|dag_retry_us
expr_stmt|;
name|acc
operator|->
name|exec_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|exec_us
expr_stmt|;
name|acc
operator|->
name|cleanup_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|cleanup_us
expr_stmt|;
name|acc
operator|->
name|exec_engine_us
operator|+=
name|rec
operator|->
name|specific
operator|.
name|user
operator|.
name|exec_engine_us
expr_stmt|;
name|acc
operator|->
name|xor_us
operator|+=
name|rec
operator|->
name|xor_us
expr_stmt|;
name|acc
operator|->
name|q_us
operator|+=
name|rec
operator|->
name|q_us
expr_stmt|;
name|acc
operator|->
name|plog_us
operator|+=
name|rec
operator|->
name|plog_us
expr_stmt|;
name|acc
operator|->
name|diskqueue_us
operator|+=
name|rec
operator|->
name|diskqueue_us
expr_stmt|;
name|acc
operator|->
name|diskwait_us
operator|+=
name|rec
operator|->
name|diskwait_us
expr_stmt|;
name|acc
operator|->
name|num_phys_ios
operator|+=
name|rec
operator|->
name|num_phys_ios
expr_stmt|;
name|acc
operator|->
name|phys_io_us
operator|=
name|rec
operator|->
name|phys_io_us
expr_stmt|;
name|acc
operator|->
name|user_reccount
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* assumes the tracing mutex is locked at entry.  In order to allow this to be called  * from interrupt context, we don't do any copyouts here, but rather just wake trace  * buffer collector thread.  */
end_comment

begin_function
name|void
name|rf_FlushAccessTraceBuf
parameter_list|()
block|{
name|accessTraceBufCount
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

