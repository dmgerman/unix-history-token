begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_parityscan.c,v 1.9 2000/05/28 03:00:31 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*****************************************************************************  *  * rf_parityscan.c -- misc utilities related to parity verification  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_comment
comment|/*****************************************************************************************  *  * walk through the entire arry and write new parity.  * This works by creating two DAGs, one to read a stripe of data and one to  * write new parity.  The first is executed, the data is xored together, and  * then the second is executed.  To avoid constantly building and tearing down  * the DAGs, we create them a priori and fill them in with the mapping  * information as we go along.  *  * there should never be more than one thread running this.  *  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_RewriteParity
parameter_list|(
name|raidPtr
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|RF_PhysDiskAddr_t
name|pda
decl_stmt|;
name|RF_SectorNum_t
name|i
decl_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* There isn't any parity. Call it "okay." */
return|return
operator|(
name|RF_PARITY_OKAY
operator|)
return|;
block|}
if|if
condition|(
name|raidPtr
operator|->
name|status
index|[
literal|0
index|]
operator|!=
name|rf_rs_optimal
condition|)
block|{
comment|/* 		 * We're in degraded mode.  Don't try to verify parity now!  		 * XXX: this should be a "we don't want to", not a  		 * "we can't" error.  		 */
return|return
operator|(
name|RF_PARITY_COULD_NOT_VERIFY
operator|)
return|;
block|}
name|ret_val
operator|=
literal|0
expr_stmt|;
name|pda
operator|.
name|startSector
operator|=
literal|0
expr_stmt|;
name|pda
operator|.
name|numSector
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
expr_stmt|;
name|rc
operator|=
name|RF_PARITY_OKAY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|raidPtr
operator|->
name|totalSectors
operator|&&
name|rc
operator|<=
name|RF_PARITY_CORRECTED
condition|;
name|i
operator|+=
name|layoutPtr
operator|->
name|dataSectorsPerStripe
control|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|waitShutdown
condition|)
block|{
comment|/* Someone is pulling the plug on this set... 			   abort the re-write */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|asm_h
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|i
argument_list|,
name|layoutPtr
operator|->
name|dataSectorsPerStripe
argument_list|,
name|NULL
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|parity_rewrite_stripes_done
operator|=
name|i
operator|/
name|layoutPtr
operator|->
name|dataSectorsPerStripe
expr_stmt|;
name|rc
operator|=
name|rf_VerifyParity
argument_list|(
name|raidPtr
argument_list|,
name|asm_h
operator|->
name|stripeMap
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|RF_PARITY_OKAY
case|:
case|case
name|RF_PARITY_CORRECTED
case|:
break|break;
case|case
name|RF_PARITY_BAD
case|:
name|printf
argument_list|(
literal|"Parity bad during correction\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RF_PARITY_COULD_NOT_CORRECT
case|:
name|printf
argument_list|(
literal|"Could not correct bad parity\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RF_PARITY_COULD_NOT_VERIFY
case|:
name|printf
argument_list|(
literal|"Could not verify parity\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad rc=%d from VerifyParity in RewriteParity\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|1
expr_stmt|;
block|}
name|rf_FreeAccessStripeMap
argument_list|(
name|asm_h
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * verify that the parity in a particular stripe is correct.  * we validate only the range of parity defined by parityPDA, since  * this is all we have locked.  The way we do this is to create an asm  * that maps the whole stripe and then range-restrict it to the parity  * region defined by the parityPDA.  *  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_VerifyParity
parameter_list|(
name|raidPtr
parameter_list|,
name|aasm
parameter_list|,
name|correct_it
parameter_list|,
name|flags
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|aasm
decl_stmt|;
name|int
name|correct_it
decl_stmt|;
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|parityPDA
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|doasm
decl_stmt|;
name|RF_LayoutSW_t
modifier|*
name|lp
decl_stmt|;
name|int
name|lrc
decl_stmt|,
name|rc
decl_stmt|;
name|lp
operator|=
name|raidPtr
operator|->
name|Layout
operator|.
name|map
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|faultsTolerated
operator|==
literal|0
condition|)
block|{
comment|/* 	         * There isn't any parity. Call it "okay." 	         */
return|return
operator|(
name|RF_PARITY_OKAY
operator|)
return|;
block|}
name|rc
operator|=
name|RF_PARITY_OKAY
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|VerifyParity
condition|)
block|{
for|for
control|(
name|doasm
operator|=
name|aasm
init|;
name|doasm
condition|;
name|doasm
operator|=
name|doasm
operator|->
name|next
control|)
block|{
for|for
control|(
name|parityPDA
operator|=
name|doasm
operator|->
name|parityInfo
init|;
name|parityPDA
condition|;
name|parityPDA
operator|=
name|parityPDA
operator|->
name|next
control|)
block|{
name|lrc
operator|=
name|lp
operator|->
name|VerifyParity
argument_list|(
name|raidPtr
argument_list|,
name|doasm
operator|->
name|raidAddress
argument_list|,
name|parityPDA
argument_list|,
name|correct_it
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrc
operator|>
name|rc
condition|)
block|{
comment|/* see rf_parityscan.h for why this 					 * works */
name|rc
operator|=
name|lrc
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|rc
operator|=
name|RF_PARITY_COULD_NOT_VERIFY
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_VerifyParityBasic
parameter_list|(
name|raidPtr
parameter_list|,
name|raidAddr
parameter_list|,
name|parityPDA
parameter_list|,
name|correct_it
parameter_list|,
name|flags
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidAddr_t
name|raidAddr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|parityPDA
decl_stmt|;
name|int
name|correct_it
decl_stmt|;
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_RaidAddr_t
name|startAddr
init|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|)
decl_stmt|;
name|RF_SectorCount_t
name|numsector
init|=
name|parityPDA
operator|->
name|numSector
decl_stmt|;
name|int
name|numbytes
init|=
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|numsector
argument_list|)
decl_stmt|;
name|int
name|bytesPerStripe
init|=
name|numbytes
operator|*
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|rd_dag_h
decl_stmt|,
modifier|*
name|wr_dag_h
decl_stmt|;
comment|/* read, write dag */
name|RF_DagNode_t
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|wrBlock
decl_stmt|,
modifier|*
name|wrUnblock
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|alloclist
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|char
modifier|*
name|pbuf
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end_p
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retcode
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|RF_StripeNum_t
name|psID
init|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|,
operator|&
name|which_ru
argument_list|)
decl_stmt|;
name|int
name|stripeWidth
init|=
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
decl_stmt|;
name|RF_AccTraceEntry_t
name|tracerec
decl_stmt|;
name|RF_MCPair_t
modifier|*
name|mcpair
decl_stmt|;
name|retcode
operator|=
name|RF_PARITY_OKAY
expr_stmt|;
name|mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|rf_MakeAllocList
argument_list|(
name|alloclist
argument_list|)
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|buf
argument_list|,
name|numbytes
operator|*
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|pbuf
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
comment|/* use calloc to make 									 * sure buffer is zeroed */
name|end_p
operator|=
name|buf
operator|+
name|bytesPerStripe
expr_stmt|;
name|rd_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
name|stripeWidth
argument_list|,
name|numbytes
argument_list|,
name|buf
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
literal|"Rod"
argument_list|,
name|alloclist
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
name|blockNode
operator|=
name|rd_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|unblockNode
operator|=
name|blockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
comment|/* map the stripe and fill in the PDAs in the dag */
name|asm_h
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|startAddr
argument_list|,
name|layoutPtr
operator|->
name|dataSectorsPerStripe
argument_list|,
name|buf
argument_list|,
name|RF_DONT_REMAP
argument_list|)
expr_stmt|;
name|asmap
operator|=
name|asm_h
operator|->
name|stripeMap
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|pda
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* no way to verify parity if disk is 					 * dead.  return w/ good status */
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
operator|!
name|asmap
operator|->
name|parityInfo
operator|->
name|next
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|parityPDA
argument_list|,
name|asmap
operator|->
name|parityInfo
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_TryToRedirectPDA
argument_list|(
name|raidPtr
argument_list|,
name|asmap
operator|->
name|parityInfo
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|blockNode
operator|->
name|succedents
index|[
name|layoutPtr
operator|->
name|numDataCol
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
comment|/* fire off the DAG */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|rd_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"Parity verify read dag:\n"
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|rd_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DispatchDAG
argument_list|(
name|rd_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|mcpair
operator|->
name|cond
argument_list|,
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to verify parity:  can't read the stripe\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RF_PARITY_COULD_NOT_VERIFY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<
name|end_p
condition|;
name|p
operator|+=
name|numbytes
control|)
block|{
name|rf_bxor
argument_list|(
name|p
argument_list|,
name|pbuf
argument_list|,
name|numbytes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbytes
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|if (pbuf[i] != 0 || buf[bytesPerStripe + i] != 0) { 			printf("Bytes: %d %d %d\n", i, pbuf[i], buf[bytesPerStripe + i]); 		}
endif|#
directive|endif
if|if
condition|(
name|pbuf
index|[
name|i
index|]
operator|!=
name|buf
index|[
name|bytesPerStripe
operator|+
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|correct_it
condition|)
name|RF_ERRORMSG3
argument_list|(
literal|"Parity verify error: byte %d of parity is 0x%x should be 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|u_char
operator|)
name|buf
index|[
name|bytesPerStripe
operator|+
name|i
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|pbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RF_PARITY_BAD
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|retcode
operator|&&
name|correct_it
condition|)
block|{
name|wr_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
name|pbuf
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
literal|"Wnp"
argument_list|,
name|alloclist
argument_list|,
name|flags
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
name|wrBlock
operator|=
name|wr_dag_h
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|wrUnblock
operator|=
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|psID
expr_stmt|;
name|wrBlock
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|tracerec
argument_list|)
argument_list|)
expr_stmt|;
name|wr_dag_h
operator|->
name|tracerec
operator|=
operator|&
name|tracerec
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
block|{
name|printf
argument_list|(
literal|"Parity verify write dag:\n"
argument_list|)
expr_stmt|;
name|rf_PrintDAGList
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
block|}
name|RF_LOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mcpair
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|rf_DispatchDAG
argument_list|(
name|wr_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mcpair
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|mcpair
operator|->
name|cond
argument_list|,
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to correct parity in VerifyParity:  can't write the stripe\n"
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RF_PARITY_COULD_NOT_CORRECT
expr_stmt|;
block|}
name|rf_FreeDAG
argument_list|(
name|wr_dag_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|RF_PARITY_BAD
condition|)
name|retcode
operator|=
name|RF_PARITY_CORRECTED
expr_stmt|;
block|}
name|out
label|:
name|rf_FreeAccessStripeMap
argument_list|(
name|asm_h
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|alloclist
argument_list|)
expr_stmt|;
name|rf_FreeDAG
argument_list|(
name|rd_dag_h
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|mcpair
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_TryToRedirectPDA
parameter_list|(
name|raidPtr
parameter_list|,
name|pda
parameter_list|,
name|parity
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|int
name|parity
decl_stmt|;
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|status
operator|==
name|rf_ds_reconstructing
condition|)
block|{
if|if
condition|(
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|pda
operator|->
name|row
index|]
operator|->
name|reconMap
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
condition|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_DISTRIBUTE_SPARE
condition|)
block|{
name|RF_RowCol_t
name|or
init|=
name|pda
operator|->
name|row
decl_stmt|,
name|oc
init|=
name|pda
operator|->
name|col
decl_stmt|;
name|RF_SectorNum_t
name|os
init|=
name|pda
operator|->
name|startSector
decl_stmt|;
if|if
condition|(
name|parity
condition|)
block|{
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|,
operator|&
name|pda
operator|->
name|row
argument_list|,
operator|&
name|pda
operator|->
name|col
argument_list|,
operator|&
name|pda
operator|->
name|startSector
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
name|printf
argument_list|(
literal|"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\n"
argument_list|,
name|or
argument_list|,
name|oc
argument_list|,
operator|(
name|long
operator|)
name|os
argument_list|,
name|pda
operator|->
name|row
argument_list|,
name|pda
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|,
operator|&
name|pda
operator|->
name|row
argument_list|,
operator|&
name|pda
operator|->
name|col
argument_list|,
operator|&
name|pda
operator|->
name|startSector
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_verifyParityDebug
condition|)
name|printf
argument_list|(
literal|"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\n"
argument_list|,
name|or
argument_list|,
name|oc
argument_list|,
operator|(
name|long
operator|)
name|os
argument_list|,
name|pda
operator|->
name|row
argument_list|,
name|pda
operator|->
name|col
argument_list|,
operator|(
name|long
operator|)
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|RF_RowCol_t
name|spRow
init|=
name|raidPtr
operator|->
name|Disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|spareRow
decl_stmt|;
name|RF_RowCol_t
name|spCol
init|=
name|raidPtr
operator|->
name|Disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|spareCol
decl_stmt|;
name|pda
operator|->
name|row
operator|=
name|spRow
expr_stmt|;
name|pda
operator|->
name|col
operator|=
name|spCol
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * currently a stub.  *  * takes as input an ASM describing a write operation and containing one failure, and  * verifies that the parity was correctly updated to reflect the write.  *  * if it's a data unit that's failed, we read the other data units in the stripe and  * the parity unit, XOR them together, and verify that we get the data intended for  * the failed disk.  Since it's easy, we also validate that the right data got written  * to the surviving data disks.  *  * If it's the parity that failed, there's really no validation we can do except the  * above verification that the right data got written to all disks.  This is because  * the new data intended for the failed disk is supplied in the ASM, but this is of  * course not the case for the new parity.  *  ****************************************************************************************/
end_comment

begin_function
name|int
name|rf_VerifyDegrModeWrite
parameter_list|(
name|raidPtr
parameter_list|,
name|asmh
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asmh
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* creates a simple DAG with a header, a block-recon node at level 1,  * nNodes nodes at level 2, an unblock-recon node at level 3, and  * a terminator node at level 4.  The stripe address field in  * the block and unblock nodes are not touched, nor are the pda  * fields in the second-level nodes, so they must be filled in later.  *  * commit point is established at unblock node - this means that any  * failure during dag execution causes the dag to fail  */
end_comment

begin_decl_stmt
name|RF_DagHeader_t
modifier|*
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
name|nNodes
argument_list|,
name|bytesPerSU
argument_list|,
name|databuf
argument_list|,
name|doFunc
argument_list|,
name|undoFunc
argument_list|,
name|name
argument_list|,
name|alloclist
argument_list|,
name|flags
argument_list|,
name|priority
argument_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nNodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytesPerSU
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|databuf
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|doFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|undoFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node names at the second level */
end_comment

begin_decl_stmt
name|RF_AllocListElem_t
modifier|*
name|alloclist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|priority
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|termNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* create the nodes, the block& unblock nodes, and the terminator 	 * node */
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nNodes
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|nNodes
index|]
expr_stmt|;
name|unblockNode
operator|=
name|blockNode
operator|+
literal|1
expr_stmt|;
name|termNode
operator|=
name|unblockNode
operator|+
literal|1
expr_stmt|;
name|dag_h
operator|=
name|rf_AllocDAGHeader
argument_list|()
expr_stmt|;
name|dag_h
operator|->
name|raidPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|raidPtr
expr_stmt|;
name|dag_h
operator|->
name|allocList
operator|=
name|NULL
expr_stmt|;
comment|/* we won't use this alloc list */
name|dag_h
operator|->
name|status
operator|=
name|rf_enable
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"SimpleDAG"
expr_stmt|;
comment|/* this dag can not commit until the unblock node is reached errors 	 * prior to the commit point imply the dag has failed */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nNodes
condition|;
name|i
operator|++
control|)
block|{
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
name|rf_InitNode
argument_list|(
operator|&
name|nodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|doFunc
argument_list|,
name|undoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
name|name
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
name|nodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
operator|(
name|databuf
operator|+
operator|(
name|i
operator|*
name|bytesPerSU
operator|)
operator|)
expr_stmt|;
block|}
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|alloclist
argument_list|)
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
return|return
operator|(
name|dag_h
operator|)
return|;
block|}
end_block

end_unit

