begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_paritylogDiskMgr.c,v 1.10 2000/01/15 01:57:57 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/* Code for flushing and reintegration operations related to parity logging.  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_if
if|#
directive|if
name|RF_INCLUDE_PARITYLOGGING
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_mcpair.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_layout.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_diskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylog.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylogging.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_parityscan.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_paritylogDiskMgr.h>
end_include

begin_function_decl
specifier|static
name|caddr_t
name|AcquireReintBuffer
parameter_list|(
name|RF_RegionBufferQueue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|caddr_t
name|AcquireReintBuffer
parameter_list|(
name|pool
parameter_list|)
name|RF_RegionBufferQueue_t
modifier|*
name|pool
decl_stmt|;
block|{
name|caddr_t
name|bufPtr
init|=
name|NULL
decl_stmt|;
comment|/* Return a region buffer from the free list (pool). If the free list 	 * is empty, WAIT. BLOCKING */
name|RF_LOCK_MUTEX
argument_list|(
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|availableBuffers
operator|>
literal|0
condition|)
block|{
name|bufPtr
operator|=
name|pool
operator|->
name|buffers
index|[
name|pool
operator|->
name|availBuffersIndex
index|]
expr_stmt|;
name|pool
operator|->
name|availableBuffers
operator|--
expr_stmt|;
name|pool
operator|->
name|availBuffersIndex
operator|++
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|availBuffersIndex
operator|==
name|pool
operator|->
name|totalBuffers
condition|)
name|pool
operator|->
name|availBuffersIndex
operator|=
literal|0
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RF_PANIC
argument_list|()
expr_stmt|;
comment|/* should never happen in correct config, 				 * single reint */
name|RF_WAIT_COND
argument_list|(
name|pool
operator|->
name|cond
argument_list|,
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bufPtr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReleaseReintBuffer
parameter_list|(
name|RF_RegionBufferQueue_t
modifier|*
name|pool
parameter_list|,
name|caddr_t
name|bufPtr
parameter_list|)
block|{
comment|/* Insert a region buffer (bufPtr) into the free list (pool). 	 * NON-BLOCKING */
name|RF_LOCK_MUTEX
argument_list|(
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pool
operator|->
name|availableBuffers
operator|++
expr_stmt|;
name|pool
operator|->
name|buffers
index|[
name|pool
operator|->
name|emptyBuffersIndex
index|]
operator|=
name|bufPtr
expr_stmt|;
name|pool
operator|->
name|emptyBuffersIndex
operator|++
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|emptyBuffersIndex
operator|==
name|pool
operator|->
name|totalBuffers
condition|)
name|pool
operator|->
name|emptyBuffersIndex
operator|=
literal|0
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pool
operator|->
name|availableBuffers
operator|<=
name|pool
operator|->
name|totalBuffers
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|pool
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_SIGNAL_COND
argument_list|(
name|pool
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReadRegionLog
parameter_list|(
name|RF_RegionId_t
name|regionID
parameter_list|,
name|RF_MCPair_t
modifier|*
name|rrd_mcpair
parameter_list|,
name|caddr_t
name|regionBuffer
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_DagHeader_t
modifier|*
modifier|*
name|rrd_dag_h
parameter_list|,
name|RF_AllocListElem_t
modifier|*
modifier|*
name|rrd_alloclist
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|rrd_pda
parameter_list|)
block|{
comment|/* Initiate the read a region log from disk.  Once initiated, return 	 * to the calling routine. 	 *  	 * NON-BLOCKING */
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|rrd_rdNode
decl_stmt|;
comment|/* create DAG to read region log from disk */
name|rf_MakeAllocList
argument_list|(
operator|*
name|rrd_alloclist
argument_list|)
expr_stmt|;
operator|*
name|rrd_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|regionBuffer
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
literal|"Rrl"
argument_list|,
operator|*
name|rrd_alloclist
argument_list|,
name|RF_DAG_FLAGS_NONE
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
comment|/* create and initialize PDA for the core log */
comment|/* RF_Malloc(*rrd_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t 	 * *)); */
operator|*
name|rrd_pda
operator|=
name|rf_AllocPDAList
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rf_MapLogParityLogging
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|rrd_pda
operator|)
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|rrd_pda
operator|)
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|rrd_pda
operator|)
operator|->
name|startSector
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rrd_pda
operator|)
operator|->
name|numSector
operator|=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|capacity
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rrd_pda
operator|)
operator|->
name|next
condition|)
block|{
operator|(
operator|*
name|rrd_pda
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"set rrd_pda->next to NULL\n"
argument_list|)
expr_stmt|;
block|}
comment|/* initialize DAG parameters */
name|RF_Malloc
argument_list|(
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_AccTraceEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rrd_dag_h
operator|)
operator|->
name|tracerec
operator|=
name|tracerec
expr_stmt|;
name|rrd_rdNode
operator|=
operator|(
operator|*
name|rrd_dag_h
operator|)
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|rrd_rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|*
name|rrd_pda
expr_stmt|;
comment|/*  rrd_rdNode->params[1] = regionBuffer; */
name|rrd_rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|rrd_rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* launch region log read dag */
name|rf_DispatchDAG
argument_list|(
operator|*
name|rrd_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rrd_mcpair
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|WriteCoreLog
parameter_list|(
name|RF_ParityLog_t
modifier|*
name|log
parameter_list|,
name|RF_MCPair_t
modifier|*
name|fwr_mcpair
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_DagHeader_t
modifier|*
modifier|*
name|fwr_dag_h
parameter_list|,
name|RF_AllocListElem_t
modifier|*
modifier|*
name|fwr_alloclist
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|fwr_pda
parameter_list|)
block|{
name|RF_RegionId_t
name|regionID
init|=
name|log
operator|->
name|regionID
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
decl_stmt|;
name|RF_SectorNum_t
name|regionOffset
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|fwr_wrNode
decl_stmt|;
comment|/* Initiate the write of a core log to a region log disk. Once 	 * initiated, return to the calling routine. 	 *  	 * NON-BLOCKING */
comment|/* create DAG to write a core log to a region log disk */
name|rf_MakeAllocList
argument_list|(
operator|*
name|fwr_alloclist
argument_list|)
expr_stmt|;
operator|*
name|fwr_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|log
operator|->
name|bufPtr
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
literal|"Wcl"
argument_list|,
operator|*
name|fwr_alloclist
argument_list|,
name|RF_DAG_FLAGS_NONE
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
comment|/* create and initialize PDA for the region log */
comment|/* RF_Malloc(*fwr_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t 	 * *)); */
operator|*
name|fwr_pda
operator|=
name|rf_AllocPDAList
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|regionOffset
operator|=
name|log
operator|->
name|diskOffset
expr_stmt|;
name|rf_MapLogParityLogging
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
name|regionOffset
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|fwr_pda
operator|)
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|fwr_pda
operator|)
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|fwr_pda
operator|)
operator|->
name|startSector
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fwr_pda
operator|)
operator|->
name|numSector
operator|=
name|raidPtr
operator|->
name|numSectorsPerLog
expr_stmt|;
comment|/* initialize DAG parameters */
name|RF_Malloc
argument_list|(
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_AccTraceEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fwr_dag_h
operator|)
operator|->
name|tracerec
operator|=
name|tracerec
expr_stmt|;
name|fwr_wrNode
operator|=
operator|(
operator|*
name|fwr_dag_h
operator|)
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|fwr_wrNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|*
name|fwr_pda
expr_stmt|;
comment|/*  fwr_wrNode->params[1] = log->bufPtr; */
name|fwr_wrNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|fwr_wrNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* launch the dag to write the core log to disk */
name|rf_DispatchDAG
argument_list|(
operator|*
name|fwr_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fwr_mcpair
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReadRegionParity
parameter_list|(
name|RF_RegionId_t
name|regionID
parameter_list|,
name|RF_MCPair_t
modifier|*
name|prd_mcpair
parameter_list|,
name|caddr_t
name|parityBuffer
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_DagHeader_t
modifier|*
modifier|*
name|prd_dag_h
parameter_list|,
name|RF_AllocListElem_t
modifier|*
modifier|*
name|prd_alloclist
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|prd_pda
parameter_list|)
block|{
comment|/* Initiate the read region parity from disk. Once initiated, return 	 * to the calling routine. 	 *  	 * NON-BLOCKING */
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|prd_rdNode
decl_stmt|;
comment|/* create DAG to read region parity from disk */
name|rf_MakeAllocList
argument_list|(
operator|*
name|prd_alloclist
argument_list|)
expr_stmt|;
operator|*
name|prd_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
literal|"Rrp"
argument_list|,
operator|*
name|prd_alloclist
argument_list|,
name|RF_DAG_FLAGS_NONE
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
comment|/* create and initialize PDA for region parity */
comment|/* RF_Malloc(*prd_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t 	 * *)); */
operator|*
name|prd_pda
operator|=
name|rf_AllocPDAList
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rf_MapRegionParity
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|prd_pda
operator|)
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|prd_pda
operator|)
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|prd_pda
operator|)
operator|->
name|startSector
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|prd_pda
operator|)
operator|->
name|numSector
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[reading %d sectors of parity from region %d]\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|prd_pda
argument_list|)
operator|->
name|numSector
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|prd_pda
operator|)
operator|->
name|next
condition|)
block|{
operator|(
operator|*
name|prd_pda
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"set prd_pda->next to NULL\n"
argument_list|)
expr_stmt|;
block|}
comment|/* initialize DAG parameters */
name|RF_Malloc
argument_list|(
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_AccTraceEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|prd_dag_h
operator|)
operator|->
name|tracerec
operator|=
name|tracerec
expr_stmt|;
name|prd_rdNode
operator|=
operator|(
operator|*
name|prd_dag_h
operator|)
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|prd_rdNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|*
name|prd_pda
expr_stmt|;
name|prd_rdNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|parityBuffer
expr_stmt|;
name|prd_rdNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|prd_rdNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_validateDAGDebug
condition|)
name|rf_ValidateDAG
argument_list|(
operator|*
name|prd_dag_h
argument_list|)
expr_stmt|;
comment|/* launch region parity read dag */
name|rf_DispatchDAG
argument_list|(
operator|*
name|prd_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prd_mcpair
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|WriteRegionParity
parameter_list|(
name|RF_RegionId_t
name|regionID
parameter_list|,
name|RF_MCPair_t
modifier|*
name|pwr_mcpair
parameter_list|,
name|caddr_t
name|parityBuffer
parameter_list|,
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_DagHeader_t
modifier|*
modifier|*
name|pwr_dag_h
parameter_list|,
name|RF_AllocListElem_t
modifier|*
modifier|*
name|pwr_alloclist
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|pwr_pda
parameter_list|)
block|{
comment|/* Initiate the write of region parity to disk. Once initiated, return 	 * to the calling routine. 	 *  	 * NON-BLOCKING */
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|pwr_wrNode
decl_stmt|;
comment|/* create DAG to write region log from disk */
name|rf_MakeAllocList
argument_list|(
operator|*
name|pwr_alloclist
argument_list|)
expr_stmt|;
operator|*
name|pwr_dag_h
operator|=
name|rf_MakeSimpleDAG
argument_list|(
name|raidPtr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|parityBuffer
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
literal|"Wrp"
argument_list|,
operator|*
name|pwr_alloclist
argument_list|,
name|RF_DAG_FLAGS_NONE
argument_list|,
name|RF_IO_NORMAL_PRIORITY
argument_list|)
expr_stmt|;
comment|/* create and initialize PDA for region parity */
comment|/* RF_Malloc(*pwr_pda, sizeof(RF_PhysDiskAddr_t), (RF_PhysDiskAddr_t 	 * *)); */
operator|*
name|pwr_pda
operator|=
name|rf_AllocPDAList
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rf_MapRegionParity
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|pwr_pda
operator|)
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|pwr_pda
operator|)
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|pwr_pda
operator|)
operator|->
name|startSector
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|pwr_pda
operator|)
operator|->
name|numSector
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize DAG parameters */
name|RF_Malloc
argument_list|(
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|,
operator|(
name|RF_AccTraceEntry_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tracerec
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccTraceEntry_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pwr_dag_h
operator|)
operator|->
name|tracerec
operator|=
name|tracerec
expr_stmt|;
name|pwr_wrNode
operator|=
operator|(
operator|*
name|pwr_dag_h
operator|)
operator|->
name|succedents
index|[
literal|0
index|]
operator|->
name|succedents
index|[
literal|0
index|]
expr_stmt|;
name|pwr_wrNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
operator|*
name|pwr_pda
expr_stmt|;
comment|/*  pwr_wrNode->params[1] = parityBuffer; */
name|pwr_wrNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|pwr_wrNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* launch the dag to write region parity to disk */
name|rf_DispatchDAG
argument_list|(
operator|*
name|pwr_dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_MCPairWakeupFunc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pwr_mcpair
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FlushLogsToDisk
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ParityLog_t
modifier|*
name|logList
parameter_list|)
block|{
comment|/* Flush a linked list of core logs to the log disk. Logs contain the 	 * disk location where they should be written.  Logs were written in 	 * FIFO order and that order must be preserved. 	 *  	 * Recommended optimizations: 1) allow multiple flushes to occur 	 * simultaneously 2) coalesce contiguous flush operations 	 *  	 * BLOCKING */
name|RF_ParityLog_t
modifier|*
name|log
decl_stmt|;
name|RF_RegionId_t
name|regionID
decl_stmt|;
name|RF_MCPair_t
modifier|*
name|fwr_mcpair
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|fwr_dag_h
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|fwr_alloclist
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|fwr_pda
decl_stmt|;
name|fwr_mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|fwr_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|logList
argument_list|)
expr_stmt|;
name|log
operator|=
name|logList
expr_stmt|;
while|while
condition|(
name|log
condition|)
block|{
name|regionID
operator|=
name|log
operator|->
name|regionID
expr_stmt|;
comment|/* create and launch a DAG to write the core log */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[initiating write of core log for region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
name|fwr_mcpair
operator|->
name|flag
operator|=
name|RF_FALSE
expr_stmt|;
name|WriteCoreLog
argument_list|(
name|log
argument_list|,
name|fwr_mcpair
argument_list|,
name|raidPtr
argument_list|,
operator|&
name|fwr_dag_h
argument_list|,
operator|&
name|fwr_alloclist
argument_list|,
operator|&
name|fwr_pda
argument_list|)
expr_stmt|;
comment|/* wait for the DAG to complete */
while|while
condition|(
operator|!
name|fwr_mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|fwr_mcpair
operator|->
name|cond
argument_list|,
name|fwr_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwr_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Unable to write core log to disk (region %d)\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* RF_Free(fwr_pda, sizeof(RF_PhysDiskAddr_t)); */
name|rf_FreePhysDiskAddr
argument_list|(
name|fwr_pda
argument_list|)
expr_stmt|;
name|rf_FreeDAG
argument_list|(
name|fwr_dag_h
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|fwr_alloclist
argument_list|)
expr_stmt|;
name|log
operator|=
name|log
operator|->
name|next
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|fwr_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|fwr_mcpair
argument_list|)
expr_stmt|;
name|rf_ReleaseParityLogs
argument_list|(
name|raidPtr
argument_list|,
name|logList
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReintegrateRegion
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_RegionId_t
name|regionID
parameter_list|,
name|RF_ParityLog_t
modifier|*
name|coreLog
parameter_list|)
block|{
name|RF_MCPair_t
modifier|*
name|rrd_mcpair
init|=
name|NULL
decl_stmt|,
modifier|*
name|prd_mcpair
decl_stmt|,
modifier|*
name|pwr_mcpair
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|rrd_dag_h
decl_stmt|,
modifier|*
name|prd_dag_h
decl_stmt|,
modifier|*
name|pwr_dag_h
decl_stmt|;
name|RF_AllocListElem_t
modifier|*
name|rrd_alloclist
decl_stmt|,
modifier|*
name|prd_alloclist
decl_stmt|,
modifier|*
name|pwr_alloclist
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|rrd_pda
decl_stmt|,
modifier|*
name|prd_pda
decl_stmt|,
modifier|*
name|pwr_pda
decl_stmt|;
name|caddr_t
name|parityBuffer
decl_stmt|,
name|regionBuffer
init|=
name|NULL
decl_stmt|;
comment|/* Reintegrate a region (regionID).  	 * 	 * 1. acquire region and parity buffers  	 * 2. read log from disk  	 * 3. read parity from disk  	 * 4. apply log to parity  	 * 5. apply core log to parity  	 * 6. write new parity to disk 	 *  	 * BLOCKING */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[reintegrating region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
comment|/* initiate read of region parity */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[initiating read of parity for region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
name|parityBuffer
operator|=
name|AcquireReintBuffer
argument_list|(
operator|&
name|raidPtr
operator|->
name|parityBufferPool
argument_list|)
expr_stmt|;
name|prd_mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|prd_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|prd_mcpair
operator|->
name|flag
operator|=
name|RF_FALSE
expr_stmt|;
name|ReadRegionParity
argument_list|(
name|regionID
argument_list|,
name|prd_mcpair
argument_list|,
name|parityBuffer
argument_list|,
name|raidPtr
argument_list|,
operator|&
name|prd_dag_h
argument_list|,
operator|&
name|prd_alloclist
argument_list|,
operator|&
name|prd_pda
argument_list|)
expr_stmt|;
comment|/* if region log nonempty, initiate read */
if|if
condition|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[initiating read of disk log for region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
name|regionBuffer
operator|=
name|AcquireReintBuffer
argument_list|(
operator|&
name|raidPtr
operator|->
name|regionBufferPool
argument_list|)
expr_stmt|;
name|rrd_mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|rrd_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|rrd_mcpair
operator|->
name|flag
operator|=
name|RF_FALSE
expr_stmt|;
name|ReadRegionLog
argument_list|(
name|regionID
argument_list|,
name|rrd_mcpair
argument_list|,
name|regionBuffer
argument_list|,
name|raidPtr
argument_list|,
operator|&
name|rrd_dag_h
argument_list|,
operator|&
name|rrd_alloclist
argument_list|,
operator|&
name|rrd_pda
argument_list|)
expr_stmt|;
block|}
comment|/* wait on read of region parity to complete */
while|while
condition|(
operator|!
name|prd_mcpair
operator|->
name|flag
condition|)
block|{
name|RF_WAIT_COND
argument_list|(
name|prd_mcpair
operator|->
name|cond
argument_list|,
name|prd_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|prd_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|prd_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to read parity from disk\n"
argument_list|)
expr_stmt|;
comment|/* add code to fail the parity disk */
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* apply core log to parity */
comment|/* if (coreLog) ApplyLogsToParity(coreLog, parityBuffer); */
if|if
condition|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|>
literal|0
condition|)
block|{
comment|/* wait on read of region log to complete */
while|while
condition|(
operator|!
name|rrd_mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|rrd_mcpair
operator|->
name|cond
argument_list|,
name|rrd_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|rrd_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrd_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to read region log from disk\n"
argument_list|)
expr_stmt|;
comment|/* add code to fail the log disk */
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* apply region log to parity */
comment|/* ApplyRegionToParity(regionID, regionBuffer, parityBuffer); */
comment|/* release resources associated with region log */
comment|/* RF_Free(rrd_pda, sizeof(RF_PhysDiskAddr_t)); */
name|rf_FreePhysDiskAddr
argument_list|(
name|rrd_pda
argument_list|)
expr_stmt|;
name|rf_FreeDAG
argument_list|(
name|rrd_dag_h
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|rrd_alloclist
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|rrd_mcpair
argument_list|)
expr_stmt|;
name|ReleaseReintBuffer
argument_list|(
operator|&
name|raidPtr
operator|->
name|regionBufferPool
argument_list|,
name|regionBuffer
argument_list|)
expr_stmt|;
block|}
comment|/* write reintegrated parity to disk */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[initiating write of parity for region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
name|pwr_mcpair
operator|=
name|rf_AllocMCPair
argument_list|()
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|pwr_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pwr_mcpair
operator|->
name|flag
operator|=
name|RF_FALSE
expr_stmt|;
name|WriteRegionParity
argument_list|(
name|regionID
argument_list|,
name|pwr_mcpair
argument_list|,
name|parityBuffer
argument_list|,
name|raidPtr
argument_list|,
operator|&
name|pwr_dag_h
argument_list|,
operator|&
name|pwr_alloclist
argument_list|,
operator|&
name|pwr_pda
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|pwr_mcpair
operator|->
name|flag
condition|)
name|RF_WAIT_COND
argument_list|(
name|pwr_mcpair
operator|->
name|cond
argument_list|,
name|pwr_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|pwr_mcpair
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwr_dag_h
operator|->
name|status
operator|!=
name|rf_enable
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"Unable to write parity to disk\n"
argument_list|)
expr_stmt|;
comment|/* add code to fail the parity disk */
name|RF_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* release resources associated with read of old parity */
comment|/* RF_Free(prd_pda, sizeof(RF_PhysDiskAddr_t)); */
name|rf_FreePhysDiskAddr
argument_list|(
name|prd_pda
argument_list|)
expr_stmt|;
name|rf_FreeDAG
argument_list|(
name|prd_dag_h
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|prd_alloclist
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|prd_mcpair
argument_list|)
expr_stmt|;
comment|/* release resources associated with write of new parity */
name|ReleaseReintBuffer
argument_list|(
operator|&
name|raidPtr
operator|->
name|parityBufferPool
argument_list|,
name|parityBuffer
argument_list|)
expr_stmt|;
comment|/* RF_Free(pwr_pda, sizeof(RF_PhysDiskAddr_t)); */
name|rf_FreePhysDiskAddr
argument_list|(
name|pwr_pda
argument_list|)
expr_stmt|;
name|rf_FreeDAG
argument_list|(
name|pwr_dag_h
argument_list|)
expr_stmt|;
name|rf_FreeAllocList
argument_list|(
name|pwr_alloclist
argument_list|)
expr_stmt|;
name|rf_FreeMCPair
argument_list|(
name|pwr_mcpair
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[finished reintegrating region %d]\n"
argument_list|,
name|regionID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ReintegrateLogs
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_ParityLog_t
modifier|*
name|logList
parameter_list|)
block|{
name|RF_ParityLog_t
modifier|*
name|log
decl_stmt|,
modifier|*
name|freeLogList
init|=
name|NULL
decl_stmt|;
name|RF_ParityLogData_t
modifier|*
name|logData
decl_stmt|,
modifier|*
name|logDataList
decl_stmt|;
name|RF_RegionId_t
name|regionID
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|logList
argument_list|)
expr_stmt|;
while|while
condition|(
name|logList
condition|)
block|{
name|log
operator|=
name|logList
expr_stmt|;
name|logList
operator|=
name|logList
operator|->
name|next
expr_stmt|;
name|log
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|regionID
operator|=
name|log
operator|->
name|regionID
expr_stmt|;
name|ReintegrateRegion
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|log
operator|->
name|numRecords
operator|=
literal|0
expr_stmt|;
comment|/* remove all items which are blocked on reintegration of this 		 * region */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|logData
operator|=
name|rf_SearchAndDequeueParityLogData
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockTail
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
name|logDataList
operator|=
name|logData
expr_stmt|;
while|while
condition|(
name|logData
condition|)
block|{
name|logData
operator|->
name|next
operator|=
name|rf_SearchAndDequeueParityLogData
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockHead
argument_list|,
operator|&
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintBlockTail
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
name|logData
operator|=
name|logData
operator|->
name|next
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* process blocked log data and clear reintInProgress flag for 		 * this region */
if|if
condition|(
name|logDataList
condition|)
name|rf_ParityLogAppend
argument_list|(
name|logDataList
argument_list|,
name|RF_TRUE
argument_list|,
operator|&
name|log
argument_list|,
name|RF_TRUE
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Enable flushing for this region.  Holding both 			 * locks provides a synchronization barrier with 			 * DumpParityLogToDisk */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
operator|=
literal|0
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintInProgress
operator|=
name|RF_FALSE
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|reintMutex
argument_list|)
expr_stmt|;
comment|/* flushing is now 											 * enabled */
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
comment|/* if log wasn't used, attach it to the list of logs to be 		 * returned */
if|if
condition|(
name|log
condition|)
block|{
name|log
operator|->
name|next
operator|=
name|freeLogList
expr_stmt|;
name|freeLogList
operator|=
name|log
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freeLogList
condition|)
name|rf_ReleaseParityLogs
argument_list|(
name|raidPtr
argument_list|,
name|freeLogList
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ShutdownLogging
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
comment|/* shutdown parity logging 1) disable parity logging in all regions 2) 	 * reintegrate all regions */
name|RF_SectorCount_t
name|diskCount
decl_stmt|;
name|RF_RegionId_t
name|regionID
decl_stmt|;
name|RF_ParityLog_t
modifier|*
name|log
decl_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[shutting down parity logging]\n"
argument_list|)
expr_stmt|;
comment|/* Since parity log maps are volatile, we must reintegrate all 	 * regions. */
if|if
condition|(
name|rf_forceParityLogReint
condition|)
block|{
for|for
control|(
name|regionID
operator|=
literal|0
init|;
name|regionID
operator|<
name|rf_numParityRegions
condition|;
name|regionID
operator|++
control|)
block|{
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|loggingEnabled
operator|=
name|RF_FALSE
expr_stmt|;
name|log
operator|=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
expr_stmt|;
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|coreLog
operator|=
name|NULL
expr_stmt|;
name|diskCount
operator|=
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|diskCount
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|regionInfo
index|[
name|regionID
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskCount
operator|>
literal|0
operator|||
name|log
operator|!=
name|NULL
condition|)
name|ReintegrateRegion
argument_list|(
name|raidPtr
argument_list|,
name|regionID
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|!=
name|NULL
condition|)
name|rf_ReleaseParityLogs
argument_list|(
name|raidPtr
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rf_parityLogDebug
condition|)
block|{
name|printf
argument_list|(
literal|"[parity logging disabled]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[should be done!]\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_ParityLoggingDiskManager
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|)
block|{
name|RF_ParityLog_t
modifier|*
name|reintQueue
decl_stmt|,
modifier|*
name|flushQueue
decl_stmt|;
name|int
name|workNeeded
decl_stmt|,
name|done
init|=
name|RF_FALSE
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Main program for parity logging disk thread.  This routine waits 	 * for work to appear in either the flush or reintegration queues and 	 * is responsible for flushing core logs to the log disk as well as 	 * reintegrating parity regions. 	 *  	 * BLOCKING */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/*          * Inform our creator that we're running. Don't bother doing the          * mutex lock/unlock dance- we locked above, and we'll unlock          * below with nothing to do, yet.          */
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|threadState
operator||=
name|RF_PLOG_RUNNING
expr_stmt|;
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|cond
argument_list|)
expr_stmt|;
comment|/* empty the work queues */
name|flushQueue
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
operator|=
name|NULL
expr_stmt|;
name|reintQueue
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
operator|=
name|NULL
expr_stmt|;
name|workNeeded
operator|=
operator|(
name|flushQueue
operator|||
name|reintQueue
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
while|while
condition|(
name|workNeeded
condition|)
block|{
comment|/* First, flush all logs in the flush queue, freeing 			 * buffers Second, reintegrate all regions which are 			 * reported as full. Third, append queued log data 			 * until blocked. 			 *  			 * Note: Incoming appends (ParityLogAppend) can block on 			 * either 1. empty buffer pool 2. region under 			 * reintegration To preserve a global FIFO ordering of 			 * appends, buffers are not released to the world 			 * until those appends blocked on buffers are removed 			 * from the append queue.  Similarly, regions which 			 * are reintegrated are not opened for general use 			 * until the append queue has been emptied. */
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
comment|/* empty flushQueue, using free'd log buffers to 			 * process bufTail */
if|if
condition|(
name|flushQueue
condition|)
name|FlushLogsToDisk
argument_list|(
name|raidPtr
argument_list|,
name|flushQueue
argument_list|)
expr_stmt|;
comment|/* empty reintQueue, flushing from reintTail as we go */
if|if
condition|(
name|reintQueue
condition|)
name|ReintegrateLogs
argument_list|(
name|raidPtr
argument_list|,
name|reintQueue
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|flushQueue
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
operator|=
name|NULL
expr_stmt|;
name|reintQueue
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
operator|=
name|NULL
expr_stmt|;
name|workNeeded
operator|=
operator|(
name|flushQueue
operator|||
name|reintQueue
operator|)
expr_stmt|;
block|}
comment|/* no work is needed at this point */
if|if
condition|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|threadState
operator|&
name|RF_PLOG_TERMINATE
condition|)
block|{
comment|/* shutdown parity logging 1. disable parity logging 			 * in all regions 2. reintegrate all regions */
name|done
operator|=
name|RF_TRUE
expr_stmt|;
comment|/* thread disabled, no work needed */
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|rf_ShutdownLogging
argument_list|(
name|raidPtr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* thread enabled, no work needed, so sleep */
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[parity logging disk manager sleeping]\n"
argument_list|)
expr_stmt|;
name|RF_WAIT_COND
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|cond
argument_list|,
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_parityLogDebug
condition|)
name|printf
argument_list|(
literal|"[parity logging disk manager just woke up]\n"
argument_list|)
expr_stmt|;
name|flushQueue
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|flushQueue
operator|=
name|NULL
expr_stmt|;
name|reintQueue
operator|=
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|reintQueue
operator|=
name|NULL
expr_stmt|;
name|workNeeded
operator|=
operator|(
name|flushQueue
operator|||
name|reintQueue
operator|)
expr_stmt|;
block|}
block|}
comment|/*          * Announce that we're done.          */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|threadState
operator||=
name|RF_PLOG_SHUTDOWN
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|RF_SIGNAL_COND
argument_list|(
name|raidPtr
operator|->
name|parityLogDiskQueue
operator|.
name|cond
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*          * In the NetBSD kernel, the thread must exit; returning would          * cause the proc trampoline to attempt to return to userspace.          */
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* does not return */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RF_INCLUDE_PARITYLOGGING> 0 */
end_comment

end_unit

