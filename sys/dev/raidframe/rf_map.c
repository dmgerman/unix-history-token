begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_map.c,v 1.5 2000/06/29 00:22:27 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/**************************************************************************  *  * map.c -- main code for mapping RAID addresses to physical disk addresses  *  **************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_freelist.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_function_decl
specifier|static
name|void
name|rf_FreePDAList
parameter_list|(
name|RF_PhysDiskAddr_t
modifier|*
name|start
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|end
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_FreeASMList
parameter_list|(
name|RF_AccessStripeMap_t
modifier|*
name|start
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|end
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************************************************************************  *  * MapAccess -- main 1st order mapping routine.  *  * Maps an access in the RAID address space to the corresponding set of physical disk  * addresses.  The result is returned as a list of AccessStripeMap structures, one per  * stripe accessed.  Each ASM structure contains a pointer to a list of PhysDiskAddr  * structures, which describe the physical locations touched by the user access.  Note  * that this routine returns only static mapping information, i.e. the list of physical  * addresses returned does not necessarily identify the set of physical locations that  * will actually be read or written.  *  * The routine also maps the parity.  The physical disk location returned always  * indicates the entire parity unit, even when only a subset of it is being accessed.  * This is because an access that is not stripe unit aligned but that spans a stripe  * unit boundary may require access two distinct portions of the parity unit, and we  * can't yet tell which portion(s) we'll actually need.  We leave it up to the algorithm  * selection code to decide what subset of the parity unit to access.  *  * Note that addresses in the RAID address space must always be maintained as  * longs, instead of ints.  *  * This routine returns NULL if numBlocks is 0  *  ****************************************************************************************/
end_comment

begin_function
name|RF_AccessStripeMapHeader_t
modifier|*
name|rf_MapAccess
parameter_list|(
name|raidPtr
parameter_list|,
name|raidAddress
parameter_list|,
name|numBlocks
parameter_list|,
name|buffer
parameter_list|,
name|remap
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidAddr_t
name|raidAddress
decl_stmt|;
comment|/* starting address in RAID address 					 * space */
name|RF_SectorCount_t
name|numBlocks
decl_stmt|;
comment|/* number of blocks in RAID address 					 * space to access */
name|caddr_t
name|buffer
decl_stmt|;
comment|/* buffer to supply/receive data */
name|int
name|remap
decl_stmt|;
comment|/* 1 => remap addresses to spare space */
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_hdr
init|=
name|NULL
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asm_list
init|=
name|NULL
decl_stmt|,
modifier|*
name|asm_p
init|=
name|NULL
decl_stmt|;
name|int
name|faultsTolerated
init|=
name|layoutPtr
operator|->
name|map
operator|->
name|faultsTolerated
decl_stmt|;
name|RF_RaidAddr_t
name|startAddress
init|=
name|raidAddress
decl_stmt|;
comment|/* we'll change 							 * raidAddress along the 							 * way */
name|RF_RaidAddr_t
name|endAddress
init|=
name|raidAddress
operator|+
name|numBlocks
decl_stmt|;
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
init|=
name|raidPtr
operator|->
name|Disks
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda_p
decl_stmt|,
modifier|*
name|pda_q
decl_stmt|;
name|RF_StripeCount_t
name|numStripes
init|=
literal|0
decl_stmt|;
name|RF_RaidAddr_t
name|stripeRealEndAddress
decl_stmt|,
name|stripeEndAddress
decl_stmt|,
name|nextStripeUnitAddress
decl_stmt|;
name|RF_RaidAddr_t
name|startAddrWithinStripe
decl_stmt|,
name|lastRaidAddr
decl_stmt|;
name|RF_StripeCount_t
name|totStripes
decl_stmt|;
name|RF_StripeNum_t
name|stripeID
decl_stmt|,
name|lastSID
decl_stmt|,
name|SUID
decl_stmt|,
name|lastSUID
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmList
decl_stmt|,
modifier|*
name|t_asm
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pdaList
decl_stmt|,
modifier|*
name|t_pda
decl_stmt|;
comment|/* allocate all the ASMs and PDAs up front */
name|lastRaidAddr
operator|=
name|raidAddress
operator|+
name|numBlocks
operator|-
literal|1
expr_stmt|;
name|stripeID
operator|=
name|rf_RaidAddressToStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddress
argument_list|)
expr_stmt|;
name|lastSID
operator|=
name|rf_RaidAddressToStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|lastRaidAddr
argument_list|)
expr_stmt|;
name|totStripes
operator|=
name|lastSID
operator|-
name|stripeID
operator|+
literal|1
expr_stmt|;
name|SUID
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddress
argument_list|)
expr_stmt|;
name|lastSUID
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
name|layoutPtr
argument_list|,
name|lastRaidAddr
argument_list|)
expr_stmt|;
name|asmList
operator|=
name|rf_AllocASMList
argument_list|(
name|totStripes
argument_list|)
expr_stmt|;
name|pdaList
operator|=
name|rf_AllocPDAList
argument_list|(
name|lastSUID
operator|-
name|SUID
operator|+
literal|1
operator|+
name|faultsTolerated
operator|*
name|totStripes
argument_list|)
expr_stmt|;
comment|/* may also need pda(s) 											 * per stripe for parity */
if|if
condition|(
name|raidAddress
operator|+
name|numBlocks
operator|>
name|raidPtr
operator|->
name|totalSectors
condition|)
block|{
name|RF_ERRORMSG1
argument_list|(
literal|"Unable to map access because offset (%d) was invalid\n"
argument_list|,
operator|(
name|int
operator|)
name|raidAddress
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|rf_mapDebug
condition|)
name|rf_PrintRaidAddressInfo
argument_list|(
name|raidPtr
argument_list|,
name|raidAddress
argument_list|,
name|numBlocks
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|raidAddress
operator|<
name|endAddress
condition|;
control|)
block|{
comment|/* make the next stripe structure */
name|RF_ASSERT
argument_list|(
name|asmList
argument_list|)
expr_stmt|;
name|t_asm
operator|=
name|asmList
expr_stmt|;
name|asmList
operator|=
name|asmList
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t_asm
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMap_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asm_p
condition|)
name|asm_list
operator|=
name|asm_p
operator|=
name|t_asm
expr_stmt|;
else|else
block|{
name|asm_p
operator|->
name|next
operator|=
name|t_asm
expr_stmt|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
expr_stmt|;
block|}
name|numStripes
operator|++
expr_stmt|;
comment|/* map SUs from current location to the end of the stripe */
name|asm_p
operator|->
name|stripeID
operator|=
comment|/* rf_RaidAddressToStripeID(layoutPtr, 		        raidAddress) */
name|stripeID
operator|++
expr_stmt|;
name|stripeRealEndAddress
operator|=
name|rf_RaidAddressOfNextStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddress
argument_list|)
expr_stmt|;
name|stripeEndAddress
operator|=
name|RF_MIN
argument_list|(
name|endAddress
argument_list|,
name|stripeRealEndAddress
argument_list|)
expr_stmt|;
name|asm_p
operator|->
name|raidAddress
operator|=
name|raidAddress
expr_stmt|;
name|asm_p
operator|->
name|endRaidAddress
operator|=
name|stripeEndAddress
expr_stmt|;
comment|/* map each stripe unit in the stripe */
name|pda_p
operator|=
name|NULL
expr_stmt|;
name|startAddrWithinStripe
operator|=
name|raidAddress
expr_stmt|;
comment|/* Raid addr of start of 							 * portion of access 							 * that is within this 							 * stripe */
for|for
control|(
init|;
name|raidAddress
operator|<
name|stripeEndAddress
condition|;
control|)
block|{
name|RF_ASSERT
argument_list|(
name|pdaList
argument_list|)
expr_stmt|;
name|t_pda
operator|=
name|pdaList
expr_stmt|;
name|pdaList
operator|=
name|pdaList
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t_pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pda_p
condition|)
name|asm_p
operator|->
name|physInfo
operator|=
name|pda_p
operator|=
name|t_pda
expr_stmt|;
else|else
block|{
name|pda_p
operator|->
name|next
operator|=
name|t_pda
expr_stmt|;
name|pda_p
operator|=
name|pda_p
operator|->
name|next
expr_stmt|;
block|}
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
name|remap
argument_list|)
expr_stmt|;
comment|/* mark any failures we find.  failedPDA is don't-care 			 * if there is more than one failure */
name|pda_p
operator|->
name|raidAddress
operator|=
name|raidAddress
expr_stmt|;
comment|/* the RAID address 								 * corresponding to this 								 * physical disk address */
name|nextStripeUnitAddress
operator|=
name|rf_RaidAddressOfNextStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddress
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|numSector
operator|=
name|RF_MIN
argument_list|(
name|endAddress
argument_list|,
name|nextStripeUnitAddress
argument_list|)
operator|-
name|raidAddress
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda_p
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rf_ASMCheckStatus
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
argument_list|,
name|asm_p
argument_list|,
name|disks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|bufPtr
operator|=
name|buffer
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
operator|(
name|raidAddress
operator|-
name|startAddress
operator|)
argument_list|)
expr_stmt|;
name|asm_p
operator|->
name|totalSectorsAccessed
operator|+=
name|pda_p
operator|->
name|numSector
expr_stmt|;
name|asm_p
operator|->
name|numStripeUnitsAccessed
operator|++
expr_stmt|;
name|asm_p
operator|->
name|origRow
operator|=
name|pda_p
operator|->
name|row
expr_stmt|;
comment|/* redundant but 							 * harmless to do this 							 * in every loop 							 * iteration */
name|raidAddress
operator|=
name|RF_MIN
argument_list|(
name|endAddress
argument_list|,
name|nextStripeUnitAddress
argument_list|)
expr_stmt|;
block|}
comment|/* Map the parity. At this stage, the startSector and 		 * numSector fields for the parity unit are always set to 		 * indicate the entire parity unit. We may modify this after 		 * mapping the data portion. */
switch|switch
condition|(
name|faultsTolerated
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
comment|/* single fault tolerant */
name|RF_ASSERT
argument_list|(
name|pdaList
argument_list|)
expr_stmt|;
name|t_pda
operator|=
name|pdaList
expr_stmt|;
name|pdaList
operator|=
name|pdaList
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t_pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|pda_p
operator|=
name|asm_p
operator|->
name|parityInfo
operator|=
name|t_pda
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
name|remap
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|numSector
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
comment|/* raidAddr may be needed to find unit to redirect to */
name|pda_p
operator|->
name|raidAddress
operator|=
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
expr_stmt|;
name|rf_ASMCheckStatus
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
argument_list|,
name|asm_p
argument_list|,
name|disks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rf_ASMParityAdjust
argument_list|(
name|asm_p
operator|->
name|parityInfo
argument_list|,
name|startAddrWithinStripe
argument_list|,
name|endAddress
argument_list|,
name|layoutPtr
argument_list|,
name|asm_p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* two fault tolerant */
name|RF_ASSERT
argument_list|(
name|pdaList
operator|&&
name|pdaList
operator|->
name|next
argument_list|)
expr_stmt|;
name|t_pda
operator|=
name|pdaList
expr_stmt|;
name|pdaList
operator|=
name|pdaList
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t_pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|pda_p
operator|=
name|asm_p
operator|->
name|parityInfo
operator|=
name|t_pda
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|t_pda
operator|=
name|pdaList
expr_stmt|;
name|pdaList
operator|=
name|pdaList
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t_pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|pda_q
operator|=
name|asm_p
operator|->
name|qInfo
operator|=
name|t_pda
expr_stmt|;
name|pda_q
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
name|remap
argument_list|)
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapQ
call|)
argument_list|(
name|raidPtr
argument_list|,
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
argument_list|,
operator|&
operator|(
name|pda_q
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_q
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_q
operator|->
name|startSector
operator|)
argument_list|,
name|remap
argument_list|)
expr_stmt|;
name|pda_q
operator|->
name|numSector
operator|=
name|pda_p
operator|->
name|numSector
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
comment|/* raidAddr may be needed to find unit to redirect to */
name|pda_p
operator|->
name|raidAddress
operator|=
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
expr_stmt|;
name|pda_q
operator|->
name|raidAddress
operator|=
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
expr_stmt|;
comment|/* failure mode stuff */
name|rf_ASMCheckStatus
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
argument_list|,
name|asm_p
argument_list|,
name|disks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rf_ASMCheckStatus
argument_list|(
name|raidPtr
argument_list|,
name|pda_q
argument_list|,
name|asm_p
argument_list|,
name|disks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rf_ASMParityAdjust
argument_list|(
name|asm_p
operator|->
name|parityInfo
argument_list|,
name|startAddrWithinStripe
argument_list|,
name|endAddress
argument_list|,
name|layoutPtr
argument_list|,
name|asm_p
argument_list|)
expr_stmt|;
name|rf_ASMParityAdjust
argument_list|(
name|asm_p
operator|->
name|qInfo
argument_list|,
name|startAddrWithinStripe
argument_list|,
name|endAddress
argument_list|,
name|layoutPtr
argument_list|,
name|asm_p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|RF_ASSERT
argument_list|(
name|asmList
operator|==
name|NULL
operator|&&
name|pdaList
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* make the header structure */
name|asm_hdr
operator|=
name|rf_AllocAccessStripeMapHeader
argument_list|()
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|numStripes
operator|==
name|totStripes
argument_list|)
expr_stmt|;
name|asm_hdr
operator|->
name|numStripes
operator|=
name|numStripes
expr_stmt|;
name|asm_hdr
operator|->
name|stripeMap
operator|=
name|asm_list
expr_stmt|;
if|if
condition|(
name|rf_mapDebug
condition|)
name|rf_PrintAccessStripeMap
argument_list|(
name|asm_hdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|asm_hdr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  * This routine walks through an ASM list and marks the PDAs that have failed.  * It's called only when a disk failure causes an in-flight DAG to fail.  * The parity may consist of two components, but we want to use only one failedPDA  * pointer.  Thus we set failedPDA to point to the first parity component, and rely  * on the rest of the code to do the right thing with this.  ****************************************************************************************/
end_comment

begin_function
name|void
name|rf_MarkFailuresInASMList
parameter_list|(
name|raidPtr
parameter_list|,
name|asm_h
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
block|{
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
init|=
name|raidPtr
operator|->
name|Disks
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
for|for
control|(
name|asmap
operator|=
name|asm_h
operator|->
name|stripeMap
init|;
name|asmap
condition|;
name|asmap
operator|=
name|asmap
operator|->
name|next
control|)
block|{
name|asmap
operator|->
name|numDataFailed
operator|=
name|asmap
operator|->
name|numParityFailed
operator|=
name|asmap
operator|->
name|numQFailed
operator|=
literal|0
expr_stmt|;
name|asmap
operator|->
name|numFailedPDAs
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|asmap
operator|->
name|failedPDAs
argument_list|,
name|RF_MAX_FAILED_PDA
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|asmap
operator|->
name|numDataFailed
operator|++
expr_stmt|;
name|asmap
operator|->
name|failedPDAs
index|[
name|asmap
operator|->
name|numFailedPDAs
index|]
operator|=
name|pda
expr_stmt|;
name|asmap
operator|->
name|numFailedPDAs
operator|++
expr_stmt|;
block|}
block|}
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
expr_stmt|;
if|if
condition|(
name|pda
operator|&&
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|asmap
operator|->
name|numParityFailed
operator|++
expr_stmt|;
name|asmap
operator|->
name|failedPDAs
index|[
name|asmap
operator|->
name|numFailedPDAs
index|]
operator|=
name|pda
expr_stmt|;
name|asmap
operator|->
name|numFailedPDAs
operator|++
expr_stmt|;
block|}
name|pda
operator|=
name|asmap
operator|->
name|qInfo
expr_stmt|;
if|if
condition|(
name|pda
operator|&&
name|RF_DEAD_DISK
argument_list|(
name|disks
index|[
name|pda
operator|->
name|row
index|]
index|[
name|pda
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
name|asmap
operator|->
name|numQFailed
operator|++
expr_stmt|;
name|asmap
operator|->
name|failedPDAs
index|[
name|asmap
operator|->
name|numFailedPDAs
index|]
operator|=
name|pda
expr_stmt|;
name|asmap
operator|->
name|numFailedPDAs
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * DuplicateASM -- duplicates an ASM and returns the new one  *  ****************************************************************************************/
end_comment

begin_function
name|RF_AccessStripeMap_t
modifier|*
name|rf_DuplicateASM
parameter_list|(
name|asmap
parameter_list|)
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
block|{
name|RF_AccessStripeMap_t
modifier|*
name|new_asm
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|new_pda
decl_stmt|,
modifier|*
name|t_pda
decl_stmt|;
name|new_pda
operator|=
name|NULL
expr_stmt|;
name|new_asm
operator|=
name|rf_AllocAccessStripeMapComponent
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|asmap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new_asm
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMap_t
argument_list|)
argument_list|)
expr_stmt|;
name|new_asm
operator|->
name|numFailedPDAs
operator|=
literal|0
expr_stmt|;
comment|/* ??? */
name|new_asm
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|new_asm
operator|->
name|physInfo
operator|=
name|NULL
expr_stmt|;
name|new_asm
operator|->
name|parityInfo
operator|=
name|NULL
expr_stmt|;
name|new_asm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
comment|/* copy the physInfo 								 * list */
name|t_pda
operator|=
name|rf_AllocPhysDiskAddr
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pda
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t_pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|t_pda
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|new_asm
operator|->
name|physInfo
condition|)
block|{
name|new_asm
operator|->
name|physInfo
operator|=
name|t_pda
expr_stmt|;
name|new_pda
operator|=
name|t_pda
expr_stmt|;
block|}
else|else
block|{
name|new_pda
operator|->
name|next
operator|=
name|t_pda
expr_stmt|;
name|new_pda
operator|=
name|new_pda
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|pda
operator|==
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
condition|)
name|new_asm
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|=
name|t_pda
expr_stmt|;
block|}
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|parityInfo
init|;
name|pda
condition|;
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
comment|/* copy the parityInfo 								 * list */
name|t_pda
operator|=
name|rf_AllocPhysDiskAddr
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pda
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t_pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|t_pda
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|new_asm
operator|->
name|parityInfo
condition|)
block|{
name|new_asm
operator|->
name|parityInfo
operator|=
name|t_pda
expr_stmt|;
name|new_pda
operator|=
name|t_pda
expr_stmt|;
block|}
else|else
block|{
name|new_pda
operator|->
name|next
operator|=
name|t_pda
expr_stmt|;
name|new_pda
operator|=
name|new_pda
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|pda
operator|==
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
condition|)
name|new_asm
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|=
name|t_pda
expr_stmt|;
block|}
return|return
operator|(
name|new_asm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * DuplicatePDA -- duplicates a PDA and returns the new one  *  ****************************************************************************************/
end_comment

begin_function
name|RF_PhysDiskAddr_t
modifier|*
name|rf_DuplicatePDA
parameter_list|(
name|pda
parameter_list|)
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|rf_AllocPhysDiskAddr
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pda
argument_list|,
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * routines to allocate and free list elements.  All allocation routines zero the  * structure before returning it.  *  * FreePhysDiskAddr is static.  It should never be called directly, because  * FreeAccessStripeMap takes care of freeing the PhysDiskAddr list.  *  ****************************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_asmhdr_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_ASMHDR
value|128
end_define

begin_define
define|#
directive|define
name|RF_ASMHDR_INC
value|16
end_define

begin_define
define|#
directive|define
name|RF_ASMHDR_INITIAL
value|32
end_define

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_asm_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_ASM
value|192
end_define

begin_define
define|#
directive|define
name|RF_ASM_INC
value|24
end_define

begin_define
define|#
directive|define
name|RF_ASM_INITIAL
value|64
end_define

begin_decl_stmt
specifier|static
name|RF_FreeList_t
modifier|*
name|rf_pda_freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RF_MAX_FREE_PDA
value|192
end_define

begin_define
define|#
directive|define
name|RF_PDA_INC
value|24
end_define

begin_define
define|#
directive|define
name|RF_PDA_INITIAL
value|64
end_define

begin_comment
comment|/* called at shutdown time.  So far, all that is necessary is to release all the free lists */
end_comment

begin_function_decl
specifier|static
name|void
name|rf_ShutdownMapModule
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownMapModule
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_pda_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_asm_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureMapModule
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|RF_FREELIST_CREATE
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|RF_MAX_FREE_ASMHDR
argument_list|,
name|RF_ASMHDR_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_asmhdr_freelist
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|RF_FREELIST_CREATE
argument_list|(
name|rf_asm_freelist
argument_list|,
name|RF_MAX_FREE_ASM
argument_list|,
name|RF_ASM_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMap_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_asm_freelist
operator|==
name|NULL
condition|)
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|RF_FREELIST_CREATE
argument_list|(
name|rf_pda_freelist
argument_list|,
name|RF_MAX_FREE_PDA
argument_list|,
name|RF_PDA_INC
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_pda_freelist
operator|==
name|NULL
condition|)
block|{
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_FREELIST_DESTROY
argument_list|(
name|rf_pda_freelist
argument_list|,
name|next
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownMapModule
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_ShutdownMapModule
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|RF_FREELIST_PRIME
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|RF_ASMHDR_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_FREELIST_PRIME
argument_list|(
name|rf_asm_freelist
argument_list|,
name|RF_ASM_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|RF_FREELIST_PRIME
argument_list|(
name|rf_pda_freelist
argument_list|,
name|RF_PDA_INITIAL
argument_list|,
name|next
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|RF_AccessStripeMapHeader_t
modifier|*
name|rf_AllocAccessStripeMapHeader
parameter_list|()
block|{
name|RF_AccessStripeMapHeader_t
modifier|*
name|p
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMapHeader_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMapHeader_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeAccessStripeMapHeader
parameter_list|(
name|p
parameter_list|)
name|RF_AccessStripeMapHeader_t
modifier|*
name|p
decl_stmt|;
block|{
name|RF_FREELIST_FREE
argument_list|(
name|rf_asmhdr_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|RF_PhysDiskAddr_t
modifier|*
name|rf_AllocPhysDiskAddr
parameter_list|()
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|p
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_pda_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* allocates a list of PDAs, locking the free list only once  * when we have to call calloc, we do it one component at a time to simplify  * the process of freeing the list at program shutdown.  This should not be  * much of a performance hit, because it should be very infrequently executed.  */
end_comment

begin_function
name|RF_PhysDiskAddr_t
modifier|*
name|rf_AllocPDAList
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|RF_FREELIST_GET_N
argument_list|(
name|rf_pda_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreePhysDiskAddr
parameter_list|(
name|p
parameter_list|)
name|RF_PhysDiskAddr_t
modifier|*
name|p
decl_stmt|;
block|{
name|RF_FREELIST_FREE
argument_list|(
name|rf_pda_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_FreePDAList
parameter_list|(
name|l_start
parameter_list|,
name|l_end
parameter_list|,
name|count
parameter_list|)
name|RF_PhysDiskAddr_t
modifier|*
name|l_start
decl_stmt|,
decl|*
name|l_end
decl_stmt|;
end_function

begin_comment
comment|/* pointers to start and end 						 * of list */
end_comment

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of elements in list */
end_comment

begin_block
block|{
name|RF_FREELIST_FREE_N
argument_list|(
name|rf_pda_freelist
argument_list|,
name|l_start
argument_list|,
name|next
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|RF_AccessStripeMap_t
modifier|*
name|rf_AllocAccessStripeMapComponent
parameter_list|()
block|{
name|RF_AccessStripeMap_t
modifier|*
name|p
decl_stmt|;
name|RF_FREELIST_GET
argument_list|(
name|rf_asm_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_AccessStripeMap_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this is essentially identical to AllocPDAList.  I should combine the two.  * when we have to call calloc, we do it one component at a time to simplify  * the process of freeing the list at program shutdown.  This should not be  * much of a performance hit, because it should be very infrequently executed.  */
end_comment

begin_function
name|RF_AccessStripeMap_t
modifier|*
name|rf_AllocASMList
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|RF_AccessStripeMap_t
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|RF_FREELIST_GET_N
argument_list|(
name|rf_asm_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_FreeAccessStripeMapComponent
parameter_list|(
name|p
parameter_list|)
name|RF_AccessStripeMap_t
modifier|*
name|p
decl_stmt|;
block|{
name|RF_FREELIST_FREE
argument_list|(
name|rf_asm_freelist
argument_list|,
name|p
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rf_FreeASMList
parameter_list|(
name|l_start
parameter_list|,
name|l_end
parameter_list|,
name|count
parameter_list|)
name|RF_AccessStripeMap_t
modifier|*
name|l_start
decl_stmt|,
decl|*
name|l_end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RF_FREELIST_FREE_N
argument_list|(
name|rf_asm_freelist
argument_list|,
name|l_start
argument_list|,
name|next
argument_list|,
operator|(
name|RF_AccessStripeMap_t
operator|*
operator|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|rf_FreeAccessStripeMap
parameter_list|(
name|hdr
parameter_list|)
name|RF_AccessStripeMapHeader_t
modifier|*
name|hdr
decl_stmt|;
block|{
name|RF_AccessStripeMap_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pt
init|=
name|NULL
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pdp
decl_stmt|,
modifier|*
name|trailer
decl_stmt|,
modifier|*
name|pdaList
init|=
name|NULL
decl_stmt|,
modifier|*
name|pdaEnd
init|=
name|NULL
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|,
name|asm_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hdr
operator|->
name|stripeMap
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
comment|/* link the 3 pda lists into the accumulating pda list */
if|if
condition|(
operator|!
name|pdaList
condition|)
name|pdaList
operator|=
name|p
operator|->
name|qInfo
expr_stmt|;
else|else
name|pdaEnd
operator|->
name|next
operator|=
name|p
operator|->
name|qInfo
expr_stmt|;
for|for
control|(
name|trailer
operator|=
name|NULL
operator|,
name|pdp
operator|=
name|p
operator|->
name|qInfo
init|;
name|pdp
condition|;
control|)
block|{
name|trailer
operator|=
name|pdp
expr_stmt|;
name|pdp
operator|=
name|pdp
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|trailer
condition|)
name|pdaEnd
operator|=
name|trailer
expr_stmt|;
if|if
condition|(
operator|!
name|pdaList
condition|)
name|pdaList
operator|=
name|p
operator|->
name|parityInfo
expr_stmt|;
else|else
name|pdaEnd
operator|->
name|next
operator|=
name|p
operator|->
name|parityInfo
expr_stmt|;
for|for
control|(
name|trailer
operator|=
name|NULL
operator|,
name|pdp
operator|=
name|p
operator|->
name|parityInfo
init|;
name|pdp
condition|;
control|)
block|{
name|trailer
operator|=
name|pdp
expr_stmt|;
name|pdp
operator|=
name|pdp
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|trailer
condition|)
name|pdaEnd
operator|=
name|trailer
expr_stmt|;
if|if
condition|(
operator|!
name|pdaList
condition|)
name|pdaList
operator|=
name|p
operator|->
name|physInfo
expr_stmt|;
else|else
name|pdaEnd
operator|->
name|next
operator|=
name|p
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|trailer
operator|=
name|NULL
operator|,
name|pdp
operator|=
name|p
operator|->
name|physInfo
init|;
name|pdp
condition|;
control|)
block|{
name|trailer
operator|=
name|pdp
expr_stmt|;
name|pdp
operator|=
name|pdp
operator|->
name|next
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|trailer
condition|)
name|pdaEnd
operator|=
name|trailer
expr_stmt|;
name|pt
operator|=
name|p
expr_stmt|;
name|asm_count
operator|++
expr_stmt|;
block|}
comment|/* debug only */
for|for
control|(
name|t
operator|=
literal|0
operator|,
name|pdp
operator|=
name|pdaList
init|;
name|pdp
condition|;
name|pdp
operator|=
name|pdp
operator|->
name|next
control|)
name|t
operator|++
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|t
operator|==
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdaList
condition|)
name|rf_FreePDAList
argument_list|(
name|pdaList
argument_list|,
name|pdaEnd
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|rf_FreeASMList
argument_list|(
name|hdr
operator|->
name|stripeMap
argument_list|,
name|pt
argument_list|,
name|asm_count
argument_list|)
expr_stmt|;
name|rf_FreeAccessStripeMapHeader
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We can't use the large write optimization if there are any failures in the stripe.  * In the declustered layout, there is no way to immediately determine what disks  * constitute a stripe, so we actually have to hunt through the stripe looking for failures.  * The reason we map the parity instead of just using asm->parityInfo->col is because  * the latter may have been already redirected to a spare drive, which would  * mess up the computation of the stripe offset.  *  * ASSUMES AT MOST ONE FAILURE IN THE STRIPE.  */
end_comment

begin_function
name|int
name|rf_CheckStripeForFailures
parameter_list|(
name|raidPtr
parameter_list|,
name|asmap
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
block|{
name|RF_RowCol_t
name|trow
decl_stmt|,
name|tcol
decl_stmt|,
name|prow
decl_stmt|,
name|pcol
decl_stmt|,
modifier|*
name|diskids
decl_stmt|,
name|row
decl_stmt|,
name|i
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_StripeCount_t
name|stripeOffset
decl_stmt|;
name|int
name|numFailures
decl_stmt|;
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|;
name|RF_SectorNum_t
name|diskOffset
decl_stmt|,
name|poffset
decl_stmt|;
name|RF_RowCol_t
name|testrow
decl_stmt|;
comment|/* quick out in the fault-free case.  */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|numFailures
operator|=
name|raidPtr
operator|->
name|numFailures
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|numFailures
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|row
operator|=
name|asmap
operator|->
name|physInfo
operator|->
name|row
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|IdentifyStripe
call|)
argument_list|(
name|raidPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|diskids
argument_list|,
operator|&
name|testrow
argument_list|)
expr_stmt|;
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapParity
call|)
argument_list|(
name|raidPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|prow
argument_list|,
operator|&
name|pcol
argument_list|,
operator|&
name|poffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get pcol */
comment|/* this need not be true if we've redirected the access to a spare in 	 * another row RF_ASSERT(row == testrow); */
name|stripeOffset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
operator|+
name|layoutPtr
operator|->
name|numParityCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|diskids
index|[
name|i
index|]
operator|!=
name|pcol
condition|)
block|{
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|testrow
index|]
index|[
name|diskids
index|[
name|i
index|]
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|raidPtr
operator|->
name|status
index|[
name|testrow
index|]
operator|!=
name|rf_rs_reconstructing
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|RF_ASSERT
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|testrow
index|]
operator|->
name|fcol
operator|==
name|diskids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|layoutPtr
operator|->
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|sosAddr
operator|+
name|stripeOffset
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
operator|&
name|trow
argument_list|,
operator|&
name|tcol
argument_list|,
operator|&
name|diskOffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
name|trow
operator|==
name|testrow
operator|)
operator|&&
operator|(
name|tcol
operator|==
name|diskids
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rf_CheckRUReconstructed
argument_list|(
name|raidPtr
operator|->
name|reconControl
index|[
name|testrow
index|]
operator|->
name|reconMap
argument_list|,
name|diskOffset
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|asmap
operator|->
name|flags
operator||=
name|RF_ASM_REDIR_LARGE_WRITE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|stripeOffset
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    return the number of failed data units in the stripe. */
end_comment

begin_function
name|int
name|rf_NumFailedDataUnitsInStripe
parameter_list|(
name|raidPtr
parameter_list|,
name|asmap
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_RowCol_t
name|trow
decl_stmt|,
name|tcol
decl_stmt|,
name|row
decl_stmt|,
name|i
decl_stmt|;
name|RF_SectorNum_t
name|diskOffset
decl_stmt|;
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|;
name|int
name|numFailures
decl_stmt|;
comment|/* quick out in the fault-free case.  */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|numFailures
operator|=
name|raidPtr
operator|->
name|numFailures
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|numFailures
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|numFailures
operator|=
literal|0
expr_stmt|;
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
name|row
operator|=
name|asmap
operator|->
name|physInfo
operator|->
name|row
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|layoutPtr
operator|->
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
call|(
name|layoutPtr
operator|->
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|sosAddr
operator|+
name|i
operator|*
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|,
operator|&
name|trow
argument_list|,
operator|&
name|tcol
argument_list|,
operator|&
name|diskOffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|trow
index|]
index|[
name|tcol
index|]
operator|.
name|status
argument_list|)
condition|)
name|numFailures
operator|++
expr_stmt|;
block|}
return|return
name|numFailures
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************************  *  * debug routines  *  ****************************************************************************************/
end_comment

begin_function
name|void
name|rf_PrintAccessStripeMap
parameter_list|(
name|asm_h
parameter_list|)
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
block|{
name|rf_PrintFullAccessStripeMap
argument_list|(
name|asm_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rf_PrintFullAccessStripeMap
parameter_list|(
name|asm_h
parameter_list|,
name|prbuf
parameter_list|)
name|RF_AccessStripeMapHeader_t
modifier|*
name|asm_h
decl_stmt|;
name|int
name|prbuf
decl_stmt|;
comment|/* flag to print buffer pointers */
block|{
name|int
name|i
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asmap
init|=
name|asm_h
operator|->
name|stripeMap
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"%d stripes total\n"
argument_list|,
operator|(
name|int
operator|)
name|asm_h
operator|->
name|numStripes
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|asmap
condition|;
name|asmap
operator|=
name|asmap
operator|->
name|next
control|)
block|{
comment|/* printf("Num failures: %d\n",asmap->numDataFailed); */
comment|/* printf("Num sectors: 		 * %d\n",(int)asmap->totalSectorsAccessed); */
name|printf
argument_list|(
literal|"Stripe %d (%d sectors), failures: %d data, %d parity: "
argument_list|,
operator|(
name|int
operator|)
name|asmap
operator|->
name|stripeID
argument_list|,
operator|(
name|int
operator|)
name|asmap
operator|->
name|totalSectorsAccessed
argument_list|,
operator|(
name|int
operator|)
name|asmap
operator|->
name|numDataFailed
argument_list|,
operator|(
name|int
operator|)
name|asmap
operator|->
name|numParityFailed
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|parityInfo
condition|)
block|{
name|printf
argument_list|(
literal|"Parity [r%d c%d s%d-%d"
argument_list|,
name|asmap
operator|->
name|parityInfo
operator|->
name|row
argument_list|,
name|asmap
operator|->
name|parityInfo
operator|->
name|col
argument_list|,
operator|(
name|int
operator|)
name|asmap
operator|->
name|parityInfo
operator|->
name|startSector
argument_list|,
call|(
name|int
call|)
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|startSector
operator|+
name|asmap
operator|->
name|parityInfo
operator|->
name|numSector
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prbuf
condition|)
name|printf
argument_list|(
literal|" b0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|asmap
operator|->
name|parityInfo
operator|->
name|bufPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
condition|)
block|{
name|printf
argument_list|(
literal|", r%d c%d s%d-%d"
argument_list|,
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|row
argument_list|,
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|col
argument_list|,
operator|(
name|int
operator|)
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|startSector
argument_list|,
call|(
name|int
call|)
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|startSector
operator|+
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|numSector
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prbuf
condition|)
name|printf
argument_list|(
literal|" b0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|bufPtr
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"]\n\t"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|asmap
operator|->
name|physInfo
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"SU r%d c%d s%d-%d "
argument_list|,
name|p
operator|->
name|row
argument_list|,
name|p
operator|->
name|col
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|startSector
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|startSector
operator|+
name|p
operator|->
name|numSector
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prbuf
condition|)
name|printf
argument_list|(
literal|"b0x%lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|p
operator|->
name|bufPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|asm_h
operator|->
name|stripeMap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|asm_h
operator|->
name|stripeMap
operator|->
name|numDataFailed
operator|+
name|asm_h
operator|->
name|stripeMap
operator|->
name|numParityFailed
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"[multiple failures]\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|asm_h
operator|->
name|stripeMap
operator|->
name|numDataFailed
operator|+
name|asm_h
operator|->
name|stripeMap
operator|->
name|numParityFailed
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\t[Failed PDA: r%d c%d s%d-%d]\n"
argument_list|,
name|p
operator|->
name|row
argument_list|,
name|p
operator|->
name|col
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|startSector
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|startSector
operator|+
name|p
operator|->
name|numSector
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rf_PrintRaidAddressInfo
parameter_list|(
name|raidPtr
parameter_list|,
name|raidAddr
parameter_list|,
name|numBlocks
parameter_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|RF_RaidAddr_t
name|raidAddr
decl_stmt|;
name|RF_SectorCount_t
name|numBlocks
decl_stmt|;
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_RaidAddr_t
name|ra
decl_stmt|,
name|sosAddr
init|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|raidAddr
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"Raid addrs of SU boundaries from start of stripe to end of access:\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|ra
operator|=
name|sosAddr
init|;
name|ra
operator|<=
name|raidAddr
operator|+
name|numBlocks
condition|;
name|ra
operator|+=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
control|)
block|{
name|printf
argument_list|(
literal|"%d (0x%x), "
argument_list|,
operator|(
name|int
operator|)
name|ra
argument_list|,
operator|(
name|int
operator|)
name|ra
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Offset into stripe unit: %d (0x%x)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|raidAddr
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|raidAddr
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    given a parity descriptor and the starting address within a stripe,    range restrict the parity descriptor to touch only the correct stuff. */
end_comment

begin_function
name|void
name|rf_ASMParityAdjust
parameter_list|(
name|RF_PhysDiskAddr_t
modifier|*
name|toAdjust
parameter_list|,
name|RF_StripeNum_t
name|startAddrWithinStripe
parameter_list|,
name|RF_SectorNum_t
name|endAddress
parameter_list|,
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asm_p
parameter_list|)
block|{
name|RF_PhysDiskAddr_t
modifier|*
name|new_pda
decl_stmt|;
comment|/* when we're accessing only a portion of one stripe unit, we want the 	 * parity descriptor to identify only the chunk of parity associated 	 * with the data.  When the access spans exactly one stripe unit 	 * boundary and is less than a stripe unit in size, it uses two 	 * disjoint regions of the parity unit.  When an access spans more 	 * than one stripe unit boundary, it uses all of the parity unit. 	 *  	 * To better handle the case where stripe units are small, we may 	 * eventually want to change the 2nd case so that if the SU size is 	 * below some threshold, we just read/write the whole thing instead of 	 * breaking it up into two accesses. */
if|if
condition|(
name|asm_p
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
condition|)
block|{
name|int
name|x
init|=
operator|(
name|startAddrWithinStripe
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
decl_stmt|;
name|toAdjust
operator|->
name|startSector
operator|+=
name|x
expr_stmt|;
name|toAdjust
operator|->
name|raidAddress
operator|+=
name|x
expr_stmt|;
name|toAdjust
operator|->
name|numSector
operator|=
name|asm_p
operator|->
name|physInfo
operator|->
name|numSector
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|toAdjust
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asm_p
operator|->
name|numStripeUnitsAccessed
operator|==
literal|2
operator|&&
name|asm_p
operator|->
name|totalSectorsAccessed
operator|<
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
condition|)
block|{
name|int
name|x
init|=
operator|(
name|startAddrWithinStripe
operator|%
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
decl_stmt|;
comment|/* create a second pda and copy the parity map info 			 * into it */
name|RF_ASSERT
argument_list|(
name|toAdjust
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|new_pda
operator|=
name|toAdjust
operator|->
name|next
operator|=
name|rf_AllocPhysDiskAddr
argument_list|()
expr_stmt|;
operator|*
name|new_pda
operator|=
operator|*
name|toAdjust
expr_stmt|;
comment|/* structure assignment */
name|new_pda
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* adjust the start sector& number of blocks for the 			 * first parity pda */
name|toAdjust
operator|->
name|startSector
operator|+=
name|x
expr_stmt|;
name|toAdjust
operator|->
name|raidAddress
operator|+=
name|x
expr_stmt|;
name|toAdjust
operator|->
name|numSector
operator|=
name|rf_RaidAddressOfNextStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|startAddrWithinStripe
argument_list|)
operator|-
name|startAddrWithinStripe
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|toAdjust
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust the second pda */
name|new_pda
operator|->
name|numSector
operator|=
name|endAddress
operator|-
name|rf_RaidAddressOfPrevStripeUnitBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|endAddress
argument_list|)
expr_stmt|;
comment|/* new_pda->raidAddress = 			 * rf_RaidAddressOfNextStripeUnitBoundary(layoutPtr, 			 * toAdjust->raidAddress); */
name|RF_ASSERT
argument_list|(
name|new_pda
operator|->
name|numSector
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    Check if a disk has been spared or failed. If spared,    redirect the I/O.    If it has been failed, record it in the asm pointer.    Fourth arg is whether data or parity. */
end_comment

begin_function
name|void
name|rf_ASMCheckStatus
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
name|pda_p
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asm_p
parameter_list|,
name|RF_RaidDisk_t
modifier|*
modifier|*
name|disks
parameter_list|,
name|int
name|parity
parameter_list|)
block|{
name|RF_DiskStatus_t
name|dstatus
decl_stmt|;
name|RF_RowCol_t
name|frow
decl_stmt|,
name|fcol
decl_stmt|;
name|dstatus
operator|=
name|disks
index|[
name|pda_p
operator|->
name|row
index|]
index|[
name|pda_p
operator|->
name|col
index|]
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|dstatus
operator|==
name|rf_ds_spared
condition|)
block|{
comment|/* if the disk has been spared, redirect access to the spare */
name|frow
operator|=
name|pda_p
operator|->
name|row
expr_stmt|;
name|fcol
operator|=
name|pda_p
operator|->
name|col
expr_stmt|;
name|pda_p
operator|->
name|row
operator|=
name|disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|spareRow
expr_stmt|;
name|pda_p
operator|->
name|col
operator|=
name|disks
index|[
name|frow
index|]
index|[
name|fcol
index|]
operator|.
name|spareCol
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dstatus
operator|==
name|rf_ds_dist_spared
condition|)
block|{
comment|/* ditto if disk has been spared to dist spare space */
name|RF_RowCol_t
name|or
init|=
name|pda_p
operator|->
name|row
decl_stmt|,
name|oc
init|=
name|pda_p
operator|->
name|col
decl_stmt|;
name|RF_SectorNum_t
name|oo
init|=
name|pda_p
operator|->
name|startSector
decl_stmt|;
if|if
condition|(
name|pda_p
operator|->
name|type
operator|==
name|RF_PDA_TYPE_DATA
condition|)
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
name|pda_p
operator|->
name|row
argument_list|,
operator|&
name|pda_p
operator|->
name|col
argument_list|,
operator|&
name|pda_p
operator|->
name|startSector
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
else|else
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapParity
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
name|pda_p
operator|->
name|row
argument_list|,
operator|&
name|pda_p
operator|->
name|col
argument_list|,
operator|&
name|pda_p
operator|->
name|startSector
argument_list|,
name|RF_REMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_mapDebug
condition|)
block|{
name|printf
argument_list|(
literal|"Redirected r %d c %d o %d -> r%d c %d o %d\n"
argument_list|,
name|or
argument_list|,
name|oc
argument_list|,
operator|(
name|int
operator|)
name|oo
argument_list|,
name|pda_p
operator|->
name|row
argument_list|,
name|pda_p
operator|->
name|col
argument_list|,
operator|(
name|int
operator|)
name|pda_p
operator|->
name|startSector
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|dstatus
argument_list|)
condition|)
block|{
comment|/* if the disk is inaccessible, mark the 				 * failure */
if|if
condition|(
name|parity
condition|)
name|asm_p
operator|->
name|numParityFailed
operator|++
expr_stmt|;
else|else
block|{
name|asm_p
operator|->
name|numDataFailed
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Do we really want this spewing 					 * out on the console? GO */
block|printf("DATA_FAILED!\n");
endif|#
directive|endif
block|}
name|asm_p
operator|->
name|failedPDAs
index|[
name|asm_p
operator|->
name|numFailedPDAs
index|]
operator|=
name|pda_p
expr_stmt|;
name|asm_p
operator|->
name|numFailedPDAs
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|switch (asm_p->numParityFailed + asm_p->numDataFailed) { 				case 1: 					asm_p->failedPDAs[0] = pda_p; 					break; 				case 2: 					asm_p->failedPDAs[1] = pda_p; 				default: 					break; 				}
endif|#
directive|endif
block|}
comment|/* the redirected access should never span a stripe unit boundary */
name|RF_ASSERT
argument_list|(
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|)
operator|==
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
name|raidPtr
operator|->
name|Layout
argument_list|,
name|pda_p
operator|->
name|raidAddress
operator|+
name|pda_p
operator|->
name|numSector
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda_p
operator|->
name|col
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

