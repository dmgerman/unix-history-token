begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_pq.c,v 1.7 2000/01/07 03:41:02 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Daniel Stodolsky  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * Code for RAID level 6 (P + Q) disk array architecture.  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagffwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegrd.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegwr.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_pqdeg.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_pq.h>
end_include

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_pFuncs
init|=
block|{
name|rf_RegularONPFunc
block|,
literal|"Regular Old-New P"
block|,
name|rf_SimpleONPFunc
block|,
literal|"Simple Old-New P"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_pRecoveryFuncs
init|=
block|{
name|rf_RecoveryPFunc
block|,
literal|"Recovery P Func"
block|,
name|rf_RecoveryPFunc
block|,
literal|"Recovery P Func"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|rf_RegularONPFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
name|rf_RegularXorFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    same as simpleONQ func, but the coefficient is always 1 */
end_comment

begin_function
name|int
name|rf_SimpleONPFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
name|rf_SimpleXorFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_RecoveryPFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
name|rf_RecoveryXorFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_RegularPFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
return|return
operator|(
name|rf_RegularXorFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_DECL_PQ
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_RAID6
operator|>
literal|0
operator|)
end_if

begin_function_decl
specifier|static
name|void
name|QDelta
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|obuf
parameter_list|,
name|char
modifier|*
name|nbuf
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|unsigned
name|char
name|coeff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rf_InvertQ
parameter_list|(
name|unsigned
name|long
modifier|*
name|qbuf
parameter_list|,
name|unsigned
name|long
modifier|*
name|abuf
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|unsigned
name|coeff
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_qFuncs
init|=
block|{
name|rf_RegularONQFunc
block|,
literal|"Regular Old-New Q"
block|,
name|rf_SimpleONQFunc
block|,
literal|"Simple Old-New Q"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_qRecoveryFuncs
init|=
block|{
name|rf_RecoveryQFunc
block|,
literal|"Recovery Q Func"
block|,
name|rf_RecoveryQFunc
block|,
literal|"Recovery Q Func"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RedFuncs_t
name|rf_pqRecoveryFuncs
init|=
block|{
name|rf_RecoveryPQFunc
block|,
literal|"Recovery PQ Func"
block|,
name|rf_RecoveryPQFunc
block|,
literal|"Recovery PQ Func"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rf_PQDagSelect
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_IoType_t
name|type
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_VoidFuncPtr
modifier|*
name|createFunc
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|unsigned
name|ndfail
init|=
name|asmap
operator|->
name|numDataFailed
decl_stmt|;
name|unsigned
name|npfail
init|=
name|asmap
operator|->
name|numParityFailed
decl_stmt|;
name|unsigned
name|ntfail
init|=
name|npfail
operator|+
name|ndfail
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntfail
operator|>
literal|2
condition|)
block|{
name|RF_ERRORMSG
argument_list|(
literal|"more than two disks failed in a single group!  Aborting I/O operation.\n"
argument_list|)
expr_stmt|;
comment|/* *infoFunc = */
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* ok, we can do this I/O */
if|if
condition|(
name|type
operator|==
name|RF_IO_TYPE_READ
condition|)
block|{
switch|switch
condition|(
name|ndfail
condition|)
block|{
case|case
literal|0
case|:
comment|/* fault free read */
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_CreateFaultFreeReadDAG
expr_stmt|;
comment|/* same as raid 5 */
break|break;
case|case
literal|1
case|:
comment|/* lost a single data unit */
comment|/* two cases: (1) parity is not lost. do a normal raid 			 * 5 reconstruct read. (2) parity is lost. do a 			 * reconstruct read using "q". */
if|if
condition|(
name|ntfail
operator|==
literal|2
condition|)
block|{
comment|/* also lost redundancy */
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_110_CreateReadDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_101_CreateReadDAG
expr_stmt|;
block|}
else|else
block|{
comment|/* P and Q are ok. But is there a failure in 				 * some unaccessed data unit? */
if|if
condition|(
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
operator|==
literal|2
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_200_CreateReadDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_100_CreateReadDAG
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* lost two data units */
comment|/* *infoFunc = PQOneTwo; */
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_200_CreateReadDAG
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|/* a write */
switch|switch
condition|(
name|ntfail
condition|)
block|{
case|case
literal|0
case|:
comment|/* fault free */
if|if
condition|(
name|rf_suppressLocksAndLargeWrites
operator|||
operator|(
operator|(
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|<=
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
operator|)
operator|&&
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|!=
literal|1
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|asmap
operator|->
name|qInfo
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|||
name|rf_CheckStripeForFailures
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
operator|)
condition|)
block|{
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQCreateSmallWriteDAG
expr_stmt|;
block|}
else|else
block|{
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQCreateLargeWriteDAG
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* single disk fault */
if|if
condition|(
name|npfail
operator|==
literal|1
condition|)
block|{
name|RF_ASSERT
argument_list|(
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
operator|)
operator|||
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
condition|)
block|{
comment|/* q died, treat like 										 * normal mode raid5 										 * write. */
if|if
condition|(
operator|(
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|<=
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
operator|)
operator|)
operator|||
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_001_CreateSmallWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_001_CreateLargeWriteDAG
expr_stmt|;
block|}
else|else
block|{
comment|/* parity died, small write only updating Q */
if|if
condition|(
operator|(
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|<=
operator|(
name|layoutPtr
operator|->
name|numDataCol
operator|/
literal|2
operator|)
operator|)
operator|||
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|==
literal|1
operator|)
operator|)
operator|||
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_010_CreateSmallWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_010_CreateLargeWriteDAG
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* data missing. Do a P reconstruct write if 				 * only a single data unit is lost in the 				 * stripe, otherwise a PQ reconstruct write. */
if|if
condition|(
name|rf_NumFailedDataUnitsInStripe
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|)
operator|==
literal|2
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_200_CreateWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_100_CreateWriteDAG
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* two disk faults */
switch|switch
condition|(
name|npfail
condition|)
block|{
case|case
literal|2
case|:
comment|/* both p and q dead */
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_011_CreateWriteDAG
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* either p or q and dead data */
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_DATA
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_PARITY
operator|)
operator|||
operator|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
operator|->
name|type
operator|==
name|RF_PDA_TYPE_Q
condition|)
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_101_CreateWriteDAG
expr_stmt|;
else|else
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_110_CreateWriteDAG
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* double data loss */
operator|*
name|createFunc
operator|=
operator|(
name|RF_VoidFuncPtr
operator|)
name|rf_PQ_200_CreateWriteDAG
expr_stmt|;
break|break;
block|}
break|break;
default|default:
comment|/* more than 2 disk faults */
operator|*
name|createFunc
operator|=
name|NULL
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*    Used as a stop gap info function */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void  PQOne(raidPtr, nSucc, nAnte, asmap) 	RF_Raid_t *raidPtr; 	int    *nSucc; 	int    *nAnte; 	RF_AccessStripeMap_t *asmap; { 	*nSucc = *nAnte = 1; }  static void  PQOneTwo(raidPtr, nSucc, nAnte, asmap) 	RF_Raid_t *raidPtr; 	int    *nSucc; 	int    *nAnte; 	RF_AccessStripeMap_t *asmap; { 	*nSucc = 1; 	*nAnte = 2; }
endif|#
directive|endif
end_endif

begin_macro
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_PQCreateLargeWriteDAG
argument_list|)
end_macro

begin_block
block|{
name|rf_CommonCreateLargeWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
literal|2
argument_list|,
name|rf_RegularPQFunc
argument_list|,
name|RF_FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|rf_RegularONQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|int
name|d
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|char
modifier|*
name|qbuf
decl_stmt|,
modifier|*
name|qpbuf
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|unsigned
name|long
name|coeff
decl_stmt|;
name|unsigned
name|secPerSU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|4
operator|*
name|d
operator|+
literal|3
operator|==
name|np
argument_list|)
expr_stmt|;
name|qbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|d
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
comment|/* q buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
index|]
operator|.
name|p
expr_stmt|;
name|obuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|new
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|d
operator|+
literal|1
operator|+
name|i
operator|)
index|]
operator|.
name|p
expr_stmt|;
name|nbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|d
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|new
operator|->
name|numSector
operator|==
name|old
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|new
operator|->
name|raidAddress
operator|==
name|old
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* the stripe unit within the stripe tells us the coefficient 		 * to use for the multiply. */
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|new
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column, then add 		 * one */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
name|qpbuf
operator|=
name|qbuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|startSector
operator|%
name|secPerSU
argument_list|)
expr_stmt|;
name|QDelta
argument_list|(
name|qpbuf
argument_list|,
name|obuf
argument_list|,
name|nbuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* call wake func explicitly since no 					 * I/O in this node */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    See the SimpleXORFunc for the difference between a simple and regular func.    These Q functions should be used for           new q = Q(data,old data,old q)     style updates and not for           q = ( new data, new data, .... )     computations.     The simple q takes 2(2d+1)+1 params, where d is the number    of stripes written. The order of params is    old data pda_0, old data buffer_0, old data pda_1, old data buffer_1, ... old data pda_d, old data buffer_d    [2d] old q pda_0, old q buffer    [2d_2] new data pda_0, new data buffer_0, ...                                    new data pda_d, new data buffer_d    raidPtr */
end_comment

begin_function
name|int
name|rf_SimpleONQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|int
name|d
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|char
modifier|*
name|qbuf
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|unsigned
name|long
name|coeff
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|4
operator|*
name|d
operator|+
literal|3
operator|==
name|np
argument_list|)
expr_stmt|;
name|qbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|d
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
comment|/* q buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
index|]
operator|.
name|p
expr_stmt|;
name|obuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|new
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|d
operator|+
literal|1
operator|+
name|i
operator|)
index|]
operator|.
name|p
expr_stmt|;
name|nbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
operator|(
name|d
operator|+
literal|1
operator|+
name|i
operator|)
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|new
operator|->
name|numSector
operator|==
name|old
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|new
operator|->
name|raidAddress
operator|==
name|old
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* the stripe unit within the stripe tells us the coefficient 		 * to use for the multiply. */
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|new
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column, then add 		 * one */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
name|QDelta
argument_list|(
name|qbuf
argument_list|,
name|obuf
argument_list|,
name|nbuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* call wake func explicitly since no 					 * I/O in this node */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_PQCreateSmallWriteDAG
argument_list|)
end_macro

begin_block
block|{
name|rf_CommonCreateSmallWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
operator|&
name|rf_pFuncs
argument_list|,
operator|&
name|rf_qFuncs
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
specifier|static
name|void
name|RegularQSubr
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|qbuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|RegularQSubr
parameter_list|(
name|node
parameter_list|,
name|qbuf
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|qbuf
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|int
name|d
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|unsigned
name|secPerSU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|qpbuf
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|old
decl_stmt|;
name|unsigned
name|long
name|coeff
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|2
operator|*
name|d
operator|+
literal|1
operator|==
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
index|]
operator|.
name|p
expr_stmt|;
name|obuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|old
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column, then add 		 * one */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
comment|/* the input buffers may not all be aligned with the start of 		 * the stripe. so shift by their sector offset within the 		 * stripe unit */
name|qpbuf
operator|=
name|qbuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|startSector
operator|%
name|secPerSU
argument_list|)
expr_stmt|;
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpbuf
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|obuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    used in degraded writes. */
end_comment

begin_function_decl
specifier|static
name|void
name|DegrQSubr
parameter_list|(
name|RF_DagNode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|DegrQSubr
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|int
name|d
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|unsigned
name|secPerSU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|char
modifier|*
name|qbuf
init|=
name|node
operator|->
name|results
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|qpbuf
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|old
decl_stmt|;
name|unsigned
name|long
name|coeff
decl_stmt|;
name|unsigned
name|fail_start
decl_stmt|;
name|int
name|j
decl_stmt|;
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|2
index|]
operator|.
name|p
expr_stmt|;
name|fail_start
operator|=
name|old
operator|->
name|startSector
operator|%
name|secPerSU
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|2
operator|)
operator|/
literal|2
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|2
operator|*
name|d
operator|+
literal|2
operator|==
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
index|]
operator|.
name|p
expr_stmt|;
name|obuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|old
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column, then add 		 * one */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
comment|/* the input buffers may not all be aligned with the start of 		 * the stripe. so shift by their sector offset within the 		 * stripe unit */
name|j
operator|=
name|old
operator|->
name|startSector
operator|%
name|secPerSU
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|j
operator|>=
name|fail_start
argument_list|)
expr_stmt|;
name|qpbuf
operator|=
name|qbuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|j
operator|-
name|fail_start
argument_list|)
expr_stmt|;
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpbuf
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|obuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    Called by large write code to compute the new parity and the new q.     structure of the params:     pda_0, buffer_0, pda_1 , buffer_1, ... , pda_d, buffer_d ( d = numDataCol    raidPtr     for a total of 2d+1 arguments.    The result buffers results[0], results[1] are the buffers for the p and q,    respectively.     We compute Q first, then compute P. The P calculation may try to reuse    one of the input buffers for its output, so if we computed P first, we would    corrupt the input for the q calculation. */
end_comment

begin_function
name|int
name|rf_RegularPQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RegularQSubr
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|results
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rf_RegularXorFunc
argument_list|(
name|node
argument_list|)
operator|)
return|;
comment|/* does the wakeup */
block|}
end_function

begin_function
name|int
name|rf_RegularQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
comment|/* Almost ... adjust Qsubr args */
name|RegularQSubr
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* call wake func explicitly since no 					 * I/O in this node */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    Called by singly degraded write code to compute the new parity and the new q.     structure of the params:     pda_0, buffer_0, pda_1 , buffer_1, ... , pda_d, buffer_d    failedPDA raidPtr     for a total of 2d+2 arguments.    The result buffers results[0], results[1] are the buffers for the parity and q,    respectively.     We compute Q first, then compute parity. The parity calculation may try to reuse    one of the input buffers for its output, so if we computed parity first, we would    corrupt the input for the q calculation.     We treat this identically to the regularPQ case, ignoring the failedPDA extra argument. */
end_comment

begin_function
name|void
name|rf_Degraded_100_PQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|np
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|DegrQSubr
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|rf_RecoveryXorFunc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    The two below are used when reading a stripe with a single lost data unit.    The parameters are     pda_0, buffer_0, .... pda_n, buffer_n, P pda, P buffer, failedPDA, raidPtr     and results[0] contains the data buffer. Which is originally zero-filled.  */
end_comment

begin_comment
comment|/* this Q func is used by the degraded-mode dag functions to recover lost data.  * the second-to-last parameter is the PDA for the failed portion of the access.  * the code here looks at this PDA and assumes that the xor target buffer is  * equal in size to the number of sectors in the failed PDA.  It then uses  * the other PDAs in the parameter list to determine where within the target  * buffer the corresponding data should be xored.  *  * Recall the basic equation is  *  *     Q = ( data_1 + 2 * data_2 ... + k * data_k  ) mod 256  *  * so to recover data_j we need  *  *    J data_j = (Q - data_1 - 2 data_2 ....- k* data_k) mod 256  *  * So the coefficient for each buffer is (255 - data_col), and j should be initialized by  * copying Q into it. Then we need to do a table lookup to convert to solve  *   data_j /= J  *  *  */
end_comment

begin_function
name|int
name|rf_RecoveryQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|(
name|RF_RaidLayout_t
operator|*
operator|)
operator|&
name|raidPtr
operator|->
name|Layout
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
init|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|2
index|]
operator|.
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|;
name|RF_RaidAddr_t
name|suoffset
decl_stmt|,
name|failedSUOffset
init|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|failedPDA
operator|->
name|startSector
argument_list|)
decl_stmt|;
name|char
modifier|*
name|srcbuf
decl_stmt|,
modifier|*
name|destbuf
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|unsigned
name|long
name|coeff
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* start by copying Q into the buffer */
name|bcopy
argument_list|(
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|3
index|]
operator|.
name|p
argument_list|,
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
operator|->
name|numSector
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|numParams
operator|-
literal|4
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|RF_ASSERT
argument_list|(
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
operator|!=
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pda
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
name|srcbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|suoffset
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|pda
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|destbuf
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|results
index|[
literal|0
index|]
operator|)
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|suoffset
operator|-
name|failedSUOffset
argument_list|)
expr_stmt|;
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|pda
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|destbuf
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|srcbuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
comment|/* Do the nasty inversion now */
name|coeff
operator|=
operator|(
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|failedPDA
operator|->
name|startSector
argument_list|)
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
name|rf_InvertQ
argument_list|(
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
name|node
operator|->
name|results
index|[
literal|0
index|]
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rf_RecoveryPQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|node
operator|->
name|numParams
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"raid%d: Recovery from PQ not implemented.\n"
argument_list|,
name|raidPtr
operator|->
name|raidid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    Degraded write Q subroutine.    Used when P is dead.    Large-write style Q computation.    Parameters     (pda,buf),(pda,buf),.....,(failedPDA,bufPtr),failedPDA,raidPtr.     We ignore failedPDA.     This is a "simple style" recovery func. */
end_comment

begin_function
name|void
name|rf_PQ_DegradedWriteQFunc
parameter_list|(
name|node
parameter_list|)
name|RF_DagNode_t
modifier|*
name|node
decl_stmt|;
block|{
name|int
name|np
init|=
name|node
operator|->
name|numParams
decl_stmt|;
name|int
name|d
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
operator|(
name|RF_Raid_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|1
index|]
operator|.
name|p
decl_stmt|;
name|unsigned
name|secPerSU
init|=
name|raidPtr
operator|->
name|Layout
operator|.
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
name|node
operator|->
name|dagHdr
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|char
modifier|*
name|qbuf
init|=
name|node
operator|->
name|results
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|qpbuf
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|old
decl_stmt|;
name|unsigned
name|long
name|coeff
decl_stmt|;
name|int
name|fail_start
decl_stmt|,
name|j
decl_stmt|;
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
name|np
operator|-
literal|2
index|]
operator|.
name|p
expr_stmt|;
name|fail_start
operator|=
name|old
operator|->
name|startSector
operator|%
name|secPerSU
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|np
operator|-
literal|2
operator|)
operator|/
literal|2
expr_stmt|;
name|RF_ASSERT
argument_list|(
literal|2
operator|*
name|d
operator|+
literal|2
operator|==
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|old
operator|=
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
index|]
operator|.
name|p
expr_stmt|;
name|obuf
operator|=
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|params
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|coeff
operator|=
name|rf_RaidAddressToStripeUnitID
argument_list|(
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
argument_list|,
name|old
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
comment|/* compute the data unit offset within the column, then add 		 * one */
name|coeff
operator|=
operator|(
name|coeff
operator|%
name|raidPtr
operator|->
name|Layout
operator|.
name|numDataCol
operator|)
expr_stmt|;
name|j
operator|=
name|old
operator|->
name|startSector
operator|%
name|secPerSU
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|j
operator|>=
name|fail_start
argument_list|)
expr_stmt|;
name|qpbuf
operator|=
name|qbuf
operator|+
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|j
operator|-
name|fail_start
argument_list|)
expr_stmt|;
name|rf_IncQ
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|qpbuf
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|obuf
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|old
operator|->
name|numSector
argument_list|)
argument_list|,
name|coeff
argument_list|)
expr_stmt|;
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|q_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_GenericWakeupFunc
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Q computations */
end_comment

begin_comment
comment|/*    coeff - colummn;     compute  dest ^= qfor[28-coeff][rn[coeff+1] a]     on 5-bit basis;    length in bytes; */
end_comment

begin_function
name|void
name|rf_IncQ
parameter_list|(
name|dest
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|,
name|coeff
parameter_list|)
name|unsigned
name|long
modifier|*
name|dest
decl_stmt|;
name|unsigned
name|long
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|unsigned
name|coeff
decl_stmt|;
block|{
name|unsigned
name|long
name|a
decl_stmt|,
name|d
decl_stmt|,
name|new
decl_stmt|;
name|unsigned
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|unsigned
name|int
modifier|*
name|q
init|=
operator|&
operator|(
name|rf_qfor
index|[
literal|28
operator|-
name|coeff
index|]
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|unsigned
name|r
init|=
name|rf_rn
index|[
name|coeff
operator|+
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|EXTRACT
parameter_list|(
name|a
parameter_list|,
name|i
parameter_list|)
value|((a>> (5L*i))& 0x1f)
define|#
directive|define
name|INSERT
parameter_list|(
name|a
parameter_list|,
name|i
parameter_list|)
value|(a<< (5L*i))
name|length
operator|/=
literal|8
expr_stmt|;
comment|/* 13 5 bit quants in a 64 bit word */
while|while
condition|(
name|length
condition|)
block|{
name|a
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|d
operator|=
operator|*
name|dest
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|^
name|r
expr_stmt|;
name|new
operator|=
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|1
argument_list|)
operator||
name|a1
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|3
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|2
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|5
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|4
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|5
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|6
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|5
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|#
directive|if
name|RF_LONGSHIFT
operator|>
literal|2
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|7
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|8
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|7
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|9
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|10
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|9
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|11
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|12
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|11
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_LONGSHIFT> 2 */
name|d
operator|^=
name|new
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|d
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    compute     dest ^= rf_qfor[28-coeff][rf_rn[coeff+1] (old^new) ]     on a five bit basis.    optimization: compute old ^ new on 64 bit basis.     length in bytes. */
end_comment

begin_function
specifier|static
name|void
name|QDelta
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|obuf
parameter_list|,
name|char
modifier|*
name|nbuf
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|unsigned
name|char
name|coeff
parameter_list|)
block|{
name|unsigned
name|long
name|a
decl_stmt|,
name|d
decl_stmt|,
name|new
decl_stmt|;
name|unsigned
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|unsigned
name|int
modifier|*
name|q
init|=
operator|&
operator|(
name|rf_qfor
index|[
literal|28
operator|-
name|coeff
index|]
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|unsigned
name|int
name|r
init|=
name|rf_rn
index|[
name|coeff
operator|+
literal|1
index|]
decl_stmt|;
name|r
operator|=
name|a1
operator|=
name|a2
operator|=
name|new
operator|=
name|d
operator|=
name|a
operator|=
literal|0
expr_stmt|;
comment|/* XXX for now... */
name|q
operator|=
name|NULL
expr_stmt|;
comment|/* XXX for now */
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* PQ in kernel currently not supported because the encoding/decoding 	 * table is not present */
name|bzero
argument_list|(
name|dest
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* KERNEL */
comment|/* this code probably doesn't work and should be rewritten  -wvcii */
comment|/* 13 5 bit quants in a 64 bit word */
name|length
operator|/=
literal|8
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|a
operator|=
operator|*
name|obuf
operator|++
expr_stmt|;
comment|/* XXX need to reorg to avoid cache conflicts */
name|a
operator|^=
operator|*
name|nbuf
operator|++
expr_stmt|;
name|d
operator|=
operator|*
name|dest
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|1
argument_list|)
operator||
name|a1
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|3
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|2
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|5
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|4
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|5
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|6
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|5
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|#
directive|if
name|RF_LONGSHIFT
operator|>
literal|2
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|7
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|8
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|7
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|9
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|10
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|9
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|11
argument_list|)
operator|^
name|r
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|12
argument_list|)
operator|^
name|r
expr_stmt|;
name|a1
operator|=
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|new
operator||
name|INSERT
argument_list|(
name|a1
argument_list|,
literal|11
argument_list|)
operator||
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_LONGSHIFT> 2 */
name|d
operator|^=
name|new
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
name|d
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _KERNEL */
block|}
end_function

begin_comment
comment|/*    recover columns a and b from the given p and q into    bufs abuf and bbuf. All bufs are word aligned.    Length is in bytes. */
end_comment

begin_comment
comment|/*  * XXX  *  * Everything about this seems wrong.  */
end_comment

begin_function
name|void
name|rf_PQ_recover
parameter_list|(
name|pbuf
parameter_list|,
name|qbuf
parameter_list|,
name|abuf
parameter_list|,
name|bbuf
parameter_list|,
name|length
parameter_list|,
name|coeff_a
parameter_list|,
name|coeff_b
parameter_list|)
name|unsigned
name|long
modifier|*
name|pbuf
decl_stmt|;
name|unsigned
name|long
modifier|*
name|qbuf
decl_stmt|;
name|unsigned
name|long
modifier|*
name|abuf
decl_stmt|;
name|unsigned
name|long
modifier|*
name|bbuf
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|unsigned
name|coeff_a
decl_stmt|;
name|unsigned
name|coeff_b
decl_stmt|;
block|{
name|unsigned
name|long
name|p
decl_stmt|,
name|q
decl_stmt|,
name|a
decl_stmt|,
name|a0
decl_stmt|,
name|a1
decl_stmt|;
name|int
name|col
init|=
operator|(
literal|29
operator|*
name|coeff_a
operator|)
operator|+
name|coeff_b
decl_stmt|;
name|unsigned
name|char
modifier|*
name|q0
init|=
operator|&
operator|(
name|rf_qinv
index|[
name|col
index|]
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|length
operator|/=
literal|8
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|p
operator|=
operator|*
name|pbuf
operator|++
expr_stmt|;
name|q
operator|=
operator|*
name|qbuf
operator|++
expr_stmt|;
name|a0
operator|=
name|EXTRACT
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a
operator|=
name|q0
index|[
name|a0
operator|<<
literal|5
operator||
name|a1
index|]
expr_stmt|;
define|#
directive|define
name|MF
parameter_list|(
name|i
parameter_list|)
define|\
value|a0 = EXTRACT(p,i); \       a1 = EXTRACT(q,i); \       a  = a | INSERT(q0[a0<<5 | a1],i)
name|MF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MF
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|MF
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|MF
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|MF
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|MF
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|MF(7); 		MF(8); 		MF(9); 		MF(10); 		MF(11); 		MF(12);
endif|#
directive|endif
comment|/* 0 */
operator|*
name|abuf
operator|++
operator|=
name|a
expr_stmt|;
operator|*
name|bbuf
operator|++
operator|=
name|a
operator|^
name|p
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    Lost parity and a data column. Recover that data column.    Assume col coeff is lost. Let q the contents of Q after    all surviving data columns have been q-xored out of it.    Then we have the equation     q[28-coeff][a_i ^ r_i+1] = q     but q is cyclic with period 31.    So q[3+coeff][q[28-coeff][a_i ^ r_{i+1}]] =       q[31][a_i ^ r_{i+1}] = a_i ^ r_{i+1} .     so a_i = r_{coeff+1} ^ q[3+coeff][q]     The routine is passed q buffer and the buffer    the data is to be recoverd into. They can be the same. */
end_comment

begin_function
specifier|static
name|void
name|rf_InvertQ
parameter_list|(
name|unsigned
name|long
modifier|*
name|qbuf
parameter_list|,
name|unsigned
name|long
modifier|*
name|abuf
parameter_list|,
name|unsigned
name|length
parameter_list|,
name|unsigned
name|coeff
parameter_list|)
block|{
name|unsigned
name|long
name|a
decl_stmt|,
name|new
decl_stmt|;
name|unsigned
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|unsigned
name|int
modifier|*
name|q
init|=
operator|&
operator|(
name|rf_qfor
index|[
literal|3
operator|+
name|coeff
index|]
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|unsigned
name|r
init|=
name|rf_rn
index|[
name|coeff
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 13 5 bit quants in a 64 bit word */
name|length
operator|/=
literal|8
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|a
operator|=
operator|*
name|qbuf
operator|++
expr_stmt|;
name|a1
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a2
operator|=
name|EXTRACT
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|a1
operator|=
name|r
operator|^
name|q
index|[
name|a1
index|]
expr_stmt|;
name|a2
operator|=
name|r
operator|^
name|q
index|[
name|a2
index|]
expr_stmt|;
name|new
operator|=
name|INSERT
argument_list|(
name|a2
argument_list|,
literal|1
argument_list|)
operator||
name|a1
expr_stmt|;
define|#
directive|define
name|M
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
define|\
value|a1 = EXTRACT(a,i); \       a2 = EXTRACT(a,j); \       a1 = r ^ q[a1]; \       a2 = r ^ q[a2]; \       new = new | INSERT(a1,i) | INSERT(a2,j)
name|M
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|M
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|M
argument_list|(
literal|5
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|#
directive|if
name|RF_LONGSHIFT
operator|>
literal|2
name|M
argument_list|(
literal|7
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|M
argument_list|(
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|M
argument_list|(
literal|11
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RF_LONGSHIFT> 2 */
operator|*
name|abuf
operator|++
operator|=
name|new
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_DECL_PQ> 0) || 				 * (RF_INCLUDE_RAID6> 0) */
end_comment

end_unit

