begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_memchunk.c,v 1.4 1999/08/13 03:41:56 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*********************************************************************************  * rf_memchunk.c  *  * experimental code.  I've found that the malloc and free calls in the DAG  * creation code are very expensive.  Since for any given workload the DAGs  * created for different accesses are likely to be similar to each other, the  * amount of memory used for any given DAG data structure is likely to be one  * of a small number of values.  For example, in UNIX, all reads and writes will  * be less than 8k and will not span stripe unit boundaries.  Thus in the absence  * of failure, the only DAGs that will ever get created are single-node reads  * and single-stripe-unit atomic read-modify-writes.  So, I'm very likely to  * be continually asking for chunks of memory equal to the sizes of these two  * DAGs.  *  * This leads to the idea of holding on to these chunks of memory when the DAG is  * freed and then, when a new DAG is created, trying to find such a chunk before  * calling malloc.  *  * the "chunk list" is a list of lists.  Each header node contains a size value  * and a pointer to a list of chunk descriptors, each of which holds a pointer  * to a chunk of memory of the indicated size.  *  * There is currently no way to purge memory out of the chunk list.  My  * initial thought on this is to have a low-priority thread that wakes up every  * 1 or 2 seconds, purges all the chunks with low reuse counts, and sets all  * the reuse counts to zero.  *  * This whole idea may be bad, since malloc may be able to do this more efficiently.  * It's worth a try, though, and it can be turned off by setting useMemChunks to 0.  *  ********************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_options.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_shutdown.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|RF_ChunkHdr_s
name|RF_ChunkHdr_t
typedef|;
end_typedef

begin_struct
struct|struct
name|RF_ChunkHdr_s
block|{
name|int
name|size
decl_stmt|;
name|RF_ChunkDesc_t
modifier|*
name|list
decl_stmt|;
name|RF_ChunkHdr_t
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|RF_ChunkHdr_t
modifier|*
name|chunklist
decl_stmt|,
modifier|*
name|chunk_hdr_free_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RF_ChunkDesc_t
modifier|*
name|chunk_desc_free_list
decl_stmt|;
end_decl_stmt

begin_macro
name|RF_DECLARE_STATIC_MUTEX
argument_list|(
argument|chunkmutex
argument_list|)
end_macro

begin_function_decl
specifier|static
name|void
name|rf_ShutdownMemChunk
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RF_ChunkDesc_t
modifier|*
name|NewMemChunk
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rf_ShutdownMemChunk
parameter_list|(
name|ignored
parameter_list|)
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
name|RF_ChunkDesc_t
modifier|*
name|pt
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|RF_ChunkHdr_t
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|ht
decl_stmt|;
if|if
condition|(
name|rf_memChunkDebug
condition|)
name|printf
argument_list|(
literal|"Chunklist:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hdr
operator|=
name|chunklist
init|;
name|hdr
condition|;
control|)
block|{
for|for
control|(
name|p
operator|=
name|hdr
operator|->
name|list
init|;
name|p
condition|;
control|)
block|{
if|if
condition|(
name|rf_memChunkDebug
condition|)
name|printf
argument_list|(
literal|"Size %d reuse count %d\n"
argument_list|,
name|p
operator|->
name|size
argument_list|,
name|p
operator|->
name|reuse_count
argument_list|)
expr_stmt|;
name|pt
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|RF_Free
argument_list|(
name|pt
operator|->
name|buf
argument_list|,
name|pt
operator|->
name|size
argument_list|)
expr_stmt|;
name|RF_Free
argument_list|(
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ht
operator|=
name|hdr
expr_stmt|;
name|hdr
operator|=
name|hdr
operator|->
name|next
expr_stmt|;
name|RF_Free
argument_list|(
name|ht
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ht
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rf_mutex_destroy
argument_list|(
operator|&
name|chunkmutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_ConfigureMemChunk
parameter_list|(
name|listp
parameter_list|)
name|RF_ShutdownList_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|chunklist
operator|=
name|NULL
expr_stmt|;
name|chunk_hdr_free_list
operator|=
name|NULL
expr_stmt|;
name|chunk_desc_free_list
operator|=
name|NULL
expr_stmt|;
name|rc
operator|=
name|rf_mutex_init
argument_list|(
operator|&
name|chunkmutex
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to init mutex file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|rf_ShutdownCreate
argument_list|(
name|listp
argument_list|,
name|rf_ShutdownMemChunk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|RF_ERRORMSG3
argument_list|(
literal|"Unable to add to shutdown list file %s line %d rc=%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rf_mutex_destroy
argument_list|(
operator|&
name|chunkmutex
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* called to get a chunk descriptor for a newly-allocated chunk of memory  * MUTEX MUST BE LOCKED  *  * free list is not currently used  */
end_comment

begin_function
specifier|static
name|RF_ChunkDesc_t
modifier|*
name|NewMemChunk
parameter_list|(
name|size
parameter_list|,
name|buf
parameter_list|)
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|RF_ChunkDesc_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|chunk_desc_free_list
condition|)
block|{
name|p
operator|=
name|chunk_desc_free_list
expr_stmt|;
name|chunk_desc_free_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
name|RF_Malloc
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ChunkDesc_t
argument_list|)
argument_list|,
operator|(
name|RF_ChunkDesc_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|p
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|reuse_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* looks for a chunk of memory of acceptable size.  If none, allocates one and returns  * a chunk descriptor for it, but does not install anything in the list.  This is done  * when the chunk is released.  */
end_comment

begin_function
name|RF_ChunkDesc_t
modifier|*
name|rf_GetMemChunk
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|RF_ChunkHdr_t
modifier|*
name|hdr
init|=
name|chunklist
decl_stmt|;
name|RF_ChunkDesc_t
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|chunkmutex
argument_list|)
expr_stmt|;
for|for
control|(
name|hdr
operator|=
name|chunklist
init|;
name|hdr
condition|;
name|hdr
operator|=
name|hdr
operator|->
name|next
control|)
if|if
condition|(
name|hdr
operator|->
name|size
operator|>=
name|size
condition|)
block|{
name|p
operator|=
name|hdr
operator|->
name|list
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|hdr
operator|->
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|reuse_count
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|RF_Malloc
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|NewMemChunk
argument_list|(
name|size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|chunkmutex
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
name|p
operator|->
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rf_ReleaseMemChunk
parameter_list|(
name|chunk
parameter_list|)
name|RF_ChunkDesc_t
modifier|*
name|chunk
decl_stmt|;
block|{
name|RF_ChunkHdr_t
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|ht
init|=
name|NULL
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|chunkmutex
argument_list|)
expr_stmt|;
for|for
control|(
name|hdr
operator|=
name|chunklist
init|;
name|hdr
operator|&&
name|hdr
operator|->
name|size
operator|<
name|chunk
operator|->
name|size
condition|;
name|ht
operator|=
name|hdr
operator|,
name|hdr
operator|=
name|hdr
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|hdr
operator|&&
name|hdr
operator|->
name|size
operator|==
name|chunk
operator|->
name|size
condition|)
block|{
name|chunk
operator|->
name|next
operator|=
name|hdr
operator|->
name|list
expr_stmt|;
name|hdr
operator|->
name|list
operator|=
name|chunk
expr_stmt|;
block|}
else|else
block|{
name|RF_Malloc
argument_list|(
name|new
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_ChunkHdr_t
argument_list|)
argument_list|,
operator|(
name|RF_ChunkHdr_t
operator|*
operator|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|size
operator|=
name|chunk
operator|->
name|size
expr_stmt|;
name|new
operator|->
name|list
operator|=
name|chunk
expr_stmt|;
name|chunk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ht
condition|)
block|{
name|new
operator|->
name|next
operator|=
name|ht
operator|->
name|next
expr_stmt|;
name|ht
operator|->
name|next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|next
operator|=
name|hdr
expr_stmt|;
name|chunklist
operator|=
name|new
expr_stmt|;
block|}
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|chunkmutex
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

