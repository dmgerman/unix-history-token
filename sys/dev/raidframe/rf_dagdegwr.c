begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: rf_dagdegwr.c,v 1.6 2001/01/26 04:05:08 oster Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, Daniel Stodolsky, William V. Courtright II  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * rf_dagdegwr.c  *  * code for creating degraded write DAGs  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/raidframe/rf_types.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagfuncs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_debugMem.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_memchunk.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagdegwr.h>
end_include

begin_comment
comment|/******************************************************************************  *  * General comments on DAG creation:  *  * All DAGs in this file use roll-away error recovery.  Each DAG has a single  * commit node, usually called "Cmt."  If an error occurs before the Cmt node  * is reached, the execution engine will halt forward execution and work  * backward through the graph, executing the undo functions.  Assuming that  * each node in the graph prior to the Cmt node are undoable and atomic - or -  * does not make changes to permanent state, the graph will fail atomically.  * If an error occurs after the Cmt node executes, the engine will roll-forward  * through the graph, blindly executing nodes until it reaches the end.  * If a graph reaches the end, it is assumed to have completed successfully.  *  * A graph has only 1 Cmt node.  *  */
end_comment

begin_comment
comment|/******************************************************************************  *  * The following wrappers map the standard DAG creation interface to the  * DAG creation routines.  Additionally, these wrappers enable experimentation  * with new DAG structures by providing an extra level of indirection, allowing  * the DAG creation routines to be replaced at this single point.  */
end_comment

begin_expr_stmt
specifier|static
name|RF_CREATE_DAG_FUNC_DECL
argument_list|(
argument|rf_CreateSimpleDegradedWriteDAG
argument_list|)
block|{
name|rf_CommonCreateSimpleDegradedWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
literal|1
argument_list|,
name|rf_RecoveryXorFunc
argument_list|,
name|RF_TRUE
argument_list|)
block|; }
name|void
name|rf_CreateDegradedWriteDAG
argument_list|(
argument|raidPtr
argument_list|,
argument|asmap
argument_list|,
argument|dag_h
argument_list|,
argument|bp
argument_list|,
argument|flags
argument_list|,
argument|allocList
argument_list|)
name|RF_Raid_t
operator|*
name|raidPtr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_AllocListElem_t
modifier|*
name|allocList
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
decl_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"DegradedWriteDAG"
expr_stmt|;
comment|/* if the access writes only a portion of the failed unit, and also 	 * writes some portion of at least one surviving unit, we create two 	 * DAGs, one for the failed component and one for the non-failed 	 * component, and do them sequentially.  Note that the fact that we're 	 * accessing only a portion of the failed unit indicates that the 	 * access either starts or ends in the failed unit, and hence we need 	 * create only two dags.  This is inefficient in that the same data or 	 * parity can get read and written twice using this structure.  I need 	 * to fix this to do the access all at once. */
name|RF_ASSERT
argument_list|(
operator|!
operator|(
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|!=
literal|1
operator|&&
name|failedPDA
operator|->
name|numSector
operator|!=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
operator|)
argument_list|)
expr_stmt|;
name|rf_CreateSimpleDegradedWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  *  * DAG creation code begins here  */
end_comment

begin_comment
comment|/******************************************************************************  *  * CommonCreateSimpleDegradedWriteDAG -- creates a DAG to do a degraded-mode  * write, which is as follows  *  *                                        / {Wnq} --\  * hdr -> blockNode ->  Rod -> Xor -> Cmt -> Wnp ----> unblock -> term  *                  \  {Rod} /            \  Wnd ---/  *                                        \ {Wnd} -/  *  * commit nodes: Xor, Wnd  *  * IMPORTANT:  * This DAG generator does not work for double-degraded archs since it does not  * generate Q  *  * This dag is essentially identical to the large-write dag, except that the  * write to the failed data unit is suppressed.  *  * IMPORTANT:  this dag does not work in the case where the access writes only  * a portion of the failed unit, and also writes some portion of at least one  * surviving SU.  this case is handled in CreateDegradedWriteDAG above.  *  * The block& unblock nodes are leftovers from a previous version.  They  * do nothing, but I haven't deleted them because it would be a tremendous  * effort to put them back in.  *  * This dag is used whenever a one of the data units in a write has failed.  * If it is the parity unit that failed, the nonredundant write dag (below)  * is used.  *****************************************************************************/
end_comment

begin_decl_stmt
name|void
name|rf_CommonCreateSimpleDegradedWriteDAG
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|dag_h
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|,
name|allocList
argument_list|,
name|nfaults
argument_list|,
name|redFunc
argument_list|,
name|allowBufferRecycle
argument_list|)
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_AccessStripeMap_t
modifier|*
name|asmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_RaidAccessFlags_t
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RF_AllocListElem_t
modifier|*
name|allocList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfaults
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|redFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|allowBufferRecycle
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nNodes
decl_stmt|,
name|nRrdNodes
decl_stmt|,
name|nWndNodes
decl_stmt|,
name|nXorBufs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|paramNum
decl_stmt|,
name|rdnodesFaked
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|wnpNode
decl_stmt|,
modifier|*
name|wnqNode
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wndNodes
decl_stmt|,
modifier|*
name|rrdNodes
decl_stmt|,
modifier|*
name|xorNode
decl_stmt|,
modifier|*
name|commitNode
decl_stmt|;
name|RF_SectorCount_t
name|sectorsPerSU
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|char
modifier|*
name|xorTargetBuf
init|=
name|NULL
decl_stmt|;
comment|/* the target buffer for the XOR 					 * operation */
name|char
modifier|*
name|overlappingPDAs
decl_stmt|;
comment|/* a temporary array of flags */
name|RF_AccessStripeMapHeader_t
modifier|*
name|new_asm_h
index|[
literal|2
index|]
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|parityPDA
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|failedPDA
decl_stmt|;
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
decl_stmt|;
name|layoutPtr
operator|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
expr_stmt|;
name|parityStripeID
operator|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
expr_stmt|;
name|sectorsPerSU
operator|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
expr_stmt|;
comment|/* failedPDA points to the pda within the asm that targets the failed 	 * disk */
name|failedPDA
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|rf_dagDebug
condition|)
name|printf
argument_list|(
literal|"[Creating degraded-write DAG]\n"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"SimpleDegradedWriteDAG"
expr_stmt|;
comment|/*          * Generate two ASMs identifying the surviving data          * we need in order to recover the lost data.          */
comment|/* overlappingPDAs array must be zero'd */
name|RF_Calloc
argument_list|(
name|overlappingPDAs
argument_list|,
name|asmap
operator|->
name|numStripeUnitsAccessed
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|rf_GenerateFailedAccessASMs
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
name|failedPDA
argument_list|,
name|dag_h
argument_list|,
name|new_asm_h
argument_list|,
operator|&
name|nXorBufs
argument_list|,
name|NULL
argument_list|,
name|overlappingPDAs
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/* create all the nodes at once */
name|nWndNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|-
literal|1
expr_stmt|;
comment|/* no access is 							 * generated for the 							 * failed pda */
name|nRrdNodes
operator|=
operator|(
operator|(
name|new_asm_h
index|[
literal|0
index|]
operator|)
condition|?
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|new_asm_h
index|[
literal|1
index|]
operator|)
condition|?
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
else|:
literal|0
operator|)
expr_stmt|;
comment|/*          * XXX          *          * There's a bug with a complete stripe overwrite- that means 0 reads          * of old data, and the rest of the DAG generation code doesn't like          * that. A release is coming, and I don't wanna risk breaking a critical          * DAG generator, so here's what I'm gonna do- if there's no read nodes,          * I'm gonna fake there being a read node, and I'm gonna swap in a          * no-op node in its place (to make all the link-up code happy).          * This should be fixed at some point.  --jimz          */
if|if
condition|(
name|nRrdNodes
operator|==
literal|0
condition|)
block|{
name|nRrdNodes
operator|=
literal|1
expr_stmt|;
name|rdnodesFaked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rdnodesFaked
operator|=
literal|0
expr_stmt|;
block|}
comment|/* lock, unlock, xor, Wnd, Rrd, W(nfaults) */
name|nNodes
operator|=
literal|5
operator|+
name|nfaults
operator|+
name|nWndNodes
operator|+
name|nRrdNodes
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|blockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|commitNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|unblockNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|termNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|xorNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|wnpNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|wndNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nWndNodes
expr_stmt|;
name|rrdNodes
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|nRrdNodes
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|wnqNode
operator|=
operator|&
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wnqNode
operator|=
name|NULL
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|i
operator|==
name|nNodes
argument_list|)
expr_stmt|;
comment|/* this dag can not commit until all rrd and xor Nodes have completed */
name|dag_h
operator|->
name|numCommitNodes
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|numCommits
operator|=
literal|0
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|nRrdNodes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nRrdNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|commitNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_TRUE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nWndNodes
operator|+
name|nfaults
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Cmt"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nWndNodes
operator|+
name|nfaults
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|rf_InitNode
argument_list|(
name|xorNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|redFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nRrdNodes
argument_list|,
literal|2
operator|*
name|nXorBufs
operator|+
literal|2
argument_list|,
name|nfaults
argument_list|,
name|dag_h
argument_list|,
literal|"Xrc"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
comment|/*          * Fill in the Rrd nodes. If any of the rrd buffers are the same size as          * the failed buffer, save a pointer to it so we can use it as the target          * of the XOR. The pdas in the rrd nodes have been range-restricted, so if          * a buffer is the same size as the failed buffer, it must also be at the          * same alignment within the SU.          */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new_asm_h
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pda
operator|=
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|i
operator|<
name|new_asm_h
index|[
literal|0
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rrdNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rrd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* i now equals the number of stripe units accessed in new_asm_h[0] */
if|if
condition|(
name|new_asm_h
index|[
literal|1
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|pda
operator|=
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|physInfo
init|;
name|j
operator|<
name|new_asm_h
index|[
literal|1
index|]
operator|->
name|stripeMap
operator|->
name|numStripeUnitsAccessed
condition|;
name|j
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|rf_InitNode
argument_list|(
operator|&
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskReadFunc
argument_list|,
name|rf_DiskReadUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Rrd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|rrdNodes
index|[
name|i
operator|+
name|j
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|allowBufferRecycle
operator|&&
operator|(
name|pda
operator|->
name|numSector
operator|==
name|failedPDA
operator|->
name|numSector
operator|)
condition|)
name|xorTargetBuf
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdnodesFaked
condition|)
block|{
comment|/* 	         * This is where we'll init that fake noop read node 	         * (XXX should the wakeup func be different?) 	         */
name|rf_InitNode
argument_list|(
operator|&
name|rrdNodes
index|[
literal|0
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"RrN"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
comment|/*          * Make a PDA for the parity unit.  The parity PDA should start at          * the same offset into the SU as the failed PDA.          */
comment|/* Danner comment: I don't think this copy is really necessary. We are 	 * in one of two cases here. (1) The entire failed unit is written. 	 * Then asmap->parityInfo will describe the entire parity. (2) We are 	 * only writing a subset of the failed unit and nothing else. Then the 	 * asmap->parityInfo describes the failed unit and the copy can also 	 * be avoided. */
name|RF_MallocAndAdd
argument_list|(
name|parityPDA
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|parityPDA
operator|->
name|row
operator|=
name|asmap
operator|->
name|parityInfo
operator|->
name|row
expr_stmt|;
name|parityPDA
operator|->
name|col
operator|=
name|asmap
operator|->
name|parityInfo
operator|->
name|col
expr_stmt|;
name|parityPDA
operator|->
name|startSector
operator|=
operator|(
operator|(
name|asmap
operator|->
name|parityInfo
operator|->
name|startSector
operator|/
name|sectorsPerSU
operator|)
operator|*
name|sectorsPerSU
operator|)
operator|+
operator|(
name|failedPDA
operator|->
name|startSector
operator|%
name|sectorsPerSU
operator|)
expr_stmt|;
name|parityPDA
operator|->
name|numSector
operator|=
name|failedPDA
operator|->
name|numSector
expr_stmt|;
if|if
condition|(
operator|!
name|xorTargetBuf
condition|)
block|{
name|RF_CallocAndAdd
argument_list|(
name|xorTargetBuf
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
block|}
comment|/* init the Wnp node */
name|rf_InitNode
argument_list|(
name|wnpNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnp"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|parityPDA
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorTargetBuf
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wnpNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
comment|/* fill in the Wnq Node */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
block|{
name|RF_MallocAndAdd
argument_list|(
name|parityPDA
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|parityPDA
operator|->
name|row
operator|=
name|asmap
operator|->
name|qInfo
operator|->
name|row
expr_stmt|;
name|parityPDA
operator|->
name|col
operator|=
name|asmap
operator|->
name|qInfo
operator|->
name|col
expr_stmt|;
name|parityPDA
operator|->
name|startSector
operator|=
operator|(
operator|(
name|asmap
operator|->
name|qInfo
operator|->
name|startSector
operator|/
name|sectorsPerSU
operator|)
operator|*
name|sectorsPerSU
operator|)
operator|+
operator|(
name|failedPDA
operator|->
name|startSector
operator|%
name|sectorsPerSU
operator|)
expr_stmt|;
name|parityPDA
operator|->
name|numSector
operator|=
name|failedPDA
operator|->
name|numSector
expr_stmt|;
name|rf_InitNode
argument_list|(
name|wnqNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnq"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|parityPDA
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|xorNode
operator|->
name|results
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|xorNode
operator|->
name|results
index|[
literal|1
index|]
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wnqNode
operator|->
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fill in the Wnd nodes */
for|for
control|(
name|pda
operator|=
name|asmap
operator|->
name|physInfo
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pda
operator|==
name|failedPDA
condition|)
block|{
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
name|rf_InitNode
argument_list|(
operator|&
name|wndNodes
index|[
name|i
index|]
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_DiskWriteFunc
argument_list|,
name|rf_DiskWriteUndoFunc
argument_list|,
name|rf_GenericWakeupFunc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Wnd"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|.
name|v
operator|=
name|parityStripeID
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|.
name|v
operator|=
name|RF_CREATE_PARAM3
argument_list|(
name|RF_IO_NORMAL_PRIORITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|which_ru
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the results of the xor node */
name|xorNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|xorTargetBuf
expr_stmt|;
comment|/* fill in the params of the xor node */
name|paramNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdnodesFaked
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* all the Rrd nodes need to be xored together */
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|=
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|=
name|rrdNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* any Wnd nodes that overlap the failed access need to be 		 * xored in */
if|if
condition|(
name|overlappingPDAs
index|[
name|i
index|]
condition|)
block|{
name|RF_MallocAndAdd
argument_list|(
name|pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wndNodes
index|[
name|i
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pda
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|rf_RangeRestrictPDA
argument_list|(
name|raidPtr
argument_list|,
name|failedPDA
argument_list|,
name|pda
argument_list|,
name|RF_RESTRICT_DOBUFFER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|pda
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|pda
operator|->
name|bufPtr
expr_stmt|;
block|}
block|}
name|RF_Free
argument_list|(
name|overlappingPDAs
argument_list|,
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * Install the failed PDA into the xor param list so that the          * new data gets xor'd in.          */
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|failedPDA
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|failedPDA
operator|->
name|bufPtr
expr_stmt|;
comment|/*          * The last 2 params to the recovery xor node are always the failed          * PDA and the raidPtr. install the failedPDA even though we have just          * done so above. This allows us to use the same XOR function for both          * degraded reads and degraded writes.          */
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|failedPDA
expr_stmt|;
name|xorNode
operator|->
name|params
index|[
name|paramNum
operator|++
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|paramNum
operator|==
literal|2
operator|*
name|nXorBufs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/*          * Code to link nodes begins here          */
comment|/* link header to block node */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numAntecedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
comment|/* link block node to rd nodes */
name|RF_ASSERT
argument_list|(
name|blockNode
operator|->
name|numSuccedents
operator|==
name|nRrdNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rrdNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|rrdNodes
index|[
name|i
index|]
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link read nodes to xor node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numAntecedents
operator|==
name|nRrdNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|rrdNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rrdNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|xorNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|rrdNodes
index|[
name|i
index|]
expr_stmt|;
name|xorNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_trueData
expr_stmt|;
block|}
comment|/* link xor node to commit node */
name|RF_ASSERT
argument_list|(
name|xorNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|xorNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|commitNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|xorNode
expr_stmt|;
name|commitNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* link commit node to wnd nodes */
name|RF_ASSERT
argument_list|(
name|commitNode
operator|->
name|numSuccedents
operator|==
name|nfaults
operator|+
name|nWndNodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
index|[
name|i
index|]
operator|.
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link the commit node to wnp, wnq nodes */
name|RF_ASSERT
argument_list|(
name|wnpNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|nWndNodes
index|]
operator|=
name|wnpNode
expr_stmt|;
name|wnpNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wnpNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|wnqNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|commitNode
operator|->
name|succedents
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|wnqNode
expr_stmt|;
name|wnqNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|commitNode
expr_stmt|;
name|wnqNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link write new data nodes to unblock node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numAntecedents
operator|==
operator|(
name|nWndNodes
operator|+
name|nfaults
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWndNodes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|wndNodes
index|[
name|i
index|]
operator|.
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wndNodes
index|[
name|i
index|]
operator|.
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
operator|&
name|wndNodes
index|[
name|i
index|]
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link write new parity node to unblock node */
name|RF_ASSERT
argument_list|(
name|wnpNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wnpNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|nWndNodes
index|]
operator|=
name|wnpNode
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|nWndNodes
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* link write new q node to unblock node */
if|if
condition|(
name|nfaults
operator|==
literal|2
condition|)
block|{
name|RF_ASSERT
argument_list|(
name|wnqNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|wnqNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|unblockNode
operator|->
name|antecedents
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|wnqNode
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|nWndNodes
operator|+
literal|1
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
comment|/* link unblock node to term node */
name|RF_ASSERT
argument_list|(
name|unblockNode
operator|->
name|numSuccedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numAntecedents
operator|==
literal|1
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|termNode
operator|->
name|numSuccedents
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|CONS_PDA
parameter_list|(
define|if,start,num) \   pda_p->row = asmap->if->row;    pda_p->col = asmap->if->col; \   pda_p->startSector = ((asmap->if->startSector / secPerSU) * secPerSU) + start; \   pda_p->numSector = num; \   pda_p->next = NULL; \   RF_MallocAndAdd(pda_p->bufPtr,rf_RaidAddressToByte(raidPtr,num),(char *), allocList)
end_define

begin_if
if|#
directive|if
operator|(
name|RF_INCLUDE_PQ
operator|>
literal|0
operator|)
operator|||
operator|(
name|RF_INCLUDE_EVENODD
operator|>
literal|0
operator|)
end_if

begin_function
name|void
name|rf_WriteGenerateFailedAccessASMs
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|pdap
parameter_list|,
name|int
modifier|*
name|nNodep
parameter_list|,
name|RF_PhysDiskAddr_t
modifier|*
modifier|*
name|pqpdap
parameter_list|,
name|int
modifier|*
name|nPQNodep
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|int
name|PDAPerDisk
decl_stmt|,
name|i
decl_stmt|;
name|RF_SectorCount_t
name|secPerSU
init|=
name|layoutPtr
operator|->
name|sectorsPerStripeUnit
decl_stmt|;
name|int
name|numDataCol
init|=
name|layoutPtr
operator|->
name|numDataCol
decl_stmt|;
name|int
name|state
decl_stmt|;
name|unsigned
name|napdas
decl_stmt|;
name|RF_SectorNum_t
name|fone_start
decl_stmt|,
name|fone_end
decl_stmt|,
name|ftwo_start
init|=
literal|0
decl_stmt|,
name|ftwo_end
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|fone
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|ftwo
init|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|1
index|]
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda_p
decl_stmt|;
name|RF_RaidAddr_t
name|sosAddr
decl_stmt|;
comment|/* determine how many pda's we will have to generate per unaccess 	 * stripe. If there is only one failed data unit, it is one; if two, 	 * possibly two, depending wether they overlap. */
name|fone_start
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|fone
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|fone_end
operator|=
name|fone_start
operator|+
name|fone
operator|->
name|numSector
expr_stmt|;
if|if
condition|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
condition|)
block|{
name|PDAPerDisk
operator|=
literal|1
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
operator|*
name|pqpdap
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|=
operator|*
name|pqpdap
expr_stmt|;
comment|/* build p */
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
comment|/* build q */
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
block|}
else|else
block|{
name|ftwo_start
operator|=
name|rf_StripeUnitOffset
argument_list|(
name|layoutPtr
argument_list|,
name|ftwo
operator|->
name|startSector
argument_list|)
expr_stmt|;
name|ftwo_end
operator|=
name|ftwo_start
operator|+
name|ftwo
operator|->
name|numSector
expr_stmt|;
if|if
condition|(
name|fone
operator|->
name|numSector
operator|+
name|ftwo
operator|->
name|numSector
operator|>
name|secPerSU
condition|)
block|{
name|PDAPerDisk
operator|=
literal|1
expr_stmt|;
name|state
operator|=
literal|2
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
operator|*
name|pqpdap
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|=
operator|*
name|pqpdap
expr_stmt|;
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
literal|0
argument_list|,
name|secPerSU
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
literal|0
argument_list|,
name|secPerSU
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
block|}
else|else
block|{
name|PDAPerDisk
operator|=
literal|2
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
comment|/* four of them, fone, then ftwo */
name|RF_MallocAndAdd
argument_list|(
operator|*
name|pqpdap
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|=
operator|*
name|pqpdap
expr_stmt|;
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
name|fone_start
argument_list|,
name|fone
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|parityInfo
argument_list|,
name|ftwo_start
argument_list|,
name|ftwo
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_PARITY
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|CONS_PDA
argument_list|(
name|qInfo
argument_list|,
name|ftwo_start
argument_list|,
name|ftwo
operator|->
name|numSector
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_Q
expr_stmt|;
block|}
block|}
comment|/* figure out number of nonaccessed pda */
name|napdas
operator|=
name|PDAPerDisk
operator|*
operator|(
name|numDataCol
operator|-
literal|2
operator|)
expr_stmt|;
operator|*
name|nPQNodep
operator|=
name|PDAPerDisk
expr_stmt|;
operator|*
name|nNodep
operator|=
name|napdas
expr_stmt|;
if|if
condition|(
name|napdas
operator|==
literal|0
condition|)
return|return;
comment|/* short circuit */
comment|/* allocate up our list of pda's */
name|RF_CallocAndAdd
argument_list|(
name|pda_p
argument_list|,
name|napdas
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_PhysDiskAddr_t
argument_list|)
argument_list|,
operator|(
name|RF_PhysDiskAddr_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
operator|*
name|pdap
operator|=
name|pda_p
expr_stmt|;
comment|/* linkem together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|napdas
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|pda_p
index|[
name|i
index|]
operator|.
name|next
operator|=
name|pda_p
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|sosAddr
operator|=
name|rf_RaidAddressOfPrevStripeBoundary
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numDataCol
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pda_p
operator|-
operator|(
operator|*
name|pdap
operator|)
operator|)
operator|==
name|napdas
condition|)
continue|continue;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip over dead disks */
if|if
condition|(
name|RF_DEAD_DISK
argument_list|(
name|raidPtr
operator|->
name|Disks
index|[
name|pda_p
operator|->
name|row
index|]
index|[
name|pda_p
operator|->
name|col
index|]
operator|.
name|status
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|1
case|:
comment|/* fone */
name|pda_p
operator|->
name|numSector
operator|=
name|fone
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|fone_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* full stripe */
name|pda_p
operator|->
name|numSector
operator|=
name|secPerSU
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|secPerSU
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* two slabs */
name|pda_p
operator|->
name|numSector
operator|=
name|fone
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|fone_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|fone_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|pda_p
operator|++
expr_stmt|;
name|pda_p
operator|->
name|type
operator|=
name|RF_PDA_TYPE_DATA
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|=
name|sosAddr
operator|+
operator|(
name|i
operator|*
name|secPerSU
operator|)
expr_stmt|;
call|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|MapSector
call|)
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|raidAddress
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|row
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|col
operator|)
argument_list|,
operator|&
operator|(
name|pda_p
operator|->
name|startSector
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pda_p
operator|->
name|numSector
operator|=
name|ftwo
operator|->
name|numSector
expr_stmt|;
name|pda_p
operator|->
name|raidAddress
operator|+=
name|ftwo_start
expr_stmt|;
name|pda_p
operator|->
name|startSector
operator|+=
name|ftwo_start
expr_stmt|;
name|RF_MallocAndAdd
argument_list|(
name|pda_p
operator|->
name|bufPtr
argument_list|,
name|rf_RaidAddressToByte
argument_list|(
name|raidPtr
argument_list|,
name|pda_p
operator|->
name|numSector
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
name|pda_p
operator|++
expr_stmt|;
block|}
name|RF_ASSERT
argument_list|(
name|pda_p
operator|-
operator|*
name|pdap
operator|==
name|napdas
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|DISK_NODE_PDA
parameter_list|(
name|node
parameter_list|)
value|((node)->params[0].p)
end_define

begin_define
define|#
directive|define
name|DISK_NODE_PARAMS
parameter_list|(
name|_node_
parameter_list|,
name|_p_
parameter_list|)
define|\
value|(_node_).params[0].p = _p_ ; \   (_node_).params[1].p = (_p_)->bufPtr; \   (_node_).params[2].v = parityStripeID; \   (_node_).params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru)
end_define

begin_function
name|void
name|rf_DoubleDegSmallWrite
parameter_list|(
name|RF_Raid_t
modifier|*
name|raidPtr
parameter_list|,
name|RF_AccessStripeMap_t
modifier|*
name|asmap
parameter_list|,
name|RF_DagHeader_t
modifier|*
name|dag_h
parameter_list|,
name|void
modifier|*
name|bp
parameter_list|,
name|RF_RaidAccessFlags_t
name|flags
parameter_list|,
name|RF_AllocListElem_t
modifier|*
name|allocList
parameter_list|,
name|char
modifier|*
name|redundantReadNodeName
parameter_list|,
name|char
modifier|*
name|redundantWriteNodeName
parameter_list|,
name|char
modifier|*
name|recoveryNodeName
parameter_list|,
name|int
function_decl|(
modifier|*
name|recovFunc
function_decl|)
parameter_list|(
name|RF_DagNode_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|RF_RaidLayout_t
modifier|*
name|layoutPtr
init|=
operator|&
operator|(
name|raidPtr
operator|->
name|Layout
operator|)
decl_stmt|;
name|RF_DagNode_t
modifier|*
name|nodes
decl_stmt|,
modifier|*
name|wudNodes
decl_stmt|,
modifier|*
name|rrdNodes
decl_stmt|,
modifier|*
name|recoveryNode
decl_stmt|,
modifier|*
name|blockNode
decl_stmt|,
modifier|*
name|unblockNode
decl_stmt|,
modifier|*
name|rpNodes
decl_stmt|,
modifier|*
name|rqNodes
decl_stmt|,
modifier|*
name|wpNodes
decl_stmt|,
modifier|*
name|wqNodes
decl_stmt|,
modifier|*
name|termNode
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|pda
decl_stmt|,
modifier|*
name|pqPDAs
decl_stmt|;
name|RF_PhysDiskAddr_t
modifier|*
name|npdas
decl_stmt|;
name|int
name|nWriteNodes
decl_stmt|,
name|nNodes
decl_stmt|,
name|nReadNodes
decl_stmt|,
name|nRrdNodes
decl_stmt|,
name|nWudNodes
decl_stmt|,
name|i
decl_stmt|;
name|RF_ReconUnitNum_t
name|which_ru
decl_stmt|;
name|int
name|nPQNodes
decl_stmt|;
name|RF_StripeNum_t
name|parityStripeID
init|=
name|rf_RaidAddressToParityStripeID
argument_list|(
name|layoutPtr
argument_list|,
name|asmap
operator|->
name|raidAddress
argument_list|,
operator|&
name|which_ru
argument_list|)
decl_stmt|;
comment|/* simple small write case - First part looks like a reconstruct-read 	 * of the failed data units. Then a write of all data units not 	 * failed. */
comment|/* Hdr | ------Block- /  /         \   Rrd  Rrd ...  Rrd  Rp Rq \  \ 	 * /  -------PQ----- /   \   \ Wud   Wp  WQ	     \    |   / 	 * --Unblock- | T 	 *  	 * Rrd = read recovery data  (potentially none) Wud = write user data 	 * (not incl. failed disks) Wp = Write P (could be two) Wq = Write Q 	 * (could be two) 	 *  	 */
name|rf_WriteGenerateFailedAccessASMs
argument_list|(
name|raidPtr
argument_list|,
name|asmap
argument_list|,
operator|&
name|npdas
argument_list|,
operator|&
name|nRrdNodes
argument_list|,
operator|&
name|pqPDAs
argument_list|,
operator|&
name|nPQNodes
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asmap
operator|->
name|numDataFailed
operator|==
literal|1
argument_list|)
expr_stmt|;
name|nWudNodes
operator|=
name|asmap
operator|->
name|numStripeUnitsAccessed
operator|-
operator|(
name|asmap
operator|->
name|numDataFailed
operator|)
expr_stmt|;
name|nReadNodes
operator|=
name|nRrdNodes
operator|+
literal|2
operator|*
name|nPQNodes
expr_stmt|;
name|nWriteNodes
operator|=
name|nWudNodes
operator|+
literal|2
operator|*
name|nPQNodes
expr_stmt|;
name|nNodes
operator|=
literal|4
operator|+
name|nReadNodes
operator|+
name|nWriteNodes
expr_stmt|;
name|RF_CallocAndAdd
argument_list|(
name|nodes
argument_list|,
name|nNodes
argument_list|,
sizeof|sizeof
argument_list|(
name|RF_DagNode_t
argument_list|)
argument_list|,
operator|(
name|RF_DagNode_t
operator|*
operator|)
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|blockNode
operator|=
name|nodes
expr_stmt|;
name|unblockNode
operator|=
name|blockNode
operator|+
literal|1
expr_stmt|;
name|termNode
operator|=
name|unblockNode
operator|+
literal|1
expr_stmt|;
name|recoveryNode
operator|=
name|termNode
operator|+
literal|1
expr_stmt|;
name|rrdNodes
operator|=
name|recoveryNode
operator|+
literal|1
expr_stmt|;
name|rpNodes
operator|=
name|rrdNodes
operator|+
name|nRrdNodes
expr_stmt|;
name|rqNodes
operator|=
name|rpNodes
operator|+
name|nPQNodes
expr_stmt|;
name|wudNodes
operator|=
name|rqNodes
operator|+
name|nPQNodes
expr_stmt|;
name|wpNodes
operator|=
name|wudNodes
operator|+
name|nWudNodes
expr_stmt|;
name|wqNodes
operator|=
name|wpNodes
operator|+
name|nPQNodes
expr_stmt|;
name|dag_h
operator|->
name|creator
operator|=
literal|"PQ_DDSimpleSmallWrite"
expr_stmt|;
name|dag_h
operator|->
name|numSuccedents
operator|=
literal|1
expr_stmt|;
name|dag_h
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|blockNode
expr_stmt|;
name|rf_InitNode
argument_list|(
name|termNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_TerminateFunc
argument_list|,
name|rf_TerminateUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Trm"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
name|termNode
operator|->
name|antecedents
index|[
literal|0
index|]
operator|=
name|unblockNode
expr_stmt|;
name|termNode
operator|->
name|antType
index|[
literal|0
index|]
operator|=
name|rf_control
expr_stmt|;
comment|/* init the block and unblock nodes */
comment|/* The block node has all the read nodes as successors */
name|rf_InitNode
argument_list|(
name|blockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nReadNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nReadNodes
condition|;
name|i
operator|++
control|)
name|blockNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
name|rrdNodes
operator|+
name|i
expr_stmt|;
comment|/* The unblock node has all the writes as successors */
name|rf_InitNode
argument_list|(
name|unblockNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|rf_NullNodeFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|nWriteNodes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dag_h
argument_list|,
literal|"Nil"
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWriteNodes
condition|;
name|i
operator|++
control|)
block|{
name|unblockNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
name|wudNodes
operator|+
name|i
expr_stmt|;
name|unblockNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
block|}
name|unblockNode
operator|->
name|succedents
index|[
literal|0
index|]
operator|=
name|termNode
expr_stmt|;
define|#
directive|define
name|INIT_READ_NODE
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
define|\
value|rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskReadFunc, rf_DiskReadUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, name, allocList); \   (node)->succedents[0] = recoveryNode; \   (node)->antecedents[0] = blockNode; \   (node)->antType[0] = rf_control;
comment|/* build the read nodes */
name|pda
operator|=
name|npdas
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRrdNodes
condition|;
name|i
operator|++
operator|,
name|pda
operator|=
name|pda
operator|->
name|next
control|)
block|{
name|INIT_READ_NODE
argument_list|(
name|rrdNodes
operator|+
name|i
argument_list|,
literal|"rrd"
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rrdNodes
index|[
name|i
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
block|}
comment|/* read redundancy pdas */
name|pda
operator|=
name|pqPDAs
expr_stmt|;
name|INIT_READ_NODE
argument_list|(
name|rpNodes
argument_list|,
literal|"Rp"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rpNodes
index|[
literal|0
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|INIT_READ_NODE
argument_list|(
name|rqNodes
argument_list|,
name|redundantReadNodeName
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rqNodes
index|[
literal|0
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
if|if
condition|(
name|nPQNodes
operator|==
literal|2
condition|)
block|{
name|pda
operator|++
expr_stmt|;
name|INIT_READ_NODE
argument_list|(
name|rpNodes
operator|+
literal|1
argument_list|,
literal|"Rp"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rpNodes
index|[
literal|1
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|INIT_READ_NODE
argument_list|(
name|rqNodes
operator|+
literal|1
argument_list|,
name|redundantReadNodeName
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|rqNodes
index|[
literal|1
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
block|}
comment|/* the recovery node has all reads as precedessors and all writes as 	 * successors. It generates a result for every write P or write Q 	 * node. As parameters, it takes a pda per read and a pda per stripe 	 * of user data written. It also takes as the last params the raidPtr 	 * and asm. For results, it takes PDA for P& Q. */
name|rf_InitNode
argument_list|(
name|recoveryNode
argument_list|,
name|rf_wait
argument_list|,
name|RF_FALSE
argument_list|,
name|recovFunc
argument_list|,
name|rf_NullNodeUndoFunc
argument_list|,
name|NULL
argument_list|,
name|nWriteNodes
argument_list|,
comment|/* succesors */
name|nReadNodes
argument_list|,
comment|/* preds */
name|nReadNodes
operator|+
name|nWudNodes
operator|+
literal|3
argument_list|,
comment|/* params */
literal|2
operator|*
name|nPQNodes
argument_list|,
comment|/* results */
name|dag_h
argument_list|,
name|recoveryNodeName
argument_list|,
name|allocList
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nReadNodes
condition|;
name|i
operator|++
control|)
block|{
name|recoveryNode
operator|->
name|antecedents
index|[
name|i
index|]
operator|=
name|rrdNodes
operator|+
name|i
expr_stmt|;
name|recoveryNode
operator|->
name|antType
index|[
name|i
index|]
operator|=
name|rf_control
expr_stmt|;
name|recoveryNode
operator|->
name|params
index|[
name|i
index|]
operator|.
name|p
operator|=
name|DISK_NODE_PDA
argument_list|(
name|rrdNodes
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWudNodes
condition|;
name|i
operator|++
control|)
block|{
name|recoveryNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
name|wudNodes
operator|+
name|i
expr_stmt|;
block|}
name|recoveryNode
operator|->
name|params
index|[
name|nReadNodes
operator|+
name|nWudNodes
index|]
operator|.
name|p
operator|=
name|asmap
operator|->
name|failedPDAs
index|[
literal|0
index|]
expr_stmt|;
name|recoveryNode
operator|->
name|params
index|[
name|nReadNodes
operator|+
name|nWudNodes
operator|+
literal|1
index|]
operator|.
name|p
operator|=
name|raidPtr
expr_stmt|;
name|recoveryNode
operator|->
name|params
index|[
name|nReadNodes
operator|+
name|nWudNodes
operator|+
literal|2
index|]
operator|.
name|p
operator|=
name|asmap
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nWriteNodes
condition|;
name|i
operator|++
control|)
name|recoveryNode
operator|->
name|succedents
index|[
name|i
index|]
operator|=
name|wudNodes
operator|+
name|i
expr_stmt|;
name|pda
operator|=
name|pqPDAs
expr_stmt|;
name|recoveryNode
operator|->
name|results
index|[
literal|0
index|]
operator|=
name|pda
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|recoveryNode
operator|->
name|results
index|[
literal|1
index|]
operator|=
name|pda
expr_stmt|;
if|if
condition|(
name|nPQNodes
operator|==
literal|2
condition|)
block|{
name|pda
operator|++
expr_stmt|;
name|recoveryNode
operator|->
name|results
index|[
literal|2
index|]
operator|=
name|pda
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|recoveryNode
operator|->
name|results
index|[
literal|3
index|]
operator|=
name|pda
expr_stmt|;
block|}
comment|/* fill writes */
define|#
directive|define
name|INIT_WRITE_NODE
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
define|\
value|rf_InitNode(node, rf_wait, RF_FALSE, rf_DiskWriteFunc, rf_DiskWriteUndoFunc, rf_GenericWakeupFunc, 1, 1, 4, 0, dag_h, name, allocList); \     (node)->succedents[0] = unblockNode; \     (node)->antecedents[0] = recoveryNode; \     (node)->antType[0] = rf_control;
name|pda
operator|=
name|asmap
operator|->
name|physInfo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nWudNodes
condition|;
name|i
operator|++
control|)
block|{
name|INIT_WRITE_NODE
argument_list|(
name|wudNodes
operator|+
name|i
argument_list|,
literal|"Wd"
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|wudNodes
index|[
name|i
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|recoveryNode
operator|->
name|params
index|[
name|nReadNodes
operator|+
name|i
index|]
operator|.
name|p
operator|=
name|DISK_NODE_PDA
argument_list|(
name|wudNodes
operator|+
name|i
argument_list|)
expr_stmt|;
name|pda
operator|=
name|pda
operator|->
name|next
expr_stmt|;
block|}
comment|/* write redundancy pdas */
name|pda
operator|=
name|pqPDAs
expr_stmt|;
name|INIT_WRITE_NODE
argument_list|(
name|wpNodes
argument_list|,
literal|"Wp"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|wpNodes
index|[
literal|0
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|INIT_WRITE_NODE
argument_list|(
name|wqNodes
argument_list|,
literal|"Wq"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|wqNodes
index|[
literal|0
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
if|if
condition|(
name|nPQNodes
operator|==
literal|2
condition|)
block|{
name|pda
operator|++
expr_stmt|;
name|INIT_WRITE_NODE
argument_list|(
name|wpNodes
operator|+
literal|1
argument_list|,
literal|"Wp"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|wpNodes
index|[
literal|1
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
name|pda
operator|++
expr_stmt|;
name|INIT_WRITE_NODE
argument_list|(
name|wqNodes
operator|+
literal|1
argument_list|,
literal|"Wq"
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|pda
argument_list|)
expr_stmt|;
name|DISK_NODE_PARAMS
argument_list|(
name|wqNodes
index|[
literal|1
index|]
argument_list|,
name|pda
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (RF_INCLUDE_PQ> 0) || (RF_INCLUDE_EVENODD> 0) */
end_comment

end_unit

