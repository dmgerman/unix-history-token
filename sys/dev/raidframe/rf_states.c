begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rf_states.c,v 1.15 2000/10/20 02:24:45 oster Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Copyright (c) 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Mark Holland, William V. Courtright II, Robby Findler  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_archs.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_threadstuff.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_raid.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dag.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_desc.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_aselect.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_general.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_states.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_dagutils.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_engine.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_map.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_etimer.h>
end_include

begin_include
include|#
directive|include
file|<dev/raidframe/rf_kintf.h>
end_include

begin_comment
comment|/* prototypes for some of the available states.     States must:       - not block.       - either schedule rf_ContinueRaidAccess as a callback and return        RF_TRUE, or complete all of their work and return RF_FALSE.       - increment desc->state when they have finished their work. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|StateName
parameter_list|(
name|RF_AccessState_t
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|rf_QuiesceState
case|:
return|return
literal|"QuiesceState"
return|;
case|case
name|rf_MapState
case|:
return|return
literal|"MapState"
return|;
case|case
name|rf_LockState
case|:
return|return
literal|"LockState"
return|;
case|case
name|rf_CreateDAGState
case|:
return|return
literal|"CreateDAGState"
return|;
case|case
name|rf_ExecuteDAGState
case|:
return|return
literal|"ExecuteDAGState"
return|;
case|case
name|rf_ProcessDAGState
case|:
return|return
literal|"ProcessDAGState"
return|;
case|case
name|rf_CleanupState
case|:
return|return
literal|"CleanupState"
return|;
case|case
name|rf_LastState
case|:
return|return
literal|"LastState"
return|;
case|case
name|rf_IncrAccessesCountState
case|:
return|return
literal|"IncrAccessesCountState"
return|;
case|case
name|rf_DecrAccessesCountState
case|:
return|return
literal|"DecrAccessesCountState"
return|;
default|default:
return|return
literal|"!!! UnnamedState !!!"
return|;
block|}
block|}
end_function

begin_function
name|void
name|rf_ContinueRaidAccess
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|int
name|suspended
init|=
name|RF_FALSE
decl_stmt|;
name|int
name|current_state_index
init|=
name|desc
operator|->
name|state
decl_stmt|;
name|RF_AccessState_t
name|current_state
init|=
name|desc
operator|->
name|states
index|[
name|current_state_index
index|]
decl_stmt|;
name|int
name|unit
init|=
name|desc
operator|->
name|raidPtr
operator|->
name|raidid
decl_stmt|;
do|do
block|{
name|current_state_index
operator|=
name|desc
operator|->
name|state
expr_stmt|;
name|current_state
operator|=
name|desc
operator|->
name|states
index|[
name|current_state_index
index|]
expr_stmt|;
switch|switch
condition|(
name|current_state
condition|)
block|{
case|case
name|rf_QuiesceState
case|:
name|suspended
operator|=
name|rf_State_Quiesce
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_IncrAccessesCountState
case|:
name|suspended
operator|=
name|rf_State_IncrAccessCount
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_MapState
case|:
name|suspended
operator|=
name|rf_State_Map
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_LockState
case|:
name|suspended
operator|=
name|rf_State_Lock
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_CreateDAGState
case|:
name|suspended
operator|=
name|rf_State_CreateDAG
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_ExecuteDAGState
case|:
name|suspended
operator|=
name|rf_State_ExecuteDAG
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_ProcessDAGState
case|:
name|suspended
operator|=
name|rf_State_ProcessDAG
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_CleanupState
case|:
name|suspended
operator|=
name|rf_State_Cleanup
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_DecrAccessesCountState
case|:
name|suspended
operator|=
name|rf_State_DecrAccessCount
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|rf_LastState
case|:
name|suspended
operator|=
name|rf_State_LastState
argument_list|(
name|desc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* after this point, we cannot dereference desc since desc may 		 * have been freed. desc is only freed in LastState, so if we 		 * renter this function or loop back up, desc should be valid. */
if|if
condition|(
name|rf_printStatesDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: State: %-24s StateIndex: %3i desc: 0x%ld %s\n"
argument_list|,
name|unit
argument_list|,
name|StateName
argument_list|(
name|current_state
argument_list|)
argument_list|,
name|current_state_index
argument_list|,
operator|(
name|long
operator|)
name|desc
argument_list|,
name|suspended
condition|?
literal|"callback scheduled"
else|:
literal|"looping"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|suspended
operator|&&
name|current_state
operator|!=
name|rf_LastState
condition|)
do|;
return|return;
block|}
end_function

begin_function
name|void
name|rf_ContinueDagAccess
parameter_list|(
name|RF_DagList_t
modifier|*
name|dagList
parameter_list|)
block|{
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
operator|&
operator|(
name|dagList
operator|->
name|desc
operator|->
name|tracerec
operator|)
decl_stmt|;
name|RF_RaidAccessDesc_t
modifier|*
name|desc
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|desc
operator|=
name|dagList
operator|->
name|desc
expr_stmt|;
name|timer
operator|=
name|tracerec
operator|->
name|timer
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|exec_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|tracerec
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* skip to dag which just finished */
name|dag_h
operator|=
name|dagList
operator|->
name|dags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dagList
operator|->
name|numDagsDone
condition|;
name|i
operator|++
control|)
block|{
name|dag_h
operator|=
name|dag_h
operator|->
name|next
expr_stmt|;
block|}
comment|/* check to see if retry is required */
if|if
condition|(
name|dag_h
operator|->
name|status
operator|==
name|rf_rollBackward
condition|)
block|{
comment|/* when a dag fails, mark desc status as bad and allow all 		 * other dags in the desc to execute to completion.  then, 		 * free all dags and start over */
name|desc
operator|->
name|status
operator|=
literal|1
expr_stmt|;
comment|/* bad status */
block|{
name|printf
argument_list|(
literal|"raid%d: DAG failure: %c addr 0x%lx (%ld) nblk 0x%x (%d) buf 0x%lx\n"
argument_list|,
name|desc
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|,
name|desc
operator|->
name|type
argument_list|,
operator|(
name|long
operator|)
name|desc
operator|->
name|raidAddress
argument_list|,
operator|(
name|long
operator|)
name|desc
operator|->
name|raidAddress
argument_list|,
operator|(
name|int
operator|)
name|desc
operator|->
name|numBlocks
argument_list|,
operator|(
name|int
operator|)
name|desc
operator|->
name|numBlocks
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|desc
operator|->
name|bufPtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dagList
operator|->
name|numDagsDone
operator|++
expr_stmt|;
name|rf_ContinueRaidAccess
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rf_State_LastState
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|callbackFunc
function_decl|)
parameter_list|(
name|RF_CBParam_t
parameter_list|)
init|=
name|desc
operator|->
name|callbackFunc
function_decl|;
name|RF_CBParam_t
name|callbackArg
decl_stmt|;
name|callbackArg
operator|.
name|p
operator|=
name|desc
operator|->
name|callbackArg
expr_stmt|;
comment|/* 	 * If this is not an async request, wake up the caller 	 */
if|if
condition|(
name|desc
operator|->
name|async_flag
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
name|desc
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * That's all the IO for this one... unbusy the 'disk'. 	 */
name|rf_disk_unbusy
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/*  	 * Wakeup any requests waiting to go. 	 */
name|RF_LOCK_MUTEX
argument_list|(
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|desc
operator|->
name|raidPtr
operator|)
operator|->
name|mutex
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|desc
operator|->
name|raidPtr
operator|)
operator|->
name|openings
operator|++
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|desc
operator|->
name|raidPtr
operator|)
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* wake up any pending IO */
name|raidstart
argument_list|(
operator|(
operator|(
name|RF_Raid_t
operator|*
operator|)
name|desc
operator|->
name|raidPtr
operator|)
argument_list|)
expr_stmt|;
comment|/* printf("Calling biodone on 0x%x\n",desc->bp); */
name|biodone
argument_list|(
name|desc
operator|->
name|bp
argument_list|)
expr_stmt|;
comment|/* access came through ioctl */
if|if
condition|(
name|callbackFunc
condition|)
name|callbackFunc
argument_list|(
name|callbackArg
argument_list|)
expr_stmt|;
name|rf_FreeRaidAccDesc
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|RF_FALSE
return|;
block|}
end_function

begin_function
name|int
name|rf_State_IncrAccessCount
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
name|desc
operator|->
name|raidPtr
expr_stmt|;
comment|/* Bummer. We have to do this to be 100% safe w.r.t. the increment 	 * below */
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|accs_in_flight
operator|++
expr_stmt|;
comment|/* used to detect quiescence */
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|desc
operator|->
name|state
operator|++
expr_stmt|;
return|return
name|RF_FALSE
return|;
block|}
end_function

begin_function
name|int
name|rf_State_DecrAccessCount
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
name|desc
operator|->
name|raidPtr
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|raidPtr
operator|->
name|accs_in_flight
operator|--
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|accesses_suspended
operator|&&
name|raidPtr
operator|->
name|accs_in_flight
operator|==
literal|0
condition|)
block|{
name|rf_SignalQuiescenceLock
argument_list|(
name|raidPtr
argument_list|,
name|raidPtr
operator|->
name|reconDesc
argument_list|)
expr_stmt|;
block|}
name|rf_UpdateUserStats
argument_list|(
name|raidPtr
argument_list|,
name|RF_ETIMER_VAL_US
argument_list|(
name|desc
operator|->
name|timer
argument_list|)
argument_list|,
name|desc
operator|->
name|numBlocks
argument_list|)
expr_stmt|;
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|desc
operator|->
name|state
operator|++
expr_stmt|;
return|return
name|RF_FALSE
return|;
block|}
end_function

begin_function
name|int
name|rf_State_Quiesce
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
operator|&
name|desc
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|int
name|suspended
init|=
name|RF_FALSE
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
decl_stmt|;
name|raidPtr
operator|=
name|desc
operator|->
name|raidPtr
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|desc
operator|->
name|timer
argument_list|)
expr_stmt|;
name|RF_LOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidPtr
operator|->
name|accesses_suspended
condition|)
block|{
name|RF_CallbackDesc_t
modifier|*
name|cb
decl_stmt|;
name|cb
operator|=
name|rf_AllocCallbackDesc
argument_list|()
expr_stmt|;
comment|/* XXX the following cast is quite bogus... 		 * rf_ContinueRaidAccess takes a (RF_RaidAccessDesc_t *) as an 		 * argument..  GO */
name|cb
operator|->
name|callbackFunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|RF_CBParam_t
argument_list|)
operator|)
name|rf_ContinueRaidAccess
expr_stmt|;
name|cb
operator|->
name|callbackArg
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
name|cb
operator|->
name|next
operator|=
name|raidPtr
operator|->
name|quiesce_wait_list
expr_stmt|;
name|raidPtr
operator|->
name|quiesce_wait_list
operator|=
name|cb
expr_stmt|;
name|suspended
operator|=
name|RF_TRUE
expr_stmt|;
block|}
name|RF_UNLOCK_MUTEX
argument_list|(
name|raidPtr
operator|->
name|access_suspend_mutex
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|suspend_ovhd_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspended
operator|&&
name|rf_quiesceDebug
condition|)
name|printf
argument_list|(
literal|"Stalling access due to quiescence lock\n"
argument_list|)
expr_stmt|;
name|desc
operator|->
name|state
operator|++
expr_stmt|;
return|return
name|suspended
return|;
block|}
end_function

begin_function
name|int
name|rf_State_Map
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
operator|&
name|desc
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|asmap
operator|=
name|rf_MapAccess
argument_list|(
name|raidPtr
argument_list|,
name|desc
operator|->
name|raidAddress
argument_list|,
name|desc
operator|->
name|numBlocks
argument_list|,
name|desc
operator|->
name|bufPtr
argument_list|,
name|RF_DONT_REMAP
argument_list|)
operator|)
condition|)
name|RF_PANIC
argument_list|()
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|map_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|desc
operator|->
name|state
operator|++
expr_stmt|;
return|return
name|RF_FALSE
return|;
block|}
end_function

begin_function
name|int
name|rf_State_Lock
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
operator|&
name|desc
operator|->
name|tracerec
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asmh
init|=
name|desc
operator|->
name|asmap
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asm_p
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|int
name|suspended
init|=
name|RF_FALSE
decl_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_NO_STRIPE_LOCKS
operator|)
condition|)
block|{
name|RF_StripeNum_t
name|lastStripeID
init|=
operator|-
literal|1
decl_stmt|;
comment|/* acquire each lock that we don't already hold */
for|for
control|(
name|asm_p
operator|=
name|asmh
operator|->
name|stripeMap
init|;
name|asm_p
condition|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
control|)
block|{
name|RF_ASSERT
argument_list|(
name|RF_IO_IS_R_OR_W
argument_list|(
name|desc
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rf_suppressLocksAndLargeWrites
operator|&&
name|asm_p
operator|->
name|parityInfo
operator|&&
operator|!
operator|(
name|desc
operator|->
name|flags
operator|&
name|RF_DAG_SUPPRESS_LOCKS
operator|)
operator|&&
operator|!
operator|(
name|asm_p
operator|->
name|flags
operator|&
name|RF_ASM_FLAGS_LOCK_TRIED
operator|)
condition|)
block|{
name|asm_p
operator|->
name|flags
operator||=
name|RF_ASM_FLAGS_LOCK_TRIED
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|asm_p
operator|->
name|stripeID
operator|>
name|lastStripeID
argument_list|)
expr_stmt|;
comment|/* locks must be acquired hierarchically */
name|lastStripeID
operator|=
name|asm_p
operator|->
name|stripeID
expr_stmt|;
comment|/* XXX the cast to (void (*)(RF_CBParam_t)) 				 * below is bogus!  GO */
name|RF_INIT_LOCK_REQ_DESC
argument_list|(
name|asm_p
operator|->
name|lockReqDesc
argument_list|,
name|desc
operator|->
name|type
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|RF_Buf_t
argument_list|)
operator|)
name|rf_ContinueRaidAccess
argument_list|,
name|desc
argument_list|,
name|asm_p
argument_list|,
name|raidPtr
operator|->
name|Layout
operator|.
name|dataSectorsPerStripe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_AcquireStripeLock
argument_list|(
name|raidPtr
operator|->
name|lockTable
argument_list|,
name|asm_p
operator|->
name|stripeID
argument_list|,
operator|&
name|asm_p
operator|->
name|lockReqDesc
argument_list|)
condition|)
block|{
name|suspended
operator|=
name|RF_TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|RF_IO_TYPE_WRITE
operator|&&
name|raidPtr
operator|->
name|status
index|[
name|asm_p
operator|->
name|physInfo
operator|->
name|row
index|]
operator|==
name|rf_rs_reconstructing
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|asm_p
operator|->
name|flags
operator|&
name|RF_ASM_FLAGS_FORCE_TRIED
operator|)
condition|)
block|{
name|int
name|val
decl_stmt|;
name|asm_p
operator|->
name|flags
operator||=
name|RF_ASM_FLAGS_FORCE_TRIED
expr_stmt|;
comment|/* XXX the cast below is quite 					 * bogus!!! XXX  GO */
name|val
operator|=
name|rf_ForceOrBlockRecon
argument_list|(
name|raidPtr
argument_list|,
name|asm_p
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|RF_Raid_t
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|rf_ContinueRaidAccess
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|asm_p
operator|->
name|flags
operator||=
name|RF_ASM_FLAGS_RECON_BLOCKED
expr_stmt|;
block|}
else|else
block|{
name|suspended
operator|=
name|RF_TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rf_pssDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: skipping force/block because already done, psid %ld\n"
argument_list|,
name|desc
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|long
operator|)
name|asm_p
operator|->
name|stripeID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|rf_pssDebug
condition|)
block|{
name|printf
argument_list|(
literal|"raid%d: skipping force/block because not write or not under recon, psid %ld\n"
argument_list|,
name|desc
operator|->
name|raidPtr
operator|->
name|raidid
argument_list|,
operator|(
name|long
operator|)
name|asm_p
operator|->
name|stripeID
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|lock_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|suspended
condition|)
return|return
operator|(
name|RF_TRUE
operator|)
return|;
block|}
name|desc
operator|->
name|state
operator|++
expr_stmt|;
return|return
operator|(
name|RF_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the following three states create, execute, and post-process dags  * the error recovery unit is a single dag.  * by default, SelectAlgorithm creates an array of dags, one per parity stripe  * in some tricky cases, multiple dags per stripe are created  *   - dags within a parity stripe are executed sequentially (arbitrary order)  *   - dags for distinct parity stripes are executed concurrently  *  * repeat until all dags complete successfully -or- dag selection fails  *  * while !done  *   create dag(s) (SelectAlgorithm)  *   if dag  *     execute dag (DispatchDAG)  *     if dag successful  *       done (SUCCESS)  *     else  *       !done (RETRY - start over with new dags)  *   else  *     done (FAIL)  */
end_comment

begin_function
name|int
name|rf_State_CreateDAG
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
operator|&
name|desc
operator|->
name|tracerec
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|int
name|i
decl_stmt|,
name|selectStatus
decl_stmt|;
comment|/* generate a dag for the access, and fire it off.  When the dag 	 * completes, we'll get re-invoked in the next state. */
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* SelectAlgorithm returns one or more dags */
name|selectStatus
operator|=
name|rf_SelectAlgorithm
argument_list|(
name|desc
argument_list|,
name|desc
operator|->
name|flags
operator||
name|RF_DAG_SUPPRESS_LOCKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf_printDAGsDebug
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
name|rf_PrintDAGList
argument_list|(
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* update time to create all dags */
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|dag_create_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* good status */
if|if
condition|(
name|selectStatus
condition|)
block|{
comment|/* failed to create a dag */
comment|/* this happens when there are too many faults or incomplete 		 * dag libraries */
name|printf
argument_list|(
literal|"[Failed to create a DAG]\n"
argument_list|)
expr_stmt|;
name|RF_PANIC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* bind dags to desc */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
block|{
name|dag_h
operator|=
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
expr_stmt|;
while|while
condition|(
name|dag_h
condition|)
block|{
name|dag_h
operator|->
name|bp
operator|=
operator|(
name|RF_Buf_t
operator|)
name|desc
operator|->
name|bp
expr_stmt|;
name|dag_h
operator|->
name|tracerec
operator|=
name|tracerec
expr_stmt|;
name|dag_h
operator|=
name|dag_h
operator|->
name|next
expr_stmt|;
block|}
block|}
name|desc
operator|->
name|flags
operator||=
name|RF_DAG_DISPATCH_RETURNED
expr_stmt|;
name|desc
operator|->
name|state
operator|++
expr_stmt|;
comment|/* next state should be rf_State_ExecuteDAG */
block|}
return|return
name|RF_FALSE
return|;
block|}
end_function

begin_comment
comment|/* the access has an array of dagLists, one dagList per parity stripe.  * fire the first dag in each parity stripe (dagList).  * dags within a stripe (dagList) must be executed sequentially  *  - this preserves atomic parity update  * dags for independents parity groups (stripes) are fired concurrently */
end_comment

begin_function
name|int
name|rf_State_ExecuteDAG
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|RF_DagList_t
modifier|*
name|dagArray
init|=
name|desc
operator|->
name|dagArray
decl_stmt|;
comment|/* next state is always rf_State_ProcessDAG important to do this 	 * before firing the first dag (it may finish before we leave this 	 * routine) */
name|desc
operator|->
name|state
operator|++
expr_stmt|;
comment|/* sweep dag array, a stripe at a time, firing the first dag in each 	 * stripe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
block|{
name|RF_ASSERT
argument_list|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDags
operator|>
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsDone
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsFired
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|dagArray
index|[
name|i
index|]
operator|.
name|tracerec
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* fire first dag in this stripe */
name|dag_h
operator|=
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
expr_stmt|;
name|RF_ASSERT
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsFired
operator|++
expr_stmt|;
comment|/* XXX Yet another case where we pass in a conflicting 		 * function pointer :-(  XXX  GO */
name|rf_DispatchDAG
argument_list|(
name|dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_ContinueDagAccess
argument_list|,
operator|&
name|dagArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* the DAG will always call the callback, even if there was no 	 * blocking, so we are always suspended in this state */
return|return
name|RF_TRUE
return|;
block|}
end_function

begin_comment
comment|/* rf_State_ProcessDAG is entered when a dag completes.  * first, check to all dags in the access have completed  * if not, fire as many dags as possible */
end_comment

begin_function
name|int
name|rf_State_ProcessDAG
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_AccessStripeMapHeader_t
modifier|*
name|asmh
init|=
name|desc
operator|->
name|asmap
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|done
init|=
name|RF_TRUE
decl_stmt|;
name|RF_DagList_t
modifier|*
name|dagArray
init|=
name|desc
operator|->
name|dagArray
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
comment|/* check to see if this is the last dag */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDags
operator|!=
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsDone
condition|)
name|done
operator|=
name|RF_FALSE
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|status
condition|)
block|{
comment|/* a dag failed, retry */
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* free all dags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
block|{
name|rf_FreeDAG
argument_list|(
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
argument_list|)
expr_stmt|;
block|}
name|rf_MarkFailuresInASMList
argument_list|(
name|raidPtr
argument_list|,
name|asmh
argument_list|)
expr_stmt|;
comment|/* back up to rf_State_CreateDAG */
name|desc
operator|->
name|state
operator|=
name|desc
operator|->
name|state
operator|-
literal|2
expr_stmt|;
return|return
name|RF_FALSE
return|;
block|}
else|else
block|{
comment|/* move on to rf_State_Cleanup */
name|desc
operator|->
name|state
operator|++
expr_stmt|;
block|}
return|return
name|RF_FALSE
return|;
block|}
else|else
block|{
comment|/* more dags to execute */
comment|/* see if any are ready to be fired.  if so, fire them */
comment|/* don't fire the initial dag in a list, it's fired in 		 * rf_State_ExecuteDAG */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsDone
operator|<
name|dagArray
index|[
name|i
index|]
operator|.
name|numDags
operator|)
operator|&&
operator|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsDone
operator|==
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsFired
operator|)
operator|&&
operator|(
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsFired
operator|>
literal|0
operator|)
condition|)
block|{
name|RF_ETIMER_START
argument_list|(
name|dagArray
index|[
name|i
index|]
operator|.
name|tracerec
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* fire next dag in this stripe */
comment|/* first, skip to next dag awaiting execution */
name|dag_h
operator|=
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsDone
condition|;
name|j
operator|++
control|)
name|dag_h
operator|=
name|dag_h
operator|->
name|next
expr_stmt|;
name|dagArray
index|[
name|i
index|]
operator|.
name|numDagsFired
operator|++
expr_stmt|;
comment|/* XXX and again we pass a different function 				 * pointer.. GO */
name|rf_DispatchDAG
argument_list|(
name|dag_h
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|rf_ContinueDagAccess
argument_list|,
operator|&
name|dagArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RF_TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* only make it this far if all dags complete successfully */
end_comment

begin_function
name|int
name|rf_State_Cleanup
parameter_list|(
name|RF_RaidAccessDesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|RF_AccTraceEntry_t
modifier|*
name|tracerec
init|=
operator|&
name|desc
operator|->
name|tracerec
decl_stmt|;
name|RF_AccessStripeMapHeader_t
modifier|*
name|asmh
init|=
name|desc
operator|->
name|asmap
decl_stmt|;
name|RF_Raid_t
modifier|*
name|raidPtr
init|=
name|desc
operator|->
name|raidPtr
decl_stmt|;
name|RF_AccessStripeMap_t
modifier|*
name|asm_p
decl_stmt|;
name|RF_DagHeader_t
modifier|*
name|dag_h
decl_stmt|;
name|RF_Etimer_t
name|timer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|desc
operator|->
name|state
operator|++
expr_stmt|;
name|timer
operator|=
name|tracerec
operator|->
name|timer
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|dag_retry_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* the RAID I/O is complete.  Clean up. */
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|dag_retry_us
operator|=
literal|0
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags
operator|&
name|RF_DAG_RETURN_DAG
condition|)
block|{
comment|/* copy dags into paramDAG */
operator|*
operator|(
name|desc
operator|->
name|paramDAG
operator|)
operator|=
name|desc
operator|->
name|dagArray
index|[
literal|0
index|]
operator|.
name|dags
expr_stmt|;
name|dag_h
operator|=
operator|*
operator|(
name|desc
operator|->
name|paramDAG
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
block|{
comment|/* concatenate dags from remaining stripes */
name|RF_ASSERT
argument_list|(
name|dag_h
argument_list|)
expr_stmt|;
while|while
condition|(
name|dag_h
operator|->
name|next
condition|)
name|dag_h
operator|=
name|dag_h
operator|->
name|next
expr_stmt|;
name|dag_h
operator|->
name|next
operator|=
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* free all dags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|numStripes
condition|;
name|i
operator|++
control|)
block|{
name|rf_FreeDAG
argument_list|(
name|desc
operator|->
name|dagArray
index|[
name|i
index|]
operator|.
name|dags
argument_list|)
expr_stmt|;
block|}
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|cleanup_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|raidPtr
operator|->
name|Layout
operator|.
name|map
operator|->
name|flags
operator|&
name|RF_NO_STRIPE_LOCKS
operator|)
condition|)
block|{
for|for
control|(
name|asm_p
operator|=
name|asmh
operator|->
name|stripeMap
init|;
name|asm_p
condition|;
name|asm_p
operator|=
name|asm_p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|rf_suppressLocksAndLargeWrites
operator|&&
name|asm_p
operator|->
name|parityInfo
operator|&&
operator|!
operator|(
name|desc
operator|->
name|flags
operator|&
name|RF_DAG_SUPPRESS_LOCKS
operator|)
condition|)
block|{
name|RF_ASSERT_VALID_LOCKREQ
argument_list|(
operator|&
name|asm_p
operator|->
name|lockReqDesc
argument_list|)
expr_stmt|;
name|rf_ReleaseStripeLock
argument_list|(
name|raidPtr
operator|->
name|lockTable
argument_list|,
name|asm_p
operator|->
name|stripeID
argument_list|,
operator|&
name|asm_p
operator|->
name|lockReqDesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asm_p
operator|->
name|flags
operator|&
name|RF_ASM_FLAGS_RECON_BLOCKED
condition|)
block|{
name|rf_UnblockRecon
argument_list|(
name|raidPtr
argument_list|,
name|asm_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|lock_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_START
argument_list|(
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags
operator|&
name|RF_DAG_RETURN_ASM
condition|)
operator|*
operator|(
name|desc
operator|->
name|paramASM
operator|)
operator|=
name|asmh
expr_stmt|;
else|else
name|rf_FreeAccessStripeMap
argument_list|(
name|asmh
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|tracerec
operator|->
name|specific
operator|.
name|user
operator|.
name|cleanup_us
operator|+=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|desc
operator|->
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|desc
operator|->
name|timer
argument_list|)
expr_stmt|;
name|timer
operator|=
name|desc
operator|->
name|tracerec
operator|.
name|tot_timer
expr_stmt|;
name|RF_ETIMER_STOP
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|RF_ETIMER_EVAL
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|desc
operator|->
name|tracerec
operator|.
name|total_us
operator|=
name|RF_ETIMER_VAL_US
argument_list|(
name|timer
argument_list|)
expr_stmt|;
name|rf_LogTraceRec
argument_list|(
name|raidPtr
argument_list|,
name|tracerec
argument_list|)
expr_stmt|;
name|desc
operator|->
name|flags
operator||=
name|RF_DAG_ACCESS_COMPLETE
expr_stmt|;
return|return
name|RF_FALSE
return|;
block|}
end_function

end_unit

