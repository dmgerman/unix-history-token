begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * FreeBSD/CAM specific routines for LSI '909 FC  adapters.  * FreeBSD Version.  *  * Copyright (c)  2000, 2001 by Greg Ansley  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2002, 2006 by Matthew Jacob  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon including  *    a substantially similar Disclaimer requirement for further binary  *    redistribution.  * 3. Neither the names of the above listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE COPYRIGHT  * OWNER OR CONTRIBUTOR IS ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Support from Chris Ellsworth in order to make SAS adapters work  * is gratefully acknowledged.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004, Avid Technology, Inc. and its contributors.  * Copyright (c) 2005, WHEEL Sp. z o.o.  * Copyright (c) 2004, 2005 Justin T. Gibbs  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon including  *    a substantially similar Disclaimer requirement for further binary  *    redistribution.  * 3. Neither the names of the above listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE COPYRIGHT  * OWNER OR CONTRIBUTOR IS ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/mpt/mpt.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpt/mpt_cam.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpt/mpt_raid.h>
end_include

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_ioc.h"
end_include

begin_comment
comment|/* XXX Fix Event Handling!!! */
end_comment

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_init.h"
end_include

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_targ.h"
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_function_decl
specifier|static
name|void
name|mpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|mpt_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_setwidth
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_setsync
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_calc_geometry
parameter_list|(
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
parameter_list|,
name|int
name|extended
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mpt_reply_handler_t
name|mpt_scsi_reply_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_reply_handler_t
name|mpt_scsi_tmf_reply_handler
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mpt_scsi_reply_frame_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_bus_reset
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
comment|/*sleep_ok*/
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_spawn_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_terminate_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_recovery_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_scsi_send_tmf
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|u_int
comment|/*type*/
parameter_list|,
name|u_int
comment|/*flags*/
parameter_list|,
name|u_int
comment|/*channel*/
parameter_list|,
name|u_int
comment|/*target*/
parameter_list|,
name|u_int
comment|/*lun*/
parameter_list|,
name|u_int
comment|/*abort_ctx*/
parameter_list|,
name|int
comment|/*sleep_ok*/
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_recover_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uint32_t
name|scsi_io_handler_id
init|=
name|MPT_HANDLER_ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|scsi_tmf_handler_id
init|=
name|MPT_HANDLER_ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_probe_handler_t
name|mpt_cam_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_attach_handler_t
name|mpt_cam_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_event_handler_t
name|mpt_cam_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_reset_handler_t
name|mpt_cam_ioc_reset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_detach_handler_t
name|mpt_cam_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mpt_personality
name|mpt_cam_personality
init|=
block|{
operator|.
name|name
operator|=
literal|"mpt_cam"
block|,
operator|.
name|probe
operator|=
name|mpt_cam_probe
block|,
operator|.
name|attach
operator|=
name|mpt_cam_attach
block|,
operator|.
name|event
operator|=
name|mpt_cam_event
block|,
operator|.
name|reset
operator|=
name|mpt_cam_ioc_reset
block|,
operator|.
name|detach
operator|=
name|mpt_cam_detach
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MPT_PERSONALITY
argument_list|(
name|mpt_cam
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mpt_cam_probe
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
comment|/* 	 * Only attach to nodes that support the initiator 	 * role or have RAID physical devices that need 	 * CAM pass-thru support. 	 */
if|if
condition|(
operator|(
name|mpt
operator|->
name|mpt_proto_flags
operator|&
name|MPI_PORTFACTS_PROTOCOL_INITIATOR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mpt
operator|->
name|ioc_page2
operator|!=
name|NULL
operator|&&
name|mpt
operator|->
name|ioc_page2
operator|->
name|MaxPhysDisks
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpt_cam_attach
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|mpt_handler_t
name|handler
decl_stmt|;
name|int
name|maxq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|bus
operator|=
literal|0
expr_stmt|;
name|maxq
operator|=
operator|(
name|mpt
operator|->
name|mpt_global_credits
operator|<
name|MPT_MAX_REQUESTS
argument_list|(
name|mpt
argument_list|)
operator|)
condition|?
name|mpt
operator|->
name|mpt_global_credits
else|:
name|MPT_MAX_REQUESTS
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_reply_handler
expr_stmt|;
name|error
operator|=
name|mpt_register_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
operator|&
name|scsi_io_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_tmf_reply_handler
expr_stmt|;
name|error
operator|=
name|mpt_register_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
operator|&
name|scsi_tmf_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * We keep one request reserved for timeout TMF requests. 	 */
name|mpt
operator|->
name|tmf_req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|tmf_req
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate dedicated TMF request!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Mark the request as free even though not on the free list. 	 * There is only one TMF request allowed to be outstanding at 	 * a time and the TMF routines perform their own allocation 	 * tracking using the standard state flags. 	 */
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
name|maxq
operator|--
expr_stmt|;
if|if
condition|(
name|mpt_spawn_recovery_thread
argument_list|(
name|mpt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to spawn recovery thread!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|maxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate CAM SIMQ!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Construct our SIM entry. 	 */
name|mpt
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|mpt_action
argument_list|,
name|mpt_poll
argument_list|,
literal|"mpt"
argument_list|,
name|mpt
argument_list|,
name|mpt
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|maxq
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate CAM SIM!\n"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Register exactly the bus. 	 */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Bus registration Failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate Path!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Only register a second bus for RAID physical 	 * devices if the controller supports RAID. 	 */
if|if
condition|(
name|mpt
operator|->
name|ioc_page2
operator|==
name|NULL
operator|||
name|mpt
operator|->
name|ioc_page2
operator|->
name|MaxPhysDisks
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Create a "bus" to export all hidden disks to CAM. 	 */
name|mpt
operator|->
name|phydisk_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|mpt_action
argument_list|,
name|mpt_poll
argument_list|,
literal|"mpt"
argument_list|,
name|mpt
argument_list|,
name|mpt
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|maxq
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|phydisk_sim
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate Physical Disk CAM SIM!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Register exactly the bus. 	 */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|,
literal|1
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Physical Disk Bus registration Failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|mpt
operator|->
name|phydisk_path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate Physical Disk Path!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_cam_detach
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mpt_cam_detach
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|mpt_handler_t
name|handler
decl_stmt|;
name|mpt_terminate_recovery_thread
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_reply_handler
expr_stmt|;
name|mpt_deregister_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
name|scsi_io_handler_id
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_tmf_reply_handler
expr_stmt|;
name|mpt_deregister_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
name|scsi_tmf_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|tmf_req
operator|!=
name|NULL
condition|)
block|{
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|tmf_req
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|mpt
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|sim
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|phydisk_sim
operator|!=
name|NULL
condition|)
block|{
name|xpt_free_path
argument_list|(
name|mpt
operator|->
name|phydisk_path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|phydisk_sim
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is used after a system crash to dump core onto the  * swap device.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|mpt
operator|=
operator|(
expr|struct
name|mpt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_intr
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog timeout routine for SCSI requests.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|request_t
modifier|*
name|req
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTYET
name|mpt
operator|=
name|mpt_find_softc
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|==
name|NULL
condition|)
return|return;
else|#
directive|else
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
endif|#
directive|endif
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|req
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
expr_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Request %p Timed out.\n"
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_QUEUED
operator|)
operator|==
name|REQ_STATE_QUEUED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_TIMEDOUT
expr_stmt|;
name|mpt_wakeup_recovery_thread
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback routine from "bus_dmamap_load" or, in simple cases, called directly.  *  * Takes a list of physical segments and builds the SGL for SCSI IO command  * and forwards the commard to the IOC after one last check that CAM has not  * aborted the transaction.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_execute_req
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|,
modifier|*
name|trq
decl_stmt|;
name|char
modifier|*
name|mpt_off
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|int
name|seg
decl_stmt|,
name|first_lim
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|nxt_off
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|MSG_SCSI_IO_REQUEST
modifier|*
name|mpt_req
decl_stmt|;
name|SGE_SIMPLE64
modifier|*
name|se
decl_stmt|;
name|SGE_CHAIN64
modifier|*
name|ce
decl_stmt|;
name|req
operator|=
operator|(
name|request_t
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
name|req
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
expr_stmt|;
name|mpt_req
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|mpt_off
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
operator|(
name|uint32_t
operator|)
name|nseg
operator|)
operator|>=
name|mpt
operator|->
name|max_seg_cnt
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
operator|&&
name|error
operator|!=
name|ENOMEM
condition|)
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_execute_req: err %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_QFRZN
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_TOO_BIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * No data to transfer? 	 * Just make a single simple SGL with zero length. 	 */
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|tidx
init|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpt_req
operator|->
name|SGL
operator|)
operator|-
name|mpt_off
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mpt_off
index|[
name|tidx
index|]
argument_list|,
literal|0xff
argument_list|,
name|MPT_REQUEST_AREA
operator|-
name|tidx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|SGE_SIMPLE32
modifier|*
name|se1
init|=
operator|(
name|SGE_SIMPLE32
operator|*
operator|)
operator|&
name|mpt_req
operator|->
name|SGL
decl_stmt|;
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se1
argument_list|,
operator|(
name|MPI_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_LIST
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mpt_req
operator|->
name|DataLength
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|flags
operator|=
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
name|flags
operator||=
name|MPI_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_SG_LIST_PHYS
operator||
name|CAM_DATA_PHYS
operator|)
operator|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Okay, fill in what we can at the end of the command frame. 	 * If we have up to MPT_NSGL_FIRST, we can fit them all into 	 * the command frame. 	 * 	 * Otherwise, we fill up through MPT_NSGL_FIRST less one 	 * SIMPLE64 pointers and start doing CHAIN64 entries after 	 * that. 	 */
if|if
condition|(
name|nseg
operator|<
name|MPT_NSGL_FIRST
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
name|first_lim
operator|=
name|nseg
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Leave room for CHAIN element 		 */
name|first_lim
operator|=
name|MPT_NSGL_FIRST
argument_list|(
name|mpt
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|se
operator|=
operator|(
name|SGE_SIMPLE64
operator|*
operator|)
operator|&
name|mpt_req
operator|->
name|SGL
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|first_lim
condition|;
name|seg
operator|++
operator|,
name|se
operator|++
operator|,
name|dm_segs
operator|++
control|)
block|{
name|uint32_t
name|tf
decl_stmt|;
name|bzero
argument_list|(
name|se
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|Address
operator|.
name|Low
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|se
operator|->
name|Address
operator|.
name|High
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|dm_segs
operator|->
name|ds_addr
operator|)
operator|>>
literal|32
expr_stmt|;
block|}
name|MPI_pSGE_SET_LENGTH
argument_list|(
name|se
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tf
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|first_lim
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Tell the IOC where to find the first chain element. 	 */
name|mpt_req
operator|->
name|ChainOffset
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|se
operator|-
operator|(
name|char
operator|*
operator|)
name|mpt_req
operator|)
operator|>>
literal|2
expr_stmt|;
name|nxt_off
operator|=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|trq
operator|=
name|req
expr_stmt|;
comment|/* 	 * Make up the rest of the data segments out of a chain element 	 * (contiained in the current request frame) which points to 	 * SIMPLE64 elements in the next request frame, possibly ending 	 * with *another* chain element (if there's more). 	 */
while|while
condition|(
name|seg
operator|<
name|nseg
condition|)
block|{
name|int
name|this_seg_lim
decl_stmt|;
name|uint32_t
name|tf
decl_stmt|,
name|cur_off
decl_stmt|;
name|bus_addr_t
name|chain_list_addr
decl_stmt|;
comment|/* 		 * Point to the chain descriptor. Note that the chain 		 * descriptor is at the end of the *previous* list (whether 		 * chain or simple). 		 */
name|ce
operator|=
operator|(
name|SGE_CHAIN64
operator|*
operator|)
name|se
expr_stmt|;
comment|/* 		 * Before we change our current pointer, make  sure we won't 		 * overflow the request area with this frame. Note that we 		 * test against 'greater than' here as it's okay in this case 		 * to have next offset be just outside the request area. 		 */
if|if
condition|(
operator|(
name|nxt_off
operator|+
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
operator|)
operator|>
name|MPT_REQUEST_AREA
condition|)
block|{
name|nxt_off
operator|=
name|MPT_REQUEST_AREA
expr_stmt|;
goto|goto
name|next_chain
goto|;
block|}
comment|/* 		 * Set our SGE element pointer to the beginning of the chain 		 * list and update our next chain list offset. 		 */
name|se
operator|=
operator|(
name|SGE_SIMPLE64
operator|*
operator|)
operator|&
name|mpt_off
index|[
name|nxt_off
index|]
expr_stmt|;
name|cur_off
operator|=
name|nxt_off
expr_stmt|;
name|nxt_off
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 		 * Now initialized the chain descriptor. 		 */
name|bzero
argument_list|(
name|ce
argument_list|,
sizeof|sizeof
argument_list|(
name|SGE_CHAIN64
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Get the physical address of the chain list. 		 */
name|chain_list_addr
operator|=
name|trq
operator|->
name|req_pbuf
expr_stmt|;
name|chain_list_addr
operator|+=
name|cur_off
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|ce
operator|->
name|Address
operator|.
name|High
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|chain_list_addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|ce
operator|->
name|Address
operator|.
name|Low
operator|=
operator|(
name|uint32_t
operator|)
name|chain_list_addr
expr_stmt|;
name|ce
operator|->
name|Flags
operator|=
name|MPI_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
comment|/* 		 * If we have more than a frame's worth of segments left, 		 * set up the chain list to have the last element be another 		 * chain descriptor. 		 */
if|if
condition|(
operator|(
name|nseg
operator|-
name|seg
operator|)
operator|>
name|MPT_NSGL
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
name|this_seg_lim
operator|=
name|seg
operator|+
name|MPT_NSGL
argument_list|(
name|mpt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * The length of the chain is the length in bytes of the 			 * number of segments plus the next chain element. 			 * 			 * The next chain descriptor offset is the length, 			 * in words, of the number of segments. 			 */
name|ce
operator|->
name|Length
operator|=
operator|(
name|this_seg_lim
operator|-
name|seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SGE_SIMPLE64
argument_list|)
expr_stmt|;
name|ce
operator|->
name|NextChainOffset
operator|=
name|ce
operator|->
name|Length
operator|>>
literal|2
expr_stmt|;
name|ce
operator|->
name|Length
operator|+=
sizeof|sizeof
argument_list|(
name|SGE_CHAIN64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this_seg_lim
operator|=
name|nseg
expr_stmt|;
name|ce
operator|->
name|Length
operator|=
operator|(
name|this_seg_lim
operator|-
name|seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SGE_SIMPLE64
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fill in the chain list SGE elements with our segment data. 		 * 		 * If we're the last element in this chain list, set the last 		 * element flag. If we're the completely last element period, 		 * set the end of list and end of buffer flags. 		 */
while|while
condition|(
name|seg
operator|<
name|this_seg_lim
condition|)
block|{
name|bzero
argument_list|(
name|se
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|Address
operator|.
name|Low
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|se
operator|->
name|Address
operator|.
name|High
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|dm_segs
operator|->
name|ds_addr
operator|)
operator|>>
literal|32
expr_stmt|;
block|}
name|MPI_pSGE_SET_LENGTH
argument_list|(
name|se
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tf
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|this_seg_lim
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|se
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|next_chain
label|:
comment|/* 		 * If we have more segments to do and we've used up all of 		 * the space in a request area, go allocate another one 		 * and chain to that. 		 */
if|if
condition|(
name|seg
operator|<
name|nseg
operator|&&
name|nxt_off
operator|>=
name|MPT_REQUEST_AREA
condition|)
block|{
name|request_t
modifier|*
name|nrq
init|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * Append the new request area on the tail of our list. 			 */
if|if
condition|(
operator|(
name|trq
operator|=
name|req
operator|->
name|chain
operator|)
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|chain
operator|=
name|nrq
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|trq
operator|->
name|chain
operator|!=
name|NULL
condition|)
block|{
name|trq
operator|=
name|trq
operator|->
name|chain
expr_stmt|;
block|}
name|trq
operator|->
name|chain
operator|=
name|nrq
expr_stmt|;
block|}
name|trq
operator|=
name|nrq
expr_stmt|;
name|mpt_off
operator|=
name|trq
operator|->
name|req_vbuf
expr_stmt|;
name|mpt_req
operator|=
name|trq
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|memset
argument_list|(
name|mpt_off
argument_list|,
literal|0xff
argument_list|,
name|MPT_REQUEST_AREA
argument_list|)
expr_stmt|;
block|}
name|nxt_off
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
label|:
comment|/* 	 * Last time we need to check if this CCB needs to be aborted. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|mpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_handle_init
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|nc
init|=
literal|0
decl_stmt|;
name|mpt_print_scsi_io_request
argument_list|(
name|req
operator|->
name|req_vbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|trq
operator|=
name|req
operator|->
name|chain
init|;
name|trq
condition|;
name|trq
operator|=
name|trq
operator|->
name|chain
control|)
block|{
name|printf
argument_list|(
literal|"  Additional Chain Area %d\n"
argument_list|,
name|nc
operator|++
argument_list|)
expr_stmt|;
name|mpt_dump_sgl
argument_list|(
name|trq
operator|->
name|req_vbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_start
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|MSG_SCSI_IO_REQUEST
modifier|*
name|mpt_req
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|int
name|raid_passthru
decl_stmt|;
comment|/* Get the pointer for the physical addapter */
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
name|raid_passthru
operator|=
operator|(
name|sim
operator|==
name|mpt
operator|->
name|phydisk_sim
operator|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* Get a request structure off the free list */
if|if
condition|(
operator|(
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|COWWWWW 	if (raid_passthru) { 		status = mpt_raid_quiesce_disk(mpt, mpt->raid_disks + ccb->ccb_h.target_id, 		     request_t *req) 	}
endif|#
directive|endif
comment|/* 	 * Link the ccb and the request structure so we can find 	 * the other knowing either the request or the ccb 	 */
name|req
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
operator|=
name|req
expr_stmt|;
comment|/* Now we build the command for the IOC */
name|mpt_req
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|bzero
argument_list|(
name|mpt_req
argument_list|,
sizeof|sizeof
expr|*
name|mpt_req
argument_list|)
expr_stmt|;
name|mpt_req
operator|->
name|Function
operator|=
name|MPI_FUNCTION_SCSI_IO_REQUEST
expr_stmt|;
if|if
condition|(
name|raid_passthru
condition|)
name|mpt_req
operator|->
name|Function
operator|=
name|MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
expr_stmt|;
name|mpt_req
operator|->
name|Bus
operator|=
name|mpt
operator|->
name|bus
expr_stmt|;
name|mpt_req
operator|->
name|SenseBufferLength
operator|=
operator|(
name|csio
operator|->
name|sense_len
operator|<
name|MPT_SENSE_SIZE
operator|)
condition|?
name|csio
operator|->
name|sense_len
else|:
name|MPT_SENSE_SIZE
expr_stmt|;
comment|/* 	 * We use the message context to find the request structure when we 	 * Get the command completion interrupt from the IOC. 	 */
name|mpt_req
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|scsi_io_handler_id
argument_list|)
expr_stmt|;
comment|/* Which physical device to do the I/O on */
name|mpt_req
operator|->
name|TargetID
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* 	 * XXX Assumes Single level, Single byte, CAM LUN type. 	 */
name|mpt_req
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
comment|/* Set the direction of the transfer */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|mpt_req
operator|->
name|Control
operator|=
name|MPI_SCSIIO_CONTROL_READ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
name|mpt_req
operator|->
name|Control
operator|=
name|MPI_SCSIIO_CONTROL_WRITE
expr_stmt|;
else|else
name|mpt_req
operator|->
name|Control
operator|=
name|MPI_SCSIIO_CONTROL_NODATATRANSFER
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|tag_action
condition|)
block|{
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_HEADOFQ
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_ACAQ
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_ORDEREDQ
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_Q_TAG
case|:
default|default:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_SIMPLEQ
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_SIMPLEQ
expr_stmt|;
else|else
comment|/* XXX No such thing for a target doing packetized. */
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_UNTAGGED
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|==
literal|0
operator|&&
name|mpt
operator|->
name|is_sas
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
condition|)
block|{
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_NO_DISCONNECT
expr_stmt|;
block|}
block|}
comment|/* Copy the scsi command block into place */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|mpt_req
operator|->
name|CDB
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|mpt_req
operator|->
name|CDB
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
name|mpt_req
operator|->
name|CDBLength
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
name|mpt_req
operator|->
name|DataLength
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|mpt_req
operator|->
name|SenseBufferLowAddr
operator|=
name|req
operator|->
name|sense_pbuf
expr_stmt|;
comment|/* 	 * If we have any data to send with this command, 	 * map it into bus space. 	 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We've been given a pointer to a single buffer. 			 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Virtual address that needs to translated into 				 * one or more physical address ranges. 				 */
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|mpt_execute_req
argument_list|,
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * We have been given a pointer to single 				 * physical buffer. 				 */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|mpt_execute_req
argument_list|(
name|req
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We have been given a list of addresses. 			 * This case could be easily supported but they are not 			 * currently generated by the CAM subsystem so there 			 * is no point in wasting the time right now. 			 */
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|mpt_execute_req
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|mpt_execute_req
argument_list|(
name|req
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|mpt_execute_req
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_bus_reset
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|error
operator|=
name|mpt_scsi_send_tmf
argument_list|(
name|mpt
argument_list|,
name|MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS
argument_list|,
name|mpt
operator|->
name|is_fc
condition|?
name|MPI_SCSITASKMGMT_MSGFLAGS_LIP_RESET_OPTION
else|:
literal|0
argument_list|,
comment|/*bus*/
literal|0
argument_list|,
comment|/*target_id*/
literal|0
argument_list|,
comment|/*target_lun*/
literal|0
argument_list|,
comment|/*abort_ctx*/
literal|0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * mpt_scsi_send_tmf hard resets on failure, so no 		 * need to do so here. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: mpt_scsi_send_tmf returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Wait for bus reset to be processed by the IOC. */
name|error
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|sleep_ok
argument_list|,
comment|/*time_ms*/
literal|5000
argument_list|)
expr_stmt|;
name|status
operator|=
name|mpt
operator|->
name|tmf_req
operator|->
name|IOCStatus
expr_stmt|;
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: Reset timed-out."
literal|"Resetting controller.\n"
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|MPI_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI_SCSI_STATUS_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: TMF Status %d."
literal|"Resetting controller.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_cam_event
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_EVENT_NOTIFY_REPLY
modifier|*
name|msg
parameter_list|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_ALWAYS
argument_list|,
literal|"mpt_cam_event: 0x%x\n"
argument_list|,
name|msg
operator|->
name|Event
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|Event
operator|&
literal|0xFF
condition|)
block|{
case|case
name|MPI_EVENT_UNIT_ATTENTION
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Bus: 0x%02x TargetID: 0x%02x\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_IOC_BUS_RESET
case|:
comment|/* We generated a bus reset */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"IOC Bus Reset Port: %d\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_EXT_BUS_RESET
case|:
comment|/* Someone else generated a bus reset */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Ext Bus Reset\n"
argument_list|)
expr_stmt|;
comment|/* 		 * These replies don't return EventData like the MPI 		 * spec says they do 		 */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_RESCAN
case|:
comment|/* 		 * In general this means a device has been added 		 * to the loop. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Rescan Port: %d\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/*		xpt_async(AC_FOUND_DEVICE, path, NULL);  */
break|break;
case|case
name|MPI_EVENT_LINK_STATUS_CHANGE
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port %d: LinkState: %s\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"Failed"
else|:
literal|"Active"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_LOOP_STATE_CHANGE
case|:
switch|switch
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x01
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: LIP(%02x,%02x) "
literal|"(Loop Initialization)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0xF7
case|:
if|if
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0xF7
condition|)
block|{
name|printf
argument_list|(
literal|"Device needs AL_PA\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Device %02lx doesn't like "
literal|"FC performance\n"
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0xF8
case|:
if|if
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0xF7
condition|)
block|{
name|printf
argument_list|(
literal|"Device had loop failure at its "
literal|"receiver prior to acquiring "
literal|"AL_PA\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Device %02lx detected loop "
literal|"failure at its receiver\n"
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Device %02lx requests that device "
literal|"%02lx reset itself\n"
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x02
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: "
literal|"LPE(%02x,%02x) (Loop Port Enable)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Port */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Character 3 */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
comment|/* Character 4 */
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: "
literal|"LPB(%02x,%02x) (Loop Port Bypass)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Port */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Character 3 */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
comment|/* Character 4 */
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: Unknown "
literal|"FC event (%02x %02x %02x)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Port */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Event */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Character 3 */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
comment|/* Character 4 */
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MPI_EVENT_LOGOUT
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"FC Logout Port: %d N_PortID: %02x\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_EVENT_CHANGE
case|:
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"mpt_cam_event: MPI_EVENT_EVENT_CHANGE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_SAS_DEVICE_STATUS_CHANGE
case|:
comment|/* 		 * Devices are attachin'..... 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_cam_event: MPI_EVENT_SAS_DEVICE_STATUS_CHANGE\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
comment|/*handled*/
literal|0
operator|)
return|;
block|}
return|return
operator|(
comment|/*handled*/
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reply path for all SCSI I/O requests, called from our  * interrupt handler by extracting our handler index from  * the MsgContext field of the reply from the IOC.  *  * This routine is optimized for the common case of a  * completion without error.  All exception handling is  * offloaded to non-inlined helper routines to minimize  * cache footprint.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_scsi_reply_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|MSG_SCSI_IO_REQUEST
modifier|*
name|scsi_req
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|scsi_req
operator|=
operator|(
name|MSG_SCSI_IO_REQUEST
operator|*
operator|)
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Completion without CCB. Flags %#x, Func %#x\n"
argument_list|,
name|req
operator|->
name|state
argument_list|,
name|scsi_req
operator|->
name|Function
argument_list|)
expr_stmt|;
name|mpt_print_scsi_io_request
argument_list|(
name|scsi_req
argument_list|)
expr_stmt|;
return|return
operator|(
comment|/*free_reply*/
name|TRUE
operator|)
return|;
block|}
name|untimeout
argument_list|(
name|mpt_timeout
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply_frame
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Context only reply, completion 		 * without error status. 		 */
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
block|}
else|else
block|{
name|mpt_scsi_reply_frame_handler
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|reply_frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|outofbeer
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|mpt
operator|->
name|outofbeer
operator|=
literal|0
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"THAWQ\n"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_req
operator|->
name|Function
operator|==
name|MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
operator|&&
name|scsi_req
operator|->
name|CDB
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|&&
operator|(
name|scsi_req
operator|->
name|CDB
index|[
literal|1
index|]
operator|&
name|SI_EVPD
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
comment|/* 		 * Fake out the device type so that only the 		 * pass-thru device will attach. 		 */
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|inq
operator|->
name|device
operator|&=
operator|~
literal|0x1F
expr_stmt|;
name|inq
operator|->
name|device
operator||=
name|T_NODEVICE
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_TIMEDOUT
operator|)
operator|==
literal|0
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|else
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_NEED_WAKEUP
operator|)
operator|==
literal|0
condition|)
block|{
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
comment|/*free_reply*/
name|TRUE
operator|)
return|;
block|}
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
comment|/*free_reply*/
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_scsi_tmf_reply_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|MSG_SCSI_TASK_MGMT_REPLY
modifier|*
name|tmf_reply
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"TMF Complete: req %p, reply %p\n"
argument_list|,
name|req
argument_list|,
name|reply_frame
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|req
operator|==
name|mpt
operator|->
name|tmf_req
argument_list|,
operator|(
literal|"TMF Reply not using mpt->tmf_req"
operator|)
argument_list|)
expr_stmt|;
name|tmf_reply
operator|=
operator|(
name|MSG_SCSI_TASK_MGMT_REPLY
operator|*
operator|)
name|reply_frame
expr_stmt|;
comment|/* Record status of TMF for any waiters. */
name|req
operator|->
name|IOCStatus
operator|=
name|tmf_reply
operator|->
name|IOCStatus
expr_stmt|;
name|status
operator|=
name|le16toh
argument_list|(
name|tmf_reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"TMF Complete: status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_NEED_WAKEUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
return|return
operator|(
comment|/*free_reply*/
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up all SCSI Initiator personality state in response  * to a controller reset.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_cam_ioc_reset
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|type
parameter_list|)
block|{
comment|/* 	 * The pending list is already run down by 	 * the generic handler.  Perform the same 	 * operation on the timed out request list. 	 */
name|mpt_complete_request_chain
argument_list|(
name|mpt
argument_list|,
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|MPI_IOCSTATUS_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* 	 * Inform the XPT that a bus reset has occurred. 	 */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse additional completion information in the reply  * frame for SCSI I/O requests.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_scsi_reply_frame_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|MSG_SCSI_IO_REPLY
modifier|*
name|scsi_io_reply
decl_stmt|;
name|u_int
name|ioc_status
decl_stmt|;
name|u_int
name|sstate
decl_stmt|;
name|u_int
name|loginfo
decl_stmt|;
name|MPT_DUMP_REPLY_FRAME
argument_list|(
name|mpt
argument_list|,
name|reply_frame
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|reply_frame
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
operator|||
name|reply_frame
operator|->
name|Function
operator|==
name|MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
argument_list|,
operator|(
literal|"MPT SCSI I/O Handler called with incorrect reply type"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|reply_frame
operator|->
name|MsgFlags
operator|&
name|MPI_MSGFLAGS_CONTINUATION_REPLY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"MPT SCSI I/O Handler called with continuation reply"
operator|)
argument_list|)
expr_stmt|;
name|scsi_io_reply
operator|=
operator|(
name|MSG_SCSI_IO_REPLY
operator|*
operator|)
name|reply_frame
expr_stmt|;
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|scsi_io_reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
name|loginfo
operator|=
name|ioc_status
operator|&
name|MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE
expr_stmt|;
name|ioc_status
operator|&=
name|MPI_IOCSTATUS_MASK
expr_stmt|;
name|sstate
operator|=
name|scsi_io_reply
operator|->
name|SCSIState
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|le32toh
argument_list|(
name|scsi_io_reply
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_AUTOSENSE_VALID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_SENSE_PHYS
operator||
name|CAM_SENSE_PTR
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|scsi_io_reply
operator|->
name|SenseCount
expr_stmt|;
name|bcopy
argument_list|(
name|req
operator|->
name|sense_vbuf
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|min
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|,
name|scsi_io_reply
operator|->
name|SenseCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_QUEUE_TAG_REJECTED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Tag messages rejected, but non-tagged retry 		 * was successful. XXXX 		mpt_set_tags(mpt, devinfo, MPT_QUEUE_NONE); 		 */
block|}
switch|switch
condition|(
name|ioc_status
condition|)
block|{
case|case
name|MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH
case|:
comment|/* 		 * XXX 		 * Linux driver indicates that a zero 		 * transfer length with this error code 		 * indicates a CRC error. 		 * 		 * No need to swap the bytes for checking 		 * against zero. 		 */
if|if
condition|(
name|scsi_io_reply
operator|->
name|TransferCount
operator|==
literal|0
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_UNCOR_PARITY
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MPI_IOCSTATUS_SCSI_DATA_UNDERRUN
case|:
case|case
name|MPI_IOCSTATUS_SUCCESS
case|:
case|case
name|MPI_IOCSTATUS_SCSI_RECOVERED_ERROR
case|:
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_NO_SCSI_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Status was never returned for this transaction. 			 */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi_io_reply
operator|->
name|SCSIStatus
operator|!=
name|SCSI_STATUS_OK
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|scsi_io_reply
operator|->
name|SCSIStatus
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_SCSI_STATUS_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_AUTOSENSE_FAILED
operator|)
operator|!=
literal|0
condition|)
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_RESPONSE_INFO_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX Handle SPI-Packet and FCP-2 reponse info. */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
block|}
else|else
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_DATA_OVERRUN
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_IO_DATA_ERROR
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_UNCOR_PARITY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE
case|:
comment|/* 		 * Since selection timeouts and "device really not 		 * there" are grouped into this error code, report 		 * selection timeout.  Selection timeouts are 		 * typically retried before giving up on the device 		 * whereas "device not there" errors are considered 		 * unretryable. 		 */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_SEQUENCE_FAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_INVALID_BUS
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_PATH_INVALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_INVALID_TARGETID
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_TID_INVALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_TERMIO
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_INVALID_STATE
case|:
comment|/* 		 * The IOC has been reset.  Emulate a bus reset. 		 */
comment|/* FALLTHROUGH */
case|case
name|MPI_IOCSTATUS_SCSI_EXT_TERMINATED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_TASK_TERMINATED
case|:
case|case
name|MPI_IOCSTATUS_SCSI_IOC_TERMINATED
case|:
comment|/* 		 * Don't clobber any timeout status that has 		 * already been set for this transaction.  We 		 * want the SCSI layer to be able to differentiate 		 * between the command we aborted due to timeout 		 * and any innocent bystanders. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
break|break;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_TERMIO
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_INSUFFICIENT_RESOURCES
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_RESRC_UNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_BUSY
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_BUSY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_INVALID_FUNCTION
case|:
case|case
name|MPI_IOCSTATUS_INVALID_SGL
case|:
case|case
name|MPI_IOCSTATUS_INTERNAL_ERROR
case|:
case|case
name|MPI_IOCSTATUS_INVALID_FIELD
case|:
default|default:
comment|/* XXX 		 * Some of the above may need to kick 		 * of a recovery action!!!! 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNREC_HBA_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|mpt_freeze_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
comment|/*free_reply*/
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|u_int
name|tgt
decl_stmt|;
name|int
name|raid_passthru
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"mpt_action\n"
operator|)
argument_list|)
expr_stmt|;
name|mpt
operator|=
operator|(
expr|struct
name|mpt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|raid_passthru
operator|=
operator|(
name|sim
operator|==
name|mpt
operator|->
name|phydisk_sim
operator|)
expr_stmt|;
name|tgt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
if|if
condition|(
name|raid_passthru
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_PATH_INQ
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_RESET_BUS
condition|)
block|{
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt_map_physdisk
argument_list|(
name|mpt
argument_list|,
name|ccb
argument_list|,
operator|&
name|tgt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
operator|=
name|mpt
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
comment|/* 		 * Do a couple of preliminary checks... 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Max supported CDB length is 16 bytes */
comment|/* XXX Unless we implement the new 32byte message type */
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|PTR_MSG_SCSI_IO_REQUEST
operator|)
literal|0
operator|)
operator|->
name|CDB
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|mpt_start
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_RESET_BUS
case|:
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"XPT_RESET_BUS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|raid_passthru
condition|)
block|{
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mpt_bus_reset
argument_list|(
name|mpt
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * mpt_bus_reset is always successful in that it 		 * will fall back to a hard reset should a bus 		 * reset attempt fail. 		 */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ABORT
case|:
comment|/* 		 * XXX: Need to implement 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
define|#
directive|define
name|IS_CURRENT_SETTINGS
parameter_list|(
name|c
parameter_list|)
value|(c->type == CTS_TYPE_CURRENT_SETTINGS)
else|#
directive|else
define|#
directive|define
name|IS_CURRENT_SETTINGS
parameter_list|(
name|c
parameter_list|)
value|(c->flags& CCB_TRANS_CURRENT_SETTINGS)
endif|#
directive|endif
define|#
directive|define
name|DP_DISC_ENABLE
value|0x1
define|#
directive|define
name|DP_DISC_DISABL
value|0x2
define|#
directive|define
name|DP_DISC
value|(DP_DISC_ENABLE|DP_DISC_DISABL)
define|#
directive|define
name|DP_TQING_ENABLE
value|0x4
define|#
directive|define
name|DP_TQING_DISABL
value|0x8
define|#
directive|define
name|DP_TQING
value|(DP_TQING_ENABLE|DP_TQING_DISABL)
define|#
directive|define
name|DP_WIDE
value|0x10
define|#
directive|define
name|DP_NARROW
value|0x20
define|#
directive|define
name|DP_WIDTH
value|(DP_WIDE|DP_NARROW)
define|#
directive|define
name|DP_SYNC
value|0x40
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* Nexus Settings */
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Attempt to set User settings\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|==
literal|0
operator|&&
name|mpt
operator|->
name|is_sas
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|dval
init|=
literal|0
decl_stmt|;
name|u_int
name|period
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
condition|)
block|{
name|dval
operator||=
name|DP_DISC_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
condition|)
block|{
name|dval
operator||=
name|DP_TQING_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
condition|)
block|{
if|if
condition|(
name|cts
operator|->
name|bus_width
condition|)
name|dval
operator||=
name|DP_WIDE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_NARROW
expr_stmt|;
block|}
comment|/* 			 * Any SYNC RATE of nonzero and SYNC_OFFSET 			 * of nonzero will cause us to go to the 			 * selected (from NVRAM) maximum value for 			 * this device. At a later point, we'll 			 * allow finer control. 			 */
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|&&
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_SYNC
expr_stmt|;
name|period
operator|=
name|cts
operator|->
name|sync_period
expr_stmt|;
name|offset
operator|=
name|cts
operator|->
name|sync_offset
expr_stmt|;
block|}
else|#
directive|else
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|dval
operator||=
name|DP_DISC_ENABLE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_DISC_DISABL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|dval
operator||=
name|DP_TQING_ENABLE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_TQING_DISABL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|==
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|dval
operator||=
name|DP_WIDE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_NARROW
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|&&
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|&&
operator|(
name|spi
operator|->
name|sync_period
operator|&&
name|spi
operator|->
name|sync_offset
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_SYNC
expr_stmt|;
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
block|}
endif|#
directive|endif
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_DISC_ENABLE
condition|)
block|{
name|mpt
operator|->
name|mpt_disc_enable
operator||=
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dval
operator|&
name|DP_DISC_DISABL
condition|)
block|{
name|mpt
operator|->
name|mpt_disc_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_TQING_ENABLE
condition|)
block|{
name|mpt
operator|->
name|mpt_tag_enable
operator||=
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dval
operator|&
name|DP_TQING_DISABL
condition|)
block|{
name|mpt
operator|->
name|mpt_tag_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_WIDTH
condition|)
block|{
if|if
condition|(
name|mpt_setwidth
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
name|dval
operator|&
name|DP_WIDE
argument_list|)
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Set width Failed!\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dval
operator|&
name|DP_SYNC
condition|)
block|{
if|if
condition|(
name|mpt_setsync
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Set sync Failed!\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SET tgt %d flags %x period %x off %x\n"
argument_list|,
name|tgt
argument_list|,
name|dval
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
comment|/* 			 * a lot of normal SCSI things don't make sense. 			 */
name|cts
operator|->
name|flags
operator|=
name|CCB_TRANS_TAG_ENB
operator||
name|CCB_TRANS_DISC_ENB
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
comment|/* 			 * How do you measure the width of a high 			 * speed serial bus? Well, in bytes. 			 * 			 * Offset and period make no sense, though, so we set 			 * (above) a 'base' transfer speed to be gigabit. 			 */
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
else|#
directive|else
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|fc
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_FC
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|fc
operator|->
name|valid
operator|=
name|CTS_FC_VALID_SPEED
expr_stmt|;
name|fc
operator|->
name|bitrate
operator|=
literal|100000
expr_stmt|;
comment|/* XXX: Need for 2Gb/s */
comment|/* XXX: need a port database for each target */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
name|cts
operator|->
name|flags
operator|=
name|CCB_TRANS_TAG_ENB
operator||
name|CCB_TRANS_DISC_ENB
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
comment|/* 			 * How do you measure the width of a high 			 * speed serial bus? Well, in bytes. 			 * 			 * Offset and period make no sense, though, so we set 			 * (above) a 'base' transfer speed to be gigabit. 			 */
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
else|#
directive|else
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|sas
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_3
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|sas
operator|->
name|valid
operator|=
name|CTS_SAS_VALID_SPEED
expr_stmt|;
name|sas
operator|->
name|bitrate
operator|=
literal|300000
expr_stmt|;
comment|/* XXX: Default 3Gbps */
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
endif|#
directive|endif
name|uint8_t
name|dval
decl_stmt|,
name|pval
decl_stmt|,
name|oval
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 			 * We aren't going off of Port PAGE2 params for 			 * tagged queuing or disconnect capabilities 			 * for current settings. For goal settings, 			 * we assert all capabilities- we've had some 			 * problems with reading NVRAM data. 			 */
if|if
condition|(
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|)
block|{
name|CONFIG_PAGE_SCSI_DEVICE_0
name|tmp
decl_stmt|;
name|dval
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|tgt
index|]
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|,
comment|/*timeout_ms*/
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"cannot get target %d DP0\n"
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Tgt %d Page 0: NParms %x "
literal|"Information %x\n"
argument_list|,
name|tgt
argument_list|,
name|tmp
operator|.
name|NegotiatedParameters
argument_list|,
name|tmp
operator|.
name|Information
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|NegotiatedParameters
operator|&
name|MPI_SCSIDEVPAGE0_NP_WIDE
condition|)
name|dval
operator||=
name|DP_WIDE
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|mpt_disc_enable
operator|&
operator|(
literal|1
operator|<<
name|tgt
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_DISC_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|mpt_tag_enable
operator|&
operator|(
literal|1
operator|<<
name|tgt
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_TQING_ENABLE
expr_stmt|;
block|}
name|oval
operator|=
operator|(
name|tmp
operator|.
name|NegotiatedParameters
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pval
operator|=
operator|(
name|tmp
operator|.
name|NegotiatedParameters
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX: Fix wrt NVRAM someday. Attempts 				 * XXX: to read port page2 device data 				 * XXX: just returns zero in these areas. 				 */
name|dval
operator|=
name|DP_WIDE
operator||
name|DP_DISC
operator||
name|DP_TQING
expr_stmt|;
name|oval
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|16
operator|)
expr_stmt|;
name|pval
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
name|cts
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_DISC_ENABLE
condition|)
block|{
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_TQING_ENABLE
condition|)
block|{
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_WIDE
condition|)
block|{
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
block|}
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
if|if
condition|(
name|oval
condition|)
block|{
name|cts
operator|->
name|sync_period
operator|=
name|pval
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
name|oval
expr_stmt|;
name|cts
operator|->
name|valid
operator||=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
block|}
else|#
directive|else
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_DISC_ENABLE
condition|)
block|{
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_TQING_ENABLE
condition|)
block|{
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
name|oval
operator|&&
name|pval
condition|)
block|{
name|spi
operator|->
name|sync_offset
operator|=
name|oval
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|pval
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_SYNC_RATE
expr_stmt|;
block|}
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_WIDE
condition|)
block|{
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
else|else
block|{
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
block|}
else|else
block|{
name|scsi
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"GET %s tgt %d flags %x period %x offset %x\n"
argument_list|,
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|?
literal|"ACTIVE"
else|:
literal|"NVRAM"
argument_list|,
name|tgt
argument_list|,
name|dval
argument_list|,
name|pval
argument_list|,
name|oval
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|mpt_calc_geometry
argument_list|(
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
comment|/* XXX Report base speed more accurately for FC/SAS, etc.*/
if|if
condition|(
name|raid_passthru
condition|)
block|{
name|cpi
operator|->
name|max_target
operator|=
name|mpt
operator|->
name|ioc_page2
operator|->
name|MaxPhysDisks
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|cpi
operator|->
name|max_target
operator|+
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|100000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
comment|/* XXX SHOULD BE BASED UPON IOC FACTS XXX */
name|cpi
operator|->
name|max_target
operator|=
literal|255
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|cpi
operator|->
name|max_target
operator|+
literal|1
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|100000
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|cpi
operator|->
name|max_target
operator|=
literal|63
expr_stmt|;
comment|/* XXX */
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|cpi
operator|->
name|max_target
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|mpt
operator|->
name|mpt_ini_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|15
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"LSI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_setwidth
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|tgt
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|CONFIG_PAGE_SCSI_DEVICE_1
name|tmp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|tmp
operator|=
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|tmp
operator|.
name|RequestedParameters
operator||=
name|MPI_SCSIDEVPAGE1_RP_WIDE
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_WIDE
expr_stmt|;
block|}
name|rv
operator|=
name|mpt_write_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|,
comment|/*timeout_ms*/
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_setwidth: write cur page failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|,
comment|/*timeout_ms*/
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_setwidth: read cur page failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|=
name|tmp
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Target %d Page 1: RequestedParameters %x Config %x\n"
argument_list|,
name|tgt
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|.
name|RequestedParameters
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|.
name|Configuration
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_setsync
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|tgt
parameter_list|,
name|int
name|period
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|CONFIG_PAGE_SCSI_DEVICE_1
name|tmp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|tmp
operator|=
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
expr_stmt|;
name|tmp
operator|.
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK
expr_stmt|;
name|tmp
operator|.
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK
expr_stmt|;
name|tmp
operator|.
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_DT
expr_stmt|;
name|tmp
operator|.
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_QAS
expr_stmt|;
name|tmp
operator|.
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_IU
expr_stmt|;
comment|/* 	 * XXX: For now, we're ignoring specific settings 	 */
if|if
condition|(
name|period
operator|&&
name|offset
condition|)
block|{
name|int
name|factor
decl_stmt|,
name|offset
decl_stmt|,
name|np
decl_stmt|;
name|factor
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|offset
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|np
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|factor
operator|<
literal|0x9
condition|)
block|{
name|np
operator||=
name|MPI_SCSIDEVPAGE1_RP_QAS
expr_stmt|;
name|np
operator||=
name|MPI_SCSIDEVPAGE1_RP_IU
expr_stmt|;
block|}
if|if
condition|(
name|factor
operator|<
literal|0xa
condition|)
block|{
name|np
operator||=
name|MPI_SCSIDEVPAGE1_RP_DT
expr_stmt|;
block|}
name|np
operator||=
operator|(
name|factor
operator|<<
literal|8
operator|)
operator||
operator|(
name|offset
operator|<<
literal|16
operator|)
expr_stmt|;
name|tmp
operator|.
name|RequestedParameters
operator||=
name|np
expr_stmt|;
block|}
name|rv
operator|=
name|mpt_write_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|,
comment|/*timeout_ms*/
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_setsync: write cur page failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|,
comment|/*timeout_ms*/
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_setsync: read cur page failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|=
name|tmp
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Target %d Page 1: RParams %x Config %x\n"
argument_list|,
name|tgt
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|.
name|RequestedParameters
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|.
name|Configuration
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_calc_geometry
parameter_list|(
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
parameter_list|,
name|int
name|extended
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|cam_calc_geometry
argument_list|(
name|ccg
argument_list|,
name|extended
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint32_t
name|size_mb
decl_stmt|;
name|uint32_t
name|secs_per_cylinder
decl_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccg
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************** Timeout Recovery ******************************/
end_comment

begin_function
specifier|static
name|int
name|mpt_spawn_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|mpt_kthread_create
argument_list|(
name|mpt_recovery_thread
argument_list|,
name|mpt
argument_list|,
operator|&
name|mpt
operator|->
name|recovery_thread
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*altstack*/
literal|0
argument_list|,
literal|"mpt_recovery%d"
argument_list|,
name|mpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock is not held on entry.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_terminate_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|recovery_thread
operator|==
name|NULL
condition|)
block|{
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
name|mpt
operator|->
name|shutdwn_recovery
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep on a slightly different location 	 * for this interlock just for added safety. 	 */
name|mpt_sleep
argument_list|(
name|mpt
argument_list|,
operator|&
name|mpt
operator|->
name|recovery_thread
argument_list|,
name|PUSER
argument_list|,
literal|"thtrm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_recovery_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpt
operator|=
operator|(
expr|struct
name|mpt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|!=
literal|0
operator|&&
name|mpt
operator|->
name|shutdwn_recovery
operator|==
literal|0
condition|)
name|mpt_sleep
argument_list|(
name|mpt
argument_list|,
name|mpt
argument_list|,
name|PUSER
argument_list|,
literal|"idle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|shutdwn_recovery
operator|!=
literal|0
condition|)
break|break;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_recover_commands
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
name|mpt
operator|->
name|recovery_thread
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|mpt
operator|->
name|recovery_thread
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_scsi_send_tmf
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|u_int
name|type
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|u_int
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|u_int
name|abort_ctx
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|MSG_SCSI_TASK_MGMT
modifier|*
name|tmf_req
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Wait for any current TMF request to complete. 	 * We're only allowed to issue one TMF at a time. 	 */
name|error
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|REQ_STATE_FREE
argument_list|,
name|REQ_STATE_MASK
argument_list|,
name|sleep_ok
argument_list|,
name|MPT_TMF_MAX_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_ALLOCATED
operator||
name|REQ_STATE_QUEUED
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|tmf_req
operator|=
operator|(
name|MSG_SCSI_TASK_MGMT
operator|*
operator|)
name|mpt
operator|->
name|tmf_req
operator|->
name|req_vbuf
expr_stmt|;
name|bzero
argument_list|(
name|tmf_req
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmf_req
argument_list|)
argument_list|)
expr_stmt|;
name|tmf_req
operator|->
name|TargetID
operator|=
name|target
expr_stmt|;
name|tmf_req
operator|->
name|Bus
operator|=
name|channel
expr_stmt|;
name|tmf_req
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
name|tmf_req
operator|->
name|Function
operator|=
name|MPI_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|tmf_req
operator|->
name|Reserved
operator|=
literal|0
expr_stmt|;
name|tmf_req
operator|->
name|TaskType
operator|=
name|type
expr_stmt|;
name|tmf_req
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|tmf_req
operator|->
name|MsgFlags
operator|=
name|flags
expr_stmt|;
name|tmf_req
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|mpt
operator|->
name|tmf_req
operator|->
name|index
operator||
name|scsi_tmf_handler_id
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|tmf_req
operator|->
name|LUN
argument_list|,
sizeof|sizeof
argument_list|(
name|tmf_req
operator|->
name|LUN
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tmf_req
operator|->
name|Reserved2
argument_list|)
argument_list|)
expr_stmt|;
name|tmf_req
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|lun
expr_stmt|;
name|tmf_req
operator|->
name|TaskMsgContext
operator|=
name|abort_ctx
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"Issuing TMF %p with MsgContext of 0x%x\n"
argument_list|,
name|tmf_req
argument_list|,
name|tmf_req
operator|->
name|MsgContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>
name|MPT_PRT_DEBUG
condition|)
name|mpt_print_request
argument_list|(
name|tmf_req
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpt_send_handshake_cmd
argument_list|(
name|mpt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmf_req
argument_list|)
argument_list|,
name|tmf_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a command times out, it is placed on the requeust_timeout_list  * and we wake our recovery thread.  The MPT-Fusion architecture supports  * only a single TMF operation at a time, so we serially abort/bdr, etc,  * the timedout transactions.  The next TMF is issued either by the  * completion handler of the current TMF waking our recovery thread,  * or the TMF timeout handler causing a hard reset sequence.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_recover_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * No work to do- leave. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_recover_commands: no requests.\n"
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Flush any commands whose completion coincides with their timeout. 	 */
name|mpt_intr
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The timedout commands have already 		 * completed.  This typically means 		 * that either the timeout value was on 		 * the hairy edge of what the device 		 * requires or - more likely - interrupts 		 * are not happening. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Timedout requests already complete. "
literal|"Interrupts may not be functioning.\n"
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We have no visibility into the current state of the 	 * controller, so attempt to abort the commands in the 	 * order they timed-out. 	 */
while|while
condition|(
operator|(
name|req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|status
decl_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Attempting to Abort Req %p\n"
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpt_scsi_send_tmf
argument_list|(
name|mpt
argument_list|,
name|MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK
argument_list|,
comment|/*MsgFlags*/
literal|0
argument_list|,
name|mpt
operator|->
name|bus
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|scsi_io_handler_id
argument_list|)
argument_list|,
comment|/*sleep_ok*/
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * mpt_scsi_send_tmf hard resets on failure, so no 			 * need to do so here.  Our queue should be emptied 			 * by the hard reset. 			 */
continue|continue;
block|}
name|error
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|REQ_STATE_DONE
argument_list|,
comment|/*sleep_ok*/
name|TRUE
argument_list|,
comment|/*time_ms*/
literal|500
argument_list|)
expr_stmt|;
name|status
operator|=
name|mpt
operator|->
name|tmf_req
operator|->
name|IOCStatus
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If we've errored out and the transaction is still 			 * pending, reset the controller. 			 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_recover_commands: Abort timed-out. "
literal|"Resetting controller\n"
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
comment|/*reinit*/
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * TMF is complete. 		 */
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MPI_IOCSTATUS_MASK
operator|)
operator|==
name|MPI_SCSI_STATUS_SUCCESS
condition|)
continue|continue;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"mpt_recover_commands: Abort Failed "
literal|"with status 0x%x\n.  Resetting bus"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * If the abort attempt fails for any reason, reset the bus. 		 * We should find all of the timed-out commands on our 		 * list are in the done state after this completes. 		 */
name|mpt_bus_reset
argument_list|(
name|mpt
argument_list|,
comment|/*sleep_ok*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

