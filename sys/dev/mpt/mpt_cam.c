begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * FreeBSD/CAM specific routines for LSI '909 FC  adapters.  * FreeBSD Version.  *  * Copyright (c)  2000, 2001 by Greg Ansley  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2002, 2006 by Matthew Jacob  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon including  *    a substantially similar Disclaimer requirement for further binary  *    redistribution.  * 3. Neither the names of the above listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE COPYRIGHT  * OWNER OR CONTRIBUTOR IS ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Support from Chris Ellsworth in order to make SAS adapters work  * is gratefully acknowledged.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2004, Avid Technology, Inc. and its contributors.  * Copyright (c) 2005, WHEEL Sp. z o.o.  * Copyright (c) 2004, 2005 Justin T. Gibbs  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon including  *    a substantially similar Disclaimer requirement for further binary  *    redistribution.  * 3. Neither the names of the above listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF THE COPYRIGHT  * OWNER OR CONTRIBUTOR IS ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/mpt/mpt.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpt/mpt_cam.h>
end_include

begin_include
include|#
directive|include
file|<dev/mpt/mpt_raid.h>
end_include

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_ioc.h"
end_include

begin_comment
comment|/* XXX Fix Event Handling!!! */
end_comment

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_init.h"
end_include

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_targ.h"
end_include

begin_include
include|#
directive|include
file|"dev/mpt/mpilib/mpi_fc.h"
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_function_decl
specifier|static
name|void
name|mpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|mpt_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_get_spi_settings
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_setwidth
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_setsync
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_update_spi_config
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_calc_geometry
parameter_list|(
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
parameter_list|,
name|int
name|extended
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mpt_reply_handler_t
name|mpt_scsi_reply_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_reply_handler_t
name|mpt_scsi_tmf_reply_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_reply_handler_t
name|mpt_fc_els_reply_handler
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mpt_scsi_reply_frame_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_bus_reset
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_fc_reset_link
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_spawn_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_terminate_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_recovery_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_recover_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_scsi_send_tmf
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_fc_post_els
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_post_target_command
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_add_els_buffers
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_add_target_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_free_els_buffers
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_free_target_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_enable_lun
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|target_id_t
parameter_list|,
name|lun_id_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_disable_lun
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|target_id_t
parameter_list|,
name|lun_id_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_target_start_io
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cam_status
name|mpt_abort_target_ccb
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpt_abort_target_cmd
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_scsi_tgt_status
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|union
name|ccb
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_scsi_tgt_tsk_mgmt
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|,
name|mpt_task_mgmt_t
parameter_list|,
name|tgt_resource_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_tgt_dump_tgt_state
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpt_tgt_dump_req_state
parameter_list|(
name|struct
name|mpt_softc
modifier|*
parameter_list|,
name|request_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|mpt_reply_handler_t
name|mpt_scsi_tgt_reply_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|scsi_io_handler_id
init|=
name|MPT_HANDLER_ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|scsi_tmf_handler_id
init|=
name|MPT_HANDLER_ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fc_els_handler_id
init|=
name|MPT_HANDLER_ID_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_probe_handler_t
name|mpt_cam_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_attach_handler_t
name|mpt_cam_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_enable_handler_t
name|mpt_cam_enable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_event_handler_t
name|mpt_cam_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_reset_handler_t
name|mpt_cam_ioc_reset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpt_detach_handler_t
name|mpt_cam_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mpt_personality
name|mpt_cam_personality
init|=
block|{
operator|.
name|name
operator|=
literal|"mpt_cam"
block|,
operator|.
name|probe
operator|=
name|mpt_cam_probe
block|,
operator|.
name|attach
operator|=
name|mpt_cam_attach
block|,
operator|.
name|enable
operator|=
name|mpt_cam_enable
block|,
operator|.
name|event
operator|=
name|mpt_cam_event
block|,
operator|.
name|reset
operator|=
name|mpt_cam_ioc_reset
block|,
operator|.
name|detach
operator|=
name|mpt_cam_detach
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MPT_PERSONALITY
argument_list|(
name|mpt_cam
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mpt_cam_probe
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
comment|/* 	 * Only attach to nodes that support the initiator or target 	 * role or have RAID physical devices that need CAM pass-thru support. 	 */
if|if
condition|(
operator|(
name|mpt
operator|->
name|mpt_proto_flags
operator|&
name|MPI_PORTFACTS_PROTOCOL_INITIATOR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mpt
operator|->
name|mpt_proto_flags
operator|&
name|MPI_PORTFACTS_PROTOCOL_TARGET
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mpt
operator|->
name|ioc_page2
operator|!=
name|NULL
operator|&&
name|mpt
operator|->
name|ioc_page2
operator|->
name|MaxPhysDisks
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpt_cam_attach
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|mpt_handler_t
name|handler
decl_stmt|;
name|int
name|maxq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
expr_stmt|;
name|maxq
operator|=
operator|(
name|mpt
operator|->
name|mpt_global_credits
operator|<
name|MPT_MAX_REQUESTS
argument_list|(
name|mpt
argument_list|)
operator|)
condition|?
name|mpt
operator|->
name|mpt_global_credits
else|:
name|MPT_MAX_REQUESTS
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_reply_handler
expr_stmt|;
name|error
operator|=
name|mpt_register_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
operator|&
name|scsi_io_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup0
goto|;
block|}
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_tmf_reply_handler
expr_stmt|;
name|error
operator|=
name|mpt_register_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
operator|&
name|scsi_tmf_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup0
goto|;
block|}
comment|/* 	 * If we're fibre channel and could support target mode, we register 	 * an ELS reply handler and give it resources. 	 */
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|&&
operator|(
name|mpt
operator|->
name|role
operator|&
name|MPT_ROLE_TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_fc_els_reply_handler
expr_stmt|;
name|error
operator|=
name|mpt_register_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
operator|&
name|fc_els_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup0
goto|;
block|}
if|if
condition|(
name|mpt_add_els_buffers
argument_list|(
name|mpt
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup0
goto|;
block|}
name|maxq
operator|-=
name|mpt
operator|->
name|els_cmds_allocated
expr_stmt|;
block|}
comment|/* 	 * If we support target mode, we register a reply handler for it, 	 * but don't add resources until we actually enable target mode. 	 */
if|if
condition|(
operator|(
name|mpt
operator|->
name|role
operator|&
name|MPT_ROLE_TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_tgt_reply_handler
expr_stmt|;
name|error
operator|=
name|mpt_register_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
operator|&
name|mpt
operator|->
name|scsi_tgt_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|cleanup0
goto|;
block|}
block|}
comment|/* 	 * We keep one request reserved for timeout TMF requests. 	 */
name|mpt
operator|->
name|tmf_req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|tmf_req
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate dedicated TMF request!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup0
goto|;
block|}
comment|/* 	 * Mark the request as free even though not on the free list. 	 * There is only one TMF request allowed to be outstanding at 	 * a time and the TMF routines perform their own allocation 	 * tracking using the standard state flags. 	 */
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
name|maxq
operator|--
expr_stmt|;
if|if
condition|(
name|mpt_spawn_recovery_thread
argument_list|(
name|mpt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to spawn recovery thread!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup0
goto|;
block|}
comment|/* 	 * The rest of this is CAM foo, for which we need to drop our lock 	 */
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 	 * Create the device queue for our SIM(s). 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|maxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate CAM SIMQ!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Construct our SIM entry. 	 */
name|mpt
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|mpt_action
argument_list|,
name|mpt_poll
argument_list|,
literal|"mpt"
argument_list|,
name|mpt
argument_list|,
name|mpt
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|maxq
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate CAM SIM!\n"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Register exactly the bus. 	 */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Bus registration Failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate Path!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Only register a second bus for RAID physical 	 * devices if the controller supports RAID. 	 */
if|if
condition|(
name|mpt
operator|->
name|ioc_page2
operator|==
name|NULL
operator|||
name|mpt
operator|->
name|ioc_page2
operator|->
name|MaxPhysDisks
operator|==
literal|0
condition|)
block|{
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Create a "bus" to export all hidden disks to CAM. 	 */
name|mpt
operator|->
name|phydisk_sim
operator|=
name|cam_sim_alloc
argument_list|(
name|mpt_action
argument_list|,
name|mpt_poll
argument_list|,
literal|"mpt"
argument_list|,
name|mpt
argument_list|,
name|mpt
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|maxq
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|phydisk_sim
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate Physical Disk CAM SIM!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Register exactly the bus. 	 */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|,
literal|1
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Physical Disk Bus registration Failed!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|mpt
operator|->
name|phydisk_path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unable to allocate Physical Disk Path!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|cleanup0
label|:
name|mpt_cam_detach
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read FC configuration information  */
end_comment

begin_function
specifier|static
name|int
name|mpt_read_config_info_fc
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|char
modifier|*
name|topology
init|=
name|NULL
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|speed
init|=
literal|0
decl_stmt|;
name|rv
operator|=
name|mpt_read_cfg_header
argument_list|(
name|mpt
argument_list|,
name|MPI_CONFIG_PAGETYPE_FC_PORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Header
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FC Port Page 0 Header: %x %x %x %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Header
operator|.
name|PageVersion
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Header
operator|.
name|PageLength
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Header
operator|.
name|PageNumber
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Header
operator|.
name|PageType
argument_list|)
expr_stmt|;
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|mpt
operator|->
name|mpt_fcport_page0
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"failed to read FC Port Page 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|speed
operator|=
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|CurrentSpeed
expr_stmt|;
switch|switch
condition|(
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|Flags
operator|&
name|MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK
condition|)
block|{
case|case
name|MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT
case|:
name|speed
operator|=
literal|0
expr_stmt|;
name|topology
operator|=
literal|"<NO LOOP>"
expr_stmt|;
break|break;
case|case
name|MPI_FCPORTPAGE0_FLAGS_ATTACH_POINT_TO_POINT
case|:
name|topology
operator|=
literal|"N-Port"
expr_stmt|;
break|break;
case|case
name|MPI_FCPORTPAGE0_FLAGS_ATTACH_PRIVATE_LOOP
case|:
name|topology
operator|=
literal|"NL-Port"
expr_stmt|;
break|break;
case|case
name|MPI_FCPORTPAGE0_FLAGS_ATTACH_FABRIC_DIRECT
case|:
name|topology
operator|=
literal|"F-Port"
expr_stmt|;
break|break;
case|case
name|MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP
case|:
name|topology
operator|=
literal|"FL-Port"
expr_stmt|;
break|break;
default|default:
name|speed
operator|=
literal|0
expr_stmt|;
name|topology
operator|=
literal|"?"
expr_stmt|;
break|break;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INFO
argument_list|,
literal|"FC Port Page 0: Topology<%s> WWNN 0x%08x%08x WWPN 0x%08x%08x "
literal|"Speed %u-Gbit\n"
argument_list|,
name|topology
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|WWNN
operator|.
name|High
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|WWNN
operator|.
name|Low
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|WWPN
operator|.
name|High
argument_list|,
name|mpt
operator|->
name|mpt_fcport_page0
operator|.
name|WWPN
operator|.
name|Low
argument_list|,
name|speed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set FC configuration information.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_set_initial_config_fc
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
if|#
directive|if
literal|0
block|CONFIG_PAGE_FC_PORT_1 fc; 	U32 fl; 	int r, doit = 0;  	if ((mpt->role& MPT_ROLE_TARGET) == 0) { 		return (0); 	}  	r = mpt_read_cfg_header(mpt, MPI_CONFIG_PAGETYPE_FC_PORT, 1, 0,&fc.Header, FALSE, 5000); 	if (r) { 		return (mpt_fc_reset_link(mpt, 1)); 	}  	r = mpt_read_cfg_page(mpt, MPI_CONFIG_ACTION_PAGE_READ_CURRENT, 0,&fc.Header, sizeof (fc), FALSE, 5000); 	if (r) { 		return (mpt_fc_reset_link(mpt, 1)); 	}  	fl = le32toh(fc.Flags); 	if ((fl& MPI_FCPORTPAGE1_FLAGS_TARGET_MODE_OXID) == 0) { 		fl |= MPI_FCPORTPAGE1_FLAGS_TARGET_MODE_OXID; 		doit = 1; 	} 	if (doit) { 		const char *cc;  		mpt_lprt(mpt, MPT_PRT_INFO, 		    "FC Port Page 1: New Flags %x \n", fl); 		fc.Flags = htole32(fl); 		r = mpt_write_cfg_page(mpt, 		    MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT, 0,&fc.Header, 		    sizeof(fc), FALSE, 5000); 		if (r != 0) { 			cc = "FC PORT PAGE1 UPDATE: FAILED\n"; 		} else { 			cc = "FC PORT PAGE1 UPDATED: SYSTEM NEEDS RESET\n"; 		} 		mpt_prt(mpt, cc); 	}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read SAS configuration information. Nothing to do yet.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_read_config_info_sas
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set SAS configuration information. Nothing to do yet.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_set_initial_config_sas
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read SCSI configuration information  */
end_comment

begin_function
specifier|static
name|int
name|mpt_read_config_info_spi
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|i
decl_stmt|;
name|rv
operator|=
name|mpt_read_cfg_header
argument_list|(
name|mpt
argument_list|,
name|MPI_CONFIG_PAGETYPE_SCSI_PORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Header
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 0 Header: %x %x %x %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Header
operator|.
name|PageVersion
argument_list|,
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Header
operator|.
name|PageLength
argument_list|,
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Header
operator|.
name|PageNumber
argument_list|,
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Header
operator|.
name|PageType
argument_list|)
expr_stmt|;
name|rv
operator|=
name|mpt_read_cfg_header
argument_list|(
name|mpt
argument_list|,
name|MPI_CONFIG_PAGETYPE_SCSI_PORT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Header
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 1 Header: %x %x %x %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Header
operator|.
name|PageVersion
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Header
operator|.
name|PageLength
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Header
operator|.
name|PageNumber
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Header
operator|.
name|PageType
argument_list|)
expr_stmt|;
name|rv
operator|=
name|mpt_read_cfg_header
argument_list|(
name|mpt
argument_list|,
name|MPI_CONFIG_PAGETYPE_SCSI_PORT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|Header
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 2 Header: %x %x %x %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|Header
operator|.
name|PageVersion
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|Header
operator|.
name|PageLength
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|Header
operator|.
name|PageNumber
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|Header
operator|.
name|PageType
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator|=
name|mpt_read_cfg_header
argument_list|(
name|mpt
argument_list|,
name|MPI_CONFIG_PAGETYPE_SCSI_DEVICE
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Header
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Target %d Device Page 0 Header: %x %x %x %x\n"
argument_list|,
name|i
argument_list|,
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageVersion
argument_list|,
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageLength
argument_list|,
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageNumber
argument_list|,
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageType
argument_list|)
expr_stmt|;
name|rv
operator|=
name|mpt_read_cfg_header
argument_list|(
name|mpt
argument_list|,
name|MPI_CONFIG_PAGETYPE_SCSI_DEVICE
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Header
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Target %d Device Page 1 Header: %x %x %x %x\n"
argument_list|,
name|i
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageVersion
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageLength
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageNumber
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Header
operator|.
name|PageType
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * At this point, we don't *have* to fail. As long as we have 	 * valid config header information, we can (barely) lurch 	 * along. 	 */
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|mpt
operator|->
name|mpt_port_page0
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"failed to read SPI Port Page 0\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 0: Capabilities %x PhysicalInterface %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
argument_list|,
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|PhysicalInterface
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|mpt
operator|->
name|mpt_port_page1
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"failed to read SPI Port Page 1\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 1: Configuration %x OnBusTimerValue %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Configuration
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|OnBusTimerValue
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|mpt
operator|->
name|mpt_port_page2
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"failed to read SPI Port Page 2\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 2: Flags %x Settings %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|PortFlags
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|PortSettings
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Port Page 2 Tgt %d: timo %x SF %x Flags %x\n"
argument_list|,
name|i
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|DeviceSettings
index|[
name|i
index|]
operator|.
name|Timeout
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|DeviceSettings
index|[
name|i
index|]
operator|.
name|SyncFactor
argument_list|,
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|DeviceSettings
index|[
name|i
index|]
operator|.
name|DeviceFlags
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|i
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpt
operator|->
name|mpt_dev_page0
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"cannot read SPI Target %d Device Page 0\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Tgt %d Page 0: NParms %x Information %x"
argument_list|,
name|i
argument_list|,
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|NegotiatedParameters
argument_list|,
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|i
index|]
operator|.
name|Information
argument_list|)
expr_stmt|;
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|i
argument_list|,
operator|&
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpt
operator|->
name|mpt_dev_page1
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"cannot read SPI Target %d Device Page 1\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SPI Tgt %d Page 1: RParms %x Configuration %x\n"
argument_list|,
name|i
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|RequestedParameters
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Configuration
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate SPI configuration information.  *  * In particular, validate SPI Port Page 1.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_set_initial_config_spi
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pp1val
init|=
operator|(
operator|(
literal|1
operator|<<
name|mpt
operator|->
name|mpt_ini_id
operator|)
operator|<<
literal|16
operator|)
operator||
name|mpt
operator|->
name|mpt_ini_id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mpt
operator|->
name|mpt_disc_enable
operator|=
literal|0xff
expr_stmt|;
name|mpt
operator|->
name|mpt_tag_enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Configuration
operator|!=
name|pp1val
condition|)
block|{
name|CONFIG_PAGE_SCSI_PORT_1
name|tmp
decl_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"SPI Port Page 1 Config value bad (%x)- should "
literal|"be %x\n"
argument_list|,
name|mpt
operator|->
name|mpt_port_page1
operator|.
name|Configuration
argument_list|,
name|pp1val
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|mpt
operator|->
name|mpt_port_page1
expr_stmt|;
name|tmp
operator|.
name|Configuration
operator|=
name|pp1val
expr_stmt|;
name|error
operator|=
name|mpt_write_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tmp
operator|.
name|Configuration
operator|!=
name|pp1val
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"failed to reset SPI Port Page 1 Config value\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt
operator|->
name|mpt_port_page1
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 	 * The purpose of this exercise is to get 	 * all targets back to async/narrow. 	 * 	 * We skip this if the BIOS has already negotiated speeds with targets. 	 */
name|i
operator|=
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|PortSettings
operator|&
name|MPI_SCSIPORTPAGE2_PORT_MASK_NEGO_MASTER_SETTINGS
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MPI_SCSIPORTPAGE2_PORT_ALL_MASTER_SETTINGS
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INFO
argument_list|,
literal|"honoring BIOS transfer negotiation for all targets\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|RequestedParameters
operator|=
literal|0
expr_stmt|;
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|i
index|]
operator|.
name|Configuration
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|mpt_update_spi_config
argument_list|(
name|mpt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpt_cam_enable
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
if|if
condition|(
name|mpt_read_config_info_fc
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|mpt_set_initial_config_fc
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
if|if
condition|(
name|mpt_read_config_info_sas
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|mpt_set_initial_config_sas
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mpt_read_config_info_spi
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|mpt_set_initial_config_spi
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mpt_cam_detach
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|mpt_handler_t
name|handler
decl_stmt|;
name|mpt_terminate_recovery_thread
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_reply_handler
expr_stmt|;
name|mpt_deregister_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
name|scsi_io_handler_id
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_tmf_reply_handler
expr_stmt|;
name|mpt_deregister_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
name|scsi_tmf_handler_id
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_fc_els_reply_handler
expr_stmt|;
name|mpt_deregister_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
name|fc_els_handler_id
argument_list|)
expr_stmt|;
name|handler
operator|.
name|reply_handler
operator|=
name|mpt_scsi_tgt_reply_handler
expr_stmt|;
name|mpt_deregister_handler
argument_list|(
name|mpt
argument_list|,
name|MPT_HANDLER_REPLY
argument_list|,
name|handler
argument_list|,
name|mpt
operator|->
name|scsi_tgt_handler_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|tmf_req
operator|!=
name|NULL
condition|)
block|{
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_ALLOCATED
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|tmf_req
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|sim
operator|!=
name|NULL
condition|)
block|{
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|mpt
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|sim
operator|=
name|NULL
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|phydisk_sim
operator|!=
name|NULL
condition|)
block|{
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|mpt
operator|->
name|phydisk_path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|mpt
operator|->
name|phydisk_sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|phydisk_sim
operator|=
name|NULL
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is used after a system crash to dump core onto the swap device.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|mpt
operator|=
operator|(
expr|struct
name|mpt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_intr
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Watchdog timeout routine for SCSI requests.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|request_t
modifier|*
name|req
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|req
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
expr_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"request %p:%u timed out for ccb %p (req->ccb %p)\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|ccb
argument_list|,
name|req
operator|->
name|ccb
argument_list|)
expr_stmt|;
comment|/* XXX: WHAT ARE WE TRYING TO DO HERE? */
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_QUEUED
operator|)
operator|==
name|REQ_STATE_QUEUED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_TIMEDOUT
expr_stmt|;
name|mpt_wakeup_recovery_thread
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback routine from "bus_dmamap_load" or, in simple cases, called directly.  *  * Takes a list of physical segments and builds the SGL for SCSI IO command  * and forwards the commard to the IOC after one last check that CAM has not  * aborted the transaction.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_execute_req_a64
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|,
modifier|*
name|trq
decl_stmt|;
name|char
modifier|*
name|mpt_off
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|int
name|seg
decl_stmt|,
name|first_lim
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|nxt_off
decl_stmt|;
name|void
modifier|*
name|sglp
decl_stmt|;
name|MSG_REQUEST_HEADER
modifier|*
name|hdrp
decl_stmt|;
name|SGE_SIMPLE64
modifier|*
name|se
decl_stmt|;
name|SGE_CHAIN64
modifier|*
name|ce
decl_stmt|;
name|req
operator|=
operator|(
name|request_t
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
name|req
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
expr_stmt|;
name|hdrp
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|mpt_off
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
name|sglp
operator|=
operator|&
operator|(
operator|(
name|PTR_MSG_SCSI_IO_REQUEST
operator|)
name|hdrp
operator|)
operator|->
name|SGL
expr_stmt|;
block|}
else|else
comment|/* if (hdrp->Function == MPI_FUNCTION_TARGET_ASSIST) */
block|{
name|sglp
operator|=
operator|&
operator|(
operator|(
name|PTR_MSG_TARGET_ASSIST_REQUEST
operator|)
name|hdrp
operator|)
operator|->
name|SGL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
operator|(
name|uint32_t
operator|)
name|nseg
operator|)
operator|>=
name|mpt
operator|->
name|max_seg_cnt
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
operator|&&
name|error
operator|!=
name|ENOMEM
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_execute_req: err %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|cam_status
name|status
decl_stmt|;
name|mpt_freeze_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_TARGET_ASSIST
condition|)
block|{
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
decl_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|state
operator|=
name|TGT_STATE_IN_CAM
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * No data to transfer? 	 * Just make a single simple SGL with zero length. 	 */
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|tidx
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|sglp
operator|)
operator|-
name|mpt_off
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mpt_off
index|[
name|tidx
index|]
argument_list|,
literal|0xff
argument_list|,
name|MPT_REQUEST_AREA
operator|-
name|tidx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|SGE_SIMPLE32
modifier|*
name|se1
init|=
operator|(
name|SGE_SIMPLE32
operator|*
operator|)
name|sglp
decl_stmt|;
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se1
argument_list|,
operator|(
name|MPI_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_LIST
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|flags
operator|=
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|flags
operator||=
name|MPI_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|flags
operator||=
name|MPI_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_SG_LIST_PHYS
operator||
name|CAM_DATA_PHYS
operator|)
operator|)
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Okay, fill in what we can at the end of the command frame. 	 * If we have up to MPT_NSGL_FIRST, we can fit them all into 	 * the command frame. 	 * 	 * Otherwise, we fill up through MPT_NSGL_FIRST less one 	 * SIMPLE64 pointers and start doing CHAIN64 entries after 	 * that. 	 */
if|if
condition|(
name|nseg
operator|<
name|MPT_NSGL_FIRST
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
name|first_lim
operator|=
name|nseg
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Leave room for CHAIN element 		 */
name|first_lim
operator|=
name|MPT_NSGL_FIRST
argument_list|(
name|mpt
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|se
operator|=
operator|(
name|SGE_SIMPLE64
operator|*
operator|)
name|sglp
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|first_lim
condition|;
name|seg
operator|++
operator|,
name|se
operator|++
operator|,
name|dm_segs
operator|++
control|)
block|{
name|uint32_t
name|tf
decl_stmt|;
name|memset
argument_list|(
name|se
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|Address
operator|.
name|Low
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|se
operator|->
name|Address
operator|.
name|High
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|dm_segs
operator|->
name|ds_addr
operator|)
operator|>>
literal|32
expr_stmt|;
block|}
name|MPI_pSGE_SET_LENGTH
argument_list|(
name|se
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tf
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|first_lim
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Tell the IOC where to find the first chain element. 	 */
name|hdrp
operator|->
name|ChainOffset
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|se
operator|-
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|>>
literal|2
expr_stmt|;
name|nxt_off
operator|=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|trq
operator|=
name|req
expr_stmt|;
comment|/* 	 * Make up the rest of the data segments out of a chain element 	 * (contiained in the current request frame) which points to 	 * SIMPLE64 elements in the next request frame, possibly ending 	 * with *another* chain element (if there's more). 	 */
while|while
condition|(
name|seg
operator|<
name|nseg
condition|)
block|{
name|int
name|this_seg_lim
decl_stmt|;
name|uint32_t
name|tf
decl_stmt|,
name|cur_off
decl_stmt|;
name|bus_addr_t
name|chain_list_addr
decl_stmt|;
comment|/* 		 * Point to the chain descriptor. Note that the chain 		 * descriptor is at the end of the *previous* list (whether 		 * chain or simple). 		 */
name|ce
operator|=
operator|(
name|SGE_CHAIN64
operator|*
operator|)
name|se
expr_stmt|;
comment|/* 		 * Before we change our current pointer, make  sure we won't 		 * overflow the request area with this frame. Note that we 		 * test against 'greater than' here as it's okay in this case 		 * to have next offset be just outside the request area. 		 */
if|if
condition|(
operator|(
name|nxt_off
operator|+
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
operator|)
operator|>
name|MPT_REQUEST_AREA
condition|)
block|{
name|nxt_off
operator|=
name|MPT_REQUEST_AREA
expr_stmt|;
goto|goto
name|next_chain
goto|;
block|}
comment|/* 		 * Set our SGE element pointer to the beginning of the chain 		 * list and update our next chain list offset. 		 */
name|se
operator|=
operator|(
name|SGE_SIMPLE64
operator|*
operator|)
operator|&
name|mpt_off
index|[
name|nxt_off
index|]
expr_stmt|;
name|cur_off
operator|=
name|nxt_off
expr_stmt|;
name|nxt_off
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 		 * Now initialized the chain descriptor. 		 */
name|memset
argument_list|(
name|ce
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Get the physical address of the chain list. 		 */
name|chain_list_addr
operator|=
name|trq
operator|->
name|req_pbuf
expr_stmt|;
name|chain_list_addr
operator|+=
name|cur_off
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|ce
operator|->
name|Address
operator|.
name|High
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|chain_list_addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|ce
operator|->
name|Address
operator|.
name|Low
operator|=
operator|(
name|uint32_t
operator|)
name|chain_list_addr
expr_stmt|;
name|ce
operator|->
name|Flags
operator|=
name|MPI_SGE_FLAGS_CHAIN_ELEMENT
operator||
name|MPI_SGE_FLAGS_64_BIT_ADDRESSING
expr_stmt|;
comment|/* 		 * If we have more than a frame's worth of segments left, 		 * set up the chain list to have the last element be another 		 * chain descriptor. 		 */
if|if
condition|(
operator|(
name|nseg
operator|-
name|seg
operator|)
operator|>
name|MPT_NSGL
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
name|this_seg_lim
operator|=
name|seg
operator|+
name|MPT_NSGL
argument_list|(
name|mpt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * The length of the chain is the length in bytes of the 			 * number of segments plus the next chain element. 			 * 			 * The next chain descriptor offset is the length, 			 * in words, of the number of segments. 			 */
name|ce
operator|->
name|Length
operator|=
operator|(
name|this_seg_lim
operator|-
name|seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SGE_SIMPLE64
argument_list|)
expr_stmt|;
name|ce
operator|->
name|NextChainOffset
operator|=
name|ce
operator|->
name|Length
operator|>>
literal|2
expr_stmt|;
name|ce
operator|->
name|Length
operator|+=
sizeof|sizeof
argument_list|(
name|SGE_CHAIN64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this_seg_lim
operator|=
name|nseg
expr_stmt|;
name|ce
operator|->
name|Length
operator|=
operator|(
name|this_seg_lim
operator|-
name|seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SGE_SIMPLE64
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fill in the chain list SGE elements with our segment data. 		 * 		 * If we're the last element in this chain list, set the last 		 * element flag. If we're the completely last element period, 		 * set the end of list and end of buffer flags. 		 */
while|while
condition|(
name|seg
operator|<
name|this_seg_lim
condition|)
block|{
name|memset
argument_list|(
name|se
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|Address
operator|.
name|Low
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|se
operator|->
name|Address
operator|.
name|High
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|dm_segs
operator|->
name|ds_addr
operator|)
operator|>>
literal|32
expr_stmt|;
block|}
name|MPI_pSGE_SET_LENGTH
argument_list|(
name|se
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tf
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|this_seg_lim
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|se
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|next_chain
label|:
comment|/* 		 * If we have more segments to do and we've used up all of 		 * the space in a request area, go allocate another one 		 * and chain to that. 		 */
if|if
condition|(
name|seg
operator|<
name|nseg
operator|&&
name|nxt_off
operator|>=
name|MPT_REQUEST_AREA
condition|)
block|{
name|request_t
modifier|*
name|nrq
decl_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|nrq
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * Append the new request area on the tail of our list. 			 */
if|if
condition|(
operator|(
name|trq
operator|=
name|req
operator|->
name|chain
operator|)
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|chain
operator|=
name|nrq
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|trq
operator|->
name|chain
operator|!=
name|NULL
condition|)
block|{
name|trq
operator|=
name|trq
operator|->
name|chain
expr_stmt|;
block|}
name|trq
operator|->
name|chain
operator|=
name|nrq
expr_stmt|;
block|}
name|trq
operator|=
name|nrq
expr_stmt|;
name|mpt_off
operator|=
name|trq
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|memset
argument_list|(
name|mpt_off
argument_list|,
literal|0xff
argument_list|,
name|MPT_REQUEST_AREA
argument_list|)
expr_stmt|;
block|}
name|nxt_off
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
label|:
comment|/* 	 * Last time we need to check if this CCB needs to be aborted. 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_TARGET_ASSIST
condition|)
block|{
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
decl_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|state
operator|=
name|TGT_STATE_IN_CAM
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
block|}
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_execute_req_a64: I/O cancelled (status 0x%x)\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|mpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_handle_init
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|nc
init|=
literal|0
decl_stmt|;
name|mpt_print_request
argument_list|(
name|req
operator|->
name|req_vbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|trq
operator|=
name|req
operator|->
name|chain
init|;
name|trq
condition|;
name|trq
operator|=
name|trq
operator|->
name|chain
control|)
block|{
name|printf
argument_list|(
literal|"  Additional Chain Area %d\n"
argument_list|,
name|nc
operator|++
argument_list|)
expr_stmt|;
name|mpt_dump_sgl
argument_list|(
name|trq
operator|->
name|req_vbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_TARGET_ASSIST
condition|)
block|{
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
decl_stmt|;
name|mpt_tgt_state_t
modifier|*
name|tgt
init|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WE_TRUST_AUTO_GOOD_STATUS
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|&&
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_OK
operator|&&
name|tgt
operator|->
name|resid
operator|==
literal|0
condition|)
block|{
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_MOVING_DATA_AND_STATUS
expr_stmt|;
block|}
else|else
block|{
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_MOVING_DATA
expr_stmt|;
block|}
else|#
directive|else
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_MOVING_DATA
expr_stmt|;
endif|#
directive|endif
block|}
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_execute_req
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|,
modifier|*
name|trq
decl_stmt|;
name|char
modifier|*
name|mpt_off
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|int
name|seg
decl_stmt|,
name|first_lim
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|nxt_off
decl_stmt|;
name|void
modifier|*
name|sglp
decl_stmt|;
name|MSG_REQUEST_HEADER
modifier|*
name|hdrp
decl_stmt|;
name|SGE_SIMPLE32
modifier|*
name|se
decl_stmt|;
name|SGE_CHAIN32
modifier|*
name|ce
decl_stmt|;
name|req
operator|=
operator|(
name|request_t
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
name|req
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
expr_stmt|;
name|hdrp
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|mpt_off
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
name|sglp
operator|=
operator|&
operator|(
operator|(
name|PTR_MSG_SCSI_IO_REQUEST
operator|)
name|hdrp
operator|)
operator|->
name|SGL
expr_stmt|;
block|}
else|else
comment|/* if (hdrp->Function == MPI_FUNCTION_TARGET_ASSIST) */
block|{
name|sglp
operator|=
operator|&
operator|(
operator|(
name|PTR_MSG_TARGET_ASSIST_REQUEST
operator|)
name|hdrp
operator|)
operator|->
name|SGL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
operator|(
name|uint32_t
operator|)
name|nseg
operator|)
operator|>=
name|mpt
operator|->
name|max_seg_cnt
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"segment count %d too large (max %u)\n"
argument_list|,
name|nseg
argument_list|,
name|mpt
operator|->
name|max_seg_cnt
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_TARGET_ASSIST
condition|)
block|{
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
decl_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|state
operator|=
name|TGT_STATE_IN_CAM
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|cam_status
name|status
decl_stmt|;
name|mpt_freeze_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|status
operator|=
name|CAM_REQ_TOO_BIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * No data to transfer? 	 * Just make a single simple SGL with zero length. 	 */
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|tidx
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|sglp
operator|)
operator|-
name|mpt_off
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mpt_off
index|[
name|tidx
index|]
argument_list|,
literal|0xff
argument_list|,
name|MPT_REQUEST_AREA
operator|-
name|tidx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|SGE_SIMPLE32
modifier|*
name|se1
init|=
operator|(
name|SGE_SIMPLE32
operator|*
operator|)
name|sglp
decl_stmt|;
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se1
argument_list|,
operator|(
name|MPI_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
operator||
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_LIST
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|flags
operator|=
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
expr_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|flags
operator||=
name|MPI_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|flags
operator||=
name|MPI_SGE_FLAGS_HOST_TO_IOC
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_SG_LIST_PHYS
operator||
name|CAM_DATA_PHYS
operator|)
operator|)
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Okay, fill in what we can at the end of the command frame. 	 * If we have up to MPT_NSGL_FIRST, we can fit them all into 	 * the command frame. 	 * 	 * Otherwise, we fill up through MPT_NSGL_FIRST less one 	 * SIMPLE32 pointers and start doing CHAIN32 entries after 	 * that. 	 */
if|if
condition|(
name|nseg
operator|<
name|MPT_NSGL_FIRST
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
name|first_lim
operator|=
name|nseg
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Leave room for CHAIN element 		 */
name|first_lim
operator|=
name|MPT_NSGL_FIRST
argument_list|(
name|mpt
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|se
operator|=
operator|(
name|SGE_SIMPLE32
operator|*
operator|)
name|sglp
expr_stmt|;
for|for
control|(
name|seg
operator|=
literal|0
init|;
name|seg
operator|<
name|first_lim
condition|;
name|seg
operator|++
operator|,
name|se
operator|++
operator|,
name|dm_segs
operator|++
control|)
block|{
name|uint32_t
name|tf
decl_stmt|;
name|memset
argument_list|(
name|se
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|Address
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|MPI_pSGE_SET_LENGTH
argument_list|(
name|se
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tf
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|first_lim
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Tell the IOC where to find the first chain element. 	 */
name|hdrp
operator|->
name|ChainOffset
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|se
operator|-
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|>>
literal|2
expr_stmt|;
name|nxt_off
operator|=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|trq
operator|=
name|req
expr_stmt|;
comment|/* 	 * Make up the rest of the data segments out of a chain element 	 * (contiained in the current request frame) which points to 	 * SIMPLE32 elements in the next request frame, possibly ending 	 * with *another* chain element (if there's more). 	 */
while|while
condition|(
name|seg
operator|<
name|nseg
condition|)
block|{
name|int
name|this_seg_lim
decl_stmt|;
name|uint32_t
name|tf
decl_stmt|,
name|cur_off
decl_stmt|;
name|bus_addr_t
name|chain_list_addr
decl_stmt|;
comment|/* 		 * Point to the chain descriptor. Note that the chain 		 * descriptor is at the end of the *previous* list (whether 		 * chain or simple). 		 */
name|ce
operator|=
operator|(
name|SGE_CHAIN32
operator|*
operator|)
name|se
expr_stmt|;
comment|/* 		 * Before we change our current pointer, make  sure we won't 		 * overflow the request area with this frame. Note that we 		 * test against 'greater than' here as it's okay in this case 		 * to have next offset be just outside the request area. 		 */
if|if
condition|(
operator|(
name|nxt_off
operator|+
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
operator|)
operator|>
name|MPT_REQUEST_AREA
condition|)
block|{
name|nxt_off
operator|=
name|MPT_REQUEST_AREA
expr_stmt|;
goto|goto
name|next_chain
goto|;
block|}
comment|/* 		 * Set our SGE element pointer to the beginning of the chain 		 * list and update our next chain list offset. 		 */
name|se
operator|=
operator|(
name|SGE_SIMPLE32
operator|*
operator|)
operator|&
name|mpt_off
index|[
name|nxt_off
index|]
expr_stmt|;
name|cur_off
operator|=
name|nxt_off
expr_stmt|;
name|nxt_off
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 		 * Now initialized the chain descriptor. 		 */
name|memset
argument_list|(
name|ce
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Get the physical address of the chain list. 		 */
name|chain_list_addr
operator|=
name|trq
operator|->
name|req_pbuf
expr_stmt|;
name|chain_list_addr
operator|+=
name|cur_off
expr_stmt|;
name|ce
operator|->
name|Address
operator|=
name|chain_list_addr
expr_stmt|;
name|ce
operator|->
name|Flags
operator|=
name|MPI_SGE_FLAGS_CHAIN_ELEMENT
expr_stmt|;
comment|/* 		 * If we have more than a frame's worth of segments left, 		 * set up the chain list to have the last element be another 		 * chain descriptor. 		 */
if|if
condition|(
operator|(
name|nseg
operator|-
name|seg
operator|)
operator|>
name|MPT_NSGL
argument_list|(
name|mpt
argument_list|)
condition|)
block|{
name|this_seg_lim
operator|=
name|seg
operator|+
name|MPT_NSGL
argument_list|(
name|mpt
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * The length of the chain is the length in bytes of the 			 * number of segments plus the next chain element. 			 * 			 * The next chain descriptor offset is the length, 			 * in words, of the number of segments. 			 */
name|ce
operator|->
name|Length
operator|=
operator|(
name|this_seg_lim
operator|-
name|seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SGE_SIMPLE32
argument_list|)
expr_stmt|;
name|ce
operator|->
name|NextChainOffset
operator|=
name|ce
operator|->
name|Length
operator|>>
literal|2
expr_stmt|;
name|ce
operator|->
name|Length
operator|+=
sizeof|sizeof
argument_list|(
name|SGE_CHAIN32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this_seg_lim
operator|=
name|nseg
expr_stmt|;
name|ce
operator|->
name|Length
operator|=
operator|(
name|this_seg_lim
operator|-
name|seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SGE_SIMPLE32
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fill in the chain list SGE elements with our segment data. 		 * 		 * If we're the last element in this chain list, set the last 		 * element flag. If we're the completely last element period, 		 * set the end of list and end of buffer flags. 		 */
while|while
condition|(
name|seg
operator|<
name|this_seg_lim
condition|)
block|{
name|memset
argument_list|(
name|se
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|se
argument_list|)
argument_list|)
expr_stmt|;
name|se
operator|->
name|Address
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|MPI_pSGE_SET_LENGTH
argument_list|(
name|se
argument_list|,
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|tf
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|seg
operator|==
name|this_seg_lim
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|==
name|nseg
operator|-
literal|1
condition|)
block|{
name|tf
operator||=
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
block|}
name|MPI_pSGE_SET_FLAGS
argument_list|(
name|se
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|se
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
name|next_chain
label|:
comment|/* 		 * If we have more segments to do and we've used up all of 		 * the space in a request area, go allocate another one 		 * and chain to that. 		 */
if|if
condition|(
name|seg
operator|<
name|nseg
operator|&&
name|nxt_off
operator|>=
name|MPT_REQUEST_AREA
condition|)
block|{
name|request_t
modifier|*
name|nrq
decl_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|nrq
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * Append the new request area on the tail of our list. 			 */
if|if
condition|(
operator|(
name|trq
operator|=
name|req
operator|->
name|chain
operator|)
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|chain
operator|=
name|nrq
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|trq
operator|->
name|chain
operator|!=
name|NULL
condition|)
block|{
name|trq
operator|=
name|trq
operator|->
name|chain
expr_stmt|;
block|}
name|trq
operator|->
name|chain
operator|=
name|nrq
expr_stmt|;
block|}
name|trq
operator|=
name|nrq
expr_stmt|;
name|mpt_off
operator|=
name|trq
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|memset
argument_list|(
name|mpt_off
argument_list|,
literal|0xff
argument_list|,
name|MPT_REQUEST_AREA
argument_list|)
expr_stmt|;
block|}
name|nxt_off
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
label|:
comment|/* 	 * Last time we need to check if this CCB needs to be aborted. 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_TARGET_ASSIST
condition|)
block|{
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
decl_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|state
operator|=
name|TGT_STATE_IN_CAM
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
block|}
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_execute_req: I/O cancelled (status 0x%x)\n"
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|mpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_handle_init
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|nc
init|=
literal|0
decl_stmt|;
name|mpt_print_request
argument_list|(
name|req
operator|->
name|req_vbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|trq
operator|=
name|req
operator|->
name|chain
init|;
name|trq
condition|;
name|trq
operator|=
name|trq
operator|->
name|chain
control|)
block|{
name|printf
argument_list|(
literal|"  Additional Chain Area %d\n"
argument_list|,
name|nc
operator|++
argument_list|)
expr_stmt|;
name|mpt_dump_sgl
argument_list|(
name|trq
operator|->
name|req_vbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdrp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_TARGET_ASSIST
condition|)
block|{
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
decl_stmt|;
name|mpt_tgt_state_t
modifier|*
name|tgt
init|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WE_TRUST_AUTO_GOOD_STATUS
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|&&
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_OK
operator|&&
name|tgt
operator|->
name|resid
operator|==
literal|0
condition|)
block|{
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_MOVING_DATA_AND_STATUS
expr_stmt|;
block|}
else|else
block|{
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_MOVING_DATA
expr_stmt|;
block|}
else|#
directive|else
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_MOVING_DATA
expr_stmt|;
endif|#
directive|endif
block|}
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_start
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|;
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|MSG_SCSI_IO_REQUEST
modifier|*
name|mpt_req
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|bus_dmamap_callback_t
modifier|*
name|cb
decl_stmt|;
name|int
name|raid_passthru
decl_stmt|;
comment|/* Get the pointer for the physical addapter */
name|mpt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
expr_stmt|;
name|raid_passthru
operator|=
operator|(
name|sim
operator|==
name|mpt
operator|->
name|phydisk_sim
operator|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"mpt_start"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|cb
operator|=
name|mpt_execute_req_a64
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|=
name|mpt_execute_req
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|COWWWWW 	if (raid_passthru) { 		status = mpt_raid_quiesce_disk(mpt, mpt->raid_disks + ccb->ccb_h.target_id, 		     request_t *req) 	}
endif|#
directive|endif
comment|/* 	 * Link the ccb and the request structure so we can find 	 * the other knowing either the request or the ccb 	 */
name|req
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
operator|=
name|req
expr_stmt|;
comment|/* Now we build the command for the IOC */
name|mpt_req
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|memset
argument_list|(
name|mpt_req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MSG_SCSI_IO_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|mpt_req
operator|->
name|Function
operator|=
name|MPI_FUNCTION_SCSI_IO_REQUEST
expr_stmt|;
if|if
condition|(
name|raid_passthru
condition|)
block|{
name|mpt_req
operator|->
name|Function
operator|=
name|MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
expr_stmt|;
block|}
name|mpt_req
operator|->
name|Bus
operator|=
literal|0
expr_stmt|;
comment|/* we don't have multiport devices yet */
name|mpt_req
operator|->
name|SenseBufferLength
operator|=
operator|(
name|csio
operator|->
name|sense_len
operator|<
name|MPT_SENSE_SIZE
operator|)
condition|?
name|csio
operator|->
name|sense_len
else|:
name|MPT_SENSE_SIZE
expr_stmt|;
comment|/* 	 * We use the message context to find the request structure when we 	 * Get the command completion interrupt from the IOC. 	 */
name|mpt_req
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|scsi_io_handler_id
argument_list|)
expr_stmt|;
comment|/* Which physical device to do the I/O on */
name|mpt_req
operator|->
name|TargetID
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* We assume a single level LUN type */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>=
literal|256
condition|)
block|{
name|mpt_req
operator|->
name|LUN
index|[
literal|0
index|]
operator|=
literal|0x40
operator||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>>
literal|8
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|mpt_req
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|mpt_req
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
block|}
comment|/* Set the direction of the transfer */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|mpt_req
operator|->
name|Control
operator|=
name|MPI_SCSIIO_CONTROL_READ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_OUT
condition|)
block|{
name|mpt_req
operator|->
name|Control
operator|=
name|MPI_SCSIIO_CONTROL_WRITE
expr_stmt|;
block|}
else|else
block|{
name|mpt_req
operator|->
name|Control
operator|=
name|MPI_SCSIIO_CONTROL_NODATATRANSFER
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|tag_action
condition|)
block|{
case|case
name|MSG_HEAD_OF_Q_TAG
case|:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_HEADOFQ
expr_stmt|;
break|break;
case|case
name|MSG_ACA_TASK
case|:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_ACAQ
expr_stmt|;
break|break;
case|case
name|MSG_ORDERED_Q_TAG
case|:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_ORDEREDQ
expr_stmt|;
break|break;
case|case
name|MSG_SIMPLE_Q_TAG
case|:
default|default:
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_SIMPLEQ
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|||
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_SIMPLEQ
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX No such thing for a target doing packetized. */
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_UNTAGGED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|==
literal|0
operator|&&
name|mpt
operator|->
name|is_sas
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
condition|)
block|{
name|mpt_req
operator|->
name|Control
operator||=
name|MPI_SCSIIO_CONTROL_NO_DISCONNECT
expr_stmt|;
block|}
block|}
comment|/* Copy the scsi command block into place */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|mpt_req
operator|->
name|CDB
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|mpt_req
operator|->
name|CDB
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
name|mpt_req
operator|->
name|CDBLength
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
name|mpt_req
operator|->
name|DataLength
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|mpt_req
operator|->
name|SenseBufferLowAddr
operator|=
name|req
operator|->
name|sense_pbuf
expr_stmt|;
comment|/* 	 * If we have any data to send with this command map it into bus space. 	 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We've been given a pointer to a single buffer. 			 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Virtual address that needs to translated into 				 * one or more physical address ranges. 				 */
name|int
name|error
decl_stmt|;
name|int
name|s
init|=
name|splsoftvm
argument_list|()
decl_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|cb
argument_list|,
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 					 * So as to maintain ordering, 					 * freeze the controller queue 					 * until our mapping is 					 * returned. 					 */
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccbh
operator|->
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * We have been given a pointer to single 				 * physical buffer. 				 */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We have been given a list of addresses. 			 * This case could be easily supported but they are not 			 * currently generated by the CAM subsystem so there 			 * is no point in wasting the time right now. 			 */
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_bus_reset
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|uint8_t
name|response
decl_stmt|;
name|error
operator|=
name|mpt_scsi_send_tmf
argument_list|(
name|mpt
argument_list|,
name|MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS
argument_list|,
name|mpt
operator|->
name|is_fc
condition|?
name|MPI_SCSITASKMGMT_MSGFLAGS_LIP_RESET_OPTION
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sleep_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * mpt_scsi_send_tmf hard resets on failure, so no 		 * need to do so here. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: mpt_scsi_send_tmf returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Wait for bus reset to be processed by the IOC. */
name|error
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|sleep_ok
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
name|status
operator|=
name|mpt
operator|->
name|tmf_req
operator|->
name|IOCStatus
expr_stmt|;
name|response
operator|=
name|mpt
operator|->
name|tmf_req
operator|->
name|ResponseCode
expr_stmt|;
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: Reset timed-out. "
literal|"Resetting controller.\n"
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|MPI_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI_IOCSTATUS_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: TMF IOC Status 0x%x. "
literal|"Resetting controller.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|response
operator|!=
name|MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED
operator|&&
name|response
operator|!=
name|MPI_SCSITASKMGMT_RSP_TM_COMPLETE
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_bus_reset: TMF Response 0x%x. "
literal|"Resetting controller.\n"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_fc_reset_link
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|dowait
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|request_t
modifier|*
name|req
decl_stmt|;
name|PTR_MSG_FC_PRIMITIVE_SEND_REQUEST
name|fc
decl_stmt|;
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|fc
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|memset
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fc
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|SendFlags
operator|=
name|MPI_FC_PRIM_SEND_FLAGS_RESET_LINK
expr_stmt|;
name|fc
operator|->
name|Function
operator|=
name|MPI_FUNCTION_FC_PRIMITIVE_SEND
expr_stmt|;
name|fc
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|fc_els_handler_id
argument_list|)
expr_stmt|;
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowait
condition|)
block|{
name|r
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|FALSE
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_cam_event
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_EVENT_NOTIFY_REPLY
modifier|*
name|msg
parameter_list|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|Event
operator|&
literal|0xFF
condition|)
block|{
case|case
name|MPI_EVENT_UNIT_ATTENTION
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Bus: 0x%02x TargetID: 0x%02x\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_IOC_BUS_RESET
case|:
comment|/* We generated a bus reset */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"IOC Bus Reset Port: %d\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_EXT_BUS_RESET
case|:
comment|/* Someone else generated a bus reset */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"External Bus Reset Detected\n"
argument_list|)
expr_stmt|;
comment|/* 		 * These replies don't return EventData like the MPI 		 * spec says they do 		 */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_RESCAN
case|:
comment|/* 		 * In general this means a device has been added to the loop. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Rescan Port: %d\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/*		xpt_async(AC_FOUND_DEVICE, path, NULL);  */
break|break;
case|case
name|MPI_EVENT_LINK_STATUS_CHANGE
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port %d: LinkState: %s\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"Failed"
else|:
literal|"Active"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_LOOP_STATE_CHANGE
case|:
switch|switch
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x01
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: LIP(%02x,%02x) "
literal|"(Loop Initialization)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0xF7
case|:
if|if
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0xF7
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Device needs AL_PA\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Device %02x doesn't like "
literal|"FC performance\n"
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0xF8
case|:
if|if
condition|(
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0xF7
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Device had loop failure "
literal|"at its receiver prior to acquiring"
literal|" AL_PA\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Device %02x detected loop"
literal|" failure at its receiver\n"
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Device %02x requests that device "
literal|"%02x reset itself\n"
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x02
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: "
literal|"LPE(%02x,%02x) (Loop Port Enable)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Port */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Character 3 */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
comment|/* Character 4 */
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: "
literal|"LPB(%02x,%02x) (Loop Port Bypass)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Port */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Character 3 */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
comment|/* Character 4 */
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Port 0x%x: FC LinkEvent: Unknown "
literal|"FC event (%02x %02x %02x)\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Port */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Event */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
comment|/* Character 3 */
operator|(
name|msg
operator|->
name|Data
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
comment|/* Character 4 */
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MPI_EVENT_LOGOUT
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"FC Logout Port: %d N_PortID: %02x\n"
argument_list|,
operator|(
name|msg
operator|->
name|Data
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|msg
operator|->
name|Data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_EVENT_CHANGE
case|:
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"mpt_cam_event: MPI_EVENT_EVENT_CHANGE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_EVENT_SAS_DEVICE_STATUS_CHANGE
case|:
comment|/* 		 * Devices are attachin'..... 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_cam_event: MPI_EVENT_SAS_DEVICE_STATUS_CHANGE\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_WARN
argument_list|,
literal|"mpt_cam_event: 0x%x\n"
argument_list|,
name|msg
operator|->
name|Event
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reply path for all SCSI I/O requests, called from our  * interrupt handler by extracting our handler index from  * the MsgContext field of the reply from the IOC.  *  * This routine is optimized for the common case of a  * completion without error.  All exception handling is  * offloaded to non-inlined helper routines to minimize  * cache footprint.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_scsi_reply_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|uint32_t
name|reply_desc
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|MSG_SCSI_IO_REQUEST
modifier|*
name|scsi_req
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|state
operator|==
name|REQ_STATE_FREE
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_scsi_reply_handler: req already free\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|scsi_req
operator|=
operator|(
name|MSG_SCSI_IO_REQUEST
operator|*
operator|)
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"req %p:%u without CCB (state %#x "
literal|"func %#x index %u rf %p)\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|req
operator|->
name|state
argument_list|,
name|scsi_req
operator|->
name|Function
argument_list|,
name|req
operator|->
name|index
argument_list|,
name|reply_frame
argument_list|)
expr_stmt|;
name|mpt_print_scsi_io_request
argument_list|(
name|scsi_req
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|untimeout
argument_list|(
name|mpt_timeout
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reply_frame
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Context only reply, completion without error status. 		 */
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
block|}
else|else
block|{
name|mpt_scsi_reply_frame_handler
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|reply_frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|outofbeer
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|mpt
operator|->
name|outofbeer
operator|=
literal|0
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"THAWQ\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scsi_req
operator|->
name|Function
operator|==
name|MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
operator|&&
name|scsi_req
operator|->
name|CDB
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|&&
operator|(
name|scsi_req
operator|->
name|CDB
index|[
literal|1
index|]
operator|&
name|SI_EVPD
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
comment|/* 		 * Fake out the device type so that only the 		 * pass-thru device will attach. 		 */
name|inq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|inq
operator|->
name|device
operator|&=
operator|~
literal|0x1F
expr_stmt|;
name|inq
operator|->
name|device
operator||=
name|T_NODEVICE
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_TIMEDOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"completing timedout/aborted req %p:%u\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_NEED_WAKEUP
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"mpt_scsi_reply_handler"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_scsi_tmf_reply_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|uint32_t
name|reply_desc
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|MSG_SCSI_TASK_MGMT_REPLY
modifier|*
name|tmf_reply
decl_stmt|;
name|KASSERT
argument_list|(
name|req
operator|==
name|mpt
operator|->
name|tmf_req
argument_list|,
operator|(
literal|"TMF Reply not using mpt->tmf_req"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"mpt_scsi_tmf_reply_handler"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmf_reply
operator|=
operator|(
name|MSG_SCSI_TASK_MGMT_REPLY
operator|*
operator|)
name|reply_frame
expr_stmt|;
comment|/* Record IOC Status and Response Code of TMF for any waiters. */
name|req
operator|->
name|IOCStatus
operator|=
name|le16toh
argument_list|(
name|tmf_reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
name|req
operator|->
name|ResponseCode
operator|=
name|tmf_reply
operator|->
name|ResponseCode
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INFO
argument_list|,
literal|"TMF complete: req %p:%u status 0x%x\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|le16toh
argument_list|(
name|tmf_reply
operator|->
name|IOCStatus
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_NEED_WAKEUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: Move to definitions file  */
end_comment

begin_define
define|#
directive|define
name|ELS
value|0x22
end_define

begin_define
define|#
directive|define
name|FC4LS
value|0x32
end_define

begin_define
define|#
directive|define
name|ABTS
value|0x81
end_define

begin_define
define|#
directive|define
name|BA_ACC
value|0x84
end_define

begin_define
define|#
directive|define
name|LS_RJT
value|0x01
end_define

begin_define
define|#
directive|define
name|LS_ACC
value|0x02
end_define

begin_define
define|#
directive|define
name|PLOGI
value|0x03
end_define

begin_define
define|#
directive|define
name|LOGO
value|0x05
end_define

begin_define
define|#
directive|define
name|SRR
value|0x14
end_define

begin_define
define|#
directive|define
name|PRLI
value|0x20
end_define

begin_define
define|#
directive|define
name|PRLO
value|0x21
end_define

begin_define
define|#
directive|define
name|ADISC
value|0x52
end_define

begin_define
define|#
directive|define
name|RSCN
value|0x61
end_define

begin_function
specifier|static
name|void
name|mpt_fc_els_send_response
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|PTR_MSG_LINK_SERVICE_BUFFER_POST_REPLY
name|rp
parameter_list|,
name|U8
name|length
parameter_list|)
block|{
name|MSG_LINK_SERVICE_RSP_REQUEST
name|tmp
decl_stmt|;
name|PTR_MSG_LINK_SERVICE_RSP_REQUEST
name|rsp
decl_stmt|;
comment|/* 	 * We are going to reuse the ELS request to send this response back. 	 */
name|rsp
operator|=
operator|&
name|tmp
expr_stmt|;
name|memset
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rsp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_IMMEDIATE_LINK_DATA
comment|/* 	 * Apparently the IMMEDIATE stuff doesn't seem to work. 	 */
name|rsp
operator|->
name|RspFlags
operator|=
name|LINK_SERVICE_RSP_FLAGS_IMMEDIATE
expr_stmt|;
endif|#
directive|endif
name|rsp
operator|->
name|RspLength
operator|=
name|length
expr_stmt|;
name|rsp
operator|->
name|Function
operator|=
name|MPI_FUNCTION_FC_LINK_SRVC_RSP
expr_stmt|;
name|rsp
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|fc_els_handler_id
argument_list|)
expr_stmt|;
comment|/* 	 * Copy over information from the original reply frame to 	 * it's correct place in the response. 	 */
name|memcpy
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|rsp
operator|+
literal|0x0c
argument_list|,
operator|(
name|U8
operator|*
operator|)
name|rp
operator|+
literal|0x1c
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* 	 * And now copy back the temporary area to the original frame. 	 */
name|memcpy
argument_list|(
name|req
operator|->
name|req_vbuf
argument_list|,
name|rsp
argument_list|,
sizeof|sizeof
argument_list|(
name|MSG_LINK_SERVICE_RSP_REQUEST
argument_list|)
argument_list|)
expr_stmt|;
name|rsp
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_IMMEDIATE_LINK_DATA
name|memcpy
argument_list|(
operator|(
name|U8
operator|*
operator|)
operator|&
name|rsp
operator|->
name|SGL
argument_list|,
operator|&
operator|(
operator|(
name|U8
operator|*
operator|)
name|req
operator|->
name|req_vbuf
operator|)
index|[
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|PTR_SGE_SIMPLE32
name|se
init|=
operator|(
name|PTR_SGE_SIMPLE32
operator|)
operator|&
name|rsp
operator|->
name|SGL
decl_stmt|;
name|bus_addr_t
name|paddr
init|=
name|req
operator|->
name|req_pbuf
decl_stmt|;
name|paddr
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|se
operator|->
name|FlagsLength
operator|=
name|MPI_SGE_FLAGS_HOST_TO_IOC
operator||
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
name|se
operator|->
name|FlagsLength
operator|<<=
name|MPI_SGE_FLAGS_SHIFT
expr_stmt|;
name|se
operator|->
name|FlagsLength
operator||=
operator|(
name|length
operator|)
expr_stmt|;
name|se
operator|->
name|Address
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Send it on... 	 */
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_fc_els_reply_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|uint32_t
name|reply_desc
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|PTR_MSG_LINK_SERVICE_BUFFER_POST_REPLY
name|rp
init|=
operator|(
name|PTR_MSG_LINK_SERVICE_BUFFER_POST_REPLY
operator|)
name|reply_frame
decl_stmt|;
name|U8
name|rctl
decl_stmt|;
name|U8
name|type
decl_stmt|;
name|U8
name|cmd
decl_stmt|;
name|U16
name|status
init|=
name|le16toh
argument_list|(
name|reply_frame
operator|->
name|IOCStatus
argument_list|)
decl_stmt|;
name|U32
modifier|*
name|elsbuf
decl_stmt|;
name|int
name|ioindex
decl_stmt|;
name|int
name|do_refresh
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
name|mpt_req_on_free_list
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"fc_els_reply_handler: req %p:%u for function %x on freelist!"
operator|,
name|req
operator|,
name|req
operator|->
name|serno
operator|,
name|rp
operator|->
name|Function
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|Function
operator|!=
name|MPI_FUNCTION_FC_PRIMITIVE_SEND
condition|)
block|{
name|mpt_req_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"fc_els_reply_handler"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"fc_els_reply_handler"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INVARIANT
argument_list|,
literal|"FC_ELS Complete: req %p:%u, reply %p function %x\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|reply_frame
argument_list|,
name|reply_frame
operator|->
name|Function
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MPI_IOCSTATUS_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"ELS REPLY STATUS 0x%x for Function %x\n"
argument_list|,
name|status
argument_list|,
name|reply_frame
operator|->
name|Function
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|MPI_IOCSTATUS_INVALID_STATE
condition|)
block|{
comment|/* 			 * XXX: to get around shutdown issue 			 */
name|mpt
operator|->
name|disabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* 	 * If the function of a link service response, we recycle the 	 * response to be a refresh for a new link service request. 	 * 	 * The request pointer is bogus in this case and we have to fetch 	 * it based upon the TransactionContext. 	 */
if|if
condition|(
name|rp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_FC_LINK_SRVC_RSP
condition|)
block|{
comment|/* Freddie Uncle Charlie Katie */
comment|/* We don't get the IOINDEX as part of the Link Svc Rsp */
for|for
control|(
name|ioindex
operator|=
literal|0
init|;
name|ioindex
operator|<
name|mpt
operator|->
name|els_cmds_allocated
condition|;
name|ioindex
operator|++
control|)
if|if
condition|(
name|mpt
operator|->
name|els_cmd_ptrs
index|[
name|ioindex
index|]
operator|==
name|req
condition|)
block|{
break|break;
block|}
name|KASSERT
argument_list|(
name|ioindex
operator|<
name|mpt
operator|->
name|els_cmds_allocated
argument_list|,
operator|(
literal|"can't find my mommie!"
operator|)
argument_list|)
expr_stmt|;
comment|/* remove from active list as we're going to re-post it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|mpt_fc_post_els
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|ioindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|rp
operator|->
name|Function
operator|==
name|MPI_FUNCTION_FC_PRIMITIVE_SEND
condition|)
block|{
comment|/* remove from active list as we're done */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_NEED_WAKEUP
operator|)
operator|==
literal|0
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"Async Primitive Send Complete\n"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"Sync Primitive Send Complete\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|rp
operator|->
name|Function
operator|!=
name|MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"unexpected ELS_REPLY: Function 0x%x Flags %x "
literal|"Length %d Message Flags %x\n"
argument_list|,
name|rp
operator|->
name|Function
argument_list|,
name|rp
operator|->
name|Flags
argument_list|,
name|rp
operator|->
name|MsgLength
argument_list|,
name|rp
operator|->
name|MsgFlags
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|rp
operator|->
name|MsgLength
operator|<=
literal|5
condition|)
block|{
comment|/* 		 * This is just a ack of an original ELS buffer post 		 */
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INVARIANT
argument_list|,
literal|"RECV'd ACK of FC_ELS buf post %p:%u\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|rctl
operator|=
operator|(
name|le32toh
argument_list|(
name|rp
operator|->
name|Rctl_Did
argument_list|)
operator|&
name|MPI_FC_RCTL_MASK
operator|)
operator|>>
name|MPI_FC_RCTL_SHIFT
expr_stmt|;
name|type
operator|=
operator|(
name|le32toh
argument_list|(
name|rp
operator|->
name|Type_Fctl
argument_list|)
operator|&
name|MPI_FC_TYPE_MASK
operator|)
operator|>>
name|MPI_FC_TYPE_SHIFT
expr_stmt|;
name|elsbuf
operator|=
operator|&
operator|(
operator|(
name|U32
operator|*
operator|)
name|req
operator|->
name|req_vbuf
operator|)
index|[
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
index|]
expr_stmt|;
name|cmd
operator|=
name|be32toh
argument_list|(
name|elsbuf
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|Flags
operator|&
name|MPI_LS_BUF_POST_REPLY_FLAG_NO_RSP_NEEDED
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_ALWAYS
argument_list|,
literal|"ELS_REPLY: response unneeded\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|ioindex
operator|=
name|le32toh
argument_list|(
name|rp
operator|->
name|TransactionContext
argument_list|)
expr_stmt|;
name|req
operator|=
name|mpt
operator|->
name|els_cmd_ptrs
index|[
name|ioindex
index|]
expr_stmt|;
if|if
condition|(
name|rctl
operator|==
name|ELS
operator|&&
name|type
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRLI
case|:
comment|/* 			 * Send back a PRLI ACC 			 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"PRLI from 0x%08x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|rp
operator|->
name|Wwn
operator|.
name|PortNameHigh
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|rp
operator|->
name|Wwn
operator|.
name|PortNameLow
argument_list|)
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
literal|0x02100014
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|1
index|]
operator||=
name|htobe32
argument_list|(
literal|0x00000100
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|4
index|]
operator|=
name|htobe32
argument_list|(
literal|0x00000002
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|role
operator|&
name|MPT_ROLE_TARGET
condition|)
name|elsbuf
index|[
literal|4
index|]
operator||=
name|htobe32
argument_list|(
literal|0x00000010
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|role
operator|&
name|MPT_ROLE_INITIATOR
condition|)
name|elsbuf
index|[
literal|4
index|]
operator||=
name|htobe32
argument_list|(
literal|0x00000020
argument_list|)
expr_stmt|;
comment|/* remove from active list as we're done */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|mpt_fc_els_send_response
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|rp
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|do_refresh
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|PRLO
case|:
name|memset
argument_list|(
name|elsbuf
argument_list|,
literal|0
argument_list|,
literal|5
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
literal|0x02100014
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
literal|0x08000100
argument_list|)
expr_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"PRLO from 0x%08x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|rp
operator|->
name|Wwn
operator|.
name|PortNameHigh
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|rp
operator|->
name|Wwn
operator|.
name|PortNameLow
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove from active list as we're done */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|mpt_fc_els_send_response
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|rp
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|do_refresh
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"ELS TYPE 1 COMMAND: %x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|rctl
operator|==
name|ABTS
operator|&&
name|type
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|rx_id
init|=
name|le16toh
argument_list|(
name|rp
operator|->
name|Rxid
argument_list|)
decl_stmt|;
name|uint16_t
name|ox_id
init|=
name|le16toh
argument_list|(
name|rp
operator|->
name|Oxid
argument_list|)
decl_stmt|;
name|request_t
modifier|*
name|tgt_req
init|=
name|NULL
decl_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"ELS: ABTS OX_ID 0x%x RX_ID 0x%x from 0x%08x%08x\n"
argument_list|,
name|ox_id
argument_list|,
name|rx_id
argument_list|,
name|le32toh
argument_list|(
name|rp
operator|->
name|Wwn
operator|.
name|PortNameHigh
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|rp
operator|->
name|Wwn
operator|.
name|PortNameLow
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_id
operator|>=
name|mpt
operator|->
name|mpt_max_tgtcmds
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Bad RX_ID 0x%x\n"
argument_list|,
name|rx_id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|tgt_cmd_ptrs
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"No TGT CMD PTRS\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tgt_req
operator|=
name|mpt
operator|->
name|tgt_cmd_ptrs
index|[
name|rx_id
index|]
expr_stmt|;
block|}
if|if
condition|(
name|tgt_req
condition|)
block|{
name|mpt_tgt_state_t
modifier|*
name|tgt
init|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|tgt_req
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|vbuf
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|tgt
operator|->
name|ccb
decl_stmt|;
name|uint32_t
name|ct_id
decl_stmt|;
name|vbuf
operator|=
name|tgt_req
operator|->
name|req_vbuf
expr_stmt|;
name|vbuf
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 			 * Check to make sure we have the correct command 			 * The reply descriptor in the target state should 			 * should contain an IoIndex that should match the 			 * RX_ID. 			 * 			 * It'd be nice to have OX_ID to crosscheck with 			 * as well. 			 */
name|ct_id
operator|=
name|GET_IO_INDEX
argument_list|(
name|tgt
operator|->
name|reply_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct_id
operator|!=
name|rx_id
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_ERROR
argument_list|,
literal|"ABORT Mismatch: "
literal|"RX_ID received=0x%x; RX_ID in cmd=0x%x\n"
argument_list|,
name|rx_id
argument_list|,
name|ct_id
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|ccb
operator|=
name|tgt
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"CCB (%p): lun %u flags %x status %x\n"
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"target state 0x%x resid %u xfrd %u rpwrd "
literal|"%x nxfers %x\n"
argument_list|,
name|tgt
operator|->
name|state
argument_list|,
name|tgt
operator|->
name|resid
argument_list|,
name|tgt
operator|->
name|bytes_xfered
argument_list|,
name|tgt
operator|->
name|reply_desc
argument_list|,
name|tgt
operator|->
name|nxfers
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
name|mpt_abort_target_cmd
argument_list|(
name|mpt
argument_list|,
name|tgt_req
argument_list|)
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"unable to start TargetAbort\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"no back pointer for RX_ID 0x%x\n"
argument_list|,
name|rx_id
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|elsbuf
argument_list|,
literal|0
argument_list|,
literal|5
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
operator|(
name|ox_id
operator|<<
literal|16
operator|)
operator||
name|rx_id
argument_list|)
expr_stmt|;
name|elsbuf
index|[
literal|2
index|]
operator|=
name|htobe32
argument_list|(
literal|0x000ffff
argument_list|)
expr_stmt|;
comment|/* 		 * Dork with the reply frame so that the reponse to it 		 * will be correct. 		 */
name|rp
operator|->
name|Rctl_Did
operator|+=
operator|(
operator|(
name|BA_ACC
operator|-
name|ABTS
operator|)
operator|<<
name|MPI_FC_RCTL_SHIFT
operator|)
expr_stmt|;
comment|/* remove from active list as we're done */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|mpt_fc_els_send_response
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|rp
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|do_refresh
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"ELS: RCTL %x TYPE %x CMD %x\n"
argument_list|,
name|rctl
argument_list|,
name|type
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_refresh
operator|==
name|TRUE
condition|)
block|{
comment|/* remove from active list as we're done */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|&=
operator|~
name|REQ_STATE_QUEUED
expr_stmt|;
name|req
operator|->
name|state
operator||=
name|REQ_STATE_DONE
expr_stmt|;
name|mpt_fc_post_els
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|ioindex
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up all SCSI Initiator personality state in response  * to a controller reset.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_cam_ioc_reset
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|type
parameter_list|)
block|{
comment|/* 	 * The pending list is already run down by 	 * the generic handler.  Perform the same 	 * operation on the timed out request list. 	 */
name|mpt_complete_request_chain
argument_list|(
name|mpt
argument_list|,
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|MPI_IOCSTATUS_INVALID_STATE
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: We need to repost ELS and Target Command Buffers? 	 */
comment|/* 	 * Inform the XPT that a bus reset has occurred. 	 */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|mpt
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse additional completion information in the reply  * frame for SCSI I/O requests.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_scsi_reply_frame_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|MSG_SCSI_IO_REPLY
modifier|*
name|scsi_io_reply
decl_stmt|;
name|u_int
name|ioc_status
decl_stmt|;
name|u_int
name|sstate
decl_stmt|;
name|u_int
name|loginfo
decl_stmt|;
name|MPT_DUMP_REPLY_FRAME
argument_list|(
name|mpt
argument_list|,
name|reply_frame
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|reply_frame
operator|->
name|Function
operator|==
name|MPI_FUNCTION_SCSI_IO_REQUEST
operator|||
name|reply_frame
operator|->
name|Function
operator|==
name|MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH
argument_list|,
operator|(
literal|"MPT SCSI I/O Handler called with incorrect reply type"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|reply_frame
operator|->
name|MsgFlags
operator|&
name|MPI_MSGFLAGS_CONTINUATION_REPLY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"MPT SCSI I/O Handler called with continuation reply"
operator|)
argument_list|)
expr_stmt|;
name|scsi_io_reply
operator|=
operator|(
name|MSG_SCSI_IO_REPLY
operator|*
operator|)
name|reply_frame
expr_stmt|;
name|ioc_status
operator|=
name|le16toh
argument_list|(
name|scsi_io_reply
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
name|loginfo
operator|=
name|ioc_status
operator|&
name|MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE
expr_stmt|;
name|ioc_status
operator|&=
name|MPI_IOCSTATUS_MASK
expr_stmt|;
name|sstate
operator|=
name|scsi_io_reply
operator|->
name|SCSIState
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|le32toh
argument_list|(
name|scsi_io_reply
operator|->
name|TransferCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_AUTOSENSE_VALID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
operator|(
name|CAM_SENSE_PHYS
operator||
name|CAM_SENSE_PTR
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|scsi_io_reply
operator|->
name|SenseCount
expr_stmt|;
name|bcopy
argument_list|(
name|req
operator|->
name|sense_vbuf
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|min
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|,
name|scsi_io_reply
operator|->
name|SenseCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_QUEUE_TAG_REJECTED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Tag messages rejected, but non-tagged retry 		 * was successful. XXXX 		mpt_set_tags(mpt, devinfo, MPT_QUEUE_NONE); 		 */
block|}
switch|switch
condition|(
name|ioc_status
condition|)
block|{
case|case
name|MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH
case|:
comment|/* 		 * XXX 		 * Linux driver indicates that a zero 		 * transfer length with this error code 		 * indicates a CRC error. 		 * 		 * No need to swap the bytes for checking 		 * against zero. 		 */
if|if
condition|(
name|scsi_io_reply
operator|->
name|TransferCount
operator|==
literal|0
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_UNCOR_PARITY
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|MPI_IOCSTATUS_SCSI_DATA_UNDERRUN
case|:
case|case
name|MPI_IOCSTATUS_SUCCESS
case|:
case|case
name|MPI_IOCSTATUS_SCSI_RECOVERED_ERROR
case|:
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_NO_SCSI_STATUS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Status was never returned for this transaction. 			 */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_UNEXP_BUSFREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scsi_io_reply
operator|->
name|SCSIStatus
operator|!=
name|SCSI_STATUS_OK
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|scsi_io_reply
operator|->
name|SCSIStatus
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_SCSI_STATUS_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_AUTOSENSE_FAILED
operator|)
operator|!=
literal|0
condition|)
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_AUTOSENSE_FAIL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sstate
operator|&
name|MPI_SCSI_STATE_RESPONSE_INFO_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX Handle SPI-Packet and FCP-2 reponse info. */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
block|}
else|else
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_DATA_OVERRUN
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_DATA_RUN_ERR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_IO_DATA_ERROR
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_UNCOR_PARITY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE
case|:
comment|/* 		 * Since selection timeouts and "device really not 		 * there" are grouped into this error code, report 		 * selection timeout.  Selection timeouts are 		 * typically retried before giving up on the device 		 * whereas "device not there" errors are considered 		 * unretryable. 		 */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_SEL_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_SEQUENCE_FAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_INVALID_BUS
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_PATH_INVALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_INVALID_TARGETID
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_TID_INVALID
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_TERMIO
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_INVALID_STATE
case|:
comment|/* 		 * The IOC has been reset.  Emulate a bus reset. 		 */
comment|/* FALLTHROUGH */
case|case
name|MPI_IOCSTATUS_SCSI_EXT_TERMINATED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_SCSI_TASK_TERMINATED
case|:
case|case
name|MPI_IOCSTATUS_SCSI_IOC_TERMINATED
case|:
comment|/* 		 * Don't clobber any timeout status that has 		 * already been set for this transaction.  We 		 * want the SCSI layer to be able to differentiate 		 * between the command we aborted due to timeout 		 * and any innocent bystanders. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
break|break;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_TERMIO
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_INSUFFICIENT_RESOURCES
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_RESRC_UNAVAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_BUSY
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_BUSY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_IOCSTATUS_INVALID_FUNCTION
case|:
case|case
name|MPI_IOCSTATUS_INVALID_SGL
case|:
case|case
name|MPI_IOCSTATUS_INTERNAL_ERROR
case|:
case|case
name|MPI_IOCSTATUS_INVALID_FIELD
case|:
default|default:
comment|/* XXX 		 * Some of the above may need to kick 		 * of a recovery action!!!! 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNREC_HBA_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|mpt_freeze_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|u_int
name|tgt
decl_stmt|;
name|int
name|raid_passthru
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"mpt_action\n"
operator|)
argument_list|)
expr_stmt|;
name|mpt
operator|=
operator|(
expr|struct
name|mpt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|MPT_OWNED
argument_list|(
name|mpt
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"mpt owned on entrance to mpt_action"
operator|)
argument_list|)
expr_stmt|;
name|raid_passthru
operator|=
operator|(
name|sim
operator|==
name|mpt
operator|->
name|phydisk_sim
operator|)
expr_stmt|;
name|tgt
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
if|if
condition|(
name|raid_passthru
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_PATH_INQ
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_RESET_BUS
condition|)
block|{
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt_map_physdisk
argument_list|(
name|mpt
argument_list|,
name|ccb
argument_list|,
operator|&
name|tgt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
operator|=
name|mpt
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
comment|/* 		 * Do a couple of preliminary checks... 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Max supported CDB length is 16 bytes */
comment|/* XXX Unless we implement the new 32byte message type */
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|PTR_MSG_SCSI_IO_REQUEST
operator|)
literal|0
operator|)
operator|->
name|CDB
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
name|mpt_start
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_RESET_BUS
case|:
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"XPT_RESET_BUS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|raid_passthru
condition|)
block|{
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mpt_bus_reset
argument_list|(
name|mpt
argument_list|,
comment|/*sleep_ok*/
name|FALSE
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * mpt_bus_reset is always successful in that it 		 * will fall back to a hard reset should a bus 		 * reset attempt fail. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|accb
init|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
decl_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|accb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|mpt_abort_target_ccb
argument_list|(
name|mpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_CONT_TARGET_IO
case|:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"cannot abort active CTIOs yet\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
case|case
name|XPT_SCSI_IO
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UA_ABORT
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
define|#
directive|define
name|IS_CURRENT_SETTINGS
parameter_list|(
name|c
parameter_list|)
value|(c->type == CTS_TYPE_CURRENT_SETTINGS)
else|#
directive|else
define|#
directive|define
name|IS_CURRENT_SETTINGS
parameter_list|(
name|c
parameter_list|)
value|(c->flags& CCB_TRANS_CURRENT_SETTINGS)
endif|#
directive|endif
define|#
directive|define
name|DP_DISC_ENABLE
value|0x1
define|#
directive|define
name|DP_DISC_DISABL
value|0x2
define|#
directive|define
name|DP_DISC
value|(DP_DISC_ENABLE|DP_DISC_DISABL)
define|#
directive|define
name|DP_TQING_ENABLE
value|0x4
define|#
directive|define
name|DP_TQING_DISABL
value|0x8
define|#
directive|define
name|DP_TQING
value|(DP_TQING_ENABLE|DP_TQING_DISABL)
define|#
directive|define
name|DP_WIDE
value|0x10
define|#
directive|define
name|DP_NARROW
value|0x20
define|#
directive|define
name|DP_WIDTH
value|(DP_WIDE|DP_NARROW)
define|#
directive|define
name|DP_SYNC
value|0x40
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* Nexus Settings */
block|{
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
endif|#
directive|endif
name|uint8_t
name|dval
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|int
name|m
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Attempt to set User settings\n"
argument_list|)
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|||
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|mpt
operator|->
name|mpt_port_page2
operator|.
name|PortSettings
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|&
name|MPI_SCSIPORTPAGE2_PORT_MASK_NEGO_MASTER_SETTINGS
operator|)
operator|==
name|MPI_SCSIPORTPAGE2_PORT_ALL_MASTER_SETTINGS
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|dval
operator|=
literal|0
expr_stmt|;
name|period
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
condition|)
block|{
name|dval
operator||=
name|DP_DISC_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
condition|)
block|{
name|dval
operator||=
name|DP_TQING_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
condition|)
block|{
if|if
condition|(
name|cts
operator|->
name|bus_width
condition|)
name|dval
operator||=
name|DP_WIDE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_NARROW
expr_stmt|;
block|}
comment|/* 		 * Any SYNC RATE of nonzero and SYNC_OFFSET 		 * of nonzero will cause us to go to the 		 * selected (from NVRAM) maximum value for 		 * this device. At a later point, we'll 		 * allow finer control. 		 */
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|&&
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_SYNC
expr_stmt|;
name|period
operator|=
name|cts
operator|->
name|sync_period
expr_stmt|;
name|offset
operator|=
name|cts
operator|->
name|sync_offset
expr_stmt|;
block|}
else|#
directive|else
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|dval
operator||=
name|DP_DISC_ENABLE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_DISC_DISABL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|dval
operator||=
name|DP_TQING_ENABLE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_TQING_DISABL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|bus_width
operator|==
name|MSG_EXT_WDTR_BUS_16_BIT
condition|)
name|dval
operator||=
name|DP_WIDE
expr_stmt|;
else|else
name|dval
operator||=
name|DP_NARROW
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|&&
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|&&
operator|(
name|spi
operator|->
name|sync_period
operator|&&
name|spi
operator|->
name|sync_offset
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_SYNC
expr_stmt|;
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
block|}
endif|#
directive|endif
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_DISC_ENABLE
condition|)
block|{
name|mpt
operator|->
name|mpt_disc_enable
operator||=
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dval
operator|&
name|DP_DISC_DISABL
condition|)
block|{
name|mpt
operator|->
name|mpt_disc_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_TQING_ENABLE
condition|)
block|{
name|mpt
operator|->
name|mpt_tag_enable
operator||=
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dval
operator|&
name|DP_TQING_DISABL
condition|)
block|{
name|mpt
operator|->
name|mpt_tag_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|tgt
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_WIDTH
condition|)
block|{
name|mpt_setwidth
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_SYNC
condition|)
block|{
name|mpt_setsync
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"SET tgt %d flags %x period %x off %x\n"
argument_list|,
name|tgt
argument_list|,
name|dval
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
comment|/* 			 * a lot of normal SCSI things don't make sense. 			 */
name|cts
operator|->
name|flags
operator|=
name|CCB_TRANS_TAG_ENB
operator||
name|CCB_TRANS_DISC_ENB
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
comment|/* 			 * How do you measure the width of a high 			 * speed serial bus? Well, in bytes. 			 * 			 * Offset and period make no sense, though, so we set 			 * (above) a 'base' transfer speed to be gigabit. 			 */
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
else|#
directive|else
name|struct
name|ccb_trans_settings_fc
modifier|*
name|fc
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|fc
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_FC
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|fc
operator|->
name|valid
operator|=
name|CTS_FC_VALID_SPEED
expr_stmt|;
name|fc
operator|->
name|bitrate
operator|=
literal|100000
expr_stmt|;
comment|/* XXX: Need for 2Gb/s */
comment|/* XXX: need a port database for each target */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
name|cts
operator|->
name|flags
operator|=
name|CCB_TRANS_TAG_ENB
operator||
name|CCB_TRANS_DISC_ENB
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
comment|/* 			 * How do you measure the width of a high 			 * speed serial bus? Well, in bytes. 			 * 			 * Offset and period make no sense, though, so we set 			 * (above) a 'base' transfer speed to be gigabit. 			 */
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
else|#
directive|else
name|struct
name|ccb_trans_settings_sas
modifier|*
name|sas
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|sas
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_3
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SAS
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|0
expr_stmt|;
name|sas
operator|->
name|valid
operator|=
name|CTS_SAS_VALID_SPEED
expr_stmt|;
name|sas
operator|->
name|bitrate
operator|=
literal|300000
expr_stmt|;
comment|/* XXX: Default 3Gbps */
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|mpt_get_spi_settings
argument_list|(
name|mpt
argument_list|,
name|cts
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|mpt_calc_geometry
argument_list|(
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
comment|/* XXX Report base speed more accurately for FC/SAS, etc.*/
if|if
condition|(
name|raid_passthru
condition|)
block|{
name|cpi
operator|->
name|max_target
operator|=
name|mpt
operator|->
name|ioc_page2
operator|->
name|MaxPhysDisks
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|cpi
operator|->
name|max_target
operator|+
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|100000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
comment|/* XXX SHOULD BE BASED UPON IOC FACTS XXX XXX */
name|cpi
operator|->
name|max_target
operator|=
literal|255
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|mpt
operator|->
name|mpt_ini_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|100000
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|cpi
operator|->
name|max_target
operator|=
literal|63
expr_stmt|;
comment|/* XXX */
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|mpt
operator|->
name|mpt_ini_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|300000
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_TAG_ABLE
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|initiator_id
operator|=
name|mpt
operator|->
name|mpt_ini_id
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|15
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mpt
operator|->
name|role
operator|&
name|MPT_ROLE_INITIATOR
operator|)
operator|==
literal|0
condition|)
block|{
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOINITIATOR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mpt
operator|->
name|role
operator|&
name|MPT_ROLE_TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpi
operator|->
name|target_sprt
operator|=
name|PIT_PROCESSOR
operator||
name|PIT_DISCONNECT
operator||
name|PIT_TERM_IO
expr_stmt|;
block|}
else|else
block|{
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"LSI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
block|{
name|int
name|result
decl_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|cel
operator|.
name|enable
condition|)
name|result
operator|=
name|mpt_enable_lun
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|mpt_disable_lun
argument_list|(
name|mpt
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_NOTIFY_ACK
case|:
comment|/* recycle notify ack */
case|case
name|XPT_IMMED_NOTIFY
case|:
comment|/* Add Immediate Notify Resource */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Add Accept Target IO Resource */
block|{
name|tgt_resource_t
modifier|*
name|trtp
decl_stmt|;
name|lun_id_t
name|lun
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
decl_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|sim_priv
operator|.
name|entries
index|[
literal|0
index|]
operator|.
name|field
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|sim_priv
operator|.
name|entries
index|[
literal|1
index|]
operator|.
name|ptr
operator|=
name|mpt
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|CAM_TARGET_WILDCARD
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|trtp
operator|=
operator|&
name|mpt
operator|->
name|trt_wildcard
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|>=
name|MPT_MAX_LUNS
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|trtp
operator|=
operator|&
name|mpt
operator|->
name|trt
index|[
name|lun
index|]
expr_stmt|;
block|}
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG1
argument_list|,
literal|"Put FREE ATIO %p lun %d\n"
argument_list|,
name|ccb
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|trtp
operator|->
name|atios
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_IMMED_NOTIFY
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG1
argument_list|,
literal|"Put FREE INOT lun %d\n"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|trtp
operator|->
name|inots
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_ALWAYS
argument_list|,
literal|"Got Notify ACK\n"
argument_list|)
expr_stmt|;
block|}
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_INPROG
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CONT_TARGET_IO
case|:
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_target_start_io
argument_list|(
name|mpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_get_spi_settings
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CAM_NEW_TRAN_CODE
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
endif|#
directive|endif
name|int
name|tgt
decl_stmt|;
name|uint8_t
name|dval
decl_stmt|,
name|pval
decl_stmt|,
name|oval
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|tgt
operator|=
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
comment|/* 	 * We aren't going off of Port PAGE2 params for 	 * tagged queuing or disconnect capabilities 	 * for current settings. For goal settings, 	 * we assert all capabilities- we've had some 	 * problems with reading NVRAM data. 	 */
if|if
condition|(
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|)
block|{
name|CONFIG_PAGE_SCSI_DEVICE_0
name|tmp
decl_stmt|;
name|dval
operator|=
literal|0
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|mpt
operator|->
name|mpt_dev_page0
index|[
name|tgt
index|]
expr_stmt|;
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"can't get tgt %d config page 0\n"
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"mpt_get_spi: SPI Tgt %d Page 0: NParms %x Info %x\n"
argument_list|,
name|tgt
argument_list|,
name|tmp
operator|.
name|NegotiatedParameters
argument_list|,
name|tmp
operator|.
name|Information
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|NegotiatedParameters
operator|&
name|MPI_SCSIDEVPAGE0_NP_WIDE
condition|)
block|{
name|dval
operator||=
name|DP_WIDE
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|mpt_disc_enable
operator|&
operator|(
literal|1
operator|<<
name|tgt
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_DISC_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|mpt_tag_enable
operator|&
operator|(
literal|1
operator|<<
name|tgt
operator|)
condition|)
block|{
name|dval
operator||=
name|DP_TQING_ENABLE
expr_stmt|;
block|}
name|oval
operator|=
operator|(
name|tmp
operator|.
name|NegotiatedParameters
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pval
operator|=
operator|(
name|tmp
operator|.
name|NegotiatedParameters
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX: Fix wrt NVRAM someday. Attempts 		 * XXX: to read port page2 device data 		 * XXX: just returns zero in these areas. 		 */
name|dval
operator|=
name|DP_WIDE
operator||
name|DP_DISC
operator||
name|DP_TQING
expr_stmt|;
name|oval
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|16
operator|)
expr_stmt|;
name|pval
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CAM_NEW_TRAN_CODE
name|cts
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_DISC_ENABLE
condition|)
block|{
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_TQING_ENABLE
condition|)
block|{
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_WIDE
condition|)
block|{
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
block|}
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
if|if
condition|(
name|oval
condition|)
block|{
name|cts
operator|->
name|sync_period
operator|=
name|pval
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
name|oval
expr_stmt|;
name|cts
operator|->
name|valid
operator||=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
block|}
else|#
directive|else
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_DISC_ENABLE
condition|)
block|{
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
block|}
if|if
condition|(
name|dval
operator|&
name|DP_TQING_ENABLE
condition|)
block|{
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
if|if
condition|(
name|oval
operator|&&
name|pval
condition|)
block|{
name|spi
operator|->
name|sync_offset
operator|=
name|oval
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
name|pval
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_SYNC_RATE
expr_stmt|;
block|}
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_BUS_WIDTH
expr_stmt|;
if|if
condition|(
name|dval
operator|&
name|DP_WIDE
condition|)
block|{
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
else|else
block|{
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
name|CAM_LUN_WILDCARD
condition|)
block|{
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
block|}
else|else
block|{
name|scsi
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"mpt_get_spi: tgt %d %s settings flags %x period %x offset %x\n"
argument_list|,
name|tgt
argument_list|,
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|?
literal|"ACTIVE"
else|:
literal|"NVRAM"
argument_list|,
name|dval
argument_list|,
name|pval
argument_list|,
name|oval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_setwidth
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|tgt
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|PTR_CONFIG_PAGE_SCSI_DEVICE_1
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|&
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|tmp
operator|->
name|RequestedParameters
operator||=
name|MPI_SCSIDEVPAGE1_RP_WIDE
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_WIDE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_setsync
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|tgt
parameter_list|,
name|int
name|period
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|PTR_CONFIG_PAGE_SCSI_DEVICE_1
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|&
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
expr_stmt|;
name|tmp
operator|->
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_MIN_SYNC_PERIOD_MASK
expr_stmt|;
name|tmp
operator|->
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_MAX_SYNC_OFFSET_MASK
expr_stmt|;
name|tmp
operator|->
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_DT
expr_stmt|;
name|tmp
operator|->
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_QAS
expr_stmt|;
name|tmp
operator|->
name|RequestedParameters
operator|&=
operator|~
name|MPI_SCSIDEVPAGE1_RP_IU
expr_stmt|;
comment|/* 	 * XXX: For now, we're ignoring specific settings 	 */
if|if
condition|(
name|period
operator|&&
name|offset
condition|)
block|{
name|int
name|factor
decl_stmt|,
name|offset
decl_stmt|,
name|np
decl_stmt|;
name|factor
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|offset
operator|=
operator|(
name|mpt
operator|->
name|mpt_port_page0
operator|.
name|Capabilities
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|np
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|factor
operator|<
literal|0x9
condition|)
block|{
name|np
operator||=
name|MPI_SCSIDEVPAGE1_RP_QAS
expr_stmt|;
name|np
operator||=
name|MPI_SCSIDEVPAGE1_RP_IU
expr_stmt|;
block|}
if|if
condition|(
name|factor
operator|<
literal|0xa
condition|)
block|{
name|np
operator||=
name|MPI_SCSIDEVPAGE1_RP_DT
expr_stmt|;
block|}
name|np
operator||=
operator|(
name|factor
operator|<<
literal|8
operator|)
operator||
operator|(
name|offset
operator|<<
literal|16
operator|)
expr_stmt|;
name|tmp
operator|->
name|RequestedParameters
operator||=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_update_spi_config
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|int
name|tgt
parameter_list|)
block|{
name|CONFIG_PAGE_SCSI_DEVICE_1
name|tmp
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|tmp
operator|=
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
expr_stmt|;
name|rv
operator|=
name|mpt_write_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_update_spi_config: write cur page failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|mpt_read_cur_cfg_page
argument_list|(
name|mpt
argument_list|,
name|tgt
argument_list|,
operator|&
name|tmp
operator|.
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|FALSE
argument_list|,
literal|500
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_update_spi_config: read cur page failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|=
name|tmp
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"mpt_update_spi_config[%d]: Page 1: RParams %x Config %x\n"
argument_list|,
name|tgt
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|.
name|RequestedParameters
argument_list|,
name|mpt
operator|->
name|mpt_dev_page1
index|[
name|tgt
index|]
operator|.
name|Configuration
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_calc_geometry
parameter_list|(
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
parameter_list|,
name|int
name|extended
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|cam_calc_geometry
argument_list|(
name|ccg
argument_list|,
name|extended
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint32_t
name|size_mb
decl_stmt|;
name|uint32_t
name|secs_per_cylinder
decl_stmt|;
if|if
condition|(
name|ccg
operator|->
name|block_size
operator|==
literal|0
condition|)
block|{
name|ccg
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
return|return;
block|}
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccg
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************** Timeout Recovery ******************************/
end_comment

begin_function
specifier|static
name|int
name|mpt_spawn_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|mpt_kthread_create
argument_list|(
name|mpt_recovery_thread
argument_list|,
name|mpt
argument_list|,
operator|&
name|mpt
operator|->
name|recovery_thread
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*altstack*/
literal|0
argument_list|,
literal|"mpt_recovery%d"
argument_list|,
name|mpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_terminate_recovery_thread
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
if|if
condition|(
name|mpt
operator|->
name|recovery_thread
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|mpt
operator|->
name|shutdwn_recovery
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 	 * Sleep on a slightly different location 	 * for this interlock just for added safety. 	 */
name|mpt_sleep
argument_list|(
name|mpt
argument_list|,
operator|&
name|mpt
operator|->
name|recovery_thread
argument_list|,
name|PUSER
argument_list|,
literal|"thtrm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_recovery_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mpt_softc
modifier|*
name|mpt
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpt
operator|=
operator|(
expr|struct
name|mpt_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|MPT_LOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|shutdwn_recovery
operator|==
literal|0
condition|)
block|{
name|mpt_sleep
argument_list|(
name|mpt
argument_list|,
name|mpt
argument_list|,
name|PUSER
argument_list|,
literal|"idle"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mpt
operator|->
name|shutdwn_recovery
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|mpt_recover_commands
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
name|mpt
operator|->
name|recovery_thread
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|mpt
operator|->
name|recovery_thread
argument_list|)
expr_stmt|;
name|MPT_UNLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_scsi_send_tmf
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|u_int
name|type
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|u_int
name|channel
parameter_list|,
name|u_int
name|target
parameter_list|,
name|u_int
name|lun
parameter_list|,
name|u_int
name|abort_ctx
parameter_list|,
name|int
name|sleep_ok
parameter_list|)
block|{
name|MSG_SCSI_TASK_MGMT
modifier|*
name|tmf_req
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Wait for any current TMF request to complete. 	 * We're only allowed to issue one TMF at a time. 	 */
name|error
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|REQ_STATE_FREE
argument_list|,
name|REQ_STATE_FREE
argument_list|,
name|sleep_ok
argument_list|,
name|MPT_TMF_MAX_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|mpt_assign_serno
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_ALLOCATED
operator||
name|REQ_STATE_QUEUED
expr_stmt|;
name|tmf_req
operator|=
operator|(
name|MSG_SCSI_TASK_MGMT
operator|*
operator|)
name|mpt
operator|->
name|tmf_req
operator|->
name|req_vbuf
expr_stmt|;
name|memset
argument_list|(
name|tmf_req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmf_req
argument_list|)
argument_list|)
expr_stmt|;
name|tmf_req
operator|->
name|TargetID
operator|=
name|target
expr_stmt|;
name|tmf_req
operator|->
name|Bus
operator|=
name|channel
expr_stmt|;
name|tmf_req
operator|->
name|ChainOffset
operator|=
literal|0
expr_stmt|;
name|tmf_req
operator|->
name|Function
operator|=
name|MPI_FUNCTION_SCSI_TASK_MGMT
expr_stmt|;
name|tmf_req
operator|->
name|Reserved
operator|=
literal|0
expr_stmt|;
name|tmf_req
operator|->
name|TaskType
operator|=
name|type
expr_stmt|;
name|tmf_req
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|tmf_req
operator|->
name|MsgFlags
operator|=
name|flags
expr_stmt|;
name|tmf_req
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|mpt
operator|->
name|tmf_req
operator|->
name|index
operator||
name|scsi_tmf_handler_id
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tmf_req
operator|->
name|LUN
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmf_req
operator|->
name|LUN
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tmf_req
operator|->
name|Reserved2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lun
operator|>
literal|256
condition|)
block|{
name|tmf_req
operator|->
name|LUN
index|[
literal|0
index|]
operator|=
literal|0x40
operator||
operator|(
operator|(
name|lun
operator|>>
literal|8
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|tmf_req
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|lun
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|tmf_req
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|lun
expr_stmt|;
block|}
name|tmf_req
operator|->
name|TaskMsgContext
operator|=
name|abort_ctx
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INFO
argument_list|,
literal|"Issuing TMF %p:%u with MsgContext of 0x%x\n"
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|mpt
operator|->
name|tmf_req
operator|->
name|serno
argument_list|,
name|tmf_req
operator|->
name|MsgContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>
name|MPT_PRT_DEBUG
condition|)
block|{
name|mpt_print_request
argument_list|(
name|tmf_req
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|mpt_req_on_pending_list
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"mpt_scsi_send_tmf: tmf_req already on pending list"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|error
operator|=
name|mpt_send_handshake_cmd
argument_list|(
name|mpt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tmf_req
argument_list|)
argument_list|,
name|tmf_req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|MPT_OK
condition|)
block|{
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a command times out, it is placed on the requeust_timeout_list  * and we wake our recovery thread.  The MPT-Fusion architecture supports  * only a single TMF operation at a time, so we serially abort/bdr, etc,  * the timedout transactions.  The next TMF is issued either by the  * completion handler of the current TMF waking our recovery thread,  * or the TMF timeout handler causing a hard reset sequence.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_recover_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * No work to do- leave. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_recover_commands: no requests.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Flush any commands whose completion coincides with their timeout. 	 */
name|mpt_intr
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The timedout commands have already 		 * completed.  This typically means 		 * that either the timeout value was on 		 * the hairy edge of what the device 		 * requires or - more likely - interrupts 		 * are not happening. 		 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Timedout requests already complete. "
literal|"Interrupts may not be functioning.\n"
argument_list|)
expr_stmt|;
name|mpt_enable_ints
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We have no visibility into the current state of the 	 * controller, so attempt to abort the commands in the 	 * order they timed-out. For initiator commands, we 	 * depend on the reply handler pulling requests off 	 * the timeout list. 	 */
while|while
condition|(
operator|(
name|req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uint16_t
name|status
decl_stmt|;
name|uint8_t
name|response
decl_stmt|;
name|MSG_REQUEST_HEADER
modifier|*
name|hdrp
init|=
name|req
operator|->
name|req_vbuf
decl_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"attempting to abort req %p:%u function %x\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|hdrp
operator|->
name|Function
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|req
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"null ccb in timed out request. "
literal|"Resetting Controller.\n"
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if this is not an initiator command and 		 * deal with it differently if it is. 		 */
switch|switch
condition|(
name|hdrp
operator|->
name|Function
condition|)
block|{
case|case
name|MPI_FUNCTION_SCSI_IO_REQUEST
case|:
break|break;
default|default:
comment|/* 			 * XXX: FIX ME: need to abort target assists... 			 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"just putting it back on the pend q\n"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_timeout_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|mpt_scsi_send_tmf
argument_list|(
name|mpt
argument_list|,
name|MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|scsi_io_handler_id
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * mpt_scsi_send_tmf hard resets on failure, so no 			 * need to do so here.  Our queue should be emptied 			 * by the hard reset. 			 */
continue|continue;
block|}
name|error
operator|=
name|mpt_wait_req
argument_list|(
name|mpt
argument_list|,
name|mpt
operator|->
name|tmf_req
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|REQ_STATE_DONE
argument_list|,
name|TRUE
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|status
operator|=
name|mpt
operator|->
name|tmf_req
operator|->
name|IOCStatus
expr_stmt|;
name|response
operator|=
name|mpt
operator|->
name|tmf_req
operator|->
name|ResponseCode
expr_stmt|;
name|mpt
operator|->
name|tmf_req
operator|->
name|state
operator|=
name|REQ_STATE_FREE
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If we've errored out,, reset the controller. 			 */
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_recover_commands: abort timed-out. "
literal|"Resetting controller\n"
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|MPI_IOCSTATUS_MASK
operator|)
operator|!=
name|MPI_IOCSTATUS_SUCCESS
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_recover_commands: IOC Status 0x%x. "
literal|"Resetting controller.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|response
operator|!=
name|MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED
operator|&&
name|response
operator|!=
name|MPI_SCSITASKMGMT_RSP_TM_COMPLETE
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_recover_commands: TMF Response 0x%x. "
literal|"Resetting controller.\n"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|mpt_reset
argument_list|(
name|mpt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"abort of req %p:%u completed\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************ Target Mode Support ****************************/
end_comment

begin_function
specifier|static
name|void
name|mpt_fc_post_els
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|int
name|ioindex
parameter_list|)
block|{
name|MSG_LINK_SERVICE_BUFFER_POST_REQUEST
modifier|*
name|fc
decl_stmt|;
name|PTR_SGE_TRANSACTION32
name|tep
decl_stmt|;
name|PTR_SGE_SIMPLE32
name|se
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|paddr
operator|=
name|req
operator|->
name|req_pbuf
expr_stmt|;
name|paddr
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|fc
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|memset
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
name|MPT_REQUEST_AREA
argument_list|)
expr_stmt|;
name|fc
operator|->
name|BufferCount
operator|=
literal|1
expr_stmt|;
name|fc
operator|->
name|Function
operator|=
name|MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
expr_stmt|;
name|fc
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|fc_els_handler_id
argument_list|)
expr_stmt|;
comment|/* 	 * Okay, set up ELS buffer pointers. ELS buffer pointers 	 * consist of a TE SGL element (with details length of zero) 	 * followe by a SIMPLE SGL element which holds the address 	 * of the buffer. 	 */
name|tep
operator|=
operator|(
name|PTR_SGE_TRANSACTION32
operator|)
operator|&
name|fc
operator|->
name|SGL
expr_stmt|;
name|tep
operator|->
name|ContextSize
operator|=
literal|4
expr_stmt|;
name|tep
operator|->
name|Flags
operator|=
literal|0
expr_stmt|;
name|tep
operator|->
name|TransactionContext
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
name|ioindex
argument_list|)
expr_stmt|;
name|se
operator|=
operator|(
name|PTR_SGE_SIMPLE32
operator|)
operator|&
name|tep
operator|->
name|TransactionDetails
index|[
literal|0
index|]
expr_stmt|;
name|se
operator|->
name|FlagsLength
operator|=
name|MPI_SGE_FLAGS_HOST_TO_IOC
operator||
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
name|se
operator|->
name|FlagsLength
operator|<<=
name|MPI_SGE_FLAGS_SHIFT
expr_stmt|;
name|se
operator|->
name|FlagsLength
operator||=
operator|(
name|MPT_NRFM
argument_list|(
name|mpt
argument_list|)
operator|-
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
operator|)
expr_stmt|;
name|se
operator|->
name|Address
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INVARIANT
argument_list|,
literal|"add ELS index %d ioindex %d for %p:%u\n"
argument_list|,
name|req
operator|->
name|index
argument_list|,
name|ioindex
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|req
operator|->
name|state
operator|&
name|REQ_STATE_LOCKED
operator|)
operator|!=
literal|0
operator|)
argument_list|,
operator|(
literal|"mpt_fc_post_els: request not locked"
operator|)
argument_list|)
expr_stmt|;
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_post_target_command
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|int
name|ioindex
parameter_list|)
block|{
name|PTR_MSG_TARGET_CMD_BUFFER_POST_REQUEST
name|fc
decl_stmt|;
name|PTR_CMD_BUFFER_DESCRIPTOR
name|cb
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|paddr
operator|=
name|req
operator|->
name|req_pbuf
expr_stmt|;
name|paddr
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
operator|->
name|req_vbuf
argument_list|,
literal|0
argument_list|,
name|MPT_REQUEST_AREA
argument_list|)
expr_stmt|;
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
operator|->
name|state
operator|=
name|TGT_STATE_LOADING
expr_stmt|;
name|fc
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|fc
operator|->
name|BufferCount
operator|=
literal|1
expr_stmt|;
name|fc
operator|->
name|Function
operator|=
name|MPI_FUNCTION_TARGET_CMD_BUFFER_POST
expr_stmt|;
name|fc
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|mpt
operator|->
name|scsi_tgt_handler_id
argument_list|)
expr_stmt|;
name|cb
operator|=
operator|&
name|fc
operator|->
name|Buffer
index|[
literal|0
index|]
expr_stmt|;
name|cb
operator|->
name|IoIndex
operator|=
name|htole16
argument_list|(
name|ioindex
argument_list|)
expr_stmt|;
name|cb
operator|->
name|u
operator|.
name|PhysicalAddress32
operator|=
operator|(
name|U32
operator|)
name|paddr
expr_stmt|;
name|mpt_check_doorbell
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_add_els_buffers
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|mpt
operator|->
name|els_cmds_allocated
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|mpt
operator|->
name|els_cmd_ptrs
operator|=
name|malloc
argument_list|(
name|MPT_MAX_ELS
operator|*
sizeof|sizeof
argument_list|(
name|request_t
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|els_cmd_ptrs
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Feed the chip some ELS buffer resources 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPT_MAX_ELS
condition|;
name|i
operator|++
control|)
block|{
name|request_t
modifier|*
name|req
init|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|req
operator|->
name|state
operator||=
name|REQ_STATE_LOCKED
expr_stmt|;
name|mpt
operator|->
name|els_cmd_ptrs
index|[
name|i
index|]
operator|=
name|req
expr_stmt|;
name|mpt_fc_post_els
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"unable to add ELS buffer resources\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpt
operator|->
name|els_cmd_ptrs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|els_cmd_ptrs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|!=
name|MPT_MAX_ELS
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INFO
argument_list|,
literal|"only added %d of %d  ELS buffers\n"
argument_list|,
name|i
argument_list|,
name|MPT_MAX_ELS
argument_list|)
expr_stmt|;
block|}
name|mpt
operator|->
name|els_cmds_allocated
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_add_target_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|mpt
operator|->
name|tgt_cmd_ptrs
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|max
operator|=
name|MPT_MAX_REQUESTS
argument_list|(
name|mpt
argument_list|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|mpt
operator|->
name|mpt_max_tgtcmds
condition|)
block|{
name|max
operator|=
name|mpt
operator|->
name|mpt_max_tgtcmds
expr_stmt|;
block|}
name|mpt
operator|->
name|tgt_cmd_ptrs
operator|=
name|malloc
argument_list|(
name|max
operator|*
sizeof|sizeof
argument_list|(
name|request_t
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|tgt_cmd_ptrs
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_add_target_commands: could not allocate cmd ptrs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|request_t
modifier|*
name|req
decl_stmt|;
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|req
operator|->
name|state
operator||=
name|REQ_STATE_LOCKED
expr_stmt|;
name|mpt
operator|->
name|tgt_cmd_ptrs
index|[
name|i
index|]
operator|=
name|req
expr_stmt|;
name|mpt_post_target_command
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_ERROR
argument_list|,
literal|"could not add any target bufs\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpt
operator|->
name|tgt_cmd_ptrs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mpt
operator|->
name|tgt_cmd_ptrs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|mpt
operator|->
name|tgt_cmds_allocated
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|max
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_INFO
argument_list|,
literal|"added %d of %d target bufs\n"
argument_list|,
name|i
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_free_els_buffers
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"fix me! need to implement mpt_free_els_buffers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_free_target_commands
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"fix me! need to implement mpt_free_target_commands"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_enable_lun
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|target_id_t
name|tgt
parameter_list|,
name|lun_id_t
name|lun
parameter_list|)
block|{
if|if
condition|(
name|tgt
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|mpt
operator|->
name|twildcard
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|>=
name|MPT_MAX_LUNS
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tgt
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|tgt
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mpt
operator|->
name|tenabled
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Try to add some target command resources 		 */
if|if
condition|(
name|mpt_add_target_commands
argument_list|(
name|mpt
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|mpt_free_els_buffers
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
operator|(
name|void
operator|)
name|mpt_fc_reset_link
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mpt
operator|->
name|tenabled
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|mpt
operator|->
name|trt_wildcard
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mpt
operator|->
name|trt
index|[
name|lun
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_disable_lun
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|target_id_t
name|tgt
parameter_list|,
name|lun_id_t
name|lun
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tgt
operator|==
name|CAM_TARGET_WILDCARD
operator|&&
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|mpt
operator|->
name|twildcard
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lun
operator|>=
name|MPT_MAX_LUNS
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tgt
operator|!=
name|CAM_TARGET_WILDCARD
operator|&&
name|tgt
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|mpt
operator|->
name|trt_wildcard
operator|.
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mpt
operator|->
name|trt
index|[
name|lun
index|]
operator|.
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MPT_MAX_LUNS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mpt
operator|->
name|trt
index|[
name|lun
index|]
operator|.
name|enabled
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MPT_MAX_LUNS
operator|&&
name|mpt
operator|->
name|twildcard
operator|==
literal|0
condition|)
block|{
name|mpt_free_els_buffers
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|mpt_free_target_commands
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
operator|(
name|void
operator|)
name|mpt_fc_reset_link
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mpt
operator|->
name|tenabled
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called with MPT lock held  */
end_comment

begin_function
specifier|static
name|void
name|mpt_target_start_io
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
init|=
operator|&
name|ccb
operator|->
name|csio
decl_stmt|;
name|request_t
modifier|*
name|cmd_req
init|=
name|MPT_TAG_2_REQ
argument_list|(
name|mpt
argument_list|,
name|csio
operator|->
name|tag_id
argument_list|)
decl_stmt|;
name|mpt_tgt_state_t
modifier|*
name|tgt
init|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tgt
operator|->
name|state
condition|)
block|{
case|case
name|TGT_STATE_IN_CAM
case|:
break|break;
case|case
name|TGT_STATE_MOVING_DATA
case|:
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|tgt
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"ccb %p flags 0x%x tag 0x%08x had bad request "
literal|"starting I/O\n"
argument_list|,
name|ccb
argument_list|,
name|csio
operator|->
name|ccb_h
operator|.
name|flags
argument_list|,
name|csio
operator|->
name|tag_id
argument_list|)
expr_stmt|;
name|mpt_tgt_dump_req_state
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP_ERR
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|csio
operator|->
name|dxfer_len
condition|)
block|{
name|bus_dmamap_callback_t
modifier|*
name|cb
decl_stmt|;
name|PTR_MSG_TARGET_ASSIST_REQUEST
name|ta
decl_stmt|;
name|request_t
modifier|*
name|req
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
argument_list|,
operator|(
literal|"dxfer_len %u but direction is NONE\n"
operator|,
name|csio
operator|->
name|dxfer_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SIM_QUEUED
operator||
name|CAM_REQ_INPROG
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|>
literal|4
condition|)
block|{
name|cb
operator|=
name|mpt_execute_req_a64
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|=
name|mpt_execute_req
expr_stmt|;
block|}
name|req
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
operator|=
name|req
expr_stmt|;
comment|/* 		 * Record the currently active ccb and the 		 * request for it in our target state area. 		 */
name|tgt
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|tgt
operator|->
name|req
operator|=
name|req
expr_stmt|;
name|memset
argument_list|(
name|req
operator|->
name|req_vbuf
argument_list|,
literal|0
argument_list|,
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
argument_list|)
expr_stmt|;
name|ta
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
operator|==
literal|0
condition|)
block|{
name|PTR_MPI_TARGET_SSP_CMD_BUFFER
name|ssp
init|=
name|cmd_req
operator|->
name|req_vbuf
decl_stmt|;
name|ta
operator|->
name|QueueTag
operator|=
name|ssp
operator|->
name|InitiatorTag
expr_stmt|;
block|}
else|else
block|{
name|PTR_MPI_TARGET_SCSI_SPI_CMD_BUFFER
name|sp
init|=
name|cmd_req
operator|->
name|req_vbuf
decl_stmt|;
name|ta
operator|->
name|QueueTag
operator|=
name|sp
operator|->
name|Tag
expr_stmt|;
block|}
name|ta
operator|->
name|Function
operator|=
name|MPI_FUNCTION_TARGET_ASSIST
expr_stmt|;
name|ta
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|mpt
operator|->
name|scsi_tgt_handler_id
argument_list|)
expr_stmt|;
name|ta
operator|->
name|ReplyWord
operator|=
name|htole32
argument_list|(
name|tgt
operator|->
name|reply_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>
literal|256
condition|)
block|{
name|ta
operator|->
name|LUN
index|[
literal|0
index|]
operator|=
literal|0x40
operator||
operator|(
operator|(
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|>>
literal|8
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|ta
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|ta
operator|->
name|LUN
index|[
literal|1
index|]
operator|=
name|csio
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
block|}
name|ta
operator|->
name|RelativeOffset
operator|=
name|tgt
operator|->
name|bytes_xfered
expr_stmt|;
name|ta
operator|->
name|DataLength
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|DataLength
operator|>
name|tgt
operator|->
name|resid
condition|)
block|{
name|ta
operator|->
name|DataLength
operator|=
name|tgt
operator|->
name|resid
expr_stmt|;
block|}
comment|/* 		 * XXX Should be done after data transfer completes? 		 */
name|tgt
operator|->
name|resid
operator|-=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|tgt
operator|->
name|bytes_xfered
operator|+=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|ta
operator|->
name|TargetAssistFlags
operator||=
name|TARGET_ASSIST_FLAGS_DATA_DIRECTION
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WE_TRUST_AUTO_GOOD_STATUS
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|&&
name|csio
operator|->
name|scsi_status
operator|==
name|SCSI_STATUS_OK
operator|&&
name|tgt
operator|->
name|resid
operator|==
literal|0
condition|)
block|{
name|ta
operator|->
name|TargetAssistFlags
operator||=
name|TARGET_ASSIST_FLAGS_AUTO_STATUS
expr_stmt|;
block|}
endif|#
directive|endif
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_SETTING_UP_FOR_DATA
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"DATA_CCB %p tag %x %u bytes %u resid flg %x req %p:%u "
literal|"nxtstate=%d\n"
argument_list|,
name|csio
argument_list|,
name|csio
operator|->
name|tag_id
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|tgt
operator|->
name|resid
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|tgt
operator|->
name|state
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
init|=
name|splsoftvm
argument_list|()
decl_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mpt
operator|->
name|buffer_dmat
argument_list|,
name|req
operator|->
name|dmap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|cb
argument_list|,
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * We have been given a pointer to single 				 * physical buffer. 				 */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We have been given a list of addresses. 			 * This case could be easily supported but they are not 			 * currently generated by the CAM subsystem so there 			 * is no point in wasting the time right now. 			 */
name|struct
name|bus_dma_segment
modifier|*
name|sgs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just use the segments provided */
name|sgs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
call|(
modifier|*
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|sgs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
modifier|*
name|sp
init|=
name|NULL
decl_stmt|,
name|sense
index|[
name|MPT_SENSE_SIZE
index|]
decl_stmt|;
comment|/* 		 * XXX: I don't know why this seems to happen, but 		 * XXX: completing the CCB seems to make things happy. 		 * XXX: This seems to happen if the initiator requests 		 * XXX: enough data that we have to do multiple CTIOs. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"Meaningless STATUS CCB (%p): flags %x status %x "
literal|"resid %d bytes_xfered %u\n"
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|tgt
operator|->
name|resid
argument_list|,
name|tgt
operator|->
name|bytes_xfered
argument_list|)
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_SENSE
condition|)
block|{
name|sp
operator|=
name|sense
expr_stmt|;
name|memcpy
argument_list|(
name|sp
argument_list|,
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|min
argument_list|(
name|csio
operator|->
name|sense_len
argument_list|,
name|MPT_SENSE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
name|ccb
argument_list|,
name|cmd_req
argument_list|,
name|csio
operator|->
name|scsi_status
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Abort queued up CCBs  */
end_comment

begin_function
specifier|static
name|cam_status
name|mpt_abort_target_ccb
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|mpt_hdr_stailq
modifier|*
name|lp
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|srch
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|accb
init|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
decl_stmt|;
name|tgt_resource_t
modifier|*
name|trtp
decl_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"aborting ccb %p\n"
argument_list|,
name|accb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|==
name|CAM_LUN_WILDCARD
condition|)
block|{
name|trtp
operator|=
operator|&
name|mpt
operator|->
name|trt_wildcard
expr_stmt|;
block|}
else|else
block|{
name|trtp
operator|=
operator|&
name|mpt
operator|->
name|trt
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
index|]
expr_stmt|;
block|}
if|if
condition|(
name|accb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ACCEPT_TARGET_IO
condition|)
block|{
name|lp
operator|=
operator|&
name|trtp
operator|->
name|atios
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|accb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_IMMED_NOTIFY
condition|)
block|{
name|lp
operator|=
operator|&
name|trtp
operator|->
name|inots
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|CAM_REQ_INVALID
operator|)
return|;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|srch
argument_list|,
argument|lp
argument_list|,
argument|sim_links.stqe
argument_list|)
block|{
if|if
condition|(
name|srch
operator|==
operator|&
name|accb
operator|->
name|ccb_h
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
name|lp
argument_list|,
name|srch
argument_list|,
name|ccb_hdr
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|accb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
name|xpt_done
argument_list|(
name|accb
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_REQ_CMP
operator|)
return|;
block|}
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_abort_tgt_ccb: CCB %p not found\n"
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|CAM_PATH_INVALID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ask the MPT to abort the current target command  */
end_comment

begin_function
specifier|static
name|int
name|mpt_abort_target_cmd
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|cmd_req
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|request_t
modifier|*
name|req
decl_stmt|;
name|PTR_MSG_TARGET_MODE_ABORT
name|abtp
decl_stmt|;
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|abtp
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|memset
argument_list|(
name|abtp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|abtp
argument_list|)
argument_list|)
expr_stmt|;
name|abtp
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|mpt
operator|->
name|scsi_tgt_handler_id
argument_list|)
expr_stmt|;
name|abtp
operator|->
name|AbortType
operator|=
name|TARGET_MODE_ABORT_TYPE_EXACT_IO
expr_stmt|;
name|abtp
operator|->
name|Function
operator|=
name|MPI_FUNCTION_TARGET_MODE_ABORT
expr_stmt|;
name|abtp
operator|->
name|ReplyWord
operator|=
name|htole32
argument_list|(
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
operator|->
name|reply_desc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
operator|||
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|mpt_send_handshake_cmd
argument_list|(
name|mpt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * WE_TRUST_AUTO_GOOD_STATUS- I've found that setting   * TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS leads the  * FC929 to set bogus FC_RSP fields (nonzero residuals  * but w/o RESID fields set). This causes QLogic initiators  * to think maybe that a frame was lost.  *  * WE_CAN_USE_AUTO_REPOST- we can't use AUTO_REPOST because  * we use allocated requests to do TARGET_ASSIST and we  * need to know when to release them.  */
end_comment

begin_function
specifier|static
name|void
name|mpt_scsi_tgt_status
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|request_t
modifier|*
name|cmd_req
parameter_list|,
name|uint8_t
name|status
parameter_list|,
name|uint8_t
specifier|const
modifier|*
name|sense_data
parameter_list|)
block|{
name|uint8_t
modifier|*
name|cmd_vbuf
decl_stmt|;
name|mpt_tgt_state_t
modifier|*
name|tgt
decl_stmt|;
name|PTR_MSG_TARGET_STATUS_SEND_REQUEST
name|tp
decl_stmt|;
name|request_t
modifier|*
name|req
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|resplen
init|=
literal|0
decl_stmt|;
name|cmd_vbuf
operator|=
name|cmd_req
operator|->
name|req_vbuf
expr_stmt|;
name|cmd_vbuf
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|tgt
operator|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|cmd_req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|mpt_get_request
argument_list|(
name|mpt
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
operator|==
literal|0
condition|)
block|{
name|mpt
operator|->
name|outofbeer
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|mpt
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"FREEZEQ\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"XXXX could not allocate status req- dropping\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|req
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
operator|=
name|mpt
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_req_ptr
operator|=
name|req
expr_stmt|;
block|}
comment|/* 	 * Record the currently active ccb, if any, and the 	 * request for it in our target state area. 	 */
name|tgt
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|tgt
operator|->
name|req
operator|=
name|req
expr_stmt|;
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_SENDING_STATUS
expr_stmt|;
name|tp
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|paddr
operator|=
name|req
operator|->
name|req_pbuf
expr_stmt|;
name|paddr
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|Function
operator|=
name|MPI_FUNCTION_TARGET_STATUS_SEND
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
name|PTR_MPI_TARGET_FCP_CMD_BUFFER
name|fc
init|=
operator|(
name|PTR_MPI_TARGET_FCP_CMD_BUFFER
operator|)
name|cmd_vbuf
decl_stmt|;
name|uint8_t
modifier|*
name|sts_vbuf
decl_stmt|;
name|uint32_t
modifier|*
name|rsp
decl_stmt|;
name|sts_vbuf
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|sts_vbuf
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|rsp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sts_vbuf
expr_stmt|;
name|memcpy
argument_list|(
name|tp
operator|->
name|LUN
argument_list|,
name|fc
operator|->
name|FcpLun
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
operator|->
name|LUN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The MPI_TARGET_FCP_RSP_BUFFER define is unfortunate. 		 * It has to be big-endian in memory and is organized 		 * in 32 bit words, which are much easier to deal with 		 * as words which are swizzled as needed. 		 * 		 * All we're filling here is the FC_RSP payload. 		 * We may just have the chip synthesize it if 		 * we have no residual and an OK status. 		 * 		 */
name|memset
argument_list|(
name|rsp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MPI_TARGET_FCP_RSP_BUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|rsp
index|[
literal|2
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|tgt
operator|->
name|resid
condition|)
block|{
name|rsp
index|[
literal|2
index|]
operator||=
literal|0x800
expr_stmt|;
comment|/* XXXX NEED MNEMONIC!!!! */
name|rsp
index|[
literal|3
index|]
operator|=
name|htobe32
argument_list|(
name|tgt
operator|->
name|resid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WE_TRUST_AUTO_GOOD_STATUS
name|resplen
operator|=
sizeof|sizeof
argument_list|(
name|MPI_TARGET_FCP_RSP_BUFFER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rsp
index|[
literal|2
index|]
operator||=
literal|0x200
expr_stmt|;
comment|/* XXXX NEED MNEMONIC!!!! */
name|rsp
index|[
literal|4
index|]
operator|=
name|htobe32
argument_list|(
name|MPT_SENSE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense_data
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|rsp
index|[
literal|8
index|]
argument_list|,
name|sense_data
argument_list|,
name|MPT_SENSE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"mpt_scsi_tgt_status: CHECK CONDI"
literal|"TION but no sense data?\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rsp
argument_list|,
literal|0
argument_list|,
name|MPT_SENSE_SIZE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
operator|(
literal|8
operator|+
operator|(
name|MPT_SENSE_SIZE
operator|>>
literal|2
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|rsp
index|[
name|i
index|]
operator|=
name|htobe32
argument_list|(
name|rsp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WE_TRUST_AUTO_GOOD_STATUS
name|resplen
operator|=
sizeof|sizeof
argument_list|(
name|MPI_TARGET_FCP_RSP_BUFFER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|WE_TRUST_AUTO_GOOD_STATUS
name|resplen
operator|=
sizeof|sizeof
argument_list|(
name|MPI_TARGET_FCP_RSP_BUFFER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rsp
index|[
literal|2
index|]
operator|=
name|htobe32
argument_list|(
name|rsp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|PTR_MPI_TARGET_SSP_CMD_BUFFER
name|ssp
init|=
operator|(
name|PTR_MPI_TARGET_SSP_CMD_BUFFER
operator|)
name|cmd_vbuf
decl_stmt|;
name|memcpy
argument_list|(
name|tp
operator|->
name|LUN
argument_list|,
name|ssp
operator|->
name|LogicalUnitNumber
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
operator|->
name|LUN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PTR_MPI_TARGET_SCSI_SPI_CMD_BUFFER
name|sp
init|=
operator|(
name|PTR_MPI_TARGET_SCSI_SPI_CMD_BUFFER
operator|)
name|cmd_vbuf
decl_stmt|;
name|tp
operator|->
name|StatusCode
operator|=
name|status
expr_stmt|;
name|tp
operator|->
name|QueueTag
operator|=
name|htole16
argument_list|(
name|sp
operator|->
name|Tag
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tp
operator|->
name|LUN
argument_list|,
name|sp
operator|->
name|LogicalUnitNumber
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
operator|->
name|LUN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|ReplyWord
operator|=
name|htole32
argument_list|(
name|tgt
operator|->
name|reply_desc
argument_list|)
expr_stmt|;
name|tp
operator|->
name|MsgContext
operator|=
name|htole32
argument_list|(
name|req
operator|->
name|index
operator||
name|mpt
operator|->
name|scsi_tgt_handler_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WE_CAN_USE_AUTO_REPOST
name|tp
operator|->
name|MsgFlags
operator|=
name|TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|SCSI_STATUS_OK
operator|&&
name|resplen
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|MsgFlags
operator||=
name|TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|StatusDataSGE
operator|.
name|u
operator|.
name|Address32
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
expr_stmt|;
name|tp
operator|->
name|StatusDataSGE
operator|.
name|FlagsLength
operator|=
name|MPI_SGE_FLAGS_HOST_TO_IOC
operator||
name|MPI_SGE_FLAGS_SIMPLE_ELEMENT
operator||
name|MPI_SGE_FLAGS_LAST_ELEMENT
operator||
name|MPI_SGE_FLAGS_END_OF_LIST
operator||
name|MPI_SGE_FLAGS_END_OF_BUFFER
expr_stmt|;
name|tp
operator|->
name|StatusDataSGE
operator|.
name|FlagsLength
operator|<<=
name|MPI_SGE_FLAGS_SHIFT
expr_stmt|;
name|tp
operator|->
name|StatusDataSGE
operator|.
name|FlagsLength
operator||=
name|resplen
expr_stmt|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"STATUS_CCB %p (wit%s sense) tag %x req %p:%u resid %u\n"
argument_list|,
name|ccb
argument_list|,
name|sense_data
condition|?
literal|"h"
else|:
literal|"hout"
argument_list|,
name|ccb
condition|?
name|ccb
operator|->
name|csio
operator|.
name|tag_id
else|:
operator|-
literal|1
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|tgt
operator|->
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SIM_QUEUED
operator||
name|CAM_REQ_INPROG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|mpt_timeout
argument_list|,
name|ccb
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|mpt_send_cmd
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_scsi_tgt_tsk_mgmt
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|mpt_task_mgmt_t
name|fc
parameter_list|,
name|tgt_resource_t
modifier|*
name|trtp
parameter_list|,
name|int
name|init_id
parameter_list|)
block|{
name|struct
name|ccb_immed_notify
modifier|*
name|inot
decl_stmt|;
name|mpt_tgt_state_t
modifier|*
name|tgt
decl_stmt|;
name|tgt
operator|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|inot
operator|=
operator|(
expr|struct
name|ccb_immed_notify
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|trtp
operator|->
name|inots
argument_list|)
expr_stmt|;
if|if
condition|(
name|inot
operator|==
name|NULL
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_WARN
argument_list|,
literal|"no INOTSs- sending back BSY\n"
argument_list|)
expr_stmt|;
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
name|NULL
argument_list|,
name|req
argument_list|,
name|SCSI_STATUS_BUSY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|trtp
operator|->
name|inots
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG1
argument_list|,
literal|"Get FREE INOT %p lun %d\n"
argument_list|,
name|inot
argument_list|,
name|inot
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inot
operator|->
name|sense_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inot
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|inot
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|inot
operator|->
name|message_args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inot
operator|->
name|message_args
argument_list|)
argument_list|)
expr_stmt|;
name|inot
operator|->
name|initiator_id
operator|=
name|init_id
expr_stmt|;
comment|/* XXX */
comment|/* 	 * This is a somewhat grotesque attempt to map from task management 	 * to old style SCSI messages. God help us all. 	 */
switch|switch
condition|(
name|fc
condition|)
block|{
case|case
name|MPT_ABORT_TASK_SET
case|:
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
break|break;
case|case
name|MPT_CLEAR_TASK_SET
case|:
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|MSG_CLEAR_TASK_SET
expr_stmt|;
break|break;
case|case
name|MPT_TARGET_RESET
case|:
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|MSG_TARGET_RESET
expr_stmt|;
break|break;
case|case
name|MPT_CLEAR_ACA
case|:
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|MSG_CLEAR_ACA
expr_stmt|;
break|break;
case|case
name|MPT_TERMINATE_TASK
case|:
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
break|break;
default|default:
name|inot
operator|->
name|message_args
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
break|break;
block|}
name|tgt
operator|->
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
expr_stmt|;
name|inot
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_MESSAGE_RECV
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|inot
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_scsi_tgt_atio
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|uint32_t
name|reply_desc
parameter_list|)
block|{
name|struct
name|ccb_accept_tio
modifier|*
name|atiop
decl_stmt|;
name|lun_id_t
name|lun
decl_stmt|;
name|int
name|tag_action
init|=
literal|0
decl_stmt|;
name|mpt_tgt_state_t
modifier|*
name|tgt
decl_stmt|;
name|tgt_resource_t
modifier|*
name|trtp
init|=
name|NULL
decl_stmt|;
name|U8
modifier|*
name|lunptr
decl_stmt|;
name|U8
modifier|*
name|vbuf
decl_stmt|;
name|U16
name|itag
decl_stmt|;
name|U16
name|ioindex
decl_stmt|;
name|mpt_task_mgmt_t
name|fct
init|=
name|MPT_NIL_TMT_VALUE
decl_stmt|;
name|uint8_t
modifier|*
name|cdbp
decl_stmt|;
comment|/* 	 * First, DMA sync the received command- which is in the *request* 	 * phys area. 	 * XXX: We could optimize this for a range 	 */
name|bus_dmamap_sync
argument_list|(
name|mpt
operator|->
name|request_dmat
argument_list|,
name|mpt
operator|->
name|request_dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Stash info for the current command where we can get at it later. 	 */
name|vbuf
operator|=
name|req
operator|->
name|req_vbuf
expr_stmt|;
name|vbuf
operator|+=
name|MPT_RQSL
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
comment|/* 	 * Get our state pointer set up. 	 */
name|tgt
operator|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt
operator|->
name|state
operator|!=
name|TGT_STATE_LOADED
condition|)
block|{
name|mpt_tgt_dump_req_state
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"bad target state in mpt_scsi_tgt_atio"
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|tgt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mpt_tgt_state_t
argument_list|)
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_IN_CAM
expr_stmt|;
name|tgt
operator|->
name|reply_desc
operator|=
name|reply_desc
expr_stmt|;
name|ioindex
operator|=
name|GET_IO_INDEX
argument_list|(
name|reply_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|is_fc
condition|)
block|{
name|PTR_MPI_TARGET_FCP_CMD_BUFFER
name|fc
decl_stmt|;
name|fc
operator|=
operator|(
name|PTR_MPI_TARGET_FCP_CMD_BUFFER
operator|)
name|vbuf
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|FcpCntl
index|[
literal|2
index|]
condition|)
block|{
comment|/* 			 * Task Management Request 			 */
switch|switch
condition|(
name|fc
operator|->
name|FcpCntl
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|0x2
case|:
name|fct
operator|=
name|MPT_ABORT_TASK_SET
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|fct
operator|=
name|MPT_CLEAR_TASK_SET
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|fct
operator|=
name|MPT_TARGET_RESET
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|fct
operator|=
name|MPT_CLEAR_ACA
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|fct
operator|=
name|MPT_TERMINATE_TASK
expr_stmt|;
break|break;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"CORRUPTED TASK MGMT BITS: 0x%x\n"
argument_list|,
name|fc
operator|->
name|FcpCntl
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
name|req
argument_list|,
name|SCSI_STATUS_OK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|fc
operator|->
name|FcpCntl
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
name|tag_action
operator|=
name|MSG_SIMPLE_Q_TAG
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|tag_action
operator|=
name|MSG_HEAD_OF_Q_TAG
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tag_action
operator|=
name|MSG_ORDERED_Q_TAG
expr_stmt|;
break|break;
default|default:
comment|/* 				 * Bah. Ignore Untagged Queing and ACA 				 */
name|tag_action
operator|=
name|MSG_SIMPLE_Q_TAG
expr_stmt|;
break|break;
block|}
block|}
name|tgt
operator|->
name|resid
operator|=
name|be32toh
argument_list|(
name|fc
operator|->
name|FcpDl
argument_list|)
expr_stmt|;
name|cdbp
operator|=
name|fc
operator|->
name|FcpCdb
expr_stmt|;
name|lunptr
operator|=
name|fc
operator|->
name|FcpLun
expr_stmt|;
name|itag
operator|=
name|be16toh
argument_list|(
name|fc
operator|->
name|OptionalOxid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mpt
operator|->
name|is_sas
condition|)
block|{
name|PTR_MPI_TARGET_SSP_CMD_BUFFER
name|ssp
decl_stmt|;
name|ssp
operator|=
operator|(
name|PTR_MPI_TARGET_SSP_CMD_BUFFER
operator|)
name|vbuf
expr_stmt|;
name|cdbp
operator|=
name|ssp
operator|->
name|CDB
expr_stmt|;
name|lunptr
operator|=
name|ssp
operator|->
name|LogicalUnitNumber
expr_stmt|;
name|itag
operator|=
name|ssp
operator|->
name|InitiatorTag
expr_stmt|;
block|}
else|else
block|{
name|PTR_MPI_TARGET_SCSI_SPI_CMD_BUFFER
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|PTR_MPI_TARGET_SCSI_SPI_CMD_BUFFER
operator|)
name|vbuf
expr_stmt|;
name|cdbp
operator|=
name|sp
operator|->
name|CDB
expr_stmt|;
name|lunptr
operator|=
name|sp
operator|->
name|LogicalUnitNumber
expr_stmt|;
name|itag
operator|=
name|sp
operator|->
name|Tag
expr_stmt|;
block|}
comment|/* 	 * Generate a simple lun 	 */
switch|switch
condition|(
name|lunptr
index|[
literal|0
index|]
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0x40
case|:
name|lun
operator|=
operator|(
operator|(
name|lunptr
index|[
literal|0
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|8
operator|)
operator||
name|lunptr
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|lun
operator|=
name|lunptr
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_ERROR
argument_list|,
literal|"cannot handle this type lun\n"
argument_list|)
expr_stmt|;
name|lun
operator|=
literal|0xffff
expr_stmt|;
break|break;
block|}
comment|/* 	 * Deal with non-enabled or bad luns here. 	 */
if|if
condition|(
name|lun
operator|>=
name|MPT_MAX_LUNS
operator|||
name|mpt
operator|->
name|tenabled
operator|==
literal|0
operator|||
name|mpt
operator|->
name|trt
index|[
name|lun
index|]
operator|.
name|enabled
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|twildcard
condition|)
block|{
name|trtp
operator|=
operator|&
name|mpt
operator|->
name|trt_wildcard
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fct
operator|!=
name|MPT_NIL_TMT_VALUE
condition|)
block|{
specifier|const
name|uint8_t
name|sp
index|[
name|MPT_SENSE_SIZE
index|]
init|=
block|{
literal|0xf0
block|,
literal|0
block|,
literal|0x5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x25
block|}
decl_stmt|;
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
name|NULL
argument_list|,
name|req
argument_list|,
name|SCSI_STATUS_CHECK_COND
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|trtp
operator|=
operator|&
name|mpt
operator|->
name|trt
index|[
name|lun
index|]
expr_stmt|;
block|}
comment|/* 	 * Deal with any task management 	 */
if|if
condition|(
name|fct
operator|!=
name|MPT_NIL_TMT_VALUE
condition|)
block|{
if|if
condition|(
name|trtp
operator|==
name|NULL
condition|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"task mgmt function %x but no listener\n"
argument_list|,
name|fct
argument_list|)
expr_stmt|;
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
literal|0
argument_list|,
name|req
argument_list|,
name|SCSI_STATUS_OK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpt_scsi_tgt_tsk_mgmt
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|fct
argument_list|,
name|trtp
argument_list|,
name|GET_INITIATOR_INDEX
argument_list|(
name|reply_desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|atiop
operator|=
operator|(
expr|struct
name|ccb_accept_tio
operator|*
operator|)
name|STAILQ_FIRST
argument_list|(
operator|&
name|trtp
operator|->
name|atios
argument_list|)
expr_stmt|;
if|if
condition|(
name|atiop
operator|==
name|NULL
condition|)
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_WARN
argument_list|,
literal|"no ATIOs for lun %u- sending back %s\n"
argument_list|,
name|lun
argument_list|,
name|mpt
operator|->
name|tenabled
condition|?
literal|"QUEUE FULL"
else|:
literal|"BUSY"
argument_list|)
expr_stmt|;
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
name|NULL
argument_list|,
name|req
argument_list|,
name|mpt
operator|->
name|tenabled
condition|?
name|SCSI_STATUS_QUEUE_FULL
else|:
name|SCSI_STATUS_BUSY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|trtp
operator|->
name|atios
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG1
argument_list|,
literal|"Get FREE ATIO %p lun %d\n"
argument_list|,
name|atiop
argument_list|,
name|atiop
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|atiop
operator|->
name|ccb_h
operator|.
name|ccb_mpt_ptr
operator|=
name|mpt
expr_stmt|;
name|atiop
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CDB_RECVD
expr_stmt|;
name|atiop
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|lun
expr_stmt|;
name|atiop
operator|->
name|sense_len
operator|=
literal|0
expr_stmt|;
name|atiop
operator|->
name|init_id
operator|=
name|GET_INITIATOR_INDEX
argument_list|(
name|reply_desc
argument_list|)
expr_stmt|;
name|atiop
operator|->
name|cdb_len
operator|=
name|mpt_cdblen
argument_list|(
name|cdbp
index|[
literal|0
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|atiop
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cdbp
argument_list|,
name|atiop
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
comment|/* 	 * The tag we construct here allows us to find the 	 * original request that the command came in with. 	 * 	 * This way we don't have to depend on anything but the 	 * tag to find things when CCBs show back up from CAM. 	 */
name|atiop
operator|->
name|tag_id
operator|=
name|MPT_MAKE_TAGID
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|ioindex
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|tag_id
operator|=
name|atiop
operator|->
name|tag_id
expr_stmt|;
if|if
condition|(
name|tag_action
condition|)
block|{
name|atiop
operator|->
name|tag_action
operator|=
name|tag_action
expr_stmt|;
name|atiop
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_TAG_ACTION_VALID
expr_stmt|;
block|}
if|if
condition|(
name|mpt
operator|->
name|verbose
operator|>=
name|MPT_PRT_DEBUG
condition|)
block|{
name|int
name|i
decl_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"START_CCB %p for lun %u CDB=<"
argument_list|,
name|atiop
argument_list|,
name|atiop
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|atiop
operator|->
name|cdb_len
condition|;
name|i
operator|++
control|)
block|{
name|mpt_prtc
argument_list|(
name|mpt
argument_list|,
literal|"%02x%c"
argument_list|,
name|cdbp
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|==
operator|(
name|atiop
operator|->
name|cdb_len
operator|-
literal|1
operator|)
operator|)
condition|?
literal|'>'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|mpt_prtc
argument_list|(
name|mpt
argument_list|,
literal|" itag %x tag %x rdesc %x dl=%u\n"
argument_list|,
name|itag
argument_list|,
name|atiop
operator|->
name|tag_id
argument_list|,
name|tgt
operator|->
name|reply_desc
argument_list|,
name|tgt
operator|->
name|resid
argument_list|)
expr_stmt|;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|atiop
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_tgt_dump_tgt_state
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|)
block|{
name|mpt_tgt_state_t
modifier|*
name|tgt
init|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
decl_stmt|;
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"req %p:%u tgt:rdesc 0x%x resid %u xfrd %u ccb %p treq %p "
literal|"nx %d tag 0x%08x state=%d\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|tgt
operator|->
name|reply_desc
argument_list|,
name|tgt
operator|->
name|resid
argument_list|,
name|tgt
operator|->
name|bytes_xfered
argument_list|,
name|tgt
operator|->
name|ccb
argument_list|,
name|tgt
operator|->
name|req
argument_list|,
name|tgt
operator|->
name|nxfers
argument_list|,
name|tgt
operator|->
name|tag_id
argument_list|,
name|tgt
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpt_tgt_dump_req_state
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|)
block|{
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"req %p:%u index %u (%x) state %x\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|req
operator|->
name|index
argument_list|,
name|req
operator|->
name|index
argument_list|,
name|req
operator|->
name|state
argument_list|)
expr_stmt|;
name|mpt_tgt_dump_tgt_state
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_scsi_tgt_reply_handler
parameter_list|(
name|struct
name|mpt_softc
modifier|*
name|mpt
parameter_list|,
name|request_t
modifier|*
name|req
parameter_list|,
name|uint32_t
name|reply_desc
parameter_list|,
name|MSG_DEFAULT_REPLY
modifier|*
name|reply_frame
parameter_list|)
block|{
name|int
name|dbg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|U16
name|status
decl_stmt|;
if|if
condition|(
name|reply_frame
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Figure out what the state of the command is. 		 */
name|mpt_tgt_state_t
modifier|*
name|tgt
init|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"turbo scsi_tgt_reply"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt
operator|->
name|req
condition|)
block|{
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|tgt
operator|->
name|req
argument_list|,
literal|"turbo scsi_tgt_reply associated req"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|tgt
operator|->
name|state
condition|)
block|{
case|case
name|TGT_STATE_LOADED
case|:
comment|/* 			 * This is a new command starting. 			 */
name|mpt_scsi_tgt_atio
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|reply_desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TGT_STATE_MOVING_DATA
case|:
block|{
name|uint8_t
modifier|*
name|sp
init|=
name|NULL
decl_stmt|,
name|sense
index|[
name|MPT_SENSE_SIZE
index|]
decl_stmt|;
name|ccb
operator|=
name|tgt
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|tgt
operator|->
name|req
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"mpt: turbo target reply with null "
literal|"associated request moving data"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"mpt: turbo target reply with null "
literal|"associated ccb moving data"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|tgt
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|tgt
operator|->
name|nxfers
operator|++
expr_stmt|;
name|untimeout
argument_list|(
name|mpt_timeout
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"TARGET_ASSIST %p (req %p:%u) done tag 0x%x\n"
argument_list|,
name|ccb
argument_list|,
name|tgt
operator|->
name|req
argument_list|,
name|tgt
operator|->
name|req
operator|->
name|serno
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|)
expr_stmt|;
comment|/* 			 * Free the Target Assist Request 			 */
name|KASSERT
argument_list|(
name|tgt
operator|->
name|req
operator|->
name|ccb
operator|==
name|ccb
argument_list|,
operator|(
literal|"tgt->req %p:%u tgt->req->ccb %p"
operator|,
name|tgt
operator|->
name|req
operator|,
name|tgt
operator|->
name|req
operator|->
name|serno
operator|,
name|tgt
operator|->
name|req
operator|->
name|ccb
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|tgt
operator|->
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|tgt
operator|->
name|req
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Do we need to send status now? That is, are 			 * we done with all our data transfers? 			 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_STATUS
operator|)
operator|==
literal|0
condition|)
block|{
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"zero ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_IN_CAM
expr_stmt|;
if|if
condition|(
name|mpt
operator|->
name|outofbeer
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|mpt
operator|->
name|outofbeer
operator|=
literal|0
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"THAWQ\n"
argument_list|)
expr_stmt|;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Otherwise, send status (and sense) 			 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_SENSE
condition|)
block|{
name|sp
operator|=
name|sense
expr_stmt|;
name|memcpy
argument_list|(
name|sp
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|min
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|,
name|MPT_SENSE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mpt_scsi_tgt_status
argument_list|(
name|mpt
argument_list|,
name|ccb
argument_list|,
name|req
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TGT_STATE_SENDING_STATUS
case|:
case|case
name|TGT_STATE_MOVING_DATA_AND_STATUS
case|:
block|{
name|int
name|ioindex
decl_stmt|;
name|ccb
operator|=
name|tgt
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|tgt
operator|->
name|req
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"mpt: turbo target reply with null "
literal|"associated request sending status"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|ccb
condition|)
block|{
name|tgt
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tgt
operator|->
name|state
operator|==
name|TGT_STATE_MOVING_DATA_AND_STATUS
condition|)
block|{
name|tgt
operator|->
name|nxfers
operator|++
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|mpt_timeout
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SEND_SENSE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SENT_SENSE
expr_stmt|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"TARGET_STATUS tag %x sts %x flgs %x req "
literal|"%p\n"
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|tag_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
argument_list|,
name|tgt
operator|->
name|req
argument_list|)
expr_stmt|;
comment|/* 				 * Free the Target Send Status Request 				 */
name|KASSERT
argument_list|(
name|tgt
operator|->
name|req
operator|->
name|ccb
operator|==
name|ccb
argument_list|,
operator|(
literal|"tgt->req %p:%u tgt->req->ccb %p"
operator|,
name|tgt
operator|->
name|req
operator|,
name|tgt
operator|->
name|req
operator|->
name|serno
operator|,
name|tgt
operator|->
name|req
operator|->
name|ccb
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Notify CAM that we're done 				 */
name|mpt_set_ccb_status
argument_list|(
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
argument_list|,
operator|(
literal|"ZERO ccb sts at %d\n"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"TARGET_STATUS non-CAM for  req %p:%u\n"
argument_list|,
name|tgt
operator|->
name|req
argument_list|,
name|tgt
operator|->
name|req
operator|->
name|serno
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|tgt
operator|->
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|tgt
operator|->
name|req
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * And re-post the Command Buffer. 			 * This wil reset the state. 			 */
name|ioindex
operator|=
name|GET_IO_INDEX
argument_list|(
name|reply_desc
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_post_target_command
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
name|ioindex
argument_list|)
expr_stmt|;
comment|/* 			 * And post a done for anyone who cares 			 */
if|if
condition|(
name|ccb
condition|)
block|{
if|if
condition|(
name|mpt
operator|->
name|outofbeer
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|mpt
operator|->
name|outofbeer
operator|=
literal|0
expr_stmt|;
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|MPT_PRT_DEBUG
argument_list|,
literal|"THAWQ\n"
argument_list|)
expr_stmt|;
block|}
name|MPTLOCK_2_CAMLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|CAMLOCK_2_MPTLOCK
argument_list|(
name|mpt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|TGT_STATE_NIL
case|:
comment|/* XXX This Never Happens XXX */
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_LOADED
expr_stmt|;
break|break;
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unknown Target State 0x%x in Context "
literal|"Reply Function\n"
argument_list|,
name|tgt
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|status
operator|=
name|le16toh
argument_list|(
name|reply_frame
operator|->
name|IOCStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MPI_IOCSTATUS_SUCCESS
condition|)
block|{
name|dbg
operator|=
name|MPT_PRT_ERROR
expr_stmt|;
block|}
else|else
block|{
name|dbg
operator|=
name|MPT_PRT_DEBUG1
expr_stmt|;
block|}
name|mpt_lprt
argument_list|(
name|mpt
argument_list|,
name|dbg
argument_list|,
literal|"SCSI_TGT REPLY: req=%p:%u reply=%p func=%x IOCstatus 0x%x\n"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|serno
argument_list|,
name|reply_frame
argument_list|,
name|reply_frame
operator|->
name|Function
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reply_frame
operator|->
name|Function
condition|)
block|{
case|case
name|MPI_FUNCTION_TARGET_CMD_BUFFER_POST
case|:
block|{
name|mpt_tgt_state_t
modifier|*
name|tgt
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"tgt reply BUFFER POST"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
name|MPI_IOCSTATUS_SUCCESS
condition|)
block|{
comment|/* 			 * XXX What to do? 			 */
break|break;
block|}
name|tgt
operator|=
name|MPT_TGT_STATE
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tgt
operator|->
name|state
operator|==
name|TGT_STATE_LOADING
argument_list|,
operator|(
literal|"bad state 0x%x on reply to buffer post\n"
operator|,
name|tgt
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
name|mpt_assign_serno
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|tgt
operator|->
name|state
operator|=
name|TGT_STATE_LOADED
expr_stmt|;
break|break;
block|}
case|case
name|MPI_FUNCTION_TARGET_ASSIST
case|:
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"tgt reply TARGET ASSIST"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"target assist completion\n"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_FUNCTION_TARGET_STATUS_SEND
case|:
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"tgt reply STATUS SEND"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"status send completion\n"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPI_FUNCTION_TARGET_MODE_ABORT
case|:
block|{
name|PTR_MSG_TARGET_MODE_ABORT_REPLY
name|abtrp
init|=
operator|(
name|PTR_MSG_TARGET_MODE_ABORT_REPLY
operator|)
name|reply_frame
decl_stmt|;
name|PTR_MSG_TARGET_MODE_ABORT
name|abtp
init|=
operator|(
name|PTR_MSG_TARGET_MODE_ABORT
operator|)
name|req
operator|->
name|req_vbuf
decl_stmt|;
name|uint32_t
name|cc
init|=
name|GET_IO_INDEX
argument_list|(
name|le32toh
argument_list|(
name|abtp
operator|->
name|ReplyWord
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|mpt_req_not_spcl
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|,
literal|"tgt reply TMODE ABORT"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"ABORT RX_ID 0x%x Complete; status 0x%x cnt %u\n"
argument_list|,
name|cc
argument_list|,
name|le16toh
argument_list|(
name|abtrp
operator|->
name|IOCStatus
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|abtrp
operator|->
name|AbortCount
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mpt
operator|->
name|request_pending_list
argument_list|,
name|req
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mpt_free_request
argument_list|(
name|mpt
argument_list|,
name|req
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|mpt_prt
argument_list|(
name|mpt
argument_list|,
literal|"Unknown Target Address Reply Function code: "
literal|"0x%x\n"
argument_list|,
name|reply_frame
operator|->
name|Function
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

end_unit

