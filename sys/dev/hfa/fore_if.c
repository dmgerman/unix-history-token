begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Network interface layer support  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_aali.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_slave.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle netatm core service interface ioctl requests   *  * Called at splnet.  *  * Arguments:  *	code		ioctl function (sub)code  *	data		data to/from ioctl  *	arg		optional code-specific argument  *  * Returns:  *	0 		request processed successfully  *	error		request failed - reason code  */
end_comment

begin_function
name|int
name|fore_atm_ioctl
parameter_list|(
name|code
parameter_list|,
name|data
parameter_list|,
name|arg
parameter_list|)
name|int
name|code
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
block|{
name|struct
name|atminfreq
modifier|*
name|aip
init|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|caddr_t
name|buf
init|=
name|aip
operator|->
name|air_buf_addr
decl_stmt|;
name|struct
name|air_vinfo_rsp
modifier|*
name|avr
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|buf_len
init|=
name|aip
operator|->
name|air_buf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|ifname
index|[
literal|2
operator|*
name|IFNAMSIZ
index|]
decl_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"fore_atm_ioctl: code=%d, opcode=%d\n"
argument_list|,
name|code
argument_list|,
name|aip
operator|->
name|air_opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|aip
operator|->
name|air_opcode
condition|)
block|{
case|case
name|AIOCS_INF_VST
case|:
comment|/* 		 * Get vendor statistics 		 */
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
name|fup
operator|=
operator|(
name|Fore_unit
operator|*
operator|)
name|pip
expr_stmt|;
if|if
condition|(
name|pip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snprintf
argument_list|(
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 		 * Cast response structure onto user's buffer 		 */
name|avr
operator|=
operator|(
expr|struct
name|air_vinfo_rsp
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 		 * How large is the response structure? 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_vinfo_rsp
argument_list|)
expr_stmt|;
comment|/* 		 * Sanity check - enough room for response structure? 		 */
if|if
condition|(
name|buf_len
operator|<
name|len
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 		 * Copy interface name into response structure 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
name|ifname
argument_list|,
name|avr
operator|->
name|avsp_intf
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Advance the buffer address and decrement the size 		 */
name|buf
operator|+=
name|len
expr_stmt|;
name|buf_len
operator|-=
name|len
expr_stmt|;
comment|/* 		 * Get the vendor stats from the hardware 		 */
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|fore_get_stats
argument_list|(
name|fup
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Stick as much of it as we have room for  			 * into the response 			 */
name|count
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|Fore_stats
argument_list|)
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/* 			 * Copy stats into user's buffer. Return value is 			 * amount of data copied. 			 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|fup
operator|->
name|fu_stats
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|buf
operator|+=
name|count
expr_stmt|;
name|buf_len
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|Fore_stats
argument_list|)
condition|)
name|err
operator|=
name|ENOSPC
expr_stmt|;
block|}
comment|/* 		 * Record amount we're returning as vendor info... 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|&
name|count
argument_list|,
operator|&
name|avr
operator|->
name|avsp_len
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Update the reply pointers and lengths 		 */
name|aip
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOSYS
expr_stmt|;
comment|/* Operation not supported */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free Fore-specific device resources  *   * Frees all dynamically acquired resources for a device unit.  Before  * this function is called, the CP will have been reset and our interrupt  * vectors removed.  *  * Arguments:  *	fup	pointer to device unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|fore_interface_free
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
comment|/* 	 * Free up all of our allocated memory 	 */
name|fore_xmit_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|fore_recv_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|fore_buf_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|fore_cmd_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Clear device initialized 	 */
if|if
condition|(
name|fup
operator|->
name|fu_flags
operator|&
name|CUF_INITED
condition|)
block|{
name|fup
operator|->
name|fu_flags
operator|&=
operator|~
name|CUF_INITED
expr_stmt|;
block|}
if|if
condition|(
name|fup
operator|->
name|fu_flags
operator|&
name|FUF_STATCMD
condition|)
block|{
name|fup
operator|->
name|fu_flags
operator|&=
operator|~
name|FUF_STATCMD
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

