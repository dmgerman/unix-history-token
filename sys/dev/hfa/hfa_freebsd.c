begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Matthew N. Dodd<winter@jurai.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_aali.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_slave.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/hfa_freebsd.h>
end_include

begin_decl_stmt
name|devclass_t
name|hfa_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|hfa_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|hfa_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hfa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hfa_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|mem_type
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate memory resource.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate interrupt resource.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"Interrupt lock"
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfa_free
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hfa_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hfa_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|mem_type
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|irq_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the mutex. 	 */
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
operator|!=
literal|0
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hfa_softc
modifier|*
name|sc
decl_stmt|;
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|err_count
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hfa_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fup
operator|=
operator|&
name|sc
operator|->
name|fup
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|err_count
operator|=
name|BOOT_LOOPS
expr_stmt|;
comment|/* 	 * Start initializing it 	 */
name|fup
operator|->
name|fu_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_mtu
operator|=
name|FORE_IFF_MTU
expr_stmt|;
name|fup
operator|->
name|fu_vcc_pool
operator|=
operator|&
name|fore_vcc_pool
expr_stmt|;
name|fup
operator|->
name|fu_nif_pool
operator|=
operator|&
name|fore_nif_pool
expr_stmt|;
name|fup
operator|->
name|fu_ioctl
operator|=
name|fore_atm_ioctl
expr_stmt|;
name|fup
operator|->
name|fu_instvcc
operator|=
name|fore_instvcc
expr_stmt|;
name|fup
operator|->
name|fu_openvcc
operator|=
name|fore_openvcc
expr_stmt|;
name|fup
operator|->
name|fu_closevcc
operator|=
name|fore_closevcc
expr_stmt|;
name|fup
operator|->
name|fu_output
operator|=
name|fore_output
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|fup
operator|->
name|fu_thandle
argument_list|)
expr_stmt|;
comment|/* 	 * Poke the hardware - boot the CP and prepare it for downloading 	 */
name|hfa_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the monitor to perform self-test 	 */
while|while
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|!=
name|BOOT_MONREADY
condition|)
block|{
if|if
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|==
name|BOOT_FAILTEST
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed self-test\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
operator|--
name|err_count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to boot - status=0x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DELAY
argument_list|(
name|BOOT_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the adapter config info - at least as much as we can 	 */
name|fup
operator|->
name|fu_config
operator|.
name|ac_vendor
operator|=
name|VENDOR_FORE
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_vendapi
operator|=
name|VENDAPI_FORE_1
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_media
operator|=
name|MEDIA_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
comment|/* 	 * Save device ram info for user-level programs 	 */
name|fup
operator|->
name|fu_config
operator|.
name|ac_ram
operator|=
operator|(
name|long
operator|)
name|fup
operator|->
name|fu_ram
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_ramsize
operator|=
name|fup
operator|->
name|fu_ramsize
expr_stmt|;
comment|/* 	 * Set device capabilities 	 */
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvpi
operator|=
name|FORE_MAX_VPI
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvci
operator|=
name|FORE_MAX_VCI
expr_stmt|;
comment|/* 	 * Register this interface with ATM core services 	 */
name|error
operator|=
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|fore_services
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|fore_units
index|[
name|device_get_unit
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|fup
expr_stmt|;
name|fore_nunits
operator|++
expr_stmt|;
comment|/* 	 * Initialize the CP microcode program. 	 */
name|fore_initialize
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfa_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hfa_softc
modifier|*
name|sc
decl_stmt|;
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hfa_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fup
operator|=
operator|&
name|sc
operator|->
name|fup
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * De-Register this interface with ATM core services 	 */
name|error
operator|=
name|atm_physif_deregister
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the board and return it to cold_start state. 	 * Hopefully, this will prevent use of resources as 	 * we're trying to free things up. 	 */
name|hfa_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Lock out all device interrupts 	 */
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Remove any pending timeout()'s 	 */
operator|(
name|void
operator|)
name|untimeout
argument_list|(
operator|(
name|KTimeout_ret
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|fore_initialize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fup
argument_list|,
name|fup
operator|->
name|fu_thandle
argument_list|)
expr_stmt|;
name|hfa_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Free any Fore-specific device resources 	 */
name|fore_interface_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hfa_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hfa_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hfa_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|HFA_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fore_intr
argument_list|(
operator|&
name|sc
operator|->
name|fup
argument_list|)
expr_stmt|;
name|HFA_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|hfa_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hfa_softc
modifier|*
name|sc
decl_stmt|;
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hfa_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fup
operator|=
operator|&
name|sc
operator|->
name|fup
expr_stmt|;
name|HFA_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the board and return it to cold_start state 	 */
if|if
condition|(
name|fup
operator|->
name|fu_mon
condition|)
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
operator|=
name|CP_WRITE
argument_list|(
name|BOOT_COLDSTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ctlreg
condition|)
block|{
switch|switch
condition|(
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
condition|)
block|{
case|case
name|DEV_FORE_ESA200E
case|:
break|break;
case|case
name|DEV_FORE_SBA200E
case|:
comment|/* 			 * Reset i960 by setting and clearing RESET 			 */
name|SBA200E_HCR_INIT
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|SBA200E_RESET
argument_list|)
expr_stmt|;
name|SBA200E_HCR_CLR
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|SBA200E_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEV_FORE_SBA200
case|:
comment|/* 			 * Reset i960 by setting and clearing RESET 			 * 			 * SBA200 will NOT reset if bit is OR'd in! 			 */
operator|*
name|fup
operator|->
name|fu_ctlreg
operator|=
name|SBA200_RESET
expr_stmt|;
operator|*
name|fup
operator|->
name|fu_ctlreg
operator|=
name|SBA200_RESET_CLR
expr_stmt|;
break|break;
case|case
name|DEV_FORE_PCA200E
case|:
comment|/* 			 * Reset i960 by setting and clearing RESET 			 */
name|PCA200E_HCR_INIT
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|PCA200E_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|PCA200E_HCR_CLR
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|PCA200E_RESET
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|HFA_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|hfa_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* 		* Verify software version 		*/
if|if
condition|(
name|atm_version
operator|!=
name|ATM_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"hfa: version mismatch: fore=%d.%d kernel=%d.%d\n"
argument_list|,
name|ATM_VERS_MAJ
argument_list|(
name|ATM_VERSION
argument_list|)
argument_list|,
name|ATM_VERS_MIN
argument_list|(
name|ATM_VERSION
argument_list|)
argument_list|,
name|ATM_VERS_MAJ
argument_list|(
name|atm_version
argument_list|)
argument_list|,
name|ATM_VERS_MIN
argument_list|(
name|atm_version
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		* Initialize DMA mapping 		*/
name|DMA_INIT
argument_list|()
expr_stmt|;
comment|/* 		* Start up watchdog timer 		*/
name|atm_timeout
argument_list|(
operator|&
name|fore_timer
argument_list|,
name|ATM_HZ
operator|*
name|FORE_TIME_TICK
argument_list|,
name|fore_timeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* 		 * Release DMA mapping 		 */
name|DMA_RELEASE
argument_list|()
expr_stmt|;
comment|/* 		 * Stop watchdog timer 		 */
name|atm_untimeout
argument_list|(
operator|&
name|fore_timer
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|hfa_moduledata
init|=
block|{
literal|"hfa"
block|,
name|hfa_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|hfa
argument_list|,
name|hfa_moduledata
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|hfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

