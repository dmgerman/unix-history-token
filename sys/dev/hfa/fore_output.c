begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * PDU output processing  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_aali.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_slave.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|KBuffer
modifier|*
name|fore_xmit_segment
parameter_list|(
name|Fore_unit
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|H_xmit_queue
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fore_seg_dma_free
parameter_list|(
name|H_xmit_queue
modifier|*
parameter_list|,
name|KBuffer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Output a PDU  *   * This function is called via the common driver code after receiving a  * stack *_DATA* command.  The common code has already validated most of  * the request so we just need to check a few more Fore-specific details.  * Then we just build a transmit descriptor request for the PDU and issue   * the command to the CP.    *  * Arguments:  *	cup	pointer to device common unit  *	cvp	pointer to common VCC entry  *	m	pointer to output PDU buffer chain head  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|fore_output
parameter_list|(
name|cup
parameter_list|,
name|cvp
parameter_list|,
name|m
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|Fore_unit
modifier|*
name|fup
init|=
operator|(
name|Fore_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Fore_vcc
modifier|*
name|fvp
init|=
operator|(
name|Fore_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|Xmit_queue
modifier|*
name|cqp
decl_stmt|;
name|Xmit_descr
modifier|*
name|xdp
decl_stmt|;
name|int
name|retry
decl_stmt|,
name|nsegs
decl_stmt|,
name|pdulen
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|atm_dev_print
condition|)
name|atm_dev_pdu_print
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|,
name|m
argument_list|,
literal|"fore_output"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
comment|/* 	 * If we're still waiting for activation to finish, delay for 	 * a little while before we toss the PDU 	 */
if|if
condition|(
name|fvp
operator|->
name|fv_state
operator|==
name|CVS_INITED
condition|)
block|{
name|retry
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|retry
operator|--
operator|&&
operator|(
name|fvp
operator|->
name|fv_state
operator|==
name|CVS_INITED
operator|)
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|->
name|fv_state
operator|!=
name|CVS_ACTIVE
condition|)
block|{
comment|/* 			 * Activation still hasn't finished, oh well.... 			 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_notact
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Queue PDU at end of transmit queue 	 * 	 * If queue is full we'll delay a bit before tossing the PDU 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_tail
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|hxp
operator|->
name|hxq_status
operator|)
operator|&
name|QSTAT_FREE
operator|)
condition|)
block|{
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_full
operator|++
expr_stmt|;
name|retry
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
name|fore_xmit_drain
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|retry
operator|&&
operator|(
operator|!
operator|(
operator|(
operator|*
name|hxp
operator|->
name|hxq_status
operator|)
operator|&
name|QSTAT_FREE
operator|)
operator|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|hxp
operator|->
name|hxq_status
operator|)
operator|&
name|QSTAT_FREE
operator|)
condition|)
block|{
comment|/* 			 * Queue is still full, bye-bye PDU 			 */
name|fup
operator|->
name|fu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * We've got a free transmit queue entry 	 */
comment|/* 	 * Now build the transmit segment descriptors for this PDU 	 */
name|m
operator|=
name|fore_xmit_segment
argument_list|(
name|fup
argument_list|,
name|m
argument_list|,
name|hxp
argument_list|,
operator|&
name|nsegs
argument_list|,
operator|&
name|pdulen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The build failed, buffer chain has been freed 		 */
name|vcp
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set up the descriptor header 	 */
name|xdp
operator|=
name|hxp
operator|->
name|hxq_descr
expr_stmt|;
name|xdp
operator|->
name|xd_cell_hdr
operator|=
name|ATM_HDR_SET
argument_list|(
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xdp
operator|->
name|xd_spec
operator|=
name|XDS_SET_SPEC
argument_list|(
literal|0
argument_list|,
name|fvp
operator|->
name|fv_aal
argument_list|,
name|nsegs
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
name|xdp
operator|->
name|xd_rate
operator|=
name|FORE_DEF_RATE
expr_stmt|;
comment|/* 	 * Everything is ready to go, so officially claim the host queue 	 * entry and setup the CP-resident queue entry.  The CP will grab 	 * the PDU when the descriptor pointer is set. 	 */
name|fup
operator|->
name|fu_xmit_tail
operator|=
name|hxp
operator|->
name|hxq_next
expr_stmt|;
name|hxp
operator|->
name|hxq_buf
operator|=
name|m
expr_stmt|;
name|hxp
operator|->
name|hxq_vcc
operator|=
name|fvp
expr_stmt|;
operator|(
operator|*
name|hxp
operator|->
name|hxq_status
operator|)
operator|=
name|QSTAT_PENDING
expr_stmt|;
name|cqp
operator|=
name|hxp
operator|->
name|hxq_cpelem
expr_stmt|;
name|cqp
operator|->
name|cq_descr
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
operator|(
name|u_long
operator|)
name|hxp
operator|->
name|hxq_descr_dma
operator||
name|XMIT_SEGS_TO_BLKS
argument_list|(
name|nsegs
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * See if there are any completed queue entries 	 */
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
name|fore_xmit_drain
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Build Transmit Segment Descriptors  *   * This function will take a supplied buffer chain of data to be transmitted  * and build the transmit segment descriptors for the data.  This will include   * the dreaded operation of ensuring that the data for each transmit segment  * is full-word aligned and (except for the last segment) is an integral number  * of words in length.  If the data isn't already aligned and sized as  * required, then the data must be shifted (copied) into place - a sure  * performance killer.  Note that we rely on the fact that all buffer data  * areas are allocated with (at least) full-word alignments/lengths.  *  * If any errors are encountered, the buffer chain will be freed.  *   * Arguments:  *	fup	pointer to device unit  *	m	pointer to output PDU buffer chain head  *	hxp	pointer to host transmit queue entry  *	segp	pointer to return the number of transmit segments  *	lenp	pointer to return the pdu length  *  * Returns:  *	m	build successful, pointer to (possibly new) head of   *		output PDU buffer chain  *	NULL	build failed, buffer chain freed  *  */
end_comment

begin_function
specifier|static
name|KBuffer
modifier|*
name|fore_xmit_segment
parameter_list|(
name|fup
parameter_list|,
name|m
parameter_list|,
name|hxp
parameter_list|,
name|segp
parameter_list|,
name|lenp
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|int
modifier|*
name|segp
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|Xmit_descr
modifier|*
name|xdp
init|=
name|hxp
operator|->
name|hxq_descr
decl_stmt|;
name|Xmit_seg_descr
modifier|*
name|xsp
decl_stmt|;
name|H_dma
modifier|*
name|sdmap
decl_stmt|;
name|KBuffer
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m1
decl_stmt|,
modifier|*
name|mprev
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|,
name|bfr
decl_stmt|;
name|void
modifier|*
name|dma
decl_stmt|;
name|int
name|pdulen
decl_stmt|,
name|nsegs
decl_stmt|,
name|len
decl_stmt|,
name|align
decl_stmt|;
name|int
name|compressed
init|=
literal|0
decl_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|retry
label|:
name|xsp
operator|=
name|xdp
operator|->
name|xd_seg
expr_stmt|;
name|sdmap
operator|=
name|hxp
operator|->
name|hxq_dma
expr_stmt|;
name|mprev
operator|=
name|NULL
expr_stmt|;
name|pdulen
operator|=
literal|0
expr_stmt|;
name|nsegs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop thru each buffer in the chain, performing the necessary 	 * data positioning and then building a segment descriptor for 	 * that data. 	 */
while|while
condition|(
name|m
condition|)
block|{
comment|/* 		 * Get rid of any zero-length buffers 		 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mprev
condition|)
block|{
name|KB_UNLINK
argument_list|(
name|m
argument_list|,
name|mprev
argument_list|,
name|m1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KB_UNLINKHEAD
argument_list|(
name|m
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m1
expr_stmt|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Make sure we don't try to use too many segments 		 */
if|if
condition|(
name|nsegs
operator|>=
name|XMIT_MAX_SEGS
condition|)
block|{
comment|/* 			 * First, free already allocated DMA addresses 			 */
name|fore_seg_dma_free
argument_list|(
name|hxp
argument_list|,
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/* 			 * Try to compress buffer chain (but only once) 			 */
if|if
condition|(
name|compressed
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_maxpdu
operator|++
expr_stmt|;
name|m
operator|=
name|atm_dev_compress
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Build segment descriptors for compressed chain 			 */
name|m0
operator|=
name|m
expr_stmt|;
name|compressed
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* 		 * Get start of data onto full-word alignment 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|cp
operator|)
operator|&
operator|(
name|XMIT_SEG_ALIGN
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Gotta slide the data up 			 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_segnoal
operator|++
expr_stmt|;
name|bfr
operator|=
name|cp
operator|-
name|align
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|bfr
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|KB_HEADMOVE
argument_list|(
name|m
argument_list|,
operator|-
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Data already aligned 			 */
name|bfr
operator|=
name|cp
expr_stmt|;
block|}
comment|/* 		 * Now work on getting the data length correct 		 */
name|len
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|align
operator|=
operator|(
name|len
operator|&
operator|(
name|XMIT_SEG_ALIGN
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&&
operator|(
name|m1
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Have to move some data from following buffer(s) 			 * to word-fill this buffer 			 */
name|int
name|ncopy
init|=
name|MIN
argument_list|(
name|XMIT_SEG_ALIGN
operator|-
name|align
argument_list|,
name|KB_LEN
argument_list|(
name|m1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncopy
condition|)
block|{
comment|/* 				 * Move data to current buffer 				 */
name|caddr_t
name|dest
decl_stmt|;
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_seglen
operator|++
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m1
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|dest
operator|=
name|bfr
operator|+
name|len
expr_stmt|;
name|KB_HEADADJ
argument_list|(
name|m1
argument_list|,
operator|-
name|ncopy
argument_list|)
expr_stmt|;
name|KB_TAILADJ
argument_list|(
name|m
argument_list|,
name|ncopy
argument_list|)
expr_stmt|;
name|len
operator|+=
name|ncopy
expr_stmt|;
while|while
condition|(
name|ncopy
operator|--
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 			 * If we've drained the buffer, free it 			 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KBuffer
modifier|*
name|m2
decl_stmt|;
name|KB_UNLINK
argument_list|(
name|m1
argument_list|,
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Finally, build the segment descriptor 		 */
comment|/* 		 * Round last segment to fullword length (if needed) 		 */
if|if
condition|(
name|len
operator|&
operator|(
name|XMIT_SEG_ALIGN
operator|-
literal|1
operator|)
condition|)
name|xsp
operator|->
name|xsd_len
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
operator|(
name|len
operator|+
name|XMIT_SEG_ALIGN
operator|)
operator|&
operator|~
operator|(
name|XMIT_SEG_ALIGN
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|xsp
operator|->
name|xsd_len
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|len
expr_stmt|;
comment|/* 		 * Get a DMA address for the data 		 */
name|dma
operator|=
operator|(
name|void
operator|*
operator|)
name|vtophys
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|==
name|NULL
condition|)
block|{
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_segdma
operator|++
expr_stmt|;
name|fore_seg_dma_free
argument_list|(
name|hxp
argument_list|,
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Now we're really ready to call it a segment 		 */
operator|*
name|sdmap
operator|++
operator|=
name|xsp
operator|->
name|xsd_buffer
operator|=
operator|(
name|H_dma
operator|)
name|dma
expr_stmt|;
comment|/* 		 * Bump counters and get ready for next buffer 		 */
name|pdulen
operator|+=
name|len
expr_stmt|;
name|nsegs
operator|++
expr_stmt|;
name|xsp
operator|++
expr_stmt|;
name|mprev
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Validate PDU length 	 */
if|if
condition|(
name|pdulen
operator|>
name|XMIT_MAX_PDULEN
condition|)
block|{
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_xm_maxpdu
operator|++
expr_stmt|;
name|fore_seg_dma_free
argument_list|(
name|hxp
argument_list|,
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Return the good news to the caller 	 */
operator|*
name|segp
operator|=
name|nsegs
expr_stmt|;
operator|*
name|lenp
operator|=
name|pdulen
expr_stmt|;
return|return
operator|(
name|m0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free Transmit Segment Queue DMA addresses  *   * Arguments:  *	hxp	pointer to host transmit queue entry  *	m0	pointer to output PDU buffer chain head  *	nsegs	number of processed transmit segments  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|fore_seg_dma_free
parameter_list|(
name|hxp
parameter_list|,
name|m0
parameter_list|,
name|nsegs
parameter_list|)
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|KBuffer
modifier|*
name|m0
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|H_dma
modifier|*
name|sdmap
init|=
name|hxp
operator|->
name|hxq_dma
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sdmap
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

