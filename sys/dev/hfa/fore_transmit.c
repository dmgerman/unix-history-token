begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: fore_transmit.c,v 1.8 1998/07/17 20:19:37 root Exp $  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Transmit queue management  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $Id: fore_transmit.c,v 1.8 1998/07/17 20:19:37 root Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_comment
comment|/*  * Allocate Transmit Queue Data Structures  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	0		allocations successful  *	else		allocation failed  */
end_comment

begin_function
name|int
name|fore_xmit_allocate
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|void
modifier|*
name|memp
decl_stmt|;
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Allocate non-cacheable memory for transmit status words 	 */
name|memp
operator|=
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
name|XMIT_QUELEN
argument_list|,
name|QSTAT_ALIGN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_xmit_stat
operator|=
operator|(
name|Q_status
operator|*
operator|)
name|memp
expr_stmt|;
name|memp
operator|=
name|DMA_GET_ADDR
argument_list|(
name|fup
operator|->
name|fu_xmit_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
name|XMIT_QUELEN
argument_list|,
name|QSTAT_ALIGN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_xmit_statd
operator|=
operator|(
name|Q_status
operator|*
operator|)
name|memp
expr_stmt|;
comment|/* 	 * Allocate memory for transmit descriptors 	 * 	 * We will allocate the transmit descriptors individually rather than  	 * as a single memory block, which will often be larger than a memory 	 * page.  On some systems (eg. FreeBSD) the physical addresses of  	 * adjacent virtual memory pages are not contiguous. 	 */
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_q
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XMIT_QUELEN
condition|;
name|i
operator|++
operator|,
name|hxp
operator|++
control|)
block|{
comment|/* 		 * Allocate a transmit descriptor for this queue entry 		 */
name|hxp
operator|->
name|hxq_descr
operator|=
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Xmit_descr
argument_list|)
argument_list|,
name|XMIT_DESCR_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hxp
operator|->
name|hxq_descr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|hxp
operator|->
name|hxq_descr_dma
operator|=
name|DMA_GET_ADDR
argument_list|(
name|hxp
operator|->
name|hxq_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|Xmit_descr
argument_list|)
argument_list|,
name|XMIT_DESCR_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hxp
operator|->
name|hxq_descr_dma
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit Queue Initialization  *  * Allocate and initialize the host-resident transmit queue structures  * and then initialize the CP-resident queue structures.  *   * Called at interrupt level.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_xmit_initialize
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|Aali
modifier|*
name|aap
init|=
name|fup
operator|->
name|fu_aali
decl_stmt|;
name|Xmit_queue
modifier|*
name|cqp
decl_stmt|;
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|Q_status
modifier|*
name|qsp
decl_stmt|;
name|Q_status
modifier|*
name|qsp_dma
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Point to CP-resident transmit queue 	 */
name|cqp
operator|=
operator|(
name|Xmit_queue
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|CP_READ
argument_list|(
name|aap
operator|->
name|aali_xmit_q
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Point to host-resident transmit queue structures 	 */
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_q
expr_stmt|;
name|qsp
operator|=
name|fup
operator|->
name|fu_xmit_stat
expr_stmt|;
name|qsp_dma
operator|=
name|fup
operator|->
name|fu_xmit_statd
expr_stmt|;
comment|/* 	 * Loop thru all queue entries and do whatever needs doing 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XMIT_QUELEN
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Set queue status word to free 		 */
operator|*
name|qsp
operator|=
name|QSTAT_FREE
expr_stmt|;
comment|/* 		 * Set up host queue entry and link into ring 		 */
name|hxp
operator|->
name|hxq_cpelem
operator|=
name|cqp
expr_stmt|;
name|hxp
operator|->
name|hxq_status
operator|=
name|qsp
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|XMIT_QUELEN
operator|-
literal|1
operator|)
condition|)
name|hxp
operator|->
name|hxq_next
operator|=
name|fup
operator|->
name|fu_xmit_q
expr_stmt|;
else|else
name|hxp
operator|->
name|hxq_next
operator|=
name|hxp
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Now let the CP into the game 		 */
name|cqp
operator|->
name|cq_status
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
name|qsp_dma
argument_list|)
expr_stmt|;
comment|/* 		 * Bump all queue pointers 		 */
name|hxp
operator|++
expr_stmt|;
name|qsp
operator|++
expr_stmt|;
name|qsp_dma
operator|++
expr_stmt|;
name|cqp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize queue pointers 	 */
name|fup
operator|->
name|fu_xmit_head
operator|=
name|fup
operator|->
name|fu_xmit_tail
operator|=
name|fup
operator|->
name|fu_xmit_q
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Drain Transmit Queue  *  * This function will free all completed entries at the head of the  * transmit queue.  Freeing the entry includes releasing the transmit  * buffers (buffer chain) back to the kernel.    *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_xmit_drain
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|H_dma
modifier|*
name|sdmap
decl_stmt|;
name|Fore_vcc
modifier|*
name|fvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
comment|/* 	 * Process each completed entry 	 */
while|while
condition|(
operator|*
name|fup
operator|->
name|fu_xmit_head
operator|->
name|hxq_status
operator|&
name|QSTAT_COMPLETED
condition|)
block|{
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_head
expr_stmt|;
comment|/* 		 * Release the entry's DMA addresses and buffer chain 		 */
for|for
control|(
name|m
operator|=
name|hxp
operator|->
name|hxq_buf
operator|,
name|sdmap
operator|=
name|hxp
operator|->
name|hxq_dma
init|;
name|m
condition|;
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
operator|,
name|sdmap
operator|++
control|)
block|{
name|caddr_t
name|cp
decl_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
operator|*
name|sdmap
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|KB_FREEALL
argument_list|(
name|hxp
operator|->
name|hxq_buf
argument_list|)
expr_stmt|;
comment|/* 		 * Get VCC over which data was sent (may be null if 		 * VCC has been closed in the meantime) 		 */
name|fvp
operator|=
name|hxp
operator|->
name|hxq_vcc
expr_stmt|;
comment|/* 		 * Now collect some statistics 		 */
if|if
condition|(
operator|*
name|hxp
operator|->
name|hxq_status
operator|&
name|QSTAT_ERROR
condition|)
block|{
comment|/* 			 * CP ran into problems, not much we can do 			 * other than record the event 			 */
name|fup
operator|->
name|fu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|fvp
condition|)
block|{
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|vcp
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Good transmission 			 */
name|int
name|len
init|=
name|XDS_GET_LEN
argument_list|(
name|hxp
operator|->
name|hxq_descr
operator|->
name|xd_spec
argument_list|)
decl_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_opdus
operator|++
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_obytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|fvp
condition|)
block|{
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|vcp
operator|->
name|vc_opdus
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_obytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
block|{
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_obytes
operator|+=
name|len
expr_stmt|;
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_obytes
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 		 * Mark this entry free for use and bump head pointer 		 * to the next entry in the queue 		 */
operator|*
name|hxp
operator|->
name|hxq_status
operator|=
name|QSTAT_FREE
expr_stmt|;
name|fup
operator|->
name|fu_xmit_head
operator|=
name|hxp
operator|->
name|hxq_next
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Free Transmit Queue Data Structures  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_xmit_free
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|H_dma
modifier|*
name|sdmap
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Free any transmit buffers left on the queue 	 */
if|if
condition|(
name|fup
operator|->
name|fu_flags
operator|&
name|CUF_INITED
condition|)
block|{
while|while
condition|(
operator|*
name|fup
operator|->
name|fu_xmit_head
operator|->
name|hxq_status
operator|!=
name|QSTAT_FREE
condition|)
block|{
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_head
expr_stmt|;
comment|/* 			 * Release the entry's DMA addresses and buffer chain 			 */
for|for
control|(
name|m
operator|=
name|hxp
operator|->
name|hxq_buf
operator|,
name|sdmap
operator|=
name|hxp
operator|->
name|hxq_dma
init|;
name|m
condition|;
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
operator|,
name|sdmap
operator|++
control|)
block|{
name|caddr_t
name|cp
decl_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
operator|*
name|sdmap
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|KB_FREEALL
argument_list|(
name|hxp
operator|->
name|hxq_buf
argument_list|)
expr_stmt|;
operator|*
name|hxp
operator|->
name|hxq_status
operator|=
name|QSTAT_FREE
expr_stmt|;
name|fup
operator|->
name|fu_xmit_head
operator|=
name|hxp
operator|->
name|hxq_next
expr_stmt|;
block|}
block|}
comment|/* 	 * Free the status words 	 */
if|if
condition|(
name|fup
operator|->
name|fu_xmit_stat
condition|)
block|{
if|if
condition|(
name|fup
operator|->
name|fu_xmit_statd
condition|)
block|{
name|DMA_FREE_ADDR
argument_list|(
name|fup
operator|->
name|fu_xmit_stat
argument_list|,
name|fup
operator|->
name|fu_xmit_statd
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
name|XMIT_QUELEN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
block|}
name|atm_dev_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fup
operator|->
name|fu_xmit_stat
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_xmit_stat
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_xmit_statd
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Free the transmit descriptors 	 */
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_q
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XMIT_QUELEN
condition|;
name|i
operator|++
operator|,
name|hxp
operator|++
control|)
block|{
comment|/* 		 * Free the transmit descriptor for this queue entry 		 */
if|if
condition|(
name|hxp
operator|->
name|hxq_descr_dma
condition|)
block|{
name|DMA_FREE_ADDR
argument_list|(
name|hxp
operator|->
name|hxq_descr
argument_list|,
name|hxp
operator|->
name|hxq_descr_dma
argument_list|,
sizeof|sizeof
argument_list|(
name|Xmit_descr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hxp
operator|->
name|hxq_descr_dma
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|hxp
operator|->
name|hxq_descr
condition|)
block|{
name|atm_dev_free
argument_list|(
name|hxp
operator|->
name|hxq_descr
argument_list|)
expr_stmt|;
name|hxp
operator|->
name|hxq_descr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

end_unit

