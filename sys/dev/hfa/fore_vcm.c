begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Virtual Channel Management  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * VCC Stack Instantiation  *   * This function is called via the common driver code during a device VCC  * stack instantiation.  The common code has already validated some of  * the request so we just need to check a few more Fore-specific details.  *  * Called at splnet.  *  * Arguments:  *	cup	pointer to device common unit  *	cvp	pointer to common VCC entry  *  * Returns:  *	0	instantiation successful  *	err 	instantiation failed - reason indicated  *  */
end_comment

begin_function
name|int
name|fore_instvcc
parameter_list|(
name|cup
parameter_list|,
name|cvp
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
block|{
name|Fore_vcc
modifier|*
name|fvp
init|=
operator|(
name|Fore_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
init|=
operator|&
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_attr
decl_stmt|;
comment|/* 	 * Validate requested AAL 	 */
switch|switch
condition|(
name|ap
operator|->
name|aal
operator|.
name|type
condition|)
block|{
case|case
name|ATM_AAL0
case|:
name|fvp
operator|->
name|fv_aal
operator|=
name|FORE_AAL_0
expr_stmt|;
break|break;
case|case
name|ATM_AAL3_4
case|:
name|fvp
operator|->
name|fv_aal
operator|=
name|FORE_AAL_4
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|forward_max_SDU_size
operator|>
name|FORE_IFF_MTU
operator|)
operator|||
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|backward_max_SDU_size
operator|>
name|FORE_IFF_MTU
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|ATM_AAL5
case|:
name|fvp
operator|->
name|fv_aal
operator|=
name|FORE_AAL_5
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
operator|>
name|FORE_IFF_MTU
operator|)
operator|||
operator|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|backward_max_SDU_size
operator|>
name|FORE_IFF_MTU
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a VCC  *   * This function is called via the common driver code after receiving a  * stack *_INIT command.  The common code has already validated most of  * the request so we just need to check a few more Fore-specific details.  * Then we just issue the command to the CP.  Note that we can't wait around  * for the CP to process the command, so we return success for now and abort  * the connection if the command later fails.  *  * Called at splimp.  *  * Arguments:  *	cup	pointer to device common unit  *	cvp	pointer to common VCC entry  *  * Returns:  *	0	open successful  *	else 	open failed  *  */
end_comment

begin_function
name|int
name|fore_openvcc
parameter_list|(
name|cup
parameter_list|,
name|cvp
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
block|{
name|Fore_unit
modifier|*
name|fup
init|=
operator|(
name|Fore_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Fore_vcc
modifier|*
name|fvp
init|=
operator|(
name|Fore_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|H_cmd_queue
modifier|*
name|hcp
decl_stmt|;
name|Cmd_queue
modifier|*
name|cqp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"fore_openvcc: fup=%p, fvp=%p, vcc=(%d,%d)\n"
argument_list|,
name|fup
argument_list|,
name|fvp
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the VPI and VCI values 	 */
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_vpi
operator|>
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvpi
operator|)
operator|||
operator|(
name|vcp
operator|->
name|vc_vci
operator|>
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvci
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Only need to tell the CP about incoming VCCs 	 */
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_type
operator|&
name|VCC_IN
operator|)
operator|==
literal|0
condition|)
block|{
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_open_vcc
operator|++
expr_stmt|;
name|fvp
operator|->
name|fv_state
operator|=
name|CVS_ACTIVE
expr_stmt|;
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Queue command at end of command queue 	 */
name|hcp
operator|=
name|fup
operator|->
name|fu_cmd_tail
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|hcp
operator|->
name|hcq_status
operator|)
operator|&
name|QSTAT_FREE
condition|)
block|{
comment|/* 		 * Queue entry available, so set our view of things up 		 */
name|hcp
operator|->
name|hcq_code
operator|=
name|CMD_ACT_VCCIN
expr_stmt|;
name|hcp
operator|->
name|hcq_arg
operator|=
name|fvp
expr_stmt|;
name|fup
operator|->
name|fu_cmd_tail
operator|=
name|hcp
operator|->
name|hcq_next
expr_stmt|;
name|fvp
operator|->
name|fv_flags
operator||=
name|FVF_ACTCMD
expr_stmt|;
comment|/* 		 * Now set the CP-resident queue entry - the CP will grab 		 * the command when the op-code is set. 		 */
name|cqp
operator|=
name|hcp
operator|->
name|hcq_cpelem
expr_stmt|;
operator|(
operator|*
name|hcp
operator|->
name|hcq_status
operator|)
operator|=
name|QSTAT_PENDING
expr_stmt|;
name|cqp
operator|->
name|cmdq_act
operator|.
name|act_vccid
operator|=
name|CP_WRITE
argument_list|(
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|->
name|fv_aal
operator|==
name|FORE_AAL_0
condition|)
name|cqp
operator|->
name|cmdq_act
operator|.
name|act_batch
operator|=
name|CP_WRITE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|cmdq_act
operator|.
name|act_spec
operator|=
name|CP_WRITE
argument_list|(
name|ACT_SET_SPEC
argument_list|(
name|BUF_STRAT_1
argument_list|,
name|fvp
operator|->
name|fv_aal
argument_list|,
name|CMD_ACT_VCCIN
operator||
name|CMD_INTR_REQ
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Command queue full 		 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_cm_full
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a VCC  *   * This function is called via the common driver code after receiving a  * stack *_TERM command.  The common code has already validated most of  * the request so we just need to check a few more Fore-specific details.  * Then we just issue the command to the CP.  Note that we can't wait around  * for the CP to process the command, so we return success for now and whine  * if the command later fails.  *  * Called at splimp.  *  * Arguments:  *	cup	pointer to device common unit  *	cvp	pointer to common VCC entry  *  * Returns:  *	0	close successful  *	else 	close failed  *  */
end_comment

begin_function
name|int
name|fore_closevcc
parameter_list|(
name|cup
parameter_list|,
name|cvp
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
block|{
name|Fore_unit
modifier|*
name|fup
init|=
operator|(
name|Fore_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Fore_vcc
modifier|*
name|fvp
init|=
operator|(
name|Fore_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|H_xmit_queue
modifier|*
name|hxp
decl_stmt|;
name|H_cmd_queue
modifier|*
name|hcp
decl_stmt|;
name|Cmd_queue
modifier|*
name|cqp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|ATM_DEBUG4
argument_list|(
literal|"fore_closevcc: fup=%p, fvp=%p, vcc=(%d,%d)\n"
argument_list|,
name|fup
argument_list|,
name|fvp
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Clear any references to this VCC in our transmit queue 	 */
for|for
control|(
name|hxp
operator|=
name|fup
operator|->
name|fu_xmit_head
operator|,
name|i
operator|=
literal|0
init|;
operator|(
operator|*
name|hxp
operator|->
name|hxq_status
operator|!=
name|QSTAT_FREE
operator|)
operator|&&
operator|(
name|i
operator|<
name|XMIT_QUELEN
operator|)
condition|;
name|hxp
operator|=
name|hxp
operator|->
name|hxq_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hxp
operator|->
name|hxq_vcc
operator|==
name|fvp
condition|)
block|{
name|hxp
operator|->
name|hxq_vcc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Clear any references to this VCC in our command queue 	 */
for|for
control|(
name|hcp
operator|=
name|fup
operator|->
name|fu_cmd_head
operator|,
name|i
operator|=
literal|0
init|;
operator|(
operator|*
name|hcp
operator|->
name|hcq_status
operator|!=
name|QSTAT_FREE
operator|)
operator|&&
operator|(
name|i
operator|<
name|CMD_QUELEN
operator|)
condition|;
name|hcp
operator|=
name|hcp
operator|->
name|hcq_next
operator|,
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|hcp
operator|->
name|hcq_code
condition|)
block|{
case|case
name|CMD_ACT_VCCIN
case|:
case|case
name|CMD_ACT_VCCOUT
case|:
if|if
condition|(
name|hcp
operator|->
name|hcq_arg
operator|==
name|fvp
condition|)
block|{
name|hcp
operator|->
name|hcq_arg
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 	 * If this VCC has been previously activated, then we need to tell 	 * the CP to deactivate it. 	 */
if|if
condition|(
name|fvp
operator|->
name|fv_flags
operator|&
name|FVF_ACTCMD
condition|)
block|{
comment|/* 		 * Queue command at end of command queue 		 */
name|hcp
operator|=
name|fup
operator|->
name|fu_cmd_tail
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|hcp
operator|->
name|hcq_status
operator|)
operator|&
name|QSTAT_FREE
condition|)
block|{
comment|/* 			 * Queue entry available, so set our view of things up 			 */
name|hcp
operator|->
name|hcq_code
operator|=
name|CMD_DACT_VCCIN
expr_stmt|;
name|hcp
operator|->
name|hcq_arg
operator|=
name|fvp
expr_stmt|;
name|fup
operator|->
name|fu_cmd_tail
operator|=
name|hcp
operator|->
name|hcq_next
expr_stmt|;
comment|/* 			 * Now set the CP-resident queue entry - the CP will  			 * grab the command when the op-code is set. 			 */
name|cqp
operator|=
name|hcp
operator|->
name|hcq_cpelem
expr_stmt|;
operator|(
operator|*
name|hcp
operator|->
name|hcq_status
operator|)
operator|=
name|QSTAT_PENDING
expr_stmt|;
name|cqp
operator|->
name|cmdq_dact
operator|.
name|dact_vccid
operator|=
name|CP_WRITE
argument_list|(
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|cmdq_dact
operator|.
name|dact_cmd
operator|=
name|CP_WRITE
argument_list|(
name|CMD_DACT_VCCIN
operator||
name|CMD_INTR_REQ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Command queue full 			 * 			 * If we get here, we'll be getting out-of-sync with 			 * the CP because we can't (for now at least) do 			 * anything about close errors in the common code. 			 * This won't be too bad, since we'll just toss any 			 * PDUs received from the VCC and the sigmgr's will 			 * always get open failures when trying to use this 			 * (vpi,vci)...oh, well...always gotta have that one 			 * last bug to fix! XXX 			 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_cm_full
operator|++
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Finish up... 	 */
if|if
condition|(
name|fvp
operator|->
name|fv_state
operator|==
name|CVS_ACTIVE
condition|)
name|fup
operator|->
name|fu_open_vcc
operator|--
expr_stmt|;
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

