begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: fore_receive.c,v 1.10 1998/07/17 20:19:35 root Exp $  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Receive queue management  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $Id: fore_receive.c,v 1.10 1998/07/17 20:19:35 root Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fore_recv_stack
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|KBuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate Receive Queue Data Structures  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	0		allocations successful  *	else		allocation failed  */
end_comment

begin_function
name|int
name|fore_recv_allocate
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|caddr_t
name|memp
decl_stmt|;
comment|/* 	 * Allocate non-cacheable memory for receive status words 	 */
name|memp
operator|=
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
name|RECV_QUELEN
argument_list|,
name|QSTAT_ALIGN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_recv_stat
operator|=
operator|(
name|Q_status
operator|*
operator|)
name|memp
expr_stmt|;
name|memp
operator|=
name|DMA_GET_ADDR
argument_list|(
name|fup
operator|->
name|fu_recv_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
name|RECV_QUELEN
argument_list|,
name|QSTAT_ALIGN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_recv_statd
operator|=
operator|(
name|Q_status
operator|*
operator|)
name|memp
expr_stmt|;
comment|/* 	 * Allocate memory for receive descriptors 	 */
name|memp
operator|=
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Recv_descr
argument_list|)
operator|*
name|RECV_QUELEN
argument_list|,
name|RECV_DESCR_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_recv_desc
operator|=
operator|(
name|Recv_descr
operator|*
operator|)
name|memp
expr_stmt|;
name|memp
operator|=
name|DMA_GET_ADDR
argument_list|(
name|fup
operator|->
name|fu_recv_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|Recv_descr
argument_list|)
operator|*
name|RECV_QUELEN
argument_list|,
name|RECV_DESCR_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_recv_descd
operator|=
operator|(
name|Recv_descr
operator|*
operator|)
name|memp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive Queue Initialization  *  * Allocate and initialize the host-resident receive queue structures  * and then initialize the CP-resident queue structures.  *   * Called at interrupt level.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_recv_initialize
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|Aali
modifier|*
name|aap
init|=
name|fup
operator|->
name|fu_aali
decl_stmt|;
name|Recv_queue
modifier|*
name|cqp
decl_stmt|;
name|H_recv_queue
modifier|*
name|hrp
decl_stmt|;
name|Recv_descr
modifier|*
name|rdp
decl_stmt|;
name|Recv_descr
modifier|*
name|rdp_dma
decl_stmt|;
name|Q_status
modifier|*
name|qsp
decl_stmt|;
name|Q_status
modifier|*
name|qsp_dma
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Point to CP-resident receive queue 	 */
name|cqp
operator|=
operator|(
name|Recv_queue
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|CP_READ
argument_list|(
name|aap
operator|->
name|aali_recv_q
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Point to host-resident receive queue structures 	 */
name|hrp
operator|=
name|fup
operator|->
name|fu_recv_q
expr_stmt|;
name|qsp
operator|=
name|fup
operator|->
name|fu_recv_stat
expr_stmt|;
name|qsp_dma
operator|=
name|fup
operator|->
name|fu_recv_statd
expr_stmt|;
name|rdp
operator|=
name|fup
operator|->
name|fu_recv_desc
expr_stmt|;
name|rdp_dma
operator|=
name|fup
operator|->
name|fu_recv_descd
expr_stmt|;
comment|/* 	 * Loop thru all queue entries and do whatever needs doing 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECV_QUELEN
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Set queue status word to free 		 */
operator|*
name|qsp
operator|=
name|QSTAT_FREE
expr_stmt|;
comment|/* 		 * Set up host queue entry and link into ring 		 */
name|hrp
operator|->
name|hrq_cpelem
operator|=
name|cqp
expr_stmt|;
name|hrp
operator|->
name|hrq_status
operator|=
name|qsp
expr_stmt|;
name|hrp
operator|->
name|hrq_descr
operator|=
name|rdp
expr_stmt|;
name|hrp
operator|->
name|hrq_descr_dma
operator|=
name|rdp_dma
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|RECV_QUELEN
operator|-
literal|1
operator|)
condition|)
name|hrp
operator|->
name|hrq_next
operator|=
name|fup
operator|->
name|fu_recv_q
expr_stmt|;
else|else
name|hrp
operator|->
name|hrq_next
operator|=
name|hrp
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Now let the CP into the game 		 */
name|cqp
operator|->
name|cq_descr
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
name|rdp_dma
argument_list|)
expr_stmt|;
name|cqp
operator|->
name|cq_status
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
name|qsp_dma
argument_list|)
expr_stmt|;
comment|/* 		 * Bump all queue pointers 		 */
name|hrp
operator|++
expr_stmt|;
name|qsp
operator|++
expr_stmt|;
name|qsp_dma
operator|++
expr_stmt|;
name|rdp
operator|++
expr_stmt|;
name|rdp_dma
operator|++
expr_stmt|;
name|cqp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize queue pointers 	 */
name|fup
operator|->
name|fu_recv_head
operator|=
name|fup
operator|->
name|fu_recv_q
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Drain Receive Queue  *  * This function will process all completed entries at the head of the  * receive queue.  The received segments will be linked into a received  * PDU buffer chain and it will then be passed up the PDU's VCC stack for   * processing by the next higher protocol layer.  *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_recv_drain
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|H_recv_queue
modifier|*
name|hrp
init|=
name|NULL
decl_stmt|;
name|Recv_descr
modifier|*
name|rdp
decl_stmt|;
name|Recv_seg_descr
modifier|*
name|rsp
decl_stmt|;
name|Buf_handle
modifier|*
name|bhp
decl_stmt|;
name|Fore_vcc
modifier|*
name|fvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|,
modifier|*
name|mhead
decl_stmt|,
modifier|*
name|mtail
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|u_long
name|hdr
decl_stmt|,
name|nsegs
decl_stmt|;
name|u_int
name|seglen
decl_stmt|,
name|type0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pdulen
decl_stmt|,
name|retries
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
comment|/* Silence the compiler */
name|mtail
operator|=
name|NULL
expr_stmt|;
name|type0
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Process each completed entry 	 */
name|retry
label|:
while|while
condition|(
operator|*
name|fup
operator|->
name|fu_recv_head
operator|->
name|hrq_status
operator|&
name|QSTAT_COMPLETED
condition|)
block|{
comment|/* 		 * Get completed entry's receive descriptor 		 */
name|hrp
operator|=
name|fup
operator|->
name|fu_recv_head
expr_stmt|;
name|rdp
operator|=
name|hrp
operator|->
name|hrq_descr
expr_stmt|;
ifdef|#
directive|ifdef
name|VAC
comment|/* 		 * Cache flush receive descriptor  		 */
if|if
condition|(
name|vac
condition|)
block|{
name|vac_flush
argument_list|(
operator|(
name|addr_t
operator|)
name|rdp
argument_list|,
sizeof|sizeof
argument_list|(
name|Recv_descr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hdr
operator|=
name|rdp
operator|->
name|rd_cell_hdr
expr_stmt|;
name|nsegs
operator|=
name|rdp
operator|->
name|rd_nsegs
expr_stmt|;
name|pdulen
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mhead
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Locate incoming VCC for this PDU 		 */
name|fvp
operator|=
operator|(
name|Fore_vcc
operator|*
operator|)
name|atm_dev_vcc_find
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|,
name|ATM_HDR_GET_VPI
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|ATM_HDR_GET_VCI
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|VCC_IN
argument_list|)
expr_stmt|;
comment|/* 		 * Check for a receive error 		 * 		 * Apparently the receive descriptor itself contains valid  		 * information, but the received pdu data is probably bogus. 		 * We'll arrange for the receive buffer segments to be tossed. 		 */
if|if
condition|(
operator|*
name|hrp
operator|->
name|hrq_status
operator|&
name|QSTAT_ERROR
condition|)
block|{
name|fup
operator|->
name|fu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|fvp
condition|)
block|{
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|vcp
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
name|ATM_DEBUG1
argument_list|(
literal|"fore receive error: hdr=0x%x\n"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Build PDU buffer chain from receive segments 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rsp
operator|=
name|rdp
operator|->
name|rd_seg
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
operator|,
name|rsp
operator|++
control|)
block|{
name|bhp
operator|=
name|rsp
operator|->
name|rsd_handle
expr_stmt|;
name|seglen
operator|=
name|rsp
operator|->
name|rsd_len
expr_stmt|;
comment|/* 			 * Remove buffer from our supplied queue and get 			 * to the underlying buffer 			 */
switch|switch
condition|(
name|bhp
operator|->
name|bh_type
condition|)
block|{
case|case
name|BHT_S1_SMALL
case|:
name|DEQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1s_bq
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_buf1s_cnt
operator|--
expr_stmt|;
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|bhp
operator|-
name|BUF1_SM_HOFF
operator|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
name|bhp
operator|->
name|bh_dma
argument_list|,
name|BUF1_SM_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BHT_S1_LARGE
case|:
name|DEQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1l_bq
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_cnt
operator|--
expr_stmt|;
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|bhp
operator|-
name|BUF1_LG_HOFF
operator|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
name|bhp
operator|->
name|bh_dma
argument_list|,
name|BUF1_LG_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_recv_drain: bhp=0x%x type=0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|bhp
argument_list|,
name|bhp
operator|->
name|bh_type
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"fore_recv_drain: bad buffer type"
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Toss any zero-length or receive error buffers  			 */
if|if
condition|(
operator|(
name|seglen
operator|==
literal|0
operator|)
operator|||
name|error
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Link buffer into chain 			 */
if|if
condition|(
name|mhead
operator|==
name|NULL
condition|)
block|{
name|type0
operator|=
name|bhp
operator|->
name|bh_type
expr_stmt|;
name|KB_LINKHEAD
argument_list|(
name|m
argument_list|,
name|mhead
argument_list|)
expr_stmt|;
name|mhead
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|KB_LINK
argument_list|(
name|m
argument_list|,
name|mtail
argument_list|)
expr_stmt|;
block|}
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|seglen
expr_stmt|;
name|pdulen
operator|+=
name|seglen
expr_stmt|;
name|mtail
operator|=
name|m
expr_stmt|;
comment|/* 			 * Flush received buffer data 			 */
ifdef|#
directive|ifdef
name|VAC
if|if
condition|(
name|vac
condition|)
block|{
name|addr_t
name|dp
decl_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|dp
argument_list|,
name|addr_t
argument_list|)
expr_stmt|;
name|vac_pageflush
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 		 * Make sure we've got a non-null PDU 		 */
if|if
condition|(
name|mhead
operator|==
name|NULL
condition|)
block|{
goto|goto
name|free_ent
goto|;
block|}
comment|/* 		 * We only support user data PDUs (for now) 		 */
if|if
condition|(
name|hdr
operator|&
name|ATM_HDR_SET_PT
argument_list|(
name|ATM_PT_NONUSER
argument_list|)
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
goto|goto
name|free_ent
goto|;
block|}
comment|/* 		 * Toss the data if there's no VCC 		 */
if|if
condition|(
name|fvp
operator|==
name|NULL
condition|)
block|{
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_rv_novcc
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
goto|goto
name|free_ent
goto|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|atm_dev_print
condition|)
name|atm_dev_pdu_print
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|,
operator|(
name|Cmn_vcc
operator|*
operator|)
name|fvp
argument_list|,
name|mhead
argument_list|,
literal|"fore_recv"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Make sure we have our queueing headroom at the front 		 * of the buffer chain 		 */
if|if
condition|(
name|type0
operator|!=
name|BHT_S1_SMALL
condition|)
block|{
comment|/* 			 * Small buffers already have headroom built-in, but 			 * if CP had to use a large buffer for the first  			 * buffer, then we have to allocate a buffer here to 			 * contain the headroom. 			 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_rv_nosbf
operator|++
expr_stmt|;
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
name|BUF1_SM_SIZE
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_rv_nomb
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
goto|goto
name|free_ent
goto|;
block|}
comment|/* 			 * Put new buffer at head of PDU chain 			 */
name|KB_LINKHEAD
argument_list|(
name|m
argument_list|,
name|mhead
argument_list|)
expr_stmt|;
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|0
expr_stmt|;
name|KB_HEADSET
argument_list|(
name|m
argument_list|,
name|BUF1_SM_DOFF
argument_list|)
expr_stmt|;
name|mhead
operator|=
name|m
expr_stmt|;
block|}
comment|/* 		 * It looks like we've got a valid PDU - count it quick!! 		 */
name|KB_PLENSET
argument_list|(
name|mhead
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_ipdus
operator|++
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_ibytes
operator|+=
name|pdulen
expr_stmt|;
name|vcp
operator|=
name|fvp
operator|->
name|fv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|vcp
operator|->
name|vc_ipdus
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_ibytes
operator|+=
name|pdulen
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
block|{
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_ibytes
operator|+=
name|pdulen
expr_stmt|;
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_ibytes
operator|+=
name|pdulen
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * The STACK_CALL needs to happen at splnet() in order 		 * for the stack sequence processing to work.  Schedule an 		 * interrupt queue callback at splnet() since we are  		 * currently at device level. 		 */
comment|/* 		 * Prepend callback function pointer and token value to buffer. 		 * We have already guaranteed that the space is available 		 * in the first buffer. 		 */
name|KB_HEADADJ
argument_list|(
name|mhead
argument_list|,
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|mhead
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|atm_intr_func_t
operator|*
operator|)
name|cp
operator|)
operator|=
name|fore_recv_stack
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cp
operator|)
operator|=
operator|(
name|void
operator|*
operator|)
name|fvp
expr_stmt|;
comment|/* 		 * Schedule callback 		 */
if|if
condition|(
operator|!
name|IF_QFULL
argument_list|(
operator|&
name|atm_intrq
argument_list|)
condition|)
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|atm_intrq
argument_list|,
name|mhead
argument_list|)
expr_stmt|;
name|SCHED_ATM
expr_stmt|;
block|}
else|else
block|{
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_rv_ifull
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|mhead
argument_list|)
expr_stmt|;
goto|goto
name|free_ent
goto|;
block|}
name|free_ent
label|:
comment|/* 		 * Mark this entry free for use and bump head pointer 		 * to the next entry in the queue 		 */
operator|*
name|hrp
operator|->
name|hrq_status
operator|=
name|QSTAT_FREE
expr_stmt|;
name|hrp
operator|->
name|hrq_cpelem
operator|->
name|cq_descr
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
operator|(
name|u_long
operator|)
name|hrp
operator|->
name|hrq_descr_dma
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_recv_head
operator|=
name|hrp
operator|->
name|hrq_next
expr_stmt|;
block|}
comment|/* 	 * Nearly all of the interrupts generated by the CP will be due 	 * to PDU reception.  However, we may receive an interrupt before 	 * the CP has completed the status word DMA to host memory.  Thus, 	 * if we haven't processed any PDUs during this interrupt, we will 	 * wait a bit for completed work on the receive queue, rather than  	 * having to field an extra interrupt very soon. 	 */
if|if
condition|(
name|hrp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|++
name|retries
operator|<=
name|FORE_RECV_RETRY
condition|)
block|{
name|DELAY
argument_list|(
name|FORE_RECV_DELAY
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Pass Incoming PDU up Stack  *  * This function is called via the core ATM interrupt queue callback   * set in fore_recv_drain().  It will pass the supplied incoming   * PDU up the incoming VCC's stack.  *  * Called at splnet.  *  * Arguments:  *	tok		token to identify stack instantiation  *	m		pointer to incoming PDU buffer chain  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_recv_stack
parameter_list|(
name|tok
parameter_list|,
name|m
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|Fore_vcc
modifier|*
name|fvp
init|=
operator|(
name|Fore_vcc
operator|*
operator|)
name|tok
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Send the data up the stack 	 */
name|STACK_CALL
argument_list|(
name|CPCS_UNITDATA_SIG
argument_list|,
name|fvp
operator|->
name|fv_upper
argument_list|,
name|fvp
operator|->
name|fv_toku
argument_list|,
name|fvp
operator|->
name|fv_connvc
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Free Receive Queue Data Structures  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_recv_free
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
comment|/* 	 * We'll just let fore_buf_free() take care of freeing any 	 * buffers sitting on the receive queue (which are also still 	 * on the fu_*_bq queue). 	 */
if|if
condition|(
name|fup
operator|->
name|fu_flags
operator|&
name|CUF_INITED
condition|)
block|{ 	}
comment|/* 	 * Free the status words 	 */
if|if
condition|(
name|fup
operator|->
name|fu_recv_stat
condition|)
block|{
if|if
condition|(
name|fup
operator|->
name|fu_recv_statd
condition|)
block|{
name|DMA_FREE_ADDR
argument_list|(
name|fup
operator|->
name|fu_recv_stat
argument_list|,
name|fup
operator|->
name|fu_recv_statd
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
name|RECV_QUELEN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
block|}
name|atm_dev_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fup
operator|->
name|fu_recv_stat
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_recv_stat
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_recv_statd
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Free the receive descriptors 	 */
if|if
condition|(
name|fup
operator|->
name|fu_recv_desc
condition|)
block|{
if|if
condition|(
name|fup
operator|->
name|fu_recv_descd
condition|)
block|{
name|DMA_FREE_ADDR
argument_list|(
name|fup
operator|->
name|fu_recv_desc
argument_list|,
name|fup
operator|->
name|fu_recv_descd
argument_list|,
sizeof|sizeof
argument_list|(
name|Recv_descr
argument_list|)
operator|*
name|RECV_QUELEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atm_dev_free
argument_list|(
name|fup
operator|->
name|fu_recv_desc
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_recv_desc
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_recv_descd
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

