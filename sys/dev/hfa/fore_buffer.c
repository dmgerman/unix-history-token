begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Buffer Supply queue management  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fore_buf_drain
name|__P
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fore_buf_supply_1s
name|__P
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fore_buf_supply_1l
name|__P
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate Buffer Supply Queues Data Structures  *  * Here we are allocating memory for both Strategy 1 Small and Large  * structures contiguously.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	0		allocations successful  *	else		allocation failed  */
end_comment

begin_function
name|int
name|fore_buf_allocate
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|caddr_t
name|memp
decl_stmt|;
comment|/* 	 * Allocate non-cacheable memory for buffer supply status words 	 */
name|memp
operator|=
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
operator|(
name|BUF1_SM_QUELEN
operator|+
name|BUF1_LG_QUELEN
operator|)
argument_list|,
name|QSTAT_ALIGN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_buf1s_stat
operator|=
operator|(
name|Q_status
operator|*
operator|)
name|memp
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_stat
operator|=
operator|(
operator|(
name|Q_status
operator|*
operator|)
name|memp
operator|)
operator|+
name|BUF1_SM_QUELEN
expr_stmt|;
name|memp
operator|=
name|DMA_GET_ADDR
argument_list|(
name|fup
operator|->
name|fu_buf1s_stat
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
operator|(
name|BUF1_SM_QUELEN
operator|+
name|BUF1_LG_QUELEN
operator|)
argument_list|,
name|QSTAT_ALIGN
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_buf1s_statd
operator|=
operator|(
name|Q_status
operator|*
operator|)
name|memp
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_statd
operator|=
operator|(
operator|(
name|Q_status
operator|*
operator|)
name|memp
operator|)
operator|+
name|BUF1_SM_QUELEN
expr_stmt|;
comment|/* 	 * Allocate memory for buffer supply descriptors 	 */
name|memp
operator|=
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Buf_descr
argument_list|)
operator|*
operator|(
operator|(
name|BUF1_SM_QUELEN
operator|*
name|BUF1_SM_ENTSIZE
operator|)
operator|+
operator|(
name|BUF1_LG_QUELEN
operator|*
name|BUF1_LG_ENTSIZE
operator|)
operator|)
argument_list|,
name|BUF_DESCR_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_buf1s_desc
operator|=
operator|(
name|Buf_descr
operator|*
operator|)
name|memp
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_desc
operator|=
operator|(
operator|(
name|Buf_descr
operator|*
operator|)
name|memp
operator|)
operator|+
operator|(
name|BUF1_SM_QUELEN
operator|*
name|BUF1_SM_ENTSIZE
operator|)
expr_stmt|;
name|memp
operator|=
name|DMA_GET_ADDR
argument_list|(
name|fup
operator|->
name|fu_buf1s_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|Buf_descr
argument_list|)
operator|*
operator|(
operator|(
name|BUF1_SM_QUELEN
operator|*
name|BUF1_SM_ENTSIZE
operator|)
operator|+
operator|(
name|BUF1_LG_QUELEN
operator|*
name|BUF1_LG_ENTSIZE
operator|)
operator|)
argument_list|,
name|BUF_DESCR_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_buf1s_descd
operator|=
operator|(
name|Buf_descr
operator|*
operator|)
name|memp
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_descd
operator|=
operator|(
operator|(
name|Buf_descr
operator|*
operator|)
name|memp
operator|)
operator|+
operator|(
name|BUF1_SM_QUELEN
operator|*
name|BUF1_SM_ENTSIZE
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Buffer Supply Queues Initialization  *  * Allocate and initialize the host-resident buffer supply queue structures  * and then initialize the CP-resident queue structures.  *   * Called at interrupt level.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_buf_initialize
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|Aali
modifier|*
name|aap
init|=
name|fup
operator|->
name|fu_aali
decl_stmt|;
name|Buf_queue
modifier|*
name|cqp
decl_stmt|;
name|H_buf_queue
modifier|*
name|hbp
decl_stmt|;
name|Buf_descr
modifier|*
name|bdp
decl_stmt|;
name|Buf_descr
modifier|*
name|bdp_dma
decl_stmt|;
name|Q_status
modifier|*
name|qsp
decl_stmt|;
name|Q_status
modifier|*
name|qsp_dma
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Initialize Strategy 1 Small Queues 	 */
comment|/* 	 * Point to CP-resident buffer supply queue 	 */
name|cqp
operator|=
operator|(
name|Buf_queue
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|CP_READ
argument_list|(
name|aap
operator|->
name|aali_buf1s_q
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Point to host-resident buffer supply queue structures 	 */
name|hbp
operator|=
name|fup
operator|->
name|fu_buf1s_q
expr_stmt|;
name|qsp
operator|=
name|fup
operator|->
name|fu_buf1s_stat
expr_stmt|;
name|qsp_dma
operator|=
name|fup
operator|->
name|fu_buf1s_statd
expr_stmt|;
name|bdp
operator|=
name|fup
operator|->
name|fu_buf1s_desc
expr_stmt|;
name|bdp_dma
operator|=
name|fup
operator|->
name|fu_buf1s_descd
expr_stmt|;
comment|/* 	 * Loop thru all queue entries and do whatever needs doing 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF1_SM_QUELEN
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Set queue status word to free 		 */
operator|*
name|qsp
operator|=
name|QSTAT_FREE
expr_stmt|;
comment|/* 		 * Set up host queue entry and link into ring 		 */
name|hbp
operator|->
name|hbq_cpelem
operator|=
name|cqp
expr_stmt|;
name|hbp
operator|->
name|hbq_status
operator|=
name|qsp
expr_stmt|;
name|hbp
operator|->
name|hbq_descr
operator|=
name|bdp
expr_stmt|;
name|hbp
operator|->
name|hbq_descr_dma
operator|=
name|bdp_dma
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|BUF1_SM_QUELEN
operator|-
literal|1
operator|)
condition|)
name|hbp
operator|->
name|hbq_next
operator|=
name|fup
operator|->
name|fu_buf1s_q
expr_stmt|;
else|else
name|hbp
operator|->
name|hbq_next
operator|=
name|hbp
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Now let the CP into the game 		 */
name|cqp
operator|->
name|cq_status
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
name|qsp_dma
argument_list|)
expr_stmt|;
comment|/* 		 * Bump all queue pointers 		 */
name|hbp
operator|++
expr_stmt|;
name|qsp
operator|++
expr_stmt|;
name|qsp_dma
operator|++
expr_stmt|;
name|bdp
operator|+=
name|BUF1_SM_ENTSIZE
expr_stmt|;
name|bdp_dma
operator|+=
name|BUF1_SM_ENTSIZE
expr_stmt|;
name|cqp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize queue pointers 	 */
name|fup
operator|->
name|fu_buf1s_head
operator|=
name|fup
operator|->
name|fu_buf1s_tail
operator|=
name|fup
operator|->
name|fu_buf1s_q
expr_stmt|;
comment|/* 	 * Initialize Strategy 1 Large Queues 	 */
comment|/* 	 * Point to CP-resident buffer supply queue 	 */
name|cqp
operator|=
operator|(
name|Buf_queue
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|CP_READ
argument_list|(
name|aap
operator|->
name|aali_buf1l_q
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Point to host-resident buffer supply queue structures 	 */
name|hbp
operator|=
name|fup
operator|->
name|fu_buf1l_q
expr_stmt|;
name|qsp
operator|=
name|fup
operator|->
name|fu_buf1l_stat
expr_stmt|;
name|qsp_dma
operator|=
name|fup
operator|->
name|fu_buf1l_statd
expr_stmt|;
name|bdp
operator|=
name|fup
operator|->
name|fu_buf1l_desc
expr_stmt|;
name|bdp_dma
operator|=
name|fup
operator|->
name|fu_buf1l_descd
expr_stmt|;
comment|/* 	 * Loop thru all queue entries and do whatever needs doing 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF1_LG_QUELEN
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Set queue status word to free 		 */
operator|*
name|qsp
operator|=
name|QSTAT_FREE
expr_stmt|;
comment|/* 		 * Set up host queue entry and link into ring 		 */
name|hbp
operator|->
name|hbq_cpelem
operator|=
name|cqp
expr_stmt|;
name|hbp
operator|->
name|hbq_status
operator|=
name|qsp
expr_stmt|;
name|hbp
operator|->
name|hbq_descr
operator|=
name|bdp
expr_stmt|;
name|hbp
operator|->
name|hbq_descr_dma
operator|=
name|bdp_dma
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|BUF1_LG_QUELEN
operator|-
literal|1
operator|)
condition|)
name|hbp
operator|->
name|hbq_next
operator|=
name|fup
operator|->
name|fu_buf1l_q
expr_stmt|;
else|else
name|hbp
operator|->
name|hbq_next
operator|=
name|hbp
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Now let the CP into the game 		 */
name|cqp
operator|->
name|cq_status
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
name|qsp_dma
argument_list|)
expr_stmt|;
comment|/* 		 * Bump all queue pointers 		 */
name|hbp
operator|++
expr_stmt|;
name|qsp
operator|++
expr_stmt|;
name|qsp_dma
operator|++
expr_stmt|;
name|bdp
operator|+=
name|BUF1_LG_ENTSIZE
expr_stmt|;
name|bdp_dma
operator|+=
name|BUF1_LG_ENTSIZE
expr_stmt|;
name|cqp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize queue pointers 	 */
name|fup
operator|->
name|fu_buf1l_head
operator|=
name|fup
operator|->
name|fu_buf1l_tail
operator|=
name|fup
operator|->
name|fu_buf1l_q
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Supply Buffers to CP  *  * This function will resupply the CP with buffers to be used to  * store incoming data.  *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_buf_supply
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
comment|/* 	 * First, clean out the supply queues 	 */
name|fore_buf_drain
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Then, supply the buffers for each queue 	 */
name|fore_buf_supply_1s
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|fore_buf_supply_1l
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Supply Strategy 1 Small Buffers to CP  *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_buf_supply_1s
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|H_buf_queue
modifier|*
name|hbp
decl_stmt|;
name|Buf_queue
modifier|*
name|cqp
decl_stmt|;
name|Buf_descr
modifier|*
name|bdp
decl_stmt|;
name|Buf_handle
modifier|*
name|bhp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|int
name|nvcc
decl_stmt|,
name|nbuf
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Figure out how many buffers we should be giving to the CP. 	 * We're basing this calculation on the current number of open 	 * VCCs thru this device, with certain minimum and maximum values 	 * enforced.  This will then allow us to figure out how many more  	 * buffers we need to supply to the CP.  This will be rounded up  	 * to fill a supply queue entry. 	 */
name|nvcc
operator|=
name|MAX
argument_list|(
name|fup
operator|->
name|fu_open_vcc
argument_list|,
name|BUF_MIN_VCC
argument_list|)
expr_stmt|;
name|nbuf
operator|=
name|nvcc
operator|*
literal|4
expr_stmt|;
name|nbuf
operator|=
name|MIN
argument_list|(
name|nbuf
argument_list|,
name|BUF1_SM_CPPOOL
argument_list|)
expr_stmt|;
name|nbuf
operator|-=
name|fup
operator|->
name|fu_buf1s_cnt
expr_stmt|;
name|nbuf
operator|=
name|roundup
argument_list|(
name|nbuf
argument_list|,
name|BUF1_SM_ENTSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * OK, now supply the buffers to the CP 	 */
while|while
condition|(
name|nbuf
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Acquire a supply queue entry 		 */
name|hbp
operator|=
name|fup
operator|->
name|fu_buf1s_tail
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|hbp
operator|->
name|hbq_status
operator|)
operator|&
name|QSTAT_FREE
operator|)
condition|)
break|break;
name|bdp
operator|=
name|hbp
operator|->
name|hbq_descr
expr_stmt|;
comment|/* 		 * Get a buffer for each descriptor in the queue entry 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF1_SM_ENTSIZE
condition|;
name|i
operator|++
operator|,
name|bdp
operator|++
control|)
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 			 * Get a small buffer 			 */
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
name|BUF1_SM_SIZE
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|KB_HEADSET
argument_list|(
name|m
argument_list|,
name|BUF1_SM_DOFF
argument_list|)
expr_stmt|;
comment|/* 			 * Point to buffer handle structure 			 */
name|bhp
operator|=
operator|(
name|Buf_handle
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|m
operator|+
name|BUF1_SM_HOFF
operator|)
expr_stmt|;
name|bhp
operator|->
name|bh_type
operator|=
name|BHT_S1_SMALL
expr_stmt|;
comment|/* 			 * Setup buffer descriptor 			 */
name|bdp
operator|->
name|bsd_handle
operator|=
name|bhp
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|bhp
operator|->
name|bh_dma
operator|=
name|bdp
operator|->
name|bsd_buffer
operator|=
operator|(
name|H_dma
operator|)
name|DMA_GET_ADDR
argument_list|(
name|cp
argument_list|,
name|BUF1_SM_SIZE
argument_list|,
name|BUF_DATA_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdp
operator|->
name|bsd_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Unable to assign dma address - free up 				 * this descriptor's buffer 				 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_bf_segdma
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * All set, so queue buffer (handle) 			 */
name|ENQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1s_bq
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we we're not able to fill all the descriptors for 		 * an entry, free up what's been partially built 		 */
if|if
condition|(
name|i
operator|!=
name|BUF1_SM_ENTSIZE
condition|)
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 			 * Clean up each used descriptor 			 */
for|for
control|(
name|bdp
operator|=
name|hbp
operator|->
name|hbq_descr
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|bdp
operator|++
control|)
block|{
name|bhp
operator|=
name|bdp
operator|->
name|bsd_handle
expr_stmt|;
name|DEQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1s_bq
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|bhp
operator|-
name|BUF1_SM_HOFF
operator|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
name|bhp
operator|->
name|bh_dma
argument_list|,
name|BUF1_SM_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Finally, we've got an entry ready for the CP. 		 * So claim the host queue entry and setup the CP-resident 		 * queue entry.  The CP will (potentially) grab the supplied 		 * buffers when the descriptor pointer is set. 		 */
name|fup
operator|->
name|fu_buf1s_tail
operator|=
name|hbp
operator|->
name|hbq_next
expr_stmt|;
operator|(
operator|*
name|hbp
operator|->
name|hbq_status
operator|)
operator|=
name|QSTAT_PENDING
expr_stmt|;
name|cqp
operator|=
name|hbp
operator|->
name|hbq_cpelem
expr_stmt|;
name|cqp
operator|->
name|cq_descr
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
operator|(
name|u_long
operator|)
name|hbp
operator|->
name|hbq_descr_dma
argument_list|)
expr_stmt|;
comment|/* 		 * Update counters, etc for supplied buffers 		 */
name|fup
operator|->
name|fu_buf1s_cnt
operator|+=
name|BUF1_SM_ENTSIZE
expr_stmt|;
name|nbuf
operator|-=
name|BUF1_SM_ENTSIZE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Supply Strategy 1 Large Buffers to CP  *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_buf_supply_1l
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|H_buf_queue
modifier|*
name|hbp
decl_stmt|;
name|Buf_queue
modifier|*
name|cqp
decl_stmt|;
name|Buf_descr
modifier|*
name|bdp
decl_stmt|;
name|Buf_handle
modifier|*
name|bhp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|int
name|nvcc
decl_stmt|,
name|nbuf
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Figure out how many buffers we should be giving to the CP. 	 * We're basing this calculation on the current number of open 	 * VCCs thru this device, with certain minimum and maximum values 	 * enforced.  This will then allow us to figure out how many more  	 * buffers we need to supply to the CP.  This will be rounded up  	 * to fill a supply queue entry. 	 */
name|nvcc
operator|=
name|MAX
argument_list|(
name|fup
operator|->
name|fu_open_vcc
argument_list|,
name|BUF_MIN_VCC
argument_list|)
expr_stmt|;
name|nbuf
operator|=
name|nvcc
operator|*
literal|4
operator|*
name|RECV_MAX_SEGS
expr_stmt|;
name|nbuf
operator|=
name|MIN
argument_list|(
name|nbuf
argument_list|,
name|BUF1_LG_CPPOOL
argument_list|)
expr_stmt|;
name|nbuf
operator|-=
name|fup
operator|->
name|fu_buf1l_cnt
expr_stmt|;
name|nbuf
operator|=
name|roundup
argument_list|(
name|nbuf
argument_list|,
name|BUF1_LG_ENTSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * OK, now supply the buffers to the CP 	 */
while|while
condition|(
name|nbuf
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Acquire a supply queue entry 		 */
name|hbp
operator|=
name|fup
operator|->
name|fu_buf1l_tail
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|hbp
operator|->
name|hbq_status
operator|)
operator|&
name|QSTAT_FREE
operator|)
condition|)
break|break;
name|bdp
operator|=
name|hbp
operator|->
name|hbq_descr
expr_stmt|;
comment|/* 		 * Get a buffer for each descriptor in the queue entry 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF1_LG_ENTSIZE
condition|;
name|i
operator|++
operator|,
name|bdp
operator|++
control|)
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 			 * Get a cluster buffer 			 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|KB_F_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|KB_HEADSET
argument_list|(
name|m
argument_list|,
name|BUF1_LG_DOFF
argument_list|)
expr_stmt|;
comment|/* 			 * Point to buffer handle structure 			 */
name|bhp
operator|=
operator|(
name|Buf_handle
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|m
operator|+
name|BUF1_LG_HOFF
operator|)
expr_stmt|;
name|bhp
operator|->
name|bh_type
operator|=
name|BHT_S1_LARGE
expr_stmt|;
comment|/* 			 * Setup buffer descriptor 			 */
name|bdp
operator|->
name|bsd_handle
operator|=
name|bhp
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|bhp
operator|->
name|bh_dma
operator|=
name|bdp
operator|->
name|bsd_buffer
operator|=
operator|(
name|H_dma
operator|)
name|DMA_GET_ADDR
argument_list|(
name|cp
argument_list|,
name|BUF1_LG_SIZE
argument_list|,
name|BUF_DATA_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdp
operator|->
name|bsd_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Unable to assign dma address - free up 				 * this descriptor's buffer 				 */
name|fup
operator|->
name|fu_stats
operator|->
name|st_drv
operator|.
name|drv_bf_segdma
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * All set, so queue buffer (handle) 			 */
name|ENQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1l_bq
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we we're not able to fill all the descriptors for 		 * an entry, free up what's been partially built 		 */
if|if
condition|(
name|i
operator|!=
name|BUF1_LG_ENTSIZE
condition|)
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 			 * Clean up each used descriptor 			 */
for|for
control|(
name|bdp
operator|=
name|hbp
operator|->
name|hbq_descr
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|bdp
operator|++
control|)
block|{
name|bhp
operator|=
name|bdp
operator|->
name|bsd_handle
expr_stmt|;
name|DEQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1l_bq
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|bhp
operator|-
name|BUF1_LG_HOFF
operator|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
name|bhp
operator|->
name|bh_dma
argument_list|,
name|BUF1_LG_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Finally, we've got an entry ready for the CP. 		 * So claim the host queue entry and setup the CP-resident 		 * queue entry.  The CP will (potentially) grab the supplied 		 * buffers when the descriptor pointer is set. 		 */
name|fup
operator|->
name|fu_buf1l_tail
operator|=
name|hbp
operator|->
name|hbq_next
expr_stmt|;
operator|(
operator|*
name|hbp
operator|->
name|hbq_status
operator|)
operator|=
name|QSTAT_PENDING
expr_stmt|;
name|cqp
operator|=
name|hbp
operator|->
name|hbq_cpelem
expr_stmt|;
name|cqp
operator|->
name|cq_descr
operator|=
operator|(
name|CP_dma
operator|)
name|CP_WRITE
argument_list|(
operator|(
name|u_long
operator|)
name|hbp
operator|->
name|hbq_descr_dma
argument_list|)
expr_stmt|;
comment|/* 		 * Update counters, etc for supplied buffers 		 */
name|fup
operator|->
name|fu_buf1l_cnt
operator|+=
name|BUF1_LG_ENTSIZE
expr_stmt|;
name|nbuf
operator|-=
name|BUF1_LG_ENTSIZE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Drain Buffer Supply Queues  *  * This function will free all completed entries at the head of each  * buffer supply queue.  Since we consider the CP to "own" the buffers  * once we put them on a supply queue and since a completed supply queue   * entry is only telling us that the CP has accepted the buffers that we   * gave to it, there's not much to do here.  *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_buf_drain
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|H_buf_queue
modifier|*
name|hbp
decl_stmt|;
comment|/* 	 * Drain Strategy 1 Small Queue 	 */
comment|/* 	 * Process each completed entry 	 */
while|while
condition|(
operator|*
name|fup
operator|->
name|fu_buf1s_head
operator|->
name|hbq_status
operator|&
name|QSTAT_COMPLETED
condition|)
block|{
name|hbp
operator|=
name|fup
operator|->
name|fu_buf1s_head
expr_stmt|;
if|if
condition|(
operator|*
name|hbp
operator|->
name|hbq_status
operator|&
name|QSTAT_ERROR
condition|)
block|{
comment|/* 			 * XXX - what does this mean??? 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_buf_drain: buf1s queue error\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Mark this entry free for use and bump head pointer 		 * to the next entry in the queue 		 */
operator|*
name|hbp
operator|->
name|hbq_status
operator|=
name|QSTAT_FREE
expr_stmt|;
name|fup
operator|->
name|fu_buf1s_head
operator|=
name|hbp
operator|->
name|hbq_next
expr_stmt|;
block|}
comment|/* 	 * Drain Strategy 1 Large Queue 	 */
comment|/* 	 * Process each completed entry 	 */
while|while
condition|(
operator|*
name|fup
operator|->
name|fu_buf1l_head
operator|->
name|hbq_status
operator|&
name|QSTAT_COMPLETED
condition|)
block|{
name|hbp
operator|=
name|fup
operator|->
name|fu_buf1l_head
expr_stmt|;
if|if
condition|(
operator|*
name|hbp
operator|->
name|hbq_status
operator|&
name|QSTAT_ERROR
condition|)
block|{
comment|/* 			 * XXX - what does this mean??? 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_buf_drain: buf1l queue error\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Mark this entry free for use and bump head pointer 		 * to the next entry in the queue 		 */
operator|*
name|hbp
operator|->
name|hbq_status
operator|=
name|QSTAT_FREE
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_head
operator|=
name|hbp
operator|->
name|hbq_next
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Free Buffer Supply Queue Data Structures  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
name|void
name|fore_buf_free
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|Buf_handle
modifier|*
name|bhp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
comment|/* 	 * Free any previously supplied and not returned buffers 	 */
if|if
condition|(
name|fup
operator|->
name|fu_flags
operator|&
name|CUF_INITED
condition|)
block|{
comment|/* 		 * Run through Strategy 1 Small queue 		 */
while|while
condition|(
operator|(
name|bhp
operator|=
name|Q_HEAD
argument_list|(
name|fup
operator|->
name|fu_buf1s_bq
argument_list|,
name|Buf_handle
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 			 * Back off to buffer 			 */
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|bhp
operator|-
name|BUF1_SM_HOFF
operator|)
expr_stmt|;
comment|/* 			 * Dequeue handle and free buffer 			 */
name|DEQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1s_bq
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
name|bhp
operator|->
name|bh_dma
argument_list|,
name|BUF1_SM_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Run through Strategy 1 Large queue 		 */
while|while
condition|(
operator|(
name|bhp
operator|=
name|Q_HEAD
argument_list|(
name|fup
operator|->
name|fu_buf1l_bq
argument_list|,
name|Buf_handle
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|caddr_t
name|cp
decl_stmt|;
comment|/* 			 * Back off to buffer 			 */
name|m
operator|=
operator|(
name|KBuffer
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|bhp
operator|-
name|BUF1_LG_HOFF
operator|)
expr_stmt|;
comment|/* 			 * Dequeue handle and free buffer 			 */
name|DEQUEUE
argument_list|(
name|bhp
argument_list|,
name|Buf_handle
argument_list|,
name|bh_qelem
argument_list|,
name|fup
operator|->
name|fu_buf1l_bq
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|DMA_FREE_ADDR
argument_list|(
name|cp
argument_list|,
name|bhp
operator|->
name|bh_dma
argument_list|,
name|BUF1_LG_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Free the status words 	 */
if|if
condition|(
name|fup
operator|->
name|fu_buf1s_stat
condition|)
block|{
if|if
condition|(
name|fup
operator|->
name|fu_buf1s_statd
condition|)
block|{
name|DMA_FREE_ADDR
argument_list|(
name|fup
operator|->
name|fu_buf1s_stat
argument_list|,
name|fup
operator|->
name|fu_buf1s_statd
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_status
argument_list|)
operator|*
operator|(
name|BUF1_SM_QUELEN
operator|+
name|BUF1_LG_QUELEN
operator|)
argument_list|,
name|ATM_DEV_NONCACHE
argument_list|)
expr_stmt|;
block|}
name|atm_dev_free
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|fup
operator|->
name|fu_buf1s_stat
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_buf1s_stat
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_buf1s_statd
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_stat
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_statd
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Free the transmit descriptors 	 */
if|if
condition|(
name|fup
operator|->
name|fu_buf1s_desc
condition|)
block|{
if|if
condition|(
name|fup
operator|->
name|fu_buf1s_descd
condition|)
block|{
name|DMA_FREE_ADDR
argument_list|(
name|fup
operator|->
name|fu_buf1s_desc
argument_list|,
name|fup
operator|->
name|fu_buf1s_descd
argument_list|,
sizeof|sizeof
argument_list|(
name|Buf_descr
argument_list|)
operator|*
operator|(
operator|(
name|BUF1_SM_QUELEN
operator|*
name|BUF1_SM_ENTSIZE
operator|)
operator|+
operator|(
name|BUF1_LG_QUELEN
operator|*
name|BUF1_LG_ENTSIZE
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atm_dev_free
argument_list|(
name|fup
operator|->
name|fu_buf1s_desc
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_buf1s_desc
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_buf1s_descd
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_desc
operator|=
name|NULL
expr_stmt|;
name|fup
operator|->
name|fu_buf1l_descd
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

