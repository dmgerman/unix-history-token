begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILING_LINT
end_ifdef

begin_warning
warning|#
directive|warning
literal|"The fore pci driver is broken and is not compiled with LINT"
end_warning

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Loadable kernel module and device identification support  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_aali.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_slave.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fore_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fore_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fore_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fore_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDPCI
end_ifndef

begin_error
error|#
directive|error
literal|"The fore device requires the old pci compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|fore_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|fore_pci_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|fore_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fore_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fore_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fore_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|fore_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fore_ident
name|fore_ident_table
index|[]
init|=
block|{
block|{
literal|0x0200
block|,
literal|"FORE Systems PCA-200 ATM ForeRunner"
block|}
block|,
block|{
literal|0x0210
block|,
literal|"FORE Systems PCA-200PC"
block|}
block|,
block|{
literal|0x0250
block|,
literal|"FORE Systems ATM"
block|}
block|,
block|{
literal|0x0300
block|,
literal|"FORE Systems PCA-200E"
block|}
block|,
block|{
literal|0x0310
block|,
literal|"FORE Systems ATM"
block|}
block|,
block|{
literal|0x0400
block|,
literal|"FORE Systems PCA-200HE ATM ForeRunner"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize driver processing  *   * This will be called during module loading.  Not much to do here, as  * we must wait for our identify/attach routines to get called before  * we know what we're in for.  *  * Arguments:  *	none  *  * Returns:  *	0 	startup was successful   *	errno	startup failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_start
parameter_list|()
block|{
comment|/* 	 * Verify software version 	 */
if|if
condition|(
name|atm_version
operator|!=
name|ATM_VERSION
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"version mismatch: fore=%d.%d kernel=%d.%d\n"
argument_list|,
name|ATM_VERS_MAJ
argument_list|(
name|ATM_VERSION
argument_list|)
argument_list|,
name|ATM_VERS_MIN
argument_list|(
name|ATM_VERSION
argument_list|)
argument_list|,
name|ATM_VERS_MAJ
argument_list|(
name|atm_version
argument_list|)
argument_list|,
name|ATM_VERS_MIN
argument_list|(
name|atm_version
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Initialize DMA mapping 	 */
name|DMA_INIT
argument_list|()
expr_stmt|;
comment|/* 	 * Start up watchdog timer 	 */
name|atm_timeout
argument_list|(
operator|&
name|fore_timer
argument_list|,
name|ATM_HZ
operator|*
name|FORE_TIME_TICK
argument_list|,
name|fore_timeout
argument_list|)
expr_stmt|;
name|fore_inited
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device probe routine  *   * Determine if this driver will support the identified device.  If we claim  * to support the device, our attach routine will (later) be called for the  * device.  */
end_comment

begin_function
specifier|static
name|int
name|fore_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fore_ident
modifier|*
name|ident
decl_stmt|;
name|u_int16_t
name|devid
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|FORE_VENDOR_ID
condition|)
block|{
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|ident
operator|=
name|fore_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
if|if
condition|(
name|ident
operator|->
name|devid
operator|==
name|devid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device attach routine  *   * Attach a device we've previously claimed to support.  Walk through its  * register set and map, as required.  Determine what level the device will  * be interrupting at and then register an interrupt handler for it.  If we  * succeed, then reset the adapter and initialize the microcode.  * Last, register the interface with the kernel ATM services.  *  * Arguments:  *	config_id	device's PCI configuration ID  *	unit		device unit number  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|fore_pci_attach
parameter_list|(
name|config_id
parameter_list|,
name|unit
parameter_list|)
name|pcici_t
name|config_id
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|pcidi_t
name|device_id
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|err_count
init|=
name|BOOT_LOOPS
decl_stmt|;
comment|/*  	 * Check that unit is not>= FORE_MAX_UNITS  	 */
comment|/* 	 * Make sure this isn't a duplicate unit 	 */
if|if
condition|(
name|fore_units
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * Allocate a new unit structure 	 */
name|fup
operator|=
operator|(
name|Fore_unit
operator|*
operator|)
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Fore_unit
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Start initializing it 	 */
name|fup
operator|->
name|fu_unit
operator|=
name|unit
expr_stmt|;
name|fup
operator|->
name|fu_mtu
operator|=
name|FORE_IFF_MTU
expr_stmt|;
name|fup
operator|->
name|fu_pcitag
operator|=
name|config_id
expr_stmt|;
name|fup
operator|->
name|fu_vcc_pool
operator|=
operator|&
name|fore_vcc_pool
expr_stmt|;
name|fup
operator|->
name|fu_nif_pool
operator|=
operator|&
name|fore_nif_pool
expr_stmt|;
name|fup
operator|->
name|fu_ioctl
operator|=
name|fore_atm_ioctl
expr_stmt|;
name|fup
operator|->
name|fu_instvcc
operator|=
name|fore_instvcc
expr_stmt|;
name|fup
operator|->
name|fu_openvcc
operator|=
name|fore_openvcc
expr_stmt|;
name|fup
operator|->
name|fu_closevcc
operator|=
name|fore_closevcc
expr_stmt|;
name|fup
operator|->
name|fu_output
operator|=
name|fore_output
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|fup
operator|->
name|fu_thandle
argument_list|)
expr_stmt|;
comment|/* 	 * Get our device type 	 */
name|device_id
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|device_id
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
condition|)
block|{
case|case
name|FORE_PCA200E_ID
case|:
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
operator|=
name|DEV_FORE_PCA200E
expr_stmt|;
break|break;
default|default:
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
operator|=
name|DEV_UNKNOWN
expr_stmt|;
block|}
comment|/* 	 * Enable Memory Mapping / Bus Mastering  	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Map RAM 	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: memory mapping not enabled\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
operator|(
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCA200E_PCI_MEMBASE
argument_list|,
operator|&
name|va
argument_list|,
operator|&
name|pa
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to map memory\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|fup
operator|->
name|fu_ram
operator|=
operator|(
name|Fore_mem
operator|*
operator|)
name|va
expr_stmt|;
name|fup
operator|->
name|fu_ramsize
operator|=
name|PCA200E_RAM_SIZE
expr_stmt|;
name|fup
operator|->
name|fu_mon
operator|=
operator|(
name|Mon960
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|MON960_BASE
operator|)
expr_stmt|;
name|fup
operator|->
name|fu_ctlreg
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
operator|(
name|va
operator|+
name|PCA200E_HCR_OFFSET
operator|)
expr_stmt|;
name|fup
operator|->
name|fu_imask
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
operator|(
name|va
operator|+
name|PCA200E_IMASK_OFFSET
operator|)
expr_stmt|;
name|fup
operator|->
name|fu_psr
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
operator|(
name|va
operator|+
name|PCA200E_PSR_OFFSET
operator|)
expr_stmt|;
comment|/* 	 * Convert Endianess of Slave RAM accesses 	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCA200E_PCI_MCTL
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCA200E_MCTL_SWAP
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCA200E_PCI_MCTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Map interrupt in 	 */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|fore_intr
argument_list|,
name|fup
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to map interrupt\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Poke the hardware - boot the CP and prepare it for downloading 	 */
name|fore_reset
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the monitor to perform self-test 	 */
while|while
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|!=
name|BOOT_MONREADY
condition|)
block|{
if|if
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|==
name|BOOT_FAILTEST
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: failed self-test\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
elseif|else
if|if
condition|(
operator|--
name|err_count
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to boot - status=0x%lx\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|,
operator|(
name|u_long
operator|)
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|DELAY
argument_list|(
name|BOOT_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the adapter config info - at least as much as we can 	 */
name|fup
operator|->
name|fu_config
operator|.
name|ac_vendor
operator|=
name|VENDOR_FORE
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_vendapi
operator|=
name|VENDAPI_FORE_1
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_media
operator|=
name|MEDIA_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_bustype
operator|=
name|BUS_PCI
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_busslot
operator|=
name|config_id
operator|->
name|bus
operator|<<
literal|8
operator||
name|config_id
operator|->
name|slot
expr_stmt|;
comment|/* 	 * Save device ram info for user-level programs 	 */
name|fup
operator|->
name|fu_config
operator|.
name|ac_ram
operator|=
operator|(
name|long
operator|)
name|fup
operator|->
name|fu_ram
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_ramsize
operator|=
name|fup
operator|->
name|fu_ramsize
expr_stmt|;
comment|/* 	 * Set device capabilities 	 */
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvpi
operator|=
name|FORE_MAX_VPI
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvci
operator|=
name|FORE_MAX_VCI
expr_stmt|;
comment|/* 	 * Register this interface with ATM core services 	 */
if|if
condition|(
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|fore_services
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Registration failed - back everything out 		 */
goto|goto
name|failed
goto|;
block|}
name|fore_units
index|[
name|unit
index|]
operator|=
name|fup
expr_stmt|;
name|fore_nunits
operator|++
expr_stmt|;
comment|/* 	 * Add hook to our shutdown function 	 */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|fore_pci_shutdown
argument_list|,
name|fup
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the CP microcode program. 	 */
name|fore_initialize
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return;
name|failed
label|:
comment|/* 	 * Unattach the device from the system 	 */
name|fore_unattach
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Free any Fore-specific device resources 	 */
name|fore_interface_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|atm_dev_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Device shutdown routine  *   * Arguments:  *	howto		type of shutdown  *	fup		pointer to device unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|fore_pci_shutdown
parameter_list|(
name|fup
parameter_list|,
name|howto
parameter_list|)
name|void
modifier|*
name|fup
decl_stmt|;
name|int
name|howto
decl_stmt|;
block|{
name|fore_reset
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Device unattach routine  *   * Reset the physical device, remove any pending timeouts,   * unmap any register sets, and unregister any interrupts.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_unattach
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
comment|/* 	 * Reset the board and return it to cold_start state. 	 * Hopefully, this will prevent use of resources as 	 * we're trying to free things up. 	 */
name|fore_reset
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Lock out all device interrupts 	 */
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Remove any pending timeout()'s 	 */
operator|(
name|void
operator|)
name|untimeout
argument_list|(
operator|(
name|KTimeout_ret
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|fore_initialize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fup
argument_list|,
name|fup
operator|->
name|fu_thandle
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap the device interrupt 	 */
operator|(
name|void
operator|)
name|pci_unmap_int
argument_list|(
name|fup
operator|->
name|fu_pcitag
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap memory 	 */
ifdef|#
directive|ifdef
name|notdef
operator|(
name|void
operator|)
name|pci_unmap_mem
argument_list|(
name|fup
operator|->
name|fu_pcitag
argument_list|,
name|PCA200E_PCI_MEMBASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device reset routine  *   * Reset the physical device  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_reset
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
comment|/* 	 * Reset the board and return it to cold_start state 	 */
if|if
condition|(
name|fup
operator|->
name|fu_mon
condition|)
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
operator|=
name|CP_WRITE
argument_list|(
name|BOOT_COLDSTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ctlreg
condition|)
block|{
if|if
condition|(
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
operator|==
name|DEV_FORE_PCA200E
condition|)
block|{
comment|/* 			 * Reset i960 by setting and clearing RESET 			 */
name|PCA200E_HCR_INIT
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|PCA200E_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|PCA200E_HCR_CLR
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|PCA200E_RESET
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ATM_LINKED
end_ifndef

begin_comment
comment|/*  *******************************************************************  *  * Loadable Module Support  *  *******************************************************************  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Driver entry points  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fore_cdev
init|=
block|{
comment|/* open */
name|noopen
block|,
comment|/* close */
name|noclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|noioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
name|noname
block|,
comment|/* maj */
operator|-
literal|1
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Loadable device driver module description  */
end_comment

begin_expr_stmt
name|MOD_DEV
argument_list|(
name|fore
argument_list|,
name|LM_DT_CHAR
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fore_cdev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Loadable module support "load" entry point  *   * This is the routine called by the lkm driver whenever the  * modload(1) command is issued for this module.  *  * Arguments:  *	lkmtp	pointer to lkm drivers's structure  *	cmd	lkm command code  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_load
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
return|return
operator|(
name|fore_doload
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadable module support "unload" entry point  *   * This is the routine called by the lkm driver whenever the  * modunload(1) command is issued for this module.  *  * Arguments:  *	lkmtp	pointer to lkm drivers's structure  *	cmd	lkm command code  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_unload
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
return|return
operator|(
name|fore_dounload
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadable module support entry point  *   * This is the routine called by the lkm driver for all loadable module  * functions for this driver.  This routine name must be specified  * on the modload(1) command.  This routine will be called whenever the  * modload(1), modunload(1) or modstat(1) commands are issued for this  * module.  *  * Arguments:  *	lkmtp	pointer to lkm drivers's structure  *	cmd	lkm command code  *	ver	lkm version  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
name|int
name|fore_mod
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|,
name|ver
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|ver
decl_stmt|;
block|{
name|DISPATCH
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|,
name|ver
argument_list|,
name|fore_load
argument_list|,
name|fore_unload
argument_list|,
name|lkm_nullcmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATM_LINKED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

