begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: fore_load.c,v 1.2 1998/09/17 09:34:59 phk Exp $  *  */
end_comment

begin_comment
comment|/*  * FORE Systems 200-Series Adapter Support  * ---------------------------------------  *  * Loadable kernel module and device identification support  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/hfa/fore_include.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $Id: fore_load.c,v 1.2 1998/09/17 09:34:59 phk Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local functions  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fore_start
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|fore_stop
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fore_doload
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fore_dounload
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fore_identify
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fore_attach
name|__P
argument_list|(
operator|(
expr|struct
name|devinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fore_pci_probe
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|pcidi_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fore_pci_attach
name|__P
argument_list|(
operator|(
name|pcici_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199506
end_if

begin_decl_stmt
specifier|static
name|int
name|fore_pci_shutdown
name|__P
argument_list|(
operator|(
expr|struct
name|kern_devconf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|fore_pci_shutdown
name|__P
argument_list|(
operator|(
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|fore_unattach
name|__P
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fore_reset
name|__P
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fore_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver entry points  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|dev_ops
name|fore_ops
init|=
block|{
literal|1
block|,
comment|/* revision */
name|fore_identify
block|,
comment|/* identify */
name|fore_attach
block|,
comment|/* attach */
name|NULL
block|,
comment|/* open */
name|NULL
block|,
comment|/* close */
name|NULL
block|,
comment|/* read */
name|NULL
block|,
comment|/* write */
name|NULL
block|,
comment|/* strategy */
name|NULL
block|,
comment|/* dump */
name|NULL
block|,
comment|/* psize */
name|NULL
block|,
comment|/* ioctl */
name|NULL
block|,
comment|/* reset */
name|NULL
comment|/* mmap */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|static
name|u_long
name|fore_pci_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|fore_pci_device
init|=
block|{
name|FORE_DEV_NAME
block|,
name|fore_pci_probe
block|,
name|fore_pci_attach
block|,
operator|&
name|fore_pci_count
block|,
if|#
directive|if
name|BSD
operator|<
literal|199506
name|fore_pci_shutdown
else|#
directive|else
name|NULL
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|fore_pci_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize driver processing  *   * This will be called during module loading.  Not much to do here, as  * we must wait for our identify/attach routines to get called before  * we know what we're in for.  *  * Arguments:  *	none  *  * Returns:  *	0 	startup was successful   *	errno	startup failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_start
parameter_list|()
block|{
comment|/* 	 * Verify software version 	 */
if|if
condition|(
name|atm_version
operator|!=
name|ATM_VERSION
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"version mismatch: fore=%d.%d kernel=%d.%d\n"
argument_list|,
name|ATM_VERS_MAJ
argument_list|(
name|ATM_VERSION
argument_list|)
argument_list|,
name|ATM_VERS_MIN
argument_list|(
name|ATM_VERSION
argument_list|)
argument_list|,
name|ATM_VERS_MAJ
argument_list|(
name|atm_version
argument_list|)
argument_list|,
name|ATM_VERS_MIN
argument_list|(
name|atm_version
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Initialize DMA mapping 	 */
name|DMA_INIT
argument_list|()
expr_stmt|;
comment|/* 	 * Start up watchdog timer 	 */
name|atm_timeout
argument_list|(
operator|&
name|fore_timer
argument_list|,
name|ATM_HZ
operator|*
name|FORE_TIME_TICK
argument_list|,
name|fore_timeout
argument_list|)
expr_stmt|;
name|fore_inited
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_comment
comment|/*  * Halt driver processing   *   * This will be called just prior to unloading the module from memory.  * Everything we've setup since we've been loaded must be undone here.  *  * Arguments:  *	none  *  * Returns:  *	0 	shutdown was successful   *	errno	shutdown failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_stop
parameter_list|()
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Stop the watchdog timer 	 */
operator|(
name|void
operator|)
name|atm_untimeout
argument_list|(
operator|&
name|fore_timer
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up each device (if any) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fore_nunits
condition|;
name|i
operator|++
control|)
block|{
name|Fore_unit
modifier|*
name|fup
init|=
name|fore_units
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fup
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Deregister device from kernel services 		 */
if|if
condition|(
name|err
operator|=
name|atm_physif_deregister
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 		 * Unattach the device from the system 		 */
name|fore_unattach
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 		 * Free any Fore-specific device resources 		 */
name|fore_interface_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 		 * Free the unit structure 		 */
name|atm_dev_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|fore_units
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|fore_nunits
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now free our global resources 	 */
comment|/* 	 * Release our storage pools 	 */
name|atm_release_pool
argument_list|(
operator|&
name|fore_vcc_pool
argument_list|)
expr_stmt|;
name|atm_release_pool
argument_list|(
operator|&
name|fore_nif_pool
argument_list|)
expr_stmt|;
comment|/* 	 * Release all DMA mappings 	 */
name|DMA_RELEASE
argument_list|()
expr_stmt|;
name|fore_inited
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device identify routine  *   * Determine if this driver will support the named device.  If we claim to  * support the device, our attach routine will (later) be called for the  * device.  *  * Arguments:  *	name	pointer to identifier string from device  *  * Returns:  *	1 	driver claims support for this device  *	0	device not claimed by this driver  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_identify
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* 	 * Initialize driver stuff 	 */
if|if
condition|(
name|fore_inited
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fore_start
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|fore_devices
index|[
name|i
index|]
operator|.
name|fd_name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fore_devices
index|[
name|i
index|]
operator|.
name|fd_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We support this device!! 			 */
if|if
condition|(
name|fore_nunits
operator|<
name|FORE_MAX_UNITS
condition|)
block|{
name|fore_nunits
operator|++
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_identify: Too many devices\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device attach routine  *   * Attach a device we've previously claimed to support.  Walk through its  * register set and map, as required.  Determine what level the device will  * be interrupting at and then register an interrupt handler for it.  If we  * succeed, then reset the adapter and read useful info from its PROM.  * Last, register the interface with the kernel ATM services.  *  * Arguments:  *	devinfo_p	pointer to device information structure  *  * Returns:  *	0 	attach was successful  *	-1	attach failed  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_attach
parameter_list|(
name|devinfo_p
parameter_list|)
name|struct
name|dev_info
modifier|*
name|devinfo_p
decl_stmt|;
block|{
name|struct
name|dev_reg
modifier|*
name|dev_reg_p
decl_stmt|;
name|struct
name|dev_intr
modifier|*
name|dev_intr_p
decl_stmt|;
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|Atm_config
modifier|*
name|fcp
decl_stmt|;
name|addr_t
name|valp
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err_count
init|=
name|BOOT_LOOPS
decl_stmt|;
specifier|static
name|int
name|unit
init|=
literal|0
decl_stmt|;
comment|/* 	 * Sanity check 	 */
if|if
condition|(
name|devinfo_p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Make sure this isn't a duplicate unit 	 */
if|if
condition|(
name|fore_units
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Allocate a new unit structure 	 */
name|fup
operator|=
operator|(
name|Fore_unit
operator|*
operator|)
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Fore_unit
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Start initializing it 	 */
name|fup
operator|->
name|fu_unit
operator|=
name|unit
expr_stmt|;
name|fup
operator|->
name|fu_mtu
operator|=
name|FORE_IFF_MTU
expr_stmt|;
name|fup
operator|->
name|fu_devinfo
operator|=
name|devinfo_p
expr_stmt|;
name|fup
operator|->
name|fu_vcc_pool
operator|=
operator|&
name|fore_vcc_pool
expr_stmt|;
name|fup
operator|->
name|fu_nif_pool
operator|=
operator|&
name|fore_nif_pool
expr_stmt|;
name|fup
operator|->
name|fu_ioctl
operator|=
name|fore_atm_ioctl
expr_stmt|;
name|fup
operator|->
name|fu_instvcc
operator|=
name|fore_instvcc
expr_stmt|;
name|fup
operator|->
name|fu_openvcc
operator|=
name|fore_openvcc
expr_stmt|;
name|fup
operator|->
name|fu_closevcc
operator|=
name|fore_closevcc
expr_stmt|;
name|fup
operator|->
name|fu_output
operator|=
name|fore_output
expr_stmt|;
comment|/* 	 * Consider this unit assigned 	 */
name|fore_units
index|[
name|unit
index|]
operator|=
name|fup
expr_stmt|;
name|unit
operator|++
expr_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"fore_attach: fup=%p\n"
argument_list|,
name|fup
argument_list|)
expr_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"\tfu_xmit_q=%p fu_xmit_head=%p\n"
argument_list|,
name|fup
operator|->
name|fu_xmit_q
argument_list|,
operator|&
name|fup
operator|->
name|fu_xmit_head
argument_list|)
expr_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"\tfu_recv_q=%p fu_recv_head=%p\n"
argument_list|,
name|fup
operator|->
name|fu_recv_q
argument_list|,
operator|&
name|fup
operator|->
name|fu_recv_head
argument_list|)
expr_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"\tfu_buf1s_q=%p fu_buf1s_head=%p\n"
argument_list|,
name|fup
operator|->
name|fu_buf1s_q
argument_list|,
operator|&
name|fup
operator|->
name|fu_buf1s_head
argument_list|)
expr_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"\tfu_buf1l_q=%p fu_buf1l_head=%p\n"
argument_list|,
name|fup
operator|->
name|fu_buf1l_q
argument_list|,
operator|&
name|fup
operator|->
name|fu_buf1l_head
argument_list|)
expr_stmt|;
name|ATM_DEBUG2
argument_list|(
literal|"\tfu_cmd_q=%p fu_cmd_head=%p\n"
argument_list|,
name|fup
operator|->
name|fu_cmd_q
argument_list|,
operator|&
name|fup
operator|->
name|fu_cmd_head
argument_list|)
expr_stmt|;
name|ATM_DEBUG1
argument_list|(
literal|"\tfu_stats=%p\n"
argument_list|,
operator|&
name|fup
operator|->
name|fu_stats
argument_list|)
expr_stmt|;
comment|/* 	 * Tell kernel our unit number 	 */
name|devinfo_p
operator|->
name|devi_unit
operator|=
name|fup
operator|->
name|fu_unit
expr_stmt|;
comment|/* 	 * Figure out what type of device we've got.  This should always 	 * work since we've already done this at identify time! 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fore_devices
index|[
name|i
index|]
operator|.
name|fd_name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fore_devices
index|[
name|i
index|]
operator|.
name|fd_name
argument_list|,
name|devinfo_p
operator|->
name|devi_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fore_devices
index|[
name|i
index|]
operator|.
name|fd_name
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
operator|=
name|fore_devices
index|[
name|i
index|]
operator|.
name|fd_devtyp
expr_stmt|;
comment|/* 	 * Walk through the OPENPROM register information 	 * mapping register banks as they are found. 	 */
for|for
control|(
name|dev_reg_p
operator|=
name|devinfo_p
operator|->
name|devi_reg
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|devinfo_p
operator|->
name|devi_nreg
condition|;
name|i
operator|++
operator|,
operator|++
name|dev_reg_p
control|)
block|{
if|if
condition|(
name|dev_reg_p
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Can't happen... 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Each device type has different register sets 		 */
switch|switch
condition|(
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
condition|)
block|{
ifdef|#
directive|ifdef
name|FORE_SBUS
case|case
name|DEV_FORE_SBA200E
case|:
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* 			 * Host Control Register (HCR) 			 */
case|case
literal|1
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
operator|!=
name|dev_reg_p
operator|->
name|reg_size
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_ctlreg
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
name|map_regs
argument_list|(
name|dev_reg_p
operator|->
name|reg_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
argument_list|,
name|dev_reg_p
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ctlreg
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
comment|/* 			 * SBus Burst Transfer Configuration Register 			 */
case|case
literal|2
case|:
comment|/* 				 * Not used 				 */
break|break;
comment|/* 			 * SBus Interrupt Level Select Register 			 */
case|case
literal|3
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
operator|!=
name|dev_reg_p
operator|->
name|reg_size
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_intlvl
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
name|map_regs
argument_list|(
name|dev_reg_p
operator|->
name|reg_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
argument_list|,
name|dev_reg_p
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_intlvl
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
comment|/* 			 * i960 RAM 			 */
case|case
literal|4
case|:
name|fup
operator|->
name|fu_ram
operator|=
operator|(
name|Fore_mem
operator|*
operator|)
name|map_regs
argument_list|(
name|dev_reg_p
operator|->
name|reg_addr
argument_list|,
name|dev_reg_p
operator|->
name|reg_size
argument_list|,
name|dev_reg_p
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ram
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_ramsize
operator|=
name|dev_reg_p
operator|->
name|reg_size
expr_stmt|;
comment|/* 				 * Various versions of the Sun PROM mess with  				 * the reg_addr value in unpredictable (to me, 				 * at least) ways, so just use the "memoffset" 				 * property, which should give us the RAM  				 * offset directly. 				 */
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"memoffset"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_config
operator|.
name|ac_ram
operator|=
name|val
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_ramsize
operator|=
name|fup
operator|->
name|fu_ramsize
expr_stmt|;
comment|/* 				 * Set monitor interface for initializing 				 */
name|fup
operator|->
name|fu_mon
operator|=
operator|(
name|Mon960
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|MON960_BASE
operator|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_attach: Too many registers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|DEV_FORE_SBA200
case|:
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* 			 * Board Control Register (BCR) 			 */
case|case
literal|1
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
operator|!=
name|dev_reg_p
operator|->
name|reg_size
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_ctlreg
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
name|map_regs
argument_list|(
name|dev_reg_p
operator|->
name|reg_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
argument_list|,
name|dev_reg_p
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ctlreg
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
comment|/* 			 * i960 RAM 			 */
case|case
literal|2
case|:
name|fup
operator|->
name|fu_ram
operator|=
operator|(
name|Fore_mem
operator|*
operator|)
name|map_regs
argument_list|(
name|dev_reg_p
operator|->
name|reg_addr
argument_list|,
name|dev_reg_p
operator|->
name|reg_size
argument_list|,
name|dev_reg_p
operator|->
name|reg_bustype
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ram
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_ramsize
operator|=
name|dev_reg_p
operator|->
name|reg_size
expr_stmt|;
comment|/* 				 * Various versions of the Sun PROM mess with  				 * the reg_addr value in unpredictable (to me, 				 * at least) ways, so just use the "memoffset" 				 * property, which should give us the RAM  				 * offset directly. 				 */
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"memoffset"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fup
operator|->
name|fu_config
operator|.
name|ac_ram
operator|=
name|val
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_ramsize
operator|=
name|fup
operator|->
name|fu_ramsize
expr_stmt|;
comment|/* 				 * Set monitor interface for initializing 				 */
name|fup
operator|->
name|fu_mon
operator|=
operator|(
name|Mon960
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|MON960_BASE
operator|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_attach: Too many registers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* FORE_SBUS */
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_attach: Unsupported device type %d\n"
argument_list|,
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Install the device in the interrupt chain. 	 * 	 * dev_intr_p may be null IFF devi_nintr is zero. 	 */
name|dev_intr_p
operator|=
name|devinfo_p
operator|->
name|devi_intr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo_p
operator|->
name|devi_nintr
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|dev_intr_p
control|)
block|{
if|if
condition|(
name|dev_intr_p
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Can't happen. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Convert hardware ipl (0-15) into spl level. 		 */
if|if
condition|(
name|ipltospl
argument_list|(
name|dev_intr_p
operator|->
name|int_pri
argument_list|)
operator|>
name|fup
operator|->
name|fu_intrpri
condition|)
block|{
name|fup
operator|->
name|fu_intrpri
operator|=
name|ipltospl
argument_list|(
name|dev_intr_p
operator|->
name|int_pri
argument_list|)
expr_stmt|;
comment|/* 			 * If SBA-200E card, set SBus interrupt level 			 * into board register 			 */
if|if
condition|(
name|fup
operator|->
name|fu_intlvl
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun4c
argument_list|)
operator|*
operator|(
name|fup
operator|->
name|fu_intlvl
operator|)
operator|=
name|dev_intr_p
operator|->
name|int_pri
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|sun4m
argument_list|)
specifier|extern
name|int
name|svimap
index|[]
decl_stmt|;
operator|*
operator|(
name|fup
operator|->
name|fu_intlvl
operator|)
operator|=
name|svimap
index|[
name|dev_intr_p
operator|->
name|int_pri
operator|&
literal|0xf
index|]
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|PORT ME;
endif|#
directive|endif
block|}
block|}
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 		 * Register our interrupt routine. 		 */
operator|(
name|void
operator|)
name|addintr
argument_list|(
name|dev_intr_p
operator|->
name|int_pri
argument_list|,
name|fore_poll
argument_list|,
name|devinfo_p
operator|->
name|devi_name
argument_list|,
name|devinfo_p
operator|->
name|devi_unit
argument_list|)
expr_stmt|;
comment|/* 		 * If we can do DMA (we can), then DVMA routines need 		 * to know the highest IPL level we will interrupt at. 		 */
name|adddma
argument_list|(
name|dev_intr_p
operator|->
name|int_pri
argument_list|)
expr_stmt|;
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Poke the hardware...boot the CP and prepare it for downloading 	 */
name|fore_reset
argument_list|(
name|fup
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
condition|)
block|{
ifdef|#
directive|ifdef
name|FORE_SBUS
case|case
name|DEV_FORE_SBA200E
case|:
comment|/* 		 * Enable interrupts 		 */
name|SBA200E_HCR_SET
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|SBA200E_SBUS_ENA
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FORE_SBUS */
block|}
comment|/* 	 * Wait for monitor to perform self-test 	 */
while|while
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|!=
name|BOOT_MONREADY
condition|)
block|{
if|if
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|==
name|BOOT_FAILTEST
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_attach: Unit %d failed self-test\n"
argument_list|,
name|fup
operator|->
name|fu_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|--
name|err_count
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_attach: Unit %d unable to boot\n"
argument_list|,
name|fup
operator|->
name|fu_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
name|BOOT_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write a one line message to the console informing 	 * that we've attached the device. 	 */
name|report_dev
argument_list|(
name|devinfo_p
argument_list|)
expr_stmt|;
comment|/* 	 * Get the mac address from the card PROM 	 */
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddress1"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|-
literal|1
condition|)
block|{
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|0
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddress2"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|1
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddress3"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|2
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddress4"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|3
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddress5"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|4
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddress6"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|5
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Newer PROM - mac addresses have been combined. Also, 		 * macaddrlo2 reflects the board serial number. 		 */
name|val
operator|=
name|htonl
argument_list|(
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddrlo2"
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|KM_COPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|val
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|htonl
argument_list|(
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"macaddrhi4"
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|KM_COPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|val
argument_list|,
operator|(
name|caddr_t
operator|)
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
operator|.
name|ma_data
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the adapter config info 	 */
name|fcp
operator|=
operator|&
name|fup
operator|->
name|fu_config
expr_stmt|;
name|fcp
operator|->
name|ac_vendor
operator|=
name|VENDOR_FORE
expr_stmt|;
name|fcp
operator|->
name|ac_vendapi
operator|=
name|VENDAPI_FORE_1
expr_stmt|;
name|fcp
operator|->
name|ac_macaddr
operator|=
name|fup
operator|->
name|fu_pif
operator|.
name|pif_macaddr
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"promversion"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"hw-version"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|fcp
operator|->
name|ac_hard_vers
argument_list|,
literal|"%d.%d.%d"
argument_list|,
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|fcp
operator|->
name|ac_hard_vers
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"serialnumber"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|-
literal|1
condition|)
name|fcp
operator|->
name|ac_serial
operator|=
name|val
expr_stmt|;
name|valp
operator|=
operator|(
name|addr_t
operator|)
name|getlongprop
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"model"
argument_list|)
expr_stmt|;
if|if
condition|(
name|valp
condition|)
block|{
comment|/* 		 * Media Type 		 */
switch|switch
condition|(
name|fcp
operator|->
name|ac_device
condition|)
block|{
ifdef|#
directive|ifdef
name|FORE_SBUS
case|case
name|DEV_FORE_SBA200E
case|:
name|fcp
operator|->
name|ac_media
operator|=
name|MEDIA_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
break|break;
case|case
name|DEV_FORE_SBA200
case|:
comment|/* 			 * Look at the /SSS trailer to determine 4B5B speed 			 * 	TAXI-100 = 125; TAXI-140 = 175 			 * Assume that OC3 has no /SSS speed identifier. 			 */
while|while
condition|(
operator|*
name|valp
operator|&&
operator|*
name|valp
operator|!=
literal|'/'
condition|)
name|valp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|valp
operator|==
name|NULL
condition|)
block|{
name|fcp
operator|->
name|ac_media
operator|=
name|MEDIA_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|valp
argument_list|,
literal|"/125"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fcp
operator|->
name|ac_media
operator|=
name|MEDIA_TAXI_100
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_TAXI100
expr_stmt|;
block|}
else|else
block|{
name|fcp
operator|->
name|ac_media
operator|=
name|MEDIA_TAXI_140
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_TAXI140
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* FORE_SBUS */
block|}
comment|/* 		 * Free property space 		 */
name|KM_FREE
argument_list|(
name|valp
argument_list|,
name|getproplen
argument_list|(
name|devinfo_p
operator|->
name|devi_nodeid
argument_list|,
literal|"model"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Bus information 	 */
name|fcp
operator|->
name|ac_busslot
operator|=
ifdef|#
directive|ifdef
name|SBUS_SIZE
call|(
name|long
call|)
argument_list|(
name|devinfo_p
operator|->
name|devi_reg
operator|->
name|reg_addr
operator|-
name|SBUS_BASE
argument_list|)
operator|/
name|SBUS_SIZE
expr_stmt|;
else|#
directive|else
name|sbusslot
argument_list|(
operator|(
name|u_long
operator|)
name|devinfo_p
operator|->
name|devi_reg
operator|->
name|reg_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|getprop
argument_list|(
name|devinfo_p
operator|->
name|devi_parent
operator|->
name|devi_nodeid
argument_list|,
literal|"burst-sizes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SBUS_BURST32
condition|)
name|fcp
operator|->
name|ac_bustype
operator|=
name|BUS_SBUS_B32
expr_stmt|;
else|else
name|fcp
operator|->
name|ac_bustype
operator|=
name|BUS_SBUS_B16
expr_stmt|;
comment|/* 	 * Set device capabilities 	 */
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvpi
operator|=
name|FORE_MAX_VPI
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvci
operator|=
name|FORE_MAX_VCI
expr_stmt|;
comment|/* 	 * Register this interface with ATM core services 	 */
if|if
condition|(
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|fore_services
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Registration failed - back everything out 		 */
comment|/* 		 * Modload calls UNLOAD if it get's a failure - don't 		 * call fore_unload() here. 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Initialize the CP microcode program. 	 */
name|fore_initialize
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * Device probe routine  *   * Determine if this driver will support the identified device.  If we claim  * to support the device, our attach routine will (later) be called for the  * device.  *  * Arguments:  *	config_id	device's PCI configuration ID  *	device_id	device's PCI Vendor/Device ID  *  * Returns:  *	name 	device identification string  *	NULL	device not claimed by this driver  *  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fore_pci_probe
parameter_list|(
name|config_id
parameter_list|,
name|device_id
parameter_list|)
name|pcici_t
name|config_id
decl_stmt|;
name|pcidi_t
name|device_id
decl_stmt|;
block|{
comment|/* 	 * Initialize driver stuff 	 */
if|if
condition|(
name|fore_inited
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fore_start
argument_list|()
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|device_id
operator|&
literal|0xffff
operator|)
operator|!=
name|FORE_VENDOR_ID
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|device_id
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|==
name|FORE_PCA200E_ID
condition|)
return|return
operator|(
literal|"FORE Systems PCA-200E ATM"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device attach routine  *   * Attach a device we've previously claimed to support.  Walk through its  * register set and map, as required.  Determine what level the device will  * be interrupting at and then register an interrupt handler for it.  If we  * succeed, then reset the adapter and initialize the microcode.  * Last, register the interface with the kernel ATM services.  *  * Arguments:  *	config_id	device's PCI configuration ID  *	unit		device unit number  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|fore_pci_attach
parameter_list|(
name|config_id
parameter_list|,
name|unit
parameter_list|)
name|pcici_t
name|config_id
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|pcidi_t
name|device_id
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|err_count
init|=
name|BOOT_LOOPS
decl_stmt|;
comment|/* 	 * Just checking... 	 */
if|if
condition|(
name|unit
operator|>=
name|FORE_MAX_UNITS
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: too many devices\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure this isn't a duplicate unit 	 */
if|if
condition|(
name|fore_units
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * Allocate a new unit structure 	 */
name|fup
operator|=
operator|(
name|Fore_unit
operator|*
operator|)
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Fore_unit
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Start initializing it 	 */
name|fup
operator|->
name|fu_unit
operator|=
name|unit
expr_stmt|;
name|fup
operator|->
name|fu_mtu
operator|=
name|FORE_IFF_MTU
expr_stmt|;
name|fup
operator|->
name|fu_pcitag
operator|=
name|config_id
expr_stmt|;
name|fup
operator|->
name|fu_vcc_pool
operator|=
operator|&
name|fore_vcc_pool
expr_stmt|;
name|fup
operator|->
name|fu_nif_pool
operator|=
operator|&
name|fore_nif_pool
expr_stmt|;
name|fup
operator|->
name|fu_ioctl
operator|=
name|fore_atm_ioctl
expr_stmt|;
name|fup
operator|->
name|fu_instvcc
operator|=
name|fore_instvcc
expr_stmt|;
name|fup
operator|->
name|fu_openvcc
operator|=
name|fore_openvcc
expr_stmt|;
name|fup
operator|->
name|fu_closevcc
operator|=
name|fore_closevcc
expr_stmt|;
name|fup
operator|->
name|fu_output
operator|=
name|fore_output
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|fup
operator|->
name|fu_thandle
argument_list|)
expr_stmt|;
comment|/* 	 * Get our device type 	 */
name|device_id
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|device_id
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
condition|)
block|{
case|case
name|FORE_PCA200E_ID
case|:
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
operator|=
name|DEV_FORE_PCA200E
expr_stmt|;
break|break;
default|default:
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
operator|=
name|DEV_UNKNOWN
expr_stmt|;
block|}
comment|/* 	 * Map RAM 	 */
if|if
condition|(
operator|(
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCA200E_PCI_MEMBASE
argument_list|,
operator|&
name|va
argument_list|,
operator|&
name|pa
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to map memory\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|fup
operator|->
name|fu_ram
operator|=
operator|(
name|Fore_mem
operator|*
operator|)
name|va
expr_stmt|;
name|fup
operator|->
name|fu_ramsize
operator|=
name|PCA200E_RAM_SIZE
expr_stmt|;
name|fup
operator|->
name|fu_mon
operator|=
operator|(
name|Mon960
operator|*
operator|)
operator|(
name|fup
operator|->
name|fu_ram
operator|+
name|MON960_BASE
operator|)
expr_stmt|;
name|fup
operator|->
name|fu_ctlreg
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
operator|(
name|va
operator|+
name|PCA200E_HCR_OFFSET
operator|)
expr_stmt|;
name|fup
operator|->
name|fu_imask
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
operator|(
name|va
operator|+
name|PCA200E_IMASK_OFFSET
operator|)
expr_stmt|;
name|fup
operator|->
name|fu_psr
operator|=
operator|(
name|Fore_reg
operator|*
operator|)
operator|(
name|va
operator|+
name|PCA200E_PSR_OFFSET
operator|)
expr_stmt|;
comment|/* 	 * Convert Endianess of Slave RAM accesses 	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCA200E_PCI_MCTL
argument_list|)
expr_stmt|;
name|val
operator||=
name|PCA200E_MCTL_SWAP
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCA200E_PCI_MCTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Map interrupt in 	 */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|fore_intr
argument_list|,
name|fup
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to map interrupt\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Poke the hardware - boot the CP and prepare it for downloading 	 */
name|fore_reset
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the monitor to perform self-test 	 */
while|while
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|!=
name|BOOT_MONREADY
condition|)
block|{
if|if
condition|(
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
operator|==
name|BOOT_FAILTEST
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: failed self-test\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
elseif|else
if|if
condition|(
operator|--
name|err_count
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to boot - status=0x%lx\n"
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|unit
argument_list|,
name|CP_READ
argument_list|(
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|DELAY
argument_list|(
name|BOOT_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup the adapter config info - at least as much as we can 	 */
name|fup
operator|->
name|fu_config
operator|.
name|ac_vendor
operator|=
name|VENDOR_FORE
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_vendapi
operator|=
name|VENDAPI_FORE_1
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_media
operator|=
name|MEDIA_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_bustype
operator|=
name|BUS_PCI
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_busslot
operator|=
name|config_id
operator|->
name|bus
operator|<<
literal|8
operator||
name|config_id
operator|->
name|slot
expr_stmt|;
comment|/* 	 * Save device ram info for user-level programs 	 */
name|fup
operator|->
name|fu_config
operator|.
name|ac_ram
operator|=
operator|(
name|long
operator|)
name|fup
operator|->
name|fu_ram
expr_stmt|;
name|fup
operator|->
name|fu_config
operator|.
name|ac_ramsize
operator|=
name|fup
operator|->
name|fu_ramsize
expr_stmt|;
comment|/* 	 * Set device capabilities 	 */
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvpi
operator|=
name|FORE_MAX_VPI
expr_stmt|;
name|fup
operator|->
name|fu_pif
operator|.
name|pif_maxvci
operator|=
name|FORE_MAX_VCI
expr_stmt|;
comment|/* 	 * Register this interface with ATM core services 	 */
if|if
condition|(
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|,
name|FORE_DEV_NAME
argument_list|,
name|fore_services
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Registration failed - back everything out 		 */
goto|goto
name|failed
goto|;
block|}
name|fore_units
index|[
name|unit
index|]
operator|=
name|fup
expr_stmt|;
name|fore_nunits
operator|++
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199506
comment|/* 	 * Add hook to our shutdown function 	 */
name|at_shutdown
argument_list|(
name|fore_pci_shutdown
argument_list|,
name|fup
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize the CP microcode program. 	 */
name|fore_initialize
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return;
name|failed
label|:
comment|/* 	 * Unattach the device from the system 	 */
name|fore_unattach
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Free any Fore-specific device resources 	 */
name|fore_interface_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
name|atm_dev_free
argument_list|(
name|fup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199506
end_if

begin_comment
comment|/*  * Device shutdown routine  *   * Arguments:  *	kdc		pointer to device's configuration table  *	force		forced shutdown flag  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_pci_shutdown
parameter_list|(
name|kdc
parameter_list|,
name|force
parameter_list|)
name|struct
name|kern_devconf
modifier|*
name|kdc
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
if|if
condition|(
name|kdc
operator|->
name|kdc_unit
operator|<
name|fore_nunits
condition|)
block|{
name|fup
operator|=
name|fore_units
index|[
name|kdc
operator|->
name|kdc_unit
index|]
expr_stmt|;
if|if
condition|(
name|fup
operator|!=
name|NULL
condition|)
block|{
name|fore_reset
argument_list|(
name|fup
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Device shutdown routine  *   * Arguments:  *	howto		type of shutdown  *	fup		pointer to device unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|fore_pci_shutdown
parameter_list|(
name|howto
parameter_list|,
name|fup
parameter_list|)
name|int
name|howto
decl_stmt|;
name|void
modifier|*
name|fup
decl_stmt|;
block|{
name|fore_reset
argument_list|(
operator|(
name|Fore_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD< 199506 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*  * Device unattach routine  *   * Reset the physical device, remove any pending timeouts,   * unmap any register sets, and unregister any interrupts.  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_unattach
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|sun
name|struct
name|dev_info
modifier|*
name|devinfo_p
init|=
name|fup
operator|->
name|fu_devinfo
decl_stmt|;
name|struct
name|dev_reg
modifier|*
name|dev_reg_p
decl_stmt|;
name|struct
name|dev_intr
modifier|*
name|dev_intr_p
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Reset the board and return it to cold_start state. 	 * Hopefully, this will prevent use of resources as 	 * we're trying to free things up. 	 */
name|fore_reset
argument_list|(
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Lock out all device interrupts 	 */
name|DEVICE_LOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
comment|/* 	 * Remove any pending timeout()'s 	 */
operator|(
name|void
operator|)
name|untimeout
argument_list|(
operator|(
name|KTimeout_ret
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|fore_initialize
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fup
argument_list|,
name|fup
operator|->
name|fu_thandle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
comment|/* 	 * Remove any mappings of the device 	 */
for|for
control|(
name|dev_reg_p
operator|=
name|devinfo_p
operator|->
name|devi_reg
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|devinfo_p
operator|->
name|devi_nreg
condition|;
name|i
operator|++
operator|,
operator|++
name|dev_reg_p
control|)
block|{
if|if
condition|(
name|dev_reg_p
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Can't happen... 			 */
break|break;
block|}
comment|/* 		 * Each device type has different register sets 		 */
switch|switch
condition|(
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
condition|)
block|{
ifdef|#
directive|ifdef
name|FORE_SBUS
case|case
name|DEV_FORE_SBA200E
case|:
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* 			 * Host Control Register (HCR) 			 */
case|case
literal|1
case|:
name|unmap_regs
argument_list|(
operator|(
name|addr_t
operator|)
name|fup
operator|->
name|fu_ctlreg
argument_list|,
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * SBus Burst Transfer Configuration Register 			 */
case|case
literal|2
case|:
comment|/* 				 * Not used 				 */
break|break;
comment|/* 			 * SBus Interrupt Level Select Register 			 */
case|case
literal|3
case|:
name|unmap_regs
argument_list|(
operator|(
name|addr_t
operator|)
name|fup
operator|->
name|fu_intlvl
argument_list|,
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * i960 RAM 			 */
case|case
literal|4
case|:
name|unmap_regs
argument_list|(
operator|(
name|addr_t
operator|)
name|fup
operator|->
name|fu_ram
argument_list|,
name|fup
operator|->
name|fu_ramsize
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DEV_FORE_SBA200
case|:
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* 			 * Board Control Register (BCR) 			 */
case|case
literal|1
case|:
name|unmap_regs
argument_list|(
operator|(
name|addr_t
operator|)
name|fup
operator|->
name|fu_ctlreg
argument_list|,
sizeof|sizeof
argument_list|(
name|Fore_reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * i960 RAM 			 */
case|case
literal|2
case|:
name|unmap_regs
argument_list|(
operator|(
name|addr_t
operator|)
name|fup
operator|->
name|fu_ram
argument_list|,
name|fup
operator|->
name|fu_ramsize
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
comment|/* FORE_SBUS */
block|}
block|}
comment|/* 	 * Remove the interrupt vector(s) 	 */
name|dev_intr_p
operator|=
name|devinfo_p
operator|->
name|devi_intr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo_p
operator|->
name|devi_nintr
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|dev_intr_p
control|)
block|{
if|if
condition|(
name|dev_intr_p
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Can't happen... 			 */
break|break;
block|}
operator|(
name|void
operator|)
name|remintr
argument_list|(
name|dev_intr_p
operator|->
name|int_pri
argument_list|,
name|fore_poll
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* sun */
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * Unmap the device interrupt 	 */
operator|(
name|void
operator|)
name|pci_unmap_int
argument_list|(
name|fup
operator|->
name|fu_pcitag
argument_list|)
expr_stmt|;
comment|/* 	 * Unmap memory 	 */
ifdef|#
directive|ifdef
name|notdef
operator|(
name|void
operator|)
name|pci_unmap_mem
argument_list|(
name|fup
operator|->
name|fu_pcitag
argument_list|,
name|PCA200E_PCI_MEMBASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __FreeBSD__ */
name|DEVICE_UNLOCK
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|fup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device reset routine  *   * Reset the physical device  *  * Arguments:  *	fup		pointer to device unit structure  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|fore_reset
parameter_list|(
name|fup
parameter_list|)
name|Fore_unit
modifier|*
name|fup
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
comment|/* 	 * Reset the board and return it to cold_start state 	 */
if|if
condition|(
name|fup
operator|->
name|fu_mon
condition|)
name|fup
operator|->
name|fu_mon
operator|->
name|mon_bstat
operator|=
name|CP_WRITE
argument_list|(
name|BOOT_COLDSTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|fup
operator|->
name|fu_ctlreg
condition|)
block|{
switch|switch
condition|(
name|fup
operator|->
name|fu_config
operator|.
name|ac_device
condition|)
block|{
ifdef|#
directive|ifdef
name|FORE_SBUS
case|case
name|DEV_FORE_SBA200E
case|:
comment|/* 			 * Reset i960 by setting and clearing RESET 			 */
name|SBA200E_HCR_INIT
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|SBA200E_RESET
argument_list|)
expr_stmt|;
name|SBA200E_HCR_CLR
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|SBA200E_RESET
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEV_FORE_SBA200
case|:
comment|/* 			 * Reset i960 by setting and clearing RESET 			 * 			 * SBA200 will NOT reset if bit is OR'd in! 			 */
operator|*
name|fup
operator|->
name|fu_ctlreg
operator|=
name|SBA200_RESET
expr_stmt|;
operator|*
name|fup
operator|->
name|fu_ctlreg
operator|=
name|SBA200_RESET_CLR
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FORE_SBUS */
ifdef|#
directive|ifdef
name|FORE_PCI
case|case
name|DEV_FORE_PCA200E
case|:
comment|/* 			 * Reset i960 by setting and clearing RESET 			 */
name|PCA200E_HCR_INIT
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|PCA200E_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|PCA200E_HCR_CLR
argument_list|(
operator|*
name|fup
operator|->
name|fu_ctlreg
argument_list|,
name|PCA200E_RESET
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ATM_LINKED
end_ifndef

begin_comment
comment|/*  *******************************************************************  *  * Loadable Module Support  *  *******************************************************************  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_comment
comment|/*  * Generic module load processing  *   * This function is called by an OS-specific function when this  * module is being loaded.  *  * Arguments:  *	none  *  * Returns:  *	0 	load was successful   *	errno	load failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_doload
parameter_list|()
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Start us up 	 */
name|err
operator|=
name|fore_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
comment|/* Problems, clean up */
operator|(
name|void
operator|)
name|fore_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic module unload processing  *   * This function is called by an OS-specific function when this  * module is being unloaded.  *  * Arguments:  *	none  *  * Returns:  *	0 	unload was successful   *	errno	unload failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_dounload
parameter_list|()
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * OK, try to clean up our mess 	 */
name|err
operator|=
name|fore_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadable driver description  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vdldrv
name|fore_drv
init|=
block|{
name|VDMAGIC_DRV
block|,
comment|/* Device Driver */
literal|"fore_mod"
block|,
comment|/* name */
operator|&
name|fore_ops
block|,
comment|/* dev_ops */
name|NULL
block|,
comment|/* bdevsw */
name|NULL
block|,
comment|/* cdevsw */
literal|0
block|,
comment|/* blockmajor */
literal|0
comment|/* charmajor */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Loadable module support entry point  *   * This is the routine called by the vd driver for all loadable module  * functions for this pseudo driver.  This routine name must be specified  * on the modload(1) command.  This routine will be called whenever the  * modload(1), modunload(1) or modstat(1) commands are issued for this  * module.  *  * Arguments:  *	cmd	vd command code  *	vdp	pointer to vd driver's structure  *	vdi	pointer to command-specific vdioctl_* structure  *	vds	pointer to status structure (VDSTAT only)  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
name|int
name|fore_mod
parameter_list|(
name|cmd
parameter_list|,
name|vdp
parameter_list|,
name|vdi
parameter_list|,
name|vds
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|vddrv
modifier|*
name|vdp
decl_stmt|;
name|caddr_t
name|vdi
decl_stmt|;
name|struct
name|vdstat
modifier|*
name|vds
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|VDLOAD
case|:
comment|/* 		 * Module Load 		 * 		 * We dont support any user configuration 		 */
name|err
operator|=
name|fore_doload
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
comment|/* Let vd driver know about us */
name|vdp
operator|->
name|vdd_vdtab
operator|=
operator|(
expr|struct
name|vdlinkage
operator|*
operator|)
operator|&
name|fore_drv
expr_stmt|;
break|break;
case|case
name|VDUNLOAD
case|:
comment|/* 		 * Module Unload 		 */
name|err
operator|=
name|fore_dounload
argument_list|()
expr_stmt|;
break|break;
case|case
name|VDSTAT
case|:
comment|/* 		 * Module Status 		 */
comment|/* Not much to say at the moment */
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fore_mod: Unknown vd command 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Driver entry points  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fore_cdev
init|=
block|{
operator|(
name|d_open_t
operator|*
operator|)
name|enodev
block|,
comment|/* open */
operator|(
name|d_close_t
operator|*
operator|)
name|enodev
block|,
comment|/* close */
name|NULL
block|,
comment|/* read */
name|NULL
block|,
comment|/* write */
name|NULL
block|,
comment|/* ioctl */
name|NULL
block|,
comment|/* stop */
name|NULL
block|,
comment|/* reset */
name|NULL
block|,
comment|/* devtotty */
name|NULL
block|,
comment|/* select */
name|NULL
block|,
comment|/* mmap */
name|NULL
comment|/* strategy */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Loadable device driver module description  */
end_comment

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199506
end_if

begin_expr_stmt
name|MOD_DEV
argument_list|(
literal|"fore_mod"
argument_list|,
name|LM_DT_CHAR
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fore_cdev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|MOD_DEV
argument_list|(
name|fore
argument_list|,
name|LM_DT_CHAR
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fore_cdev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Loadable module support "load" entry point  *   * This is the routine called by the lkm driver whenever the  * modload(1) command is issued for this module.  *  * Arguments:  *	lkmtp	pointer to lkm drivers's structure  *	cmd	lkm command code  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_load
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
return|return
operator|(
name|fore_doload
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadable module support "unload" entry point  *   * This is the routine called by the lkm driver whenever the  * modunload(1) command is issued for this module.  *  * Arguments:  *	lkmtp	pointer to lkm drivers's structure  *	cmd	lkm command code  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
specifier|static
name|int
name|fore_unload
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
return|return
operator|(
name|fore_dounload
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadable module support entry point  *   * This is the routine called by the lkm driver for all loadable module  * functions for this driver.  This routine name must be specified  * on the modload(1) command.  This routine will be called whenever the  * modload(1), modunload(1) or modstat(1) commands are issued for this  * module.  *  * Arguments:  *	lkmtp	pointer to lkm drivers's structure  *	cmd	lkm command code  *	ver	lkm version  *  * Returns:  *	0 	command was successful   *	errno	command failed - reason indicated  *  */
end_comment

begin_function
name|int
name|fore_mod
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|,
name|ver
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|ver
decl_stmt|;
block|{
if|#
directive|if
name|BSD
operator|<
literal|199506
name|DISPATCH
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|,
name|ver
argument_list|,
name|fore_load
argument_list|,
name|fore_unload
argument_list|,
name|nosys
argument_list|)
expr_stmt|;
else|#
directive|else
name|DISPATCH
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|,
name|ver
argument_list|,
name|fore_load
argument_list|,
name|fore_unload
argument_list|,
name|lkm_nullcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATM_LINKED */
end_comment

end_unit

