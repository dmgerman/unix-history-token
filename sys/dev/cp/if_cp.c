begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Cronyx-Tau-PCI adapter driver for FreeBSD.  * Supports PPP/HDLC, Cisco/HDLC and FrameRelay protocol in synchronous mode,  * and asyncronous channels with full modem control.  * Keepalive protocol implemented in both Cisco and PPP modes.  *  * Copyright (C) 1999-2004 Cronyx Engineering.  * Author: Kurakin Roman,<rik@cronyx.ru>  *  * Copyright (C) 1999-2002 Cronyx Engineering.  * Author: Serge Vakulenko,<vak@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations a permission to use,  * modify and redistribute this software in source and binary forms,  * as long as this message is kept with the software, all derivative  * works or modified versions.  *  * $Cronyx: if_cp.c,v 1.1.2.32 2004/02/26 17:56:39 rik Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_define
define|#
directive|define
name|NPCI
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|501000
end_if

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"opt_ng_cronyx.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_CRONYX
end_ifdef

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NETGRAPH
end_ifndef

begin_error
error|#
directive|error
error|#option	NETGRAPH missed from configuration
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_include
include|#
directive|include
file|<dev/cp/ng_cp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<netgraph/ng_cp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_define
define|#
directive|define
name|PP_CISCO
value|IFF_LINK2
end_define

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
end_if

begin_include
include|#
directive|include
file|<bpfilter.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_include
include|#
directive|include
file|<bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_define
define|#
directive|define
name|NBPFILTER
value|NBPF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_include
include|#
directive|include
file|<dev/cx/machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cp/cpddk.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/cronyx/machdep.h>
end_include

begin_include
include|#
directive|include
file|<pci/cpddk.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cserial.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_comment
comment|/* If we don't have Cronyx's sppp version, we don't have fr support via sppp */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PP_FR
end_ifndef

begin_define
define|#
directive|define
name|PP_FR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CP_DEBUG
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|CP_DEBUG2
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug>1) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|134
end_define

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_decl_stmt
specifier|static
name|int
name|cp_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|cp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cp_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cp_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_bdrv_t
block|{
name|cp_board_t
modifier|*
name|board
decl_stmt|;
name|struct
name|resource
modifier|*
name|cp_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|cp_irq
decl_stmt|;
name|void
modifier|*
name|cp_intrhand
decl_stmt|;
block|}
name|bdrv_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|driver_t
name|cp_driver
init|=
block|{
literal|"cp"
block|,
name|cp_methods
block|,
sizeof|sizeof
argument_list|(
name|bdrv_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cp_devclass
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|_drv_t
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|cp_chan_t
modifier|*
name|chan
decl_stmt|;
name|cp_board_t
modifier|*
name|board
decl_stmt|;
name|cp_buf_t
name|buf
decl_stmt|;
name|int
name|running
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|char
name|nodename
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|struct
name|ifqueue
name|queue
decl_stmt|;
name|struct
name|ifqueue
name|hi_queue
decl_stmt|;
name|short
name|timeout
decl_stmt|;
name|struct
name|callout_handle
name|timeout_handle
decl_stmt|;
else|#
directive|else
name|struct
name|sppp
name|pp
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|dev_t
name|devt
decl_stmt|;
endif|#
directive|endif
block|}
name|drv_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|cp_receive
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_transmit
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_error
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|ng_type
name|typestruct
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|cp_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cp_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|cp_board_t
modifier|*
name|adapter
index|[
name|NBRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|drv_t
modifier|*
name|channel
index|[
name|NBRD
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cp_qbuf_t
modifier|*
name|queue
index|[
name|NBRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|led_timo
index|[
name|NBRD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|timeout_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cp_destroy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the mbuf chain, for debug purposes only.  */
end_comment

begin_function
specifier|static
name|void
name|printmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mbuf:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|" HDR %d:"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|" EXT:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an mbuf from data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|makembuf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cp_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|tag
operator|->
name|vendor
operator|==
name|cp_vendor_id
operator|&&
name|tag
operator|->
name|device
operator|==
name|cp_device_id
condition|)
return|return
literal|"Cronyx-Tau-PCI serial adapter"
return|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|cp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|cp_vendor_id
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|cp_device_id
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cronyx-Tau-PCI serial adapter"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|cp_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
operator|*
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp_destroy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|channel
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|d
operator|->
name|chan
operator|->
name|type
condition|)
block|{
case|case
name|T_G703
case|:
name|cp_g703_timer
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_E1
case|:
name|cp_e1_timer
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_E3
case|:
case|case
name|T_T3
case|:
case|case
name|T_STS1
case|:
name|cp_e3_timer
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cp_destroy
condition|)
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cp_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cp_board_t
modifier|*
name|b
init|=
name|arg
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|cp_destroy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp_led
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cp_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|cp_board_t
modifier|*
name|b
init|=
name|arg
decl_stmt|;
else|#
directive|else
name|bdrv_t
modifier|*
name|bd
init|=
name|arg
decl_stmt|;
name|cp_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
endif|#
directive|endif
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|cp_destroy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Turn LED on. */
name|cp_led
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp_interrupt
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Turn LED off 50 msec later. */
if|if
condition|(
operator|!
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
condition|)
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|=
name|timeout
argument_list|(
name|cp_led_off
argument_list|,
name|b
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|cp_cdevsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called if the probe succeeded.  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
end_if

begin_function
specifier|static
name|void
name|cp_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|vm_offset_t
name|pbase
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|cp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|vbase
decl_stmt|;
name|cp_board_t
modifier|*
name|b
decl_stmt|;
name|cp_chan_t
modifier|*
name|c
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
name|unsigned
name|short
name|res
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|b
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_board_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: couldn't allocate memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
endif|#
directive|endif
block|}
name|adapter
index|[
name|unit
index|]
operator|=
name|b
expr_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_board_t
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|tag
argument_list|,
name|PCIR_MAPS
argument_list|,
operator|&
name|vbase
argument_list|,
operator|&
name|pbase
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: cannot map memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|bd
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|sys
operator|=
name|bd
expr_stmt|;
name|rid
operator|=
name|PCIR_MAPS
expr_stmt|;
name|bd
operator|->
name|cp_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|cp_res
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: cannot map memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|vbase
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|bd
operator|->
name|cp_res
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|res
operator|=
name|cp_init
argument_list|(
name|b
argument_list|,
name|unit
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|vbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: can't init, error code:%x\n"
argument_list|,
name|unit
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_MAPS
argument_list|,
name|bd
operator|->
name|cp_res
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
return|return
operator|(
name|ENXIO
operator|)
return|;
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
name|queue
index|[
name|unit
index|]
operator|=
name|contigmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cp_qbuf_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: allocate memory for qbuf_t\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
return|return
operator|(
name|ENXIO
operator|)
return|;
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
name|cp_reset
argument_list|(
name|b
argument_list|,
name|queue
index|[
name|unit
index|]
argument_list|,
name|vtophys
argument_list|(
name|queue
index|[
name|unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|cp_intr
argument_list|,
name|b
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
name|printf
argument_list|(
literal|"cp%d: cannot map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|cp_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|cp_irq
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: cannot map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_MAPS
argument_list|,
name|bd
operator|->
name|cp_res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|cp_irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|cp_intr
argument_list|,
name|bd
argument_list|,
operator|&
name|bd
operator|->
name|cp_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d: cannot set up irq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_MAPS
argument_list|,
name|bd
operator|->
name|cp_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|bd
operator|->
name|cp_irq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"cp%d: %s, clock %ld MHz\n"
argument_list|,
name|unit
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|osc
operator|/
literal|1000000
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|type
condition|)
continue|continue;
name|d
operator|=
name|contigmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|drv_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0x100000
argument_list|,
literal|0xffffffff
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cp%d-%d: cannot allocate memory for drv_t\n"
argument_list|,
name|unit
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
name|d
expr_stmt|;
name|bzero
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|drv_t
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|d
operator|->
name|name
argument_list|,
literal|"cp%d.%d"
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|chan
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|sys
operator|=
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|d
operator|->
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot make common node\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_NODE_SET_PRIVATE
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|node
operator|->
name|private
operator|=
name|d
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|d
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_CP_NODE_TYPE
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot name node\n"
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_rmnode
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|d
operator|->
name|queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|d
operator|->
name|hi_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|,
literal|"cp_queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"cp_queue_hi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/*NETGRAPH*/
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_softc
operator|=
name|d
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|501000
name|if_initname
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
literal|"cp"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_unit
operator|=
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_name
operator|=
literal|"cp"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_mtu
operator|=
name|PP_MTU
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ioctl
operator|=
name|cp_sioctl
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_start
operator|=
name|cp_ifstart
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_watchdog
operator|=
name|cp_ifwatchdog
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_init
operator|=
name|cp_initialize
expr_stmt|;
name|sppp_attach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_tlf
operator|=
name|cp_tlf
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_tls
operator|=
name|cp_tls
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
operator|||
name|NBPFILTER
operator|>
literal|0
comment|/* If BPF is in the kernel, call the attach for it. 		 * The header size of PPP or Cisco/HDLC is 4 bytes. */
name|bpfattach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|DLT_PPP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/*NETGRAPH*/
name|cp_start_e1
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cp_start_chan
argument_list|(
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|d
operator|->
name|buf
argument_list|,
name|vtophys
argument_list|(
operator|&
name|d
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register callback functions. */
name|cp_register_transmit
argument_list|(
name|c
argument_list|,
operator|&
name|cp_transmit
argument_list|)
expr_stmt|;
name|cp_register_receive
argument_list|(
name|c
argument_list|,
operator|&
name|cp_receive
argument_list|)
expr_stmt|;
name|cp_register_error
argument_list|(
name|c
argument_list|,
operator|&
name|cp_error
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|d
operator|->
name|devt
operator|=
name|make_dev
argument_list|(
operator|&
name|cp_cdevsw
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"cp%d"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
specifier|static
name|int
name|cp_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cp_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
name|cp_chan_t
modifier|*
name|c
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
comment|/* Check if the device is busy (open). */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
comment|/* Ok, we can unload driver */
comment|/* At first we should stop all channels */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
name|cp_stop_chan
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cp_stop_e1
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cp_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the adapter. */
name|cp_destroy
operator|=
literal|1
expr_stmt|;
name|cp_interrupt_poll
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp_led_off
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|cp_reset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cp_led_off
argument_list|,
name|b
argument_list|,
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|410000
operator|&&
name|NBPFILTER
operator|>
literal|0
comment|/* Detach from the packet filter list of interfaces. */
name|bpfdetach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Detach from the sync PPP list. */
name|sppp_detach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
comment|/* Detach from the system list of interfaces. */
name|if_detach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|d
operator|->
name|node
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_rmnode
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|destroy_dev
argument_list|(
name|d
operator|->
name|devt
argument_list|)
expr_stmt|;
block|}
comment|/* Disable the interrupt request. */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|cp_irq
argument_list|,
name|bd
operator|->
name|cp_intrhand
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|bd
operator|->
name|cp_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|bd
operator|->
name|cp_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_MAPS
argument_list|,
name|bd
operator|->
name|cp_res
argument_list|)
expr_stmt|;
name|cp_led_off
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_timo
index|[
name|b
operator|->
name|num
index|]
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cp_led_off
argument_list|,
name|b
argument_list|,
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Deallocate buffers. */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|free
argument_list|(
name|d
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
else|#
directive|else
name|contigfree
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|adapter
index|[
name|b
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|free
argument_list|(
name|queue
index|[
name|b
operator|->
name|num
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
else|#
directive|else
name|contigfree
argument_list|(
name|queue
index|[
name|b
operator|->
name|num
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_qbuf_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
specifier|static
name|u_long
name|cp_count
decl_stmt|;
specifier|static
name|struct
name|pci_device
name|cp_driver
init|=
block|{
literal|"cp"
block|,
name|cp_probe
block|,
name|cp_attach
block|,
operator|&
name|cp_count
block|,
literal|0
block|}
decl_stmt|;
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|cp_driver
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NETGRAPH
specifier|static
name|void
name|cp_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|cp_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|cp_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|cp_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|cp_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|sp
operator|->
name|pp_if
operator|.
name|if_softc
decl_stmt|;
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_tlf\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*	cp_set_dtr (d->chan, 0);*/
comment|/*	cp_set_rts (d->chan, 0);*/
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
name|sp
operator|->
name|pp_down
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|cp_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|sp
operator|->
name|pp_if
operator|.
name|if_softc
decl_stmt|;
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_tls\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
name|sp
operator|->
name|pp_up
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/*  * Process an ioctl request.  */
specifier|static
name|int
name|cp_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|was_up
decl_stmt|,
name|should_be_up
decl_stmt|;
name|was_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl 0x%lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCADDMULTI
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCADDMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCDELMULTI
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCDELMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCSIFFLAGS
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCSIFFLAGS\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl SIOCSIFADDR\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We get here only in case of SIFFLAGS or SIFADDR. */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|should_be_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|was_up
operator|&&
name|should_be_up
condition|)
block|{
comment|/* Interface goes up -- start it. */
name|cp_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|cp_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_up
operator|&&
operator|!
name|should_be_up
condition|)
block|{
comment|/* Interface is going down -- stop it. */
comment|/*		if ((d->pp.pp_flags& PP_FR) || (ifp->if_flags& PP_CISCO))*/
name|cp_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl 0x%lx p4\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Initialization of interface.  * It seems to be never called by upper level?  */
specifier|static
name|void
name|cp_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|softc
decl_stmt|;
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_initialize\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*NETGRAPH*/
comment|/*  * Stop the interface.  Called on splimp().  */
specifier|static
name|void
name|cp_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_down\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Interface is going down -- stop it. */
name|cp_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Start the interface.  Called on splimp().  */
specifier|static
name|void
name|cp_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_up\n"
operator|)
argument_list|)
expr_stmt|;
name|cp_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|1
expr_stmt|;
block|}
comment|/*  * Start output on the interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
specifier|static
name|void
name|cp_send
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_send, tn=%d te=%d\n"
operator|,
name|d
operator|->
name|chan
operator|->
name|tn
operator|,
name|d
operator|->
name|chan
operator|->
name|te
operator|)
argument_list|)
expr_stmt|;
comment|/* No output if the interface is down. */
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
comment|/* No output if the modem is off. */
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|chan
operator|->
name|lloop
operator|||
name|d
operator|->
name|chan
operator|->
name|type
operator|!=
name|T_SERIAL
operator|||
name|cp_get_dsr
argument_list|(
name|d
operator|->
name|chan
argument_list|)
operator|)
condition|)
return|return;
while|while
condition|(
name|cp_transmit_space
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
block|{
comment|/* Get the packet to send. */
ifdef|#
directive|ifdef
name|NETGRAPH
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|sppp_dequeue
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|||
name|NBPFILTER
operator|>
literal|0
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|NETGRAPH
argument_list|)
if|if
condition|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_bpf
condition|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|BPF_MTAP
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|bpf_mtap
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|BUFSZ
condition|)
name|printf
argument_list|(
literal|"%s: too long packet: %d bytes: "
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|cp_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|u_char
modifier|*
name|buf
init|=
name|d
operator|->
name|chan
operator|->
name|tbuf
index|[
name|d
operator|->
name|chan
operator|->
name|te
index|]
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cp_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Set up transmit timeout, if the transmit ring is not empty.*/
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|10
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_timer
operator|=
literal|10
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * Start output on the interface.  * Always called on splimp().  */
specifier|static
name|void
name|cp_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|dtr
condition|)
name|cp_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|cp_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp_send
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Handle transmit timeouts.  * Recover after lost transmit interrupts.  * Always called on splimp().  */
specifier|static
name|void
name|cp_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"device timeout\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|cp_stop_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|cp_stop_e1
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|cp_start_e1
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|cp_start_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|cp_transmit
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_opackets
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|cp_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|cp_receive
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
name|int
name|error
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
name|m
operator|=
name|makembuf
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"no memory for packet\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_iqdrops
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|c
operator|->
name|debug
operator|>
literal|1
condition|)
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|ng_queue_data
argument_list|(
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ipackets
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
operator|||
name|NBPFILTER
operator|>
literal|0
comment|/* Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf. */
if|if
condition|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_bpf
condition|)
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|BPF_TAP
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|bpf_tap
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|sppp_input
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|cp_error
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
name|CP_FRAME
case|:
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"frame error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CP_CRC
case|:
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"crc error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CP_OVERRUN
case|:
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_collisions
expr_stmt|;
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CP_OVERFLOW
case|:
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overflow error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CP_UNDERRUN
case|:
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"underrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_oerrors
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|cp_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"error #%d\n"
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*  * You also need read, write, open, close routines.  * This should get you started  */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
specifier|static
name|int
name|cp_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|oflags
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|cp_open
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|oflags
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBRD
operator|*
name|NCHAN
operator|||
operator|!
operator|(
name|d
operator|=
name|channel
index|[
name|unit
index|]
operator|)
condition|)
return|return
name|ENXIO
return|;
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Only called on the LAST close.  */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
specifier|static
name|int
name|cp_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|fflag
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|cp_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|fflag
argument_list|,
name|int
name|devtype
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"cp_close\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|cp_modem_status
parameter_list|(
name|cp_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|int
name|status
decl_stmt|,
name|s
decl_stmt|;
name|status
operator|=
name|d
operator|->
name|running
condition|?
name|TIOCM_LE
else|:
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp_get_cd
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|cp_get_cts
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|cp_get_dsr
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|dtr
condition|)
name|status
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rts
condition|)
name|status
operator||=
name|TIOCM_RTS
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
specifier|static
name|int
name|cp_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|data
argument_list|,
name|int
name|flag
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
else|#
directive|else
decl|static
name|int
name|cp_ioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|data
argument_list|,
name|int
name|flag
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
endif|#
directive|endif
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|cp_chan_t
modifier|*
name|c
init|=
name|d
operator|->
name|chan
decl_stmt|;
name|struct
name|serial_statistics
modifier|*
name|st
decl_stmt|;
name|struct
name|e1_statistics
modifier|*
name|opte1
decl_stmt|;
name|struct
name|e3_statistics
modifier|*
name|opte3
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|char
name|mask
index|[
literal|16
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SERIAL_GETREGISTERED
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getregistered\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|NBRD
operator|*
name|NCHAN
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|channel
index|[
name|s
index|]
condition|)
name|mask
index|[
name|s
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|s
operator|&
literal|7
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|mask
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|NETGRAPH
case|case
name|SERIAL_GETPROTO
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getproto\n"
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
condition|?
literal|"fr"
else|:
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|?
literal|"cisco"
else|:
literal|"ppp"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPROTO
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setproto\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 500000 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __FreeBSD_version>= 500000 */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"cisco"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
operator|(
name|PP_FR
operator|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator||=
name|PP_CISCO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"fr"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|&&
operator|!
name|PP_FR
condition|)
block|{
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator||=
name|PP_FR
operator||
name|PP_KEEPALIVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ppp"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
name|PP_FR
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETKEEPALIVE
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getkeepalive\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_KEEPALIVE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETKEEPALIVE
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setkeepalive\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
else|else
name|d
operator|->
name|pp
operator|.
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/*NETGRAPH*/
case|case
name|SERIAL_GETMODE
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getmode\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SERIAL_HDLC
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETMODE
case|:
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|!=
name|SERIAL_HDLC
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCFG
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcfg\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|char
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|board
operator|->
name|mux
condition|?
literal|'c'
else|:
literal|'a'
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETCFG
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setcfg\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_mux
argument_list|(
name|c
operator|->
name|board
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|)
operator|==
literal|'c'
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSTAT
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getstat\n"
operator|)
argument_list|)
expr_stmt|;
name|st
operator|=
operator|(
expr|struct
name|serial_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|st
operator|->
name|rintr
operator|=
name|c
operator|->
name|rintr
expr_stmt|;
name|st
operator|->
name|tintr
operator|=
name|c
operator|->
name|tintr
expr_stmt|;
name|st
operator|->
name|mintr
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|ibytes
operator|=
name|c
operator|->
name|ibytes
expr_stmt|;
name|st
operator|->
name|ipkts
operator|=
name|c
operator|->
name|ipkts
expr_stmt|;
name|st
operator|->
name|obytes
operator|=
name|c
operator|->
name|obytes
expr_stmt|;
name|st
operator|->
name|opkts
operator|=
name|c
operator|->
name|opkts
expr_stmt|;
name|st
operator|->
name|ierrs
operator|=
name|c
operator|->
name|overrun
operator|+
name|c
operator|->
name|frame
operator|+
name|c
operator|->
name|crc
expr_stmt|;
name|st
operator|->
name|oerrs
operator|=
name|c
operator|->
name|underrun
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETESTAT
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getestat\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_G703
condition|)
return|return
name|EINVAL
return|;
name|opte1
operator|=
operator|(
expr|struct
name|e1_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|opte1
operator|->
name|status
operator|=
name|c
operator|->
name|status
expr_stmt|;
name|opte1
operator|->
name|cursec
operator|=
name|c
operator|->
name|cursec
expr_stmt|;
name|opte1
operator|->
name|totsec
operator|=
name|c
operator|->
name|totsec
operator|+
name|c
operator|->
name|cursec
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|bpv
operator|=
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|fse
operator|=
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|crce
operator|=
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|rcrce
operator|=
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|uas
operator|=
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|les
operator|=
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|es
operator|=
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|bes
operator|=
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|ses
operator|=
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|oofs
operator|=
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|css
operator|=
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|dm
operator|=
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|bpv
operator|=
name|c
operator|->
name|total
operator|.
name|bpv
operator|+
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|fse
operator|=
name|c
operator|->
name|total
operator|.
name|fse
operator|+
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|crce
operator|=
name|c
operator|->
name|total
operator|.
name|crce
operator|+
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|rcrce
operator|=
name|c
operator|->
name|total
operator|.
name|rcrce
operator|+
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|uas
operator|=
name|c
operator|->
name|total
operator|.
name|uas
operator|+
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|les
operator|=
name|c
operator|->
name|total
operator|.
name|les
operator|+
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|es
operator|=
name|c
operator|->
name|total
operator|.
name|es
operator|+
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|bes
operator|=
name|c
operator|->
name|total
operator|.
name|bes
operator|+
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|ses
operator|=
name|c
operator|->
name|total
operator|.
name|ses
operator|+
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|oofs
operator|=
name|c
operator|->
name|total
operator|.
name|oofs
operator|+
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|css
operator|=
name|c
operator|->
name|total
operator|.
name|css
operator|+
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|dm
operator|=
name|c
operator|->
name|total
operator|.
name|dm
operator|+
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|48
condition|;
operator|++
name|s
control|)
block|{
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bpv
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|fse
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|crce
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|rcrce
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|uas
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|les
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|es
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bes
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|ses
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|oofs
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|css
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|dm
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|dm
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_GETE3STAT
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: gete3stat\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
name|opte3
operator|=
operator|(
expr|struct
name|e3_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|opte3
operator|->
name|status
operator|=
name|c
operator|->
name|e3status
expr_stmt|;
name|opte3
operator|->
name|cursec
operator|=
operator|(
name|c
operator|->
name|e3csec_5
operator|*
literal|2
operator|+
literal|1
operator|)
operator|/
literal|10
expr_stmt|;
name|opte3
operator|->
name|totsec
operator|=
name|c
operator|->
name|e3tsec
operator|+
name|opte3
operator|->
name|cursec
expr_stmt|;
name|opte3
operator|->
name|ccv
operator|=
name|c
operator|->
name|e3ccv
expr_stmt|;
name|opte3
operator|->
name|tcv
operator|=
name|c
operator|->
name|e3tcv
operator|+
name|opte3
operator|->
name|ccv
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|48
condition|;
operator|++
name|s
control|)
block|{
name|opte3
operator|->
name|icv
index|[
name|s
index|]
operator|=
name|c
operator|->
name|e3icv
index|[
name|s
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_CLRSTAT
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: clrstat\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|c
operator|->
name|rintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ibytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|obytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ipkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|opkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|overrun
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|frame
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|underrun
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
operator|->
name|currnt
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|currnt
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|c
operator|->
name|interval
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|interval
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|e3ccv
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|e3tcv
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|c
operator|->
name|e3icv
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|e3icv
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETBAUD
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getbaud\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|baud
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETBAUD
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setbaud\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_baud
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETLOOP
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getloop\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|lloop
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETLOOP
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setloop\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_lloop
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDPLL
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdpll\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|dpll
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDPLL
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdpll\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_dpll
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETNRZI
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getnrzi\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|nrzi
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETNRZI
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setnrzi\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_nrzi
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDEBUG
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdebug\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|d
operator|->
name|chan
operator|->
name|debug
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDEBUG
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdebug\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator||=
name|IFF_DEBUG
expr_stmt|;
else|else
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_DEBUG
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|SERIAL_GETHIGAIN
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: gethigain\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|higain
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETHIGAIN
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: sethigain\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_higain
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETPHONY
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getphony\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|phony
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPHONY
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setphony\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_phony
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETUNFRAM
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getunfram\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|unfram
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETUNFRAM
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setunfram\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_unfram
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSCRAMBLER
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getscrambler\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_G703
operator|&&
operator|!
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|scrambler
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETSCRAMBLER
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setscrambler\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_G703
operator|&&
operator|!
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_scrambler
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETMONITOR
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getmonitor\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_E3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|monitor
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETMONITOR
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setmonitor\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_monitor
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETUSE16
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getuse16\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|use16
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETUSE16
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setuse16\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_use16
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCRC4
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcrc4\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|crc4
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETCRC4
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setcrc4\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_crc4
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getclk\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_G703
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_E3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|c
operator|->
name|gsyn
condition|)
block|{
default|default:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_INTERNAL
expr_stmt|;
break|break;
case|case
name|GSYN_RCV
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE
expr_stmt|;
break|break;
case|case
name|GSYN_RCV0
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE_CHAN0
expr_stmt|;
break|break;
case|case
name|GSYN_RCV1
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE_CHAN1
expr_stmt|;
break|break;
case|case
name|GSYN_RCV2
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE_CHAN2
expr_stmt|;
break|break;
case|case
name|GSYN_RCV3
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE_CHAN3
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_SETCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setclk\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_G703
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_E3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
default|default:
name|cp_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE
case|:
name|cp_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN0
case|:
name|cp_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV0
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN1
case|:
name|cp_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV1
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN2
case|:
name|cp_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV2
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN3
case|:
name|cp_set_gsyn
argument_list|(
name|c
argument_list|,
name|GSYN_RCV3
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETTIMESLOTS
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: gettimeslots\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
operator|)
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_DATA
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|u_long
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|ts
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETTIMESLOTS
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: settimeslots\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|||
name|c
operator|->
name|unfram
operator|)
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_DATA
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_ts
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETINVCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getinvclk\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
name|EINVAL
return|;
else|#
directive|else
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|invtxc
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
case|case
name|SERIAL_SETINVCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setinvclk\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_invtxc
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|cp_set_invrxc
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETINVTCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getinvtclk\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|invtxc
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETINVTCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setinvtclk\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_invtxc
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETINVRCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getinvrclk\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|invrxc
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETINVRCLK
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setinvrclk\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_invrxc
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETLEVEL
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getlevel\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_G703
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cp_get_lq
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
literal|0
block|case SERIAL_RESET: 	        CP_DEBUG2 (d, ("ioctl: reset\n"));
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
block|error = suser (p->p_ucred,&p->p_acflag);
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
block|error = suser (p);
else|#
directive|else
block|error = suser (td);
endif|#
directive|endif
block|if (error) 	                return error; 		s = splimp (); 		cp_reset (c->board, 0, 0); 		splx (s); 		return 0;  	case SERIAL_HARDRESET: 	        CP_DEBUG2 (d, ("ioctl: hardreset\n"));
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
block|error = suser (p->p_ucred,&p->p_acflag);
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
block|error = suser (p);
else|#
directive|else
block|error = suser (td);
endif|#
directive|endif
block|if (error) 	                return error; 		s = splimp ();
comment|/* hard_reset (c->board); */
block|splx (s); 		return 0;
endif|#
directive|endif
case|case
name|SERIAL_GETCABLE
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcable\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_SERIAL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cp_get_cable
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDIR
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getdir\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E1
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_DATA
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|dir
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDIR
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setdir\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_dir
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETRLOOP
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getrloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_G703
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_E3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cp_get_rloop
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETRLOOP
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_E3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_rloop
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCABLEN
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getcablen\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|cablen
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETCABLEN
case|:
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setloop\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|T_T3
operator|&&
name|c
operator|->
name|type
operator|!=
name|T_STS1
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_cablen
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCSDTR
case|:
comment|/* Set DTR */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCCDTR
case|:
comment|/* Clear DTR */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMSET
case|:
comment|/* Set DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_set_dtr
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|cp_set_rts
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIS
case|:
comment|/* Add DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|cp_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|cp_set_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIC
case|:
comment|/* Clear DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|cp_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|cp_set_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMGET
case|:
comment|/* Get modem status */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|cp_modem_status
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOTTY
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
specifier|static
name|struct
name|cdevsw
name|cp_cdevsw
init|=
block|{
name|cp_open
block|,
name|cp_close
block|,
name|noread
block|,
name|nowrite
block|,
name|cp_ioctl
block|,
name|nullstop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"cp"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|500000
specifier|static
name|struct
name|cdevsw
name|cp_cdevsw
init|=
block|{
name|cp_open
block|,
name|cp_close
block|,
name|noread
block|,
name|nowrite
block|,
name|cp_ioctl
block|,
name|nopoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"cp"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_NAGGED
block|,
operator|-
literal|1
block|}
decl_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|==
literal|500000
specifier|static
name|struct
name|cdevsw
name|cp_cdevsw
init|=
block|{
name|cp_open
block|,
name|cp_close
block|,
name|noread
block|,
name|nowrite
block|,
name|cp_ioctl
block|,
name|nopoll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"cp"
block|,
name|CDEV_MAJOR
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_NAGGED
block|, 	}
decl_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<=
literal|501000
specifier|static
name|struct
name|cdevsw
name|cp_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|cp_open
block|,
operator|.
name|d_close
operator|=
name|cp_close
block|,
operator|.
name|d_read
operator|=
name|noread
block|,
operator|.
name|d_write
operator|=
name|nowrite
block|,
operator|.
name|d_ioctl
operator|=
name|cp_ioctl
block|,
operator|.
name|d_poll
operator|=
name|nopoll
block|,
operator|.
name|d_mmap
operator|=
name|nommap
block|,
operator|.
name|d_strategy
operator|=
name|nostrategy
block|,
operator|.
name|d_name
operator|=
literal|"cp"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_dump
operator|=
name|nodump
block|,
operator|.
name|d_flags
operator|=
name|D_NAGGED
block|, }
decl_stmt|;
elif|#
directive|elif
name|__FreeBSD_version
operator|<
literal|502103
specifier|static
name|struct
name|cdevsw
name|cp_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|cp_open
block|,
operator|.
name|d_close
operator|=
name|cp_close
block|,
operator|.
name|d_ioctl
operator|=
name|cp_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cp"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_NAGGED
block|, }
decl_stmt|;
else|#
directive|else
comment|/* __FreeBSD_version>= 502103 */
specifier|static
name|struct
name|cdevsw
name|cp_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|cp_open
block|,
operator|.
name|d_close
operator|=
name|cp_close
block|,
operator|.
name|d_ioctl
operator|=
name|cp_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cp"
block|,
operator|.
name|d_maj
operator|=
name|CDEV_MAJOR
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|, }
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_cp_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_cp_constructor
parameter_list|(
name|node_p
modifier|*
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
operator|*
name|node
operator|)
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Constructor\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
specifier|static
name|int
name|ng_cp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Newhook\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Attach debug hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CP_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|hook
operator|->
name|private
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for raw hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CP_HOOK_RAW
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|hook
operator|->
name|private
operator|=
name|d
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|cp_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|char
modifier|*
name|format_timeslots
parameter_list|(
name|u_long
name|s
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|s
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|int
name|prev
init|=
operator|(
name|i
operator|>
literal|1
operator|)
operator|&
operator|(
name|s
operator|>>
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|int
name|next
init|=
operator|(
name|i
operator|<
literal|31
operator|)
operator|&
operator|(
name|s
operator|>>
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
if|if
condition|(
name|next
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|10
condition|)
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|i
operator|/
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|i
operator|%
literal|10
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
specifier|static
name|int
name|print_modems
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|status
init|=
name|cp_modem_status
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  LE   DTR  DSR  RTS  CTS  CD\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%4s %4s %4s %4s %4s %4s\n"
argument_list|,
name|status
operator|&
name|TIOCM_LE
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DTR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DSR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_RTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CD
condition|?
literal|"On"
else|:
literal|"-"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cp_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  Rintr   Tintr   Mintr   Ibytes   Ipkts   Ierrs   Obytes   Opkts   Oerrs\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%7ld %7ld %7ld %8lu %7ld %7ld %8lu %7ld %7ld\n"
argument_list|,
name|c
operator|->
name|rintr
argument_list|,
name|c
operator|->
name|tintr
argument_list|,
literal|0l
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|c
operator|->
name|ibytes
argument_list|,
name|c
operator|->
name|ipkts
argument_list|,
name|c
operator|->
name|overrun
operator|+
name|c
operator|->
name|frame
operator|+
name|c
operator|->
name|crc
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|c
operator|->
name|obytes
argument_list|,
name|c
operator|->
name|opkts
argument_list|,
name|c
operator|->
name|underrun
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|char
modifier|*
name|format_e1_status
parameter_list|(
name|u_char
name|status
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_NOALARM
condition|)
return|return
literal|"Ok"
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_AIS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",AIS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOMF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOMF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_FARLOF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",FARLOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_AIS16
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",AIS16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_FARLOMF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",FARLOMF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_TSTREQ
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",TSTREQ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_TSTERR
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",TSTERR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|','
condition|)
return|return
name|buf
operator|+
literal|1
return|;
return|return
literal|"Unknown"
return|;
block|}
specifier|static
name|int
name|print_frac
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|leftalign
parameter_list|,
name|u_long
name|numerator
parameter_list|,
name|u_long
name|divider
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numerator
operator|<
literal|1
operator|||
name|divider
operator|<
literal|1
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
name|leftalign
condition|?
literal|"/-   "
else|:
literal|"    -"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
literal|1000.0
operator|*
name|numerator
operator|/
name|divider
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1000
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
name|leftalign
condition|?
literal|"/.%-3d"
else|:
literal|" .%03d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
operator|*
operator|(
name|s
operator|+
name|length
operator|)
operator|=
name|leftalign
condition|?
literal|'/'
else|:
literal|' '
expr_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1000000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|500
operator|)
operator|/
literal|1000
operator|*
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|100000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|50
operator|)
operator|/
literal|100
operator|*
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|10000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|5
operator|)
operator|/
literal|10
operator|*
literal|10
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1000
case|:
name|length
operator|+=
name|printf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|".999"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
case|case
literal|10000
case|:
name|n
operator|=
literal|9990
expr_stmt|;
break|break;
case|case
literal|100000
case|:
name|n
operator|=
literal|99900
expr_stmt|;
break|break;
case|case
literal|1000000
case|:
name|n
operator|=
literal|999000
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|10000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d.%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|,
name|n
operator|/
literal|10
operator|%
literal|100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|100000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d.%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|,
name|n
operator|/
literal|100
operator|%
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|1000000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d."
argument_list|,
name|n
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_e1_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cp_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|e1_counters
name|total
decl_stmt|;
name|u_long
name|totsec
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|totsec
operator|=
name|c
operator|->
name|totsec
operator|+
name|c
operator|->
name|cursec
expr_stmt|;
name|total
operator|.
name|bpv
operator|=
name|c
operator|->
name|total
operator|.
name|bpv
operator|+
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|total
operator|.
name|fse
operator|=
name|c
operator|->
name|total
operator|.
name|fse
operator|+
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|total
operator|.
name|crce
operator|=
name|c
operator|->
name|total
operator|.
name|crce
operator|+
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|total
operator|.
name|rcrce
operator|=
name|c
operator|->
name|total
operator|.
name|rcrce
operator|+
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|total
operator|.
name|uas
operator|=
name|c
operator|->
name|total
operator|.
name|uas
operator|+
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|total
operator|.
name|les
operator|=
name|c
operator|->
name|total
operator|.
name|les
operator|+
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|total
operator|.
name|es
operator|=
name|c
operator|->
name|total
operator|.
name|es
operator|+
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|total
operator|.
name|bes
operator|=
name|c
operator|->
name|total
operator|.
name|bes
operator|+
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|total
operator|.
name|ses
operator|=
name|c
operator|->
name|total
operator|.
name|ses
operator|+
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|total
operator|.
name|oofs
operator|=
name|c
operator|->
name|total
operator|.
name|oofs
operator|+
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|total
operator|.
name|css
operator|=
name|c
operator|->
name|total
operator|.
name|css
operator|+
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|total
operator|.
name|dm
operator|=
name|c
operator|->
name|total
operator|.
name|dm
operator|+
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" Unav/Degr  Bpv/Fsyn  CRC/RCRC  Err/Lerr  Sev/Bur   Oof/Slp  Status\n"
argument_list|)
expr_stmt|;
comment|/* Unavailable seconds, degraded minutes */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|uas
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
literal|60
operator|*
name|c
operator|->
name|currnt
operator|.
name|dm
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Bipolar violations, frame sync errors */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|bpv
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|fse
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* CRC errors, remote CRC errors (E-bit) */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|crce
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|rcrce
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Errored seconds, line errored seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|es
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|les
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Severely errored seconds, burst errored seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|ses
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|bes
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Out of frame seconds, controlled slip seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|oofs
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|css
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %s\n"
argument_list|,
name|format_e1_status
argument_list|(
name|c
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print total statistics. */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|uas
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
literal|60
operator|*
name|total
operator|.
name|dm
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|bpv
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|fse
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|crce
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|rcrce
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|es
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|les
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|ses
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|bes
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|oofs
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|css
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" -- Total\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
specifier|static
name|int
name|print_chan
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|cp_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"cp%d"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" debug=%d"
argument_list|,
name|d
operator|->
name|chan
operator|->
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|board
operator|->
name|mux
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=C"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=A"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|baud
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %ld"
argument_list|,
name|c
operator|->
name|baud
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" extclock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_E1
operator|||
name|c
operator|->
name|type
operator|==
name|T_G703
condition|)
switch|switch
condition|(
name|c
operator|->
name|gsyn
condition|)
block|{
case|case
name|GSYN_INT
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV0
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV1
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV2
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GSYN_RCV3
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv3"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_SERIAL
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" dpll=%s"
argument_list|,
name|c
operator|->
name|dpll
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" nrzi=%s"
argument_list|,
name|c
operator|->
name|nrzi
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" invclk=%s"
argument_list|,
name|c
operator|->
name|invtxc
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_E1
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" higain=%s"
argument_list|,
name|c
operator|->
name|higain
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" loop=%s"
argument_list|,
name|c
operator|->
name|lloop
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_E1
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" ts=%s"
argument_list|,
name|format_timeslots
argument_list|(
name|c
operator|->
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_G703
condition|)
block|{
name|int
name|lq
decl_stmt|,
name|x
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|lq
operator|=
name|cp_get_lq
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" (level=-%.1fdB)"
argument_list|,
name|lq
operator|/
literal|10.0
argument_list|)
expr_stmt|;
block|}
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_cp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_cp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rcvmsg\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_CP_COOKIE
case|:
name|printf
argument_list|(
literal|"Not implemented yet\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|dl
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
literal|730
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|dl
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|MALLOC
argument_list|(
name|resp
argument_list|,
expr|struct
name|ng_mesg
operator|*
argument_list|,
name|dl
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|resp
argument_list|,
name|dl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
operator|(
name|resp
operator|)
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|l
operator|+=
name|print_chan
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_modems
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_e1_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
name|l
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|l
argument_list|,
literal|"Error: node not connect to channel"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|version
operator|=
name|NG_VERSION
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|arglen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|token
operator|=
name|msg
operator|->
name|header
operator|.
name|token
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|typecookie
operator|=
name|NGM_CP_COOKIE
expr_stmt|;
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmd
operator|=
name|msg
operator|->
name|header
operator|.
name|cmd
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
literal|"status"
argument_list|,
name|NG_CMDSTRLEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
specifier|static
name|int
name|ng_cp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
else|#
directive|else
specifier|static
name|int
name|ng_cp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifqueue
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CP_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rcvdata\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|hook
operator|->
name|private
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ENETDOWN
return|;
block|}
name|q
operator|=
operator|(
name|meta
operator|&&
name|meta
operator|->
name|priority
operator|>
literal|0
operator|)
condition|?
operator|&
name|d
operator|->
name|hi_queue
else|:
operator|&
name|d
operator|->
name|queue
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|IF_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ng_cp_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rmnode\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|running
condition|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|cp_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KLD_MODULE
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_REALLY_DIE
condition|)
block|{
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* __FreeBSD_version< 500000 */
name|drv_t
modifier|*
name|d
init|=
name|node
operator|->
name|private
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|running
condition|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|cp_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLD_MODULE
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
comment|/* We do so because of pci module problem, see also comment in 	   cp_unload. Not in 4.x. */
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|#
directive|else
name|node
operator|->
name|flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
specifier|static
name|void
name|ng_cp_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|timeout
operator|==
literal|1
condition|)
name|cp_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timeout
condition|)
name|d
operator|->
name|timeout
operator|--
expr_stmt|;
name|d
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|ng_cp_watchdog
argument_list|,
name|d
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|ng_cp_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
condition|)
block|{
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Connect\n"
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|ng_cp_watchdog
argument_list|,
name|d
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ng_cp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|drv_t
modifier|*
name|d
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
condition|)
block|{
name|CP_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Disconnect\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|hook
operator|->
name|private
condition|)
endif|#
directive|endif
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|cp_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|ng_cp_watchdog
argument_list|,
name|d
argument_list|,
name|d
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
ifdef|#
directive|ifdef
name|KLD_MODULE
extern|extern STAILQ_HEAD(devlist
operator|,
extern|pci_devinfo
block|)
function|pci_devq;
specifier|static
name|struct
name|pci_devinfo
modifier|*
name|pci_device_find
parameter_list|(
name|u_int16_t
name|device
parameter_list|,
name|u_int16_t
name|vendor
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|int
name|u
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|dinfo
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|pci_devq
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|dinfo
operator|&&
operator|(
name|i
operator|<
name|pci_numdevs
operator|)
condition|;
name|dinfo
operator|=
name|STAILQ_NEXT
argument_list|(
name|dinfo
argument_list|,
name|pci_links
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
if|if
condition|(
operator|(
name|device
operator|==
name|cfg
operator|->
name|device
operator|)
operator|&&
operator|(
name|vendor
operator|==
name|cfg
operator|->
name|vendor
operator|)
condition|)
block|{
if|if
condition|(
name|u
operator|==
name|unit
condition|)
return|return
name|dinfo
return|;
name|u
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/*  * Function called when loading the driver.  */
specifier|static
name|int
name|cp_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
condition|;
operator|++
name|i
control|)
block|{
name|dinfo
operator|=
name|pci_device_find
argument_list|(
name|cp_device_id
argument_list|,
name|cp_vendor_id
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dinfo
condition|)
break|break;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|cp_attach
argument_list|(
name|cfg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|device
operator|=
operator|&
name|cp_driver
expr_stmt|;
name|strncpy
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|,
name|cp_driver
operator|.
name|pd_name
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
index|[
sizeof|sizeof
argument_list|(
name|dinfo
operator|->
name|conf
operator|.
name|pd_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dinfo
operator|->
name|conf
operator|.
name|pd_unit
operator|=
name|i
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* Deactivate the timeout routine. */
name|untimeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|timeout_handle
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * Function called when unloading the driver.  */
specifier|static
name|int
name|cp_unload
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|1
comment|/* Currently pci loadable module not fully supported, so we just 	   return EBUSY. Do not forget to correct ng_cp_rmnode then probelm 	   would be solved. */
return|return
name|EBUSY
return|;
else|#
directive|else
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
comment|/* Check if the device is busy (open). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
operator|*
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|chan
operator|->
name|type
operator|&&
name|d
operator|->
name|running
condition|)
return|return
name|EBUSY
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Deactivate the timeout routine. */
name|untimeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|timeout_handle
argument_list|)
expr_stmt|;
comment|/* OK to unload the driver, unregister the interrupt first. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
condition|;
operator|++
name|i
control|)
block|{
name|cp_board_t
modifier|*
name|b
init|=
name|adapter
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|||
operator|!
name|b
operator|->
name|type
condition|)
continue|continue;
name|cp_reset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*		pci_unmap_int (tag, cp_intr, b,&net_imask);*/
comment|/* Here should be something like pci_unmap_mem ()*/
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|led_timo
index|[
name|i
index|]
operator|.
name|callout
condition|)
name|untimeout
argument_list|(
name|cp_led_off
argument_list|,
name|adapter
operator|+
name|i
argument_list|,
name|led_timo
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Detach the interfaces, free buffer memory. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
operator|*
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|NETGRAPH
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
operator|||
name|NBPFILTER
operator|>
literal|0
comment|/* Detach from the packet filter list of interfaces. */
block|{
name|struct
name|bpf_if
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|b
init|=
operator|&
name|bpf_iflist
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
operator|*
name|b
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|bif_ifp
operator|==
name|d
operator|->
name|pp
operator|.
name|pp_if
condition|)
block|{
operator|*
name|b
operator|=
name|q
operator|->
name|bif_next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
operator|&
operator|(
name|q
operator|->
name|bif_next
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Detach from the sync PPP list. */
name|sppp_detach
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|)
expr_stmt|;
comment|/* Detach from the system list of interfaces. */
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&d->pp.pp_if.if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
operator|.
name|if_addrhead
argument_list|,
name|ifa
argument_list|,
name|ifa_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifa
argument_list|,
name|M_IFADDR
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ifnet
argument_list|,
operator|&
name|d
operator|->
name|pp
operator|.
name|pp_if
argument_list|,
name|if_link
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Deallocate buffers. */
comment|/*		free (d, M_DEVBUF);*/
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBRD
condition|;
operator|++
name|i
control|)
block|{
name|cp_board_t
modifier|*
name|b
init|=
name|adapter
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|b
operator|&&
name|b
operator|->
name|type
condition|)
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
ifdef|#
directive|ifdef
name|KLD_MODULE
specifier|static
name|int
name|cp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|cp_cdevsw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
return|return
name|cp_load
argument_list|()
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
name|cp_unload
argument_list|()
return|;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* KLD_MODULE */
else|#
directive|else
comment|/* __FreeBSD_version>= 400000 */
specifier|static
name|int
name|cp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
specifier|static
name|int
name|load_count
init|=
literal|0
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|cdsw
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502103
name|dev
operator|=
name|udev2dev
argument_list|(
name|makeudev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|dev
operator|!=
name|NODEV
operator|&&
operator|(
name|cdsw
operator|=
name|devsw
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
name|cdsw
operator|->
name|d_maj
operator|==
name|CDEV_MAJOR
condition|)
block|{
name|printf
argument_list|(
literal|"Tau-PCI driver is already in system\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|typestruct
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Failed to register ng_cp\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|load_count
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|500000
name|cdevsw_add
argument_list|(
operator|&
name|cp_cdevsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|load_count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Removing device entry for Tau-PCI\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<=
literal|500000
name|cdevsw_remove
argument_list|(
operator|&
name|cp_cdevsw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
operator|&&
name|defined
name|NETGRAPH
name|ng_rmtype
argument_list|(
operator|&
name|typestruct
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|untimeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|timeout_handle
argument_list|)
expr_stmt|;
operator|--
name|load_count
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* __FreeBSD_version< 400000 */
ifdef|#
directive|ifdef
name|NETGRAPH
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
name|NG_ABI_VERSION
block|,
else|#
directive|else
name|NG_VERSION
block|,
endif|#
directive|endif
name|NG_CP_NODE_TYPE
block|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
operator|&&
operator|(
name|defined
name|KLD_MODULE
operator|)
name|cp_modevent
block|,
else|#
directive|else
name|NULL
block|,
endif|#
directive|endif
name|ng_cp_constructor
block|,
name|ng_cp_rcvmsg
block|,
name|ng_cp_rmnode
block|,
name|ng_cp_newhook
block|,
name|NULL
block|,
name|ng_cp_connect
block|,
name|ng_cp_rcvdata
block|,
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|NULL
block|,
endif|#
directive|endif
name|ng_cp_disconnect
block|,
name|NULL
block|}
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
name|NETGRAPH_INIT_ORDERED
argument_list|(
name|cp
argument_list|,
operator|&
name|typestruct
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,\
name|SI_ORDER_MIDDLE
operator|+
name|CDEV_MAJOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/*NETGRAPH*/
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
ifdef|#
directive|ifdef
name|NETGRAPH
name|MODULE_DEPEND
argument_list|(
name|ng_cp
argument_list|,
name|netgraph
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|)
expr_stmt|;
else|#
directive|else
name|MODULE_DEPEND
argument_list|(
name|cp
argument_list|,
name|sppp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KLD_MODULE
name|DRIVER_MODULE
argument_list|(
name|cpmod
argument_list|,
name|pci
argument_list|,
name|cp_driver
argument_list|,
name|cp_devclass
argument_list|,
name|cp_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRIVER_MODULE
argument_list|(
name|cp
argument_list|,
name|pci
argument_list|,
name|cp_driver
argument_list|,
name|cp_devclass
argument_list|,
name|cp_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|__FreeBSD_version
operator|>=
literal|400000
ifdef|#
directive|ifdef
name|NETGRAPH
name|DRIVER_MODULE
argument_list|(
name|cp
argument_list|,
name|pci
argument_list|,
name|cp_driver
argument_list|,
name|cp_devclass
argument_list|,
name|ng_mod_event
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
else|#
directive|else
name|DRIVER_MODULE
argument_list|(
name|cp
argument_list|,
name|pci
argument_list|,
name|cp_driver
argument_list|,
name|cp_devclass
argument_list|,
name|cp_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* __FreeBSD_version< 400000 */
ifdef|#
directive|ifdef
name|KLD_MODULE
ifndef|#
directive|ifndef
name|NETGRAPH
specifier|static
name|moduledata_t
name|cpmod
init|=
block|{
literal|"cp"
block|,
name|cp_modevent
block|,
name|NULL
block|}
decl_stmt|;
name|DECLARE_MODULE
argument_list|(
name|cp
argument_list|,
name|cpmod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
operator|+
name|CDEV_MAJOR
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* KLD_MODULE */
comment|/*  * Now for some driver initialisation.  * Occurs ONCE during boot (very early).  * This is if we are NOT a loadable module.  */
specifier|static
name|void
name|cp_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|cp_cdevsw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Activate the timeout routine. */
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|cp_timeout
argument_list|,
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
if|#
directive|if
literal|0
comment|/* Register our node type in netgraph */
block|if (ng_newtype (&typestruct)) 		printf ("Failed to register ng_cp\n");
endif|#
directive|endif
endif|#
directive|endif
block|}
name|SYSINIT
argument_list|(
argument|cpdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|cp_drvinit
argument_list|,
literal|0
argument_list|)
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KLD_MODULE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD_version< 400000 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI */
end_comment

end_unit

