begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008, 2009 Michael Shalayeff  * Copyright (c) 2009, 2010 Hans-Joerg Hoexer  * All rights reserved.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* #define	TPM_DEBUG */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/conf.h>
end_include

begin_include
include|#
directive|include
file|<dev/isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/isa/isavar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/tpm/tpmvar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_comment
comment|/* XXX horrible hack for tcsd (-lpthread) workaround on OpenBSD */
end_comment

begin_undef
undef|#
directive|undef
name|PCATCH
end_undef

begin_define
define|#
directive|define
name|PCATCH
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TPM_BUFSIZ
value|1024
end_define

begin_define
define|#
directive|define
name|TPM_HDRSIZE
value|10
end_define

begin_define
define|#
directive|define
name|TPM_PARAM_SIZE
value|0x0001
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|IRQUNK
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TPM_ACCESS
value|0x0000
end_define

begin_comment
comment|/* acess register */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_ESTABLISHMENT
value|0x01
end_define

begin_comment
comment|/* establishment */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_REQUEST_USE
value|0x02
end_define

begin_comment
comment|/* request using locality */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_REQUEST_PENDING
value|0x04
end_define

begin_comment
comment|/* pending request */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_SEIZE
value|0x08
end_define

begin_comment
comment|/* request locality seize */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_SEIZED
value|0x10
end_define

begin_comment
comment|/* locality has been seized */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_ACTIVE_LOCALITY
value|0x20
end_define

begin_comment
comment|/* locality is active */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_VALID
value|0x80
end_define

begin_comment
comment|/* bits are valid */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_BITS
define|\
value|"\020\01EST\02REQ\03PEND\04SEIZE\05SEIZED\06ACT\010VALID"
end_define

begin_define
define|#
directive|define
name|TPM_INTERRUPT_ENABLE
value|0x0008
end_define

begin_define
define|#
directive|define
name|TPM_GLOBAL_INT_ENABLE
value|0x80000000
end_define

begin_comment
comment|/* enable ints */
end_comment

begin_define
define|#
directive|define
name|TPM_CMD_READY_INT
value|0x00000080
end_define

begin_comment
comment|/* cmd ready enable */
end_comment

begin_define
define|#
directive|define
name|TPM_INT_EDGE_FALLING
value|0x00000018
end_define

begin_define
define|#
directive|define
name|TPM_INT_EDGE_RISING
value|0x00000010
end_define

begin_define
define|#
directive|define
name|TPM_INT_LEVEL_LOW
value|0x00000008
end_define

begin_define
define|#
directive|define
name|TPM_INT_LEVEL_HIGH
value|0x00000000
end_define

begin_define
define|#
directive|define
name|TPM_LOCALITY_CHANGE_INT
value|0x00000004
end_define

begin_comment
comment|/* locality change enable */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_VALID_INT
value|0x00000002
end_define

begin_comment
comment|/* int on TPM_STS_VALID is set */
end_comment

begin_define
define|#
directive|define
name|TPM_DATA_AVAIL_INT
value|0x00000001
end_define

begin_comment
comment|/* int on TPM_STS_DATA_AVAIL is set */
end_comment

begin_define
define|#
directive|define
name|TPM_INTERRUPT_ENABLE_BITS
define|\
value|"\020\040ENA\010RDY\03LOCH\02STSV\01DRDY"
end_define

begin_define
define|#
directive|define
name|TPM_INT_VECTOR
value|0x000c
end_define

begin_comment
comment|/* 8 bit reg for 4 bit irq vector */
end_comment

begin_define
define|#
directive|define
name|TPM_INT_STATUS
value|0x0010
end_define

begin_comment
comment|/* bits are& 0x87 from TPM_INTERRUPT_ENABLE */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_CAPABILITIES
value|0x0014
end_define

begin_comment
comment|/* capability register */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_BURST_COUNT_STATIC
value|0x0100
end_define

begin_comment
comment|/* TPM_STS_BMASK static */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_CMD_READY_INT
value|0x0080
end_define

begin_comment
comment|/* int on ready supported */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_INT_EDGE_FALLING
value|0x0040
end_define

begin_comment
comment|/* falling edge ints supported */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_INT_EDGE_RISING
value|0x0020
end_define

begin_comment
comment|/* rising edge ints supported */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_INT_LEVEL_LOW
value|0x0010
end_define

begin_comment
comment|/* level-low ints supported */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_INT_LEVEL_HIGH
value|0x0008
end_define

begin_comment
comment|/* level-high ints supported */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_LOCALITY_CHANGE_INT
value|0x0004
end_define

begin_comment
comment|/* locality-change int (mb 1) */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_STS_VALID_INT
value|0x0002
end_define

begin_comment
comment|/* TPM_STS_VALID int supported */
end_comment

begin_define
define|#
directive|define
name|TPM_INTF_DATA_AVAIL_INT
value|0x0001
end_define

begin_comment
comment|/* TPM_STS_DATA_AVAIL int supported (mb 1) */
end_comment

begin_define
define|#
directive|define
name|TPM_CAPSREQ
define|\
value|(TPM_INTF_DATA_AVAIL_INT|TPM_INTF_LOCALITY_CHANGE_INT|TPM_INTF_INT_LEVEL_LOW)
end_define

begin_define
define|#
directive|define
name|TPM_CAPBITS
define|\
value|"\020\01IDRDY\02ISTSV\03ILOCH\04IHIGH\05ILOW\06IEDGE\07IFALL\010IRDY\011BCST"
end_define

begin_define
define|#
directive|define
name|TPM_STS
value|0x0018
end_define

begin_comment
comment|/* status register */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_MASK
value|0x000000ff
end_define

begin_comment
comment|/* status bits */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_BMASK
value|0x00ffff00
end_define

begin_comment
comment|/* ro io burst size */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_VALID
value|0x00000080
end_define

begin_comment
comment|/* ro other bits are valid */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_CMD_READY
value|0x00000040
end_define

begin_comment
comment|/* rw chip/signal ready */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_GO
value|0x00000020
end_define

begin_comment
comment|/* wo start the command */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_DATA_AVAIL
value|0x00000010
end_define

begin_comment
comment|/* ro data available */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_DATA_EXPECT
value|0x00000008
end_define

begin_comment
comment|/* ro more data to be written */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_RESP_RETRY
value|0x00000002
end_define

begin_comment
comment|/* wo resend the response */
end_comment

begin_define
define|#
directive|define
name|TPM_STS_BITS
value|"\020\010VALID\07RDY\06GO\05DRDY\04EXPECT\02RETRY"
end_define

begin_define
define|#
directive|define
name|TPM_DATA
value|0x0024
end_define

begin_define
define|#
directive|define
name|TPM_ID
value|0x0f00
end_define

begin_define
define|#
directive|define
name|TPM_REV
value|0x0f04
end_define

begin_define
define|#
directive|define
name|TPM_SIZE
value|0x5000
end_define

begin_comment
comment|/* five pages of the above */
end_comment

begin_define
define|#
directive|define
name|TPM_ACCESS_TMO
value|2000
end_define

begin_comment
comment|/* 2sec */
end_comment

begin_define
define|#
directive|define
name|TPM_READY_TMO
value|2000
end_define

begin_comment
comment|/* 2sec */
end_comment

begin_define
define|#
directive|define
name|TPM_READ_TMO
value|120000
end_define

begin_comment
comment|/* 2 minutes */
end_comment

begin_define
define|#
directive|define
name|TPM_BURST_TMO
value|2000
end_define

begin_comment
comment|/* 2sec */
end_comment

begin_define
define|#
directive|define
name|TPM_LEGACY_BUSY
value|0x01
end_define

begin_define
define|#
directive|define
name|TPM_LEGACY_ABRT
value|0x01
end_define

begin_define
define|#
directive|define
name|TPM_LEGACY_DA
value|0x02
end_define

begin_define
define|#
directive|define
name|TPM_LEGACY_RE
value|0x04
end_define

begin_define
define|#
directive|define
name|TPM_LEGACY_LAST
value|0x04
end_define

begin_define
define|#
directive|define
name|TPM_LEGACY_BITS
value|"\020\01BUSY\2DA\3RE\4LAST"
end_define

begin_define
define|#
directive|define
name|TPM_LEGACY_TMO
value|(2*60)
end_define

begin_comment
comment|/* sec */
end_comment

begin_define
define|#
directive|define
name|TPM_LEGACY_SLEEP
value|5
end_define

begin_comment
comment|/* ticks */
end_comment

begin_define
define|#
directive|define
name|TPM_LEGACY_DELAY
value|100
end_define

begin_comment
comment|/* Set when enabling legacy interface in host bridge. */
end_comment

begin_decl_stmt
name|int
name|tpm_enabled
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|TPMSOFTC
parameter_list|(
name|dev
parameter_list|)
define|\
value|((struct tpm_softc *)dev->si_drv1)
end_define

begin_decl_stmt
name|d_open_t
name|tpmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_close_t
name|tpmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_read_t
name|tpmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_write_t
name|tpmwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|d_ioctl_t
name|tpmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|tpm_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|tpmopen
block|,
operator|.
name|d_close
operator|=
name|tpmclose
block|,
operator|.
name|d_read
operator|=
name|tpmread
block|,
operator|.
name|d_write
operator|=
name|tpmwrite
block|,
operator|.
name|d_ioctl
operator|=
name|tpmioctl
block|,
operator|.
name|d_name
operator|=
literal|"tpm"
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TPMSOFTC
parameter_list|(
name|dev
parameter_list|)
define|\
value|(struct tpm_softc *)device_lookup(&tpm_cd, minor(dev))
end_define

begin_decl_stmt
name|struct
name|cfdriver
name|tpm_cd
init|=
block|{
name|NULL
block|,
literal|"tpm"
block|,
name|DV_DULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|tpm_match
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tpm_attach
parameter_list|(
name|struct
name|device
modifier|*
parameter_list|,
name|struct
name|device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cfattach
name|tpm_ca
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|tpm_softc
argument_list|)
block|,
name|tpm_match
block|,
name|tpm_attach
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|const
struct|struct
block|{
name|u_int32_t
name|devid
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|TPM_DEV_NOINTS
value|0x0001
block|}
name|tpm_devs
index|[]
init|=
block|{
block|{
literal|0x000615d1
block|,
literal|"IFX SLD 9630 TT 1.1"
block|,
literal|0
block|}
block|,
block|{
literal|0x000b15d1
block|,
literal|"IFX SLB 9635 TT 1.2"
block|,
literal|0
block|}
block|,
block|{
literal|0x100214e4
block|,
literal|"Broadcom BCM0102"
block|,
name|TPM_DEV_NOINTS
block|}
block|,
block|{
literal|0x00fe1050
block|,
literal|"WEC WPCT200"
block|,
literal|0
block|}
block|,
block|{
literal|0x687119fa
block|,
literal|"SNS SSX35"
block|,
literal|0
block|}
block|,
block|{
literal|0x2e4d5453
block|,
literal|"STM ST19WP18"
block|,
literal|0
block|}
block|,
block|{
literal|0x32021114
block|,
literal|"ATML 97SC3203"
block|,
name|TPM_DEV_NOINTS
block|}
block|,
block|{
literal|0x10408086
block|,
literal|"INTEL INTC0102"
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|""
block|,
name|TPM_DEV_NOINTS
block|}
block|, }
struct|;
end_struct

begin_function_decl
name|int
name|tpm_tis12_irqinit
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_tis12_init
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_tis12_start
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_tis12_read
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_tis12_write
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_tis12_end
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function_decl
name|void
name|tpm_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|tpm_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tpm_powerhook
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_suspend
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_resume
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|tpm_waitfor_poll
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_waitfor_int
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_waitfor
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_request_locality
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_getburst
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|tpm_status
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_tmotohz
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_legacy_probe
parameter_list|(
name|bus_space_tag_t
parameter_list|,
name|bus_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_legacy_init
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_legacy_start
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_legacy_read
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_legacy_write
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tpm_legacy_end
parameter_list|(
name|struct
name|tpm_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * FreeBSD specific code for probing and attaching TPM to device tree.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void tpm_identify(driver_t *driver, device_t parent) { 	BUS_ADD_CHILD(parent, ISA_ORDER_SPECULATIVE, "tpm", 0); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|tpm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|sc
operator|->
name|sc_bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
name|irq
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
else|else
name|irq
operator|=
name|IRQUNK
expr_stmt|;
comment|/* In case PnP probe this may contain some initialization. */
name|tpm_tis12_probe
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpm_legacy_probe
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_init
operator|=
name|tpm_legacy_init
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|tpm_legacy_start
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
name|tpm_legacy_read
expr_stmt|;
name|sc
operator|->
name|sc_write
operator|=
name|tpm_legacy_write
expr_stmt|;
name|sc
operator|->
name|sc_end
operator|=
name|tpm_legacy_end
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_init
operator|=
name|tpm_tis12_init
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|tpm_tis12_start
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
name|tpm_tis12_read
expr_stmt|;
name|sc
operator|->
name|sc_write
operator|=
name|tpm_tis12_write
expr_stmt|;
name|sc
operator|->
name|sc_end
operator|=
name|tpm_tis12_end
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|sc
operator|->
name|sc_init
call|)
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
literal|"tpm"
argument_list|)
condition|)
block|{
name|tpm_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_init
operator|==
name|tpm_tis12_init
operator|&&
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
operator|&&
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|NULL
argument_list|,
name|tpm_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_cookie
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tpm_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": cannot establish interrupt\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sc
operator|->
name|sc_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|tpm_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"tpm"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_cookie
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|sc
operator|->
name|sc_cdev
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * OpenBSD specific code for probing and attaching TPM to device tree.  */
end_comment

begin_function
name|int
name|tpm_match
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|void
modifier|*
name|match
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|isa_attach_args
modifier|*
name|ia
init|=
name|aux
decl_stmt|;
name|struct
name|cfdata
modifier|*
name|cf
init|=
name|match
decl_stmt|;
name|bus_space_tag_t
name|bt
init|=
name|ia
operator|->
name|ia_memt
decl_stmt|;
name|bus_space_handle_t
name|bh
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* There can be only one. */
if|if
condition|(
name|cf
operator|->
name|cf_unit
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tpm_legacy_probe
argument_list|(
name|ia
operator|->
name|ia_iot
argument_list|,
name|ia
operator|->
name|ia_iobase
argument_list|)
condition|)
block|{
name|ia
operator|->
name|ia_iosize
operator|=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ia
operator|->
name|ia_maddr
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|bt
argument_list|,
name|ia
operator|->
name|ia_maddr
argument_list|,
name|TPM_SIZE
argument_list|,
literal|0
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_tis12_probe
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|)
operator|)
condition|)
block|{
name|ia
operator|->
name|ia_iosize
operator|=
literal|0
expr_stmt|;
name|ia
operator|->
name|ia_msize
operator|=
name|TPM_SIZE
expr_stmt|;
block|}
name|bus_space_unmap
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_SIZE
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|tpm_attach
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|self
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|tpm_softc
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|isa_attach_args
modifier|*
name|ia
init|=
name|aux
decl_stmt|;
name|bus_addr_t
name|iobase
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|tpm_legacy_probe
argument_list|(
name|ia
operator|->
name|ia_iot
argument_list|,
name|ia
operator|->
name|ia_iobase
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_bt
operator|=
name|ia
operator|->
name|ia_iot
expr_stmt|;
name|iobase
operator|=
name|ia
operator|->
name|ia_iobase
expr_stmt|;
name|size
operator|=
name|ia
operator|->
name|ia_iosize
expr_stmt|;
name|sc
operator|->
name|sc_batm
operator|=
name|ia
operator|->
name|ia_iot
expr_stmt|;
name|sc
operator|->
name|sc_init
operator|=
name|tpm_legacy_init
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|tpm_legacy_start
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
name|tpm_legacy_read
expr_stmt|;
name|sc
operator|->
name|sc_write
operator|=
name|tpm_legacy_write
expr_stmt|;
name|sc
operator|->
name|sc_end
operator|=
name|tpm_legacy_end
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_bt
operator|=
name|ia
operator|->
name|ia_memt
expr_stmt|;
name|iobase
operator|=
name|ia
operator|->
name|ia_maddr
expr_stmt|;
name|size
operator|=
name|TPM_SIZE
expr_stmt|;
name|sc
operator|->
name|sc_init
operator|=
name|tpm_tis12_init
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|tpm_tis12_start
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
name|tpm_tis12_read
expr_stmt|;
name|sc
operator|->
name|sc_write
operator|=
name|tpm_tis12_write
expr_stmt|;
name|sc
operator|->
name|sc_end
operator|=
name|tpm_tis12_end
expr_stmt|;
block|}
if|if
condition|(
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|iobase
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_bh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": cannot map registers\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_init
call|)
argument_list|(
name|sc
argument_list|,
name|ia
operator|->
name|ia_irq
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
operator|)
condition|)
block|{
name|bus_space_unmap
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Only setup interrupt handler when we have a vector and the 	 * chip is TIS 1.2 compliant. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_init
operator|==
name|tpm_tis12_init
operator|&&
name|ia
operator|->
name|ia_irq
operator|!=
name|IRQUNK
operator|&&
operator|(
name|sc
operator|->
name|sc_ih
operator|=
name|isa_intr_establish
argument_list|(
name|ia
operator|->
name|ia_ic
argument_list|,
name|ia
operator|->
name|ia_irq
argument_list|,
name|IST_EDGE
argument_list|,
name|IPL_TTY
argument_list|,
name|tpm_intr
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bus_space_unmap
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_SIZE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cannot establish interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|sc
operator|->
name|sc_suspend
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_suspend
operator|=
name|PWR_RESUME
expr_stmt|;
name|sc
operator|->
name|sc_powerhook
operator|=
name|powerhook_establish
argument_list|(
name|tpm_powerhook
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Probe TPM using TIS 1.2 interface. */
end_comment

begin_function
name|int
name|tpm_tis12_probe
parameter_list|(
name|bus_space_tag_t
name|bt
parameter_list|,
name|bus_space_handle_t
name|bh
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|u_int8_t
name|save
decl_stmt|,
name|reg
decl_stmt|;
name|r
operator|=
name|bus_space_read_4
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_INTF_CAPABILITIES
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0xffffffff
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm: caps=%b\n"
argument_list|,
name|r
argument_list|,
name|TPM_CAPBITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|r
operator|&
name|TPM_CAPSREQ
operator|)
operator|!=
name|TPM_CAPSREQ
operator|||
operator|!
operator|(
name|r
operator|&
operator|(
name|TPM_INTF_INT_EDGE_RISING
operator||
name|TPM_INTF_INT_LEVEL_LOW
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm: caps too low (caps=%b)\n"
argument_list|,
name|r
argument_list|,
name|TPM_CAPBITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|save
operator|=
name|bus_space_read_1
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_ACCESS
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_ACCESS
argument_list|,
name|TPM_ACCESS_REQUEST_USE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|bus_space_read_1
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_ACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|TPM_ACCESS_VALID
operator|)
operator|&&
operator|(
name|reg
operator|&
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
operator|&&
name|bus_space_read_4
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_ID
argument_list|)
operator|!=
literal|0xffffffff
condition|)
return|return
literal|1
return|;
name|bus_space_write_1
argument_list|(
name|bt
argument_list|,
name|bh
argument_list|,
name|TPM_ACCESS
argument_list|,
name|save
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Setup interrupt vector if one is provided and interrupts are know to  * work on that particular chip.  */
end_comment

begin_function
name|int
name|tpm_tis12_irqinit
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|irq
operator|==
name|IRQUNK
operator|)
operator|||
operator|(
name|tpm_devs
index|[
name|idx
index|]
operator|.
name|flags
operator|&
name|TPM_DEV_NOINTS
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_vector
operator|=
name|IRQUNK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Ack and disable all interrupts. */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|)
operator|&
operator|~
name|TPM_GLOBAL_INT_ENABLE
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INT_STATUS
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INT_STATUS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program interrupt vector. */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INT_VECTOR
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_vector
operator|=
name|irq
expr_stmt|;
comment|/* Program interrupt type. */
if|if
condition|(
name|sc
operator|->
name|sc_capabilities
operator|&
name|TPM_INTF_INT_EDGE_RISING
condition|)
name|r
operator|=
name|TPM_INT_EDGE_RISING
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_capabilities
operator|&
name|TPM_INTF_INT_LEVEL_HIGH
condition|)
name|r
operator|=
name|TPM_INT_LEVEL_HIGH
expr_stmt|;
else|else
name|r
operator|=
name|TPM_INT_LEVEL_LOW
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Setup TPM using TIS 1.2 interface. */
end_comment

begin_function
name|int
name|tpm_tis12_init
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|r
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTF_CAPABILITIES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|" caps=%b "
argument_list|,
name|r
argument_list|,
name|TPM_CAPBITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|r
operator|&
name|TPM_CAPSREQ
operator|)
operator|!=
name|TPM_CAPSREQ
operator|||
operator|!
operator|(
name|r
operator|&
operator|(
name|TPM_INTF_INT_EDGE_RISING
operator||
name|TPM_INTF_INT_LEVEL_LOW
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": capabilities too low (caps=%b)\n"
argument_list|,
name|r
argument_list|,
name|TPM_CAPBITS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sc
operator|->
name|sc_capabilities
operator|=
name|r
expr_stmt|;
name|sc
operator|->
name|sc_devid
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_ID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rev
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_REV
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tpm_devs
index|[
name|i
index|]
operator|.
name|devid
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tpm_devs
index|[
name|i
index|]
operator|.
name|devid
operator|==
name|sc
operator|->
name|sc_devid
condition|)
break|break;
if|if
condition|(
name|tpm_devs
index|[
name|i
index|]
operator|.
name|devid
condition|)
name|printf
argument_list|(
literal|": %s rev 0x%x\n"
argument_list|,
name|tpm_devs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sc
operator|->
name|sc_rev
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|": device 0x%08x rev 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_devid
argument_list|,
name|sc
operator|->
name|sc_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpm_tis12_irqinit
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|tpm_request_locality
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Abort whatever it thought it was doing. */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
argument_list|,
name|TPM_STS_CMD_READY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_request_locality
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|int
name|to
decl_stmt|,
name|rv
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_ACCESS
argument_list|)
operator|&
operator|(
name|TPM_ACCESS_VALID
operator||
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
operator|)
operator|==
operator|(
name|TPM_ACCESS_VALID
operator||
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
condition|)
return|return
literal|0
return|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_ACCESS
argument_list|,
name|TPM_ACCESS_REQUEST_USE
argument_list|)
expr_stmt|;
name|to
operator|=
name|tpm_tmotohz
argument_list|(
name|TPM_ACCESS_TMO
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_ACCESS
argument_list|)
operator|&
operator|(
name|TPM_ACCESS_VALID
operator||
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
operator|)
operator|!=
operator|(
name|TPM_ACCESS_VALID
operator||
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
operator|&&
name|to
operator|--
condition|)
block|{
name|rv
operator|=
name|tsleep
argument_list|(
name|sc
operator|->
name|sc_init
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"tpm_locality"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&&
name|rv
operator|!=
name|EWOULDBLOCK
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_request_locality: interrupted %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
block|}
if|if
condition|(
operator|(
name|r
operator|&
operator|(
name|TPM_ACCESS_VALID
operator||
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
operator|)
operator|!=
operator|(
name|TPM_ACCESS_VALID
operator||
name|TPM_ACCESS_ACTIVE_LOCALITY
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_request_locality: access %b\n"
argument_list|,
name|r
argument_list|,
name|TPM_ACCESS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EBUSY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_getburst
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|burst
decl_stmt|,
name|to
decl_stmt|,
name|rv
decl_stmt|;
name|to
operator|=
name|tpm_tmotohz
argument_list|(
name|TPM_BURST_TMO
argument_list|)
expr_stmt|;
name|burst
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|burst
operator|==
literal|0
operator|&&
name|to
operator|--
condition|)
block|{
comment|/* 		 * Burst count has to be read from bits 8 to 23 without 		 * touching any other bits, eg. the actual status bits 0 		 * to 7. 		 */
name|burst
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|burst
operator||=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
operator|+
literal|2
argument_list|)
operator|<<
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_getburst: read %d\n"
argument_list|,
name|burst
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|burst
condition|)
return|return
name|burst
return|;
name|rv
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"tpm_getburst"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&&
name|rv
operator|!=
name|EWOULDBLOCK
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|u_int8_t
name|tpm_status
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|status
decl_stmt|;
name|status
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
argument_list|)
operator|&
name|TPM_STS_MASK
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|tpm_tmotohz
parameter_list|(
name|int
name|tmo
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|tmo
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|1000
operator|*
operator|(
name|tmo
operator|%
literal|1000
operator|)
expr_stmt|;
return|return
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Save TPM state on suspend. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpm_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
else|#
directive|else
function|tpm_suspend
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|why
parameter_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|why
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
name|command
index|[]
init|=
block|{
literal|0
block|,
literal|193
block|,
comment|/* TPM_TAG_RQU_COMMAND */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
comment|/* Length in bytes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|156
comment|/* TPM_ORD_SaveStates */
block|}
decl_stmt|;
comment|/* 	 * Power down:  We have to issue the SaveStates command. 	 */
name|sc
operator|->
name|sc_write
argument_list|(
name|sc
argument_list|,
operator|&
name|command
argument_list|,
sizeof|sizeof
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_read
argument_list|(
name|sc
argument_list|,
operator|&
name|command
argument_list|,
sizeof|sizeof
argument_list|(
name|command
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|TPM_HDRSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_suspend: power down: %d -> %d\n"
argument_list|,
name|sc
operator|->
name|sc_suspend
argument_list|,
name|why
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_suspend
operator|=
name|why
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handle resume event.  Actually nothing to do as the BIOS is supposed  * to restore the previously saved state.  */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpm_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
else|#
directive|else
function|tpm_resume
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|why
parameter_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|why
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_resume: resume: %d -> %d\n"
argument_list|,
name|sc
operator|->
name|sc_suspend
argument_list|,
name|why
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_suspend
operator|=
name|why
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dispatch suspend and resume events. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_function
name|void
name|tpm_powerhook
parameter_list|(
name|int
name|why
parameter_list|,
name|void
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|tpm_softc
operator|*
operator|)
name|self
decl_stmt|;
if|if
condition|(
name|why
operator|!=
name|PWR_RESUME
condition|)
name|tpm_suspend
argument_list|(
name|sc
argument_list|,
name|why
argument_list|)
expr_stmt|;
else|else
name|tpm_resume
argument_list|(
name|sc
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__FreeBSD__ */
end_comment

begin_comment
comment|/* Wait for given status bits using polling. */
end_comment

begin_function
name|int
name|tpm_waitfor_poll
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|mask
parameter_list|,
name|int
name|tmo
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
comment|/* 	 * Poll until either the requested condition or a time out is 	 * met. 	 */
while|while
condition|(
operator|(
operator|(
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
operator|)
operator|&
name|mask
operator|)
operator|!=
name|mask
operator|&&
name|tmo
operator|--
condition|)
block|{
name|rv
operator|=
name|tsleep
argument_list|(
name|c
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"tpm_poll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&&
name|rv
operator|!=
name|EWOULDBLOCK
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_waitfor_poll: interrupted %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for given status bits using interrupts. */
end_comment

begin_function
name|int
name|tpm_waitfor_int
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|mask
parameter_list|,
name|int
name|tmo
parameter_list|,
name|void
modifier|*
name|c
parameter_list|,
name|int
name|inttype
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|to
decl_stmt|;
comment|/* Poll and return when condition is already met. */
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
literal|0
return|;
comment|/* 	 * Enable interrupt on tpm chip.  Note that interrupts on our 	 * level (SPL_TTY) are disabled (see tpm{read,write} et al) and 	 * will not be delivered to the cpu until we call tsleep(9) below. 	 */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|)
operator||
name|inttype
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|)
operator||
name|TPM_GLOBAL_INT_ENABLE
argument_list|)
expr_stmt|;
comment|/* 	 * Poll once more to remedy the race between previous polling 	 * and enabling interrupts on the tpm chip. 	 */
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
block|{
name|rv
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|to
operator|=
name|tpm_tmotohz
argument_list|(
name|tmo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_waitfor_int: sleeping for %d ticks on %p\n"
argument_list|,
name|to
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * tsleep(9) enables interrupts on the cpu and returns after 	 * wake up with interrupts disabled again.  Note that interrupts 	 * generated by the tpm chip while being at SPL_TTY are not lost 	 * but held and delivered as soon as the cpu goes below SPL_TTY. 	 */
name|rv
operator|=
name|tsleep
argument_list|(
name|c
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"tpm_intr"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_waitfor_int: woke up with rv %d stat %b\n"
argument_list|,
name|rv
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts on tpm chip again. */
name|out
label|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|)
operator|&
operator|~
name|TPM_GLOBAL_INT_ENABLE
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|,
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INTERRUPT_ENABLE
argument_list|)
operator|&
operator|~
name|inttype
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Wait on given status bits, uses interrupts where possible, otherwise polls.  */
end_comment

begin_function
name|int
name|tpm_waitfor
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|b0
parameter_list|,
name|int
name|tmo
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|u_int8_t
name|b
decl_stmt|;
name|int
name|re
decl_stmt|,
name|to
decl_stmt|,
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_waitfor: b0 %b\n"
argument_list|,
name|b0
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If possible, use interrupts, otherwise poll. 	 * 	 * We use interrupts for TPM_STS_VALID and TPM_STS_DATA_AVAIL (if 	 * the tpm chips supports them) as waiting for those can take 	 * really long.  The other TPM_STS* are not needed very often 	 * so we do not support them. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_vector
operator|!=
name|IRQUNK
condition|)
block|{
name|b
operator|=
name|b0
expr_stmt|;
comment|/* 		 * Wait for data ready.  This interrupt only occures 		 * when both TPM_STS_VALID and TPM_STS_DATA_AVAIL are asserted. 		 * Thus we don't have to bother with TPM_STS_VALID 		 * separately and can just return. 		 * 		 * This only holds for interrupts!  When using polling 		 * both flags have to be waited for, see below. 		 */
if|if
condition|(
operator|(
name|b
operator|&
name|TPM_STS_DATA_AVAIL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_capabilities
operator|&
name|TPM_INTF_DATA_AVAIL_INT
operator|)
condition|)
return|return
name|tpm_waitfor_int
argument_list|(
name|sc
argument_list|,
name|b
argument_list|,
name|tmo
argument_list|,
name|c
argument_list|,
name|TPM_DATA_AVAIL_INT
argument_list|)
return|;
comment|/* Wait for status valid bit. */
if|if
condition|(
operator|(
name|b
operator|&
name|TPM_STS_VALID
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_capabilities
operator|&
name|TPM_INTF_STS_VALID_INT
operator|)
condition|)
block|{
name|rv
operator|=
name|tpm_waitfor_int
argument_list|(
name|sc
argument_list|,
name|b
argument_list|,
name|tmo
argument_list|,
name|c
argument_list|,
name|TPM_STS_VALID_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
else|else
name|b
operator|=
name|b0
operator|&
operator|~
name|TPM_STS_VALID
expr_stmt|;
block|}
comment|/* 		 * When all flags are taken care of, return.  Otherwise 		 * use polling for eg. TPM_STS_CMD_READY. 		 */
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|re
operator|=
literal|3
expr_stmt|;
name|restart
label|:
comment|/* 	 * If requested wait for TPM_STS_VALID before dealing with 	 * any other flag.  Eg. when both TPM_STS_DATA_AVAIL and TPM_STS_VALID 	 * are requested, wait for the latter first. 	 */
name|b
operator|=
name|b0
expr_stmt|;
if|if
condition|(
name|b0
operator|&
name|TPM_STS_VALID
condition|)
name|b
operator|=
name|TPM_STS_VALID
expr_stmt|;
name|to
operator|=
name|tpm_tmotohz
argument_list|(
name|tmo
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_waitfor_poll
argument_list|(
name|sc
argument_list|,
name|b
argument_list|,
name|to
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
if|if
condition|(
operator|(
name|b
operator|&
name|sc
operator|->
name|sc_stat
operator|)
operator|==
name|TPM_STS_VALID
condition|)
block|{
comment|/* Now wait for other flags. */
name|b
operator|=
name|b0
operator|&
operator|~
name|TPM_STS_VALID
expr_stmt|;
name|to
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|b
operator|)
operator|!=
name|b
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_waitfor: timeout: stat=%b b=%b\n"
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|,
name|b
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|re
operator|--
operator|&&
operator|(
name|b0
operator|&
name|TPM_STS_VALID
operator|)
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
argument_list|,
name|TPM_STS_RESP_RETRY
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
return|return
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Start transaction. */
end_comment

begin_function
name|int
name|tpm_tis12_start
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|UIO_READ
condition|)
block|{
name|rv
operator|=
name|tpm_waitfor
argument_list|(
name|sc
argument_list|,
name|TPM_STS_DATA_AVAIL
operator||
name|TPM_STS_VALID
argument_list|,
name|TPM_READ_TMO
argument_list|,
name|sc
operator|->
name|sc_read
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
comment|/* Own our (0th) locality. */
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_request_locality
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stat
operator|&
name|TPM_STS_CMD_READY
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_start: UIO_WRITE status %b\n"
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_start: UIO_WRITE readying chip\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Abort previous and restart. */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
argument_list|,
name|TPM_STS_CMD_READY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_waitfor
argument_list|(
name|sc
argument_list|,
name|TPM_STS_CMD_READY
argument_list|,
name|TPM_READY_TMO
argument_list|,
name|sc
operator|->
name|sc_write
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_start: UIO_WRITE readying failed %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_start: UIO_WRITE readying done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_tis12_read
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|n
decl_stmt|,
name|bcnt
decl_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_read: len %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_waitfor
argument_list|(
name|sc
argument_list|,
name|TPM_STS_DATA_AVAIL
operator||
name|TPM_STS_VALID
argument_list|,
name|TPM_READ_TMO
argument_list|,
name|sc
operator|->
name|sc_read
argument_list|)
operator|)
condition|)
return|return
name|rv
return|;
name|bcnt
operator|=
name|tpm_getburst
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_read: fetching %d, burst is %d\n"
argument_list|,
name|n
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|n
operator|--
condition|;
name|len
operator|--
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_DATA
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TPM_PARAM_SIZE
operator|)
operator|==
literal|0
operator|&&
name|cnt
operator|>=
literal|6
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_read: read %zd bytes, len %d\n"
argument_list|,
name|cnt
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
condition|)
operator|*
name|count
operator|=
name|cnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_tis12_write
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_write: sc %p buf %p len %d\n"
argument_list|,
name|sc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_request_locality
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|r
operator|=
name|tpm_getburst
argument_list|(
name|sc
argument_list|)
init|;
name|r
operator|>
literal|0
operator|&&
name|cnt
operator|<
name|len
operator|-
literal|1
condition|;
name|r
operator|--
control|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_DATA
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_waitfor
argument_list|(
name|sc
argument_list|,
name|TPM_STS_VALID
argument_list|,
name|TPM_READ_TMO
argument_list|,
name|sc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_write: failed burst rv %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|TPM_STS_DATA_EXPECT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_write: failed rv %d stat=%b\n"
argument_list|,
name|rv
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EIO
return|;
block|}
block|}
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_DATA
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_waitfor
argument_list|(
name|sc
argument_list|,
name|TPM_STS_VALID
argument_list|,
name|TPM_READ_TMO
argument_list|,
name|sc
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_write: failed last byte rv %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|TPM_STS_DATA_EXPECT
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_write: failed rv %d stat=%b\n"
argument_list|,
name|rv
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|EIO
return|;
block|}
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_write: wrote %d byte\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Finish transaction. */
end_comment

begin_function
name|int
name|tpm_tis12_end
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|UIO_READ
condition|)
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|tpm_waitfor
argument_list|(
name|sc
argument_list|,
name|TPM_STS_VALID
argument_list|,
name|TPM_READ_TMO
argument_list|,
name|sc
operator|->
name|sc_read
argument_list|)
operator|)
condition|)
return|return
name|rv
return|;
comment|/* Still more data? */
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|TPM_STS_DATA_AVAIL
operator|)
operator|==
name|TPM_STS_DATA_AVAIL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_end: read failed stat=%b\n"
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
name|EIO
expr_stmt|;
block|}
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
argument_list|,
name|TPM_STS_CMD_READY
argument_list|)
expr_stmt|;
comment|/* Release our (0th) locality. */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_ACCESS
argument_list|,
name|TPM_ACCESS_ACTIVE_LOCALITY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Hungry for more? */
name|sc
operator|->
name|sc_stat
operator|=
name|tpm_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
name|sc
operator|->
name|sc_stat
operator|&
name|TPM_STS_DATA_EXPECT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_tis12_end: write failed stat=%b\n"
argument_list|,
name|sc
operator|->
name|sc_stat
argument_list|,
name|TPM_STS_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
name|EIO
expr_stmt|;
block|}
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_STS
argument_list|,
name|err
condition|?
name|TPM_STS_CMD_READY
else|:
name|TPM_STS_GO
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
name|void
else|#
directive|else
name|int
endif|#
directive|endif
name|tpm_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|u_int32_t
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
specifier|static
name|int
name|cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|r
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INT_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"tpm_intr: int=%b (%d)\n"
argument_list|,
name|r
argument_list|,
name|TPM_INTERRUPT_ENABLE_BITS
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|r
operator|&
operator|(
name|TPM_CMD_READY_INT
operator||
name|TPM_LOCALITY_CHANGE_INT
operator||
name|TPM_STS_VALID_INT
operator||
name|TPM_DATA_AVAIL_INT
operator|)
operator|)
condition|)
ifdef|#
directive|ifdef
name|__FreeBSD__
return|return;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|&
name|TPM_STS_VALID_INT
condition|)
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|TPM_CMD_READY_INT
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|sc_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|TPM_DATA_AVAIL_INT
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|sc_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|TPM_LOCALITY_CHANGE_INT
condition|)
name|wakeup
argument_list|(
name|sc
operator|->
name|sc_init
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_INT_STATUS
argument_list|,
name|r
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
return|return;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Read single byte using legacy interface. */
end_comment

begin_function
specifier|static
specifier|inline
name|u_int8_t
name|tpm_legacy_in
parameter_list|(
name|bus_space_tag_t
name|iot
parameter_list|,
name|bus_space_handle_t
name|ioh
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Write single byte using legacy interface. */
end_comment

begin_endif
unit|static inline void tpm_legacy_out(bus_space_tag_t iot, bus_space_handle_t ioh, int reg, u_int8_t v) { 	bus_space_write_1(iot, ioh, 0, reg); 	bus_space_write_1(iot, ioh, 1, v); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Probe for TPM using legacy interface. */
end_comment

begin_function
name|int
name|tpm_legacy_probe
parameter_list|(
name|bus_space_tag_t
name|iot
parameter_list|,
name|bus_addr_t
name|iobase
parameter_list|)
block|{
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|u_int8_t
name|r
decl_stmt|,
name|v
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
name|char
name|id
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|tpm_enabled
operator|||
name|iobase
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|iot
argument_list|,
name|iobase
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
operator|&
name|ioh
argument_list|)
condition|)
return|return
literal|0
return|;
name|v
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0xff
condition|)
block|{
name|bus_space_unmap
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|r
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|id
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|id
index|[
name|i
index|]
operator|=
name|tpm_legacy_in
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|TPM_ID
operator|+
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpm_legacy_probe %.4s %d.%d.%d.%d\n"
argument_list|,
operator|&
name|id
index|[
literal|4
index|]
argument_list|,
name|id
index|[
literal|0
index|]
argument_list|,
name|id
index|[
literal|1
index|]
argument_list|,
name|id
index|[
literal|2
index|]
argument_list|,
name|id
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The only chips using the legacy interface we are aware of are 	 * by Atmel.  For other chips more signature would have to be added. 	 */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|&
name|id
index|[
literal|4
index|]
argument_list|,
literal|"ATML"
argument_list|,
literal|4
argument_list|)
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bus_space_unmap
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* Setup TPM using legacy interface. */
end_comment

begin_function
name|int
name|tpm_legacy_init
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|id
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|ioh
decl_stmt|,
name|iol
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|tpm_enabled
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_bahm
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": cannot map tpm registers (%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tpm_enabled
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|id
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|id
index|[
name|i
index|]
operator|=
name|tpm_legacy_in
argument_list|(
name|sc
operator|->
name|sc_bt
argument_list|,
name|sc
operator|->
name|sc_bh
argument_list|,
name|TPM_ID
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %.4s %d.%d @0x%x\n"
argument_list|,
operator|&
name|id
index|[
literal|4
index|]
argument_list|,
name|id
index|[
literal|0
index|]
argument_list|,
name|id
index|[
literal|1
index|]
argument_list|,
name|tpm_enabled
argument_list|)
expr_stmt|;
name|iol
operator|=
name|tpm_enabled
operator|&
literal|0xff
expr_stmt|;
name|ioh
operator|=
name|tpm_enabled
operator|>>
literal|16
expr_stmt|;
name|tpm_enabled
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Start transaction. */
end_comment

begin_function
name|int
name|tpm_legacy_start
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|u_int8_t
name|bits
decl_stmt|,
name|r
decl_stmt|;
name|int
name|to
decl_stmt|,
name|rv
decl_stmt|;
name|bits
operator|=
name|flag
operator|==
name|UIO_READ
condition|?
name|TPM_LEGACY_DA
else|:
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|TPM_LEGACY_TMO
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|to
operator|=
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
operator|/
name|TPM_LEGACY_SLEEP
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|r
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
operator|(
name|TPM_LEGACY_BUSY
operator||
name|bits
operator|)
operator|)
operator|!=
name|bits
operator|&&
name|to
operator|--
condition|)
block|{
name|rv
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"legacy_tpm_start"
argument_list|,
name|TPM_LEGACY_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&&
name|rv
operator|!=
name|EWOULDBLOCK
condition|)
return|return
name|rv
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TPM_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printf
argument_list|(
literal|"%s: bits %b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|r
argument_list|,
name|TPM_LEGACY_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|r
operator|&
operator|(
name|TPM_LEGACY_BUSY
operator||
name|bits
operator|)
operator|)
operator|!=
name|bits
condition|)
return|return
name|EIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_legacy_read
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|int
name|to
decl_stmt|,
name|rv
decl_stmt|;
name|cnt
operator|=
name|rv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|!
name|rv
operator|&&
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
for|for
control|(
name|to
operator|=
literal|1000
init|;
operator|!
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|1
argument_list|)
operator|&
name|TPM_LEGACY_DA
operator|)
condition|;
name|DELAY
argument_list|(
literal|1
argument_list|)
control|)
if|if
condition|(
operator|!
name|to
operator|--
condition|)
return|return
name|EIO
return|;
name|DELAY
argument_list|(
name|TPM_LEGACY_DELAY
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
operator|*
name|count
operator|=
name|cnt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tpm_legacy_write
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|p
operator|=
name|buf
operator|,
name|n
operator|=
name|len
init|;
name|n
operator|--
condition|;
name|DELAY
argument_list|(
name|TPM_LEGACY_DELAY
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|n
operator|&&
name|len
operator|!=
name|TPM_BUFSIZ
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|1
argument_list|,
name|TPM_LEGACY_LAST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|TPM_LEGACY_DELAY
argument_list|)
expr_stmt|;
block|}
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|0
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Finish transaction. */
end_comment

begin_function
name|int
name|tpm_legacy_end
parameter_list|(
name|struct
name|tpm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|rv
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|u_int8_t
name|r
decl_stmt|;
name|int
name|to
decl_stmt|;
if|if
condition|(
name|rv
operator|||
name|flag
operator|==
name|UIO_READ
condition|)
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|1
argument_list|,
name|TPM_LEGACY_ABRT
argument_list|)
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|TPM_LEGACY_TMO
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|to
operator|=
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
operator|/
name|TPM_LEGACY_SLEEP
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|r
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_batm
argument_list|,
name|sc
operator|->
name|sc_bahm
argument_list|,
literal|1
argument_list|)
operator|)
operator|&
name|TPM_LEGACY_BUSY
operator|)
operator|&&
name|to
operator|--
condition|)
block|{
name|rv
operator|=
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"legacy_tpm_end"
argument_list|,
name|TPM_LEGACY_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|&&
name|rv
operator|!=
name|EWOULDBLOCK
condition|)
return|return
name|rv
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TPM_DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printf
argument_list|(
literal|"%s: bits %b\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|r
argument_list|,
name|TPM_LEGACY_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|&
name|TPM_LEGACY_BUSY
condition|)
return|return
name|EIO
return|;
if|if
condition|(
name|r
operator|&
name|TPM_LEGACY_RE
condition|)
return|return
name|EIO
return|;
comment|/* XXX Retry the loop? */
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpmopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
else|#
directive|else
function|tpmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|TPMSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|TPM_OPEN
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|sc_flags
operator||=
name|TPM_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpmclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
else|#
directive|else
function|tpmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|TPMSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|TPM_OPEN
operator|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|TPM_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpmread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
else|#
directive|else
function|tpmread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|TPMSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int8_t
name|buf
index|[
name|TPM_BUFSIZ
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|,
name|rv
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
name|ENXIO
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpmread: getting header\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_read
call|)
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|TPM_HDRSIZE
argument_list|,
operator|&
name|cnt
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|len
operator|=
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buf
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
literal|5
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpmread: len %d, io count %d\n"
argument_list|,
name|len
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|>
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|rv
operator|=
name|EIO
expr_stmt|;
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|,
name|rv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpmread: bad residual io count 0x%x\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
comment|/* Copy out header. */
if|if
condition|(
operator|(
name|rv
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|cnt
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
block|{
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
comment|/* Get remaining part of the answer (if anything is left). */
for|for
control|(
name|len
operator|-=
name|cnt
operator|,
name|p
operator|=
name|buf
operator|,
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
init|;
name|len
operator|>
literal|0
condition|;
name|p
operator|=
name|buf
operator|,
name|len
operator|-=
name|n
operator|,
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
control|)
block|{
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpmread: n %d len %d\n"
argument_list|,
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_read
call|)
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|NULL
argument_list|,
name|TPM_PARAM_SIZE
argument_list|)
operator|)
condition|)
block|{
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|p
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
block|{
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
block|}
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_READ
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpmwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
else|#
directive|else
function|tpmwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|tpm_softc
modifier|*
name|sc
init|=
name|TPMSOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int8_t
name|buf
index|[
name|TPM_BUFSIZ
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|rv
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
name|ENXIO
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TPM_DEBUG
name|printf
argument_list|(
literal|"tpmwrite: io count %d\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_WRITE
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
operator|(
name|sc
operator|->
name|sc_write
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
name|rv
operator|=
call|(
name|sc
operator|->
name|sc_end
call|)
argument_list|(
name|sc
argument_list|,
name|UIO_WRITE
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|__FreeBSD__
name|tpmioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
else|#
directive|else
function|tpmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
return|return
name|ENOTTY
return|;
block|}
end_function

end_unit

