begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uaudio.c,v 1.91 2004/11/05 17:46:14 kent Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf  *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf  *                  http://www.usb.org/developers/devclass_docs/termt10.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_expr_stmt
name|__KERNEL_RCSID
argument_list|(
literal|0
argument_list|,
literal|"$NetBSD: uaudio.c,v 1.91 2004/11/05 17:46:14 kent Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Also merged:  *  $NetBSD: uaudio.c,v 1.94 2005/01/15 15:19:53 kent Exp $  *  $NetBSD: uaudio.c,v 1.95 2005/01/16 06:02:19 dsainty Exp $  *  $NetBSD: uaudio.c,v 1.96 2005/01/16 12:46:00 kent Exp $  *  $NetBSD: uaudio.c,v 1.97 2005/02/24 08:19:38 martin Exp $  *  $NetBSD: uaudio.c,v 1.102 2006/04/14 17:00:55 christos Exp $  *  $NetBSD: uaudio.c,v 1.103 2006/05/11 19:09:25 mrg Exp $  *  $NetBSD: uaudio.c,v 1.105 2006/10/04 16:00:15 christos Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_comment
comment|/* for bootverbose */
end_comment

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/audioio.h>
end_include

begin_include
include|#
directive|include
file|<dev/audio_if.h>
end_include

begin_include
include|#
directive|include
file|<dev/audiovar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mulaw.h>
end_include

begin_include
include|#
directive|include
file|<dev/auconv.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_comment
comment|/* XXXXX */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/usb/uaudioreg.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudioreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_comment
comment|/* #define UAUDIO_DEBUG */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* #define USB_DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define UAUDIO_MULTIPLE_ENDPOINTS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (uaudiodebug) logprintf x; } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|do { if (uaudiodebug>(n)) logprintf x; } while (0)
end_define

begin_decl_stmt
name|int
name|uaudiodebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uaudio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB uaudio"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudiodebug
argument_list|,
literal|0
argument_list|,
literal|"uaudio debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UAUDIO_NCHANBUFS
value|6
end_define

begin_comment
comment|/* number of outstanding request */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|UAUDIO_NFRAMES
value|10
end_define

begin_comment
comment|/* ms of sound in each request */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|UAUDIO_NFRAMES
value|20
end_define

begin_comment
comment|/* ms of sound in each request */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MIX_MAX_CHAN
value|8
end_define

begin_struct
struct|struct
name|mixerctl
block|{
name|uint16_t
name|wValue
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
comment|/* using nchan */
name|uint16_t
name|wIndex
decl_stmt|;
name|uint8_t
name|nchan
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
define|#
directive|define
name|MIX_ON_OFF
value|1
define|#
directive|define
name|MIX_SIGNED_16
value|2
define|#
directive|define
name|MIX_UNSIGNED_16
value|3
define|#
directive|define
name|MIX_SIGNED_8
value|4
define|#
directive|define
name|MIX_SELECTOR
value|5
define|#
directive|define
name|MIX_SIZE
parameter_list|(
name|n
parameter_list|)
value|((n) == MIX_SIGNED_16 || (n) == MIX_UNSIGNED_16 ? 2 : 1)
define|#
directive|define
name|MIX_UNSIGNED
parameter_list|(
name|n
parameter_list|)
value|((n) == MIX_UNSIGNED_16)
name|int
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
name|u_int
name|delta
decl_stmt|;
name|u_int
name|mul
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXXXX */
name|unsigned
name|ctl
decl_stmt|;
define|#
directive|define
name|MAX_SELECTOR_INPUT_PIN
value|256
name|uint8_t
name|slctrtype
index|[
name|MAX_SELECTOR_INPUT_PIN
index|]
decl_stmt|;
endif|#
directive|endif
name|uint8_t
name|class
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|char
name|ctlname
index|[
name|MAX_AUDIO_DEV_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ctlunit
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAKE
parameter_list|(
name|h
parameter_list|,
name|l
parameter_list|)
value|(((h)<< 8) | (l))
end_define

begin_struct
struct|struct
name|as_info
block|{
name|uint8_t
name|alt
decl_stmt|;
name|uint8_t
name|encoding
decl_stmt|;
name|uint8_t
name|attributes
decl_stmt|;
comment|/* Copy of bmAttributes of 				     * usb_audio_streaming_endpoint_descriptor 				     */
name|usbd_interface_handle
name|ifaceh
decl_stmt|;
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|idesc
decl_stmt|;
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
name|edesc
decl_stmt|;
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
name|edesc1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|asf1desc
decl_stmt|;
name|int
name|sc_busy
decl_stmt|;
comment|/* currently used */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|chan
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* DMA completion intr handler */
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* arg for intr() */
else|#
directive|else
name|struct
name|pcm_channel
modifier|*
name|pcm_ch
decl_stmt|;
endif|#
directive|endif
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|usbd_pipe_handle
name|sync_pipe
decl_stmt|;
name|u_int
name|sample_size
decl_stmt|;
name|u_int
name|sample_rate
decl_stmt|;
name|u_int
name|bytes_per_frame
decl_stmt|;
name|u_int
name|fraction
decl_stmt|;
comment|/* fraction/1000 is the extra samples/frame */
name|u_int
name|residue
decl_stmt|;
comment|/* accumulates the fractional samples */
name|u_char
modifier|*
name|start
decl_stmt|;
comment|/* upper layer buffer start */
name|u_char
modifier|*
name|end
decl_stmt|;
comment|/* upper layer buffer end */
name|u_char
modifier|*
name|cur
decl_stmt|;
comment|/* current position in upper layer buffer */
name|int
name|blksize
decl_stmt|;
comment|/* chunk size to report up */
name|int
name|transferred
decl_stmt|;
comment|/* transferred bytes not reported up */
name|int
name|altidx
decl_stmt|;
comment|/* currently used altidx */
name|int
name|curchanbuf
decl_stmt|;
struct|struct
name|chanbuf
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|u_int16_t
name|sizes
index|[
name|UAUDIO_NFRAMES
index|]
decl_stmt|;
name|u_int16_t
name|offsets
index|[
name|UAUDIO_NFRAMES
index|]
decl_stmt|;
name|u_int16_t
name|size
decl_stmt|;
block|}
name|chanbufs
index|[
name|UAUDIO_NCHANBUFS
index|]
struct|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
comment|/* our softc */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|u_int32_t
name|format
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|int
name|channels
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_device_handle
name|sc_udev
decl_stmt|;
comment|/* USB device */
name|int
name|sc_ac_iface
decl_stmt|;
comment|/* Audio Control interface */
name|usbd_interface_handle
name|sc_ac_ifaceh
decl_stmt|;
name|struct
name|chan
name|sc_playchan
decl_stmt|;
comment|/* play channel */
name|struct
name|chan
name|sc_recchan
decl_stmt|;
comment|/* record channel */
name|int
name|sc_nullalt
decl_stmt|;
name|int
name|sc_audio_rev
decl_stmt|;
name|struct
name|as_info
modifier|*
name|sc_alts
decl_stmt|;
comment|/* alternate settings */
name|int
name|sc_nalts
decl_stmt|;
comment|/* # of alternate settings */
name|int
name|sc_altflags
decl_stmt|;
define|#
directive|define
name|HAS_8
value|0x01
define|#
directive|define
name|HAS_16
value|0x02
define|#
directive|define
name|HAS_8U
value|0x04
define|#
directive|define
name|HAS_ALAW
value|0x08
define|#
directive|define
name|HAS_MULAW
value|0x10
define|#
directive|define
name|UA_NOFRAC
value|0x20
comment|/* don't do sample rate adjustment */
define|#
directive|define
name|HAS_24
value|0x40
define|#
directive|define
name|HAS_32
value|0x80
name|int
name|sc_mode
decl_stmt|;
comment|/* play/record capability */
name|struct
name|mixerctl
modifier|*
name|sc_ctls
decl_stmt|;
comment|/* mixer controls */
name|int
name|sc_nctls
decl_stmt|;
comment|/* # of mixer controls */
name|device_t
name|sc_audiodev
decl_stmt|;
name|char
name|sc_dying
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|sbuf
name|uaudio_sndstat
decl_stmt|;
name|int
name|uaudio_sndstat_flag
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|terminal_list
block|{
name|int
name|size
decl_stmt|;
name|uint16_t
name|terminals
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TERMINAL_LIST_SIZE
parameter_list|(
name|N
parameter_list|)
value|(offsetof(struct terminal_list, terminals) \ 				+ sizeof(uint16_t) * (N))
end_define

begin_struct
struct|struct
name|io_terminal
block|{
union|union
block|{
specifier|const
name|usb_descriptor_t
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|usb_audio_input_terminal
modifier|*
name|it
decl_stmt|;
specifier|const
name|struct
name|usb_audio_output_terminal
modifier|*
name|ot
decl_stmt|;
specifier|const
name|struct
name|usb_audio_mixer_unit
modifier|*
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_selector_unit
modifier|*
name|su
decl_stmt|;
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
name|fu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit
modifier|*
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_extension_unit
modifier|*
name|eu
decl_stmt|;
block|}
name|d
union|;
name|int
name|inputs_size
decl_stmt|;
name|struct
name|terminal_list
modifier|*
modifier|*
name|inputs
decl_stmt|;
comment|/* list of source input terminals */
name|struct
name|terminal_list
modifier|*
name|output
decl_stmt|;
comment|/* list of destination output terminals */
name|int
name|direct
decl_stmt|;
comment|/* directly connected to an output terminal */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UAC_OUTPUT
value|0
end_define

begin_define
define|#
directive|define
name|UAC_INPUT
value|1
end_define

begin_define
define|#
directive|define
name|UAC_EQUAL
value|2
end_define

begin_define
define|#
directive|define
name|UAC_RECORD
value|3
end_define

begin_define
define|#
directive|define
name|UAC_NCLASSES
value|4
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|AudioCinputs
value|"inputs"
end_define

begin_define
define|#
directive|define
name|AudioCoutputs
value|"outputs"
end_define

begin_define
define|#
directive|define
name|AudioCrecord
value|"record"
end_define

begin_define
define|#
directive|define
name|AudioCequalization
value|"equalization"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|uac_names
index|[]
init|=
block|{
name|AudioCoutputs
block|,
name|AudioCinputs
block|,
name|AudioCequalization
block|,
name|AudioCrecord
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_identify_ac
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|usb_config_descriptor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_identify_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|usb_config_descriptor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_process_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|usb_interface_descriptor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_alt
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|uaudio_find_iface
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|mixerctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|uaudio_id_name
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|uaudio_dump_cluster
parameter_list|(
specifier|const
name|struct
name|usb_audio_cluster
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|usb_audio_cluster
name|uaudio_get_cluster
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_input
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_output
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|uaudio_get_terminal_name
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|uaudio_determine_class
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|struct
name|mixerctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
specifier|const
name|int
name|uaudio_feature_name
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|struct
name|mixerctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|uaudio_feature_name
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|struct
name|mixerctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|uaudio_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|terminal_list
modifier|*
name|uaudio_merge_terminal_list
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|terminal_list
modifier|*
name|uaudio_io_terminaltype
parameter_list|(
name|int
parameter_list|,
name|struct
name|io_terminal
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_identify
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|usb_config_descriptor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_signext
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|uaudio_value2bsd
parameter_list|(
name|struct
name|mixerctl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|uaudio_bsd2value
parameter_list|(
name|struct
name|mixerctl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|uaudio_ctl_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mixerctl
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|uaudio_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mixerctl
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_set_speed
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_chan_open
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_close
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|uaudio_chan_alloc_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_free_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|uaudio_chan_init
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|audio_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_set_param
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|uaudio_chan_ptransfer
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_pintr
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_private_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_rtransfer
parameter_list|(
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_rintr
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_private_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|uaudio_open
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_close
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_drain
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_query_encoding
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|audio_encoding
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_get_minmax_rates
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|audio_params
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
modifier|*
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_match_alt_sub
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
parameter_list|,
specifier|const
name|struct
name|audio_params
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_match_alt_chan
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_match_alt
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_set_params
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_round_blocksize
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_trigger_output
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_trigger_input
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_halt_in_dma
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_halt_out_dma
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_getdev
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|audio_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_set_port
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mixer_ctrl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_get_port
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mixer_ctrl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_query_devinfo
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mixer_devinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_get_props
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|audio_hw_if
name|uaudio_hw_if
init|=
block|{
name|uaudio_open
block|,
name|uaudio_close
block|,
name|uaudio_drain
block|,
name|uaudio_query_encoding
block|,
name|uaudio_set_params
block|,
name|uaudio_round_blocksize
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|uaudio_halt_out_dma
block|,
name|uaudio_halt_in_dma
block|,
name|NULL
block|,
name|uaudio_getdev
block|,
name|NULL
block|,
name|uaudio_mixer_set_port
block|,
name|uaudio_mixer_get_port
block|,
name|uaudio_query_devinfo
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|uaudio_get_props
block|,
name|uaudio_trigger_output
block|,
name|uaudio_trigger_input
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|audio_device
name|uaudio_device
init|=
block|{
literal|"USB audio"
block|,
literal|""
block|,
literal|"uaudio"
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_function_decl
specifier|static
name|int
name|audio_attach_mi
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_init_params
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_sndstat_prepare_pcm
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* for NetBSD compatibirity */
end_comment

begin_define
define|#
directive|define
name|AUMODE_PLAY
value|0x01
end_define

begin_define
define|#
directive|define
name|AUMODE_RECORD
value|0x02
end_define

begin_define
define|#
directive|define
name|AUDIO_PROP_FULLDUPLEX
value|0x01
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ULAW
value|1
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ALAW
value|2
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_SLINEAR_LE
value|6
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_SLINEAR_BE
value|7
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ULINEAR_LE
value|8
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ULINEAR_BE
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|uaudio
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_expr_stmt
name|USB_DECLARE_DRIVER_INIT
argument_list|(
name|uaudio
argument_list|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
argument_list|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
argument_list|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
argument_list|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|USB_MATCH
argument_list|(
argument|uaudio
argument_list|)
end_macro

begin_block
block|{
name|USB_MATCH_START
argument_list|(
name|uaudio
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|iface
operator|==
name|NULL
condition|)
return|return
name|UMATCH_NONE
return|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
comment|/* Trigger on the control interface. */
if|if
condition|(
name|id
operator|==
name|NULL
operator|||
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UICLASS_AUDIO
operator|||
name|id
operator|->
name|bInterfaceSubClass
operator|!=
name|UISUBCLASS_AUDIOCONTROL
operator|||
operator|(
name|usbd_get_quirks
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_BAD_AUDIO
operator|)
condition|)
return|return
name|UMATCH_NONE
return|;
return|return
name|UMATCH_IFACECLASS_IFACESUBCLASS
return|;
block|}
end_block

begin_macro
name|USB_ATTACH
argument_list|(
argument|uaudio
argument_list|)
end_macro

begin_block
block|{
name|USB_ATTACH_START
argument_list|(
name|uaudio
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|cdesc
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|found
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|USB_ATTACH_SETUP
expr_stmt|;
else|#
directive|else
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %s\n"
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|cdesc
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to get configuration descriptor\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|err
operator|=
name|uaudio_identify
argument_list|(
name|sc
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: audio descriptors make no sense, error=%d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ac_ifaceh
operator|=
name|uaa
operator|->
name|iface
expr_stmt|;
comment|/* Pick up the AS interface. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uaa
operator|->
name|nifaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
continue|continue;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|->
name|bInterfaceNumber
operator|==
name|sc
operator|->
name|sc_alts
index|[
name|j
index|]
operator|.
name|idesc
operator|->
name|bInterfaceNumber
condition|)
block|{
name|sc
operator|->
name|sc_alts
index|[
name|j
index|]
operator|.
name|ifaceh
operator|=
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_alts
index|[
name|j
index|]
operator|.
name|ifaceh
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: alt %d missing AS interface(s)\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s: audio rev %d.%02x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|>>
literal|8
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_playchan
operator|.
name|sc
operator|=
name|sc
operator|->
name|sc_recchan
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_AU_NO_FRAC
condition|)
name|sc
operator|->
name|sc_altflags
operator||=
name|UA_NOFRAC
expr_stmt|;
ifndef|#
directive|ifndef
name|USB_DEBUG
if|if
condition|(
name|bootverbose
condition|)
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s: %d mixer controls\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_nctls
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_ATTACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_attach: doing audio_attach_mi\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|audio_attach_mi
argument_list|(
operator|&
name|uaudio_hw_if
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|sc
operator|->
name|sc_audiodev
operator|=
name|audio_attach_mi
argument_list|(
operator|&
name|uaudio_hw_if
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|->
name|sc_dying
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|audio_attach_mi
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"audio_attach_mi failed\n"
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
endif|#
directive|endif
name|USB_ATTACH_SUCCESS_RETURN
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_activate
parameter_list|(
name|device_t
name|self
parameter_list|,
name|enum
name|devact
name|act
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|uaudio_softc
operator|*
operator|)
name|self
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
name|EOPNOTSUPP
return|;
case|case
name|DVACT_DEACTIVATE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_audiodev
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_deactivate
argument_list|(
name|sc
operator|->
name|sc_audiodev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_detach
parameter_list|(
name|device_t
name|self
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|uaudio_softc
operator|*
operator|)
name|self
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* Wait for outstanding requests to complete. */
name|usbd_delay_ms
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|UAUDIO_NCHANBUFS
operator|*
name|UAUDIO_NFRAMES
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_audiodev
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_detach
argument_list|(
name|sc
operator|->
name|sc_audiodev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_DETACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_macro
name|USB_DETACH
argument_list|(
argument|uaudio
argument_list|)
end_macro

begin_block
block|{
name|USB_DETACH_START
argument_list|(
name|uaudio
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|uaudio_sndstat_flag
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
comment|/* Wait for outstanding requests to complete. */
block|usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
endif|#
directive|endif
comment|/* do nothing ? */
return|return
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|uaudio_query_encoding
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|audio_encoding
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
name|flags
operator|=
name|sc
operator|->
name|sc_altflags
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
if|if
condition|(
name|sc
operator|->
name|sc_nalts
operator|==
literal|0
operator|||
name|flags
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|idx
operator|=
name|fp
operator|->
name|index
expr_stmt|;
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
literal|0
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEulinear
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULINEAR
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_8U
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEmulaw
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_MULAW
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEalaw
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ALAW
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_ALAW
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|3
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEslinear
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_SLINEAR
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_8
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|4
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEslinear_le
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|5
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEulinear_le
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|6
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEslinear_be
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_SLINEAR_BE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|7
case|:
name|strlcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEulinear_be
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULINEAR_BE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|uaudio_find_iface
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|offsp
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|offsp
operator|<
name|size
condition|)
block|{
name|d
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
operator|*
name|offsp
operator|)
expr_stmt|;
operator|*
name|offsp
operator|+=
name|d
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|&&
name|d
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_AUDIO
operator|&&
name|d
operator|->
name|bInterfaceSubClass
operator|==
name|subtype
condition|)
return|return
name|d
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|nmc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|mc
operator|->
name|class
operator|<
name|UAC_NCLASSES
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: adding %s.%d\n"
operator|,
name|__func__
operator|,
name|uac_names
index|[
name|mc
operator|->
name|class
index|]
operator|,
name|mc
operator|->
name|ctl
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: adding %d\n"
operator|,
name|__func__
operator|,
name|mc
operator|->
name|ctl
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|mc
operator|->
name|class
operator|<
name|UAC_NCLASSES
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: adding %s.%s\n"
operator|,
name|__func__
operator|,
name|uac_names
index|[
name|mc
operator|->
name|class
index|]
operator|,
name|mc
operator|->
name|ctlname
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: adding %s\n"
operator|,
name|__func__
operator|,
name|mc
operator|->
name|ctlname
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|mc
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|sc_nctls
operator|+
literal|1
operator|)
expr_stmt|;
name|nmc
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_mixer_add_ctl: no memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy old data, if there was any */
if|if
condition|(
name|sc
operator|->
name|sc_nctls
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|nmc
argument_list|,
name|sc
operator|->
name|sc_ctls
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mc
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|sc_nctls
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_ctls
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ctls
operator|=
name|nmc
expr_stmt|;
name|mc
operator|->
name|delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|mc
operator|->
name|minval
operator|=
literal|0
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
comment|/* Determine min and max values. */
name|mc
operator|->
name|minval
operator|=
name|uaudio_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|GET_MIN
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
operator|+
name|uaudio_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|GET_MAX
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mul
operator|=
name|mc
operator|->
name|maxval
operator|-
name|mc
operator|->
name|minval
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mul
operator|==
literal|0
condition|)
name|mc
operator|->
name|mul
operator|=
literal|1
expr_stmt|;
name|res
operator|=
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|GET_RES
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
name|mc
operator|->
name|delta
operator|=
operator|(
name|res
operator|*
literal|255
operator|+
name|mc
operator|->
name|mul
operator|/
literal|2
operator|)
operator|/
name|mc
operator|->
name|mul
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ctls
index|[
name|sc
operator|->
name|sc_nctls
operator|++
index|]
operator|=
operator|*
name|mc
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudiodebug
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_mixer_add_ctl: wValue=%04x"
operator|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|DPRINTF
argument_list|(
operator|(
literal|",%04x"
operator|,
name|mc
operator|->
name|wValue
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|DPRINTF
argument_list|(
operator|(
literal|" wIndex=%04x type=%d ctl='%d' "
literal|"min=%d max=%d\n"
operator|,
name|mc
operator|->
name|wIndex
operator|,
name|mc
operator|->
name|type
operator|,
name|mc
operator|->
name|ctl
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DPRINTF
argument_list|(
operator|(
literal|" wIndex=%04x type=%d name='%s' unit='%s' "
literal|"min=%d max=%d\n"
operator|,
name|mc
operator|->
name|wIndex
operator|,
name|mc
operator|->
name|type
operator|,
name|mc
operator|->
name|ctlname
operator|,
name|mc
operator|->
name|ctlunit
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|uaudio_id_name
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"i%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uaudio_dump_cluster
parameter_list|(
specifier|const
name|struct
name|usb_audio_cluster
modifier|*
name|cl
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|channel_names
index|[
literal|16
index|]
init|=
block|{
literal|"LEFT"
block|,
literal|"RIGHT"
block|,
literal|"CENTER"
block|,
literal|"LFE"
block|,
literal|"LEFT_SURROUND"
block|,
literal|"RIGHT_SURROUND"
block|,
literal|"LEFT_CENTER"
block|,
literal|"RIGHT_CENTER"
block|,
literal|"SURROUND"
block|,
literal|"LEFT_SIDE"
block|,
literal|"RIGHT_SIDE"
block|,
literal|"TOP"
block|,
literal|"RESERVED12"
block|,
literal|"RESERVED13"
block|,
literal|"RESERVED14"
block|,
literal|"RESERVED15"
block|, 	}
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|i
decl_stmt|,
name|first
decl_stmt|;
name|cc
operator|=
name|UGETW
argument_list|(
name|cl
operator|->
name|wChannelConfig
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"cluster: bNrChannels=%u wChannelConfig=0x%.4x"
argument_list|,
name|cl
operator|->
name|bNrChannels
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|first
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cc
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|&
literal|1
condition|)
block|{
name|logprintf
argument_list|(
literal|"%c%s"
argument_list|,
name|first
condition|?
literal|'<'
else|:
literal|','
argument_list|,
name|channel_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
name|cc
operator|=
name|cc
operator|>>
literal|1
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"> iChannelNames=%u"
argument_list|,
name|cl
operator|->
name|iChannelNames
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|usb_audio_cluster
name|uaudio_get_cluster
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|)
block|{
name|struct
name|usb_audio_cluster
name|r
decl_stmt|;
specifier|const
name|usb_descriptor_t
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* avoid infinite loops */
name|dp
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|r
operator|.
name|bNrChannels
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|it
operator|->
name|bNrChannels
expr_stmt|;
name|USETW
argument_list|(
name|r
operator|.
name|wChannelConfig
argument_list|,
name|UGETW
argument_list|(
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|it
operator|->
name|wChannelConfig
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|iChannelNames
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|it
operator|->
name|iChannelNames
expr_stmt|;
return|return
name|r
return|;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|ot
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|r
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|mu
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|mu
operator|->
name|bNrInPins
index|]
expr_stmt|;
return|return
name|r
return|;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
comment|/* XXX This is not really right */
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|su
operator|->
name|baSourceId
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|fu
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|r
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|pu
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|pu
operator|->
name|bNrInPins
index|]
expr_stmt|;
return|return
name|r
return|;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|r
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|eu
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|eu
operator|->
name|bNrInPins
index|]
expr_stmt|;
return|return
name|r
return|;
default|default:
goto|goto
name|bad
goto|;
block|}
block|}
name|bad
label|:
name|printf
argument_list|(
literal|"uaudio_get_cluster: bad data\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_input
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
specifier|const
name|struct
name|usb_audio_input_terminal
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|it
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x "
literal|"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d "
literal|"iChannelNames=%d iTerminal=%d\n"
operator|,
name|d
operator|->
name|bTerminalId
operator|,
name|UGETW
argument_list|(
name|d
operator|->
name|wTerminalType
argument_list|)
operator|,
name|d
operator|->
name|bAssocTerminal
operator|,
name|d
operator|->
name|bNrChannels
operator|,
name|UGETW
argument_list|(
name|d
operator|->
name|wChannelConfig
argument_list|)
operator|,
name|d
operator|->
name|iChannelNames
operator|,
name|d
operator|->
name|iTerminal
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_output
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
specifier|const
name|struct
name|usb_audio_output_terminal
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|ot
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x "
literal|"bAssocTerminal=%d bSourceId=%d iTerminal=%d\n"
operator|,
name|d
operator|->
name|bTerminalId
operator|,
name|UGETW
argument_list|(
name|d
operator|->
name|wTerminalType
argument_list|)
operator|,
name|d
operator|->
name|bAssocTerminal
operator|,
name|d
operator|->
name|bSourceId
operator|,
name|d
operator|->
name|iTerminal
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_mixer_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
name|int
name|c
decl_stmt|,
name|chs
decl_stmt|,
name|ichs
decl_stmt|,
name|ochs
decl_stmt|,
name|i
decl_stmt|,
name|o
decl_stmt|,
name|bno
decl_stmt|,
name|p
decl_stmt|,
name|mo
decl_stmt|,
name|mc
decl_stmt|,
name|k
decl_stmt|;
specifier|const
name|uByte
modifier|*
name|bm
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
comment|/* Compute the number of input channels */
name|ichs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
name|ichs
operator|+=
name|uaudio_get_cluster
argument_list|(
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
comment|/* and the number of output channels */
name|d1
operator|=
operator|(
specifier|const
expr|struct
name|usb_audio_mixer_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
name|ochs
operator|=
name|d1
operator|->
name|bNrChannels
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_mixer: ichs=%d ochs=%d\n"
operator|,
name|ichs
operator|,
name|ochs
operator|)
argument_list|)
expr_stmt|;
name|bm
operator|=
name|d1
operator|->
name|bmControls
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|uaudio_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXXXX */
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNvolume
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|BIT
parameter_list|(
name|bno
parameter_list|)
value|((bm[bno / 8]>> (7 - bno % 8))& 1)
for|for
control|(
name|p
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|chs
operator|=
name|uaudio_get_cluster
argument_list|(
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
name|mo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT
argument_list|(
name|bno
argument_list|)
condition|)
name|mo
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mo
operator|==
literal|1
condition|)
name|mc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mc
operator|==
name|chs
operator|&&
name|chs
operator|<=
name|MIX_MAX_CHAN
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT
argument_list|(
name|bno
argument_list|)
condition|)
name|mix
operator|.
name|wValue
index|[
name|k
operator|++
index|]
operator|=
name|MAKE
argument_list|(
name|p
operator|+
name|c
operator|+
literal|1
argument_list|,
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"mix%d-%s"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mix
operator|.
name|nchan
operator|=
name|chs
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX */
block|}
undef|#
directive|undef
name|BIT
name|p
operator|+=
name|chs
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_selector_unit
modifier|*
name|d
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|int
name|i
decl_stmt|,
name|wp
decl_stmt|;
else|#
directive|else
name|int
name|i
decl_stmt|;
name|struct
name|mixerctl
name|dummy
decl_stmt|;
endif|#
directive|endif
name|d
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|su
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_selector: bUnitId=%d bNrInPins=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_SELECTOR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|mix
operator|.
name|minval
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|maxval
operator|=
name|d
operator|->
name|bNrInPins
expr_stmt|;
name|mix
operator|.
name|mul
operator|=
name|mix
operator|.
name|maxval
operator|-
name|mix
operator|.
name|minval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SELECTOR_INPUT_PIN
condition|;
name|i
operator|++
control|)
block|{
name|mix
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|mix
operator|.
name|minval
init|;
name|i
operator|<=
name|mix
operator|.
name|maxval
condition|;
name|i
operator|++
control|)
block|{
name|mix
operator|.
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|uaudio_feature_name
argument_list|(
operator|&
name|iot
index|[
name|d
operator|->
name|baSourceId
index|[
name|i
operator|-
literal|1
index|]
index|]
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|mix
operator|.
name|minval
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|maxval
operator|=
name|d
operator|->
name|bNrInPins
expr_stmt|;
name|mix
operator|.
name|mul
operator|=
name|mix
operator|.
name|maxval
operator|-
name|mix
operator|.
name|minval
expr_stmt|;
name|wp
operator|=
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
name|MAX_AUDIO_DEV_LEN
argument_list|,
literal|"sel%d-"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|d
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|wp
operator|+=
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
operator|+
name|wp
argument_list|,
name|MAX_AUDIO_DEV_LEN
operator|-
name|wp
argument_list|,
literal|"i%d"
argument_list|,
name|d
operator|->
name|baSourceId
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|>
name|MAX_AUDIO_DEV_LEN
operator|-
literal|1
condition|)
break|break;
block|}
endif|#
directive|endif
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|uaudio_get_terminal_name
parameter_list|(
name|int
name|terminal_type
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|terminal_type
condition|)
block|{
comment|/* USB terminal types */
case|case
name|UAT_UNDEFINED
case|:
return|return
literal|"UAT_UNDEFINED"
return|;
case|case
name|UAT_STREAM
case|:
return|return
literal|"UAT_STREAM"
return|;
case|case
name|UAT_VENDOR
case|:
return|return
literal|"UAT_VENDOR"
return|;
comment|/* input terminal types */
case|case
name|UATI_UNDEFINED
case|:
return|return
literal|"UATI_UNDEFINED"
return|;
case|case
name|UATI_MICROPHONE
case|:
return|return
literal|"UATI_MICROPHONE"
return|;
case|case
name|UATI_DESKMICROPHONE
case|:
return|return
literal|"UATI_DESKMICROPHONE"
return|;
case|case
name|UATI_PERSONALMICROPHONE
case|:
return|return
literal|"UATI_PERSONALMICROPHONE"
return|;
case|case
name|UATI_OMNIMICROPHONE
case|:
return|return
literal|"UATI_OMNIMICROPHONE"
return|;
case|case
name|UATI_MICROPHONEARRAY
case|:
return|return
literal|"UATI_MICROPHONEARRAY"
return|;
case|case
name|UATI_PROCMICROPHONEARR
case|:
return|return
literal|"UATI_PROCMICROPHONEARR"
return|;
comment|/* output terminal types */
case|case
name|UATO_UNDEFINED
case|:
return|return
literal|"UATO_UNDEFINED"
return|;
case|case
name|UATO_SPEAKER
case|:
return|return
literal|"UATO_SPEAKER"
return|;
case|case
name|UATO_HEADPHONES
case|:
return|return
literal|"UATO_HEADPHONES"
return|;
case|case
name|UATO_DISPLAYAUDIO
case|:
return|return
literal|"UATO_DISPLAYAUDIO"
return|;
case|case
name|UATO_DESKTOPSPEAKER
case|:
return|return
literal|"UATO_DESKTOPSPEAKER"
return|;
case|case
name|UATO_ROOMSPEAKER
case|:
return|return
literal|"UATO_ROOMSPEAKER"
return|;
case|case
name|UATO_COMMSPEAKER
case|:
return|return
literal|"UATO_COMMSPEAKER"
return|;
case|case
name|UATO_SUBWOOFER
case|:
return|return
literal|"UATO_SUBWOOFER"
return|;
comment|/* bidir terminal types */
case|case
name|UATB_UNDEFINED
case|:
return|return
literal|"UATB_UNDEFINED"
return|;
case|case
name|UATB_HANDSET
case|:
return|return
literal|"UATB_HANDSET"
return|;
case|case
name|UATB_HEADSET
case|:
return|return
literal|"UATB_HEADSET"
return|;
case|case
name|UATB_SPEAKERPHONE
case|:
return|return
literal|"UATB_SPEAKERPHONE"
return|;
case|case
name|UATB_SPEAKERPHONEESUP
case|:
return|return
literal|"UATB_SPEAKERPHONEESUP"
return|;
case|case
name|UATB_SPEAKERPHONEECANC
case|:
return|return
literal|"UATB_SPEAKERPHONEECANC"
return|;
comment|/* telephony terminal types */
case|case
name|UATT_UNDEFINED
case|:
return|return
literal|"UATT_UNDEFINED"
return|;
case|case
name|UATT_PHONELINE
case|:
return|return
literal|"UATT_PHONELINE"
return|;
case|case
name|UATT_TELEPHONE
case|:
return|return
literal|"UATT_TELEPHONE"
return|;
case|case
name|UATT_DOWNLINEPHONE
case|:
return|return
literal|"UATT_DOWNLINEPHONE"
return|;
comment|/* external terminal types */
case|case
name|UATE_UNDEFINED
case|:
return|return
literal|"UATE_UNDEFINED"
return|;
case|case
name|UATE_ANALOGCONN
case|:
return|return
literal|"UATE_ANALOGCONN"
return|;
case|case
name|UATE_LINECONN
case|:
return|return
literal|"UATE_LINECONN"
return|;
case|case
name|UATE_LEGACYCONN
case|:
return|return
literal|"UATE_LEGACYCONN"
return|;
case|case
name|UATE_DIGITALAUIFC
case|:
return|return
literal|"UATE_DIGITALAUIFC"
return|;
case|case
name|UATE_SPDIF
case|:
return|return
literal|"UATE_SPDIF"
return|;
case|case
name|UATE_1394DA
case|:
return|return
literal|"UATE_1394DA"
return|;
case|case
name|UATE_1394DV
case|:
return|return
literal|"UATE_1394DV"
return|;
comment|/* embedded function terminal types */
case|case
name|UATF_UNDEFINED
case|:
return|return
literal|"UATF_UNDEFINED"
return|;
case|case
name|UATF_CALIBNOISE
case|:
return|return
literal|"UATF_CALIBNOISE"
return|;
case|case
name|UATF_EQUNOISE
case|:
return|return
literal|"UATF_EQUNOISE"
return|;
case|case
name|UATF_CDPLAYER
case|:
return|return
literal|"UATF_CDPLAYER"
return|;
case|case
name|UATF_DAT
case|:
return|return
literal|"UATF_DAT"
return|;
case|case
name|UATF_DCC
case|:
return|return
literal|"UATF_DCC"
return|;
case|case
name|UATF_MINIDISK
case|:
return|return
literal|"UATF_MINIDISK"
return|;
case|case
name|UATF_ANALOGTAPE
case|:
return|return
literal|"UATF_ANALOGTAPE"
return|;
case|case
name|UATF_PHONOGRAPH
case|:
return|return
literal|"UATF_PHONOGRAPH"
return|;
case|case
name|UATF_VCRAUDIO
case|:
return|return
literal|"UATF_VCRAUDIO"
return|;
case|case
name|UATF_VIDEODISCAUDIO
case|:
return|return
literal|"UATF_VIDEODISCAUDIO"
return|;
case|case
name|UATF_DVDAUDIO
case|:
return|return
literal|"UATF_DVDAUDIO"
return|;
case|case
name|UATF_TVTUNERAUDIO
case|:
return|return
literal|"UATF_TVTUNERAUDIO"
return|;
case|case
name|UATF_SATELLITE
case|:
return|return
literal|"UATF_SATELLITE"
return|;
case|case
name|UATF_CABLETUNER
case|:
return|return
literal|"UATF_CABLETUNER"
return|;
case|case
name|UATF_DSS
case|:
return|return
literal|"UATF_DSS"
return|;
case|case
name|UATF_RADIORECV
case|:
return|return
literal|"UATF_RADIORECV"
return|;
case|case
name|UATF_RADIOXMIT
case|:
return|return
literal|"UATF_RADIOXMIT"
return|;
case|case
name|UATF_MULTITRACK
case|:
return|return
literal|"UATF_MULTITRACK"
return|;
case|case
name|UATF_SYNTHESIZER
case|:
return|return
literal|"UATF_SYNTHESIZER"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown type (0x%.4x)"
argument_list|,
name|terminal_type
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|uaudio_determine_class
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mix
parameter_list|)
block|{
name|int
name|terminal_type
decl_stmt|;
if|if
condition|(
name|iot
operator|==
name|NULL
operator|||
name|iot
operator|->
name|output
operator|==
name|NULL
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
return|return
literal|0
return|;
block|}
name|terminal_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|output
operator|->
name|size
operator|==
literal|1
condition|)
name|terminal_type
operator|=
name|iot
operator|->
name|output
operator|->
name|terminals
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * If the only output terminal is USB, 	 * the class is UAC_RECORD. 	 */
if|if
condition|(
operator|(
name|terminal_type
operator|&
literal|0xff00
operator|)
operator|==
operator|(
name|UAT_UNDEFINED
operator|&
literal|0xff00
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_RECORD
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|inputs_size
operator|==
literal|1
operator|&&
name|iot
operator|->
name|inputs
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|iot
operator|->
name|inputs
index|[
literal|0
index|]
operator|->
name|size
operator|==
literal|1
condition|)
return|return
name|iot
operator|->
name|inputs
index|[
literal|0
index|]
operator|->
name|terminals
index|[
literal|0
index|]
return|;
else|else
return|return
literal|0
return|;
block|}
comment|/* 	 * If the ultimate destination of the unit is just one output 	 * terminal and the unit is connected to the output terminal 	 * directly, the class is UAC_OUTPUT. 	 */
if|if
condition|(
name|terminal_type
operator|!=
literal|0
operator|&&
name|iot
operator|->
name|direct
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
return|return
name|terminal_type
return|;
block|}
comment|/* 	 * If the unit is connected to just one input terminal, 	 * the class is UAC_INPUT. 	 */
if|if
condition|(
name|iot
operator|->
name|inputs_size
operator|==
literal|1
operator|&&
name|iot
operator|->
name|inputs
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|iot
operator|->
name|inputs
index|[
literal|0
index|]
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_INPUT
expr_stmt|;
return|return
name|iot
operator|->
name|inputs
index|[
literal|0
index|]
operator|->
name|terminals
index|[
literal|0
index|]
return|;
block|}
comment|/* 	 * Otherwise, the class is UAC_OUTPUT. 	 */
name|mix
operator|->
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
return|return
name|terminal_type
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|const
name|int
name|uaudio_feature_name
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mix
parameter_list|)
block|{
name|int
name|terminal_type
decl_stmt|;
name|terminal_type
operator|=
name|uaudio_determine_class
argument_list|(
name|iot
argument_list|,
name|mix
argument_list|)
expr_stmt|;
if|if
condition|(
name|mix
operator|->
name|class
operator|==
name|UAC_RECORD
operator|&&
name|terminal_type
operator|==
literal|0
condition|)
return|return
name|SOUND_MIXER_IMIX
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: terminal_type=%s\n"
operator|,
name|__func__
operator|,
name|uaudio_get_terminal_name
argument_list|(
name|terminal_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|terminal_type
condition|)
block|{
case|case
name|UAT_STREAM
case|:
return|return
name|SOUND_MIXER_PCM
return|;
case|case
name|UATI_MICROPHONE
case|:
case|case
name|UATI_DESKMICROPHONE
case|:
case|case
name|UATI_PERSONALMICROPHONE
case|:
case|case
name|UATI_OMNIMICROPHONE
case|:
case|case
name|UATI_MICROPHONEARRAY
case|:
case|case
name|UATI_PROCMICROPHONEARR
case|:
return|return
name|SOUND_MIXER_MIC
return|;
case|case
name|UATO_SPEAKER
case|:
case|case
name|UATO_DESKTOPSPEAKER
case|:
case|case
name|UATO_ROOMSPEAKER
case|:
case|case
name|UATO_COMMSPEAKER
case|:
return|return
name|SOUND_MIXER_SPEAKER
return|;
case|case
name|UATE_ANALOGCONN
case|:
case|case
name|UATE_LINECONN
case|:
case|case
name|UATE_LEGACYCONN
case|:
return|return
name|SOUND_MIXER_LINE
return|;
case|case
name|UATE_DIGITALAUIFC
case|:
case|case
name|UATE_SPDIF
case|:
case|case
name|UATE_1394DA
case|:
case|case
name|UATE_1394DV
case|:
return|return
name|SOUND_MIXER_ALTPCM
return|;
case|case
name|UATF_CDPLAYER
case|:
return|return
name|SOUND_MIXER_CD
return|;
case|case
name|UATF_SYNTHESIZER
case|:
return|return
name|SOUND_MIXER_SYNTH
return|;
case|case
name|UATF_VIDEODISCAUDIO
case|:
case|case
name|UATF_DVDAUDIO
case|:
case|case
name|UATF_TVTUNERAUDIO
case|:
return|return
name|SOUND_MIXER_VIDEO
return|;
comment|/* telephony terminal types */
case|case
name|UATT_UNDEFINED
case|:
case|case
name|UATT_PHONELINE
case|:
case|case
name|UATT_TELEPHONE
case|:
case|case
name|UATT_DOWNLINEPHONE
case|:
return|return
name|SOUND_MIXER_PHONEIN
return|;
comment|/*		return SOUND_MIXER_PHONEOUT;*/
case|case
name|UATF_RADIORECV
case|:
case|case
name|UATF_RADIOXMIT
case|:
return|return
name|SOUND_MIXER_RADIO
return|;
case|case
name|UAT_UNDEFINED
case|:
case|case
name|UAT_VENDOR
case|:
case|case
name|UATI_UNDEFINED
case|:
comment|/* output terminal types */
case|case
name|UATO_UNDEFINED
case|:
case|case
name|UATO_DISPLAYAUDIO
case|:
case|case
name|UATO_SUBWOOFER
case|:
case|case
name|UATO_HEADPHONES
case|:
comment|/* bidir terminal types */
case|case
name|UATB_UNDEFINED
case|:
case|case
name|UATB_HANDSET
case|:
case|case
name|UATB_HEADSET
case|:
case|case
name|UATB_SPEAKERPHONE
case|:
case|case
name|UATB_SPEAKERPHONEESUP
case|:
case|case
name|UATB_SPEAKERPHONEECANC
case|:
comment|/* external terminal types */
case|case
name|UATE_UNDEFINED
case|:
comment|/* embedded function terminal types */
case|case
name|UATF_UNDEFINED
case|:
case|case
name|UATF_CALIBNOISE
case|:
case|case
name|UATF_EQUNOISE
case|:
case|case
name|UATF_DAT
case|:
case|case
name|UATF_DCC
case|:
case|case
name|UATF_MINIDISK
case|:
case|case
name|UATF_ANALOGTAPE
case|:
case|case
name|UATF_PHONOGRAPH
case|:
case|case
name|UATF_VCRAUDIO
case|:
case|case
name|UATF_SATELLITE
case|:
case|case
name|UATF_CABLETUNER
case|:
case|case
name|UATF_DSS
case|:
case|case
name|UATF_MULTITRACK
case|:
case|case
literal|0xffff
case|:
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: 'master' for 0x%.4x\n"
operator|,
name|__func__
operator|,
name|terminal_type
operator|)
argument_list|)
expr_stmt|;
return|return
name|SOUND_MIXER_VOLUME
return|;
block|}
return|return
name|SOUND_MIXER_VOLUME
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|uaudio_feature_name
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mix
parameter_list|)
block|{
name|int
name|terminal_type
decl_stmt|;
name|terminal_type
operator|=
name|uaudio_determine_class
argument_list|(
name|iot
argument_list|,
name|mix
argument_list|)
expr_stmt|;
if|if
condition|(
name|mix
operator|->
name|class
operator|==
name|UAC_RECORD
operator|&&
name|terminal_type
operator|==
literal|0
condition|)
return|return
name|AudioNmixerout
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: terminal_type=%s\n"
operator|,
name|__func__
operator|,
name|uaudio_get_terminal_name
argument_list|(
name|terminal_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|terminal_type
condition|)
block|{
case|case
name|UAT_STREAM
case|:
return|return
name|AudioNdac
return|;
case|case
name|UATI_MICROPHONE
case|:
case|case
name|UATI_DESKMICROPHONE
case|:
case|case
name|UATI_PERSONALMICROPHONE
case|:
case|case
name|UATI_OMNIMICROPHONE
case|:
case|case
name|UATI_MICROPHONEARRAY
case|:
case|case
name|UATI_PROCMICROPHONEARR
case|:
return|return
name|AudioNmicrophone
return|;
case|case
name|UATO_SPEAKER
case|:
case|case
name|UATO_DESKTOPSPEAKER
case|:
case|case
name|UATO_ROOMSPEAKER
case|:
case|case
name|UATO_COMMSPEAKER
case|:
return|return
name|AudioNspeaker
return|;
case|case
name|UATO_HEADPHONES
case|:
return|return
name|AudioNheadphone
return|;
case|case
name|UATO_SUBWOOFER
case|:
return|return
name|AudioNlfe
return|;
comment|/* telephony terminal types */
case|case
name|UATT_UNDEFINED
case|:
case|case
name|UATT_PHONELINE
case|:
case|case
name|UATT_TELEPHONE
case|:
case|case
name|UATT_DOWNLINEPHONE
case|:
return|return
literal|"phone"
return|;
case|case
name|UATE_ANALOGCONN
case|:
case|case
name|UATE_LINECONN
case|:
case|case
name|UATE_LEGACYCONN
case|:
return|return
name|AudioNline
return|;
case|case
name|UATE_DIGITALAUIFC
case|:
case|case
name|UATE_SPDIF
case|:
case|case
name|UATE_1394DA
case|:
case|case
name|UATE_1394DV
case|:
return|return
name|AudioNaux
return|;
case|case
name|UATF_CDPLAYER
case|:
return|return
name|AudioNcd
return|;
case|case
name|UATF_SYNTHESIZER
case|:
return|return
name|AudioNfmsynth
return|;
case|case
name|UATF_VIDEODISCAUDIO
case|:
case|case
name|UATF_DVDAUDIO
case|:
case|case
name|UATF_TVTUNERAUDIO
case|:
return|return
name|AudioNvideo
return|;
case|case
name|UAT_UNDEFINED
case|:
case|case
name|UAT_VENDOR
case|:
case|case
name|UATI_UNDEFINED
case|:
comment|/* output terminal types */
case|case
name|UATO_UNDEFINED
case|:
case|case
name|UATO_DISPLAYAUDIO
case|:
comment|/* bidir terminal types */
case|case
name|UATB_UNDEFINED
case|:
case|case
name|UATB_HANDSET
case|:
case|case
name|UATB_HEADSET
case|:
case|case
name|UATB_SPEAKERPHONE
case|:
case|case
name|UATB_SPEAKERPHONEESUP
case|:
case|case
name|UATB_SPEAKERPHONEECANC
case|:
comment|/* external terminal types */
case|case
name|UATE_UNDEFINED
case|:
comment|/* embedded function terminal types */
case|case
name|UATF_UNDEFINED
case|:
case|case
name|UATF_CALIBNOISE
case|:
case|case
name|UATF_EQUNOISE
case|:
case|case
name|UATF_DAT
case|:
case|case
name|UATF_DCC
case|:
case|case
name|UATF_MINIDISK
case|:
case|case
name|UATF_ANALOGTAPE
case|:
case|case
name|UATF_PHONOGRAPH
case|:
case|case
name|UATF_VCRAUDIO
case|:
case|case
name|UATF_SATELLITE
case|:
case|case
name|UATF_CABLETUNER
case|:
case|case
name|UATF_DSS
case|:
case|case
name|UATF_RADIORECV
case|:
case|case
name|UATF_RADIOXMIT
case|:
case|case
name|UATF_MULTITRACK
case|:
case|case
literal|0xffff
case|:
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: 'master' for 0x%.4x\n"
operator|,
name|__func__
operator|,
name|terminal_type
operator|)
argument_list|)
expr_stmt|;
return|return
name|AudioNmaster
return|;
block|}
return|return
name|AudioNmaster
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|uaudio_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
name|d
decl_stmt|;
specifier|const
name|uByte
modifier|*
name|ctls
decl_stmt|;
name|int
name|ctlsize
decl_stmt|;
name|int
name|nchan
decl_stmt|;
name|u_int
name|fumask
decl_stmt|,
name|mmask
decl_stmt|,
name|cmask
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|ctl
decl_stmt|,
name|i
decl_stmt|,
name|unit
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|int
name|mixernumber
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
name|mixername
decl_stmt|;
endif|#
directive|endif
define|#
directive|define
name|GET
parameter_list|(
name|i
parameter_list|)
value|(ctls[(i)*ctlsize] | \ 		(ctlsize> 1 ? ctls[(i)*ctlsize+1]<< 8 : 0))
name|d
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|fu
expr_stmt|;
name|ctls
operator|=
name|d
operator|->
name|bmaControls
expr_stmt|;
name|ctlsize
operator|=
name|d
operator|->
name|bControlSize
expr_stmt|;
name|nchan
operator|=
operator|(
name|d
operator|->
name|bLength
operator|-
literal|7
operator|)
operator|/
name|ctlsize
expr_stmt|;
name|mmask
operator|=
name|GET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Figure out what we can control */
for|for
control|(
name|cmask
operator|=
literal|0
operator|,
name|chan
operator|=
literal|1
init|;
name|chan
operator|<
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
operator|(
literal|"uaudio_add_feature: chan=%d mask=%x\n"
operator|,
name|chan
operator|,
name|GET
argument_list|(
name|chan
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cmask
operator||=
name|GET
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uaudio_add_feature: bUnitId=%d, "
literal|"%d channels, mmask=0x%04x, cmask=0x%04x\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|nchan
operator|,
name|mmask
operator|,
name|cmask
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nchan
operator|>
name|MIX_MAX_CHAN
condition|)
name|nchan
operator|=
name|MIX_MAX_CHAN
expr_stmt|;
name|unit
operator|=
name|d
operator|->
name|bUnitId
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|unit
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
for|for
control|(
name|ctl
operator|=
name|MUTE_CONTROL
init|;
name|ctl
operator|<
name|LOUDNESS_CONTROL
condition|;
name|ctl
operator|++
control|)
block|{
name|fumask
operator|=
name|FU_MASK
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uaudio_add_feature: ctl=%d fumask=0x%04x\n"
operator|,
name|ctl
operator|,
name|fumask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmask
operator|&
name|fumask
condition|)
block|{
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmask
operator|&
name|fumask
condition|)
block|{
name|mix
operator|.
name|nchan
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|i
argument_list|)
operator|&
name|fumask
condition|)
name|mix
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MAKE
argument_list|(
name|ctl
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|mix
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
undef|#
directive|undef
name|GET
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mixernumber
operator|=
name|uaudio_feature_name
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
else|#
directive|else
name|mixername
operator|=
name|uaudio_feature_name
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|MUTE_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNmute
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|VOLUME_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|mixernumber
expr_stmt|;
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNvolume
expr_stmt|;
name|strlcpy
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
name|mixername
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|BASS_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_BASS
expr_stmt|;
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNbass
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNbass
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MID_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNmid
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNmid
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TREBLE_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_TREBLE
expr_stmt|;
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNtreble
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNtreble
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GRAPHIC_EQUALIZER_CONTROL
case|:
continue|continue;
comment|/* XXX don't add anything */
break|break;
case|case
name|AGC_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNagc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DELAY_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_UNSIGNED_16
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
literal|"4 ms"
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNdelay
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|BASS_BOOST_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNbassboost
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LOUDNESS_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_LOUD
expr_stmt|;
comment|/* Is this correct ? */
else|#
directive|else
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|mixername
argument_list|,
name|AudioNloudness
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_processing_unit
modifier|*
name|d
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|d1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_updown
modifier|*
name|ud
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|pu
expr_stmt|;
name|d1
operator|=
operator|(
specifier|const
expr|struct
name|usb_audio_processing_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
name|ud
operator|=
operator|(
specifier|const
expr|struct
name|usb_audio_processing_unit_updown
operator|*
operator|)
operator|&
name|d1
operator|->
name|bmControls
index|[
name|d1
operator|->
name|bControlSize
index|]
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|ud
operator|->
name|bNrModes
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_MASK
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_add_processing_updown: no mode select\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
comment|/* XXX */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"pro%d-mode"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|->
name|bNrModes
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_processing_updown: i=%d bm=0x%x\n"
operator|,
name|i
operator|,
name|UGETW
argument_list|(
name|ud
operator|->
name|waModes
index|[
name|i
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_processing_unit
modifier|*
name|d
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|d1
decl_stmt|;
name|int
name|ptype
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|d
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|pu
expr_stmt|;
name|d1
operator|=
operator|(
specifier|const
expr|struct
name|usb_audio_processing_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
name|ptype
operator|=
name|UGETW
argument_list|(
name|d
operator|->
name|wProcessType
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_processing: wProcessType=%d bUnitId=%d "
literal|"bNrInPins=%d\n"
operator|,
name|ptype
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_ENABLE_MASK
condition|)
block|{
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|XX_ENABLE_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"pro%d.%d-enable"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|UPDOWNMIX_PROCESS
case|:
name|uaudio_add_processing_updown
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOLBY_PROLOGIC_PROCESS
case|:
case|case
name|P3D_STEREO_EXTENDER_PROCESS
case|:
case|case
name|REVERBATION_PROCESS
case|:
case|case
name|CHORUS_PROCESS
case|:
case|case
name|DYN_RANGE_COMP_PROCESS
case|:
default|default:
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"uaudio_add_processing: unit %d, type=%d not impl.\n"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_extension_unit
modifier|*
name|d
decl_stmt|;
specifier|const
name|struct
name|usb_audio_extension_unit_1
modifier|*
name|d1
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|d
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|d
operator|.
name|eu
expr_stmt|;
name|d1
operator|=
operator|(
specifier|const
expr|struct
name|usb_audio_extension_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_extension: bUnitId=%d bNrInPins=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_AU_NO_XU
condition|)
return|return;
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_EXT_ENABLE_MASK
condition|)
block|{
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|UA_EXT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|snprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|)
argument_list|,
literal|"ext%d-enable"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|terminal_list
modifier|*
name|uaudio_merge_terminal_list
parameter_list|(
specifier|const
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|)
block|{
name|struct
name|terminal_list
modifier|*
name|tml
decl_stmt|;
name|uint16_t
modifier|*
name|ptm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|inputs
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iot
operator|->
name|inputs_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|size
expr_stmt|;
block|}
name|tml
operator|=
name|malloc
argument_list|(
name|TERMINAL_LIST_SIZE
argument_list|(
name|len
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tml
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_merge_terminal_list: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tml
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ptm
operator|=
name|tml
operator|->
name|terminals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iot
operator|->
name|inputs_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|size
operator|>
name|len
condition|)
break|break;
name|memcpy
argument_list|(
name|ptm
argument_list|,
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|terminals
argument_list|,
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|tml
operator|->
name|size
operator|+=
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|size
expr_stmt|;
name|ptm
operator|+=
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|size
expr_stmt|;
name|len
operator|-=
name|iot
operator|->
name|inputs
index|[
name|i
index|]
operator|->
name|size
expr_stmt|;
block|}
return|return
name|tml
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|terminal_list
modifier|*
name|uaudio_io_terminaltype
parameter_list|(
name|int
name|outtype
parameter_list|,
name|struct
name|io_terminal
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|terminal_list
modifier|*
name|tml
decl_stmt|;
name|struct
name|io_terminal
modifier|*
name|it
decl_stmt|;
name|int
name|src_id
decl_stmt|,
name|i
decl_stmt|;
name|it
operator|=
operator|&
name|iot
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|output
operator|!=
name|NULL
condition|)
block|{
comment|/* already has outtype? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|it
operator|->
name|output
operator|->
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|it
operator|->
name|output
operator|->
name|terminals
index|[
name|i
index|]
operator|==
name|outtype
condition|)
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
name|tml
operator|=
name|malloc
argument_list|(
name|TERMINAL_LIST_SIZE
argument_list|(
name|it
operator|->
name|output
operator|->
name|size
operator|+
literal|1
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tml
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
block|}
name|memcpy
argument_list|(
name|tml
argument_list|,
name|it
operator|->
name|output
argument_list|,
name|TERMINAL_LIST_SIZE
argument_list|(
name|it
operator|->
name|output
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|tml
operator|->
name|terminals
index|[
name|it
operator|->
name|output
operator|->
name|size
index|]
operator|=
name|outtype
expr_stmt|;
name|tml
operator|->
name|size
operator|++
expr_stmt|;
name|free
argument_list|(
name|it
operator|->
name|output
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|it
operator|->
name|output
operator|=
name|tml
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|it
operator|->
name|inputs_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|it
operator|->
name|inputs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|it
operator|->
name|inputs
index|[
name|i
index|]
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|it
operator|->
name|inputs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|it
operator|->
name|inputs_size
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* end `iot[id] != NULL' */
name|it
operator|->
name|inputs_size
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|NULL
expr_stmt|;
name|it
operator|->
name|output
operator|=
name|malloc
argument_list|(
name|TERMINAL_LIST_SIZE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|output
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|it
operator|->
name|output
operator|->
name|terminals
index|[
literal|0
index|]
operator|=
name|outtype
expr_stmt|;
name|it
operator|->
name|output
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|it
operator|->
name|direct
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|it
operator|->
name|d
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tml
operator|=
name|malloc
argument_list|(
name|TERMINAL_LIST_SIZE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tml
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|it
operator|->
name|inputs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|it
operator|->
name|inputs
index|[
literal|0
index|]
operator|=
name|tml
expr_stmt|;
name|tml
operator|->
name|terminals
index|[
literal|0
index|]
operator|=
name|UGETW
argument_list|(
name|it
operator|->
name|d
operator|.
name|it
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
name|tml
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|=
literal|1
expr_stmt|;
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|src_id
operator|=
name|it
operator|->
name|d
operator|.
name|fu
operator|->
name|bSourceId
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
return|;
block|}
name|it
operator|->
name|inputs
index|[
literal|0
index|]
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|=
literal|1
expr_stmt|;
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|src_id
operator|=
name|it
operator|->
name|d
operator|.
name|ot
operator|->
name|bSourceId
expr_stmt|;
name|it
operator|->
name|inputs
index|[
literal|0
index|]
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|=
literal|1
expr_stmt|;
name|iot
index|[
name|src_id
index|]
operator|.
name|direct
operator|=
name|TRUE
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|it
operator|->
name|inputs_size
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
operator|*
name|it
operator|->
name|d
operator|.
name|mu
operator|->
name|bNrInPins
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|it
operator|->
name|d
operator|.
name|mu
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|src_id
operator|=
name|it
operator|->
name|d
operator|.
name|mu
operator|->
name|baSourceId
index|[
name|i
index|]
expr_stmt|;
name|it
operator|->
name|inputs
index|[
name|i
index|]
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|++
expr_stmt|;
block|}
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|it
operator|->
name|inputs_size
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
operator|*
name|it
operator|->
name|d
operator|.
name|su
operator|->
name|bNrInPins
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|it
operator|->
name|d
operator|.
name|su
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|src_id
operator|=
name|it
operator|->
name|d
operator|.
name|su
operator|->
name|baSourceId
index|[
name|i
index|]
expr_stmt|;
name|it
operator|->
name|inputs
index|[
name|i
index|]
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|++
expr_stmt|;
block|}
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|it
operator|->
name|inputs_size
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
operator|*
name|it
operator|->
name|d
operator|.
name|pu
operator|->
name|bNrInPins
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|it
operator|->
name|d
operator|.
name|pu
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|src_id
operator|=
name|it
operator|->
name|d
operator|.
name|pu
operator|->
name|baSourceId
index|[
name|i
index|]
expr_stmt|;
name|it
operator|->
name|inputs
index|[
name|i
index|]
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|++
expr_stmt|;
block|}
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|it
operator|->
name|inputs_size
operator|=
literal|0
expr_stmt|;
name|it
operator|->
name|inputs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal_list
operator|*
argument_list|)
operator|*
name|it
operator|->
name|d
operator|.
name|eu
operator|->
name|bNrInPins
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inputs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_io_terminaltype: no memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|it
operator|->
name|d
operator|.
name|eu
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|src_id
operator|=
name|it
operator|->
name|d
operator|.
name|eu
operator|->
name|baSourceId
index|[
name|i
index|]
expr_stmt|;
name|it
operator|->
name|inputs
index|[
name|i
index|]
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|outtype
argument_list|,
name|iot
argument_list|,
name|src_id
argument_list|)
expr_stmt|;
name|it
operator|->
name|inputs_size
operator|++
expr_stmt|;
block|}
return|return
name|uaudio_merge_terminal_list
argument_list|(
name|it
argument_list|)
return|;
case|case
name|UDESCSUB_AC_HEADER
case|:
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|uaudio_identify
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|err
operator|=
name|uaudio_identify_ac
argument_list|(
name|sc
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
return|return
name|uaudio_identify_as
argument_list|(
name|sc
argument_list|,
name|cdesc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_add_alt
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|struct
name|as_info
modifier|*
name|nai
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|sc_nalts
operator|+
literal|1
operator|)
expr_stmt|;
name|nai
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nai
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_add_alt: no memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy old data, if there was any */
if|if
condition|(
name|sc
operator|->
name|sc_nalts
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|nai
argument_list|,
name|sc
operator|->
name|sc_alts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|sc_nalts
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_alts
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_alts
operator|=
name|nai
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_alt: adding alt=%d, enc=%d\n"
operator|,
name|ai
operator|->
name|alt
operator|,
name|ai
operator|->
name|encoding
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_nalts
operator|++
index|]
operator|=
operator|*
name|ai
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|uaudio_process_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|offsp
parameter_list|,
name|int
name|size
parameter_list|,
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|id
parameter_list|)
define|#
directive|define
name|offs
value|(*offsp)
block|{
specifier|const
name|struct
name|usb_audio_streaming_interface_descriptor
modifier|*
name|asid
decl_stmt|;
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|asf1d
decl_stmt|;
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
name|ed
decl_stmt|;
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
name|epdesc1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_streaming_endpoint_descriptor
modifier|*
name|sed
decl_stmt|;
name|int
name|format
decl_stmt|,
name|chan
decl_stmt|,
name|prec
decl_stmt|,
name|enc
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|type
decl_stmt|,
name|sync
decl_stmt|;
name|struct
name|as_info
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_str
decl_stmt|;
name|asid
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|asid
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|||
name|asid
operator|->
name|bDescriptorSubtype
operator|!=
name|AS_GENERAL
condition|)
return|return
name|USBD_INVAL
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_process_as: asid: bTerminakLink=%d wFormatTag=%d\n"
operator|,
name|asid
operator|->
name|bTerminalLink
operator|,
name|UGETW
argument_list|(
name|asid
operator|->
name|wFormatTag
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|asid
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
name|asf1d
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|asf1d
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|||
name|asf1d
operator|->
name|bDescriptorSubtype
operator|!=
name|FORMAT_TYPE
condition|)
return|return
name|USBD_INVAL
return|;
name|offs
operator|+=
name|asf1d
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
if|if
condition|(
name|asf1d
operator|->
name|bFormatType
operator|!=
name|FORMAT_TYPE_I
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ignored setting with type %d format\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|asid
operator|->
name|wFormatTag
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
name|ed
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|bDescriptorType
operator|!=
name|UDESC_ENDPOINT
condition|)
return|return
name|USBD_INVAL
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_process_as: endpoint[0] bLength=%d bDescriptorType=%d "
literal|"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d "
literal|"bInterval=%d bRefresh=%d bSynchAddress=%d\n"
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|ed
operator|->
name|bmAttributes
operator|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
operator|,
name|ed
operator|->
name|bInterval
operator|,
name|ed
operator|->
name|bRefresh
operator|,
name|ed
operator|->
name|bSynchAddress
operator|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|ed
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_ISOCHRONOUS
condition|)
return|return
name|USBD_INVAL
return|;
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
name|type
operator|=
name|UE_GET_ISO_TYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_AU_INP_ASYNC
operator|)
operator|&&
name|dir
operator|==
name|UE_DIR_IN
operator|&&
name|type
operator|==
name|UE_ISO_ADAPT
condition|)
name|type
operator|=
name|UE_ISO_ASYNC
expr_stmt|;
comment|/* We can't handle endpoints that need a sync pipe yet. */
name|sync
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|UE_DIR_IN
operator|&&
name|type
operator|==
name|UE_ISO_ADAPT
condition|)
block|{
name|sync
operator|=
name|TRUE
expr_stmt|;
ifndef|#
directive|ifndef
name|UAUDIO_MULTIPLE_ENDPOINTS
name|printf
argument_list|(
literal|"%s: ignored input endpoint of type adaptive\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|dir
operator|!=
name|UE_DIR_IN
operator|&&
name|type
operator|==
name|UE_ISO_ASYNC
condition|)
block|{
name|sync
operator|=
name|TRUE
expr_stmt|;
ifndef|#
directive|ifndef
name|UAUDIO_MULTIPLE_ENDPOINTS
name|printf
argument_list|(
literal|"%s: ignored output endpoint of type async\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
endif|#
directive|endif
block|}
name|sed
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|sed
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_ENDPOINT
operator|||
name|sed
operator|->
name|bDescriptorSubtype
operator|!=
name|AS_GENERAL
condition|)
return|return
name|USBD_INVAL
return|;
name|DPRINTF
argument_list|(
operator|(
literal|" streadming_endpoint: offset=%d bLength=%d\n"
operator|,
name|offs
operator|,
name|sed
operator|->
name|bLength
operator|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|sed
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
ifdef|#
directive|ifdef
name|UAUDIO_MULTIPLE_ENDPOINTS
if|if
condition|(
name|sync
operator|&&
name|id
operator|->
name|bNumEndpoints
operator|<=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: a sync-pipe endpoint but no other endpoint\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|sync
operator|&&
name|id
operator|->
name|bNumEndpoints
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: non sync-pipe endpoint but multiple endpoints\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
name|epdesc1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|bNumEndpoints
operator|>
literal|1
condition|)
block|{
name|epdesc1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|epdesc1
operator|->
name|bDescriptorType
operator|!=
name|UDESC_ENDPOINT
condition|)
return|return
name|USBD_INVAL
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_process_as: endpoint[1] bLength=%d "
literal|"bDescriptorType=%d bEndpointAddress=%d "
literal|"bmAttributes=0x%x wMaxPacketSize=%d bInterval=%d "
literal|"bRefresh=%d bSynchAddress=%d\n"
operator|,
name|epdesc1
operator|->
name|bLength
operator|,
name|epdesc1
operator|->
name|bDescriptorType
operator|,
name|epdesc1
operator|->
name|bEndpointAddress
operator|,
name|epdesc1
operator|->
name|bmAttributes
operator|,
name|UGETW
argument_list|(
name|epdesc1
operator|->
name|wMaxPacketSize
argument_list|)
operator|,
name|epdesc1
operator|->
name|bInterval
operator|,
name|epdesc1
operator|->
name|bRefresh
operator|,
name|epdesc1
operator|->
name|bSynchAddress
operator|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|epdesc1
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
if|if
condition|(
name|epdesc1
operator|->
name|bSynchAddress
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid endpoint: bSynchAddress=0\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|epdesc1
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_ISOCHRONOUS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid endpoint: bmAttributes=0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|epdesc1
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
if|if
condition|(
name|epdesc1
operator|->
name|bEndpointAddress
operator|!=
name|ed
operator|->
name|bSynchAddress
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid endpoint addresses: "
literal|"ep[0]->bSynchAddress=0x%x "
literal|"ep[1]->bEndpointAddress=0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ed
operator|->
name|bSynchAddress
argument_list|,
name|epdesc1
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
comment|/* UE_GET_ADDR(epdesc1->bEndpointAddress), and epdesc1->bRefresh */
block|}
name|format
operator|=
name|UGETW
argument_list|(
name|asid
operator|->
name|wFormatTag
argument_list|)
expr_stmt|;
name|chan
operator|=
name|asf1d
operator|->
name|bNrChannels
expr_stmt|;
name|prec
operator|=
name|asf1d
operator|->
name|bBitResolution
expr_stmt|;
if|if
condition|(
name|prec
operator|!=
literal|8
operator|&&
name|prec
operator|!=
literal|16
operator|&&
name|prec
operator|!=
literal|24
operator|&&
name|prec
operator|!=
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ignored setting with precision %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|prec
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|UA_FMT_PCM
case|:
if|if
condition|(
name|prec
operator|==
literal|8
condition|)
block|{
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
literal|16
condition|)
block|{
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
literal|24
condition|)
block|{
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
literal|32
condition|)
block|{
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_32
expr_stmt|;
block|}
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|format_str
operator|=
literal|"pcm"
expr_stmt|;
break|break;
case|case
name|UA_FMT_PCM8
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_8U
expr_stmt|;
name|format_str
operator|=
literal|"pcm8"
expr_stmt|;
break|break;
case|case
name|UA_FMT_ALAW
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ALAW
expr_stmt|;
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_ALAW
expr_stmt|;
name|format_str
operator|=
literal|"alaw"
expr_stmt|;
break|break;
case|case
name|UA_FMT_MULAW
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_MULAW
expr_stmt|;
name|format_str
operator|=
literal|"mulaw"
expr_stmt|;
break|break;
case|case
name|UA_FMT_IEEE_FLOAT
case|:
default|default:
name|printf
argument_list|(
literal|"%s: ignored setting with format %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"%s: %s: %dch, %d/%dbit, %s,"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|dir
operator|==
name|UE_DIR_IN
condition|?
literal|"recording"
else|:
literal|"playback"
argument_list|,
name|chan
argument_list|,
name|prec
argument_list|,
name|asf1d
operator|->
name|bSubFrameSize
operator|*
literal|8
argument_list|,
name|format_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|asf1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|printf
argument_list|(
literal|" %d-%dHz\n"
argument_list|,
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
argument_list|,
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|r
decl_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<
name|asf1d
operator|->
name|bSamFreqType
condition|;
name|r
operator|++
control|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Hz\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|uaudio_sndstat_flag
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
literal|"mode %d:(%s) %dch, %d/%dbit, %s,"
argument_list|,
name|id
operator|->
name|bAlternateSetting
argument_list|,
name|dir
operator|==
name|UE_DIR_IN
condition|?
literal|"input"
else|:
literal|"output"
argument_list|,
name|chan
argument_list|,
name|prec
argument_list|,
name|asf1d
operator|->
name|bSubFrameSize
operator|*
literal|8
argument_list|,
name|format_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|asf1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
literal|" %d-%dHz"
argument_list|,
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
argument_list|,
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|r
decl_stmt|;
name|sbuf_printf
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
literal|" %d"
argument_list|,
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|1
init|;
name|r
operator|<
name|asf1d
operator|->
name|bSamFreqType
condition|;
name|r
operator|++
control|)
name|sbuf_printf
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
literal|",%d"
argument_list|,
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
literal|"Hz"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|ai
operator|.
name|alt
operator|=
name|id
operator|->
name|bAlternateSetting
expr_stmt|;
name|ai
operator|.
name|encoding
operator|=
name|enc
expr_stmt|;
name|ai
operator|.
name|attributes
operator|=
name|sed
operator|->
name|bmAttributes
expr_stmt|;
name|ai
operator|.
name|idesc
operator|=
name|id
expr_stmt|;
name|ai
operator|.
name|edesc
operator|=
name|ed
expr_stmt|;
name|ai
operator|.
name|edesc1
operator|=
name|epdesc1
expr_stmt|;
name|ai
operator|.
name|asf1desc
operator|=
name|asf1d
expr_stmt|;
name|ai
operator|.
name|sc_busy
operator|=
literal|0
expr_stmt|;
name|ai
operator|.
name|ifaceh
operator|=
name|NULL
expr_stmt|;
name|uaudio_add_alt
argument_list|(
name|sc
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|ai
operator|.
name|attributes
operator|&
name|UA_SED_FREQ_CONTROL
condition|)
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uaudio_process_as:  FREQ_CONTROL\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|.
name|attributes
operator|&
name|UA_SED_PITCH_CONTROL
condition|)
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uaudio_process_as:  PITCH_CONTROL\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_mode
operator||=
operator|(
name|dir
operator|==
name|UE_DIR_OUT
operator|)
condition|?
name|AUMODE_PLAY
else|:
name|AUMODE_RECORD
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|offs
end_undef

begin_function
specifier|static
name|usbd_status
name|uaudio_identify_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
block|{
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offs
decl_stmt|;
name|size
operator|=
name|UGETW
argument_list|(
name|cdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|cdesc
expr_stmt|;
comment|/* Locate the AudioStreaming interface descriptor. */
name|offs
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|uaudio_find_iface
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|offs
argument_list|,
name|UISUBCLASS_AUDIOSTREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
name|USBD_INVAL
return|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|->
name|uaudio_sndstat_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|uaudio_sndstat_flag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Loop through all the alternate settings. */
while|while
condition|(
name|offs
operator|<=
name|size
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify: interface=%d offset=%d\n"
operator|,
name|id
operator|->
name|bInterfaceNumber
operator|,
name|offs
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|bNumEndpoints
condition|)
block|{
case|case
literal|0
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify: AS null alt=%d\n"
operator|,
name|id
operator|->
name|bAlternateSetting
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nullalt
operator|=
name|id
operator|->
name|bAlternateSetting
expr_stmt|;
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|UAUDIO_MULTIPLE_ENDPOINTS
case|case
literal|2
case|:
endif|#
directive|endif
name|uaudio_process_as
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
operator|&
name|offs
argument_list|,
name|size
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: ignored audio interface with %d "
literal|"endpoints\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|id
operator|->
name|bNumEndpoints
argument_list|)
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|uaudio_find_iface
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|offs
argument_list|,
name|UISUBCLASS_AUDIOSTREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sbuf_finish
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_identify_as: %d alts available\n"
operator|,
name|sc
operator|->
name|sc_nalts
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no usable endpoint found\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|uaudio_identify_ac
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|io_terminal
modifier|*
name|iot
decl_stmt|;
specifier|const
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|usb_audio_control_descriptor
modifier|*
name|acdp
decl_stmt|;
specifier|const
name|usb_descriptor_t
modifier|*
name|dp
decl_stmt|;
specifier|const
name|struct
name|usb_audio_output_terminal
modifier|*
name|pot
decl_stmt|;
name|struct
name|terminal_list
modifier|*
name|tml
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ibuf
decl_stmt|,
modifier|*
name|ibufend
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offs
decl_stmt|,
name|aclen
decl_stmt|,
name|ndps
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size
operator|=
name|UGETW
argument_list|(
name|cdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|cdesc
expr_stmt|;
comment|/* Locate the AudioControl interface descriptor. */
name|offs
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|uaudio_find_iface
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|offs
argument_list|,
name|UISUBCLASS_AUDIOCONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
name|USBD_INVAL
return|;
if|if
condition|(
name|offs
operator|+
sizeof|sizeof
expr|*
name|acdp
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
name|sc
operator|->
name|sc_ac_iface
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify_ac: AC interface is %d\n"
operator|,
name|sc
operator|->
name|sc_ac_iface
operator|)
argument_list|)
expr_stmt|;
comment|/* A class-specific AC interface header should follow. */
name|ibuf
operator|=
name|buf
operator|+
name|offs
expr_stmt|;
name|acdp
operator|=
operator|(
specifier|const
expr|struct
name|usb_audio_control_descriptor
operator|*
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|acdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|||
name|acdp
operator|->
name|bDescriptorSubtype
operator|!=
name|UDESCSUB_AC_HEADER
condition|)
return|return
name|USBD_INVAL
return|;
name|aclen
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|offs
operator|+
name|aclen
operator|>
name|size
condition|)
return|return
name|USBD_INVAL
return|;
if|if
condition|(
operator|!
operator|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_BAD_ADC
operator|)
operator|&&
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
operator|!=
name|UAUDIO_VERSION
condition|)
return|return
name|USBD_INVAL
return|;
name|sc
operator|->
name|sc_audio_rev
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify_ac: found AC header, vers=%03x, len=%d\n"
operator|,
name|sc
operator|->
name|sc_audio_rev
operator|,
name|aclen
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nullalt
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Scan through all the AC specific descriptors */
name|ibufend
operator|=
name|ibuf
operator|+
name|aclen
expr_stmt|;
name|dp
operator|=
operator|(
specifier|const
name|usb_descriptor_t
operator|*
operator|)
name|ibuf
expr_stmt|;
name|ndps
operator|=
literal|0
expr_stmt|;
name|iot
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|io_terminal
argument_list|)
operator|*
literal|256
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|iot
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no memory\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|USBD_NOMEM
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|ibuf
operator|+=
name|dp
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|ibuf
operator|>=
name|ibufend
condition|)
break|break;
name|dp
operator|=
operator|(
specifier|const
name|usb_descriptor_t
operator|*
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|ibuf
operator|+
name|dp
operator|->
name|bLength
operator|>
name|ibufend
condition|)
block|{
name|free
argument_list|(
name|iot
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|USBD_INVAL
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_identify_ac: skip desc type=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorType
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|usb_audio_input_terminal
operator|*
operator|)
name|dp
operator|)
operator|->
name|bTerminalId
expr_stmt|;
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ndps
condition|)
name|ndps
operator|=
name|i
expr_stmt|;
block|}
name|ndps
operator|++
expr_stmt|;
comment|/* construct io_terminal */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndps
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|bDescriptorSubtype
operator|!=
name|UDESCSUB_AC_OUTPUT
condition|)
continue|continue;
name|pot
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|ot
expr_stmt|;
name|tml
operator|=
name|uaudio_io_terminaltype
argument_list|(
name|UGETW
argument_list|(
name|pot
operator|->
name|wTerminalType
argument_list|)
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tml
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tml
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|usb_audio_cluster
name|cluster
decl_stmt|;
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
operator|==
name|NULL
condition|)
continue|continue;
name|logprintf
argument_list|(
literal|"id %d:\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|logprintf
argument_list|(
literal|"AC_INPUT type=%s\n"
argument_list|,
name|uaudio_get_terminal_name
argument_list|(
name|UGETW
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|it
operator|->
name|wTerminalType
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|cluster
operator|=
name|uaudio_get_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
name|uaudio_dump_cluster
argument_list|(
operator|&
name|cluster
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|logprintf
argument_list|(
literal|"AC_OUTPUT type=%s "
argument_list|,
name|uaudio_get_terminal_name
argument_list|(
name|UGETW
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|ot
operator|->
name|wTerminalType
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"src=%d\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|ot
operator|->
name|bSourceId
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|logprintf
argument_list|(
literal|"AC_MIXER src="
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|mu
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
name|logprintf
argument_list|(
literal|"%d "
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|mu
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|cluster
operator|=
name|uaudio_get_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
name|uaudio_dump_cluster
argument_list|(
operator|&
name|cluster
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|logprintf
argument_list|(
literal|"AC_SELECTOR src="
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|su
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
name|logprintf
argument_list|(
literal|"%d "
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|su
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|logprintf
argument_list|(
literal|"AC_FEATURE src=%d\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|fu
operator|->
name|bSourceId
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|logprintf
argument_list|(
literal|"AC_PROCESSING src="
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|pu
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
name|logprintf
argument_list|(
literal|"%d "
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|pu
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|cluster
operator|=
name|uaudio_get_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
name|uaudio_dump_cluster
argument_list|(
operator|&
name|cluster
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|logprintf
argument_list|(
literal|"AC_EXTENSION src="
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|eu
operator|->
name|bNrInPins
condition|;
name|j
operator|++
control|)
name|logprintf
argument_list|(
literal|"%d "
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|eu
operator|->
name|baSourceId
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|cluster
operator|=
name|uaudio_get_cluster
argument_list|(
name|i
argument_list|,
name|iot
argument_list|)
expr_stmt|;
name|uaudio_dump_cluster
argument_list|(
operator|&
name|cluster
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|logprintf
argument_list|(
literal|"unknown audio control (subtype=%d)\n"
argument_list|,
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|inputs_size
condition|;
name|j
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
name|logprintf
argument_list|(
literal|"\tinput%d: "
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|tml
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|inputs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|tml
operator|==
name|NULL
condition|)
block|{
name|logprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|tml
operator|->
name|size
condition|;
name|k
operator|++
control|)
name|logprintf
argument_list|(
literal|"%s "
argument_list|,
name|uaudio_get_terminal_name
argument_list|(
name|tml
operator|->
name|terminals
index|[
name|k
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|logprintf
argument_list|(
literal|"\toutput: "
argument_list|)
expr_stmt|;
name|tml
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|output
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tml
operator|->
name|size
condition|;
name|j
operator|++
control|)
name|logprintf
argument_list|(
literal|"%s "
argument_list|,
name|uaudio_get_terminal_name
argument_list|(
name|tml
operator|->
name|terminals
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|logprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndps
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_identify_ac: id=%d subtype=%d\n"
operator|,
name|i
operator|,
name|dp
operator|->
name|bDescriptorSubtype
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_HEADER
case|:
name|printf
argument_list|(
literal|"uaudio_identify_ac: unexpected AC header\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_INPUT
case|:
name|uaudio_add_input
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|uaudio_add_output
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|uaudio_add_mixer
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|uaudio_add_selector
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|uaudio_add_feature
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|uaudio_add_processing
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|uaudio_add_extension
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"uaudio_identify_ac: bad AC desc subtype=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* delete io_terminal */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|inputs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iot
index|[
name|i
index|]
operator|.
name|inputs_size
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|inputs
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|inputs
index|[
name|j
index|]
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|inputs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iot
index|[
name|i
index|]
operator|.
name|output
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|iot
index|[
name|i
index|]
operator|.
name|output
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|iot
index|[
name|i
index|]
operator|.
name|d
operator|.
name|desc
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|iot
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|USBD_NORMAL_COMPLETION
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|uaudio_query_devinfo
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|mixer_devinfo_t
modifier|*
name|mi
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nctls
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_query_devinfo: index=%d\n"
operator|,
name|mi
operator|->
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
name|n
operator|=
name|mi
operator|->
name|index
expr_stmt|;
name|nctls
operator|=
name|sc
operator|->
name|sc_nctls
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|UAC_OUTPUT
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCoutputs
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|UAC_INPUT
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|UAC_INPUT
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCinputs
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|UAC_EQUAL
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|UAC_EQUAL
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCequalization
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|UAC_RECORD
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|UAC_RECORD
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCrecord
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|n
operator|-=
name|UAC_NCLASSES
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|nctls
condition|)
return|return
name|ENXIO
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|n
index|]
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|mc
operator|->
name|ctlname
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|mc
operator|->
name|class
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|mc
operator|->
name|type
condition|)
block|{
case|case
name|MIX_ON_OFF
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_ENUM
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|num_mem
operator|=
literal|2
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|0
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|AudioNoff
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|0
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|0
index|]
operator|.
name|ord
operator|=
literal|0
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|1
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|AudioNon
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|1
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|1
index|]
operator|.
name|ord
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MIX_SELECTOR
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_ENUM
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|num_mem
operator|=
name|mc
operator|->
name|maxval
operator|-
name|mc
operator|->
name|minval
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|-
name|mc
operator|->
name|minval
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
name|i
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
name|i
index|]
operator|.
name|label
operator|.
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
name|mc
operator|->
name|minval
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
name|i
index|]
operator|.
name|ord
operator|=
name|i
operator|+
name|mc
operator|->
name|minval
expr_stmt|;
block|}
break|break;
default|default:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_VALUE
expr_stmt|;
name|strlcpy
argument_list|(
name|mi
operator|->
name|un
operator|.
name|v
operator|.
name|units
operator|.
name|name
argument_list|,
name|mc
operator|->
name|ctlunit
argument_list|,
name|MAX_AUDIO_DEV_LEN
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|v
operator|.
name|num_channels
operator|=
name|mc
operator|->
name|nchan
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|v
operator|.
name|delta
operator|=
name|mc
operator|->
name|delta
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_open
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_open: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_mode
operator|&
name|AUMODE_PLAY
operator|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_mode
operator|&
name|AUMODE_RECORD
operator|)
condition|)
return|return
name|EACCES
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Close function is called at splaudio().  */
end_comment

begin_function
specifier|static
name|void
name|uaudio_close
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|uaudio_drain
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
name|usbd_delay_ms
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|UAUDIO_NCHANBUFS
operator|*
name|UAUDIO_NFRAMES
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_halt_out_dma
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_out_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_playchan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_playchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_playchan
operator|.
name|pipe
operator|=
name|NULL
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_playchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_playchan
operator|.
name|intr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_halt_in_dma
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_in_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_recchan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_recchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_recchan
operator|.
name|pipe
operator|=
name|NULL
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_recchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_recchan
operator|.
name|intr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_getdev
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|audio_device
modifier|*
name|retp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_mixer_getdev:\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
operator|*
name|retp
operator|=
name|uaudio_device
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure the block size is large enough to hold all outstanding transfers.  */
end_comment

begin_function
specifier|static
name|int
name|uaudio_round_blocksize
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|blk
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|b
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_round_blocksize: blk=%d mode=%s\n"
operator|,
name|blk
operator|,
name|mode
operator|==
name|AUMODE_PLAY
condition|?
literal|"AUMODE_PLAY"
else|:
literal|"AUMODE_RECORD"
operator|)
argument_list|)
expr_stmt|;
comment|/* chan.bytes_per_frame can be 0. */
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
operator|||
name|sc
operator|->
name|sc_recchan
operator|.
name|bytes_per_frame
operator|<=
literal|0
condition|)
block|{
name|b
operator|=
name|param
operator|->
name|sample_rate
operator|*
name|UAUDIO_NFRAMES
operator|*
name|UAUDIO_NCHANBUFS
expr_stmt|;
comment|/* 		 * This does not make accurate value in the case 		 * of b % USB_FRAMES_PER_SECOND != 0 		 */
name|b
operator|/=
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|b
operator|*=
name|param
operator|->
name|precision
operator|/
literal|8
operator|*
name|param
operator|->
name|channels
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * use wMaxPacketSize in bytes_per_frame. 		 * See uaudio_set_params() and uaudio_chan_init() 		 */
name|b
operator|=
name|sc
operator|->
name|sc_recchan
operator|.
name|bytes_per_frame
operator|*
name|UAUDIO_NFRAMES
operator|*
name|UAUDIO_NCHANBUFS
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<=
literal|0
condition|)
name|b
operator|=
literal|1
expr_stmt|;
name|blk
operator|=
name|blk
operator|<=
name|b
condition|?
name|b
else|:
name|blk
operator|/
name|b
operator|*
name|b
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|blk
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_round_blocksize: blk=%d\n"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|blk
operator|=
literal|512
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_round_blocksize: resultant blk=%d\n"
operator|,
name|blk
operator|)
argument_list|)
expr_stmt|;
return|return
name|blk
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_get_props
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
return|return
name|AUDIO_PROP_FULLDUPLEX
operator||
name|AUDIO_PROP_INDEPENDENT
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD or OpenBSD */
end_comment

begin_function
specifier|static
name|int
name|uaudio_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|wValue
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|uint8_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|val
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
endif|#
directive|endif
if|if
condition|(
name|wValue
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|req
operator|.
name|bmRequestType
operator|=
name|type
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|which
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|wValue
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|wIndex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x "
literal|"wIndex=0x%04x len=%d\n"
operator|,
name|type
operator|,
name|which
operator|,
name|wValue
operator|,
name|wIndex
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_get: err=%s\n"
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|data
index|[
literal|0
index|]
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_get: bad length=%d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_get: val=%d\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|wValue
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|uint8_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|wValue
operator|==
operator|-
literal|1
condition|)
return|return;
name|req
operator|.
name|bmRequestType
operator|=
name|type
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|which
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|wValue
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|wIndex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
name|data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x "
literal|"wIndex=0x%04x len=%d, val=%d\n"
operator|,
name|type
operator|,
name|which
operator|,
name|wValue
operator|,
name|wIndex
operator|,
name|len
operator|,
name|val
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|err
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_set: err=%d\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_signext
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MIX_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|MIX_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|2
condition|)
name|val
operator|=
operator|(
name|int16_t
operator|)
name|val
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|int8_t
operator|)
name|val
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|uaudio_value2bsd
parameter_list|(
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_value2bsd: type=%03x val=%d min=%d max=%d "
operator|,
name|mc
operator|->
name|type
operator|,
name|val
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
if|if
condition|(
name|val
operator|<
name|mc
operator|->
name|minval
operator|||
name|val
operator|>
name|mc
operator|->
name|maxval
condition|)
name|val
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
operator|(
name|uaudio_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|val
argument_list|)
operator|-
name|mc
operator|->
name|minval
operator|)
operator|*
literal|255
operator|+
name|mc
operator|->
name|mul
operator|/
literal|2
operator|)
operator|/
name|mc
operator|->
name|mul
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"val'=%d\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|uaudio_bsd2value
parameter_list|(
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_bsd2value: type=%03x val=%d min=%d max=%d "
operator|,
name|mc
operator|->
name|type
operator|,
name|val
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
if|if
condition|(
name|val
operator|<
name|mc
operator|->
name|minval
operator|||
name|val
operator|>
name|mc
operator|->
name|maxval
condition|)
name|val
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
name|val
operator|+
name|mc
operator|->
name|delta
operator|/
literal|2
operator|)
operator|*
name|mc
operator|->
name|mul
operator|/
literal|255
operator|+
name|mc
operator|->
name|minval
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"val'=%d\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|uaudio_ctl_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_ctl_get: which=%d chan=%d\n"
operator|,
name|which
operator|,
name|chan
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|which
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|uaudio_value2bsd
argument_list|(
name|mc
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|uaudio_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|val
operator|=
name|uaudio_bsd2value
argument_list|(
name|mc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|uaudio_set
argument_list|(
name|sc
argument_list|,
name|which
argument_list|,
name|UT_WRITE_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|uaudio_mixer_get_port
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|mixer_ctrl_t
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|vals
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|,
name|val
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_mixer_get_port: index=%d\n"
operator|,
name|cp
operator|->
name|dev
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
name|n
operator|=
name|cp
operator|->
name|dev
operator|-
name|UAC_NCLASSES
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|sc
operator|->
name|sc_nctls
condition|)
return|return
name|ENXIO
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_ENUM
condition|)
return|return
name|EINVAL
return|;
name|cp
operator|->
name|un
operator|.
name|ord
operator|=
name|uaudio_ctl_get
argument_list|(
name|sc
argument_list|,
name|GET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_ENUM
condition|)
return|return
name|EINVAL
return|;
name|cp
operator|->
name|un
operator|.
name|ord
operator|=
name|uaudio_ctl_get
argument_list|(
name|sc
argument_list|,
name|GET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_VALUE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|!=
literal|1
operator|&&
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|!=
name|mc
operator|->
name|nchan
condition|)
return|return
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|uaudio_ctl_get
argument_list|(
name|sc
argument_list|,
name|GET_CUR
argument_list|,
name|mc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|==
literal|1
operator|&&
name|mc
operator|->
name|nchan
operator|!=
literal|1
condition|)
block|{
for|for
control|(
name|val
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|i
index|]
expr_stmt|;
name|vals
index|[
literal|0
index|]
operator|=
name|val
operator|/
name|mc
operator|->
name|nchan
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|level
index|[
name|i
index|]
operator|=
name|vals
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_mixer_set_port
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|mixer_ctrl_t
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|vals
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_mixer_set_port: index = %d\n"
operator|,
name|cp
operator|->
name|dev
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
name|n
operator|=
name|cp
operator|->
name|dev
operator|-
name|UAC_NCLASSES
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|sc
operator|->
name|sc_nctls
condition|)
return|return
name|ENXIO
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_ENUM
condition|)
return|return
name|EINVAL
return|;
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|cp
operator|->
name|un
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_ENUM
condition|)
return|return
name|EINVAL
return|;
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|cp
operator|->
name|un
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_VALUE
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|==
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|level
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|==
name|mc
operator|->
name|nchan
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|level
index|[
name|i
index|]
expr_stmt|;
else|else
return|return
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
name|i
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_trigger_input
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|,
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|audio_params
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_input: sc=%p start=%p end=%p "
literal|"blksize=%d\n"
operator|,
name|sc
operator|,
name|start
operator|,
name|end
operator|,
name|blksize
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
name|uaudio_chan_set_param
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_input: sample_size=%d bytes/frame=%d "
literal|"fraction=0.%03d\n"
operator|,
name|ch
operator|->
name|sample_size
operator|,
name|ch
operator|->
name|bytes_per_frame
operator|,
name|ch
operator|->
name|fraction
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|EIO
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|ch
operator|->
name|intr
operator|=
name|intr
expr_stmt|;
name|ch
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX -1 shouldn't be needed */
name|uaudio_chan_rtransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_trigger_output
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|,
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|audio_params
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_output: sc=%p start=%p end=%p "
literal|"blksize=%d\n"
operator|,
name|sc
operator|,
name|start
operator|,
name|end
operator|,
name|blksize
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
name|uaudio_chan_set_param
argument_list|(
name|ch
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_output: sample_size=%d bytes/frame=%d "
literal|"fraction=0.%03d\n"
operator|,
name|ch
operator|->
name|sample_size
operator|,
name|ch
operator|->
name|bytes_per_frame
operator|,
name|ch
operator|->
name|fraction
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|EIO
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|ch
operator|->
name|intr
operator|=
name|intr
expr_stmt|;
name|ch
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX */
name|uaudio_chan_ptransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD or OpenBSD */
end_comment

begin_comment
comment|/* Set up a pipe for a channel. */
end_comment

begin_function
specifier|static
name|usbd_status
name|uaudio_chan_open
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|as_info
modifier|*
name|as
decl_stmt|;
name|int
name|endpt
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
endif|#
directive|endif
name|as
operator|=
operator|&
name|sc
operator|->
name|sc_alts
index|[
name|ch
operator|->
name|altidx
index|]
expr_stmt|;
name|endpt
operator|=
name|as
operator|->
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_open: endpt=0x%02x, speed=%d, alt=%d\n"
operator|,
name|endpt
operator|,
name|ch
operator|->
name|sample_rate
operator|,
name|as
operator|->
name|alt
operator|)
argument_list|)
expr_stmt|;
comment|/* Set alternate interface corresponding to the mode. */
name|err
operator|=
name|usbd_set_interface
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|as
operator|->
name|alt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* 	 * If just one sampling rate is supported, 	 * no need to call uaudio_set_speed(). 	 * Roland SD-90 freezes by a SAMPLING_FREQ_CONTROL request. 	 */
if|if
condition|(
name|as
operator|->
name|asf1desc
operator|->
name|bSamFreqType
operator|!=
literal|1
condition|)
block|{
name|err
operator|=
name|uaudio_set_speed
argument_list|(
name|sc
argument_list|,
name|endpt
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_open: set_speed failed err=%s\n"
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ch
operator|->
name|pipe
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|sync_pipe
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_open: create pipe to 0x%02x\n"
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|endpt
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|as
operator|->
name|edesc1
operator|!=
name|NULL
condition|)
block|{
name|endpt
operator|=
name|as
operator|->
name|edesc1
operator|->
name|bEndpointAddress
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_open: create sync-pipe to 0x%02x\n"
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|endpt
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|sync_pipe
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_close
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|as_info
modifier|*
name|as
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return ;
endif|#
directive|endif
name|as
operator|=
operator|&
name|sc
operator|->
name|sc_alts
index|[
name|ch
operator|->
name|altidx
index|]
expr_stmt|;
name|as
operator|->
name|sc_busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nullalt
operator|>=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_close: set null alt=%d\n"
operator|,
name|sc
operator|->
name|sc_nullalt
operator|)
argument_list|)
expr_stmt|;
name|usbd_set_interface
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|sc
operator|->
name|sc_nullalt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|ch
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|ch
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|sync_pipe
condition|)
block|{
name|usbd_abort_pipe
argument_list|(
name|ch
operator|->
name|sync_pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|ch
operator|->
name|sync_pipe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|uaudio_chan_alloc_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|ch
operator|->
name|bytes_per_frame
operator|+
name|ch
operator|->
name|sample_size
operator|)
operator|*
name|UAUDIO_NFRAMES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
condition|;
name|i
operator|++
control|)
block|{
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|xfer
operator|=
name|xfer
expr_stmt|;
name|buf
operator|=
name|usbd_alloc_buffer
argument_list|(
name|xfer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|chan
operator|=
name|ch
expr_stmt|;
block|}
return|return
name|USBD_NORMAL_COMPLETION
return|;
name|bad
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
comment|/* implicit buffer free */
name|usbd_free_xfer
argument_list|(
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|xfer
argument_list|)
expr_stmt|;
return|return
name|USBD_NOMEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_free_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
condition|;
name|i
operator|++
control|)
name|usbd_free_xfer
argument_list|(
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
specifier|static
name|void
name|uaudio_chan_ptransfer
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|size
decl_stmt|,
name|residue
decl_stmt|,
name|total
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|sc
operator|->
name|sc_dying
condition|)
return|return;
comment|/* Pick the next channel buffer. */
name|cb
operator|=
operator|&
name|ch
operator|->
name|chanbufs
index|[
name|ch
operator|->
name|curchanbuf
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ch
operator|->
name|curchanbuf
operator|>=
name|UAUDIO_NCHANBUFS
condition|)
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
comment|/* Compute the size of each frame in the next transfer. */
name|residue
operator|=
name|ch
operator|->
name|residue
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
name|residue
operator|+=
name|ch
operator|->
name|fraction
expr_stmt|;
if|if
condition|(
name|residue
operator|>=
name|USB_FRAMES_PER_SECOND
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|->
name|sc
operator|->
name|sc_altflags
operator|&
name|UA_NOFRAC
operator|)
operator|==
literal|0
condition|)
name|size
operator|+=
name|ch
operator|->
name|sample_size
expr_stmt|;
name|residue
operator|-=
name|USB_FRAMES_PER_SECOND
expr_stmt|;
block|}
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|ch
operator|->
name|residue
operator|=
name|residue
expr_stmt|;
name|cb
operator|->
name|size
operator|=
name|total
expr_stmt|;
comment|/* 	 * Transfer data from upper layer buffer to channel buffer, taking 	 * care of wrapping the upper layer buffer. 	 */
name|n
operator|=
name|min
argument_list|(
name|total
argument_list|,
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cb
operator|->
name|buffer
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|total
operator|>
name|n
condition|)
block|{
name|total
operator|-=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cb
operator|->
name|buffer
operator|+
name|n
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|total
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudiodebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\n"
operator|,
name|cb
operator|->
name|buffer
operator|,
name|ch
operator|->
name|residue
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"   [%d] length %d\n"
operator|,
name|i
operator|,
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_transfer: ptransfer xfer=%p\n"
operator|,
name|cb
operator|->
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill the request */
name|usbd_setup_isoc_xfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|,
name|ch
operator|->
name|pipe
argument_list|,
name|cb
argument_list|,
name|cb
operator|->
name|sizes
argument_list|,
name|UAUDIO_NFRAMES
argument_list|,
name|USBD_NO_COPY
argument_list|,
name|uaudio_chan_pintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_pintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cb
operator|=
name|priv
expr_stmt|;
name|ch
operator|=
name|cb
operator|->
name|chan
expr_stmt|;
comment|/* Return if we are aborting. */
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_pintr: count=%d, transferred=%d\n"
operator|,
name|count
operator|,
name|ch
operator|->
name|transferred
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|count
operator|!=
name|cb
operator|->
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_chan_pintr: count(%d) != size(%d)\n"
argument_list|,
name|count
argument_list|,
name|cb
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ch
operator|->
name|transferred
operator|+=
name|cb
operator|->
name|size
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* s = spltty(); */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
comment|/* Call back to upper layer */
while|while
condition|(
name|ch
operator|->
name|transferred
operator|>=
name|ch
operator|->
name|blksize
condition|)
block|{
name|ch
operator|->
name|transferred
operator|-=
name|ch
operator|->
name|blksize
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_pintr: call %p(%p)\n"
operator|,
name|ch
operator|->
name|intr
operator|,
name|ch
operator|->
name|arg
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|intr
argument_list|(
name|ch
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* start next transfer */
name|uaudio_chan_ptransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
specifier|static
name|void
name|uaudio_chan_rtransfer
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|residue
decl_stmt|,
name|total
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|sc
operator|->
name|sc_dying
condition|)
return|return;
comment|/* Pick the next channel buffer. */
name|cb
operator|=
operator|&
name|ch
operator|->
name|chanbufs
index|[
name|ch
operator|->
name|curchanbuf
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ch
operator|->
name|curchanbuf
operator|>=
name|UAUDIO_NCHANBUFS
condition|)
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
comment|/* Compute the size of each frame in the next transfer. */
name|residue
operator|=
name|ch
operator|->
name|residue
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|cb
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|total
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|ch
operator|->
name|residue
operator|=
name|residue
expr_stmt|;
name|cb
operator|->
name|size
operator|=
name|total
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudiodebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\n"
operator|,
name|cb
operator|->
name|buffer
operator|,
name|ch
operator|->
name|residue
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"   [%d] length %d\n"
operator|,
name|i
operator|,
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_rtransfer: transfer xfer=%p\n"
operator|,
name|cb
operator|->
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill the request */
name|usbd_setup_isoc_xfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|,
name|ch
operator|->
name|pipe
argument_list|,
name|cb
argument_list|,
name|cb
operator|->
name|sizes
argument_list|,
name|UAUDIO_NFRAMES
argument_list|,
name|USBD_NO_COPY
argument_list|,
name|uaudio_chan_rintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_rintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
init|=
name|priv
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
init|=
name|cb
operator|->
name|chan
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|frsize
decl_stmt|;
comment|/* Return if we are aborting. */
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_rintr: count=%d, transferred=%d\n"
operator|,
name|count
operator|,
name|ch
operator|->
name|transferred
operator|)
argument_list|)
expr_stmt|;
comment|/* count< cb->size is normal for asynchronous source */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|count
operator|>
name|cb
operator|->
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_chan_rintr: count(%d)> size(%d)\n"
argument_list|,
name|count
argument_list|,
name|cb
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Transfer data from channel buffer to upper layer buffer, taking 	 * care of wrapping the upper layer buffer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|frsize
operator|=
name|cb
operator|->
name|sizes
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|frsize
argument_list|,
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ch
operator|->
name|cur
argument_list|,
name|cb
operator|->
name|buffer
operator|+
name|cb
operator|->
name|offsets
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|frsize
operator|>
name|n
condition|)
block|{
name|memcpy
argument_list|(
name|ch
operator|->
name|cur
argument_list|,
name|cb
operator|->
name|buffer
operator|+
name|cb
operator|->
name|offsets
index|[
name|i
index|]
operator|+
name|n
argument_list|,
name|frsize
operator|-
name|n
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|frsize
operator|-
name|n
expr_stmt|;
block|}
block|}
comment|/* Call back to upper layer */
name|ch
operator|->
name|transferred
operator|+=
name|count
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|->
name|transferred
operator|>=
name|ch
operator|->
name|blksize
condition|)
block|{
name|ch
operator|->
name|transferred
operator|-=
name|ch
operator|->
name|blksize
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_rintr: call %p(%p)\n"
operator|,
name|ch
operator|->
name|intr
operator|,
name|ch
operator|->
name|arg
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|intr
argument_list|(
name|ch
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* start next transfer */
name|uaudio_chan_rtransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|uaudio_chan_init
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|,
name|int
name|altidx
parameter_list|,
specifier|const
name|struct
name|audio_params
modifier|*
name|param
parameter_list|,
name|int
name|maxpktsize
parameter_list|)
block|{
name|int
name|samples_per_frame
decl_stmt|,
name|sample_size
decl_stmt|;
name|ch
operator|->
name|altidx
operator|=
name|altidx
expr_stmt|;
name|sample_size
operator|=
name|param
operator|->
name|precision
operator|*
name|param
operator|->
name|factor
operator|*
name|param
operator|->
name|hw_channels
operator|/
literal|8
expr_stmt|;
name|samples_per_frame
operator|=
name|param
operator|->
name|hw_sample_rate
operator|/
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|sample_size
operator|=
name|sample_size
expr_stmt|;
name|ch
operator|->
name|sample_rate
operator|=
name|param
operator|->
name|hw_sample_rate
expr_stmt|;
if|if
condition|(
name|maxpktsize
operator|==
literal|0
condition|)
block|{
name|ch
operator|->
name|fraction
operator|=
name|param
operator|->
name|hw_sample_rate
operator|%
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|bytes_per_frame
operator|=
name|samples_per_frame
operator|*
name|sample_size
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|fraction
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|bytes_per_frame
operator|=
name|maxpktsize
expr_stmt|;
block|}
name|ch
operator|->
name|residue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_set_param
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|,
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|)
block|{
name|ch
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|start
expr_stmt|;
name|ch
operator|->
name|blksize
operator|=
name|blksize
expr_stmt|;
name|ch
operator|->
name|transferred
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_get_minmax_rates
parameter_list|(
name|int
name|nalts
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
name|alts
parameter_list|,
specifier|const
name|struct
name|audio_params
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_long
modifier|*
name|min
parameter_list|,
name|u_long
modifier|*
name|max
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|a1d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|*
name|min
operator|=
name|ULONG_MAX
expr_stmt|;
operator|*
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalts
condition|;
name|i
operator|++
control|)
block|{
name|a1d
operator|=
name|alts
index|[
name|i
index|]
operator|.
name|asf1desc
expr_stmt|;
if|if
condition|(
name|alts
index|[
name|i
index|]
operator|.
name|sc_busy
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hw_channels
operator|!=
name|a1d
operator|->
name|bNrChannels
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hw_precision
operator|!=
name|a1d
operator|->
name|bBitResolution
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hw_encoding
operator|!=
name|alts
index|[
name|i
index|]
operator|.
name|encoding
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|!=
name|UE_GET_DIR
argument_list|(
name|alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|a1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_get_minmax_rates: cont %d-%d\n"
operator|,
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|,
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|<
operator|*
name|min
condition|)
operator|*
name|min
operator|=
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
operator|>
operator|*
name|max
condition|)
operator|*
name|max
operator|=
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|a1d
operator|->
name|bSamFreqType
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_get_minmax_rates: disc #%d: %d\n"
operator|,
name|j
operator|,
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|<
operator|*
name|min
condition|)
operator|*
name|min
operator|=
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|>
operator|*
name|max
condition|)
operator|*
name|max
operator|=
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_match_alt_sub
parameter_list|(
name|int
name|nalts
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
name|alts
parameter_list|,
specifier|const
name|struct
name|audio_params
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_long
name|rate
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|a1d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_match_alt_sub: search for %luHz %dch\n"
operator|,
name|rate
operator|,
name|p
operator|->
name|hw_channels
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nalts
condition|;
name|i
operator|++
control|)
block|{
name|a1d
operator|=
name|alts
index|[
name|i
index|]
operator|.
name|asf1desc
expr_stmt|;
if|if
condition|(
name|alts
index|[
name|i
index|]
operator|.
name|sc_busy
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hw_channels
operator|!=
name|a1d
operator|->
name|bNrChannels
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hw_precision
operator|!=
name|a1d
operator|->
name|bBitResolution
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hw_encoding
operator|!=
name|alts
index|[
name|i
index|]
operator|.
name|encoding
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|!=
name|UE_GET_DIR
argument_list|(
name|alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|a1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_match_alt_sub: cont %d-%d\n"
operator|,
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|,
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|<=
name|rate
operator|&&
name|rate
operator|<=
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
condition|)
return|return
name|i
return|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|a1d
operator|->
name|bSamFreqType
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_match_alt_sub: disc #%d: %d\n"
operator|,
name|j
operator|,
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX allow for some slack */
if|if
condition|(
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|==
name|rate
condition|)
return|return
name|i
return|;
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_match_alt_chan
parameter_list|(
name|int
name|nalts
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
name|alts
parameter_list|,
name|struct
name|audio_params
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|u_long
name|rate
decl_stmt|;
comment|/* Exact match */
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_match_alt_chan: examine %ldHz %dch %dbit.\n"
operator|,
name|p
operator|->
name|sample_rate
operator|,
name|p
operator|->
name|hw_channels
operator|,
name|p
operator|->
name|hw_precision
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|uaudio_match_alt_sub
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|p
operator|->
name|sample_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
name|uaudio_get_minmax_rates
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_match_alt_chan: min=%lu max=%lu\n"
operator|,
name|min
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Search for biggers */
name|n
operator|=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
name|rate
operator|=
name|p
operator|->
name|sample_rate
operator|*
name|n
operator|++
operator|)
operator|<=
name|max
condition|)
block|{
name|i
operator|=
name|uaudio_match_alt_sub
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|hw_sample_rate
operator|=
name|rate
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|sample_rate
operator|>=
name|min
condition|)
block|{
name|i
operator|=
name|uaudio_match_alt_sub
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|hw_sample_rate
operator|=
name|max
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|uaudio_match_alt_sub
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|hw_sample_rate
operator|=
name|min
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_match_alt
parameter_list|(
name|int
name|nalts
parameter_list|,
specifier|const
name|struct
name|as_info
modifier|*
name|alts
parameter_list|,
name|struct
name|audio_params
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|mode
operator|=
name|mode
operator|==
name|AUMODE_PLAY
condition|?
name|UE_DIR_OUT
else|:
name|UE_DIR_IN
expr_stmt|;
name|i
operator|=
name|uaudio_match_alt_chan
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
for|for
control|(
name|n
operator|=
name|p
operator|->
name|channels
operator|+
literal|1
init|;
name|n
operator|<=
name|AUDIO_MAX_CHANNELS
condition|;
name|n
operator|++
control|)
block|{
name|p
operator|->
name|hw_channels
operator|=
name|n
expr_stmt|;
name|i
operator|=
name|uaudio_match_alt_chan
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
block|}
if|if
condition|(
name|p
operator|->
name|channels
operator|!=
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|->
name|hw_channels
operator|=
literal|1
expr_stmt|;
return|return
name|uaudio_match_alt_chan
argument_list|(
name|nalts
argument_list|,
name|alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_set_params
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|setmode
parameter_list|,
name|int
name|usemode
parameter_list|,
name|struct
name|audio_params
modifier|*
name|play
parameter_list|,
name|struct
name|audio_params
modifier|*
name|rec
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|factor
decl_stmt|;
name|int
name|enc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|paltidx
decl_stmt|,
name|raltidx
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swcode
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
name|struct
name|audio_params
modifier|*
name|p
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|sc
operator|=
name|addr
expr_stmt|;
name|flags
operator|=
name|sc
operator|->
name|sc_altflags
expr_stmt|;
name|paltidx
operator|=
operator|-
literal|1
expr_stmt|;
name|raltidx
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
name|EIO
return|;
if|if
condition|(
operator|(
operator|(
name|usemode
operator|&
name|AUMODE_PLAY
operator|)
operator|&&
name|sc
operator|->
name|sc_playchan
operator|.
name|pipe
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|usemode
operator|&
name|AUMODE_RECORD
operator|)
operator|&&
name|sc
operator|->
name|sc_recchan
operator|.
name|pipe
operator|!=
name|NULL
operator|)
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
operator|(
name|usemode
operator|&
name|AUMODE_PLAY
operator|)
operator|&&
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|!=
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
index|]
operator|.
name|sc_busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|usemode
operator|&
name|AUMODE_RECORD
operator|)
operator|&&
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|!=
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
index|]
operator|.
name|sc_busy
operator|=
literal|0
expr_stmt|;
comment|/* Some uaudio devices are unidirectional.  Don't try to find a 	   matching mode for the unsupported direction. */
name|setmode
operator|&=
name|sc
operator|->
name|sc_mode
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|AUMODE_RECORD
init|;
name|mode
operator|!=
operator|-
literal|1
condition|;
name|mode
operator|=
name|mode
operator|==
name|AUMODE_RECORD
condition|?
name|AUMODE_PLAY
else|:
operator|-
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|setmode
operator|&
name|mode
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
operator|(
name|mode
operator|==
name|AUMODE_PLAY
operator|)
condition|?
name|play
else|:
name|rec
expr_stmt|;
name|factor
operator|=
literal|1
expr_stmt|;
name|swcode
operator|=
literal|0
expr_stmt|;
name|enc
operator|=
name|p
operator|->
name|encoding
expr_stmt|;
switch|switch
condition|(
name|enc
condition|)
block|{
case|case
name|AUDIO_ENCODING_SLINEAR_BE
case|:
comment|/* FALLTHROUGH */
case|case
name|AUDIO_ENCODING_SLINEAR_LE
case|:
if|if
condition|(
name|enc
operator|==
name|AUDIO_ENCODING_SLINEAR_BE
operator|&&
name|p
operator|->
name|precision
operator|==
literal|16
operator|&&
operator|(
name|flags
operator|&
name|HAS_16
operator|)
condition|)
block|{
name|swcode
operator|=
name|swap_bytes
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HAS_8
condition|)
block|{
comment|/* No conversion */
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8U
condition|)
block|{
name|swcode
operator|=
name|change_sign8
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_16
condition|)
block|{
name|factor
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|hw_precision
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|linear8_to_linear16_le
expr_stmt|;
else|else
name|swcode
operator|=
name|linear16_to_linear8_le
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULINEAR_BE
case|:
comment|/* FALLTHROUGH */
case|case
name|AUDIO_ENCODING_ULINEAR_LE
case|:
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|enc
operator|==
name|AUDIO_ENCODING_ULINEAR_LE
condition|)
name|swcode
operator|=
name|change_sign16_le
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|swap_bytes_change_sign16_le
expr_stmt|;
else|else
name|swcode
operator|=
name|change_sign16_swap_bytes_le
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HAS_8U
condition|)
block|{
comment|/* No conversion */
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8
condition|)
block|{
name|swcode
operator|=
name|change_sign8
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_16
condition|)
block|{
name|factor
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|hw_precision
operator|=
literal|16
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|ulinear8_to_slinear16_le
expr_stmt|;
else|else
name|swcode
operator|=
name|slinear16_to_ulinear8_le
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULAW
case|:
if|if
condition|(
name|flags
operator|&
name|HAS_MULAW
condition|)
break|break;
if|if
condition|(
name|flags
operator|&
name|HAS_16
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|mulaw_to_slinear16_le
expr_stmt|;
else|else
name|swcode
operator|=
name|slinear16_to_mulaw_le
expr_stmt|;
name|factor
operator|=
literal|2
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|p
operator|->
name|hw_precision
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8U
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|mulaw_to_ulinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|ulinear8_to_mulaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|mulaw_to_slinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|slinear8_to_mulaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|AUDIO_ENCODING_ALAW
case|:
if|if
condition|(
name|flags
operator|&
name|HAS_ALAW
condition|)
break|break;
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
operator|&&
operator|(
name|flags
operator|&
name|HAS_16
operator|)
condition|)
block|{
name|swcode
operator|=
name|alaw_to_slinear16_le
expr_stmt|;
name|factor
operator|=
literal|2
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|p
operator|->
name|hw_precision
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8U
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|alaw_to_ulinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|ulinear8_to_alaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|alaw_to_slinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|slinear8_to_alaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* XXX do some other conversions... */
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\n"
operator|,
name|p
operator|->
name|channels
operator|,
name|p
operator|->
name|hw_precision
operator|,
name|enc
operator|,
name|p
operator|->
name|sample_rate
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|hw_encoding
operator|=
name|enc
expr_stmt|;
name|i
operator|=
name|uaudio_match_alt
argument_list|(
name|sc
operator|->
name|sc_nalts
argument_list|,
name|sc
operator|->
name|sc_alts
argument_list|,
name|p
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|->
name|sw_code
operator|=
name|swcode
expr_stmt|;
name|p
operator|->
name|factor
operator|=
name|factor
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|paltidx
operator|=
name|i
expr_stmt|;
else|else
name|raltidx
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|setmode
operator|&
name|AUMODE_PLAY
operator|)
condition|)
block|{
comment|/* XXX abort transfer if currently happening? */
name|uaudio_chan_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_playchan
argument_list|,
name|paltidx
argument_list|,
name|play
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|setmode
operator|&
name|AUMODE_RECORD
operator|)
condition|)
block|{
comment|/* XXX abort transfer if currently happening? */
name|uaudio_chan_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_recchan
argument_list|,
name|raltidx
argument_list|,
name|rec
argument_list|,
name|UGETW
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|raltidx
index|]
operator|.
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|usemode
operator|&
name|AUMODE_PLAY
operator|)
operator|&&
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|!=
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
index|]
operator|.
name|sc_busy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|usemode
operator|&
name|AUMODE_RECORD
operator|)
operator|&&
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|!=
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
index|]
operator|.
name|sc_busy
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_set_params: use altidx=p%d/r%d, altno=p%d/r%d\n"
operator|,
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|,
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|,
operator|(
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|>=
literal|0
operator|)
condition|?
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
index|]
operator|.
name|idesc
operator|->
name|bAlternateSetting
else|:
operator|-
literal|1
operator|,
operator|(
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|>=
literal|0
operator|)
condition|?
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
index|]
operator|.
name|idesc
operator|->
name|bAlternateSetting
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD or OpenBSD */
end_comment

begin_function
specifier|static
name|usbd_status
name|uaudio_set_speed
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|endpt
parameter_list|,
name|u_int
name|speed
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|uint8_t
name|data
index|[
literal|3
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_set_speed: endpt=%d speed=%u\n"
operator|,
name|endpt
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_ENDPOINT
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SET_CUR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|SAMPLING_FREQ_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|speed
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|speed
operator|>>
literal|16
expr_stmt|;
return|return
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|int
name|uaudio_init_params
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|enc
decl_stmt|;
name|int
name|samples_per_frame
decl_stmt|,
name|sample_size
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_playchan
operator|.
name|pipe
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_recchan
operator|.
name|pipe
operator|!=
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|ch
operator|->
name|format
operator|&
literal|0x000FFFFF
condition|)
block|{
case|case
name|AFMT_U8
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_S8
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_A_LAW
case|:
comment|/* ? */
name|enc
operator|=
name|AUDIO_ENCODING_ALAW
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_MU_LAW
case|:
comment|/* ? */
name|enc
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_S16_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_S16_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_U16_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_U16_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_S24_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|AFMT_S24_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|AFMT_U24_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|AFMT_U24_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|AFMT_S32_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|AFMT_S32_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|AFMT_U32_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|AFMT_U32_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
name|enc
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown format %x\n"
argument_list|,
name|ch
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|format
operator|&
name|AFMT_STEREO
condition|)
block|{
name|ch
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
block|}
comment|/*	for (mode =  ......	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|a1d
init|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|asf1desc
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|channels
operator|==
name|a1d
operator|->
name|bNrChannels
operator|&&
name|ch
operator|->
name|precision
operator|==
name|a1d
operator|->
name|bBitResolution
operator|&&
if|#
directive|if
literal|0
expr|enc == sc->sc_alts[i].encoding) {
else|#
directive|else
name|enc
operator|==
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
operator|&&
operator|(
name|mode
operator|==
name|AUMODE_PLAY
condition|?
name|UE_DIR_OUT
else|:
name|UE_DIR_IN
operator|)
operator|==
name|UE_GET_DIR
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|a1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set_params: cont %d-%d\n"
operator|,
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|,
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|<=
name|ch
operator|->
name|sample_rate
operator|&&
name|ch
operator|->
name|sample_rate
operator|<=
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|=
name|i
expr_stmt|;
else|else
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|a1d
operator|->
name|bSamFreqType
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set_params: disc #"
literal|"%d: %d\n"
operator|,
name|j
operator|,
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX allow for some slack */
if|if
condition|(
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|==
name|ch
operator|->
name|sample_rate
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|sc
operator|->
name|sc_playchan
operator|.
name|altidx
operator|=
name|i
expr_stmt|;
else|else
name|sc
operator|->
name|sc_recchan
operator|.
name|altidx
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
block|}
block|}
comment|/* return (EINVAL); */
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|printf
argument_list|(
literal|"uaudio: This device can't play in rate=%d.\n"
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"uaudio: This device can't record in rate=%d.\n"
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|found
label|:
if|#
directive|if
literal|0
comment|/* XXX */
block|p->sw_code = swcode; 		p->factor  = factor; 		if (usemode == mode) 			sc->sc_curaltidx = i;
endif|#
directive|endif
comment|/*	} */
name|sample_size
operator|=
name|ch
operator|->
name|precision
operator|*
name|ch
operator|->
name|channels
operator|/
literal|8
expr_stmt|;
name|samples_per_frame
operator|=
name|ch
operator|->
name|sample_rate
operator|/
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|fraction
operator|=
name|ch
operator|->
name|sample_rate
operator|%
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|sample_size
operator|=
name|sample_size
expr_stmt|;
name|ch
operator|->
name|bytes_per_frame
operator|=
name|samples_per_frame
operator|*
name|sample_size
expr_stmt|;
name|ch
operator|->
name|residue
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
name|ch
operator|->
name|transferred
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|uaudio_conversion
block|{
name|uint8_t
name|uaudio_fmt
decl_stmt|;
name|uint8_t
name|uaudio_prec
decl_stmt|;
name|uint32_t
name|freebsd_fmt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|uaudio_conversion
specifier|const
name|accepted_conversion
index|[]
init|=
block|{
block|{
name|AUDIO_ENCODING_ULINEAR_LE
block|,
literal|8
block|,
name|AFMT_U8
block|}
block|,
block|{
name|AUDIO_ENCODING_ULINEAR_LE
block|,
literal|16
block|,
name|AFMT_U16_LE
block|}
block|,
block|{
name|AUDIO_ENCODING_ULINEAR_LE
block|,
literal|24
block|,
name|AFMT_U24_LE
block|}
block|,
block|{
name|AUDIO_ENCODING_ULINEAR_LE
block|,
literal|32
block|,
name|AFMT_U32_LE
block|}
block|,
block|{
name|AUDIO_ENCODING_ULINEAR_BE
block|,
literal|16
block|,
name|AFMT_U16_BE
block|}
block|,
block|{
name|AUDIO_ENCODING_ULINEAR_BE
block|,
literal|24
block|,
name|AFMT_U24_BE
block|}
block|,
block|{
name|AUDIO_ENCODING_ULINEAR_BE
block|,
literal|32
block|,
name|AFMT_U32_BE
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_LE
block|,
literal|8
block|,
name|AFMT_S8
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_LE
block|,
literal|16
block|,
name|AFMT_S16_LE
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_LE
block|,
literal|24
block|,
name|AFMT_S24_LE
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_LE
block|,
literal|32
block|,
name|AFMT_S32_LE
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_BE
block|,
literal|16
block|,
name|AFMT_S16_BE
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_BE
block|,
literal|24
block|,
name|AFMT_S24_BE
block|}
block|,
block|{
name|AUDIO_ENCODING_SLINEAR_BE
block|,
literal|32
block|,
name|AFMT_S32_BE
block|}
block|,
block|{
name|AUDIO_ENCODING_ALAW
block|,
literal|8
block|,
name|AFMT_A_LAW
block|}
block|,
block|{
name|AUDIO_ENCODING_ULAW
block|,
literal|8
block|,
name|AFMT_MU_LAW
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|uaudio_query_formats
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|reqdir
parameter_list|,
name|unsigned
name|maxfmt
parameter_list|,
name|struct
name|pcmchan_caps
modifier|*
name|cap
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|asf1d
decl_stmt|;
specifier|const
name|struct
name|uaudio_conversion
modifier|*
name|iterator
decl_stmt|;
name|unsigned
name|fmtcount
decl_stmt|,
name|foundcount
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|uint8_t
name|format
decl_stmt|,
name|numchan
decl_stmt|,
name|subframesize
decl_stmt|,
name|prec
decl_stmt|,
name|dir
decl_stmt|,
name|iscontinuous
decl_stmt|;
name|int
name|freq
decl_stmt|,
name|freq_min
decl_stmt|,
name|freq_max
decl_stmt|;
name|char
modifier|*
name|numchannel_descr
decl_stmt|;
name|char
name|freq_descr
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cap
operator|->
name|minspeed
operator|=
name|cap
operator|->
name|maxspeed
operator|=
literal|0
expr_stmt|;
name|foundcount
operator|=
name|fmtcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|i
operator|++
control|)
block|{
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|==
name|UE_DIR_OUT
operator|)
operator|!=
operator|(
name|reqdir
operator|==
name|PCMDIR_PLAY
operator|)
condition|)
continue|continue;
name|asf1d
operator|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|asf1desc
expr_stmt|;
name|format
operator|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
expr_stmt|;
name|numchan
operator|=
name|asf1d
operator|->
name|bNrChannels
expr_stmt|;
name|subframesize
operator|=
name|asf1d
operator|->
name|bSubFrameSize
expr_stmt|;
name|prec
operator|=
name|asf1d
operator|->
name|bBitResolution
expr_stmt|;
comment|/* precision */
name|iscontinuous
operator|=
name|asf1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
expr_stmt|;
if|if
condition|(
name|iscontinuous
condition|)
name|snprintf
argument_list|(
name|freq_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|freq_descr
argument_list|)
argument_list|,
literal|"continous min %d max %d"
argument_list|,
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
argument_list|,
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|freq_descr
argument_list|,
sizeof|sizeof
argument_list|(
name|freq_descr
argument_list|)
argument_list|,
literal|"fixed frequency (%d listed formats)"
argument_list|,
name|asf1d
operator|->
name|bSamFreqType
argument_list|)
expr_stmt|;
if|if
condition|(
name|numchan
operator|==
literal|1
condition|)
name|numchannel_descr
operator|=
literal|" (mono)"
expr_stmt|;
elseif|else
if|if
condition|(
name|numchan
operator|==
literal|2
condition|)
name|numchannel_descr
operator|=
literal|" (stereo)"
expr_stmt|;
else|else
name|numchannel_descr
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"uaudio_query_formats: found a native %s channel%s %s %dbit %dbytes/subframe X %d channels = %d bytes per sample\n"
argument_list|,
operator|(
name|dir
operator|==
name|UE_DIR_OUT
operator|)
condition|?
literal|"playback"
else|:
literal|"record"
argument_list|,
name|numchannel_descr
argument_list|,
name|freq_descr
argument_list|,
name|prec
argument_list|,
name|subframesize
argument_list|,
name|numchan
argument_list|,
name|subframesize
operator|*
name|numchan
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now start rejecting the ones that don't map to FreeBSD 		 */
if|if
condition|(
name|numchan
operator|!=
literal|1
operator|&&
name|numchan
operator|!=
literal|2
condition|)
continue|continue;
for|for
control|(
name|iterator
operator|=
name|accepted_conversion
init|;
name|iterator
operator|->
name|uaudio_fmt
operator|!=
literal|0
condition|;
name|iterator
operator|++
control|)
if|if
condition|(
name|iterator
operator|->
name|uaudio_fmt
operator|==
name|format
operator|&&
name|iterator
operator|->
name|uaudio_prec
operator|==
name|prec
condition|)
break|break;
if|if
condition|(
name|iterator
operator|->
name|uaudio_fmt
operator|==
literal|0
condition|)
continue|continue;
name|fmt
operator|=
name|iterator
operator|->
name|freebsd_fmt
expr_stmt|;
if|if
condition|(
name|numchan
operator|==
literal|2
condition|)
name|fmt
operator||=
name|AFMT_STEREO
expr_stmt|;
name|foundcount
operator|++
expr_stmt|;
if|if
condition|(
name|fmtcount
operator|>=
name|maxfmt
condition|)
continue|continue;
name|cap
operator|->
name|fmtlist
index|[
name|fmtcount
operator|++
index|]
operator|=
name|fmt
expr_stmt|;
if|if
condition|(
name|iscontinuous
condition|)
block|{
name|freq_min
operator|=
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
expr_stmt|;
name|freq_max
operator|=
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|minspeed
operator|==
literal|0
operator|||
name|freq_min
operator|<
name|cap
operator|->
name|minspeed
condition|)
name|cap
operator|->
name|minspeed
operator|=
name|freq_min
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|maxspeed
operator|==
literal|0
condition|)
name|cap
operator|->
name|maxspeed
operator|=
name|cap
operator|->
name|minspeed
expr_stmt|;
if|if
condition|(
name|freq_max
operator|>
name|cap
operator|->
name|maxspeed
condition|)
name|cap
operator|->
name|maxspeed
operator|=
name|freq_max
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|asf1d
operator|->
name|bSamFreqType
condition|;
name|r
operator|++
control|)
block|{
name|freq
operator|=
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|minspeed
operator|==
literal|0
operator|||
name|freq
operator|<
name|cap
operator|->
name|minspeed
condition|)
name|cap
operator|->
name|minspeed
operator|=
name|freq
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|maxspeed
operator|==
literal|0
condition|)
name|cap
operator|->
name|maxspeed
operator|=
name|cap
operator|->
name|minspeed
expr_stmt|;
if|if
condition|(
name|freq
operator|>
name|cap
operator|->
name|maxspeed
condition|)
name|cap
operator|->
name|maxspeed
operator|=
name|freq
expr_stmt|;
block|}
block|}
block|}
name|cap
operator|->
name|fmtlist
index|[
name|fmtcount
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|foundcount
return|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_pcm_dma_buff
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
name|end
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|pc
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
else|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
else|#
directive|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
endif|#
directive|endif
name|ch
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|ch
operator|->
name|pcm_ch
operator|=
name|pc
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_blocksize
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
else|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
else|#
directive|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
endif|#
directive|endif
name|ch
operator|->
name|blksize
operator|=
name|blocksize
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_speed
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|speed
parameter_list|,
name|int
name|reqdir
parameter_list|)
block|{
specifier|const
name|struct
name|uaudio_conversion
modifier|*
name|iterator
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|score
decl_stmt|,
name|hiscore
decl_stmt|,
name|bestspeed
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|reqdir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
else|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
else|#
directive|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We are successful if we find an endpoint that matches our selected format and it 	 * supports the requested speed. 	 */
name|hiscore
operator|=
literal|0
expr_stmt|;
name|bestspeed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|i
operator|++
control|)
block|{
name|int
name|dir
init|=
name|UE_GET_DIR
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
decl_stmt|;
name|int
name|format
init|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
decl_stmt|;
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|asf1d
init|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|asf1desc
decl_stmt|;
name|int
name|iscontinuous
init|=
name|asf1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
decl_stmt|;
if|if
condition|(
operator|(
name|dir
operator|==
name|UE_DIR_OUT
operator|)
operator|!=
operator|(
name|reqdir
operator|==
name|PCMDIR_PLAY
operator|)
condition|)
continue|continue;
for|for
control|(
name|iterator
operator|=
name|accepted_conversion
init|;
name|iterator
operator|->
name|uaudio_fmt
operator|!=
literal|0
condition|;
name|iterator
operator|++
control|)
if|if
condition|(
name|iterator
operator|->
name|uaudio_fmt
operator|!=
name|format
operator|||
name|iterator
operator|->
name|freebsd_fmt
operator|!=
operator|(
name|ch
operator|->
name|format
operator|&
literal|0xfffffff
operator|)
condition|)
continue|continue;
if|if
condition|(
name|iscontinuous
condition|)
block|{
if|if
condition|(
name|speed
operator|>=
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
operator|&&
name|speed
operator|<=
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
condition|)
block|{
name|ch
operator|->
name|sample_rate
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
elseif|else
if|if
condition|(
name|speed
operator|<
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
condition|)
block|{
name|score
operator|=
literal|0xfff
operator|*
name|speed
operator|/
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|hiscore
condition|)
block|{
name|bestspeed
operator|=
name|UA_SAMP_LO
argument_list|(
name|asf1d
argument_list|)
expr_stmt|;
name|hiscore
operator|=
name|score
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|speed
operator|>
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
condition|)
block|{
name|score
operator|=
literal|0xfff
operator|*
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
operator|/
name|speed
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|hiscore
condition|)
block|{
name|bestspeed
operator|=
name|UA_SAMP_HI
argument_list|(
name|asf1d
argument_list|)
expr_stmt|;
name|hiscore
operator|=
name|score
expr_stmt|;
block|}
block|}
continue|continue;
block|}
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|asf1d
operator|->
name|bSamFreqType
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|speed
operator|==
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|ch
operator|->
name|sample_rate
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
if|if
condition|(
name|speed
operator|>
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
condition|)
name|score
operator|=
literal|0xfff
operator|*
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
operator|/
name|speed
expr_stmt|;
else|else
name|score
operator|=
literal|0xfff
operator|*
name|speed
operator|/
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|>
name|hiscore
condition|)
block|{
name|bestspeed
operator|=
name|UA_GETSAMP
argument_list|(
name|asf1d
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|hiscore
operator|=
name|score
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bestspeed
operator|!=
literal|1
condition|)
block|{
name|ch
operator|->
name|sample_rate
operator|=
name|bestspeed
expr_stmt|;
return|return
name|bestspeed
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_getptr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|int
name|ptr
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
else|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
else|#
directive|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|ch
operator|->
name|cur
operator|-
name|ch
operator|->
name|start
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_format
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|format
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
else|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
else|#
directive|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
endif|#
directive|endif
name|ch
operator|->
name|format
operator|=
name|format
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|uaudio_halt_out_dma
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_out_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_playchan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_playchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_playchan
operator|.
name|pipe
operator|=
literal|0
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_playchan
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_halt_in_dma
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_in_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_recchan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_recchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_recchan
operator|.
name|pipe
operator|=
name|NULL
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_recchan
argument_list|)
expr_stmt|;
comment|/*		sc->sc_recchan.intr = NULL; */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_trigger_input
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_recchan
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*	uaudio_chan_set_param(ch, start, end, blksize) */
if|if
condition|(
name|uaudio_init_params
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|AUMODE_RECORD
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*	ch->intr = intr; 	ch->arg = arg; */
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX -1 shouldn't be needed */
name|uaudio_chan_rtransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_trigger_output
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_playchan
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|uaudio_init_params
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|AUMODE_PLAY
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX */
name|uaudio_chan_ptransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|uaudio_query_mix_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|mask
init|=
literal|0
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nctls
condition|;
name|i
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|ctl
operator|!=
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
comment|/* Set device mask bits.  			   See /usr/include/machine/soundcard.h */
name|mask
operator||=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|ctl
operator|)
expr_stmt|;
block|}
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
name|u_int32_t
name|uaudio_query_recsrc_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rec_selector_id
decl_stmt|;
name|u_int32_t
name|mask
init|=
literal|0
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rec_selector_id
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nctls
condition|;
name|i
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
operator|&&
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
operator|&&
name|mc
operator|->
name|class
operator|==
name|UAC_RECORD
condition|)
block|{
if|if
condition|(
name|rec_selector_id
operator|==
operator|-
literal|1
condition|)
block|{
name|rec_selector_id
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"There are many selectors.  Can't recognize which selector is a record source selector.\n"
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
block|}
block|}
if|if
condition|(
name|rec_selector_id
operator|==
operator|-
literal|1
condition|)
return|return
name|mask
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|rec_selector_id
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
name|i
operator|<=
name|mc
operator|->
name|maxval
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|SOUND_MIXER_NRDEVICES
condition|)
continue|continue;
name|mask
operator||=
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
name|void
name|uaudio_mixer_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|type
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nctls
condition|;
name|i
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|ctl
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|nchan
operator|==
literal|2
condition|)
block|{
comment|/* set Right */
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|right
operator|*
literal|255
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* set Left or Mono */
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|left
operator|*
literal|255
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|u_int32_t
name|uaudio_mixer_setrecsrc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rec_selector_id
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rec_selector_id
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nctls
condition|;
name|i
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
operator|&&
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
operator|&&
name|mc
operator|->
name|class
operator|==
name|UAC_RECORD
condition|)
block|{
if|if
condition|(
name|rec_selector_id
operator|==
operator|-
literal|1
condition|)
block|{
name|rec_selector_id
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
return|return
name|src
return|;
comment|/* Can't recognize which selector is record source selector */
block|}
block|}
block|}
if|if
condition|(
name|rec_selector_id
operator|==
operator|-
literal|1
condition|)
return|return
name|src
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|rec_selector_id
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
name|i
operator|<=
name|mc
operator|->
name|maxval
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src
operator|!=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
continue|continue;
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|)
return|;
block|}
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|mc
operator|->
name|minval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|mc
operator|->
name|minval
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_sndstat_prepare_pcm
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|snddev_channel
modifier|*
name|sce
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|c
decl_stmt|;
name|struct
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|int
name|pc
decl_stmt|,
name|rc
decl_stmt|,
name|vc
decl_stmt|;
name|device_t
name|pa_dev
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|pa_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|d
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|ENXIO
return|;
name|snd_mtxlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|d
operator|->
name|channels
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" (mixer only)"
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pc
operator|=
name|rc
operator|=
name|vc
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sce
argument_list|,
argument|&d->channels
argument_list|,
argument|link
argument_list|)
block|{
name|c
operator|=
name|sce
operator|->
name|channel
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_VIRTUAL
condition|)
name|vc
operator|++
expr_stmt|;
else|else
name|pc
operator|++
expr_stmt|;
block|}
else|else
name|rc
operator|++
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" (%dp/%dr/%dv channels%s%s)"
argument_list|,
name|d
operator|->
name|playcount
argument_list|,
name|d
operator|->
name|reccount
argument_list|,
name|d
operator|->
name|vchancount
argument_list|,
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_SIMPLEX
operator|)
condition|?
literal|""
else|:
literal|" duplex"
argument_list|,
ifdef|#
directive|ifdef
name|USING_DEVFS
operator|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
name|snd_unit
operator|)
condition|?
literal|" default"
else|:
literal|""
else|#
directive|else
literal|""
endif|#
directive|endif
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|uaudio_sndstat_flag
operator|!=
literal|0
condition|)
block|{
name|sbuf_cat
argument_list|(
name|s
argument_list|,
name|sbuf_data
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|uaudio_sndstat
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|<=
literal|1
condition|)
block|{
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|SLIST_FOREACH
argument_list|(
argument|sce
argument_list|,
argument|&d->channels
argument_list|,
argument|link
argument_list|)
block|{
name|c
operator|=
name|sce
operator|->
name|channel
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|c
operator|->
name|bufhard
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|bufsoft
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hosed pcm channel setup"
operator|)
argument_list|)
expr_stmt|;
comment|/* it would be better to indent child channels */
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s[%s]: "
argument_list|,
name|c
operator|->
name|parentchannel
condition|?
name|c
operator|->
name|parentchannel
operator|->
name|name
else|:
literal|""
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"spd %d"
argument_list|,
name|c
operator|->
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|speed
operator|!=
name|sndbuf_getspd
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"/%d"
argument_list|,
name|sndbuf_getspd
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", fmt 0x%08x"
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|format
operator|!=
name|sndbuf_getfmt
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"/0x%08x"
argument_list|,
name|sndbuf_getfmt
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", flags 0x%08x, 0x%08x"
argument_list|,
name|c
operator|->
name|flags
argument_list|,
name|c
operator|->
name|feederflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|pid
operator|!=
operator|-
literal|1
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", pid %d"
argument_list|,
name|c
operator|->
name|pid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"interrupts %d, "
argument_list|,
name|c
operator|->
name|interrupts
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"overruns %d, feed %u, hfree %d, sfree %d [b:%d/%d/%d|bs:%d/%d/%d]"
argument_list|,
name|c
operator|->
name|xruns
argument_list|,
name|c
operator|->
name|feedcount
argument_list|,
name|sndbuf_getfree
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getfree
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|,
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getblksz
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getblkcnt
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|,
name|sndbuf_getblksz
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|,
name|sndbuf_getblkcnt
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"underruns %d, feed %u, ready %d [b:%d/%d/%d|bs:%d/%d/%d]"
argument_list|,
name|c
operator|->
name|xruns
argument_list|,
name|c
operator|->
name|feedcount
argument_list|,
name|sndbuf_getready
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|,
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getblksz
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getblkcnt
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
argument_list|,
name|sndbuf_getsize
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|,
name|sndbuf_getblksz
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|,
name|sndbuf_getblkcnt
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"{%s}"
argument_list|,
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
operator|)
condition|?
literal|"hardware"
else|:
literal|"userland"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" -> "
argument_list|)
expr_stmt|;
name|f
operator|=
name|c
operator|->
name|feeder
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|source
operator|!=
name|NULL
condition|)
name|f
operator|=
name|f
operator|->
name|source
expr_stmt|;
while|while
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s"
argument_list|,
name|f
operator|->
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|desc
operator|->
name|type
operator|==
name|FEEDER_FMT
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"(0x%08x -> 0x%08x)"
argument_list|,
name|f
operator|->
name|desc
operator|->
name|in
argument_list|,
name|f
operator|->
name|desc
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|desc
operator|->
name|type
operator|==
name|FEEDER_RATE
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"(%d -> %d)"
argument_list|,
name|FEEDER_GET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_SRC
argument_list|)
argument_list|,
name|FEEDER_GET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_DST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|desc
operator|->
name|type
operator|==
name|FEEDER_ROOT
operator|||
name|f
operator|->
name|desc
operator|->
name|type
operator|==
name|FEEDER_MIXER
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"(0x%08x)"
argument_list|,
name|f
operator|->
name|desc
operator|->
name|out
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" -> "
argument_list|)
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|parent
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"{%s}"
argument_list|,
operator|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
operator|)
condition|?
literal|"userland"
else|:
literal|"hardware"
argument_list|)
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|uaudio_sndstat_register
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sndstat_register
argument_list|(
name|dev
argument_list|,
name|d
operator|->
name|status
argument_list|,
name|uaudio_sndstat_prepare_pcm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|audio_attach_mi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* Attach the children. */
comment|/* PCM Audio */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|func
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXXXX */
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uaudio
argument_list|,
name|uhub
argument_list|,
name|uaudio_driver
argument_list|,
name|uaudio_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|uaudio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

