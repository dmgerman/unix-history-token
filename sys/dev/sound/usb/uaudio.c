begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uaudio.c,v 1.91 2004/11/05 17:46:14 kent Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf  *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf  *                  http://www.usb.org/developers/devclass_docs/termt10.pdf  */
end_comment

begin_comment
comment|/*  * Also merged:  *  $NetBSD: uaudio.c,v 1.94 2005/01/15 15:19:53 kent Exp $  *  $NetBSD: uaudio.c,v 1.95 2005/01/16 06:02:19 dsainty Exp $  *  $NetBSD: uaudio.c,v 1.96 2005/01/16 12:46:00 kent Exp $  *  $NetBSD: uaudio.c,v 1.97 2005/02/24 08:19:38 martin Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbhid.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|uaudio_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/quirk/usb_quirk.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_comment
comment|/* for bootverbose */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudioreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudio.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|uaudio_default_rate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use rate list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uaudio_default_bits
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uaudio_default_channels
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use default */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|uaudio_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uaudio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB uaudio"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_debug
argument_list|,
literal|0
argument_list|,
literal|"uaudio debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.uaudio.default_rate"
argument_list|,
operator|&
name|uaudio_default_rate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|default_rate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_default_rate
argument_list|,
literal|0
argument_list|,
literal|"uaudio default sample rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.uaudio.default_bits"
argument_list|,
operator|&
name|uaudio_default_bits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|default_bits
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_default_bits
argument_list|,
literal|0
argument_list|,
literal|"uaudio default sample bits"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.usb.uaudio.default_channels"
argument_list|,
operator|&
name|uaudio_default_channels
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|default_channels
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudio_default_channels
argument_list|,
literal|0
argument_list|,
literal|"uaudio default sample channels"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UAUDIO_NFRAMES
value|64
end_define

begin_comment
comment|/* must be factor of 8 due HS-USB */
end_comment

begin_define
define|#
directive|define
name|UAUDIO_NCHANBUFS
value|2
end_define

begin_comment
comment|/* number of outstanding request */
end_comment

begin_define
define|#
directive|define
name|UAUDIO_RECURSE_LIMIT
value|255
end_define

begin_comment
comment|/* rounds */
end_comment

begin_define
define|#
directive|define
name|MAKE_WORD
parameter_list|(
name|h
parameter_list|,
name|l
parameter_list|)
value|(((h)<< 8) | (l))
end_define

begin_define
define|#
directive|define
name|BIT_TEST
parameter_list|(
name|bm
parameter_list|,
name|bno
parameter_list|)
value|(((bm)[(bno) / 8]>> (7 - ((bno) % 8)))& 1)
end_define

begin_define
define|#
directive|define
name|UAUDIO_MAX_CHAN
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_define
define|#
directive|define
name|MIX
parameter_list|(
name|sc
parameter_list|)
value|((sc)->sc_mixer_node)
end_define

begin_union
union|union
name|uaudio_asid
block|{
specifier|const
name|struct
name|usb_audio_streaming_interface_descriptor
modifier|*
name|v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_streaming_interface_descriptor
modifier|*
name|v2
decl_stmt|;
block|}
union|;
end_union

begin_union
union|union
name|uaudio_asf1d
block|{
specifier|const
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_streaming_type1_descriptor
modifier|*
name|v2
decl_stmt|;
block|}
union|;
end_union

begin_union
union|union
name|uaudio_sed
block|{
specifier|const
name|struct
name|usb_audio_streaming_endpoint_descriptor
modifier|*
name|v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_streaming_endpoint_descriptor
modifier|*
name|v2
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|uaudio_mixer_node
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int32_t
name|minval
decl_stmt|;
name|int32_t
name|maxval
decl_stmt|;
define|#
directive|define
name|MIX_MAX_CHAN
value|16
name|int32_t
name|wValue
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
comment|/* using nchan */
name|uint32_t
name|mul
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|wData
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
comment|/* using nchan */
name|uint16_t
name|wIndex
decl_stmt|;
name|uint8_t
name|update
index|[
operator|(
name|MIX_MAX_CHAN
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|nchan
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
define|#
directive|define
name|MIX_ON_OFF
value|1
define|#
directive|define
name|MIX_SIGNED_16
value|2
define|#
directive|define
name|MIX_UNSIGNED_16
value|3
define|#
directive|define
name|MIX_SIGNED_8
value|4
define|#
directive|define
name|MIX_SELECTOR
value|5
define|#
directive|define
name|MIX_UNKNOWN
value|6
define|#
directive|define
name|MIX_SIZE
parameter_list|(
name|n
parameter_list|)
value|((((n) == MIX_SIGNED_16) || \ 		      ((n) == MIX_UNSIGNED_16)) ? 2 : 1)
define|#
directive|define
name|MIX_UNSIGNED
parameter_list|(
name|n
parameter_list|)
value|((n) == MIX_UNSIGNED_16)
define|#
directive|define
name|MAX_SELECTOR_INPUT_PIN
value|256
name|uint8_t
name|slctrtype
index|[
name|MAX_SELECTOR_INPUT_PIN
index|]
decl_stmt|;
name|uint8_t
name|class
decl_stmt|;
name|uint8_t
name|val_default
decl_stmt|;
name|uint8_t
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_configure_msg
block|{
name|struct
name|usb_proc_msg
name|hdr
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CHAN_MAX_ALT
value|24
end_define

begin_struct
struct|struct
name|uaudio_chan_alt
block|{
name|union
name|uaudio_asf1d
name|p_asf1d
decl_stmt|;
name|union
name|uaudio_sed
name|p_sed
decl_stmt|;
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
name|p_ed1
decl_stmt|;
specifier|const
name|struct
name|uaudio_format
modifier|*
name|p_fmt
decl_stmt|;
specifier|const
name|struct
name|usb_config
modifier|*
name|usb_cfg
decl_stmt|;
name|uint32_t
name|sample_rate
decl_stmt|;
comment|/* in Hz */
name|uint16_t
name|sample_size
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|uint8_t
name|iface_alt_index
decl_stmt|;
name|uint8_t
name|channels
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_chan
block|{
name|struct
name|pcmchan_caps
name|pcm_cap
decl_stmt|;
comment|/* capabilities */
name|struct
name|uaudio_chan_alt
name|usb_alt
index|[
name|CHAN_MAX_ALT
index|]
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|pcm_buf
decl_stmt|;
name|struct
name|mtx
modifier|*
name|pcm_mtx
decl_stmt|;
comment|/* lock protecting this structure */
name|struct
name|uaudio_softc
modifier|*
name|priv_sc
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|pcm_ch
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
index|[
name|UAUDIO_NCHANBUFS
operator|+
literal|1
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* pointer to buffer */
name|uint8_t
modifier|*
name|start
decl_stmt|;
comment|/* upper layer buffer start */
name|uint8_t
modifier|*
name|end
decl_stmt|;
comment|/* upper layer buffer end */
name|uint8_t
modifier|*
name|cur
decl_stmt|;
comment|/* current position in upper layer 					 * buffer */
name|uint32_t
name|intr_frames
decl_stmt|;
comment|/* in units */
name|uint32_t
name|frames_per_second
decl_stmt|;
name|uint32_t
name|sample_rem
decl_stmt|;
name|uint32_t
name|sample_curr
decl_stmt|;
name|uint32_t
name|max_buf
decl_stmt|;
name|uint32_t
name|pcm_format
index|[
literal|2
index|]
decl_stmt|;
name|uint16_t
name|bytes_per_frame
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|num_alt
decl_stmt|;
name|uint8_t
name|cur_alt
decl_stmt|;
name|uint8_t
name|set_alt
decl_stmt|;
name|uint8_t
name|operation
decl_stmt|;
define|#
directive|define
name|CHAN_OP_NONE
value|0
define|#
directive|define
name|CHAN_OP_START
value|1
define|#
directive|define
name|CHAN_OP_STOP
value|2
define|#
directive|define
name|CHAN_OP_DRAIN
value|3
name|uint8_t
name|last_sync_time
decl_stmt|;
name|uint8_t
name|last_sync_state
decl_stmt|;
define|#
directive|define
name|UAUDIO_SYNC_NONE
value|0
define|#
directive|define
name|UAUDIO_SYNC_MORE
value|1
define|#
directive|define
name|UAUDIO_SYNC_LESS
value|2
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UMIDI_CABLES_MAX
value|16
end_define

begin_comment
comment|/* units */
end_comment

begin_define
define|#
directive|define
name|UMIDI_TX_FRAMES
value|256
end_define

begin_comment
comment|/* units */
end_comment

begin_define
define|#
directive|define
name|UMIDI_TX_BUFFER
value|(UMIDI_TX_FRAMES * 4)
end_define

begin_comment
comment|/* bytes */
end_comment

begin_enum
enum|enum
block|{
name|UMIDI_TX_TRANSFER
block|,
name|UMIDI_RX_TRANSFER
block|,
name|UMIDI_N_TRANSFER
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|umidi_sub_chan
block|{
name|struct
name|usb_fifo_sc
name|fifo
decl_stmt|;
name|uint8_t
modifier|*
name|temp_cmd
decl_stmt|;
name|uint8_t
name|temp_0
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|temp_1
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|state
decl_stmt|;
define|#
directive|define
name|UMIDI_ST_UNKNOWN
value|0
comment|/* scan for command */
define|#
directive|define
name|UMIDI_ST_1PARAM
value|1
define|#
directive|define
name|UMIDI_ST_2PARAM_1
value|2
define|#
directive|define
name|UMIDI_ST_2PARAM_2
value|3
define|#
directive|define
name|UMIDI_ST_SYSEX_0
value|4
define|#
directive|define
name|UMIDI_ST_SYSEX_1
value|5
define|#
directive|define
name|UMIDI_ST_SYSEX_2
value|6
name|uint8_t
name|read_open
range|:
literal|1
decl_stmt|;
name|uint8_t
name|write_open
range|:
literal|1
decl_stmt|;
name|uint8_t
name|unused
range|:
literal|6
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|umidi_chan
block|{
name|struct
name|umidi_sub_chan
name|sub
index|[
name|UMIDI_CABLES_MAX
index|]
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
index|[
name|UMIDI_N_TRANSFER
index|]
decl_stmt|;
name|uint8_t
name|iface_index
decl_stmt|;
name|uint8_t
name|iface_alt_index
decl_stmt|;
name|uint8_t
name|read_open_refcount
decl_stmt|;
name|uint8_t
name|write_open_refcount
decl_stmt|;
name|uint8_t
name|curr_cable
decl_stmt|;
name|uint8_t
name|max_cable
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
name|uint8_t
name|single_command
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_search_result
block|{
name|uint8_t
name|bit_input
index|[
operator|(
literal|256
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|bit_output
index|[
operator|(
literal|256
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
decl_stmt|;
name|uint8_t
name|recurse_level
decl_stmt|;
name|uint8_t
name|id_max
decl_stmt|;
name|uint8_t
name|is_input
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|UAUDIO_HID_RX_TRANSFER
block|,
name|UAUDIO_HID_N_TRANSFER
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|uaudio_hid
block|{
name|struct
name|usb_xfer
modifier|*
name|xfer
index|[
name|UAUDIO_HID_N_TRANSFER
index|]
decl_stmt|;
name|struct
name|hid_location
name|volume_up_loc
decl_stmt|;
name|struct
name|hid_location
name|volume_down_loc
decl_stmt|;
name|struct
name|hid_location
name|mute_loc
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
define|#
directive|define
name|UAUDIO_HID_VALID
value|0x0001
define|#
directive|define
name|UAUDIO_HID_HAS_ID
value|0x0002
define|#
directive|define
name|UAUDIO_HID_HAS_VOLUME_UP
value|0x0004
define|#
directive|define
name|UAUDIO_HID_HAS_VOLUME_DOWN
value|0x0008
define|#
directive|define
name|UAUDIO_HID_HAS_MUTE
value|0x0010
name|uint8_t
name|iface_index
decl_stmt|;
name|uint8_t
name|volume_up_id
decl_stmt|;
name|uint8_t
name|volume_down_id
decl_stmt|;
name|uint8_t
name|mute_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_softc
block|{
name|struct
name|sbuf
name|sc_sndstat
decl_stmt|;
name|struct
name|sndcard_func
name|sc_sndcard_func
decl_stmt|;
name|struct
name|uaudio_chan
name|sc_rec_chan
decl_stmt|;
name|struct
name|uaudio_chan
name|sc_play_chan
decl_stmt|;
name|struct
name|umidi_chan
name|sc_midi_chan
decl_stmt|;
name|struct
name|uaudio_hid
name|sc_hid
decl_stmt|;
name|struct
name|uaudio_search_result
name|sc_mixer_clocks
decl_stmt|;
name|struct
name|uaudio_mixer_node
name|sc_mixer_node
decl_stmt|;
name|struct
name|uaudio_configure_msg
name|sc_config_msg
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mtx
modifier|*
name|sc_mixer_lock
decl_stmt|;
name|struct
name|snd_mixer
modifier|*
name|sc_mixer_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_udev
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|sc_mixer_xfer
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|sc_mixer_root
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|sc_mixer_curr
decl_stmt|;
name|uint32_t
name|sc_mix_info
decl_stmt|;
name|uint32_t
name|sc_recsrc_info
decl_stmt|;
name|uint16_t
name|sc_audio_rev
decl_stmt|;
name|uint16_t
name|sc_mixer_count
decl_stmt|;
name|uint8_t
name|sc_sndstat_valid
decl_stmt|;
name|uint8_t
name|sc_mixer_iface_index
decl_stmt|;
name|uint8_t
name|sc_mixer_iface_no
decl_stmt|;
name|uint8_t
name|sc_mixer_chan
decl_stmt|;
name|uint8_t
name|sc_pcm_registered
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_mixer_init
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_audio_swap_lr
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_au_inp_async
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_au_no_xu
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_bad_adc
range|:
literal|1
decl_stmt|;
name|uint8_t
name|sc_uq_au_vendor_class
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_terminal_node
block|{
union|union
block|{
specifier|const
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|usb_audio_input_terminal
modifier|*
name|it_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_output_terminal
modifier|*
name|ot_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_mixer_unit_0
modifier|*
name|mu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_selector_unit
modifier|*
name|su_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
name|fu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_0
modifier|*
name|pu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_extension_unit_0
modifier|*
name|eu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_source_unit
modifier|*
name|csrc_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_selector_unit_0
modifier|*
name|csel_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_multiplier_unit
modifier|*
name|cmul_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_input_terminal
modifier|*
name|it_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_output_terminal
modifier|*
name|ot_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_mixer_unit_0
modifier|*
name|mu_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_selector_unit
modifier|*
name|su_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_feature_unit
modifier|*
name|fu_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_sample_rate_unit
modifier|*
name|ru_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_processing_unit_0
modifier|*
name|pu_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_extension_unit_0
modifier|*
name|eu_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_effect_unit
modifier|*
name|ef_v2
decl_stmt|;
block|}
name|u
union|;
name|struct
name|uaudio_search_result
name|usr
decl_stmt|;
name|struct
name|uaudio_terminal_node
modifier|*
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_format
block|{
name|uint16_t
name|wFormat
decl_stmt|;
name|uint8_t
name|bPrecision
decl_stmt|;
name|uint32_t
name|freebsd_fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uaudio_format
name|uaudio10_formats
index|[]
init|=
block|{
block|{
name|UA_FMT_PCM8
block|,
literal|8
block|,
name|AFMT_U8
block|,
literal|"8-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM8
block|,
literal|16
block|,
name|AFMT_U16_LE
block|,
literal|"16-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM8
block|,
literal|24
block|,
name|AFMT_U24_LE
block|,
literal|"24-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM8
block|,
literal|32
block|,
name|AFMT_U32_LE
block|,
literal|"32-bit U-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|8
block|,
name|AFMT_S8
block|,
literal|"8-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|16
block|,
name|AFMT_S16_LE
block|,
literal|"16-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|24
block|,
name|AFMT_S24_LE
block|,
literal|"24-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_PCM
block|,
literal|32
block|,
name|AFMT_S32_LE
block|,
literal|"32-bit S-LE PCM"
block|}
block|,
block|{
name|UA_FMT_ALAW
block|,
literal|8
block|,
name|AFMT_A_LAW
block|,
literal|"8-bit A-Law"
block|}
block|,
block|{
name|UA_FMT_MULAW
block|,
literal|8
block|,
name|AFMT_MU_LAW
block|,
literal|"8-bit mu-Law"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uaudio_format
name|uaudio20_formats
index|[]
init|=
block|{
block|{
name|UA20_FMT_PCM
block|,
literal|8
block|,
name|AFMT_S8
block|,
literal|"8-bit S-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM
block|,
literal|16
block|,
name|AFMT_S16_LE
block|,
literal|"16-bit S-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM
block|,
literal|24
block|,
name|AFMT_S24_LE
block|,
literal|"24-bit S-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM
block|,
literal|32
block|,
name|AFMT_S32_LE
block|,
literal|"32-bit S-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM8
block|,
literal|8
block|,
name|AFMT_U8
block|,
literal|"8-bit U-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM8
block|,
literal|16
block|,
name|AFMT_U16_LE
block|,
literal|"16-bit U-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM8
block|,
literal|24
block|,
name|AFMT_U24_LE
block|,
literal|"24-bit U-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_PCM8
block|,
literal|32
block|,
name|AFMT_U32_LE
block|,
literal|"32-bit U-LE PCM"
block|}
block|,
block|{
name|UA20_FMT_ALAW
block|,
literal|8
block|,
name|AFMT_A_LAW
block|,
literal|"8-bit A-Law"
block|}
block|,
block|{
name|UA20_FMT_MULAW
block|,
literal|8
block|,
name|AFMT_MU_LAW
block|,
literal|"8-bit mu-Law"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UAC_OUTPUT
value|0
end_define

begin_define
define|#
directive|define
name|UAC_INPUT
value|1
end_define

begin_define
define|#
directive|define
name|UAC_EQUAL
value|2
end_define

begin_define
define|#
directive|define
name|UAC_RECORD
value|3
end_define

begin_define
define|#
directive|define
name|UAC_NCLASSES
value|4
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|uac_names
index|[]
init|=
block|{
literal|"outputs"
block|,
literal|"inputs"
block|,
literal|"equalization"
block|,
literal|"record"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|uaudio_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|uaudio_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|uaudio_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uaudio_chan_play_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uaudio_chan_play_sync_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uaudio_chan_record_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uaudio_chan_record_sync_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uaudio_mixer_write_cfg_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umidi_bulk_read_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|umidi_bulk_write_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|uaudio_hid_rx_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_proc_callback_t
name|uaudio_configure_msg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==== USB mixer ==== */
end_comment

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_ctl_free
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_register_sysctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_reload_all
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_controls_create_ftu
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ==== USB audio v1.0 ==== */
end_comment

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|uaudio_mixer_feature_get_bmaControls
parameter_list|(
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb_audio_cluster
name|uaudio_mixer_get_cluster
parameter_list|(
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio_mixer_determine_class
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio_mixer_feature_name
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_find_inputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|uaudio_mixer_verify_desc
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|uaudio_set_speed
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_get
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ==== USB audio v2.0 ==== */
end_comment

begin_function_decl
specifier|static
name|void
name|uaudio20_mixer_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio20_mixer_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio20_mixer_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb_audio20_cluster
name|uaudio20_mixer_get_cluster
parameter_list|(
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio20_mixer_determine_class
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|uaudio20_mixer_feature_name
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio20_mixer_find_inputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|uaudio20_mixer_verify_desc
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|uaudio20_set_speed
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* USB audio v1.0 and v2.0 */
end_comment

begin_function_decl
specifier|static
name|void
name|uaudio_chan_fill_info_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_chan_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_ctl_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|usb_device
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_signext
parameter_list|(
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_mixer_bsd2value
parameter_list|(
name|struct
name|uaudio_mixer_node
modifier|*
parameter_list|,
name|int32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_init
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_input
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_output
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_mixer_find_outputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|umidi_convert_to_usb
parameter_list|(
name|struct
name|umidi_sub_chan
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umidi_sub_chan
modifier|*
name|umidi_sub_by_fifo
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_start_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_stop_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_start_write
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_stop_write
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umidi_open
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umidi_ioctl
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umidi_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umidi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umidi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uaudio_hid_probe
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uaudio_hid_detach
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|uaudio_chan_dump_ep_desc
parameter_list|(
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|uaudio_cfg_record
index|[
name|UAUDIO_NCHANBUFS
operator|+
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|frames
operator|=
name|UAUDIO_NFRAMES
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_record_callback
block|, 	}
block|,
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|frames
operator|=
name|UAUDIO_NFRAMES
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_record_callback
block|, 	}
block|,
index|[
literal|2
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|frames
operator|=
literal|1
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|no_pipe_ok
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_record_sync_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|uaudio_cfg_play
index|[
name|UAUDIO_NCHANBUFS
operator|+
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|frames
operator|=
name|UAUDIO_NFRAMES
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_play_callback
block|, 	}
block|,
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|frames
operator|=
name|UAUDIO_NFRAMES
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_play_callback
block|, 	}
block|,
index|[
literal|2
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_ISOCHRONOUS
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use "wMaxPacketSize * frames" */
operator|.
name|frames
operator|=
literal|1
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|no_pipe_ok
operator|=
literal|1
block|,
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_chan_play_sync_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|uaudio_mixer_config
index|[
literal|1
index|]
init|=
block|{
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* Control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|bufsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|+
literal|4
operator|)
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_mixer_write_cfg_callback
block|,
operator|.
name|timeout
operator|=
literal|1000
block|,
comment|/* 1 second */
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|umidi_cmd_to_len
index|[
literal|16
index|]
init|=
block|{
index|[
literal|0x0
index|]
operator|=
literal|0
block|,
comment|/* reserved */
index|[
literal|0x1
index|]
operator|=
literal|0
block|,
comment|/* reserved */
index|[
literal|0x2
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0x3
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x4
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x5
index|]
operator|=
literal|1
block|,
comment|/* bytes */
index|[
literal|0x6
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0x7
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x8
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0x9
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xA
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xB
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xC
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0xD
index|]
operator|=
literal|2
block|,
comment|/* bytes */
index|[
literal|0xE
index|]
operator|=
literal|3
block|,
comment|/* bytes */
index|[
literal|0xF
index|]
operator|=
literal|1
block|,
comment|/* bytes */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|umidi_config
index|[
name|UMIDI_N_TRANSFER
index|]
init|=
block|{
index|[
name|UMIDI_TX_TRANSFER
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_OUT
block|,
operator|.
name|bufsize
operator|=
name|UMIDI_TX_BUFFER
block|,
operator|.
name|callback
operator|=
operator|&
name|umidi_bulk_write_callback
block|, 	}
block|,
index|[
name|UMIDI_RX_TRANSFER
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_BULK
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
literal|4
block|,
comment|/* bytes */
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,
operator|.
name|proxy_buffer
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|umidi_bulk_read_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|usb_config
name|uaudio_hid_config
index|[
name|UAUDIO_HID_N_TRANSFER
index|]
init|=
block|{
index|[
name|UAUDIO_HID_RX_TRANSFER
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_INTERRUPT
block|,
operator|.
name|endpoint
operator|=
name|UE_ADDR_ANY
block|,
operator|.
name|direction
operator|=
name|UE_DIR_IN
block|,
operator|.
name|bufsize
operator|=
literal|0
block|,
comment|/* use wMaxPacketSize */
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|,}
block|,
operator|.
name|callback
operator|=
operator|&
name|uaudio_hid_rx_callback
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|uaudio_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|uaudio_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|uaudio_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|uaudio_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|uaudio_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|uaudio_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"uaudio"
block|,
operator|.
name|methods
operator|=
name|uaudio_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|uaudio_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following table is derived from Linux's quirks-table.h */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|uaudio_vendor_midi
index|[]
init|=
block|{
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1000
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* UX256 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1001
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MU1000 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1002
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MU2000 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1003
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MU500 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1004
argument_list|,
literal|3
argument_list|)
block|}
block|,
comment|/* UW500 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1005
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF6 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1006
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF7 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1007
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF8 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1008
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* UX96 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1009
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* UX16 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x100a
argument_list|,
literal|3
argument_list|)
block|}
block|,
comment|/* EOS BX */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x100c
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* UC-MX */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x100d
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* UC-KX */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x100e
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* S08 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x100f
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CLP-150 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1010
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CLP-170 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1011
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* P-250 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1012
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* TYROS */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1013
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PF-500 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1014
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* S90 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1015
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF-R */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1016
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MDP-5 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1017
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-204 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1018
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-206 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1019
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-208 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x101a
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-210 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x101b
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PSR-1100 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x101c
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PSR-2100 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x101d
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CLP-175 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x101e
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PSR-K1 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x101f
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* EZ-J24 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1020
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* EZ-250i */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1021
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF ES 6 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1022
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF ES 7 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1023
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* MOTIF ES 8 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1024
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-301 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1025
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-303 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1026
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-305 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1027
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-307 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1028
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-309 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1029
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CVP-309GP */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x102a
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PSR-1500 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x102b
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PSR-3000 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x102e
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* ELS-01/01C */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1030
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PSR-295/293 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1031
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DGX-205/203 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1032
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DGX-305 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1033
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DGX-505 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1034
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1035
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1036
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1037
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1038
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1039
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x103a
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x103b
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x103c
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x103d
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x103e
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x103f
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1040
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1041
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1042
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1043
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1044
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1045
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x104e
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x104f
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1050
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1051
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1052
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1053
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1054
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1055
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1056
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1057
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1058
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1059
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x105a
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x105b
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x105c
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x105d
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x1503
argument_list|,
literal|3
argument_list|)
block|}
block|,
comment|/* MOX6/MOX8 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x2000
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DGP-7 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x2001
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DGP-5 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x2002
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x2003
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5000
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* CS1D */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5001
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DSP1D */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5002
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DME32 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5003
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DM2000 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5004
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* 02R96 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5005
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* ACU16-C */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5006
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NHB32-C */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5007
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DM1000 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5008
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* 01V96 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x5009
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* SPX2000 */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x500a
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* PM5D */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x500b
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DME64N */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x500c
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DME24N */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x500d
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x500e
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x500f
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* NULL */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x7000
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* DTX */
block|{
name|USB_VPI
argument_list|(
argument|USB_VENDOR_YAMAHA
argument_list|,
literal|0x7010
argument_list|,
literal|0
argument_list|)
block|}
block|,
comment|/* UB99 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|STRUCT_USB_HOST_ID
name|__used
name|uaudio_devs
index|[]
init|=
block|{
comment|/* Generic USB audio class match */
block|{
name|USB_IFACE_CLASS
argument_list|(
name|UICLASS_AUDIO
argument_list|)
block|,
name|USB_IFACE_SUBCLASS
argument_list|(
name|UISUBCLASS_AUDIOCONTROL
argument_list|)
block|,}
block|,
comment|/* Generic USB MIDI class match */
block|{
name|USB_IFACE_CLASS
argument_list|(
name|UICLASS_AUDIO
argument_list|)
block|,
name|USB_IFACE_SUBCLASS
argument_list|(
name|UISUBCLASS_MIDISTREAM
argument_list|)
block|,}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|uaudio_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* lookup non-standard device(s) */
if|if
condition|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|uaudio_vendor_midi
argument_list|,
sizeof|sizeof
argument_list|(
name|uaudio_vendor_midi
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|BUS_PROBE_SPECIFIC
operator|)
return|;
block|}
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|!=
name|UICLASS_AUDIO
condition|)
block|{
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|!=
name|UICLASS_VENDOR
operator|||
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AU_VENDOR_CLASS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* check for AUDIO control interface */
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_AUDIOCONTROL
condition|)
block|{
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_BAD_AUDIO
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
comment|/* check for MIDI stream */
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_MIDISTREAM
condition|)
block|{
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_BAD_MIDI
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|sc
operator|->
name|sc_play_chan
operator|.
name|priv_sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_rec_chan
operator|.
name|priv_sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|sc
operator|->
name|sc_mixer_iface_index
operator|=
name|uaa
operator|->
name|info
operator|.
name|bIfaceIndex
expr_stmt|;
name|sc
operator|->
name|sc_mixer_iface_no
operator|=
name|uaa
operator|->
name|info
operator|.
name|bIfaceNum
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|uaudio_configure_msg
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
operator|.
name|hdr
operator|.
name|pm_callback
operator|=
operator|&
name|uaudio_configure_msg
expr_stmt|;
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AUDIO_SWAP_LR
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_audio_swap_lr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AU_INP_ASYNC
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_au_inp_async
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AU_NO_XU
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_au_no_xu
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_BAD_ADC
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_bad_adc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_AU_VENDOR_CLASS
argument_list|)
condition|)
name|sc
operator|->
name|sc_uq_au_vendor_class
operator|=
literal|1
expr_stmt|;
name|umidi_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
comment|/* must fill mixer info before channel info */
name|uaudio_mixer_fill_info
argument_list|(
name|sc
argument_list|,
name|uaa
operator|->
name|device
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* fill channel info */
name|uaudio_chan_fill_info
argument_list|(
name|sc
argument_list|,
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"audio rev %d.%02x\n"
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|>>
literal|8
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mixer_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|==
name|USB_VENDOR_MAUDIO
operator|&&
operator|(
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|==
name|USB_PRODUCT_MAUDIO_FASTTRACKULTRA
operator|||
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|==
name|USB_PRODUCT_MAUDIO_FASTTRACKULTRA8R
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Generating mixer descriptors\n"
argument_list|)
expr_stmt|;
name|uaudio_mixer_controls_create_ftu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|"%d mixer controls\n"
argument_list|,
name|sc
operator|->
name|sc_mixer_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|num_alt
operator|>
literal|0
condition|)
block|{
name|uint8_t
name|x
decl_stmt|;
comment|/* 		 * Need to set a default alternate interface, else 		 * some USB audio devices might go into an infinte 		 * re-enumeration loop: 		 */
name|err
operator|=
name|usbd_set_alt_interface_index
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|usb_alt
index|[
literal|0
index|]
operator|.
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|usb_alt
index|[
literal|0
index|]
operator|.
name|iface_alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"setting of alternate index failed: %s!\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_play_chan
operator|.
name|num_alt
condition|;
name|x
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Play: %d Hz, %d ch, %s format, "
literal|"2x8ms buffer.\n"
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|usb_alt
index|[
name|x
index|]
operator|.
name|sample_rate
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|usb_alt
index|[
name|x
index|]
operator|.
name|channels
argument_list|,
name|sc
operator|->
name|sc_play_chan
operator|.
name|usb_alt
index|[
name|x
index|]
operator|.
name|p_fmt
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No playback.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|num_alt
operator|>
literal|0
condition|)
block|{
name|uint8_t
name|x
decl_stmt|;
comment|/* 		 * Need to set a default alternate interface, else 		 * some USB audio devices might go into an infinte 		 * re-enumeration loop: 		 */
name|err
operator|=
name|usbd_set_alt_interface_index
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|usb_alt
index|[
literal|0
index|]
operator|.
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|usb_alt
index|[
literal|0
index|]
operator|.
name|iface_alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"setting of alternate index failed: %s!\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|sc
operator|->
name|sc_rec_chan
operator|.
name|num_alt
condition|;
name|x
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Record: %d Hz, %d ch, %s format, "
literal|"2x8ms buffer.\n"
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|usb_alt
index|[
name|x
index|]
operator|.
name|sample_rate
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|usb_alt
index|[
name|x
index|]
operator|.
name|channels
argument_list|,
name|sc
operator|->
name|sc_rec_chan
operator|.
name|usb_alt
index|[
name|x
index|]
operator|.
name|p_fmt
operator|->
name|description
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No recording.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|usbd_lookup_id_by_uaa
argument_list|(
name|uaudio_vendor_midi
argument_list|,
sizeof|sizeof
argument_list|(
name|uaudio_vendor_midi
argument_list|)
argument_list|,
name|uaa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_midi_chan
operator|.
name|iface_index
operator|=
operator|(
name|uint8_t
operator|)
name|uaa
operator|->
name|driver_info
expr_stmt|;
name|sc
operator|->
name|sc_midi_chan
operator|.
name|iface_alt_index
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
condition|)
block|{
if|if
condition|(
name|umidi_probe
argument_list|(
name|dev
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MIDI sequencer.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No MIDI sequencer.\n"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"doing child attach\n"
argument_list|)
expr_stmt|;
comment|/* attach the children */
name|sc
operator|->
name|sc_sndcard_func
operator|.
name|func
operator|=
name|SCF_PCM
expr_stmt|;
comment|/* 	 * Only attach a PCM device if we have a playback, recording 	 * or mixer device present: 	 */
if|if
condition|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|num_alt
operator|>
literal|0
operator|||
name|sc
operator|->
name|sc_rec_chan
operator|.
name|num_alt
operator|>
literal|0
operator|||
name|sc
operator|->
name|sc_mix_info
condition|)
block|{
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|sc_sndcard_func
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"child attach failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
if|if
condition|(
name|uaudio_hid_probe
argument_list|(
name|sc
argument_list|,
name|uaa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HID volume keys found.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No HID volume keys found.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* reload all mixer settings */
name|uaudio_mixer_reload_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|uaudio_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_pcm_setflags
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|pcm_setflags
argument_list|(
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|dev
argument_list|)
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uaudio_attach_sub
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|kobj_class_t
name|mixer_class
parameter_list|,
name|kobj_class_t
name|chan_class
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|uaudio_mixer_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_uq_audio_swap_lr
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"hardware has swapped left and right\n"
argument_list|)
expr_stmt|;
comment|/* uaudio_pcm_setflags(dev, SD_F_PSWAPLR); */
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mix_info
operator|&
name|SOUND_MASK_PCM
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"emulating master volume\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Emulate missing pcm mixer controller 		 * through FEEDER_VOLUME 		 */
name|uaudio_pcm_setflags
argument_list|(
name|dev
argument_list|,
name|SD_F_SOFTPCMVOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|mixer_class
argument_list|,
name|sc
argument_list|)
condition|)
goto|goto
name|detach
goto|;
name|sc
operator|->
name|sc_mixer_init
operator|=
literal|1
expr_stmt|;
name|mixer_hwvol_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|"at ? %s"
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_uaudio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
operator|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|num_alt
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|num_alt
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
name|uaudio_pcm_setflags
argument_list|(
name|dev
argument_list|,
name|SD_F_MPSAFE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pcm_registered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|num_alt
operator|>
literal|0
condition|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|chan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|num_alt
operator|>
literal|0
condition|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
name|chan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|uaudio_mixer_register_sysctl
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
name|uaudio_detach_sub
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_detach_sub
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|repeat
label|:
if|if
condition|(
name|sc
operator|->
name|sc_pcm_registered
condition|)
block|{
name|error
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_mixer_init
condition|)
block|{
name|error
operator|=
name|mixer_uninit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Waiting for sound application to exit!\n"
argument_list|)
expr_stmt|;
name|usb_pause_mtx
argument_list|(
name|NULL
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
comment|/* try again */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* 	 * Stop USB transfers early so that any audio applications 	 * will time out and close opened /dev/dspX.Y device(s), if 	 * any. 	 */
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_play_chan
operator|.
name|operation
operator|=
name|CHAN_OP_DRAIN
expr_stmt|;
name|sc
operator|->
name|sc_rec_chan
operator|.
name|operation
operator|=
name|CHAN_OP_DRAIN
expr_stmt|;
name|usb_proc_explore_mwait
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_play_chan
operator|.
name|xfer
argument_list|,
name|UAUDIO_NCHANBUFS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_rec_chan
operator|.
name|xfer
argument_list|,
name|UAUDIO_NCHANBUFS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|uaudio_hid_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"detach failed!\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_delete
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sndstat_valid
operator|=
literal|0
expr_stmt|;
name|umidi_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* free mixer data */
name|uaudio_mixer_ctl_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|uaudio_get_buffer_size
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint8_t
name|alt
parameter_list|)
block|{
name|struct
name|uaudio_chan_alt
modifier|*
name|chan_alt
init|=
operator|&
name|ch
operator|->
name|usb_alt
index|[
name|alt
index|]
decl_stmt|;
comment|/* We use 2 times 8ms of buffer */
name|uint32_t
name|buf_size
init|=
operator|(
operator|(
operator|(
name|chan_alt
operator|->
name|sample_rate
operator|*
operator|(
name|UAUDIO_NFRAMES
operator|/
literal|8
operator|)
operator|)
operator|+
literal|1000
operator|-
literal|1
operator|)
operator|/
literal|1000
operator|)
operator|*
name|chan_alt
operator|->
name|sample_size
decl_stmt|;
return|return
operator|(
name|buf_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_configure_msg_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_chan
modifier|*
name|chan
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_chan_alt
modifier|*
name|chan_alt
decl_stmt|;
name|uint32_t
name|frames
decl_stmt|;
name|uint32_t
name|buf_size
decl_stmt|;
name|uint16_t
name|fps
decl_stmt|;
name|uint8_t
name|set_alt
decl_stmt|;
name|uint8_t
name|fps_shift
decl_stmt|;
name|uint8_t
name|operation
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|num_alt
operator|<=
literal|0
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|operation
operator|=
name|chan
operator|->
name|operation
expr_stmt|;
name|chan
operator|->
name|operation
operator|=
name|CHAN_OP_NONE
expr_stmt|;
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|cur_alt
operator|!=
name|chan
operator|->
name|set_alt
condition|)
name|set_alt
operator|=
name|chan
operator|->
name|set_alt
expr_stmt|;
else|else
name|set_alt
operator|=
name|CHAN_MAX_ALT
expr_stmt|;
name|mtx_unlock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_alt
operator|>=
name|chan
operator|->
name|num_alt
condition|)
goto|goto
name|done
goto|;
name|chan_alt
operator|=
name|chan
operator|->
name|usb_alt
operator|+
name|set_alt
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|chan
operator|->
name|xfer
argument_list|,
name|UAUDIO_NCHANBUFS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_set_alt_interface_index
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan_alt
operator|->
name|iface_index
argument_list|,
name|chan_alt
operator|->
name|iface_alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"setting of alternate index failed: %s!\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Only set the sample rate if the channel reports that it 	 * supports the frequency control. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
comment|/* FALLTHROUGH */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
literal|256
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mixer_clocks
operator|.
name|bit_output
index|[
name|x
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mixer_clocks
operator|.
name|bit_input
index|[
name|x
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|uaudio20_set_speed
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|,
name|x
argument_list|,
name|chan_alt
operator|->
name|sample_rate
argument_list|)
condition|)
block|{
comment|/* 				 * If the endpoint is adaptive setting 				 * the speed may fail. 				 */
name|DPRINTF
argument_list|(
literal|"setting of sample rate failed! "
literal|"(continuing anyway)\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|chan_alt
operator|->
name|p_sed
operator|.
name|v1
operator|->
name|bmAttributes
operator|&
name|UA_SED_FREQ_CONTROL
condition|)
block|{
if|if
condition|(
name|uaudio_set_speed
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan_alt
operator|->
name|p_ed1
operator|->
name|bEndpointAddress
argument_list|,
name|chan_alt
operator|->
name|sample_rate
argument_list|)
condition|)
block|{
comment|/* 			 * If the endpoint is adaptive setting the 			 * speed may fail. 			 */
name|DPRINTF
argument_list|(
literal|"setting of sample rate failed! "
literal|"(continuing anyway)\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbd_transfer_setup
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|chan_alt
operator|->
name|iface_index
argument_list|,
name|chan
operator|->
name|xfer
argument_list|,
name|chan_alt
operator|->
name|usb_cfg
argument_list|,
name|UAUDIO_NCHANBUFS
operator|+
literal|1
argument_list|,
name|chan
argument_list|,
name|chan
operator|->
name|pcm_mtx
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"could not allocate USB transfers!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|fps
operator|=
name|usbd_get_isoc_fps
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fps
operator|<
literal|8000
condition|)
block|{
comment|/* FULL speed USB */
name|frames
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* HIGH speed USB */
name|frames
operator|=
name|UAUDIO_NFRAMES
expr_stmt|;
block|}
name|fps_shift
operator|=
name|usbd_xfer_get_fps_shift
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* down shift number of frames per second, if any */
name|fps
operator|>>=
name|fps_shift
expr_stmt|;
name|frames
operator|>>=
name|fps_shift
expr_stmt|;
comment|/* bytes per frame should not be zero */
name|chan
operator|->
name|bytes_per_frame
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|chan_alt
operator|->
name|sample_rate
operator|/
name|fps
operator|)
operator|*
name|chan_alt
operator|->
name|sample_size
operator|)
expr_stmt|;
name|chan
operator|->
name|bytes_per_frame
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|chan_alt
operator|->
name|sample_rate
operator|+
name|fps
operator|-
literal|1
operator|)
operator|/
name|fps
operator|)
operator|*
name|chan_alt
operator|->
name|sample_size
operator|)
expr_stmt|;
comment|/* setup data rate dithering, if any */
name|chan
operator|->
name|frames_per_second
operator|=
name|fps
expr_stmt|;
name|chan
operator|->
name|sample_rem
operator|=
name|chan_alt
operator|->
name|sample_rate
operator|%
name|fps
expr_stmt|;
name|chan
operator|->
name|sample_curr
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|frames_per_second
operator|=
name|fps
expr_stmt|;
comment|/* compute required buffer size */
name|buf_size
operator|=
operator|(
name|chan
operator|->
name|bytes_per_frame
index|[
literal|1
index|]
operator|*
name|frames
operator|)
expr_stmt|;
if|if
condition|(
name|buf_size
operator|>
operator|(
name|chan
operator|->
name|end
operator|-
name|chan
operator|->
name|start
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"buffer size is too big\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|chan
operator|->
name|intr_frames
operator|=
name|frames
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"fps=%d sample_rem=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|fps
argument_list|,
operator|(
name|int
operator|)
name|chan
operator|->
name|sample_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|intr_frames
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"frame shift is too high!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mtx_lock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
name|chan
operator|->
name|cur_alt
operator|=
name|set_alt
expr_stmt|;
name|mtx_unlock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
name|done
label|:
if|#
directive|if
operator|(
name|UAUDIO_NCHANBUFS
operator|!=
literal|2
operator|)
error|#
directive|error
literal|"please update code"
endif|#
directive|endif
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|CHAN_OP_START
case|:
name|mtx_lock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAN_OP_STOP
case|:
name|mtx_lock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
name|error
label|:
name|usbd_transfer_unsetup
argument_list|(
name|chan
operator|->
name|xfer
argument_list|,
name|UAUDIO_NCHANBUFS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
name|chan
operator|->
name|cur_alt
operator|=
name|CHAN_MAX_ALT
expr_stmt|;
name|mtx_unlock
argument_list|(
name|chan
operator|->
name|pcm_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_configure_msg
parameter_list|(
name|struct
name|usb_proc_msg
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
operator|(
operator|(
expr|struct
name|uaudio_configure_msg
operator|*
operator|)
name|pm
operator|)
operator|->
name|sc
decl_stmt|;
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
name|uaudio_configure_msg_sub
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_play_chan
argument_list|,
name|PCMDIR_PLAY
argument_list|)
expr_stmt|;
name|uaudio_configure_msg_sub
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rec_chan
argument_list|,
name|PCMDIR_REC
argument_list|)
expr_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================================*  * AS - Audio Stream - routines  *========================================================================*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|uaudio_chan_dump_ep_desc
parameter_list|(
specifier|const
name|usb_endpoint_descriptor_audio_t
modifier|*
name|ed
parameter_list|)
block|{
if|if
condition|(
name|ed
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"endpoint=%p bLength=%d bDescriptorType=%d \n"
literal|"bEndpointAddress=%d bmAttributes=0x%x \n"
literal|"wMaxPacketSize=%d bInterval=%d \n"
literal|"bRefresh=%d bSynchAddress=%d\n"
argument_list|,
name|ed
argument_list|,
name|ed
operator|->
name|bLength
argument_list|,
name|ed
operator|->
name|bDescriptorType
argument_list|,
name|ed
operator|->
name|bEndpointAddress
argument_list|,
name|ed
operator|->
name|bmAttributes
argument_list|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
argument_list|,
name|ed
operator|->
name|bInterval
argument_list|,
name|UEP_HAS_REFRESH
argument_list|(
name|ed
argument_list|)
condition|?
name|ed
operator|->
name|bRefresh
else|:
literal|0
argument_list|,
name|UEP_HAS_SYNCADDR
argument_list|(
name|ed
argument_list|)
condition|?
name|ed
operator|->
name|bSynchAddress
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following is a workaround for broken no-name USB audio devices  * sold by dealextreme called "3D sound". The problem is that the  * manufacturer computed wMaxPacketSize is too small to hold the  * actual data sent. In other words the device sometimes sends more  * data than it actually reports it can send in a single isochronous  * packet.  */
end_comment

begin_function
specifier|static
name|void
name|uaudio_record_fix_fs
parameter_list|(
name|usb_endpoint_descriptor_audio_t
modifier|*
name|ep
parameter_list|,
name|uint32_t
name|xps
parameter_list|,
name|uint32_t
name|add
parameter_list|)
block|{
name|uint32_t
name|mps
decl_stmt|;
name|mps
operator|=
name|UGETW
argument_list|(
name|ep
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
comment|/* 	 * If the device indicates it can send more data than what the 	 * sample rate indicates, we apply the workaround. 	 */
if|if
condition|(
name|mps
operator|>
name|xps
condition|)
block|{
comment|/* allow additional data */
name|xps
operator|+=
name|add
expr_stmt|;
comment|/* check against the maximum USB 1.x length */
if|if
condition|(
name|xps
operator|>
literal|1023
condition|)
name|xps
operator|=
literal|1023
expr_stmt|;
comment|/* check if we should do an update */
if|if
condition|(
name|mps
operator|<
name|xps
condition|)
block|{
comment|/* simply update the wMaxPacketSize field */
name|USETW
argument_list|(
name|ep
operator|->
name|wMaxPacketSize
argument_list|,
name|xps
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Workaround: Updated wMaxPacketSize "
literal|"from %d to %d bytes.\n"
argument_list|,
operator|(
name|int
operator|)
name|mps
argument_list|,
operator|(
name|int
operator|)
name|xps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|uaudio20_check_rate
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_no
parameter_list|,
name|uint8_t
name|clockid
parameter_list|,
name|uint32_t
name|rate
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|usb_error_t
name|error
decl_stmt|;
name|uint8_t
name|data
index|[
literal|255
index|]
decl_stmt|;
name|uint16_t
name|actlen
decl_stmt|;
name|uint16_t
name|rates
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"ifaceno=%d clockid=%d rate=%u\n"
argument_list|,
name|iface_no
argument_list|,
name|clockid
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UA20_CS_RANGE
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UA20_CS_SAM_FREQ_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|clockid
argument_list|,
name|iface_no
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_do_request_flags
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|,
name|USB_SHORT_XFER_OK
argument_list|,
operator|&
name|actlen
argument_list|,
name|USB_DEFAULT_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|actlen
operator|<
literal|2
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
name|rates
operator|=
name|data
index|[
literal|0
index|]
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|actlen
operator|=
operator|(
name|actlen
operator|-
literal|2
operator|)
operator|/
literal|12
expr_stmt|;
if|if
condition|(
name|rates
operator|>
name|actlen
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Too many rates\n"
argument_list|)
expr_stmt|;
name|rates
operator|=
name|actlen
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|rates
condition|;
name|x
operator|++
control|)
block|{
name|uint32_t
name|min
init|=
name|UGETDW
argument_list|(
name|data
operator|+
literal|2
operator|+
operator|(
literal|12
operator|*
name|x
operator|)
argument_list|)
decl_stmt|;
name|uint32_t
name|max
init|=
name|UGETDW
argument_list|(
name|data
operator|+
literal|6
operator|+
operator|(
literal|12
operator|*
name|x
operator|)
argument_list|)
decl_stmt|;
name|uint32_t
name|res
init|=
name|UGETDW
argument_list|(
name|data
operator|+
literal|10
operator|+
operator|(
literal|12
operator|*
name|x
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Zero residue\n"
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Swapped max and min\n"
argument_list|)
expr_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|min
expr_stmt|;
name|min
operator|=
name|max
expr_stmt|;
name|max
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|rate
operator|>=
name|min
operator|&&
name|rate
operator|<=
name|max
operator|&&
operator|(
operator|(
operator|(
name|rate
operator|-
name|min
operator|)
operator|%
name|res
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_fill_info_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint32_t
name|rate
parameter_list|,
name|uint8_t
name|channels
parameter_list|,
name|uint8_t
name|bit_resolution
parameter_list|)
block|{
name|struct
name|usb_descriptor
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
name|union
name|uaudio_asid
name|asid
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|union
name|uaudio_asf1d
name|asf1d
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|union
name|uaudio_sed
name|sed
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|usb_endpoint_descriptor_audio_t
modifier|*
name|ed1
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|usb_audio_control_descriptor
modifier|*
name|acdp
init|=
name|NULL
decl_stmt|;
name|struct
name|usb_config_descriptor
modifier|*
name|cd
init|=
name|usbd_get_config_descriptor
argument_list|(
name|udev
argument_list|)
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|uaudio_format
modifier|*
name|p_fmt
init|=
name|NULL
decl_stmt|;
name|struct
name|uaudio_chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|uaudio_chan_alt
modifier|*
name|chan_alt
decl_stmt|;
name|uint32_t
name|format
decl_stmt|;
name|uint16_t
name|curidx
init|=
literal|0xFFFF
decl_stmt|;
name|uint16_t
name|lastidx
init|=
literal|0xFFFF
decl_stmt|;
name|uint16_t
name|alt_index
init|=
literal|0
decl_stmt|;
name|uint16_t
name|audio_rev
init|=
literal|0
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint8_t
name|ep_dir
decl_stmt|;
name|uint8_t
name|bChannels
decl_stmt|;
name|uint8_t
name|bBitResolution
decl_stmt|;
name|uint8_t
name|audio_if
init|=
literal|0
decl_stmt|;
name|uint8_t
name|uma_if_class
decl_stmt|;
while|while
condition|(
operator|(
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
condition|)
block|{
name|id
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|bInterfaceNumber
operator|!=
name|lastidx
condition|)
block|{
name|lastidx
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
name|curidx
operator|++
expr_stmt|;
name|alt_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|alt_index
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
name|UAUDIO_HID_VALID
operator|)
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_HID
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|==
literal|0
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceProtocol
operator|==
literal|0
operator|)
operator|&&
operator|(
name|alt_index
operator|==
literal|0
operator|)
operator|&&
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|curidx
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Found HID interface at %d\n"
argument_list|,
name|curidx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator||=
name|UAUDIO_HID_VALID
expr_stmt|;
name|sc
operator|->
name|sc_hid
operator|.
name|iface_index
operator|=
name|curidx
expr_stmt|;
block|}
name|uma_if_class
operator|=
operator|(
operator|(
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_AUDIO
operator|)
operator|||
operator|(
operator|(
name|id
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_VENDOR
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_uq_au_vendor_class
operator|!=
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|uma_if_class
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_AUDIOSTREAM
operator|)
condition|)
block|{
name|audio_if
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|audio_if
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uma_if_class
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|==
name|UISUBCLASS_MIDISTREAM
operator|)
condition|)
block|{
comment|/* 				 * XXX could allow multiple MIDI interfaces 				 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
operator|==
literal|0
operator|)
operator|&&
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|curidx
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_midi_chan
operator|.
name|iface_index
operator|=
name|curidx
expr_stmt|;
name|sc
operator|->
name|sc_midi_chan
operator|.
name|iface_alt_index
operator|=
name|alt_index
expr_stmt|;
name|sc
operator|->
name|sc_midi_chan
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|asid
operator|.
name|v1
operator|=
name|NULL
expr_stmt|;
name|asf1d
operator|.
name|v1
operator|=
name|NULL
expr_stmt|;
name|ed1
operator|=
name|NULL
expr_stmt|;
name|sed
operator|.
name|v1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|audio_if
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|acdp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|UDESCSUB_AC_HEADER
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|acdp
argument_list|)
operator|)
condition|)
block|{
name|acdp
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
name|audio_rev
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Don't collect any USB audio descriptors if 			 * this is not an USB audio stream interface. 			 */
continue|continue;
block|}
if|if
condition|(
operator|(
name|acdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|AS_GENERAL
operator|)
operator|&&
operator|(
name|asid
operator|.
name|v1
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
comment|/* FALLTHROUGH */
block|}
elseif|else
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|asid
operator|.
name|v2
argument_list|)
condition|)
block|{
name|asid
operator|.
name|v2
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|asid
operator|.
name|v1
argument_list|)
condition|)
block|{
name|asid
operator|.
name|v1
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|acdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|FORMAT_TYPE
operator|)
operator|&&
operator|(
name|asf1d
operator|.
name|v1
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
comment|/* FALLTHROUGH */
block|}
elseif|else
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|asf1d
operator|.
name|v2
argument_list|)
condition|)
name|asf1d
operator|.
name|v2
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|asf1d
operator|.
name|v1
argument_list|)
condition|)
block|{
name|asf1d
operator|.
name|v1
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|asf1d
operator|.
name|v1
operator|->
name|bFormatType
operator|!=
name|FORMAT_TYPE_I
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"ignored bFormatType = %d\n"
argument_list|,
name|asf1d
operator|.
name|v1
operator|->
name|bFormatType
argument_list|)
expr_stmt|;
name|asf1d
operator|.
name|v1
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|desc
operator|->
name|bLength
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|asf1d
operator|.
name|v1
argument_list|)
operator|+
operator|(
operator|(
name|asf1d
operator|.
name|v1
operator|->
name|bSamFreqType
operator|==
literal|0
operator|)
condition|?
literal|6
else|:
operator|(
name|asf1d
operator|.
name|v1
operator|->
name|bSamFreqType
operator|*
literal|3
operator|)
operator|)
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"invalid descriptor, "
literal|"too short\n"
argument_list|)
expr_stmt|;
name|asf1d
operator|.
name|v1
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
name|UEP_MINSIZE
operator|)
operator|&&
operator|(
name|ed1
operator|==
name|NULL
operator|)
condition|)
block|{
name|ed1
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ed1
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_ISOCHRONOUS
condition|)
block|{
name|ed1
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|acdp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_CS_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|AS_GENERAL
operator|)
operator|&&
operator|(
name|sed
operator|.
name|v1
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
comment|/* FALLTHROUGH */
block|}
elseif|else
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|sed
operator|.
name|v2
argument_list|)
condition|)
name|sed
operator|.
name|v2
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|sed
operator|.
name|v1
argument_list|)
condition|)
name|sed
operator|.
name|v1
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asid
operator|.
name|v1
operator|==
name|NULL
operator|||
name|asf1d
operator|.
name|v1
operator|==
name|NULL
operator|||
name|ed1
operator|==
name|NULL
operator|||
name|sed
operator|.
name|v1
operator|==
name|NULL
condition|)
block|{
comment|/* need more descriptors */
continue|continue;
block|}
name|ep_dir
operator|=
name|UE_GET_DIR
argument_list|(
name|ed1
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
comment|/* We ignore sync endpoint information until further. */
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
goto|goto
name|next_ep
goto|;
block|}
elseif|else
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
name|uint32_t
name|dwFormat
decl_stmt|;
name|dwFormat
operator|=
name|UGETDW
argument_list|(
name|asid
operator|.
name|v2
operator|->
name|bmFormats
argument_list|)
expr_stmt|;
name|bChannels
operator|=
name|asid
operator|.
name|v2
operator|->
name|bNrChannels
expr_stmt|;
name|bBitResolution
operator|=
name|asf1d
operator|.
name|v2
operator|->
name|bSubslotSize
operator|*
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|bChannels
operator|!=
name|channels
operator|)
operator|||
operator|(
name|bBitResolution
operator|!=
name|bit_resolution
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong number of channels\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
for|for
control|(
name|p_fmt
operator|=
name|uaudio20_formats
init|;
name|p_fmt
operator|->
name|wFormat
operator|!=
literal|0
condition|;
name|p_fmt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_fmt
operator|->
name|wFormat
operator|&
name|dwFormat
operator|)
operator|&&
operator|(
name|p_fmt
operator|->
name|bPrecision
operator|==
name|bBitResolution
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|p_fmt
operator|->
name|wFormat
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Unsupported audio format\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
literal|256
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ep_dir
operator|==
name|UE_DIR_OUT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mixer_clocks
operator|.
name|bit_output
index|[
name|x
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mixer_clocks
operator|.
name|bit_input
index|[
name|x
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|x
operator|%
literal|8
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
name|DPRINTF
argument_list|(
literal|"Checking clock ID=%d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaudio20_check_rate
argument_list|(
name|udev
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|,
name|x
argument_list|,
name|rate
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Unsupported sampling "
literal|"rate, id=%d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
block|}
block|}
else|else
block|{
name|uint16_t
name|wFormat
decl_stmt|;
name|wFormat
operator|=
name|UGETW
argument_list|(
name|asid
operator|.
name|v1
operator|->
name|wFormatTag
argument_list|)
expr_stmt|;
name|bChannels
operator|=
name|UAUDIO_MAX_CHAN
argument_list|(
name|asf1d
operator|.
name|v1
operator|->
name|bNrChannels
argument_list|)
expr_stmt|;
name|bBitResolution
operator|=
name|asf1d
operator|.
name|v1
operator|->
name|bSubFrameSize
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|asf1d
operator|.
name|v1
operator|->
name|bSamFreqType
operator|==
literal|0
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"Sample rate: %d-%dHz\n"
argument_list|,
name|UA_SAMP_LO
argument_list|(
name|asf1d
operator|.
name|v1
argument_list|)
argument_list|,
name|UA_SAMP_HI
argument_list|(
name|asf1d
operator|.
name|v1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rate
operator|>=
name|UA_SAMP_LO
argument_list|(
name|asf1d
operator|.
name|v1
argument_list|)
operator|)
operator|&&
operator|(
name|rate
operator|<=
name|UA_SAMP_HI
argument_list|(
name|asf1d
operator|.
name|v1
argument_list|)
operator|)
condition|)
goto|goto
name|found_rate
goto|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|asf1d
operator|.
name|v1
operator|->
name|bSamFreqType
condition|;
name|x
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|16
argument_list|,
literal|"Sample rate = %dHz\n"
argument_list|,
name|UA_GETSAMP
argument_list|(
name|asf1d
operator|.
name|v1
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|==
name|UA_GETSAMP
argument_list|(
name|asf1d
operator|.
name|v1
argument_list|,
name|x
argument_list|)
condition|)
goto|goto
name|found_rate
goto|;
block|}
block|}
goto|goto
name|next_ep
goto|;
name|found_rate
label|:
for|for
control|(
name|p_fmt
operator|=
name|uaudio10_formats
init|;
name|p_fmt
operator|->
name|wFormat
operator|!=
literal|0
condition|;
name|p_fmt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_fmt
operator|->
name|wFormat
operator|==
name|wFormat
operator|)
operator|&&
operator|(
name|p_fmt
operator|->
name|bPrecision
operator|==
name|bBitResolution
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|p_fmt
operator|->
name|wFormat
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Unsupported audio format\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
if|if
condition|(
operator|(
name|bChannels
operator|!=
name|channels
operator|)
operator|||
operator|(
name|bBitResolution
operator|!=
name|bit_resolution
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Wrong number of channels\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
block|}
name|chan
operator|=
operator|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_rec_chan
else|:
operator|&
name|sc
operator|->
name|sc_play_chan
expr_stmt|;
if|if
condition|(
name|usbd_get_iface
argument_list|(
name|udev
argument_list|,
name|curidx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Interface is not valid\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
if|if
condition|(
name|chan
operator|->
name|num_alt
operator|==
name|CHAN_MAX_ALT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Too many alternate settings\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
name|chan
operator|->
name|set_alt
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|cur_alt
operator|=
name|CHAN_MAX_ALT
expr_stmt|;
name|chan_alt
operator|=
operator|&
name|chan
operator|->
name|usb_alt
index|[
name|chan
operator|->
name|num_alt
operator|++
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
name|uaudio_chan_dump_ep_desc
argument_list|(
name|ed1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|"Sample rate = %dHz, channels = %d, "
literal|"bits = %d, format = %s\n"
argument_list|,
name|rate
argument_list|,
name|channels
argument_list|,
name|bit_resolution
argument_list|,
name|p_fmt
operator|->
name|description
argument_list|)
expr_stmt|;
name|chan_alt
operator|->
name|sample_rate
operator|=
name|rate
expr_stmt|;
name|chan_alt
operator|->
name|p_asf1d
operator|=
name|asf1d
expr_stmt|;
name|chan_alt
operator|->
name|p_ed1
operator|=
name|ed1
expr_stmt|;
name|chan_alt
operator|->
name|p_fmt
operator|=
name|p_fmt
expr_stmt|;
name|chan_alt
operator|->
name|p_sed
operator|=
name|sed
expr_stmt|;
name|chan_alt
operator|->
name|iface_index
operator|=
name|curidx
expr_stmt|;
name|chan_alt
operator|->
name|iface_alt_index
operator|=
name|alt_index
expr_stmt|;
name|usbd_set_parent_iface
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|curidx
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep_dir
operator|==
name|UE_DIR_IN
condition|)
name|chan_alt
operator|->
name|usb_cfg
operator|=
name|uaudio_cfg_record
expr_stmt|;
else|else
name|chan_alt
operator|->
name|usb_cfg
operator|=
name|uaudio_cfg_play
expr_stmt|;
name|chan_alt
operator|->
name|sample_size
operator|=
operator|(
name|UAUDIO_MAX_CHAN
argument_list|(
name|channels
argument_list|)
operator|*
name|p_fmt
operator|->
name|bPrecision
operator|)
operator|/
literal|8
expr_stmt|;
name|chan_alt
operator|->
name|channels
operator|=
name|channels
expr_stmt|;
if|if
condition|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|&&
name|usbd_get_speed
argument_list|(
name|udev
argument_list|)
operator|==
name|USB_SPEED_FULL
condition|)
block|{
name|uaudio_record_fix_fs
argument_list|(
name|ed1
argument_list|,
name|chan_alt
operator|->
name|sample_size
operator|*
operator|(
name|rate
operator|/
literal|1000
operator|)
argument_list|,
name|chan_alt
operator|->
name|sample_size
operator|*
operator|(
name|rate
operator|/
literal|4000
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* setup play/record format */
name|format
operator|=
name|chan_alt
operator|->
name|p_fmt
operator|->
name|freebsd_fmt
expr_stmt|;
switch|switch
condition|(
name|chan_alt
operator|->
name|channels
condition|)
block|{
case|case
literal|2
case|:
comment|/* stereo */
name|format
operator|=
name|SND_FORMAT
argument_list|(
name|format
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* mono */
name|format
operator|=
name|SND_FORMAT
argument_list|(
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* surround and more */
name|format
operator|=
name|feeder_matrix_default_format
argument_list|(
name|SND_FORMAT
argument_list|(
name|format
argument_list|,
name|chan_alt
operator|->
name|channels
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check if format is not supported */
if|if
condition|(
name|format
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"The selected audio format is not supported\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|num_alt
operator|--
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
if|if
condition|(
name|chan
operator|->
name|num_alt
operator|>
literal|1
condition|)
block|{
comment|/* we only accumulate one format at different sample rates */
if|if
condition|(
name|chan
operator|->
name|pcm_format
index|[
literal|0
index|]
operator|!=
name|format
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Multiple formats is not supported\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|num_alt
operator|--
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
comment|/* ignore if duplicate sample rate entry */
if|if
condition|(
name|rate
operator|==
name|chan
operator|->
name|usb_alt
index|[
name|chan
operator|->
name|num_alt
operator|-
literal|2
index|]
operator|.
name|sample_rate
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Duplicate sample rate detected\n"
argument_list|)
expr_stmt|;
name|chan
operator|->
name|num_alt
operator|--
expr_stmt|;
goto|goto
name|next_ep
goto|;
block|}
block|}
name|chan
operator|->
name|pcm_cap
operator|.
name|fmtlist
operator|=
name|chan
operator|->
name|pcm_format
expr_stmt|;
name|chan
operator|->
name|pcm_cap
operator|.
name|fmtlist
index|[
literal|0
index|]
operator|=
name|format
expr_stmt|;
if|if
condition|(
name|rate
operator|<
name|chan
operator|->
name|pcm_cap
operator|.
name|minspeed
operator|||
name|chan
operator|->
name|pcm_cap
operator|.
name|minspeed
operator|==
literal|0
condition|)
name|chan
operator|->
name|pcm_cap
operator|.
name|minspeed
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|rate
operator|>
name|chan
operator|->
name|pcm_cap
operator|.
name|maxspeed
operator|||
name|chan
operator|->
name|pcm_cap
operator|.
name|maxspeed
operator|==
literal|0
condition|)
name|chan
operator|->
name|pcm_cap
operator|.
name|maxspeed
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sndstat_valid
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|,
literal|"\n\t"
literal|"mode %d.%d:(%s) %dch, %dbit, %s, %dHz"
argument_list|,
name|curidx
argument_list|,
name|alt_index
argument_list|,
operator|(
name|ep_dir
operator|==
name|UE_DIR_IN
operator|)
condition|?
literal|"input"
else|:
literal|"output"
argument_list|,
name|channels
argument_list|,
name|p_fmt
operator|->
name|bPrecision
argument_list|,
name|p_fmt
operator|->
name|description
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
name|next_ep
label|:
name|sed
operator|.
name|v1
operator|=
name|NULL
expr_stmt|;
name|ed1
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This structure defines all the supported rates. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|uaudio_rate_list
index|[
name|CHAN_MAX_ALT
index|]
init|=
block|{
literal|384000
block|,
literal|352800
block|,
literal|192000
block|,
literal|176400
block|,
literal|96000
block|,
literal|88200
block|,
literal|88000
block|,
literal|80000
block|,
literal|72000
block|,
literal|64000
block|,
literal|56000
block|,
literal|48000
block|,
literal|44100
block|,
literal|40000
block|,
literal|32000
block|,
literal|24000
block|,
literal|22050
block|,
literal|16000
block|,
literal|11025
block|,
literal|8000
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|uaudio_chan_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|uint32_t
name|rate
init|=
name|uaudio_default_rate
decl_stmt|;
name|uint8_t
name|z
decl_stmt|;
name|uint8_t
name|bits
init|=
name|uaudio_default_bits
decl_stmt|;
name|uint8_t
name|y
decl_stmt|;
name|uint8_t
name|channels
init|=
name|uaudio_default_channels
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|bits
operator|-=
operator|(
name|bits
operator|%
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits
operator|==
literal|0
operator|)
operator|||
operator|(
name|bits
operator|>
literal|32
operator|)
condition|)
block|{
comment|/* set a valid value */
name|bits
operator|=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|channels
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|usbd_get_speed
argument_list|(
name|udev
argument_list|)
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
comment|/* 			 * Due to high bandwidth usage and problems 			 * with HIGH-speed split transactions we 			 * disable surround setups on FULL-speed USB 			 * by default 			 */
name|channels
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|channels
operator|=
literal|16
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|channels
operator|>
literal|16
condition|)
block|{
name|channels
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_sndstat_valid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* try to search for a valid config */
for|for
control|(
name|x
operator|=
name|channels
init|;
name|x
condition|;
name|x
operator|--
control|)
block|{
for|for
control|(
name|y
operator|=
name|bits
init|;
name|y
condition|;
name|y
operator|-=
literal|8
control|)
block|{
comment|/* try user defined rate, if any */
if|if
condition|(
name|rate
operator|!=
literal|0
condition|)
name|uaudio_chan_fill_info_sub
argument_list|(
name|sc
argument_list|,
name|udev
argument_list|,
name|rate
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* try find a matching rate, if any */
for|for
control|(
name|z
operator|=
literal|0
init|;
name|uaudio_rate_list
index|[
name|z
index|]
condition|;
name|z
operator|++
control|)
name|uaudio_chan_fill_info_sub
argument_list|(
name|sc
argument_list|,
name|udev
argument_list|,
name|uaudio_rate_list
index|[
name|z
index|]
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_sndstat_valid
condition|)
name|sbuf_finish
argument_list|(
operator|&
name|sc
operator|->
name|sc_sndstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_play_sync_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint64_t
name|sample_rate
init|=
name|ch
operator|->
name|usb_alt
index|[
name|ch
operator|->
name|cur_alt
index|]
operator|.
name|sample_rate
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|temp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|int
name|nframes
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|nframes
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"transferred %d bytes\n"
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nframes
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|usbd_xfer_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp
operator|=
name|UGETDW
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Value = 0x%08x\n"
argument_list|,
operator|(
name|int
operator|)
name|temp
argument_list|)
expr_stmt|;
comment|/* auto-detect SYNC format */
if|if
condition|(
name|len
operator|==
literal|4
condition|)
name|temp
operator|&=
literal|0x0fffffff
expr_stmt|;
comment|/* check for no data */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
break|break;
comment|/* correctly scale value */
name|temp
operator|=
operator|(
name|temp
operator|*
literal|125ULL
operator|)
operator|-
literal|64
expr_stmt|;
comment|/* auto adjust */
while|while
condition|(
name|temp
operator|<
operator|(
name|sample_rate
operator|-
operator|(
name|sample_rate
operator|/
literal|4
operator|)
operator|)
condition|)
name|temp
operator|*=
literal|2
expr_stmt|;
while|while
condition|(
name|temp
operator|>
operator|(
name|sample_rate
operator|+
operator|(
name|sample_rate
operator|/
literal|2
operator|)
operator|)
condition|)
name|temp
operator|/=
literal|2
expr_stmt|;
comment|/* compare */
name|DPRINTF
argument_list|(
literal|"Comparing %d< %d\n"
argument_list|,
operator|(
name|int
operator|)
name|temp
argument_list|,
operator|(
name|int
operator|)
name|sample_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|sample_rate
condition|)
name|ch
operator|->
name|last_sync_state
operator|=
name|UAUDIO_SYNC_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|>
name|sample_rate
condition|)
name|ch
operator|->
name|last_sync_state
operator|=
name|UAUDIO_SYNC_MORE
expr_stmt|;
else|else
name|ch
operator|->
name|last_sync_state
operator|=
name|UAUDIO_SYNC_LESS
expr_stmt|;
break|break;
case|case
name|USB_ST_SETUP
case|:
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_framelen
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_play_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|sample_size
init|=
name|ch
operator|->
name|usb_alt
index|[
name|ch
operator|->
name|cur_alt
index|]
operator|.
name|sample_size
decl_stmt|;
name|uint32_t
name|mfl
decl_stmt|;
name|uint32_t
name|total
decl_stmt|;
name|uint32_t
name|blockcount
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|int
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|end
operator|==
name|ch
operator|->
name|start
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no buffer!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
if|if
condition|(
name|actlen
operator|<
name|sumlen
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"short transfer, "
literal|"%d of %d bytes\n"
argument_list|,
name|actlen
argument_list|,
name|sumlen
argument_list|)
expr_stmt|;
block|}
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
comment|/* start SYNC transfer, if any */
if|if
condition|(
operator|(
name|ch
operator|->
name|last_sync_time
operator|++
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|usbd_transfer_start
argument_list|(
name|ch
operator|->
name|xfer
index|[
name|UAUDIO_NCHANBUFS
index|]
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|mfl
operator|=
name|usbd_xfer_max_framelen
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bytes_per_frame
index|[
literal|1
index|]
operator|>
name|mfl
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"bytes per transfer, %d, "
literal|"exceeds maximum, %d!\n"
argument_list|,
name|ch
operator|->
name|bytes_per_frame
index|[
literal|1
index|]
argument_list|,
name|mfl
argument_list|)
expr_stmt|;
break|break;
block|}
name|blockcount
operator|=
name|ch
operator|->
name|intr_frames
expr_stmt|;
comment|/* setup number of frames */
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
name|blockcount
argument_list|)
expr_stmt|;
comment|/* reset total length */
name|total
operator|=
literal|0
expr_stmt|;
comment|/* setup frame lengths */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|blockcount
condition|;
name|n
operator|++
control|)
block|{
name|uint32_t
name|frame_len
decl_stmt|;
name|ch
operator|->
name|sample_curr
operator|+=
name|ch
operator|->
name|sample_rem
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sample_curr
operator|>=
name|ch
operator|->
name|frames_per_second
condition|)
block|{
name|ch
operator|->
name|sample_curr
operator|-=
name|ch
operator|->
name|frames_per_second
expr_stmt|;
name|frame_len
operator|=
name|ch
operator|->
name|bytes_per_frame
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|frame_len
operator|=
name|ch
operator|->
name|bytes_per_frame
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
operator|(
name|blockcount
operator|-
literal|1
operator|)
condition|)
block|{
switch|switch
condition|(
name|ch
operator|->
name|last_sync_state
condition|)
block|{
case|case
name|UAUDIO_SYNC_MORE
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"sending one sample more\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frame_len
operator|+
name|sample_size
operator|)
operator|<=
name|mfl
condition|)
name|frame_len
operator|+=
name|sample_size
expr_stmt|;
name|ch
operator|->
name|last_sync_state
operator|=
name|UAUDIO_SYNC_NONE
expr_stmt|;
break|break;
case|case
name|UAUDIO_SYNC_LESS
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"sending one sample less\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_len
operator|>=
name|sample_size
condition|)
name|frame_len
operator|-=
name|sample_size
expr_stmt|;
name|ch
operator|->
name|last_sync_state
operator|=
name|UAUDIO_SYNC_NONE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|n
argument_list|,
name|frame_len
argument_list|)
expr_stmt|;
name|total
operator|+=
name|frame_len
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"transfer %d bytes\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|total
condition|)
block|{
name|n
operator|=
name|total
expr_stmt|;
block|}
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
name|offset
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|total
operator|-=
name|n
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
name|offset
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
block|{
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
block|}
block|}
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
goto|goto
name|tr_transferred
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_record_sync_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
comment|/* TODO */
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_chan_record_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|offset0
decl_stmt|;
name|uint32_t
name|offset1
decl_stmt|;
name|uint32_t
name|mfl
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|int
name|nframes
decl_stmt|;
name|int
name|blockcount
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|nframes
argument_list|)
expr_stmt|;
name|mfl
operator|=
name|usbd_xfer_max_framelen
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|end
operator|==
name|ch
operator|->
name|start
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no buffer!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"transferred %d bytes\n"
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|offset0
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|nframes
condition|;
name|n
operator|++
control|)
block|{
name|offset1
operator|=
name|offset0
expr_stmt|;
name|len
operator|=
name|usbd_xfer_frame_len
argument_list|(
name|xfer
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|m
operator|=
operator|(
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
name|len
condition|)
name|m
operator|=
name|len
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
name|offset1
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|len
operator|-=
name|m
expr_stmt|;
name|offset1
operator|+=
name|m
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|m
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
block|{
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
block|}
block|}
name|offset0
operator|+=
name|mfl
expr_stmt|;
block|}
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|blockcount
operator|=
name|ch
operator|->
name|intr_frames
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
name|blockcount
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|blockcount
condition|;
name|n
operator|++
control|)
block|{
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|n
argument_list|,
name|mfl
argument_list|)
expr_stmt|;
block|}
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
break|break;
block|}
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|uaudio_chan_init
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|uaudio_chan
modifier|*
name|ch
init|=
operator|(
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_play_chan
else|:
operator|&
name|sc
operator|->
name|sc_rec_chan
operator|)
decl_stmt|;
name|uint32_t
name|buf_size
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
comment|/* store mutex and PCM channel */
name|ch
operator|->
name|pcm_ch
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|pcm_mtx
operator|=
name|c
operator|->
name|lock
expr_stmt|;
comment|/* compute worst case buffer */
name|buf_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|ch
operator|->
name|num_alt
condition|;
name|x
operator|++
control|)
block|{
name|uint32_t
name|temp
init|=
name|uaudio_get_buffer_size
argument_list|(
name|ch
argument_list|,
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|>
name|buf_size
condition|)
name|buf_size
operator|=
name|temp
expr_stmt|;
block|}
comment|/* allow double buffering */
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Worst case buffer is %d bytes\n"
argument_list|,
operator|(
name|int
operator|)
name|buf_size
argument_list|)
expr_stmt|;
name|ch
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|buf_size
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|ch
operator|->
name|start
operator|=
name|ch
operator|->
name|buf
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|ch
operator|->
name|buf
operator|+
name|buf_size
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|buf
expr_stmt|;
name|ch
operator|->
name|pcm_buf
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|max_buf
operator|=
name|buf_size
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pcm_mtx
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"ERROR: PCM channels does not have a mutex!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
name|ch
operator|)
return|;
name|error
label|:
name|uaudio_chan_free
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_free
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ch
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ch
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|usbd_transfer_unsetup
argument_list|(
name|ch
operator|->
name|xfer
argument_list|,
name|UAUDIO_NCHANBUFS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|num_alt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_blocksize
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|uint32_t
name|temp
init|=
literal|2
operator|*
name|uaudio_get_buffer_size
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|set_alt
argument_list|)
decl_stmt|;
name|sndbuf_setup
argument_list|(
name|ch
operator|->
name|pcm_buf
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ch
operator|->
name|start
operator|=
name|ch
operator|->
name|buf
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|ch
operator|->
name|buf
operator|+
name|temp
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|buf
expr_stmt|;
return|return
operator|(
name|temp
operator|/
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_fragments
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|,
name|uint32_t
name|blockcount
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_speed
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|uint8_t
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|ch
operator|->
name|num_alt
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|usb_alt
index|[
name|x
index|]
operator|.
name|sample_rate
operator|<
name|speed
condition|)
block|{
comment|/* sample rate is too low */
break|break;
block|}
block|}
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|x
operator|--
expr_stmt|;
name|ch
operator|->
name|set_alt
operator|=
name|x
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Selecting alt %d\n"
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|usb_alt
index|[
name|x
index|]
operator|.
name|sample_rate
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_getptr
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|->
name|cur
operator|-
name|ch
operator|->
name|start
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pcmchan_caps
modifier|*
name|uaudio_chan_getcaps
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ch
operator|->
name|pcm_cap
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_matrix
name|uaudio_chan_matrix_swap_2_0
init|=
block|{
operator|.
name|id
operator|=
name|SND_CHN_MATRIX_DRV
block|,
operator|.
name|channels
operator|=
literal|2
block|,
operator|.
name|ext
operator|=
literal|0
block|,
operator|.
name|map
operator|=
block|{
comment|/* Right */
index|[
literal|0
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|SND_CHN_T_FR
block|,
operator|.
name|members
operator|=
name|SND_CHN_T_MASK_FR
operator||
name|SND_CHN_T_MASK_FC
operator||
name|SND_CHN_T_MASK_LF
operator||
name|SND_CHN_T_MASK_BR
operator||
name|SND_CHN_T_MASK_BC
operator||
name|SND_CHN_T_MASK_SR
block|}
block|,
comment|/* Left */
index|[
literal|1
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|SND_CHN_T_FL
block|,
operator|.
name|members
operator|=
name|SND_CHN_T_MASK_FL
operator||
name|SND_CHN_T_MASK_FC
operator||
name|SND_CHN_T_MASK_LF
operator||
name|SND_CHN_T_MASK_BL
operator||
name|SND_CHN_T_MASK_BC
operator||
name|SND_CHN_T_MASK_SL
block|}
block|,
index|[
literal|2
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|SND_CHN_T_MAX
block|,
operator|.
name|members
operator|=
literal|0
block|}
block|}
block|,
operator|.
name|mask
operator|=
name|SND_CHN_T_MASK_FR
operator||
name|SND_CHN_T_MASK_FL
block|,
operator|.
name|offset
operator|=
block|{
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|pcmchan_matrix
modifier|*
name|uaudio_chan_getmatrix
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ch
operator|->
name|priv_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_uq_audio_swap_lr
operator|!=
literal|0
operator|&&
name|AFMT_CHANNEL
argument_list|(
name|format
argument_list|)
operator|==
literal|2
condition|)
return|return
operator|(
operator|&
name|uaudio_chan_matrix_swap_2_0
operator|)
return|;
return|return
operator|(
name|feeder_matrix_format_map
argument_list|(
name|format
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_set_param_format
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"Selecting format 0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|format
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_start
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|priv_sc
decl_stmt|;
name|int
name|do_start
init|=
literal|0
decl_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|operation
operator|!=
name|CHAN_OP_DRAIN
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|cur_alt
operator|==
name|ch
operator|->
name|set_alt
operator|&&
name|ch
operator|->
name|operation
operator|==
name|CHAN_OP_NONE
condition|)
block|{
comment|/* save doing the explore task */
name|do_start
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|operation
operator|=
name|CHAN_OP_START
expr_stmt|;
operator|(
name|void
operator|)
name|usb_proc_explore_msignal
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_start
condition|)
block|{
name|usbd_transfer_start
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_chan_stop
parameter_list|(
name|struct
name|uaudio_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|priv_sc
decl_stmt|;
name|int
name|do_stop
init|=
literal|0
decl_stmt|;
name|usb_proc_explore_lock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|operation
operator|!=
name|CHAN_OP_DRAIN
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|cur_alt
operator|==
name|ch
operator|->
name|set_alt
operator|&&
name|ch
operator|->
name|operation
operator|==
name|CHAN_OP_NONE
condition|)
block|{
comment|/* save doing the explore task */
name|do_stop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|operation
operator|=
name|CHAN_OP_STOP
expr_stmt|;
operator|(
name|void
operator|)
name|usb_proc_explore_msignal
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_config_msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|usb_proc_explore_unlock
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stop
condition|)
block|{
name|usbd_transfer_stop
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|ch
operator|->
name|xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================*  * AC - Audio Controller - routines  *========================================================================*/
end_comment

begin_function
specifier|static
name|int
name|uaudio_mixer_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|pmc
decl_stmt|;
name|int
name|hint
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|int
name|chan
init|=
literal|0
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|uaudio_softc
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|hint
operator|=
name|oidp
operator|->
name|oid_arg2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mixer_lock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* lookup mixer node */
name|mtx_lock
argument_list|(
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pmc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|pmc
operator|!=
name|NULL
condition|;
name|pmc
operator|=
name|pmc
operator|->
name|next
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|!=
operator|(
name|int
operator|)
name|pmc
operator|->
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
if|if
condition|(
name|pmc
operator|->
name|wValue
index|[
name|chan
index|]
operator|!=
operator|-
literal|1
operator|&&
name|pmc
operator|->
name|wValue
index|[
name|chan
index|]
operator|==
name|hint
condition|)
block|{
name|temp
operator|=
name|pmc
operator|->
name|wData
index|[
name|chan
index|]
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
name|found
label|:
name|mtx_unlock
argument_list|(
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|temp
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* update mixer value */
name|mtx_lock
argument_list|(
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc
operator|!=
name|NULL
operator|&&
name|temp
operator|>=
name|pmc
operator|->
name|minval
operator|&&
name|temp
operator|<=
name|pmc
operator|->
name|maxval
condition|)
block|{
name|pmc
operator|->
name|wData
index|[
name|chan
index|]
operator|=
name|temp
expr_stmt|;
name|pmc
operator|->
name|update
index|[
operator|(
name|chan
operator|/
literal|8
operator|)
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* start the transfer, if not already started */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_mixer_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_ctl_free
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|p_mc
decl_stmt|;
while|while
condition|(
operator|(
name|p_mc
operator|=
name|sc
operator|->
name|sc_mixer_root
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_mixer_root
operator|=
name|p_mc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p_mc
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_register_sysctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|pmc
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|mixer_tree
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|control_tree
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|int
name|n
decl_stmt|;
name|mixer_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mixer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_tree
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|pmc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|pmc
operator|!=
name|NULL
condition|;
name|pmc
operator|=
name|pmc
operator|->
name|next
operator|,
name|n
operator|++
control|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|pmc
operator|->
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
if|if
condition|(
name|pmc
operator|->
name|nchan
operator|>
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s_%d_%d"
argument_list|,
name|pmc
operator|->
name|name
argument_list|,
name|n
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s_%d"
argument_list|,
name|pmc
operator|->
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|control_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|mixer_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Mixer control nodes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_tree
operator|==
name|NULL
condition|)
continue|continue;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|control_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"val"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|pmc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|,
name|uaudio_mixer_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"Current value"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|control_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"min"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|pmc
operator|->
name|minval
argument_list|,
literal|"Minimum value"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|control_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|pmc
operator|->
name|maxval
argument_list|,
literal|"Maximum value"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|control_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"desc"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|pmc
operator|->
name|desc
argument_list|,
literal|0
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* M-Audio FastTrack Ultra Mixer Description */
end_comment

begin_comment
comment|/* Origin: Linux USB Audio driver */
end_comment

begin_function
specifier|static
name|void
name|uaudio_mixer_controls_create_ftu
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|chx
decl_stmt|;
name|int
name|chy
decl_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|6
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_UNSIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|=
literal|0
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
literal|7
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|mul
operator|=
literal|7
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
literal|"Room1,2,3,Hall1,2,Plate,Delay,Echo"
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl_sub
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|5
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
for|for
control|(
name|chx
operator|=
literal|0
init|;
name|chx
operator|!=
literal|8
condition|;
name|chx
operator|++
control|)
block|{
for|for
control|(
name|chy
operator|=
literal|0
init|;
name|chy
operator|!=
literal|8
condition|;
name|chy
operator|++
control|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|chx
operator|+
literal|1
argument_list|,
name|chy
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"mix_rec"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|val_default
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
literal|"AIn%d - Out%d Record Volume"
argument_list|,
name|chy
operator|+
literal|1
argument_list|,
name|chx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|chx
operator|+
literal|1
argument_list|,
name|chy
operator|+
literal|1
operator|+
literal|8
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"mix_play"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|val_default
operator|=
operator|(
name|chx
operator|==
name|chy
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
literal|"DIn%d - Out%d Playback Volume"
argument_list|,
name|chy
operator|+
literal|1
argument_list|,
name|chx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|6
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect_vol"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|=
literal|0
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
literal|0x7f
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|mul
operator|=
literal|0x7f
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
literal|"Effect Volume"
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl_sub
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|6
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect_dur"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|=
literal|0
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
literal|0x7f00
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|mul
operator|=
literal|0x7f00
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
literal|"Effect Duration"
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl_sub
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|6
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect_fb"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|=
literal|0
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
literal|0x7f
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|mul
operator|=
literal|0x7f
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
literal|"Effect Feedback Volume"
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl_sub
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|7
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
for|for
control|(
name|chy
operator|=
literal|0
init|;
name|chy
operator|!=
literal|4
condition|;
name|chy
operator|++
control|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|7
argument_list|,
name|chy
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect_ret"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
literal|"Effect Return %d Volume"
argument_list|,
name|chy
operator|+
literal|1
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
literal|5
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
for|for
control|(
name|chy
operator|=
literal|0
init|;
name|chy
operator|!=
literal|8
condition|;
name|chy
operator|++
control|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|9
argument_list|,
name|chy
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect_send"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
literal|"Effect Send AIn%d Volume"
argument_list|,
name|chy
operator|+
literal|1
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|9
argument_list|,
name|chy
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"effect_send"
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|update
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
literal|"Effect Send DIn%d Volume"
argument_list|,
name|chy
operator|+
literal|1
operator|+
literal|8
argument_list|)
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_reload_all
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|pmc
decl_stmt|;
name|int
name|chan
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mixer_lock
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pmc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|pmc
operator|!=
name|NULL
condition|;
name|pmc
operator|=
name|pmc
operator|->
name|next
control|)
block|{
comment|/* use reset defaults for non-oss controlled settings */
if|if
condition|(
name|pmc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
condition|)
continue|continue;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|pmc
operator|->
name|nchan
condition|;
name|chan
operator|++
control|)
name|pmc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_mixer_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* start HID volume keys, if any */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_hid
operator|.
name|xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_ctl_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|p_mc_new
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_mc_new
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|p_mc_new
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|p_mc_new
argument_list|,
name|mc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mc_new
argument_list|)
argument_list|)
expr_stmt|;
name|p_mc_new
operator|->
name|next
operator|=
name|sc
operator|->
name|sc_mixer_root
expr_stmt|;
name|sc
operator|->
name|sc_mixer_root
operator|=
name|p_mc_new
expr_stmt|;
name|sc
operator|->
name|sc_mixer_count
operator|++
expr_stmt|;
comment|/* set default value for all channels */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|p_mc_new
operator|->
name|nchan
condition|;
name|ch
operator|++
control|)
block|{
switch|switch
condition|(
name|p_mc_new
operator|->
name|val_default
condition|)
block|{
case|case
literal|1
case|:
comment|/* 50% */
name|p_mc_new
operator|->
name|wData
index|[
name|ch
index|]
operator|=
operator|(
name|p_mc_new
operator|->
name|maxval
operator|+
name|p_mc_new
operator|->
name|minval
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 100% */
name|p_mc_new
operator|->
name|wData
index|[
name|ch
index|]
operator|=
name|p_mc_new
operator|->
name|maxval
expr_stmt|;
break|break;
default|default:
comment|/* 0% */
name|p_mc_new
operator|->
name|wData
index|[
name|ch
index|]
operator|=
name|p_mc_new
operator|->
name|minval
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|)
block|{
name|int32_t
name|res
decl_stmt|;
if|if
condition|(
name|mc
operator|->
name|class
operator|<
name|UAC_NCLASSES
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"adding %s.%d\n"
argument_list|,
name|uac_names
index|[
name|mc
operator|->
name|class
index|]
argument_list|,
name|mc
operator|->
name|ctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"adding %d\n"
argument_list|,
name|mc
operator|->
name|ctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|mc
operator|->
name|minval
operator|=
literal|0
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{ 	}
else|else
block|{
comment|/* determine min and max values */
name|mc
operator|->
name|minval
operator|=
name|uaudio_mixer_get
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_audio_rev
argument_list|,
name|GET_MIN
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
name|uaudio_mixer_get
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_audio_rev
argument_list|,
name|GET_MAX
argument_list|,
name|mc
argument_list|)
expr_stmt|;
comment|/* check if max and min was swapped */
if|if
condition|(
name|mc
operator|->
name|maxval
operator|<
name|mc
operator|->
name|minval
condition|)
block|{
name|res
operator|=
name|mc
operator|->
name|maxval
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
name|mc
operator|->
name|minval
operator|=
name|res
expr_stmt|;
block|}
comment|/* compute value range */
name|mc
operator|->
name|mul
operator|=
name|mc
operator|->
name|maxval
operator|-
name|mc
operator|->
name|minval
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mul
operator|==
literal|0
condition|)
name|mc
operator|->
name|mul
operator|=
literal|1
expr_stmt|;
comment|/* compute value alignment */
name|res
operator|=
name|uaudio_mixer_get
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|sc
operator|->
name|sc_audio_rev
argument_list|,
name|GET_RES
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Resolution = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|res
argument_list|)
expr_stmt|;
block|}
name|uaudio_mixer_add_ctl_sub
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudio_debug
operator|>
literal|2
condition|)
block|{
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
literal|"[mix] wValue=%04x\n"
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"[mix] wIndex=%04x type=%d ctl='%d' "
literal|"min=%d max=%d\n"
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|mc
operator|->
name|type
argument_list|,
name|mc
operator|->
name|ctl
argument_list|,
name|mc
operator|->
name|minval
argument_list|,
name|mc
operator|->
name|maxval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_mixer_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
name|uint32_t
name|bno
decl_stmt|;
comment|/* bit number */
name|uint32_t
name|p
decl_stmt|;
comment|/* bit number accumulator */
name|uint32_t
name|mo
decl_stmt|;
comment|/* matching outputs */
name|uint32_t
name|mc
decl_stmt|;
comment|/* matching channels */
name|uint32_t
name|ichs
decl_stmt|;
comment|/* input channels */
name|uint32_t
name|ochs
decl_stmt|;
comment|/* output channels */
name|uint32_t
name|c
decl_stmt|;
name|uint32_t
name|chs
decl_stmt|;
comment|/* channels */
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|o
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
comment|/* compute the number of input channels */
name|ichs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d0
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|ichs
operator|+=
name|uaudio_mixer_get_cluster
argument_list|(
name|d0
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
block|}
name|d1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
expr_stmt|;
comment|/* and the number of output channels */
name|ochs
operator|=
name|d1
operator|->
name|bNrChannels
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"ichs=%d ochs=%d\n"
argument_list|,
name|ichs
argument_list|,
name|ochs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|if
condition|(
name|uaudio_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
operator|(
operator|(
name|ichs
operator|*
name|ochs
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d0
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|chs
operator|=
name|uaudio_mixer_get_cluster
argument_list|(
name|d0
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
name|mo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|)
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|d1
operator|->
name|bmControls
argument_list|,
name|bno
argument_list|)
condition|)
name|mo
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mo
operator|==
literal|1
condition|)
name|mc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mc
operator|==
name|chs
operator|)
operator|&&
operator|(
name|chs
operator|<=
name|MIX_MAX_CHAN
operator|)
condition|)
block|{
comment|/* repeat bit-scan */
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|)
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|d1
operator|->
name|bmControls
argument_list|,
name|bno
argument_list|)
condition|)
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
name|mc
operator|++
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|p
operator|+
name|c
operator|+
literal|1
argument_list|,
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
name|chs
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|chs
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio20_mixer_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio20_mixer_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu_v2
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
name|uint32_t
name|bno
decl_stmt|;
comment|/* bit number */
name|uint32_t
name|p
decl_stmt|;
comment|/* bit number accumulator */
name|uint32_t
name|mo
decl_stmt|;
comment|/* matching outputs */
name|uint32_t
name|mc
decl_stmt|;
comment|/* matching channels */
name|uint32_t
name|ichs
decl_stmt|;
comment|/* input channels */
name|uint32_t
name|ochs
decl_stmt|;
comment|/* output channels */
name|uint32_t
name|c
decl_stmt|;
name|uint32_t
name|chs
decl_stmt|;
comment|/* channels */
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|o
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
comment|/* compute the number of input channels */
name|ichs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d0
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|ichs
operator|+=
name|uaudio20_mixer_get_cluster
argument_list|(
name|d0
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
block|}
name|d1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
expr_stmt|;
comment|/* and the number of output channels */
name|ochs
operator|=
name|d1
operator|->
name|bNrChannels
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"ichs=%d ochs=%d\n"
argument_list|,
name|ichs
argument_list|,
name|ochs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|uaudio20_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|if
condition|(
name|uaudio20_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
operator|(
operator|(
name|ichs
operator|*
name|ochs
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d0
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|chs
operator|=
name|uaudio20_mixer_get_cluster
argument_list|(
name|d0
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|iot
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
name|mo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|)
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|d1
operator|->
name|bmControls
argument_list|,
name|bno
argument_list|)
condition|)
name|mo
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mo
operator|==
literal|1
condition|)
name|mc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mc
operator|==
name|chs
operator|)
operator|&&
operator|(
name|chs
operator|<=
name|MIX_MAX_CHAN
operator|)
condition|)
block|{
comment|/* repeat bit-scan */
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|)
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT_TEST
argument_list|(
name|d1
operator|->
name|bmControls
argument_list|,
name|bno
argument_list|)
condition|)
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
name|mc
operator|++
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|p
operator|+
name|c
operator|+
literal|1
argument_list|,
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
name|chs
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|chs
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_selector_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su_v1
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|d
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bNrInPins
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SELECTOR
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
name|d
operator|->
name|bNrInPins
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"selector"
expr_stmt|;
name|i
operator|=
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|usbd_req_get_string_any
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|>
name|MAX_SELECTOR_INPUT_PIN
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
name|MAX_SELECTOR_INPUT_PIN
expr_stmt|;
block|}
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|mul
operator|=
operator|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|-
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SELECTOR_INPUT_PIN
condition|;
name|i
operator|++
control|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
condition|;
name|i
operator|++
control|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|uaudio_mixer_feature_name
argument_list|(
operator|&
name|iot
index|[
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|class
operator|=
literal|0
expr_stmt|;
comment|/* not used */
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio20_mixer_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio20_selector_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su_v2
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|d
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bNrInPins
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio20_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SELECTOR
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
name|d
operator|->
name|bNrInPins
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"selector"
expr_stmt|;
name|i
operator|=
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|usbd_req_get_string_any
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|>
name|MAX_SELECTOR_INPUT_PIN
condition|)
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|=
name|MAX_SELECTOR_INPUT_PIN
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|mul
operator|=
operator|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
operator|-
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|minval
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SELECTOR_INPUT_PIN
condition|;
name|i
operator|++
control|)
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|maxval
condition|;
name|i
operator|++
control|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|slctrtype
index|[
name|i
index|]
operator|=
name|uaudio20_mixer_feature_name
argument_list|(
operator|&
name|iot
index|[
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|class
operator|=
literal|0
expr_stmt|;
comment|/* not used */
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|uaudio_mixer_feature_get_bmaControls
parameter_list|(
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
name|d
parameter_list|,
name|uint8_t
name|i
parameter_list|)
block|{
name|uint32_t
name|temp
init|=
literal|0
decl_stmt|;
name|uint32_t
name|offset
init|=
operator|(
name|i
operator|*
name|d
operator|->
name|bControlSize
operator|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|0
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|1
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
operator|+
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|2
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
operator|+
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|>
literal|3
condition|)
block|{
name|temp
operator||=
name|d
operator|->
name|bmaControls
index|[
name|offset
operator|+
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|fu_v1
decl_stmt|;
name|uint32_t
name|fumask
decl_stmt|;
name|uint32_t
name|mmask
decl_stmt|;
name|uint32_t
name|cmask
decl_stmt|;
name|uint16_t
name|mixernumber
decl_stmt|;
name|uint8_t
name|nchan
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|uint8_t
name|ctl
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bControlSize
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nchan
operator|=
operator|(
name|d
operator|->
name|bLength
operator|-
literal|7
operator|)
operator|/
name|d
operator|->
name|bControlSize
expr_stmt|;
name|mmask
operator|=
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nchan
operator|==
literal|0
condition|)
return|return;
comment|/* figure out what we can control */
for|for
control|(
name|chan
operator|=
literal|1
init|;
name|chan
operator|<
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|10
argument_list|,
literal|"chan=%d mask=%x\n"
argument_list|,
name|chan
argument_list|,
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|cmask
operator||=
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nchan
operator|>
name|MIX_MAX_CHAN
condition|)
block|{
name|nchan
operator|=
name|MIX_MAX_CHAN
expr_stmt|;
block|}
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|i
operator|=
name|d
operator|->
name|bmaControls
index|[
name|d
operator|->
name|bControlSize
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|usbd_req_get_string_any
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|ctl
operator|=
literal|1
init|;
name|ctl
operator|<=
name|LOUDNESS_CONTROL
condition|;
name|ctl
operator|++
control|)
block|{
name|fumask
operator|=
name|FU_MASK
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
literal|"ctl=%d fumask=0x%04x\n"
argument_list|,
name|ctl
argument_list|,
name|fumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmask
operator|&
name|fumask
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmask
operator|&
name|fumask
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uaudio_mixer_feature_get_bmaControls
argument_list|(
name|d
argument_list|,
name|i
argument_list|)
operator|&
name|fumask
condition|)
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|ctl
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
name|mixernumber
operator|=
name|uaudio_mixer_feature_name
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|MUTE_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"mute"
expr_stmt|;
break|break;
case|case
name|VOLUME_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|mixernumber
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"vol"
expr_stmt|;
break|break;
case|case
name|BASS_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_BASS
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"bass"
expr_stmt|;
break|break;
case|case
name|MID_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"mid"
expr_stmt|;
break|break;
case|case
name|TREBLE_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_TREBLE
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"treble"
expr_stmt|;
break|break;
case|case
name|GRAPHIC_EQUALIZER_CONTROL
case|:
continue|continue;
comment|/* XXX don't add anything */
case|case
name|AGC_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"agc"
expr_stmt|;
break|break;
case|case
name|DELAY_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_UNSIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"delay"
expr_stmt|;
break|break;
case|case
name|BASS_BOOST_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"boost"
expr_stmt|;
break|break;
case|case
name|LOUDNESS_CONTROL
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_LOUD
expr_stmt|;
comment|/* Is this correct ? */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"loudness"
expr_stmt|;
break|break;
default|default:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_UNKNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|!=
name|MIX_UNKNOWN
condition|)
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio20_mixer_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio20_feature_unit
modifier|*
name|d
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|fu_v2
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|uint32_t
name|mmask
decl_stmt|;
name|uint32_t
name|cmask
decl_stmt|;
name|uint16_t
name|mixernumber
decl_stmt|;
name|uint8_t
name|nchan
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|what
decl_stmt|;
if|if
condition|(
name|UGETDW
argument_list|(
name|d
operator|->
name|bmaControls
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nchan
operator|=
operator|(
name|d
operator|->
name|bLength
operator|-
literal|6
operator|)
operator|/
literal|4
expr_stmt|;
name|mmask
operator|=
name|UGETDW
argument_list|(
name|d
operator|->
name|bmaControls
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nchan
operator|==
literal|0
condition|)
return|return;
comment|/* figure out what we can control */
for|for
control|(
name|chan
operator|=
literal|1
init|;
name|chan
operator|<
name|nchan
condition|;
name|chan
operator|++
control|)
name|cmask
operator||=
name|UGETDW
argument_list|(
name|d
operator|->
name|bmaControls
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchan
operator|>
name|MIX_MAX_CHAN
condition|)
name|nchan
operator|=
name|MIX_MAX_CHAN
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|i
operator|=
name|d
operator|->
name|bmaControls
index|[
name|nchan
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|usbd_req_get_string_any
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|NULL
argument_list|,
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
argument_list|)
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|desc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|ctl
operator|=
literal|3
init|;
name|ctl
operator|!=
literal|0
condition|;
name|ctl
operator|<<=
literal|2
control|)
block|{
name|mixernumber
operator|=
name|uaudio20_mixer_feature_name
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
operator|(
literal|3
operator|<<
literal|0
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"mute"
expr_stmt|;
name|what
operator|=
name|MUTE_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|2
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|mixernumber
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"vol"
expr_stmt|;
name|what
operator|=
name|VOLUME_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|4
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_BASS
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"bass"
expr_stmt|;
name|what
operator|=
name|BASS_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|6
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"mid"
expr_stmt|;
name|what
operator|=
name|MID_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|8
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_TREBLE
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"treble"
expr_stmt|;
name|what
operator|=
name|TREBLE_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|12
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"agc"
expr_stmt|;
name|what
operator|=
name|AGC_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|14
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_UNSIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"delay"
expr_stmt|;
name|what
operator|=
name|DELAY_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|16
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"boost"
expr_stmt|;
name|what
operator|=
name|BASS_BOOST_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|18
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|SOUND_MIXER_LOUD
expr_stmt|;
comment|/* Is this correct ? */
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"loudness"
expr_stmt|;
name|what
operator|=
name|LOUDNESS_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|20
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|mixernumber
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"igain"
expr_stmt|;
name|what
operator|=
name|INPUT_GAIN_CONTROL
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|<<
literal|22
operator|)
case|:
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|ctl
operator|=
name|mixernumber
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|name
operator|=
literal|"igainpad"
expr_stmt|;
name|what
operator|=
name|INPUT_GAIN_PAD_CONTROL
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
operator|(
name|mmask
operator|&
name|ctl
operator|)
operator|==
name|ctl
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cmask
operator|&
name|ctl
operator|)
operator|==
name|ctl
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|UGETDW
argument_list|(
name|d
operator|->
name|bmaControls
index|[
name|i
index|]
argument_list|)
operator|&
name|ctl
operator|)
operator|==
name|ctl
condition|)
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|what
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
if|if
condition|(
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|!=
name|MIX_UNKNOWN
condition|)
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_processing_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|d1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_updown
modifier|*
name|ud
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d1
operator|->
name|bmControls
operator|+
name|d1
operator|->
name|bControlSize
operator|)
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|uaudio_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|uaudio_mixer_verify_desc
argument_list|(
name|d0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
operator|+
operator|(
literal|2
operator|*
name|ud
operator|->
name|bNrModes
operator|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrModes=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|ud
operator|->
name|bNrModes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_MASK
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no mode select\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|->
name|bNrModes
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"i=%d bm=0x%x\n"
argument_list|,
name|i
argument_list|,
name|UGETW
argument_list|(
name|ud
operator|->
name|waModes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_processing_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|d1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|;
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|UGETW
argument_list|(
name|d0
operator|->
name|wProcessType
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"wProcessType=%d bUnitId=%d "
literal|"bNrInPins=%d\n"
argument_list|,
name|ptype
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|->
name|bControlSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_ENABLE_MASK
condition|)
block|{
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|XX_ENABLE_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|UPDOWNMIX_PROCESS
case|:
name|uaudio_mixer_add_processing_updown
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOLBY_PROLOGIC_PROCESS
case|:
case|case
name|P3D_STEREO_EXTENDER_PROCESS
case|:
case|case
name|REVERBATION_PROCESS
case|:
case|case
name|CHORUS_PROCESS
case|:
case|case
name|DYN_RANGE_COMP_PROCESS
case|:
default|default:
name|DPRINTF
argument_list|(
literal|"unit %d, type=%d is not implemented\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_extension_unit_0
modifier|*
name|d0
init|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu_v1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_extension_unit_1
modifier|*
name|d1
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|d0
operator|->
name|baSourceId
operator|+
name|d0
operator|->
name|bNrInPins
operator|)
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"bUnitId=%d bNrInPins=%d\n"
argument_list|,
name|d0
operator|->
name|bUnitId
argument_list|,
name|d0
operator|->
name|bNrInPins
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_uq_au_no_xu
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d1
operator|->
name|bControlSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_EXT_ENABLE_MASK
condition|)
block|{
name|memset
argument_list|(
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wIndex
operator|=
name|MAKE_WORD
argument_list|(
name|d0
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_no
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE_WORD
argument_list|(
name|UA_EXT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uaudio_mixer_determine_class
argument_list|(
operator|&
name|iot
index|[
name|id
index|]
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|MIX
argument_list|(
name|sc
argument_list|)
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|MIX
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|uaudio_mixer_verify_desc
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_extension_unit_1
modifier|*
name|e1
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|u1
decl_stmt|;
union|union
block|{
specifier|const
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|usb_audio_input_terminal
modifier|*
name|it
decl_stmt|;
specifier|const
name|struct
name|usb_audio_output_terminal
modifier|*
name|ot
decl_stmt|;
specifier|const
name|struct
name|usb_audio_mixer_unit_0
modifier|*
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_selector_unit
modifier|*
name|su
decl_stmt|;
specifier|const
name|struct
name|usb_audio_feature_unit
modifier|*
name|fu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_processing_unit_0
modifier|*
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb_audio_extension_unit_0
modifier|*
name|eu
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|desc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
condition|)
block|{
goto|goto
name|error
goto|;
block|}
switch|switch
condition|(
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|it
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|ot
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|mu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|mu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|d1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|mu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|mu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|d1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|su
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|su
operator|->
name|bNrInPins
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|fu
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|len
operator|+=
name|u
operator|.
name|fu
operator|->
name|bControlSize
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|pu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|pu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|u1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|pu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|pu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u1
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u1
operator|->
name|bControlSize
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|eu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|u
operator|.
name|eu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|e1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|eu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|eu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|len
operator|+=
name|e1
operator|->
name|bControlSize
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return
operator|(
name|u
operator|.
name|desc
operator|)
return|;
name|error
label|:
if|if
condition|(
name|u
operator|.
name|desc
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"invalid descriptor, type=%d, "
literal|"sub_type=%d, len=%d of %d bytes\n"
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bDescriptorType
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|uaudio20_mixer_verify_desc
parameter_list|(
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio20_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_extension_unit_1
modifier|*
name|e1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_processing_unit_1
modifier|*
name|u1
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_selector_unit_1
modifier|*
name|c1
decl_stmt|;
union|union
block|{
specifier|const
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_source_unit
modifier|*
name|csrc
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_selector_unit_0
modifier|*
name|csel
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_clock_multiplier_unit
modifier|*
name|cmul
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_input_terminal
modifier|*
name|it
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_output_terminal
modifier|*
name|ot
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_mixer_unit_0
modifier|*
name|mu
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_selector_unit
modifier|*
name|su
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_feature_unit
modifier|*
name|fu
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_sample_rate_unit
modifier|*
name|ru
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_processing_unit_0
modifier|*
name|pu
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_extension_unit_0
modifier|*
name|eu
decl_stmt|;
specifier|const
name|struct
name|usb_audio20_effect_unit
modifier|*
name|ef
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|desc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|it
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|ot
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|mu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|len
operator|+=
name|u
operator|.
name|mu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|d1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|mu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|mu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|d1
argument_list|)
operator|+
name|d1
operator|->
name|bNrChannels
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|su
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|len
operator|+=
name|u
operator|.
name|su
operator|->
name|bNrInPins
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|fu
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EFFECT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|ef
argument_list|)
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING_V2
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|pu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|len
operator|+=
name|u
operator|.
name|pu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|u1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|pu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|pu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION_V2
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|eu
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|len
operator|+=
name|u
operator|.
name|eu
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|e1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|eu
operator|->
name|baSourceId
operator|+
name|u
operator|.
name|eu
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|e1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_CLOCK_SRC
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|csrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_CLOCK_SEL
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|csel
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|len
operator|+=
name|u
operator|.
name|csel
operator|->
name|bNrInPins
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
name|c1
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|u
operator|.
name|csel
operator|->
name|baCSourceId
operator|+
name|u
operator|.
name|csel
operator|->
name|bNrInPins
operator|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|c1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_CLOCK_MUL
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|cmul
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SAMPLE_RT
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|u
operator|.
name|ru
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|u
operator|.
name|desc
operator|->
name|bLength
operator|<
name|len
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
name|u
operator|.
name|desc
operator|)
return|;
name|error
label|:
if|if
condition|(
name|u
operator|.
name|desc
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"invalid descriptor, type=%d, "
literal|"sub_type=%d, len=%d of %d bytes\n"
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bDescriptorType
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
argument_list|,
name|u
operator|.
name|desc
operator|->
name|bLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb_audio_cluster
name|uaudio_mixer_get_cluster
parameter_list|(
name|uint8_t
name|id
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|)
block|{
name|struct
name|usb_audio_cluster
name|r
decl_stmt|;
specifier|const
name|struct
name|usb_descriptor
modifier|*
name|dp
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_RECURSE_LIMIT
condition|;
name|i
operator|++
control|)
block|{
comment|/* avoid infinite loops */
name|dp
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error
goto|;
block|}
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|r
operator|.
name|bNrChannels
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v1
operator|->
name|bNrChannels
expr_stmt|;
name|r
operator|.
name|wChannelConfig
index|[
literal|0
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v1
operator|->
name|wChannelConfig
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|.
name|wChannelConfig
index|[
literal|1
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v1
operator|->
name|wChannelConfig
index|[
literal|1
index|]
expr_stmt|;
name|r
operator|.
name|iChannelNames
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v1
operator|->
name|iChannelNames
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|ot_v1
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|r
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu_v1
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu_v1
operator|->
name|bNrInPins
index|]
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
if|if
condition|(
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su_v1
operator|->
name|bNrInPins
operator|>
literal|0
condition|)
block|{
comment|/* XXX This is not really right */
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su_v1
operator|->
name|baSourceId
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|fu_v1
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|r
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu_v1
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu_v1
operator|->
name|bNrInPins
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|r
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu_v1
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu_v1
operator|->
name|bNrInPins
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
goto|goto
name|error
goto|;
block|}
block|}
name|error
label|:
name|DPRINTF
argument_list|(
literal|"bad data\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|usb_audio20_cluster
name|uaudio20_mixer_get_cluster
parameter_list|(
name|uint8_t
name|id
parameter_list|,
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|)
block|{
name|struct
name|usb_audio20_cluster
name|r
decl_stmt|;
specifier|const
name|struct
name|usb_descriptor
modifier|*
name|dp
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_RECURSE_LIMIT
condition|;
name|i
operator|++
control|)
block|{
comment|/* avoid infinite loops */
name|dp
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|r
operator|.
name|bNrChannels
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v2
operator|->
name|bNrChannels
expr_stmt|;
name|r
operator|.
name|bmChannelConfig
index|[
literal|0
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v2
operator|->
name|bmChannelConfig
index|[
literal|0
index|]
expr_stmt|;
name|r
operator|.
name|bmChannelConfig
index|[
literal|1
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v2
operator|->
name|bmChannelConfig
index|[
literal|1
index|]
expr_stmt|;
name|r
operator|.
name|bmChannelConfig
index|[
literal|2
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v2
operator|->
name|bmChannelConfig
index|[
literal|2
index|]
expr_stmt|;
name|r
operator|.
name|bmChannelConfig
index|[
literal|3
index|]
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v2
operator|->
name|bmChannelConfig
index|[
literal|3
index|]
expr_stmt|;
name|r
operator|.
name|iChannelNames
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|it_v2
operator|->
name|iTerminal
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|ot_v2
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|r
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|usb_audio20_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu_v2
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|mu_v2
operator|->
name|bNrInPins
index|]
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
if|if
condition|(
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su_v2
operator|->
name|bNrInPins
operator|>
literal|0
condition|)
block|{
comment|/* XXX This is not really right */
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|su_v2
operator|->
name|baSourceId
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|UDESCSUB_AC_SAMPLE_RT
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|ru_v2
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EFFECT
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|ef_v2
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|id
operator|=
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|fu_v2
operator|->
name|bSourceId
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING_V2
case|:
name|r
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|usb_audio20_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu_v2
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|pu_v2
operator|->
name|bNrInPins
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|UDESCSUB_AC_EXTENSION_V2
case|:
name|r
operator|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|usb_audio20_cluster
operator|*
operator|)
operator|&
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu_v2
operator|->
name|baSourceId
index|[
name|iot
index|[
name|id
index|]
operator|.
name|u
operator|.
name|eu_v2
operator|->
name|bNrInPins
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
goto|goto
name|error
goto|;
block|}
block|}
name|error
label|:
name|DPRINTF
argument_list|(
literal|"Bad data!\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|uaudio_mixer_determine_class
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mix
parameter_list|)
block|{
name|uint16_t
name|terminal_type
init|=
literal|0x0000
decl_stmt|;
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|input
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|output
index|[
literal|2
index|]
decl_stmt|;
name|input
index|[
literal|0
index|]
operator|=
name|uaudio_mixer_get_input
argument_list|(
name|iot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input
index|[
literal|1
index|]
operator|=
name|uaudio_mixer_get_input
argument_list|(
name|iot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|uaudio_mixer_get_output
argument_list|(
name|iot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|uaudio_mixer_get_output
argument_list|(
name|iot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * check if there is only 	 * one output terminal: 	 */
if|if
condition|(
name|output
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|output
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|output
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|ot_v1
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the only output terminal is USB, 	 * the class is UAC_RECORD. 	 */
if|if
condition|(
operator|(
name|terminal_type
operator|&
literal|0xff00
operator|)
operator|==
operator|(
name|UAT_UNDEFINED
operator|&
literal|0xff00
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_RECORD
expr_stmt|;
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|input
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|input
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|it_v1
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal_type
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * if the unit is connected to just 	 * one input terminal, the 	 * class is UAC_INPUT: 	 */
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|input
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_INPUT
expr_stmt|;
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|input
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|it_v1
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Otherwise, the class is UAC_OUTPUT. 	 */
name|mix
operator|->
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|done
label|:
return|return
operator|(
name|terminal_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|uaudio20_mixer_determine_class
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mix
parameter_list|)
block|{
name|uint16_t
name|terminal_type
init|=
literal|0x0000
decl_stmt|;
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|input
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|output
index|[
literal|2
index|]
decl_stmt|;
name|input
index|[
literal|0
index|]
operator|=
name|uaudio_mixer_get_input
argument_list|(
name|iot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input
index|[
literal|1
index|]
operator|=
name|uaudio_mixer_get_input
argument_list|(
name|iot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|uaudio_mixer_get_output
argument_list|(
name|iot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
index|[
literal|1
index|]
operator|=
name|uaudio_mixer_get_output
argument_list|(
name|iot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * check if there is only 	 * one output terminal: 	 */
if|if
condition|(
name|output
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|output
index|[
literal|1
index|]
operator|)
condition|)
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|output
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|ot_v2
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
comment|/* 	 * If the only output terminal is USB, 	 * the class is UAC_RECORD. 	 */
if|if
condition|(
operator|(
name|terminal_type
operator|&
literal|0xff00
operator|)
operator|==
operator|(
name|UAT_UNDEFINED
operator|&
literal|0xff00
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_RECORD
expr_stmt|;
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|input
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|input
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|it_v2
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal_type
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * if the unit is connected to just 	 * one input terminal, the 	 * class is UAC_INPUT: 	 */
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|input
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|mix
operator|->
name|class
operator|=
name|UAC_INPUT
expr_stmt|;
name|terminal_type
operator|=
name|UGETW
argument_list|(
name|input
index|[
literal|0
index|]
operator|->
name|u
operator|.
name|it_v2
operator|->
name|wTerminalType
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Otherwise, the class is UAC_OUTPUT. 	 */
name|mix
operator|->
name|class
operator|=
name|UAC_OUTPUT
expr_stmt|;
name|done
label|:
return|return
operator|(
name|terminal_type
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|uaudio_tt_to_feature
block|{
name|uint16_t
name|terminal_type
decl_stmt|;
name|uint16_t
name|feature
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|uaudio_tt_to_feature
name|uaudio_tt_to_feature
index|[]
init|=
block|{
block|{
name|UAT_STREAM
block|,
name|SOUND_MIXER_PCM
block|}
block|,
block|{
name|UATI_MICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_DESKMICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_PERSONALMICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_OMNIMICROPHONE
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_MICROPHONEARRAY
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATI_PROCMICROPHONEARR
block|,
name|SOUND_MIXER_MIC
block|}
block|,
block|{
name|UATO_SPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATO_DESKTOPSPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATO_ROOMSPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATO_COMMSPEAKER
block|,
name|SOUND_MIXER_SPEAKER
block|}
block|,
block|{
name|UATE_ANALOGCONN
block|,
name|SOUND_MIXER_LINE
block|}
block|,
block|{
name|UATE_LINECONN
block|,
name|SOUND_MIXER_LINE
block|}
block|,
block|{
name|UATE_LEGACYCONN
block|,
name|SOUND_MIXER_LINE
block|}
block|,
block|{
name|UATE_DIGITALAUIFC
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATE_SPDIF
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATE_1394DA
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATE_1394DV
block|,
name|SOUND_MIXER_ALTPCM
block|}
block|,
block|{
name|UATF_CDPLAYER
block|,
name|SOUND_MIXER_CD
block|}
block|,
block|{
name|UATF_SYNTHESIZER
block|,
name|SOUND_MIXER_SYNTH
block|}
block|,
block|{
name|UATF_VIDEODISCAUDIO
block|,
name|SOUND_MIXER_VIDEO
block|}
block|,
block|{
name|UATF_DVDAUDIO
block|,
name|SOUND_MIXER_VIDEO
block|}
block|,
block|{
name|UATF_TVTUNERAUDIO
block|,
name|SOUND_MIXER_VIDEO
block|}
block|,
comment|/* telephony terminal types */
block|{
name|UATT_UNDEFINED
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATT_PHONELINE
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATT_TELEPHONE
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATT_DOWNLINEPHONE
block|,
name|SOUND_MIXER_PHONEIN
block|}
block|,
comment|/* SOUND_MIXER_PHONEOUT */
block|{
name|UATF_RADIORECV
block|,
name|SOUND_MIXER_RADIO
block|}
block|,
block|{
name|UATF_RADIOXMIT
block|,
name|SOUND_MIXER_RADIO
block|}
block|,
block|{
name|UAT_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UAT_VENDOR
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATI_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* output terminal types */
block|{
name|UATO_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATO_DISPLAYAUDIO
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATO_SUBWOOFER
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATO_HEADPHONES
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* bidir terminal types */
block|{
name|UATB_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_HANDSET
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_HEADSET
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_SPEAKERPHONE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_SPEAKERPHONEESUP
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATB_SPEAKERPHONEECANC
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* external terminal types */
block|{
name|UATE_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* embedded function terminal types */
block|{
name|UATF_UNDEFINED
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_CALIBNOISE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_EQUNOISE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_DAT
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_DCC
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_MINIDISK
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_ANALOGTAPE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_PHONOGRAPH
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_VCRAUDIO
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_SATELLITE
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_CABLETUNER
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_DSS
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
name|UATF_MULTITRACK
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
block|{
literal|0xffff
block|,
name|SOUND_MIXER_VOLUME
block|}
block|,
comment|/* default */
block|{
literal|0x0000
block|,
name|SOUND_MIXER_VOLUME
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint16_t
name|uaudio_mixer_feature_name
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mix
parameter_list|)
block|{
specifier|const
name|struct
name|uaudio_tt_to_feature
modifier|*
name|uat
init|=
name|uaudio_tt_to_feature
decl_stmt|;
name|uint16_t
name|terminal_type
init|=
name|uaudio_mixer_determine_class
argument_list|(
name|iot
argument_list|,
name|mix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mix
operator|->
name|class
operator|==
name|UAC_RECORD
operator|)
operator|&&
operator|(
name|terminal_type
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|SOUND_MIXER_IMIX
operator|)
return|;
block|}
while|while
condition|(
name|uat
operator|->
name|terminal_type
condition|)
block|{
if|if
condition|(
name|uat
operator|->
name|terminal_type
operator|==
name|terminal_type
condition|)
block|{
break|break;
block|}
name|uat
operator|++
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"terminal_type=0x%04x -> %d\n"
argument_list|,
name|terminal_type
argument_list|,
name|uat
operator|->
name|feature
argument_list|)
expr_stmt|;
return|return
operator|(
name|uat
operator|->
name|feature
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|uaudio20_mixer_feature_name
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mix
parameter_list|)
block|{
specifier|const
name|struct
name|uaudio_tt_to_feature
modifier|*
name|uat
decl_stmt|;
name|uint16_t
name|terminal_type
init|=
name|uaudio20_mixer_determine_class
argument_list|(
name|iot
argument_list|,
name|mix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|mix
operator|->
name|class
operator|==
name|UAC_RECORD
operator|)
operator|&&
operator|(
name|terminal_type
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|SOUND_MIXER_IMIX
operator|)
return|;
for|for
control|(
name|uat
operator|=
name|uaudio_tt_to_feature
init|;
name|uat
operator|->
name|terminal_type
operator|!=
literal|0
condition|;
name|uat
operator|++
control|)
block|{
if|if
condition|(
name|uat
operator|->
name|terminal_type
operator|==
name|terminal_type
condition|)
break|break;
block|}
name|DPRINTF
argument_list|(
literal|"terminal_type=0x%04x -> %d\n"
argument_list|,
name|terminal_type
argument_list|,
name|uat
operator|->
name|feature
argument_list|)
expr_stmt|;
return|return
operator|(
name|uat
operator|->
name|feature
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_input
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|uint8_t
name|i
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|root
init|=
name|iot
operator|->
name|root
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|n
operator|=
name|iot
operator|->
name|usr
operator|.
name|id_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iot
operator|->
name|usr
operator|.
name|bit_input
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|--
condition|)
return|return
operator|(
name|root
operator|+
name|n
operator|)
return|;
block|}
block|}
do|while
condition|(
name|n
operator|--
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|uaudio_mixer_get_output
parameter_list|(
specifier|const
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
parameter_list|,
name|uint8_t
name|i
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|root
init|=
name|iot
operator|->
name|root
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|n
operator|=
name|iot
operator|->
name|usr
operator|.
name|id_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iot
operator|->
name|usr
operator|.
name|bit_output
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|--
condition|)
return|return
operator|(
name|root
operator|+
name|n
operator|)
return|;
block|}
block|}
do|while
condition|(
name|n
operator|--
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_find_inputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
name|root
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p_id
parameter_list|,
name|uint8_t
name|n_id
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|is_last
decl_stmt|;
name|top
label|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_id
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|=
name|p_id
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|recurse_level
operator|==
name|UAUDIO_RECURSE_LIMIT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"avoided going into a circle at id=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|->
name|recurse_level
operator|++
expr_stmt|;
name|iot
operator|=
operator|(
name|root
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
continue|continue;
name|is_last
operator|=
operator|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|==
name|n_id
operator|)
expr_stmt|;
switch|switch
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|info
operator|->
name|bit_input
index|[
name|i
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|fu_v1
operator|->
name|bSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|fu_v1
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|ot_v1
operator|->
name|bSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|ot_v1
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|mu_v1
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|mu_v1
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|mu_v1
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|mu_v1
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|su_v1
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|su_v1
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|su_v1
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|su_v1
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|pu_v1
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|pu_v1
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|pu_v1
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|pu_v1
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|eu_v1
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|eu_v1
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|eu_v1
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|eu_v1
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio20_mixer_find_inputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
name|root
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p_id
parameter_list|,
name|uint8_t
name|n_id
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|is_last
decl_stmt|;
name|top
label|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_id
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|=
name|p_id
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|recurse_level
operator|==
name|UAUDIO_RECURSE_LIMIT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"avoided going into a circle at id=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|->
name|recurse_level
operator|++
expr_stmt|;
name|iot
operator|=
operator|(
name|root
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
continue|continue;
name|is_last
operator|=
operator|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|==
name|n_id
operator|)
expr_stmt|;
switch|switch
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|info
operator|->
name|bit_input
index|[
name|i
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|ot_v2
operator|->
name|bSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|ot_v2
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|mu_v2
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|mu_v2
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|mu_v2
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|mu_v2
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|su_v2
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|su_v2
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|su_v2
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|su_v2
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SAMPLE_RT
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|ru_v2
operator|->
name|bSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|ru_v2
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EFFECT
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|ef_v2
operator|->
name|bSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|ef_v2
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|fu_v2
operator|->
name|bSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|fu_v2
operator|->
name|bSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING_V2
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|pu_v2
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|pu_v2
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|pu_v2
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|pu_v2
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION_V2
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|eu_v2
operator|->
name|baSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|eu_v2
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|eu_v2
operator|->
name|baSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|eu_v2
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio20_mixer_find_clocks_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
name|root
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|p_id
parameter_list|,
name|uint8_t
name|n_id
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|is_last
decl_stmt|;
name|uint8_t
name|id
decl_stmt|;
name|top
label|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_id
condition|;
name|n
operator|++
control|)
block|{
name|i
operator|=
name|p_id
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|recurse_level
operator|==
name|UAUDIO_RECURSE_LIMIT
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"avoided going into a circle at id=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|->
name|recurse_level
operator|++
expr_stmt|;
name|iot
operator|=
operator|(
name|root
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|==
name|NULL
condition|)
continue|continue;
name|is_last
operator|=
operator|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|==
name|n_id
operator|)
expr_stmt|;
switch|switch
condition|(
name|iot
operator|->
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
name|info
operator|->
name|is_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|it_v2
operator|->
name|bCSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_clocks_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|it_v2
operator|->
name|bCSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|info
operator|->
name|is_input
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|ot_v2
operator|->
name|bCSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_clocks_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|ot_v2
operator|->
name|bCSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_CLOCK_SEL
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
name|iot
operator|->
name|u
operator|.
name|csel_v2
operator|->
name|baCSourceId
expr_stmt|;
name|n_id
operator|=
name|iot
operator|->
name|u
operator|.
name|csel_v2
operator|->
name|bNrInPins
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_clocks_sub
argument_list|(
name|root
argument_list|,
name|iot
operator|->
name|u
operator|.
name|csel_v2
operator|->
name|baCSourceId
argument_list|,
name|iot
operator|->
name|u
operator|.
name|csel_v2
operator|->
name|bNrInPins
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_CLOCK_MUL
case|:
if|if
condition|(
name|is_last
condition|)
block|{
name|p_id
operator|=
operator|&
name|iot
operator|->
name|u
operator|.
name|cmul_v2
operator|->
name|bCSourceId
expr_stmt|;
name|n_id
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|uaudio20_mixer_find_clocks_sub
argument_list|(
name|root
argument_list|,
operator|&
name|iot
operator|->
name|u
operator|.
name|cmul_v2
operator|->
name|bCSourceId
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_CLOCK_SRC
case|:
name|id
operator|=
name|iot
operator|->
name|u
operator|.
name|csrc_v2
operator|->
name|bClockId
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|is_input
condition|)
block|{
case|case
literal|0
case|:
name|info
operator|->
name|bit_output
index|[
name|id
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|id
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|info
operator|->
name|bit_input
index|[
name|id
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|id
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_find_outputs_sub
parameter_list|(
name|struct
name|uaudio_terminal_node
modifier|*
name|root
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|uint8_t
name|n_id
parameter_list|,
name|struct
name|uaudio_search_result
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
init|=
operator|(
name|root
operator|+
name|id
operator|)
decl_stmt|;
name|uint8_t
name|j
decl_stmt|;
name|j
operator|=
name|n_id
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|j
operator|!=
name|id
operator|)
operator|&&
operator|(
operator|(
name|root
operator|+
name|j
operator|)
operator|->
name|u
operator|.
name|desc
operator|)
operator|&&
operator|(
operator|(
name|root
operator|+
name|j
operator|)
operator|->
name|u
operator|.
name|desc
operator|->
name|bDescriptorSubtype
operator|==
name|UDESCSUB_AC_OUTPUT
operator|)
condition|)
block|{
comment|/* 			 * "j" (output)<--- virtual wire<--- "id" (input) 			 * 			 * if "j" has "id" on the input, then "id" have "j" on 			 * the output, because they are connected: 			 */
if|if
condition|(
operator|(
name|root
operator|+
name|j
operator|)
operator|->
name|usr
operator|.
name|bit_input
index|[
name|id
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|id
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
name|iot
operator|->
name|usr
operator|.
name|bit_output
index|[
name|j
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|j
operator|--
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_fill_info
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|void
modifier|*
name|desc
parameter_list|)
block|{
specifier|const
name|struct
name|usb_audio_control_descriptor
modifier|*
name|acdp
decl_stmt|;
name|struct
name|usb_config_descriptor
modifier|*
name|cd
init|=
name|usbd_get_config_descriptor
argument_list|(
name|udev
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|usb_descriptor
modifier|*
name|dp
decl_stmt|;
specifier|const
name|struct
name|usb_audio_unit
modifier|*
name|au
decl_stmt|;
name|struct
name|uaudio_terminal_node
modifier|*
name|iot
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|wTotalLen
decl_stmt|;
name|uint8_t
name|ID_max
init|=
literal|0
decl_stmt|;
comment|/* inclusive */
name|uint8_t
name|i
decl_stmt|;
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no Audio Control header\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|acdp
operator|=
name|desc
expr_stmt|;
if|if
condition|(
operator|(
name|acdp
operator|->
name|bLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|acdp
argument_list|)
operator|)
operator|||
operator|(
name|acdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|)
operator|||
operator|(
name|acdp
operator|->
name|bDescriptorSubtype
operator|!=
name|UDESCSUB_AC_HEADER
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"invalid Audio Control header\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* "wTotalLen" is allowed to be corrupt */
name|wTotalLen
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|wTotalLength
argument_list|)
operator|-
name|acdp
operator|->
name|bLength
expr_stmt|;
comment|/* get USB audio revision */
name|sc
operator|->
name|sc_audio_rev
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"found AC header, vers=%03x, len=%d\n"
argument_list|,
name|sc
operator|->
name|sc_audio_rev
argument_list|,
name|wTotalLen
argument_list|)
expr_stmt|;
name|iot
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uaudio_terminal_node
argument_list|)
operator|*
literal|256
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|iot
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"no memory!\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
operator|(
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
name|dp
operator|=
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|bLength
operator|>
name|wTotalLen
condition|)
block|{
break|break;
block|}
else|else
block|{
name|wTotalLen
operator|-=
name|dp
operator|->
name|bLength
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
name|au
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
name|au
operator|=
name|uaudio20_mixer_verify_desc
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|au
operator|=
name|uaudio_mixer_verify_desc
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|au
condition|)
block|{
name|iot
index|[
name|au
operator|->
name|bUnitId
index|]
operator|.
name|u
operator|.
name|desc
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|au
expr_stmt|;
if|if
condition|(
name|au
operator|->
name|bUnitId
operator|>
name|ID_max
condition|)
name|ID_max
operator|=
name|au
operator|->
name|bUnitId
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|"Maximum ID=%d\n"
argument_list|,
name|ID_max
argument_list|)
expr_stmt|;
comment|/* 	 * determine sourcing inputs for 	 * all nodes in the tree: 	 */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
comment|/* FALLTHROUGH */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
name|uaudio20_mixer_find_inputs_sub
argument_list|(
name|iot
argument_list|,
operator|&
name|i
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mixer_clocks
operator|.
name|is_input
operator|=
literal|255
expr_stmt|;
name|sc
operator|->
name|sc_mixer_clocks
operator|.
name|recurse_level
operator|=
literal|0
expr_stmt|;
name|uaudio20_mixer_find_clocks_sub
argument_list|(
name|iot
argument_list|,
operator|&
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|sc
operator|->
name|sc_mixer_clocks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uaudio_mixer_find_inputs_sub
argument_list|(
name|iot
argument_list|,
operator|&
name|i
argument_list|,
literal|1
argument_list|,
operator|&
operator|(
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
comment|/* 	 * determine outputs for 	 * all nodes in the tree: 	 */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
name|uaudio_mixer_find_outputs_sub
argument_list|(
name|iot
argument_list|,
name|i
argument_list|,
name|ID_max
argument_list|,
operator|&
operator|(
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
comment|/* set "id_max" and "root" */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|usr
operator|.
name|id_max
operator|=
name|ID_max
expr_stmt|;
operator|(
name|iot
operator|+
name|i
operator|)
operator|->
name|root
operator|=
name|iot
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
comment|/* 	 * Scan the config to create a linked list of "mixer" nodes: 	 */
name|i
operator|=
name|ID_max
expr_stmt|;
do|do
block|{
name|dp
operator|=
name|iot
index|[
name|i
index|]
operator|.
name|u
operator|.
name|desc
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
name|DPRINTFN
argument_list|(
literal|11
argument_list|,
literal|"id=%d subtype=%d\n"
argument_list|,
name|i
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_HEADER
case|:
name|DPRINTF
argument_list|(
literal|"unexpected AC header\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_INPUT
case|:
case|case
name|UDESCSUB_AC_OUTPUT
case|:
case|case
name|UDESCSUB_AC_PROCESSING_V2
case|:
case|case
name|UDESCSUB_AC_EXTENSION_V2
case|:
case|case
name|UDESCSUB_AC_EFFECT
case|:
case|case
name|UDESCSUB_AC_CLOCK_SRC
case|:
case|case
name|UDESCSUB_AC_CLOCK_SEL
case|:
case|case
name|UDESCSUB_AC_CLOCK_MUL
case|:
case|case
name|UDESCSUB_AC_SAMPLE_RT
case|:
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|uaudio20_mixer_add_mixer
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|uaudio20_mixer_add_selector
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|uaudio20_mixer_add_feature
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"bad AC desc subtype=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_HEADER
case|:
name|DPRINTF
argument_list|(
literal|"unexpected AC header\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_INPUT
case|:
case|case
name|UDESCSUB_AC_OUTPUT
case|:
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|uaudio_mixer_add_mixer
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|uaudio_mixer_add_selector
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|uaudio_mixer_add_feature
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|uaudio_mixer_add_processing
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|uaudio_mixer_add_extension
argument_list|(
name|sc
argument_list|,
name|iot
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"bad AC desc subtype=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
name|done
label|:
name|free
argument_list|(
name|iot
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_mixer_get
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint16_t
name|audio_rev
parameter_list|,
name|uint8_t
name|what
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|int
name|val
decl_stmt|;
name|uint8_t
name|data
index|[
literal|2
operator|+
operator|(
literal|2
operator|*
literal|3
operator|)
index|]
decl_stmt|;
name|usb_error_t
name|err
decl_stmt|;
if|if
condition|(
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|GET_CUR
condition|)
block|{
name|req
operator|.
name|bRequest
operator|=
name|UA20_CS_CUR
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|req
operator|.
name|bRequest
operator|=
name|UA20_CS_RANGE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint16_t
name|len
init|=
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
decl_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|what
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_CLASS_INTERFACE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"err=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|GET_CUR
case|:
name|val
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|GET_MIN
case|:
name|val
operator|=
operator|(
name|data
index|[
literal|2
index|]
operator||
operator|(
name|data
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|GET_MAX
case|:
name|val
operator|=
operator|(
name|data
index|[
literal|4
index|]
operator||
operator|(
name|data
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|GET_RES
case|:
name|val
operator|=
operator|(
name|data
index|[
literal|6
index|]
operator||
operator|(
name|data
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|val
operator|=
operator|(
name|data
index|[
literal|0
index|]
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|what
operator|==
name|GET_CUR
operator|||
name|what
operator|==
name|GET_MIN
operator|||
name|what
operator|==
name|GET_MAX
condition|)
name|val
operator|=
name|uaudio_mixer_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
literal|"val=%d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_write_cfg_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
init|=
name|sc
operator|->
name|sc_mixer_curr
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint8_t
name|repeat
init|=
literal|1
decl_stmt|;
name|uint8_t
name|update
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|tr_transferred
label|:
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
expr_stmt|;
name|sc
operator|->
name|sc_mixer_curr
operator|=
name|mc
expr_stmt|;
name|sc
operator|->
name|sc_mixer_chan
operator|=
literal|0
expr_stmt|;
name|repeat
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|mc
condition|)
block|{
while|while
condition|(
name|sc
operator|->
name|sc_mixer_chan
operator|<
name|mc
operator|->
name|nchan
condition|)
block|{
name|chan
operator|=
name|sc
operator|->
name|sc_mixer_chan
expr_stmt|;
name|sc
operator|->
name|sc_mixer_chan
operator|++
expr_stmt|;
name|update
operator|=
operator|(
operator|(
name|mc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
operator|)
operator|&&
operator|(
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
operator|!=
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|mc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_30
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_audio_rev
operator|>=
name|UAUDIO_VERSION_20
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UA20_CS_CUR
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SET_CUR
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|mc
operator|->
name|wData
index|[
name|chan
index|]
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|mc
operator|->
name|wData
index|[
name|chan
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
name|len
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mc
operator|=
name|mc
operator|->
name|next
expr_stmt|;
name|sc
operator|->
name|sc_mixer_curr
operator|=
name|mc
expr_stmt|;
name|sc
operator|->
name|sc_mixer_chan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|repeat
condition|)
block|{
goto|goto
name|tr_setup
goto|;
block|}
break|break;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* do nothing - we are detaching */
break|break;
block|}
goto|goto
name|tr_transferred
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|uaudio_set_speed
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|endpt
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|uint8_t
name|data
index|[
literal|3
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"endpt=%d speed=%u\n"
argument_list|,
name|endpt
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_ENDPOINT
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SET_CUR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|SAMPLING_FREQ_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|speed
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|speed
operator|>>
literal|16
expr_stmt|;
return|return
operator|(
name|usbd_do_request
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|uaudio20_set_speed
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|iface_no
parameter_list|,
name|uint8_t
name|clockid
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|uint8_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"ifaceno=%d clockid=%d speed=%u\n"
argument_list|,
name|iface_no
argument_list|,
name|clockid
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_INTERFACE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UA20_CS_CUR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|UA20_CS_SAM_FREQ_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|clockid
argument_list|,
name|iface_no
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|speed
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|speed
operator|>>
literal|16
expr_stmt|;
name|data
index|[
literal|3
index|]
operator|=
name|speed
operator|>>
literal|24
expr_stmt|;
return|return
operator|(
name|usbd_do_request
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_mixer_signext
parameter_list|(
name|uint8_t
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MIX_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|MIX_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|2
condition|)
block|{
name|val
operator|=
operator|(
name|int16_t
operator|)
name|val
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
name|int8_t
operator|)
name|val
expr_stmt|;
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_mixer_bsd2value
parameter_list|(
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|<
name|mc
operator|->
name|minval
operator|)
operator|||
operator|(
name|val
operator|>
name|mc
operator|->
name|maxval
operator|)
condition|)
block|{
name|val
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* compute actual volume */
name|val
operator|=
operator|(
name|val
operator|*
name|mc
operator|->
name|mul
operator|)
operator|/
literal|255
expr_stmt|;
comment|/* add lower offset */
name|val
operator|=
name|val
operator|+
name|mc
operator|->
name|minval
expr_stmt|;
comment|/* make sure we don't write a value out of range */
if|if
condition|(
name|val
operator|>
name|mc
operator|->
name|maxval
condition|)
name|val
operator|=
name|mc
operator|->
name|maxval
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
name|mc
operator|->
name|minval
condition|)
name|val
operator|=
name|mc
operator|->
name|minval
expr_stmt|;
block|}
name|DPRINTFN
argument_list|(
literal|6
argument_list|,
literal|"type=0x%03x val=%d min=%d max=%d val=%d\n"
argument_list|,
name|mc
operator|->
name|type
argument_list|,
name|val
argument_list|,
name|mc
operator|->
name|minval
argument_list|,
name|mc
operator|->
name|maxval
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
parameter_list|,
name|uint8_t
name|chan
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
name|val
operator|=
name|uaudio_mixer_bsd2value
argument_list|(
name|mc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|mc
operator|->
name|update
index|[
name|chan
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|chan
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|mc
operator|->
name|wData
index|[
name|chan
index|]
operator|=
name|val
expr_stmt|;
comment|/* start the transfer, if not already started */
name|usbd_transfer_start
argument_list|(
name|sc
operator|->
name|sc_mixer_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_mixer_init
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|mc
condition|;
name|mc
operator|=
name|mc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|ctl
operator|!=
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
comment|/* 			 * Set device mask bits. See 			 * /usr/include/machine/soundcard.h 			 */
name|sc
operator|->
name|sc_mix_info
operator||=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|ctl
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
operator|)
operator|&&
operator|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
continue|continue;
block|}
name|sc
operator|->
name|sc_recsrc_info
operator||=
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|uaudio_mixer_init_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mixer_lock
operator|=
name|mixer_get_lock
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mixer_dev
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|,
name|sc
operator|->
name|sc_mixer_xfer
argument_list|,
name|uaudio_mixer_config
argument_list|,
literal|1
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"could not allocate USB "
literal|"transfer for audio mixer!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_mix_info
operator|&
name|SOUND_MASK_VOLUME
operator|)
condition|)
block|{
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MASK_PCM
argument_list|)
expr_stmt|;
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|sc
operator|->
name|sc_mix_info
argument_list|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|sc
operator|->
name|sc_recsrc_info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_mixer_uninit_sub
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_mixer_xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mixer_lock
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_mixer_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|type
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
decl_stmt|;
name|int
name|chan
decl_stmt|;
for|for
control|(
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|mc
operator|!=
name|NULL
condition|;
name|mc
operator|=
name|mc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mc
operator|->
name|ctl
operator|==
name|type
condition|)
block|{
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|mc
operator|->
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
name|uaudio_mixer_ctl_set
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|,
name|chan
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|chan
operator|==
literal|0
condition|?
name|left
else|:
name|right
operator|)
operator|*
literal|255
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|uint32_t
name|uaudio_mixer_setrecsrc
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src
parameter_list|)
block|{
name|struct
name|uaudio_mixer_node
modifier|*
name|mc
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|mc
operator|=
name|sc
operator|->
name|sc_mixer_root
init|;
name|mc
condition|;
name|mc
operator|=
name|mc
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|mc
operator|->
name|ctl
operator|==
name|SOUND_MIXER_NRDEVICES
operator|)
operator|&&
operator|(
name|mc
operator|->
name|type
operator|==
name|MIX_SELECTOR
operator|)
condition|)
block|{
comment|/* compute selector mask */
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator||=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
name|temp
operator|=
name|mask
operator|&
name|src
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* find the first set bit */
name|temp
operator|=
operator|(
operator|-
name|temp
operator|)
operator|&
name|temp
expr_stmt|;
comment|/* update "src" */
name|src
operator|&=
operator|~
name|mask
expr_stmt|;
name|src
operator||=
name|temp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mc
operator|->
name|minval
init|;
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<=
name|mc
operator|->
name|maxval
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|temp
operator|!=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|slctrtype
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
block|{
continue|continue;
block|}
name|uaudio_mixer_ctl_set
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|src
operator|)
return|;
block|}
end_function

begin_comment
comment|/*========================================================================*  * MIDI support routines  *========================================================================*/
end_comment

begin_function
specifier|static
name|void
name|umidi_bulk_read_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|cmd_len
decl_stmt|;
name|uint8_t
name|cn
decl_stmt|;
name|uint16_t
name|pos
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTF
argument_list|(
literal|"actlen=%d bytes\n"
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|actlen
operator|>=
literal|4
condition|)
block|{
comment|/* copy out the MIDI data */
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* command length */
name|cmd_len
operator|=
name|umidi_cmd_to_len
index|[
name|buf
index|[
literal|0
index|]
operator|&
literal|0xF
index|]
expr_stmt|;
comment|/* cable number */
name|cn
operator|=
name|buf
index|[
literal|0
index|]
operator|>>
literal|4
expr_stmt|;
comment|/* 			 * Lookup sub-channel. The index is range 			 * checked below. 			 */
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|cn
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cmd_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|cn
operator|<
name|chan
operator|->
name|max_cable
operator|)
operator|&&
operator|(
name|sub
operator|->
name|read_open
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Send data to the application */
name|usb_fifo_put_data_linear
argument_list|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|cmd_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|actlen
operator|-=
literal|4
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
name|tr_setup
label|:
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * The following statemachine, that converts MIDI commands to  * USB MIDI packets, derives from Linux's usbmidi.c, which  * was written by "Clemens Ladisch":  *  * Returns:  *    0: No command  * Else: Command is complete  */
end_comment

begin_function
specifier|static
name|uint8_t
name|umidi_convert_to_usb
parameter_list|(
name|struct
name|umidi_sub_chan
modifier|*
name|sub
parameter_list|,
name|uint8_t
name|cn
parameter_list|,
name|uint8_t
name|b
parameter_list|)
block|{
name|uint8_t
name|p0
init|=
operator|(
name|cn
operator|<<
literal|4
operator|)
decl_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0xf8
condition|)
block|{
name|sub
operator|->
name|temp_0
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x0f
expr_stmt|;
name|sub
operator|->
name|temp_0
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_0
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_0
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|>=
literal|0xf0
condition|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
literal|0xf0
case|:
comment|/* system exclusive begin */
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_1
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
comment|/* MIDI time code */
case|case
literal|0xf3
case|:
comment|/* song select */
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_1PARAM
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
comment|/* song position pointer */
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_1
expr_stmt|;
break|break;
case|case
literal|0xf4
case|:
comment|/* unknown */
case|case
literal|0xf5
case|:
comment|/* unknown */
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
break|break;
case|case
literal|0xf6
case|:
comment|/* tune request */
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x05
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
literal|0xf6
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0xf7
case|:
comment|/* system exclusive end */
switch|switch
condition|(
name|sub
operator|->
name|state
condition|)
block|{
case|case
name|UMIDI_ST_SYSEX_0
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x05
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
literal|0xf7
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_SYSEX_1
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x06
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
literal|0xf7
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_SYSEX_2
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x07
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0xf7
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|>=
literal|0x80
condition|)
block|{
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|>=
literal|0xc0
operator|)
operator|&&
operator|(
name|b
operator|<=
literal|0xdf
operator|)
condition|)
block|{
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_1PARAM
expr_stmt|;
block|}
else|else
block|{
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* b< 0x80 */
switch|switch
condition|(
name|sub
operator|->
name|state
condition|)
block|{
case|case
name|UMIDI_ST_1PARAM
case|:
if|if
condition|(
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|<
literal|0xf0
condition|)
block|{
name|p0
operator||=
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|>>
literal|4
expr_stmt|;
block|}
else|else
block|{
name|p0
operator||=
literal|0x02
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
block|}
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_2PARAM_1
case|:
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_2
expr_stmt|;
break|break;
case|case
name|UMIDI_ST_2PARAM_2
case|:
if|if
condition|(
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|<
literal|0xf0
condition|)
block|{
name|p0
operator||=
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|>>
literal|4
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_2PARAM_1
expr_stmt|;
block|}
else|else
block|{
name|p0
operator||=
literal|0x03
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
block|}
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|UMIDI_ST_SYSEX_0
case|:
name|sub
operator|->
name|temp_1
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_1
expr_stmt|;
break|break;
case|case
name|UMIDI_ST_SYSEX_1
case|:
name|sub
operator|->
name|temp_1
index|[
literal|2
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_2
expr_stmt|;
break|break;
case|case
name|UMIDI_ST_SYSEX_2
case|:
name|sub
operator|->
name|temp_1
index|[
literal|0
index|]
operator|=
name|p0
operator||
literal|0x04
expr_stmt|;
name|sub
operator|->
name|temp_1
index|[
literal|3
index|]
operator|=
name|b
expr_stmt|;
name|sub
operator|->
name|temp_cmd
operator|=
name|sub
operator|->
name|temp_1
expr_stmt|;
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_SYSEX_0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_bulk_write_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint32_t
name|actlen
decl_stmt|;
name|uint16_t
name|nframes
decl_stmt|;
name|uint8_t
name|buf
decl_stmt|;
name|uint8_t
name|start_cable
decl_stmt|;
name|uint8_t
name|tr_any
decl_stmt|;
name|int
name|len
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: Some MIDI devices only accept 4 bytes of data per 	 * short terminated USB transfer. 	 */
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTF
argument_list|(
literal|"actlen=%d bytes\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
name|DPRINTF
argument_list|(
literal|"start\n"
argument_list|)
expr_stmt|;
name|nframes
operator|=
literal|0
expr_stmt|;
comment|/* reset */
name|start_cable
operator|=
name|chan
operator|->
name|curr_cable
expr_stmt|;
name|tr_any
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* round robin de-queueing */
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|chan
operator|->
name|curr_cable
index|]
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|write_open
condition|)
block|{
name|usb_fifo_get_data_linear
argument_list|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_TX
index|]
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|,
operator|&
name|actlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|actlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|actlen
condition|)
block|{
name|tr_any
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"byte=0x%02x from FIFO %u\n"
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|chan
operator|->
name|curr_cable
argument_list|)
expr_stmt|;
if|if
condition|(
name|umidi_convert_to_usb
argument_list|(
name|sub
argument_list|,
name|chan
operator|->
name|curr_cable
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"sub=0x%02x 0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|0
index|]
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|1
index|]
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|2
index|]
argument_list|,
name|sub
operator|->
name|temp_cmd
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
name|nframes
operator|*
literal|4
argument_list|,
name|sub
operator|->
name|temp_cmd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nframes
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|nframes
operator|>=
name|UMIDI_TX_FRAMES
operator|)
operator|||
operator|(
name|chan
operator|->
name|single_command
operator|!=
literal|0
operator|)
condition|)
break|break;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|chan
operator|->
name|curr_cable
operator|++
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|curr_cable
operator|>=
name|chan
operator|->
name|max_cable
condition|)
name|chan
operator|->
name|curr_cable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|curr_cable
operator|==
name|start_cable
condition|)
block|{
if|if
condition|(
name|tr_any
operator|==
literal|0
condition|)
break|break;
name|tr_any
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nframes
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Transferring %d frames\n"
argument_list|,
operator|(
name|int
operator|)
name|nframes
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
literal|4
operator|*
name|nframes
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|umidi_sub_chan
modifier|*
name|umidi_sub_by_fifo
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UMIDI_CABLES_MAX
condition|;
name|n
operator|++
control|)
block|{
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_RX
index|]
operator|==
name|fifo
operator|)
operator|||
operator|(
name|sub
operator|->
name|fifo
operator|.
name|fp
index|[
name|USB_FIFO_TX
index|]
operator|==
name|fifo
operator|)
condition|)
block|{
return|return
operator|(
name|sub
operator|)
return|;
block|}
block|}
name|panic
argument_list|(
literal|"%s:%d cannot find usb_fifo!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_start_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|usbd_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
name|UMIDI_RX_TRANSFER
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_stop_read
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
init|=
name|umidi_sub_by_fifo
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sub
operator|->
name|read_open
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|chan
operator|->
name|read_open_refcount
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX don't stop the read transfer here, hence that causes 		 * problems with some MIDI adapters 		 */
name|DPRINTF
argument_list|(
literal|"(stopping read transfer)\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_start_write
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|usbd_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
name|UMIDI_TX_TRANSFER
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_stop_write
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
init|=
name|umidi_sub_by_fifo
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sub
operator|->
name|write_open
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|chan
operator|->
name|write_open_refcount
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"(stopping write transfer)\n"
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
name|UMIDI_TX_TRANSFER
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|umidi_open
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
name|usb_fifo_softc
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
init|=
name|umidi_sub_by_fifo
argument_list|(
name|fifo
argument_list|)
decl_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
if|if
condition|(
name|usb_fifo_alloc_buffer
argument_list|(
name|fifo
argument_list|,
literal|4
argument_list|,
operator|(
literal|1024
operator|/
literal|4
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|chan
operator|->
name|read_open_refcount
operator|++
expr_stmt|;
name|sub
operator|->
name|read_open
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
if|if
condition|(
name|usb_fifo_alloc_buffer
argument_list|(
name|fifo
argument_list|,
literal|32
argument_list|,
operator|(
literal|1024
operator|/
literal|32
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* clear stall first */
name|mtx_lock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|chan
operator|->
name|write_open_refcount
operator|++
expr_stmt|;
name|sub
operator|->
name|write_open
operator|=
literal|1
expr_stmt|;
comment|/* reset */
name|sub
operator|->
name|state
operator|=
name|UMIDI_ST_UNKNOWN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_close
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
block|{
name|usb_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
block|{
name|usb_fifo_free_buffer
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|umidi_ioctl
parameter_list|(
name|struct
name|usb_fifo
modifier|*
name|fifo
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflags
parameter_list|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umidi_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_midi_chan
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|,
literal|"umidi lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|usb_fifo_methods
name|umidi_fifo_methods
init|=
block|{
operator|.
name|f_start_read
operator|=
operator|&
name|umidi_start_read
block|,
operator|.
name|f_start_write
operator|=
operator|&
name|umidi_start_write
block|,
operator|.
name|f_stop_read
operator|=
operator|&
name|umidi_stop_read
block|,
operator|.
name|f_stop_write
operator|=
operator|&
name|umidi_stop_write
block|,
operator|.
name|f_open
operator|=
operator|&
name|umidi_open
block|,
operator|.
name|f_close
operator|=
operator|&
name|umidi_close
block|,
operator|.
name|f_ioctl
operator|=
operator|&
name|umidi_ioctl
block|,
operator|.
name|basename
index|[
literal|0
index|]
operator|=
literal|"umidi"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|umidi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_midi_chan
decl_stmt|;
name|struct
name|umidi_sub_chan
modifier|*
name|sub
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
if|if
condition|(
name|usb_test_quirk
argument_list|(
name|uaa
argument_list|,
name|UQ_SINGLE_CMD_MIDI
argument_list|)
condition|)
name|chan
operator|->
name|single_command
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usbd_set_alt_interface_index
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|,
name|chan
operator|->
name|iface_alt_index
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"setting of alternate index failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
name|usbd_set_parent_iface
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|chan
operator|->
name|iface_index
argument_list|,
name|chan
operator|->
name|xfer
argument_list|,
name|umidi_config
argument_list|,
name|UMIDI_N_TRANSFER
argument_list|,
name|chan
argument_list|,
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|detach
goto|;
block|}
comment|/* 	 * Some USB MIDI device makers couldn't resist using 	 * wMaxPacketSize = 4 for RX and TX BULK endpoints, although 	 * that size is an unsupported value for FULL speed BULK 	 * endpoints. The same applies to some HIGH speed MIDI devices 	 * which are using a wMaxPacketSize different from 512 bytes. 	 * 	 * Refer to section 5.8.3 in USB 2.0 PDF: Cite: "All Host 	 * Controllers are required to have support for 8-, 16-, 32-, 	 * and 64-byte maximum packet sizes for full-speed bulk 	 * endpoints and 512 bytes for high-speed bulk endpoints." 	 */
if|if
condition|(
name|usbd_xfer_maxp_was_clamped
argument_list|(
name|chan
operator|->
name|xfer
index|[
name|UMIDI_TX_TRANSFER
index|]
argument_list|)
condition|)
name|chan
operator|->
name|single_command
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|single_command
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Single command MIDI quirk enabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|->
name|max_cable
operator|>
name|UMIDI_CABLES_MAX
operator|)
operator|||
operator|(
name|chan
operator|->
name|max_cable
operator|==
literal|0
operator|)
condition|)
block|{
name|chan
operator|->
name|max_cable
operator|=
name|UMIDI_CABLES_MAX
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|chan
operator|->
name|max_cable
condition|;
name|n
operator|++
control|)
block|{
name|sub
operator|=
operator|&
name|chan
operator|->
name|sub
index|[
name|n
index|]
expr_stmt|;
name|error
operator|=
name|usb_fifo_attach
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|chan
argument_list|,
operator|&
name|chan
operator|->
name|mtx
argument_list|,
operator|&
name|umidi_fifo_methods
argument_list|,
operator|&
name|sub
operator|->
name|fifo
argument_list|,
name|unit
argument_list|,
name|n
argument_list|,
name|chan
operator|->
name|iface_index
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|detach
goto|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: At least one device will not work properly unless the 	 * BULK IN pipe is open all the time. This might have to do 	 * about that the internal queues of the device overflow if we 	 * don't read them regularly. 	 */
name|usbd_transfer_start
argument_list|(
name|chan
operator|->
name|xfer
index|[
name|UMIDI_RX_TRANSFER
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|detach
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|int
name|umidi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|umidi_chan
modifier|*
name|chan
init|=
operator|&
name|sc
operator|->
name|sc_midi_chan
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|UMIDI_CABLES_MAX
condition|;
name|n
operator|++
control|)
block|{
name|usb_fifo_detach
argument_list|(
operator|&
name|chan
operator|->
name|sub
index|[
name|n
index|]
operator|.
name|fifo
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|chan
operator|->
name|xfer
index|[
name|UMIDI_RX_TRANSFER
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|usbd_transfer_unsetup
argument_list|(
name|chan
operator|->
name|xfer
argument_list|,
name|UMIDI_N_TRANSFER
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|chan
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_hid_rx_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|buffer
init|=
name|usbd_xfer_get_frame_buffer
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|snd_mixer
modifier|*
name|m
decl_stmt|;
name|uint8_t
name|id
decl_stmt|;
name|int
name|actlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|DPRINTF
argument_list|(
literal|"actlen=%d\n"
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|actlen
operator|!=
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
name|UAUDIO_HID_HAS_ID
operator|)
condition|)
block|{
name|id
operator|=
operator|*
name|buffer
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
name|actlen
operator|--
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|=
name|sc
operator|->
name|sc_mixer_dev
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
name|UAUDIO_HID_HAS_MUTE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|mute_id
operator|==
name|id
operator|)
operator|&&
name|hid_get_data
argument_list|(
name|buffer
argument_list|,
name|actlen
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|mute_loc
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Mute toggle\n"
argument_list|)
expr_stmt|;
name|mixer_hwvol_mute_locked
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
name|UAUDIO_HID_HAS_VOLUME_UP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|volume_up_id
operator|==
name|id
operator|)
operator|&&
name|hid_get_data
argument_list|(
name|buffer
argument_list|,
name|actlen
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|volume_up_loc
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Volume Up\n"
argument_list|)
expr_stmt|;
name|mixer_hwvol_step_locked
argument_list|(
name|m
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
name|UAUDIO_HID_HAS_VOLUME_DOWN
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|volume_down_id
operator|==
name|id
operator|)
operator|&&
name|hid_get_data
argument_list|(
name|buffer
argument_list|,
name|actlen
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|volume_down_loc
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Volume Down\n"
argument_list|)
expr_stmt|;
name|mixer_hwvol_step_locked
argument_list|(
name|m
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
comment|/* check if we can put more data into the FIFO */
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Error */
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* try to clear stall first */
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
goto|goto
name|tr_setup
goto|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|uaudio_hid_probe
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
name|void
modifier|*
name|d_ptr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint16_t
name|d_len
decl_stmt|;
name|uint8_t
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
name|UAUDIO_HID_VALID
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_mixer_lock
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Get HID descriptor */
name|error
operator|=
name|usbd_req_get_hid_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|NULL
argument_list|,
operator|&
name|d_ptr
argument_list|,
operator|&
name|d_len
argument_list|,
name|M_TEMP
argument_list|,
name|sc
operator|->
name|sc_hid
operator|.
name|iface_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"error reading report description\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* check if there is an ID byte */
name|hid_report_size
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
name|hid_input
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator||=
name|UAUDIO_HID_HAS_ID
expr_stmt|;
if|if
condition|(
name|hid_locate
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_CONSUMER
argument_list|,
literal|0xE9
comment|/* Volume Increment */
argument_list|)
argument_list|,
name|hid_input
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|volume_up_loc
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|volume_up_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HIO_VARIABLE
condition|)
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator||=
name|UAUDIO_HID_HAS_VOLUME_UP
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Found Volume Up key\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hid_locate
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_CONSUMER
argument_list|,
literal|0xEA
comment|/* Volume Decrement */
argument_list|)
argument_list|,
name|hid_input
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|volume_down_loc
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|volume_down_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HIO_VARIABLE
condition|)
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator||=
name|UAUDIO_HID_HAS_VOLUME_DOWN
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Found Volume Down key\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hid_locate
argument_list|(
name|d_ptr
argument_list|,
name|d_len
argument_list|,
name|HID_USAGE2
argument_list|(
name|HUP_CONSUMER
argument_list|,
literal|0xE2
comment|/* Mute */
argument_list|)
argument_list|,
name|hid_input
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|mute_loc
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|mute_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HIO_VARIABLE
condition|)
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator||=
name|UAUDIO_HID_HAS_MUTE
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Found Mute key\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|d_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_hid
operator|.
name|flags
operator|&
operator|(
name|UAUDIO_HID_HAS_VOLUME_UP
operator||
name|UAUDIO_HID_HAS_VOLUME_DOWN
operator||
name|UAUDIO_HID_HAS_MUTE
operator|)
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
literal|"Did not find any volume related keys\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* prevent the uhid driver from attaching */
name|usbd_set_parent_iface
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|sc
operator|->
name|sc_hid
operator|.
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_mixer_iface_index
argument_list|)
expr_stmt|;
comment|/* allocate USB transfers */
name|error
operator|=
name|usbd_transfer_setup
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|sc
operator|->
name|sc_hid
operator|.
name|iface_index
argument_list|,
name|sc
operator|->
name|sc_hid
operator|.
name|xfer
argument_list|,
name|uaudio_hid_config
argument_list|,
name|UAUDIO_HID_N_TRANSFER
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_mixer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"error=%s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uaudio_hid_detach
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|)
block|{
name|usbd_transfer_unsetup
argument_list|(
name|sc
operator|->
name|sc_hid
operator|.
name|xfer
argument_list|,
name|UAUDIO_HID_N_TRANSFER
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE_ORDERED
argument_list|(
name|uaudio
argument_list|,
name|uhub
argument_list|,
name|uaudio_driver
argument_list|,
name|uaudio_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uaudio
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|uaudio
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|uaudio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

