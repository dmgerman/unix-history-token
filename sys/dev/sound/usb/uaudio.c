begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: uaudio.c,v 1.41 2001/01/23 14:04:13 augustss Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$: */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (lennart@augustsson.net) at  * Carlstedt Research& Technology.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * USB audio specs: http://www.usb.org/developers/data/devclass/audio10.pdf  *                  http://www.usb.org/developers/data/devclass/frmts10.pdf  *                  http://www.usb.org/developers/data/devclass/termt10.pdf  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_comment
comment|/* for bootverbose */
end_comment

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/audioio.h>
end_include

begin_include
include|#
directive|include
file|<dev/audio_if.h>
end_include

begin_include
include|#
directive|include
file|<dev/mulaw.h>
end_include

begin_include
include|#
directive|include
file|<dev/auconv.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_comment
comment|/* XXXXX */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudioreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USB_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (uaudiodebug) logprintf x
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (uaudiodebug>(n)) logprintf x
end_define

begin_decl_stmt
name|int
name|uaudiodebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_usb
argument_list|,
name|OID_AUTO
argument_list|,
name|uaudio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"USB uaudio"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_usb_uaudio
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uaudiodebug
argument_list|,
literal|0
argument_list|,
literal|"uaudio debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTFN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UAUDIO_NCHANBUFS
value|6
end_define

begin_comment
comment|/* number of outstanding request */
end_comment

begin_define
define|#
directive|define
name|UAUDIO_NFRAMES
value|20
end_define

begin_comment
comment|/* ms of sound in each request */
end_comment

begin_define
define|#
directive|define
name|MIX_MAX_CHAN
value|8
end_define

begin_struct
struct|struct
name|mixerctl
block|{
name|u_int16_t
name|wValue
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
comment|/* using nchan */
name|u_int16_t
name|wIndex
decl_stmt|;
name|u_int8_t
name|nchan
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|;
define|#
directive|define
name|MIX_ON_OFF
value|1
define|#
directive|define
name|MIX_SIGNED_16
value|2
define|#
directive|define
name|MIX_UNSIGNED_16
value|3
define|#
directive|define
name|MIX_SIGNED_8
value|4
define|#
directive|define
name|MIX_SIZE
parameter_list|(
name|n
parameter_list|)
value|((n) == MIX_SIGNED_16 || (n) == MIX_UNSIGNED_16 ? 2 : 1)
define|#
directive|define
name|MIX_UNSIGNED
parameter_list|(
name|n
parameter_list|)
value|((n) == MIX_UNSIGNED_16)
name|int
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
name|u_int
name|delta
decl_stmt|;
name|u_int
name|mul
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXXXX */
name|unsigned
name|ctl
decl_stmt|;
else|#
directive|else
name|u_int8_t
name|class
decl_stmt|;
name|char
name|ctlname
index|[
name|MAX_AUDIO_DEV_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ctlunit
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAKE
parameter_list|(
name|h
parameter_list|,
name|l
parameter_list|)
value|(((h)<< 8) | (l))
end_define

begin_struct
struct|struct
name|as_info
block|{
name|u_int8_t
name|alt
decl_stmt|;
name|u_int8_t
name|encoding
decl_stmt|;
name|usbd_interface_handle
name|ifaceh
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|idesc
decl_stmt|;
name|usb_endpoint_descriptor_audio_t
modifier|*
name|edesc
decl_stmt|;
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|asf1desc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|chan
block|{
name|int
name|terminal
decl_stmt|;
comment|/* terminal id */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* dma completion intr handler */
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* arg for intr() */
else|#
directive|else
name|struct
name|pcm_channel
modifier|*
name|pcm_ch
decl_stmt|;
endif|#
directive|endif
name|usbd_pipe_handle
name|pipe
decl_stmt|;
name|int
name|dir
decl_stmt|;
comment|/* direction */
name|u_int
name|sample_size
decl_stmt|;
name|u_int
name|sample_rate
decl_stmt|;
name|u_int
name|bytes_per_frame
decl_stmt|;
name|u_int
name|fraction
decl_stmt|;
comment|/* fraction/1000 is the extra samples/frame */
name|u_int
name|residue
decl_stmt|;
comment|/* accumulates the fractional samples */
name|u_char
modifier|*
name|start
decl_stmt|;
comment|/* upper layer buffer start */
name|u_char
modifier|*
name|end
decl_stmt|;
comment|/* upper layer buffer end */
name|u_char
modifier|*
name|cur
decl_stmt|;
comment|/* current position in upper layer buffer */
name|int
name|blksize
decl_stmt|;
comment|/* chunk size to report up */
name|int
name|transferred
decl_stmt|;
comment|/* transferred bytes not reported up */
name|char
name|nofrac
decl_stmt|;
comment|/* don't do sample rate adjustment */
name|int
name|curchanbuf
decl_stmt|;
struct|struct
name|chanbuf
block|{
name|struct
name|chan
modifier|*
name|chan
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|u_int16_t
name|sizes
index|[
name|UAUDIO_NFRAMES
index|]
decl_stmt|;
name|u_int16_t
name|size
decl_stmt|;
block|}
name|chanbufs
index|[
name|UAUDIO_NCHANBUFS
index|]
struct|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
comment|/* our softc */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|u_int32_t
name|format
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|int
name|channels
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uaudio_softc
block|{
name|USBBASEDEVICE
name|sc_dev
decl_stmt|;
comment|/* base device */
name|usbd_device_handle
name|sc_udev
decl_stmt|;
comment|/* USB device */
name|char
name|sc_dead
decl_stmt|;
comment|/* The device is dead -- kill it */
name|int
name|sc_ac_iface
decl_stmt|;
comment|/* Audio Control interface */
name|usbd_interface_handle
name|sc_ac_ifaceh
decl_stmt|;
name|struct
name|chan
name|sc_chan
decl_stmt|;
name|int
name|sc_curaltidx
decl_stmt|;
name|int
name|sc_nullalt
decl_stmt|;
name|int
name|sc_audio_rev
decl_stmt|;
name|struct
name|as_info
modifier|*
name|sc_alts
decl_stmt|;
name|int
name|sc_nalts
decl_stmt|;
name|int
name|sc_props
decl_stmt|;
name|int
name|sc_altflags
decl_stmt|;
define|#
directive|define
name|HAS_8
value|0x01
define|#
directive|define
name|HAS_16
value|0x02
define|#
directive|define
name|HAS_8U
value|0x04
define|#
directive|define
name|HAS_ALAW
value|0x08
define|#
directive|define
name|HAS_MULAW
value|0x10
name|struct
name|mixerctl
modifier|*
name|sc_ctls
decl_stmt|;
name|int
name|sc_nctls
decl_stmt|;
name|device_ptr_t
name|sc_audiodev
decl_stmt|;
name|char
name|sc_dying
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UAC_OUTPUT
value|0
end_define

begin_define
define|#
directive|define
name|UAC_INPUT
value|1
end_define

begin_define
define|#
directive|define
name|UAC_EQUAL
value|2
end_define

begin_function_decl
name|Static
name|usbd_status
name|uaudio_identify_ac
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|uaudio_identify_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|uaudio_process_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|offsp
parameter_list|,
name|int
name|size
parameter_list|,
name|usb_interface_descriptor_t
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_alt
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|as_info
modifier|*
name|ai
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usb_interface_descriptor_t
modifier|*
name|uaudio_find_iface
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|offsp
parameter_list|,
name|int
name|subtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|char
modifier|*
name|uaudio_id_name
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|struct
name|usb_audio_cluster
name|uaudio_get_cluster
parameter_list|(
name|int
name|id
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_input
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_output
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|uaudio_identify
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_signext
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|int
name|uaudio_value2bsd
parameter_list|(
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|int
name|uaudio_bsd2value
parameter_list|(
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|wValue
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|int
name|uaudio_ctl_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|void
name|uaudio_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|wValue
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|uaudio_set_speed
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|uaudio_chan_open
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_chan_close
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|usbd_status
name|uaudio_chan_alloc_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_chan_free_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
parameter_list|,
name|struct
name|chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|void
name|uaudio_chan_set_param
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|,
name|struct
name|audio_params
modifier|*
name|param
parameter_list|,
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|Static
name|void
name|uaudio_chan_ptransfer
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_chan_pintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_chan_rtransfer
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_chan_rintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function_decl
name|Static
name|int
name|uaudio_open
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_close
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_drain
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_query_encoding
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|audio_encoding
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_set_params
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_round_blocksize
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_trigger_output
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_trigger_input
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|audio_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_halt_in_dma
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_halt_out_dma
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_getdev
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|audio_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_mixer_set_port
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mixer_ctrl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_mixer_get_port
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mixer_ctrl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_query_devinfo
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mixer_devinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|int
name|uaudio_get_props
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|Static
name|struct
name|audio_hw_if
name|uaudio_hw_if
init|=
block|{
name|uaudio_open
block|,
name|uaudio_close
block|,
name|uaudio_drain
block|,
name|uaudio_query_encoding
block|,
name|uaudio_set_params
block|,
name|uaudio_round_blocksize
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|uaudio_halt_out_dma
block|,
name|uaudio_halt_in_dma
block|,
name|NULL
block|,
name|uaudio_getdev
block|,
name|NULL
block|,
name|uaudio_mixer_set_port
block|,
name|uaudio_mixer_get_port
block|,
name|uaudio_query_devinfo
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|uaudio_get_props
block|,
name|uaudio_trigger_output
block|,
name|uaudio_trigger_input
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|audio_device
name|uaudio_device
init|=
block|{
literal|"USB audio"
block|,
literal|""
block|,
literal|"uaudio"
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_function_decl
name|Static
name|int
name|audio_attach_mi
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Static
name|void
name|uaudio_init_params
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* for NetBSD compatibirity */
end_comment

begin_define
define|#
directive|define
name|AUMODE_PLAY
value|0x01
end_define

begin_define
define|#
directive|define
name|AUMODE_RECORD
value|0x02
end_define

begin_define
define|#
directive|define
name|AUDIO_PROP_FULLDUPLEX
value|0x01
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ULAW
value|1
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ALAW
value|2
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_SLINEAR_LE
value|6
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_SLINEAR_BE
value|7
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ULINEAR_LE
value|8
end_define

begin_define
define|#
directive|define
name|AUDIO_ENCODING_ULINEAR_BE
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_expr_stmt
name|USB_DECLARE_DRIVER
argument_list|(
name|uaudio
argument_list|)
expr_stmt|;
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_expr_stmt
name|USB_DECLARE_DRIVER_INIT
argument_list|(
name|uaudio
argument_list|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
argument_list|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
argument_list|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
argument_list|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|USB_MATCH
argument_list|(
argument|uaudio
argument_list|)
end_macro

begin_block
block|{
name|USB_MATCH_START
argument_list|(
name|uaudio
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|iface
operator|==
name|NULL
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|iface
argument_list|)
expr_stmt|;
comment|/* Trigger on the control interface. */
if|if
condition|(
name|id
operator|==
name|NULL
operator|||
name|id
operator|->
name|bInterfaceClass
operator|!=
name|UICLASS_AUDIO
operator|||
name|id
operator|->
name|bInterfaceSubClass
operator|!=
name|UISUBCLASS_AUDIOCONTROL
operator|||
operator|(
name|usbd_get_quirks
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_BAD_AUDIO
operator|)
condition|)
return|return
operator|(
name|UMATCH_NONE
operator|)
return|;
return|return
operator|(
name|UMATCH_IFACECLASS_IFACESUBCLASS
operator|)
return|;
block|}
end_block

begin_macro
name|USB_ATTACH
argument_list|(
argument|uaudio
argument_list|)
end_macro

begin_block
block|{
name|USB_ATTACH_START
argument_list|(
name|uaudio
argument_list|,
name|sc
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|cdesc
decl_stmt|;
name|char
name|devinfo
index|[
literal|1024
index|]
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|found
decl_stmt|;
name|usbd_devinfo
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|USB_ATTACH_SETUP
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printf
argument_list|(
literal|": %s\n"
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|cdesc
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to get configuration descriptor\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|err
operator|=
name|uaudio_identify
argument_list|(
name|sc
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"%s: audio descriptors make no sense, error=%d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ac_ifaceh
operator|=
name|uaa
operator|->
name|iface
expr_stmt|;
comment|/* Pick up the AS interface. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uaa
operator|->
name|nifaces
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|id
operator|=
name|usbd_get_interface_descriptor
argument_list|(
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
continue|continue;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|->
name|bInterfaceNumber
operator|==
name|sc
operator|->
name|sc_alts
index|[
name|j
index|]
operator|.
name|idesc
operator|->
name|bInterfaceNumber
condition|)
block|{
name|sc
operator|->
name|sc_alts
index|[
name|j
index|]
operator|.
name|ifaceh
operator|=
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|uaa
operator|->
name|ifaces
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_alts
index|[
name|j
index|]
operator|.
name|ifaceh
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: alt %d missing AS interface(s)\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s: audio rev %d.%02x\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|>>
literal|8
argument_list|,
name|sc
operator|->
name|sc_audio_rev
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_AU_NO_FRAC
condition|)
name|sc
operator|->
name|sc_chan
operator|.
name|nofrac
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|USB_DEBUG
if|if
condition|(
name|bootverbose
condition|)
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s: %d mixer controls\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_nctls
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_ATTACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_attach: doing audio_attach_mi\n"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|audio_attach_mi
argument_list|(
operator|&
name|uaudio_hw_if
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|sc
operator|->
name|sc_audiodev
operator|=
name|audio_attach_mi
argument_list|(
operator|&
name|uaudio_hw_if
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|->
name|sc_dying
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|audio_attach_mi
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"audio_attach_mi failed\n"
argument_list|)
expr_stmt|;
name|USB_ATTACH_ERROR_RETURN
expr_stmt|;
block|}
endif|#
directive|endif
name|USB_ATTACH_SUCCESS_RETURN
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_activate
parameter_list|(
name|device_ptr_t
name|self
parameter_list|,
name|enum
name|devact
name|act
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|uaudio_softc
operator|*
operator|)
name|self
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DVACT_ACTIVATE
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
case|case
name|DVACT_DEACTIVATE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_audiodev
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_deactivate
argument_list|(
name|sc
operator|->
name|sc_audiodev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_detach
parameter_list|(
name|device_ptr_t
name|self
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|uaudio_softc
operator|*
operator|)
name|self
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* Wait for outstanding requests to complete. */
name|usbd_delay_ms
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|UAUDIO_NCHANBUFS
operator|*
name|UAUDIO_NFRAMES
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_audiodev
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|config_detach
argument_list|(
name|sc
operator|->
name|sc_audiodev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|usbd_add_drv_event
argument_list|(
name|USB_EVENT_DRIVER_DETACH
argument_list|,
name|sc
operator|->
name|sc_udev
argument_list|,
name|USBDEV
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_macro
name|USB_DETACH
argument_list|(
argument|uaudio
argument_list|)
end_macro

begin_block
block|{
name|USB_DETACH_START
argument_list|(
name|uaudio
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dying
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
comment|/* Wait for outstanding requests to complete. */
block|usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
endif|#
directive|endif
comment|/* do nothing ? */
return|return
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_query_encoding
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|audio_encoding
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|int
name|flags
init|=
name|sc
operator|->
name|sc_altflags
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_nalts
operator|==
literal|0
operator|||
name|flags
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|idx
operator|=
name|fp
operator|->
name|index
expr_stmt|;
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
literal|0
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEulinear
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULINEAR
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_8U
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEmulaw
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_MULAW
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEalaw
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ALAW
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_ALAW
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEslinear
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_SLINEAR
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|flags
operator|&
name|HAS_8
condition|?
literal|0
else|:
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEslinear_le
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|5
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEulinear_le
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|6
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEslinear_be
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_SLINEAR_BE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|7
case|:
name|strcpy
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|AudioEulinear_be
argument_list|)
expr_stmt|;
name|fp
operator|->
name|encoding
operator|=
name|AUDIO_ENCODING_ULINEAR_BE
expr_stmt|;
name|fp
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|fp
operator|->
name|flags
operator|=
name|AUDIO_ENCODINGFLAG_EMULATED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|usb_interface_descriptor_t
modifier|*
name|uaudio_find_iface
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|offsp
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
name|usb_interface_descriptor_t
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|offsp
operator|<
name|size
condition|)
block|{
name|d
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
operator|*
name|offsp
operator|)
expr_stmt|;
operator|*
name|offsp
operator|+=
name|d
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|&&
name|d
operator|->
name|bInterfaceClass
operator|==
name|UICLASS_AUDIO
operator|&&
name|d
operator|->
name|bInterfaceSubClass
operator|==
name|subtype
condition|)
return|return
operator|(
name|d
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_mixer_add_ctl
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|mc
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|sc_nctls
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|nmc
init|=
name|sc
operator|->
name|sc_nctls
operator|==
literal|0
condition|?
name|malloc
argument_list|(
name|len
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
else|:
name|realloc
argument_list|(
name|sc
operator|->
name|sc_ctls
argument_list|,
name|len
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|nmc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_mixer_add_ctl: no memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_ctls
operator|=
name|nmc
expr_stmt|;
name|mc
operator|->
name|delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|!=
name|MIX_ON_OFF
condition|)
block|{
comment|/* Determine min and max values. */
name|mc
operator|->
name|minval
operator|=
name|uaudio_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|GET_MIN
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
operator|+
name|uaudio_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|GET_MAX
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mul
operator|=
name|mc
operator|->
name|maxval
operator|-
name|mc
operator|->
name|minval
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mul
operator|==
literal|0
condition|)
name|mc
operator|->
name|mul
operator|=
literal|1
expr_stmt|;
name|res
operator|=
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|GET_RES
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
name|mc
operator|->
name|delta
operator|=
operator|(
name|res
operator|*
literal|256
operator|+
name|mc
operator|->
name|mul
operator|/
literal|2
operator|)
operator|/
name|mc
operator|->
name|mul
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|->
name|minval
operator|=
literal|0
expr_stmt|;
name|mc
operator|->
name|maxval
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ctls
index|[
name|sc
operator|->
name|sc_nctls
operator|++
index|]
operator|=
operator|*
name|mc
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudiodebug
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_mixer_add_ctl: wValue=%04x"
operator|,
name|mc
operator|->
name|wValue
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|DPRINTF
argument_list|(
operator|(
literal|",%04x"
operator|,
name|mc
operator|->
name|wValue
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|DPRINTF
argument_list|(
operator|(
literal|" wIndex=%04x type=%d ctl='%d' "
literal|"min=%d max=%d\n"
operator|,
name|mc
operator|->
name|wIndex
operator|,
name|mc
operator|->
name|type
operator|,
name|mc
operator|->
name|ctl
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DPRINTF
argument_list|(
operator|(
literal|" wIndex=%04x type=%d name='%s' unit='%s' "
literal|"min=%d max=%d\n"
operator|,
name|mc
operator|->
name|wIndex
operator|,
name|mc
operator|->
name|type
operator|,
name|mc
operator|->
name|ctlname
operator|,
name|mc
operator|->
name|ctlunit
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|char
modifier|*
name|uaudio_id_name
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|,
name|int
name|id
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|usb_audio_cluster
name|uaudio_get_cluster
parameter_list|(
name|int
name|id
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
name|struct
name|usb_audio_cluster
name|r
decl_stmt|;
name|usb_descriptor_t
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* avoid infinite loops */
name|dp
operator|=
name|dps
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_INPUT
case|:
define|#
directive|define
name|p
value|((struct usb_audio_input_terminal *)dp)
name|r
operator|.
name|bNrChannels
operator|=
name|p
operator|->
name|bNrChannels
expr_stmt|;
name|USETW
argument_list|(
name|r
operator|.
name|wChannelConfig
argument_list|,
name|UGETW
argument_list|(
name|p
operator|->
name|wChannelConfig
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|.
name|iChannelNames
operator|=
name|p
operator|->
name|iChannelNames
expr_stmt|;
undef|#
directive|undef
name|p
return|return
operator|(
name|r
operator|)
return|;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
define|#
directive|define
name|p
value|((struct usb_audio_output_terminal *)dp)
name|id
operator|=
name|p
operator|->
name|bSourceId
expr_stmt|;
undef|#
directive|undef
name|p
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
define|#
directive|define
name|p
value|((struct usb_audio_mixer_unit *)dp)
name|r
operator|=
operator|*
operator|(
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|p
operator|->
name|baSourceId
index|[
name|p
operator|->
name|bNrInPins
index|]
expr_stmt|;
undef|#
directive|undef
name|p
return|return
operator|(
name|r
operator|)
return|;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
comment|/* XXX This is not really right */
define|#
directive|define
name|p
value|((struct usb_audio_selector_unit *)dp)
name|id
operator|=
name|p
operator|->
name|baSourceId
index|[
literal|0
index|]
expr_stmt|;
undef|#
directive|undef
name|p
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
define|#
directive|define
name|p
value|((struct usb_audio_feature_unit *)dp)
name|id
operator|=
name|p
operator|->
name|bSourceId
expr_stmt|;
undef|#
directive|undef
name|p
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
define|#
directive|define
name|p
value|((struct usb_audio_processing_unit *)dp)
name|r
operator|=
operator|*
operator|(
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|p
operator|->
name|baSourceId
index|[
name|p
operator|->
name|bNrInPins
index|]
expr_stmt|;
undef|#
directive|undef
name|p
return|return
operator|(
name|r
operator|)
return|;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
define|#
directive|define
name|p
value|((struct usb_audio_extension_unit *)dp)
name|r
operator|=
operator|*
operator|(
expr|struct
name|usb_audio_cluster
operator|*
operator|)
operator|&
name|p
operator|->
name|baSourceId
index|[
name|p
operator|->
name|bNrInPins
index|]
expr_stmt|;
undef|#
directive|undef
name|p
return|return
operator|(
name|r
operator|)
return|;
default|default:
goto|goto
name|bad
goto|;
block|}
block|}
name|bad
label|:
name|printf
argument_list|(
literal|"uaudio_get_cluster: bad data\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_add_input
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
name|struct
name|usb_audio_input_terminal
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_input_terminal
operator|*
operator|)
name|v
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x "
literal|"bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d "
literal|"iChannelNames=%d iTerminal=%d\n"
operator|,
name|d
operator|->
name|bTerminalId
operator|,
name|UGETW
argument_list|(
name|d
operator|->
name|wTerminalType
argument_list|)
operator|,
name|d
operator|->
name|bAssocTerminal
operator|,
name|d
operator|->
name|bNrChannels
operator|,
name|UGETW
argument_list|(
name|d
operator|->
name|wChannelConfig
argument_list|)
operator|,
name|d
operator|->
name|iChannelNames
operator|,
name|d
operator|->
name|iTerminal
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|uaudio_add_output
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
name|struct
name|usb_audio_output_terminal
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_output_terminal
operator|*
operator|)
name|v
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x "
literal|"bAssocTerminal=%d bSourceId=%d iTerminal=%d\n"
operator|,
name|d
operator|->
name|bTerminalId
operator|,
name|UGETW
argument_list|(
name|d
operator|->
name|wTerminalType
argument_list|)
operator|,
name|d
operator|->
name|bAssocTerminal
operator|,
name|d
operator|->
name|bSourceId
operator|,
name|d
operator|->
name|iTerminal
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|uaudio_add_mixer
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
name|struct
name|usb_audio_mixer_unit
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_mixer_unit
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|usb_audio_mixer_unit_1
modifier|*
name|d1
decl_stmt|;
name|int
name|c
decl_stmt|,
name|chs
decl_stmt|,
name|ichs
decl_stmt|,
name|ochs
decl_stmt|,
name|i
decl_stmt|,
name|o
decl_stmt|,
name|bno
decl_stmt|,
name|p
decl_stmt|,
name|mo
decl_stmt|,
name|mc
decl_stmt|,
name|k
decl_stmt|;
name|uByte
modifier|*
name|bm
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_mixer: bUnitId=%d bNrInPins=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
comment|/* Compute the number of input channels */
name|ichs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
name|ichs
operator|+=
name|uaudio_get_cluster
argument_list|(
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|dps
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
comment|/* and the number of output channels */
name|d1
operator|=
operator|(
expr|struct
name|usb_audio_mixer_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
expr_stmt|;
name|ochs
operator|=
name|d1
operator|->
name|bNrChannels
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_mixer: ichs=%d ochs=%d\n"
operator|,
name|ichs
operator|,
name|ochs
operator|)
argument_list|)
expr_stmt|;
name|bm
operator|=
name|d1
operator|->
name|bmControls
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|class
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* XXXXX */
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNvolume
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|BIT
parameter_list|(
name|bno
parameter_list|)
value|((bm[bno / 8]>> (7 - bno % 8))& 1)
for|for
control|(
name|p
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|bNrInPins
condition|;
name|i
operator|++
control|)
block|{
name|chs
operator|=
name|uaudio_get_cluster
argument_list|(
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|,
name|dps
argument_list|)
operator|.
name|bNrChannels
expr_stmt|;
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
block|{
name|mo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT
argument_list|(
name|bno
argument_list|)
condition|)
name|mo
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mo
operator|==
literal|1
condition|)
name|mc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mc
operator|==
name|chs
operator|&&
name|chs
operator|<=
name|MIX_MAX_CHAN
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|chs
condition|;
name|c
operator|++
control|)
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|ochs
condition|;
name|o
operator|++
control|)
block|{
name|bno
operator|=
operator|(
name|p
operator|+
name|c
operator|)
operator|*
name|ochs
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|BIT
argument_list|(
name|bno
argument_list|)
condition|)
name|mix
operator|.
name|wValue
index|[
name|k
operator|++
index|]
operator|=
name|MAKE
argument_list|(
name|p
operator|+
name|c
operator|+
literal|1
argument_list|,
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"mix%d-%s"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|d
operator|->
name|baSourceId
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mix
operator|.
name|nchan
operator|=
name|chs
expr_stmt|;
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX */
block|}
undef|#
directive|undef
name|BIT
name|p
operator|+=
name|chs
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|uaudio_add_selector
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
name|struct
name|usb_audio_selector_unit
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_selector_unit
operator|*
operator|)
name|v
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_selector: bUnitId=%d bNrInPins=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"uaudio_add_selector: NOT IMPLEMENTED\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uaudio_add_feature
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
name|struct
name|usb_audio_feature_unit
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_feature_unit
operator|*
operator|)
name|v
decl_stmt|;
name|uByte
modifier|*
name|ctls
init|=
name|d
operator|->
name|bmaControls
decl_stmt|;
name|int
name|ctlsize
init|=
name|d
operator|->
name|bControlSize
decl_stmt|;
name|int
name|nchan
init|=
operator|(
name|d
operator|->
name|bLength
operator|-
literal|7
operator|)
operator|/
name|ctlsize
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|int
name|srcId
init|=
name|d
operator|->
name|bSourceId
decl_stmt|;
endif|#
directive|endif
name|u_int
name|fumask
decl_stmt|,
name|mmask
decl_stmt|,
name|cmask
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|ctl
decl_stmt|,
name|i
decl_stmt|,
name|unit
decl_stmt|;
define|#
directive|define
name|GET
parameter_list|(
name|i
parameter_list|)
value|(ctls[(i)*ctlsize] | \ 		(ctlsize> 1 ? ctls[(i)*ctlsize+1]<< 8 : 0))
name|mmask
operator|=
name|GET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Figure out what we can control */
for|for
control|(
name|cmask
operator|=
literal|0
operator|,
name|chan
operator|=
literal|1
init|;
name|chan
operator|<
name|nchan
condition|;
name|chan
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|9
argument_list|,
operator|(
literal|"uaudio_add_feature: chan=%d mask=%x\n"
operator|,
name|chan
operator|,
name|GET
argument_list|(
name|chan
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cmask
operator||=
name|GET
argument_list|(
name|chan
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uaudio_add_feature: bUnitId=%d bSourceId=%d, "
literal|"%d channels, mmask=0x%04x, cmask=0x%04x\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|srcId
operator|,
name|nchan
operator|,
name|mmask
operator|,
name|cmask
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nchan
operator|>
name|MIX_MAX_CHAN
condition|)
name|nchan
operator|=
name|MIX_MAX_CHAN
expr_stmt|;
name|unit
operator|=
name|d
operator|->
name|bUnitId
expr_stmt|;
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|unit
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
for|for
control|(
name|ctl
operator|=
name|MUTE_CONTROL
init|;
name|ctl
operator|<
name|LOUDNESS_CONTROL
condition|;
name|ctl
operator|++
control|)
block|{
name|fumask
operator|=
name|FU_MASK
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|4
argument_list|,
operator|(
literal|"uaudio_add_feature: ctl=%d fumask=0x%04x\n"
operator|,
name|ctl
operator|,
name|fumask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmask
operator|&
name|fumask
condition|)
block|{
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmask
operator|&
name|fumask
condition|)
block|{
name|mix
operator|.
name|nchan
operator|=
name|nchan
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|i
argument_list|)
operator|&
name|fumask
condition|)
name|mix
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MAKE
argument_list|(
name|ctl
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|mix
operator|.
name|wValue
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
undef|#
directive|undef
name|GET
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|class
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|MUTE_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNmute
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|VOLUME_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_16
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* mix.ctl = SOUND_MIXER_VOLUME; */
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_PCM
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNmaster
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNvolume
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|BASS_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_BASS
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNbass
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNbass
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MID_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNmid
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNmid
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TREBLE_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_SIGNED_8
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_TREBLE
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNtreble
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
name|AudioNtreble
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GRAPHIC_EQUALIZER_CONTROL
case|:
continue|continue;
comment|/* XXX don't add anything */
break|break;
case|case
name|AGC_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNagc
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DELAY_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_UNSIGNED_16
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNdelay
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
literal|"4 ms"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|BASS_BOOST_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_NRDEVICES
expr_stmt|;
comment|/* XXXXX */
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNbassboost
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LOUDNESS_CONTROL
case|:
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctl
operator|=
name|SOUND_MIXER_LOUD
expr_stmt|;
comment|/* Is this correct ? */
else|#
directive|else
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"fea%d-%s-%s"
argument_list|,
name|unit
argument_list|,
name|uaudio_id_name
argument_list|(
name|sc
argument_list|,
name|dps
argument_list|,
name|srcId
argument_list|)
argument_list|,
name|AudioNloudness
argument_list|)
expr_stmt|;
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|uaudio_add_processing_updown
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
name|struct
name|usb_audio_processing_unit
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_processing_unit
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|d1
init|=
operator|(
expr|struct
name|usb_audio_processing_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
decl_stmt|;
name|struct
name|usb_audio_processing_unit_updown
modifier|*
name|ud
init|=
operator|(
expr|struct
name|usb_audio_processing_unit_updown
operator|*
operator|)
operator|&
name|d1
operator|->
name|bmControls
index|[
name|d1
operator|->
name|bControlSize
index|]
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|ud
operator|->
name|bNrModes
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_MASK
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_add_processing_updown: no mode select\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|UD_MODE_SELECT_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|class
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
comment|/* XXX */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"pro%d-mode"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|->
name|bNrModes
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_processing_updown: i=%d bm=0x%x\n"
operator|,
name|i
operator|,
name|UGETW
argument_list|(
name|ud
operator|->
name|waModes
index|[
name|i
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uaudio_add_processing
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
name|struct
name|usb_audio_processing_unit
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_processing_unit
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|usb_audio_processing_unit_1
modifier|*
name|d1
init|=
operator|(
expr|struct
name|usb_audio_processing_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
decl_stmt|;
name|int
name|ptype
init|=
name|UGETW
argument_list|(
name|d
operator|->
name|wProcessType
argument_list|)
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_processing: wProcessType=%d bUnitId=%d "
literal|"bNrInPins=%d\n"
operator|,
name|ptype
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_PROC_ENABLE_MASK
condition|)
block|{
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|XX_ENABLE_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|class
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"pro%d.%d-enable"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|UPDOWNMIX_PROCESS
case|:
name|uaudio_add_processing_updown
argument_list|(
name|sc
argument_list|,
name|v
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOLBY_PROLOGIC_PROCESS
case|:
case|case
name|P3D_STEREO_EXTENDER_PROCESS
case|:
case|case
name|REVERBATION_PROCESS
case|:
case|case
name|CHORUS_PROCESS
case|:
case|case
name|DYN_RANGE_COMP_PROCESS
case|:
default|default:
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"uaudio_add_processing: unit %d, type=%d not impl.\n"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_function
name|void
name|uaudio_add_extension
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_descriptor_t
modifier|*
name|v
parameter_list|,
name|usb_descriptor_t
modifier|*
modifier|*
name|dps
parameter_list|)
block|{
name|struct
name|usb_audio_extension_unit
modifier|*
name|d
init|=
operator|(
expr|struct
name|usb_audio_extension_unit
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|usb_audio_extension_unit_1
modifier|*
name|d1
init|=
operator|(
expr|struct
name|usb_audio_extension_unit_1
operator|*
operator|)
operator|&
name|d
operator|->
name|baSourceId
index|[
name|d
operator|->
name|bNrInPins
index|]
decl_stmt|;
name|struct
name|mixerctl
name|mix
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_extension: bUnitId=%d bNrInPins=%d\n"
operator|,
name|d
operator|->
name|bUnitId
operator|,
name|d
operator|->
name|bNrInPins
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_AU_NO_XU
condition|)
return|return;
if|if
condition|(
name|d1
operator|->
name|bmControls
index|[
literal|0
index|]
operator|&
name|UA_EXT_ENABLE_MASK
condition|)
block|{
name|mix
operator|.
name|wIndex
operator|=
name|MAKE
argument_list|(
name|d
operator|->
name|bUnitId
argument_list|,
name|sc
operator|->
name|sc_ac_iface
argument_list|)
expr_stmt|;
name|mix
operator|.
name|nchan
operator|=
literal|1
expr_stmt|;
name|mix
operator|.
name|wValue
index|[
literal|0
index|]
operator|=
name|MAKE
argument_list|(
name|UA_EXT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|class
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|mix
operator|.
name|type
operator|=
name|MIX_ON_OFF
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mix
operator|.
name|ctlunit
operator|=
literal|""
expr_stmt|;
name|sprintf
argument_list|(
name|mix
operator|.
name|ctlname
argument_list|,
literal|"ext%d-enable"
argument_list|,
name|d
operator|->
name|bUnitId
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uaudio_mixer_add_ctl
argument_list|(
name|sc
argument_list|,
operator|&
name|mix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|usbd_status
name|uaudio_identify
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
block|{
name|usbd_status
name|err
decl_stmt|;
name|err
operator|=
name|uaudio_identify_ac
argument_list|(
name|sc
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|uaudio_identify_as
argument_list|(
name|sc
argument_list|,
name|cdesc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_add_alt
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|as_info
modifier|*
name|ai
parameter_list|)
block|{
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|sc_nalts
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|as_info
modifier|*
name|nai
init|=
name|sc
operator|->
name|sc_nalts
operator|==
literal|0
condition|?
name|malloc
argument_list|(
name|len
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
else|:
name|realloc
argument_list|(
name|sc
operator|->
name|sc_alts
argument_list|,
name|len
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|nai
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_add_alt: no memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_alts
operator|=
name|nai
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_add_alt: adding alt=%d, enc=%d\n"
operator|,
name|ai
operator|->
name|alt
operator|,
name|ai
operator|->
name|encoding
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_nalts
operator|++
index|]
operator|=
operator|*
name|ai
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uaudio_process_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|offsp
parameter_list|,
name|int
name|size
parameter_list|,
name|usb_interface_descriptor_t
modifier|*
name|id
parameter_list|)
define|#
directive|define
name|offs
value|(*offsp)
block|{
name|struct
name|usb_audio_streaming_interface_descriptor
modifier|*
name|asid
decl_stmt|;
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|asf1d
decl_stmt|;
name|usb_endpoint_descriptor_audio_t
modifier|*
name|ed
decl_stmt|;
name|struct
name|usb_audio_streaming_endpoint_descriptor
modifier|*
name|sed
decl_stmt|;
name|int
name|format
decl_stmt|,
name|chan
decl_stmt|,
name|prec
decl_stmt|,
name|enc
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|as_info
name|ai
decl_stmt|;
name|asid
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|asid
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|||
name|asid
operator|->
name|bDescriptorSubtype
operator|!=
name|AS_GENERAL
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|offs
operator|+=
name|asid
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|asf1d
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|asf1d
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|||
name|asf1d
operator|->
name|bDescriptorSubtype
operator|!=
name|FORMAT_TYPE
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|offs
operator|+=
name|asf1d
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
if|if
condition|(
name|asf1d
operator|->
name|bFormatType
operator|!=
name|FORMAT_TYPE_I
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ignored setting with type %d format\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|UGETW
argument_list|(
name|asid
operator|->
name|wFormatTag
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|ed
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|ed
operator|->
name|bDescriptorType
operator|!=
name|UDESC_ENDPOINT
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_process_as: endpoint bLength=%d bDescriptorType=%d "
literal|"bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d "
literal|"bInterval=%d bRefresh=%d bSynchAddress=%d\n"
operator|,
name|ed
operator|->
name|bLength
operator|,
name|ed
operator|->
name|bDescriptorType
operator|,
name|ed
operator|->
name|bEndpointAddress
operator|,
name|ed
operator|->
name|bmAttributes
operator|,
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
operator|,
name|ed
operator|->
name|bInterval
operator|,
name|ed
operator|->
name|bRefresh
operator|,
name|ed
operator|->
name|bSynchAddress
operator|)
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|ed
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
operator|!=
name|UE_ISOCHRONOUS
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|ed
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
name|type
operator|=
name|UE_GET_ISO_TYPE
argument_list|(
name|ed
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_AU_INP_ASYNC
operator|)
operator|&&
name|dir
operator|==
name|UE_DIR_IN
operator|&&
name|type
operator|==
name|UE_ISO_ADAPT
condition|)
name|type
operator|=
name|UE_ISO_ASYNC
expr_stmt|;
comment|/* We can't handle endpoints that need a sync pipe yet. */
if|if
condition|(
name|dir
operator|==
name|UE_DIR_IN
condition|?
name|type
operator|==
name|UE_ISO_ADAPT
else|:
name|type
operator|==
name|UE_ISO_ASYNC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ignored %sput endpoint of type %s\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|dir
operator|==
name|UE_DIR_IN
condition|?
literal|"in"
else|:
literal|"out"
argument_list|,
name|dir
operator|==
name|UE_DIR_IN
condition|?
literal|"adaptive"
else|:
literal|"async"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|sed
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|sed
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_ENDPOINT
operator|||
name|sed
operator|->
name|bDescriptorSubtype
operator|!=
name|AS_GENERAL
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|offs
operator|+=
name|sed
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|format
operator|=
name|UGETW
argument_list|(
name|asid
operator|->
name|wFormatTag
argument_list|)
expr_stmt|;
name|chan
operator|=
name|asf1d
operator|->
name|bNrChannels
expr_stmt|;
name|prec
operator|=
name|asf1d
operator|->
name|bBitResolution
expr_stmt|;
if|if
condition|(
name|prec
operator|!=
literal|8
operator|&&
name|prec
operator|!=
literal|16
condition|)
block|{
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"%s: ignored setting with precision %d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|prec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|UA_FMT_PCM
case|:
name|sc
operator|->
name|sc_altflags
operator||=
name|prec
operator|==
literal|8
condition|?
name|HAS_8
else|:
name|HAS_16
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
break|break;
case|case
name|UA_FMT_PCM8
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_8U
expr_stmt|;
break|break;
case|case
name|UA_FMT_ALAW
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ALAW
expr_stmt|;
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_ALAW
expr_stmt|;
break|break;
case|case
name|UA_FMT_MULAW
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|sc
operator|->
name|sc_altflags
operator||=
name|HAS_MULAW
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: ignored setting with format %d\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uaudio_identify: alt=%d enc=%d chan=%d prec=%d\n"
operator|,
name|id
operator|->
name|bAlternateSetting
operator|,
name|enc
operator|,
name|chan
operator|,
name|prec
operator|)
argument_list|)
expr_stmt|;
name|ai
operator|.
name|alt
operator|=
name|id
operator|->
name|bAlternateSetting
expr_stmt|;
name|ai
operator|.
name|encoding
operator|=
name|enc
expr_stmt|;
name|ai
operator|.
name|idesc
operator|=
name|id
expr_stmt|;
name|ai
operator|.
name|edesc
operator|=
name|ed
expr_stmt|;
name|ai
operator|.
name|asf1desc
operator|=
name|asf1d
expr_stmt|;
name|uaudio_add_alt
argument_list|(
name|sc
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|terminal
operator|=
name|asid
operator|->
name|bTerminalLink
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|sc_chan
operator|.
name|dir
operator||=
name|dir
operator|==
name|UE_DIR_OUT
condition|?
name|AUMODE_PLAY
else|:
name|AUMODE_RECORD
expr_stmt|;
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|offs
end_undef

begin_function
name|usbd_status
name|uaudio_identify_as
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
block|{
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offs
decl_stmt|;
name|size
operator|=
name|UGETW
argument_list|(
name|cdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|cdesc
expr_stmt|;
comment|/* Locate the AudioStreaming interface descriptor. */
name|offs
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|uaudio_find_iface
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|offs
argument_list|,
name|UISUBCLASS_AUDIOSTREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|sc
operator|->
name|sc_chan
operator|.
name|terminal
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|dir
operator|=
literal|0
expr_stmt|;
comment|/* Loop through all the alternate settings. */
while|while
condition|(
name|offs
operator|<=
name|size
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify: interface %d\n"
operator|,
name|id
operator|->
name|bInterfaceNumber
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|bNumEndpoints
condition|)
block|{
case|case
literal|0
case|:
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify: AS null alt=%d\n"
operator|,
name|id
operator|->
name|bAlternateSetting
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nullalt
operator|=
name|id
operator|->
name|bAlternateSetting
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|err
operator|=
name|uaudio_process_as
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
operator|&
name|offs
argument_list|,
name|size
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|USB_DEBUG
name|printf
argument_list|(
literal|"%s: ignored audio interface with %d "
literal|"endpoints\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|id
operator|->
name|bNumEndpoints
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|id
operator|=
name|uaudio_find_iface
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|offs
argument_list|,
name|UISUBCLASS_AUDIOSTREAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|offs
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_identify_as: %d alts available\n"
operator|,
name|sc
operator|->
name|sc_nalts
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|terminal
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no useable endpoint found\n"
argument_list|,
name|USBDEVNAME
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|dir
operator|==
operator|(
name|AUMODE_PLAY
operator||
name|AUMODE_RECORD
operator|)
condition|)
name|sc
operator|->
name|sc_props
operator||=
name|AUDIO_PROP_FULLDUPLEX
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_function
name|usbd_status
name|uaudio_identify_ac
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|usb_config_descriptor_t
modifier|*
name|cdesc
parameter_list|)
block|{
name|usb_interface_descriptor_t
modifier|*
name|id
decl_stmt|;
name|struct
name|usb_audio_control_descriptor
modifier|*
name|acdp
decl_stmt|;
name|usb_descriptor_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dps
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ibuf
decl_stmt|,
modifier|*
name|ibufend
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offs
decl_stmt|,
name|aclen
decl_stmt|,
name|ndps
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
name|UGETW
argument_list|(
name|cdesc
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|cdesc
expr_stmt|;
comment|/* Locate the AudioControl interface descriptor. */
name|offs
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|uaudio_find_iface
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|offs
argument_list|,
name|UISUBCLASS_AUDIOCONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
if|if
condition|(
name|offs
operator|+
sizeof|sizeof
expr|*
name|acdp
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|sc
operator|->
name|sc_ac_iface
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify: AC interface is %d\n"
operator|,
name|sc
operator|->
name|sc_ac_iface
operator|)
argument_list|)
expr_stmt|;
comment|/* A class-specific AC interface header should follow. */
name|ibuf
operator|=
name|buf
operator|+
name|offs
expr_stmt|;
name|acdp
operator|=
operator|(
expr|struct
name|usb_audio_control_descriptor
operator|*
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|acdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
operator|||
name|acdp
operator|->
name|bDescriptorSubtype
operator|!=
name|UDESCSUB_AC_HEADER
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|aclen
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|offs
operator|+
name|aclen
operator|>
name|size
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|usbd_get_quirks
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
operator|->
name|uq_flags
operator|&
name|UQ_BAD_ADC
operator|)
operator|&&
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
operator|!=
name|UAUDIO_VERSION
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
name|sc
operator|->
name|sc_audio_rev
operator|=
name|UGETW
argument_list|(
name|acdp
operator|->
name|bcdADC
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_identify: found AC header, vers=%03x, len=%d\n"
operator|,
name|sc
operator|->
name|sc_audio_rev
operator|,
name|aclen
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nullalt
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Scan through all the AC specific descriptors */
name|ibufend
operator|=
name|ibuf
operator|+
name|aclen
expr_stmt|;
name|dp
operator|=
operator|(
name|usb_descriptor_t
operator|*
operator|)
name|ibuf
expr_stmt|;
name|ndps
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|dps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dps
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ibuf
operator|+=
name|dp
operator|->
name|bLength
expr_stmt|;
if|if
condition|(
name|ibuf
operator|>=
name|ibufend
condition|)
break|break;
name|dp
operator|=
operator|(
name|usb_descriptor_t
operator|*
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|ibuf
operator|+
name|dp
operator|->
name|bLength
operator|>
name|ibufend
condition|)
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CS_INTERFACE
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_identify: skip desc type=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorType
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
operator|(
operator|(
expr|struct
name|usb_audio_input_terminal
operator|*
operator|)
name|dp
operator|)
operator|->
name|bTerminalId
expr_stmt|;
name|dps
index|[
name|i
index|]
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ndps
condition|)
name|ndps
operator|=
name|i
expr_stmt|;
block|}
name|ndps
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndps
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|dps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_identify: subtype=%d\n"
operator|,
name|dp
operator|->
name|bDescriptorSubtype
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|bDescriptorSubtype
condition|)
block|{
case|case
name|UDESCSUB_AC_HEADER
case|:
name|printf
argument_list|(
literal|"uaudio_identify: unexpected AC header\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_INPUT
case|:
name|uaudio_add_input
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_OUTPUT
case|:
name|uaudio_add_output
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_MIXER
case|:
name|uaudio_add_mixer
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_SELECTOR
case|:
name|uaudio_add_selector
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_FEATURE
case|:
name|uaudio_add_feature
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_PROCESSING
case|:
name|uaudio_add_processing
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDESCSUB_AC_EXTENSION
case|:
name|uaudio_add_extension
argument_list|(
name|sc
argument_list|,
name|dp
argument_list|,
name|dps
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"uaudio_identify: bad AC desc subtype=0x%02x\n"
argument_list|,
name|dp
operator|->
name|bDescriptorSubtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_query_devinfo
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|mixer_devinfo_t
modifier|*
name|mi
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nctls
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_query_devinfo: index=%d\n"
operator|,
name|mi
operator|->
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|n
operator|=
name|mi
operator|->
name|index
expr_stmt|;
name|nctls
operator|=
name|sc
operator|->
name|sc_nctls
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|nctls
condition|)
block|{
switch|switch
condition|(
name|n
operator|-
name|nctls
condition|)
block|{
case|case
name|UAC_OUTPUT
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|nctls
operator|+
name|UAC_OUTPUT
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCoutputs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|UAC_INPUT
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|nctls
operator|+
name|UAC_INPUT
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCinputs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|UAC_EQUAL
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_CLASS
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|nctls
operator|+
name|UAC_EQUAL
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
name|strcpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|AudioCequalization
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|n
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|mi
operator|->
name|label
operator|.
name|name
argument_list|,
name|mc
operator|->
name|ctlname
argument_list|,
name|MAX_AUDIO_DEV_LEN
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mixer_class
operator|=
name|mc
operator|->
name|class
expr_stmt|;
name|mi
operator|->
name|next
operator|=
name|mi
operator|->
name|prev
operator|=
name|AUDIO_MIXER_LAST
expr_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|mc
operator|->
name|type
condition|)
block|{
case|case
name|MIX_ON_OFF
case|:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_ENUM
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|num_mem
operator|=
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|0
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|AudioNoff
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|0
index|]
operator|.
name|ord
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|1
index|]
operator|.
name|label
operator|.
name|name
argument_list|,
name|AudioNon
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|e
operator|.
name|member
index|[
literal|1
index|]
operator|.
name|ord
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|mi
operator|->
name|type
operator|=
name|AUDIO_MIXER_VALUE
expr_stmt|;
name|strncpy
argument_list|(
name|mi
operator|->
name|un
operator|.
name|v
operator|.
name|units
operator|.
name|name
argument_list|,
name|mc
operator|->
name|ctlunit
argument_list|,
name|MAX_AUDIO_DEV_LEN
argument_list|)
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|v
operator|.
name|num_channels
operator|=
name|mc
operator|->
name|nchan
expr_stmt|;
name|mi
operator|->
name|un
operator|.
name|v
operator|.
name|delta
operator|=
name|mc
operator|->
name|delta
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_open
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_open: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|terminal
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_chan
operator|.
name|dir
operator|&
name|AUMODE_RECORD
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_chan
operator|.
name|dir
operator|&
name|AUMODE_PLAY
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|sc
operator|->
name|sc_chan
operator|.
name|intr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close function is called at splaudio().  */
end_comment

begin_function
name|void
name|uaudio_close
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_close: sc=%p\n"
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|uaudio_halt_in_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|uaudio_halt_out_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|intr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uaudio_drain
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|usbd_delay_ms
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
name|UAUDIO_NCHANBUFS
operator|*
name|UAUDIO_NFRAMES
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_halt_out_dma
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_out_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|=
literal|0
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_chan
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_halt_in_dma
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_in_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|=
literal|0
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_chan
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_getdev
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|audio_device
modifier|*
name|retp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_mixer_getdev:\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
operator|*
name|retp
operator|=
name|uaudio_device
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure the block size is large enough to hold all outstanding transfers.  */
end_comment

begin_function
name|int
name|uaudio_round_blocksize
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|blk
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|int
name|bpf
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|bpf
operator|=
name|sc
operator|->
name|sc_chan
operator|.
name|bytes_per_frame
operator|+
name|sc
operator|->
name|sc_chan
operator|.
name|sample_size
expr_stmt|;
comment|/* XXX */
name|bpf
operator|*=
name|UAUDIO_NFRAMES
operator|*
name|UAUDIO_NCHANBUFS
expr_stmt|;
name|bpf
operator|=
operator|(
name|bpf
operator|+
literal|15
operator|)
operator|&
operator|~
literal|15
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|bpf
condition|)
name|blk
operator|=
name|bpf
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|blk
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_round_blocksize: blk=%d\n"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|blk
operator|=
literal|512
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|1
argument_list|,
operator|(
literal|"uaudio_round_blocksize: blk=%d\n"
operator|,
name|blk
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_get_props
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_props
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD or OpenBSD */
end_comment

begin_function
name|int
name|uaudio_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|wValue
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|u_int8_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|wValue
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|req
operator|.
name|bmRequestType
operator|=
name|type
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|which
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|wValue
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|wIndex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x "
literal|"wIndex=0x%04x len=%d\n"
operator|,
name|type
operator|,
name|which
operator|,
name|wValue
operator|,
name|wIndex
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_get: err=%s\n"
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|data
index|[
literal|0
index|]
operator||
operator|(
name|data
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_get: bad length=%d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_get: val=%d\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|wValue
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|u_int8_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return;
if|if
condition|(
name|wValue
operator|==
operator|-
literal|1
condition|)
return|return;
name|req
operator|.
name|bmRequestType
operator|=
name|type
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|which
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|wValue
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|wIndex
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
name|data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x "
literal|"wIndex=0x%04x len=%d, val=%d\n"
operator|,
name|type
operator|,
name|which
operator|,
name|wValue
operator|,
name|wIndex
operator|,
name|len
operator|,
name|val
operator|&
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|err
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_set: err=%d\n"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|uaudio_signext
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MIX_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|MIX_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|2
condition|)
name|val
operator|=
operator|(
name|int16_t
operator|)
name|val
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|int8_t
operator|)
name|val
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_value2bsd
parameter_list|(
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_value2bsd: type=%03x val=%d min=%d max=%d "
operator|,
name|mc
operator|->
name|type
operator|,
name|val
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
name|val
operator|=
name|val
operator|!=
literal|0
expr_stmt|;
else|else
name|val
operator|=
operator|(
operator|(
name|uaudio_signext
argument_list|(
name|mc
operator|->
name|type
argument_list|,
name|val
argument_list|)
operator|-
name|mc
operator|->
name|minval
operator|)
operator|*
literal|256
operator|+
name|mc
operator|->
name|mul
operator|/
literal|2
operator|)
operator|/
name|mc
operator|->
name|mul
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"val'=%d\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|uaudio_bsd2value
parameter_list|(
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_bsd2value: type=%03x val=%d min=%d max=%d "
operator|,
name|mc
operator|->
name|type
operator|,
name|val
operator|,
name|mc
operator|->
name|minval
operator|,
name|mc
operator|->
name|maxval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
name|val
operator|=
name|val
operator|!=
literal|0
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|val
operator|+
name|mc
operator|->
name|delta
operator|/
literal|2
operator|)
operator|*
name|mc
operator|->
name|mul
operator|/
literal|256
operator|+
name|mc
operator|->
name|minval
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"val'=%d\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_ctl_get
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_ctl_get: which=%d chan=%d\n"
operator|,
name|which
operator|,
name|chan
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|uaudio_get
argument_list|(
name|sc
argument_list|,
name|which
argument_list|,
name|UT_READ_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|uaudio_value2bsd
argument_list|(
name|mc
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|uaudio_ctl_set
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|which
parameter_list|,
name|struct
name|mixerctl
modifier|*
name|mc
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|val
operator|=
name|uaudio_bsd2value
argument_list|(
name|mc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|uaudio_set
argument_list|(
name|sc
argument_list|,
name|which
argument_list|,
name|UT_WRITE_CLASS_INTERFACE
argument_list|,
name|mc
operator|->
name|wValue
index|[
name|chan
index|]
argument_list|,
name|mc
operator|->
name|wIndex
argument_list|,
name|MIX_SIZE
argument_list|(
name|mc
operator|->
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|int
name|uaudio_mixer_get_port
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|mixer_ctrl_t
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|vals
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|,
name|val
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_mixer_get_port: index=%d\n"
operator|,
name|cp
operator|->
name|dev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|n
operator|=
name|cp
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|sc
operator|->
name|sc_nctls
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_ENUM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cp
operator|->
name|un
operator|.
name|ord
operator|=
name|uaudio_ctl_get
argument_list|(
name|sc
argument_list|,
name|GET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_VALUE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|!=
literal|1
operator|&&
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|!=
name|mc
operator|->
name|nchan
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|uaudio_ctl_get
argument_list|(
name|sc
argument_list|,
name|GET_CUR
argument_list|,
name|mc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|==
literal|1
operator|&&
name|mc
operator|->
name|nchan
operator|!=
literal|1
condition|)
block|{
for|for
control|(
name|val
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|val
operator|+=
name|vals
index|[
name|i
index|]
expr_stmt|;
name|vals
index|[
literal|0
index|]
operator|=
name|val
operator|/
name|mc
operator|->
name|nchan
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
condition|;
name|i
operator|++
control|)
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|level
index|[
name|i
index|]
operator|=
name|vals
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_mixer_set_port
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|mixer_ctrl_t
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|vals
index|[
name|MIX_MAX_CHAN
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_mixer_set_port: index = %d\n"
operator|,
name|cp
operator|->
name|dev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|n
operator|=
name|cp
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|sc
operator|->
name|sc_nctls
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|type
operator|==
name|MIX_ON_OFF
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_ENUM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
name|cp
operator|->
name|un
operator|.
name|ord
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|AUDIO_MIXER_VALUE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|==
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|level
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|num_channels
operator|==
name|mc
operator|->
name|nchan
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|cp
operator|->
name|un
operator|.
name|value
operator|.
name|level
index|[
name|i
index|]
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mc
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
name|i
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_trigger_input
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|,
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|audio_params
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|sc_chan
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_input: sc=%p start=%p end=%p "
literal|"blksize=%d\n"
operator|,
name|sc
operator|,
name|start
operator|,
name|end
operator|,
name|blksize
operator|)
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param
argument_list|(
name|ch
argument_list|,
name|param
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_input: sample_size=%d bytes/frame=%d "
literal|"fraction=0.%03d\n"
operator|,
name|ch
operator|->
name|sample_size
operator|,
name|ch
operator|->
name|bytes_per_frame
operator|,
name|ch
operator|->
name|fraction
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_chan
operator|.
name|intr
operator|=
name|intr
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX -1 shouldn't be needed */
name|uaudio_chan_rtransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_trigger_output
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|,
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|audio_params
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|sc_chan
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_output: sc=%p start=%p end=%p "
literal|"blksize=%d\n"
operator|,
name|sc
operator|,
name|start
operator|,
name|end
operator|,
name|blksize
operator|)
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param
argument_list|(
name|ch
argument_list|,
name|param
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|3
argument_list|,
operator|(
literal|"uaudio_trigger_output: sample_size=%d bytes/frame=%d "
literal|"fraction=0.%03d\n"
operator|,
name|ch
operator|->
name|sample_size
operator|,
name|ch
operator|->
name|bytes_per_frame
operator|,
name|ch
operator|->
name|fraction
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_chan
operator|.
name|intr
operator|=
name|intr
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX */
name|uaudio_chan_ptransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD or OpenBSD */
end_comment

begin_comment
comment|/* Set up a pipe for a channel. */
end_comment

begin_function
name|usbd_status
name|uaudio_chan_open
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|as_info
modifier|*
name|as
init|=
operator|&
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_curaltidx
index|]
decl_stmt|;
name|int
name|endpt
init|=
name|as
operator|->
name|edesc
operator|->
name|bEndpointAddress
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\n"
operator|,
name|endpt
operator|,
name|ch
operator|->
name|sample_rate
operator|,
name|as
operator|->
name|alt
operator|)
argument_list|)
expr_stmt|;
comment|/* Set alternate interface corresponding to the mode. */
name|err
operator|=
name|usbd_set_interface
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|as
operator|->
name|alt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Some devices do not support this request, so ignore errors. */
ifdef|#
directive|ifdef
name|USB_DEBUG
name|err
operator|=
name|uaudio_set_speed
argument_list|(
name|sc
argument_list|,
name|endpt
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_open: set_speed failed err=%s\n"
operator|,
name|usbd_errstr
argument_list|(
name|err
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|uaudio_set_speed
argument_list|(
name|sc
argument_list|,
name|endpt
argument_list|,
name|ch
operator|->
name|sample_rate
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_open_chan: create pipe to 0x%02x\n"
operator|,
name|endpt
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|usbd_open_pipe
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|endpt
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_close
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|as_info
modifier|*
name|as
init|=
operator|&
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_curaltidx
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return ;
if|if
condition|(
name|sc
operator|->
name|sc_nullalt
operator|>=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_close_chan: set null alt=%d\n"
operator|,
name|sc
operator|->
name|sc_nullalt
operator|)
argument_list|)
expr_stmt|;
name|usbd_set_interface
argument_list|(
name|as
operator|->
name|ifaceh
argument_list|,
name|sc
operator|->
name|sc_nullalt
argument_list|)
expr_stmt|;
block|}
name|usbd_abort_pipe
argument_list|(
name|ch
operator|->
name|pipe
argument_list|)
expr_stmt|;
name|usbd_close_pipe
argument_list|(
name|ch
operator|->
name|pipe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|usbd_status
name|uaudio_chan_alloc_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|ch
operator|->
name|bytes_per_frame
operator|+
name|ch
operator|->
name|sample_size
operator|)
operator|*
name|UAUDIO_NFRAMES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
condition|;
name|i
operator|++
control|)
block|{
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|xfer
operator|=
name|xfer
expr_stmt|;
name|buf
operator|=
name|usbd_alloc_buffer
argument_list|(
name|xfer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|chan
operator|=
name|ch
expr_stmt|;
block|}
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|bad
label|:
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
comment|/* implicit buffer free */
name|usbd_free_xfer
argument_list|(
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_NOMEM
operator|)
return|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_free_buffers
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
condition|;
name|i
operator|++
control|)
name|usbd_free_xfer
argument_list|(
name|ch
operator|->
name|chanbufs
index|[
name|i
index|]
operator|.
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|uaudio_chan_ptransfer
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|size
decl_stmt|,
name|residue
decl_stmt|,
name|total
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|sc
operator|->
name|sc_dying
condition|)
return|return;
comment|/* Pick the next channel buffer. */
name|cb
operator|=
operator|&
name|ch
operator|->
name|chanbufs
index|[
name|ch
operator|->
name|curchanbuf
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ch
operator|->
name|curchanbuf
operator|>=
name|UAUDIO_NCHANBUFS
condition|)
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
comment|/* Compute the size of each frame in the next transfer. */
name|residue
operator|=
name|ch
operator|->
name|residue
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
name|residue
operator|+=
name|ch
operator|->
name|fraction
expr_stmt|;
if|if
condition|(
name|residue
operator|>=
name|USB_FRAMES_PER_SECOND
condition|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|nofrac
condition|)
name|size
operator|+=
name|ch
operator|->
name|sample_size
expr_stmt|;
name|residue
operator|-=
name|USB_FRAMES_PER_SECOND
expr_stmt|;
block|}
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|ch
operator|->
name|residue
operator|=
name|residue
expr_stmt|;
name|cb
operator|->
name|size
operator|=
name|total
expr_stmt|;
comment|/*  	 * Transfer data from upper layer buffer to channel buffer, taking 	 * care of wrapping the upper layer buffer. 	 */
name|n
operator|=
name|min
argument_list|(
name|total
argument_list|,
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cb
operator|->
name|buffer
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|total
operator|>
name|n
condition|)
block|{
name|total
operator|-=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cb
operator|->
name|buffer
operator|+
name|n
argument_list|,
name|ch
operator|->
name|cur
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|total
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudiodebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\n"
operator|,
name|cb
operator|->
name|buffer
operator|,
name|ch
operator|->
name|residue
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"   [%d] length %d\n"
operator|,
name|i
operator|,
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_transfer: ptransfer xfer=%p\n"
operator|,
name|cb
operator|->
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill the request */
name|usbd_setup_isoc_xfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|,
name|ch
operator|->
name|pipe
argument_list|,
name|cb
argument_list|,
name|cb
operator|->
name|sizes
argument_list|,
name|UAUDIO_NFRAMES
argument_list|,
name|USBD_NO_COPY
argument_list|,
name|uaudio_chan_pintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_pintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
init|=
name|priv
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
init|=
name|cb
operator|->
name|chan
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Return if we are aborting. */
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_pintr: count=%d, transferred=%d\n"
operator|,
name|count
operator|,
name|ch
operator|->
name|transferred
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|count
operator|!=
name|cb
operator|->
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_chan_pintr: count(%d) != size(%d)\n"
argument_list|,
name|count
argument_list|,
name|cb
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ch
operator|->
name|transferred
operator|+=
name|cb
operator|->
name|size
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* s = spltty(); */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
comment|/* Call back to upper layer */
while|while
condition|(
name|ch
operator|->
name|transferred
operator|>=
name|ch
operator|->
name|blksize
condition|)
block|{
name|ch
operator|->
name|transferred
operator|-=
name|ch
operator|->
name|blksize
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_pintr: call %p(%p)\n"
operator|,
name|ch
operator|->
name|intr
operator|,
name|ch
operator|->
name|arg
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|intr
argument_list|(
name|ch
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* start next transfer */
name|uaudio_chan_ptransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at splusb() */
end_comment

begin_function
name|void
name|uaudio_chan_rtransfer
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|residue
decl_stmt|,
name|total
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|sc
operator|->
name|sc_dying
condition|)
return|return;
comment|/* Pick the next channel buffer. */
name|cb
operator|=
operator|&
name|ch
operator|->
name|chanbufs
index|[
name|ch
operator|->
name|curchanbuf
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ch
operator|->
name|curchanbuf
operator|>=
name|UAUDIO_NCHANBUFS
condition|)
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
comment|/* Compute the size of each frame in the next transfer. */
name|residue
operator|=
name|ch
operator|->
name|residue
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|ch
operator|->
name|bytes_per_frame
expr_stmt|;
name|residue
operator|+=
name|ch
operator|->
name|fraction
expr_stmt|;
if|if
condition|(
name|residue
operator|>=
name|USB_FRAMES_PER_SECOND
condition|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|nofrac
condition|)
name|size
operator|+=
name|ch
operator|->
name|sample_size
expr_stmt|;
name|residue
operator|-=
name|USB_FRAMES_PER_SECOND
expr_stmt|;
block|}
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|total
operator|+=
name|size
expr_stmt|;
block|}
name|ch
operator|->
name|residue
operator|=
name|residue
expr_stmt|;
name|cb
operator|->
name|size
operator|=
name|total
expr_stmt|;
ifdef|#
directive|ifdef
name|USB_DEBUG
if|if
condition|(
name|uaudiodebug
operator|>
literal|8
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\n"
operator|,
name|cb
operator|->
name|buffer
operator|,
name|ch
operator|->
name|residue
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"   [%d] length %d\n"
operator|,
name|i
operator|,
name|cb
operator|->
name|sizes
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_rtransfer: transfer xfer=%p\n"
operator|,
name|cb
operator|->
name|xfer
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill the request */
name|usbd_setup_isoc_xfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|,
name|ch
operator|->
name|pipe
argument_list|,
name|cb
argument_list|,
name|cb
operator|->
name|sizes
argument_list|,
name|UAUDIO_NFRAMES
argument_list|,
name|USBD_NO_COPY
argument_list|,
name|uaudio_chan_rintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|usbd_transfer
argument_list|(
name|cb
operator|->
name|xfer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_rintr
parameter_list|(
name|usbd_xfer_handle
name|xfer
parameter_list|,
name|usbd_private_handle
name|priv
parameter_list|,
name|usbd_status
name|status
parameter_list|)
block|{
name|struct
name|chanbuf
modifier|*
name|cb
init|=
name|priv
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
init|=
name|cb
operator|->
name|chan
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|;
name|int
name|s
decl_stmt|,
name|n
decl_stmt|;
comment|/* Return if we are aborting. */
if|if
condition|(
name|status
operator|==
name|USBD_CANCELLED
condition|)
return|return;
name|usbd_get_xfer_status
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_rintr: count=%d, transferred=%d\n"
operator|,
name|count
operator|,
name|ch
operator|->
name|transferred
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|cb
operator|->
name|size
condition|)
block|{
comment|/* if the device fails to keep up, copy last byte */
name|u_char
name|b
init|=
name|count
condition|?
name|cb
operator|->
name|buffer
index|[
name|count
operator|-
literal|1
index|]
else|:
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|cb
operator|->
name|size
condition|)
name|cb
operator|->
name|buffer
index|[
name|count
operator|++
index|]
operator|=
name|b
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|count
operator|!=
name|cb
operator|->
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"uaudio_chan_rintr: count(%d) != size(%d)\n"
argument_list|,
name|count
argument_list|,
name|cb
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  	 * Transfer data from channel buffer to upper layer buffer, taking 	 * care of wrapping the upper layer buffer. 	 */
name|n
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|ch
operator|->
name|end
operator|-
name|ch
operator|->
name|cur
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ch
operator|->
name|cur
argument_list|,
name|cb
operator|->
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cur
operator|>=
name|ch
operator|->
name|end
condition|)
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|n
condition|)
block|{
name|memcpy
argument_list|(
name|ch
operator|->
name|cur
argument_list|,
name|cb
operator|->
name|buffer
operator|+
name|n
argument_list|,
name|count
operator|-
name|n
argument_list|)
expr_stmt|;
name|ch
operator|->
name|cur
operator|+=
name|count
operator|-
name|n
expr_stmt|;
block|}
comment|/* Call back to upper layer */
name|ch
operator|->
name|transferred
operator|+=
name|cb
operator|->
name|size
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|pcm_ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splaudio
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|->
name|transferred
operator|>=
name|ch
operator|->
name|blksize
condition|)
block|{
name|ch
operator|->
name|transferred
operator|-=
name|ch
operator|->
name|blksize
expr_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_chan_rintr: call %p(%p)\n"
operator|,
name|ch
operator|->
name|intr
operator|,
name|ch
operator|->
name|arg
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|intr
argument_list|(
name|ch
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* start next transfer */
name|uaudio_chan_rtransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_function
name|void
name|uaudio_chan_set_param
parameter_list|(
name|struct
name|chan
modifier|*
name|ch
parameter_list|,
name|struct
name|audio_params
modifier|*
name|param
parameter_list|,
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
name|end
parameter_list|,
name|int
name|blksize
parameter_list|)
block|{
name|int
name|samples_per_frame
decl_stmt|,
name|sample_size
decl_stmt|;
name|sample_size
operator|=
name|param
operator|->
name|precision
operator|*
name|param
operator|->
name|channels
operator|/
literal|8
expr_stmt|;
name|samples_per_frame
operator|=
name|param
operator|->
name|sample_rate
operator|/
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|fraction
operator|=
name|param
operator|->
name|sample_rate
operator|%
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|sample_size
operator|=
name|sample_size
expr_stmt|;
name|ch
operator|->
name|sample_rate
operator|=
name|param
operator|->
name|sample_rate
expr_stmt|;
name|ch
operator|->
name|bytes_per_frame
operator|=
name|samples_per_frame
operator|*
name|sample_size
expr_stmt|;
name|ch
operator|->
name|residue
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|start
expr_stmt|;
name|ch
operator|->
name|blksize
operator|=
name|blksize
expr_stmt|;
name|ch
operator|->
name|transferred
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uaudio_set_params
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|setmode
parameter_list|,
name|int
name|usemode
parameter_list|,
name|struct
name|audio_params
modifier|*
name|play
parameter_list|,
name|struct
name|audio_params
modifier|*
name|rec
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
init|=
name|addr
decl_stmt|;
name|int
name|flags
init|=
name|sc
operator|->
name|sc_altflags
decl_stmt|;
name|int
name|factor
decl_stmt|;
name|int
name|enc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swcode
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
name|struct
name|audio_params
modifier|*
name|p
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
for|for
control|(
name|mode
operator|=
name|AUMODE_RECORD
init|;
name|mode
operator|!=
operator|-
literal|1
condition|;
name|mode
operator|=
name|mode
operator|==
name|AUMODE_RECORD
condition|?
name|AUMODE_PLAY
else|:
operator|-
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|setmode
operator|&
name|mode
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_chan
operator|.
name|dir
operator|&
name|mode
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
name|mode
operator|==
name|AUMODE_PLAY
condition|?
name|play
else|:
name|rec
expr_stmt|;
name|factor
operator|=
literal|1
expr_stmt|;
name|swcode
operator|=
literal|0
expr_stmt|;
name|enc
operator|=
name|p
operator|->
name|encoding
expr_stmt|;
switch|switch
condition|(
name|enc
condition|)
block|{
case|case
name|AUDIO_ENCODING_SLINEAR_BE
case|:
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|16
condition|)
block|{
name|swcode
operator|=
name|swap_bytes
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|8
operator|&&
operator|!
operator|(
name|flags
operator|&
name|HAS_8
operator|)
condition|)
block|{
name|swcode
operator|=
name|change_sign8
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_SLINEAR_LE
case|:
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|8
operator|&&
operator|!
operator|(
name|flags
operator|&
name|HAS_8
operator|)
condition|)
block|{
name|swcode
operator|=
name|change_sign8
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULINEAR_BE
case|:
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|16
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|swap_bytes_change_sign16_le
expr_stmt|;
else|else
name|swcode
operator|=
name|change_sign16_swap_bytes_le
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|8
operator|&&
operator|!
operator|(
name|flags
operator|&
name|HAS_8U
operator|)
condition|)
block|{
name|swcode
operator|=
name|change_sign8
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULINEAR_LE
case|:
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|16
condition|)
block|{
name|swcode
operator|=
name|change_sign16_le
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|precision
operator|==
literal|8
operator|&&
operator|!
operator|(
name|flags
operator|&
name|HAS_8U
operator|)
condition|)
block|{
name|swcode
operator|=
name|change_sign8
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULAW
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HAS_MULAW
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
operator|&&
operator|(
name|flags
operator|&
name|HAS_16
operator|)
condition|)
block|{
name|swcode
operator|=
name|mulaw_to_slinear16_le
expr_stmt|;
name|factor
operator|=
literal|2
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8U
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|mulaw_to_ulinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|ulinear8_to_mulaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|mulaw_to_slinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|slinear8_to_mulaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ALAW
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HAS_ALAW
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
operator|&&
operator|(
name|flags
operator|&
name|HAS_16
operator|)
condition|)
block|{
name|swcode
operator|=
name|alaw_to_slinear16_le
expr_stmt|;
name|factor
operator|=
literal|2
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8U
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|alaw_to_ulinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|ulinear8_to_alaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|HAS_8
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|AUMODE_PLAY
condition|)
name|swcode
operator|=
name|alaw_to_slinear8
expr_stmt|;
else|else
name|swcode
operator|=
name|slinear8_to_alaw
expr_stmt|;
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* XXX do some other conversions... */
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\n"
operator|,
name|p
operator|->
name|channels
operator|,
name|p
operator|->
name|precision
operator|,
name|enc
operator|,
name|p
operator|->
name|sample_rate
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|a1d
init|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|asf1desc
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|channels
operator|==
name|a1d
operator|->
name|bNrChannels
operator|&&
name|p
operator|->
name|precision
operator|==
name|a1d
operator|->
name|bBitResolution
operator|&&
name|enc
operator|==
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
operator|&&
operator|(
name|mode
operator|==
name|AUMODE_PLAY
condition|?
name|UE_DIR_OUT
else|:
name|UE_DIR_IN
operator|)
operator|==
name|UE_GET_DIR
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
condition|)
block|{
if|if
condition|(
name|a1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set_params: cont %d-%d\n"
operator|,
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|,
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|<
name|p
operator|->
name|sample_rate
operator|&&
name|p
operator|->
name|sample_rate
operator|<
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|a1d
operator|->
name|bSamFreqType
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set_params: disc #"
literal|"%d: %d\n"
operator|,
name|j
operator|,
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX allow for some slack */
if|if
condition|(
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|==
name|p
operator|->
name|sample_rate
condition|)
goto|goto
name|found
goto|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
name|found
label|:
name|p
operator|->
name|sw_code
operator|=
name|swcode
expr_stmt|;
name|p
operator|->
name|factor
operator|=
name|factor
expr_stmt|;
if|if
condition|(
name|usemode
operator|==
name|mode
condition|)
name|sc
operator|->
name|sc_curaltidx
operator|=
name|i
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_set_params: use altidx=%d, altno=%d\n"
operator|,
name|sc
operator|->
name|sc_curaltidx
operator|,
name|sc
operator|->
name|sc_alts
index|[
name|sc
operator|->
name|sc_curaltidx
index|]
operator|.
name|idesc
operator|->
name|bAlternateSetting
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NetBSD or OpenBSD */
end_comment

begin_function
name|usbd_status
name|uaudio_set_speed
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|int
name|endpt
parameter_list|,
name|u_int
name|speed
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|u_int8_t
name|data
index|[
literal|3
index|]
decl_stmt|;
name|DPRINTFN
argument_list|(
literal|5
argument_list|,
operator|(
literal|"uaudio_set_speed: endpt=%d speed=%u\n"
operator|,
name|endpt
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_WRITE_CLASS_ENDPOINT
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|SET_CUR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|SAMPLING_FREQ_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|endpt
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|speed
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|data
index|[
literal|2
index|]
operator|=
name|speed
operator|>>
literal|16
expr_stmt|;
return|return
operator|(
name|usbd_do_request
argument_list|(
name|sc
operator|->
name|sc_udev
argument_list|,
operator|&
name|req
argument_list|,
operator|&
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_comment
comment|/************************************************************/
end_comment

begin_function
name|void
name|uaudio_init_params
parameter_list|(
name|struct
name|uaudio_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|chan
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|enc
decl_stmt|;
name|int
name|samples_per_frame
decl_stmt|,
name|sample_size
decl_stmt|;
switch|switch
condition|(
name|ch
operator|->
name|format
operator|&
literal|0x0000FFFF
condition|)
block|{
case|case
name|AFMT_U8
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_S8
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_A_LAW
case|:
comment|/* ? */
name|enc
operator|=
name|AUDIO_ENCODING_ALAW
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_MU_LAW
case|:
comment|/* ? */
name|enc
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|AFMT_S16_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_S16_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_SLINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_U16_LE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_LE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|AFMT_U16_BE
case|:
name|enc
operator|=
name|AUDIO_ENCODING_ULINEAR_BE
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|enc
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|precision
operator|=
literal|16
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown format %x\n"
argument_list|,
name|ch
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|format
operator|&
name|AFMT_STEREO
condition|)
block|{
name|ch
operator|->
name|channels
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|channels
operator|=
literal|1
expr_stmt|;
block|}
comment|/*	for (mode =  ......	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|a1d
init|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|asf1desc
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|channels
operator|==
name|a1d
operator|->
name|bNrChannels
operator|&&
name|ch
operator|->
name|precision
operator|==
name|a1d
operator|->
name|bBitResolution
operator|&&
if|#
directive|if
literal|1
name|enc
operator|==
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
condition|)
block|{
else|#
directive|else
name|enc
operator|==
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
operator|&&
operator|(
name|mode
operator|==
name|AUMODE_PLAY
condition|?
name|UE_DIR_OUT
else|:
name|UE_DIR_IN
operator|)
operator|==
name|UE_GET_DIR
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
block|)
block|{
endif|#
directive|endif
if|if
condition|(
name|a1d
operator|->
name|bSamFreqType
operator|==
name|UA_SAMP_CONTNUOUS
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set_params: cont %d-%d\n"
operator|,
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|,
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UA_SAMP_LO
argument_list|(
name|a1d
argument_list|)
operator|<
name|ch
operator|->
name|sample_rate
operator|&&
name|ch
operator|->
name|sample_rate
operator|<
name|UA_SAMP_HI
argument_list|(
name|a1d
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_curaltidx
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|a1d
operator|->
name|bSamFreqType
condition|;
name|j
operator|++
control|)
block|{
name|DPRINTFN
argument_list|(
literal|2
argument_list|,
operator|(
literal|"uaudio_set_params: disc #"
literal|"%d: %d\n"
operator|,
name|j
operator|,
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX allow for some slack */
if|if
condition|(
name|UA_GETSAMP
argument_list|(
name|a1d
argument_list|,
name|j
argument_list|)
operator|==
name|ch
operator|->
name|sample_rate
condition|)
block|{
name|sc
operator|->
name|sc_curaltidx
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
block|}
block|}
comment|/* return (EINVAL); */
name|found
label|:
if|#
directive|if
literal|0
comment|/* XXX */
block|p->sw_code = swcode; 		p->factor  = factor; 		if (usemode == mode) 			sc->sc_curaltidx = i;
endif|#
directive|endif
comment|/*	} */
name|sample_size
operator|=
name|ch
operator|->
name|precision
operator|*
name|ch
operator|->
name|channels
operator|/
literal|8
expr_stmt|;
name|samples_per_frame
operator|=
name|ch
operator|->
name|sample_rate
operator|/
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|fraction
operator|=
name|ch
operator|->
name|sample_rate
operator|%
name|USB_FRAMES_PER_SECOND
expr_stmt|;
name|ch
operator|->
name|sample_size
operator|=
name|sample_size
expr_stmt|;
name|ch
operator|->
name|bytes_per_frame
operator|=
name|samples_per_frame
operator|*
name|sample_size
expr_stmt|;
name|ch
operator|->
name|residue
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|cur
operator|=
name|ch
operator|->
name|start
expr_stmt|;
name|ch
operator|->
name|transferred
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|curchanbuf
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uaudio_query_formats
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
modifier|*
name|pfmt
parameter_list|,
name|u_int32_t
modifier|*
name|rfmt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pn
init|=
literal|0
decl_stmt|,
name|rn
init|=
literal|0
decl_stmt|;
name|int
name|prec
decl_stmt|,
name|dir
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|usb_audio_streaming_type1_descriptor
modifier|*
name|a1d
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nalts
condition|;
name|i
operator|++
control|)
block|{
name|fmt
operator|=
literal|0
expr_stmt|;
name|a1d
operator|=
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|asf1desc
expr_stmt|;
name|prec
operator|=
name|a1d
operator|->
name|bBitResolution
expr_stmt|;
comment|/* precision */
switch|switch
condition|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|encoding
condition|)
block|{
case|case
name|AUDIO_ENCODING_ULINEAR_LE
case|:
if|if
condition|(
name|prec
operator|==
literal|8
condition|)
block|{
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
literal|16
condition|)
block|{
name|fmt
operator|=
name|AFMT_U16_LE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_SLINEAR_LE
case|:
if|if
condition|(
name|prec
operator|==
literal|8
condition|)
block|{
name|fmt
operator|=
name|AFMT_S8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|==
literal|16
condition|)
block|{
name|fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULINEAR_BE
case|:
if|if
condition|(
name|prec
operator|==
literal|16
condition|)
block|{
name|fmt
operator|=
name|AFMT_U16_BE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_SLINEAR_BE
case|:
if|if
condition|(
name|prec
operator|==
literal|16
condition|)
block|{
name|fmt
operator|=
name|AFMT_S16_BE
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ALAW
case|:
if|if
condition|(
name|prec
operator|==
literal|8
condition|)
block|{
name|fmt
operator|=
name|AFMT_A_LAW
expr_stmt|;
block|}
break|break;
case|case
name|AUDIO_ENCODING_ULAW
case|:
if|if
condition|(
name|prec
operator|==
literal|8
condition|)
block|{
name|fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|fmt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|a1d
operator|->
name|bNrChannels
operator|==
literal|2
condition|)
block|{
comment|/* stereo/mono */
name|fmt
operator||=
name|AFMT_STEREO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a1d
operator|->
name|bNrChannels
operator|!=
literal|1
condition|)
block|{
name|fmt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fmt
operator|!=
literal|0
condition|)
block|{
name|dir
operator|=
name|UE_GET_DIR
argument_list|(
name|sc
operator|->
name|sc_alts
index|[
name|i
index|]
operator|.
name|edesc
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|UE_DIR_OUT
condition|)
block|{
name|pfmt
index|[
name|pn
operator|++
index|]
operator|=
name|fmt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
name|UE_DIR_IN
condition|)
block|{
name|rfmt
index|[
name|rn
operator|++
index|]
operator|=
name|fmt
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pn
operator|>
literal|8
operator|*
literal|2
operator|)
operator|||
operator|(
name|rn
operator|>
literal|8
operator|*
literal|2
operator|)
condition|)
break|break;
block|}
name|pfmt
index|[
name|pn
index|]
operator|=
literal|0
expr_stmt|;
name|rfmt
index|[
name|rn
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_pcm_dma_buff
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
name|end
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_chan
expr_stmt|;
name|ch
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|ch
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|ch
operator|->
name|pcm_ch
operator|=
name|pc
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_blocksize
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_chan
expr_stmt|;
name|ch
operator|->
name|blksize
operator|=
name|blocksize
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_speed
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_chan
expr_stmt|;
name|ch
operator|->
name|sample_rate
operator|=
name|speed
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|uaudio_chan_getptr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|int
name|ptr
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_chan
expr_stmt|;
name|ptr
operator|=
name|ch
operator|->
name|cur
operator|-
name|ch
operator|->
name|start
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
name|uaudio_chan_set_param_format
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_chan
expr_stmt|;
name|ch
operator|->
name|format
operator|=
name|format
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|uaudio_halt_out_dma
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"uaudio_halt_out_dma: enter\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|!=
name|NULL
condition|)
block|{
name|uaudio_chan_close
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_chan
operator|.
name|pipe
operator|=
literal|0
expr_stmt|;
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_chan
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uaudio_trigger_output
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|chan
modifier|*
name|ch
decl_stmt|;
name|usbd_status
name|err
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_chan
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dying
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|uaudio_init_params
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|err
operator|=
name|uaudio_chan_alloc_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|uaudio_chan_open
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uaudio_chan_free_buffers
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|s
operator|=
name|splusb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAUDIO_NCHANBUFS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
comment|/* XXX */
name|uaudio_chan_ptransfer
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|uaudio_query_mix_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|mask
init|=
literal|0
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nctls
condition|;
name|i
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|ctl
operator|!=
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
comment|/* Set device mask bits.  			   See /usr/include/machine/soundcard.h */
name|mask
operator||=
operator|(
literal|1
operator|<<
name|mc
operator|->
name|ctl
operator|)
expr_stmt|;
block|}
block|}
return|return
name|mask
return|;
block|}
end_function

begin_function
name|void
name|uaudio_mixer_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|unsigned
name|type
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|uaudio_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mixerctl
modifier|*
name|mc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nctls
condition|;
name|i
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|sc
operator|->
name|sc_ctls
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|ctl
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|nchan
operator|==
literal|2
condition|)
block|{
comment|/* set Right */
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|right
operator|*
literal|256
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* set Left or Mono */
name|uaudio_ctl_set
argument_list|(
name|sc
argument_list|,
name|SET_CUR
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|,
call|(
name|int
call|)
argument_list|(
name|left
operator|*
literal|256
argument_list|)
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|Static
name|int
name|audio_attach_mi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* Attach the children. */
comment|/* PCM Audio */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|func
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXXXX */
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uaudio
argument_list|,
name|uhub
argument_list|,
name|uaudio_driver
argument_list|,
name|uaudio_devclass
argument_list|,
name|usbd_driver_load
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|uaudio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

