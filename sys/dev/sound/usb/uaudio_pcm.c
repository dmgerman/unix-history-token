begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000-2002 Hiroyuki Aizu<aizu@navi.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudio.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_struct_decl
struct_decl|struct
name|ua_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ua_chinfo
block|{
name|struct
name|ua_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|hwch
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|,
name|blksz
decl_stmt|;
comment|/* XXXXX */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ua_info
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|u_int32_t
name|bufsz
decl_stmt|;
name|struct
name|ua_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
define|#
directive|define
name|FORMAT_NUM
value|32
name|u_int32_t
name|ua_playfmt
index|[
name|FORMAT_NUM
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
comment|/* FORMAT_NUM format * (stereo or mono) + endptr */
name|u_int32_t
name|ua_recfmt
index|[
name|FORMAT_NUM
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
comment|/* FORMAT_NUM format * (stereo or mono) + endptr */
name|struct
name|pcmchan_caps
name|ua_playcaps
decl_stmt|;
name|struct
name|pcmchan_caps
name|ua_reccaps
decl_stmt|;
name|int
name|vendor
decl_stmt|,
name|product
decl_stmt|,
name|release
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UAUDIO_DEFAULT_BUFSZ
value|16*1024
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|vendor
decl_stmt|;
name|int
name|product
decl_stmt|;
name|int
name|release
decl_stmt|;
name|uint32_t
name|dflags
decl_stmt|;
block|}
name|ua_quirks
index|[]
init|=
block|{
block|{
literal|0x1130
block|,
literal|0xf211
block|,
literal|0x0101
block|,
name|SD_F_PSWAPLR
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ua_chan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|pch
else|:
operator|&
name|sc
operator|->
name|rch
decl_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ch
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|uaudio_chan_set_param_pcm_dma_buff
argument_list|(
name|pa_dev
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|ch
operator|->
name|buf
operator|+
name|sc
operator|->
name|bufsz
argument_list|,
name|ch
operator|->
name|channel
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|pa_dev
argument_list|,
literal|"%s buf %p\n"
argument_list|,
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
literal|"play"
else|:
literal|"rec"
argument_list|,
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
name|ch
operator|->
name|hwch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|->
name|hwch
operator|=
literal|2
expr_stmt|;
else|#
directive|else
name|ch
operator|->
name|hwch
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_free
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ua_chinfo
modifier|*
name|ua
init|=
name|data
decl_stmt|;
if|if
condition|(
name|ua
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ua
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
comment|/* 	 * At this point, no need to query as we shouldn't select an unsorted format 	 */
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param_format
argument_list|(
name|pa_dev
argument_list|,
name|format
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|ua_chinfo
modifier|*
name|ch
decl_stmt|;
name|device_t
name|pa_dev
decl_stmt|;
name|int
name|bestspeed
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ch
operator|->
name|parent
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestspeed
operator|=
name|uaudio_chan_set_param_speed
argument_list|(
name|pa_dev
argument_list|,
name|speed
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
operator|)
condition|)
name|ch
operator|->
name|spd
operator|=
name|bestspeed
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setfragments
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blksz
parameter_list|,
name|u_int32_t
name|blkcnt
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|RANGE
argument_list|(
name|blksz
argument_list|,
literal|128
argument_list|,
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
name|blkcnt
argument_list|,
literal|2
argument_list|,
literal|512
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|blksz
operator|*
name|blkcnt
operator|)
operator|>
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|blkcnt
operator|>>
literal|1
operator|)
operator|>=
literal|2
condition|)
name|blkcnt
operator|>>=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|blksz
operator|>>
literal|1
operator|)
operator|>=
literal|128
condition|)
name|blksz
operator|>>=
literal|1
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|(
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|!=
name|blksz
operator|||
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|!=
name|blkcnt
operator|)
operator|&&
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blkcnt
argument_list|,
name|blksz
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed blksz=%u blkcnt=%u\n"
argument_list|,
name|__func__
argument_list|,
name|blksz
argument_list|,
name|blkcnt
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param_pcm_dma_buff
argument_list|(
name|pa_dev
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|ch
operator|->
name|buf
operator|+
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|,
name|ch
operator|->
name|channel
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param_blocksize
argument_list|(
name|pa_dev
argument_list|,
name|ch
operator|->
name|blksz
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blksz
parameter_list|)
block|{
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ua_chan_setfragments
argument_list|(
name|obj
argument_list|,
name|data
argument_list|,
name|blksz
argument_list|,
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
name|blksz
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|blksz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_EMLDMAWR
operator|||
name|go
operator|==
name|PCMTRIG_EMLDMARD
condition|)
return|return
literal|0
return|;
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
comment|/* XXXXX */
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|uaudio_trigger_output
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uaudio_halt_out_dma
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
name|uaudio_trigger_input
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
else|else
name|uaudio_halt_in_dma
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
name|uaudio_chan_getptr
argument_list|(
name|pa_dev
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|ua_chan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ua_chinfo
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
operator|(
name|ch
operator|->
name|parent
operator|->
name|ua_playcaps
operator|)
else|:
operator|&
operator|(
name|ch
operator|->
name|parent
operator|->
name|ua_reccaps
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ua_chan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|ua_chan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|ua_chan_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|ua_chan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|ua_chan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|ua_chan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setfragments
argument_list|,
name|ua_chan_setfragments
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|ua_chan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|ua_chan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|ua_chan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|ua_chan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ua_mixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|device_get_softc
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|mask
operator|=
name|uaudio_query_mix_info
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|SOUND_MASK_PCM
operator|)
condition|)
block|{
comment|/* 			 * Emulate missing pcm mixer controller 			 * through FEEDER_VOLUME 			 */
name|d
operator|->
name|flags
operator||=
name|SD_F_SOFTPCMVOL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|SOUND_MASK_VOLUME
operator|)
condition|)
block|{
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MASK_PCM
argument_list|)
expr_stmt|;
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
block|}
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|uaudio_query_recsrc_info
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_mixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|type
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_mixer_set
argument_list|(
name|pa_dev
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_mixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
name|uaudio_mixer_setrecsrc
argument_list|(
name|pa_dev
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ua_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|ua_mixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|ua_mixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|ua_mixer_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|ua_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ua_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* The parent device has already been probed. */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|func
operator|->
name|func
operator|!=
name|SCF_PCM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
literal|"USB Audio"
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|device_t
name|pa_dev
decl_stmt|;
name|u_int32_t
name|nplay
decl_stmt|,
name|nrec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ua
operator|=
operator|(
expr|struct
name|ua_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ua
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ua
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|ua
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* Mark for existence */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
condition|)
name|func
operator|->
name|varinfo
operator|=
operator|(
name|void
operator|*
operator|)
name|ua
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ua
operator|->
name|vendor
operator|=
name|uaudio_get_vendor
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
name|ua
operator|->
name|product
operator|=
name|uaudio_get_product
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
name|ua
operator|->
name|release
operator|=
name|uaudio_get_release
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"USB Audio: "
literal|"vendor=0x%04x, product=0x%04x, release=0x%04x\n"
argument_list|,
name|ua
operator|->
name|vendor
argument_list|,
name|ua
operator|->
name|product
argument_list|,
name|ua
operator|->
name|release
argument_list|)
expr_stmt|;
name|ua
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|UAUDIO_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using a default buffer size of %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ua
operator|->
name|bufsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|ua_mixer_class
argument_list|,
name|ua
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at ? %s"
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_uaudio
argument_list|)
argument_list|)
expr_stmt|;
name|ua
operator|->
name|ua_playcaps
operator|.
name|fmtlist
operator|=
name|ua
operator|->
name|ua_playfmt
expr_stmt|;
name|ua
operator|->
name|ua_reccaps
operator|.
name|fmtlist
operator|=
name|ua
operator|->
name|ua_recfmt
expr_stmt|;
name|nplay
operator|=
name|uaudio_query_formats
argument_list|(
name|pa_dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
name|FORMAT_NUM
operator|*
literal|2
argument_list|,
operator|&
name|ua
operator|->
name|ua_playcaps
argument_list|)
expr_stmt|;
name|nrec
operator|=
name|uaudio_query_formats
argument_list|(
name|pa_dev
argument_list|,
name|PCMDIR_REC
argument_list|,
name|FORMAT_NUM
operator|*
literal|2
argument_list|,
operator|&
name|ua
operator|->
name|ua_reccaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|nplay
operator|>
literal|1
condition|)
name|nplay
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nrec
operator|>
literal|1
condition|)
name|nrec
operator|=
literal|1
expr_stmt|;
name|d
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|d
operator|!=
name|NULL
operator|&&
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ua_quirks
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ua_quirks
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ua
operator|->
name|vendor
operator|==
name|ua_quirks
index|[
name|i
index|]
operator|.
name|vendor
operator|&&
name|ua
operator|->
name|product
operator|==
name|ua_quirks
index|[
name|i
index|]
operator|.
name|product
operator|&&
name|ua
operator|->
name|release
operator|==
name|ua_quirks
index|[
name|i
index|]
operator|.
name|release
condition|)
name|d
operator|->
name|flags
operator||=
name|ua_quirks
index|[
name|i
index|]
operator|.
name|dflags
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|ua
argument_list|,
name|nplay
argument_list|,
name|nrec
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|ua
argument_list|,
name|nplay
argument_list|,
literal|0
argument_list|)
condition|)
block|{
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
name|sndstat_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|uaudio_sndstat_register
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nplay
condition|;
name|i
operator|++
control|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|ua_chan_class
argument_list|,
name|ua
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_RECORDING
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrec
condition|;
name|i
operator|++
control|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|ua_chan_class
argument_list|,
name|ua
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|free
argument_list|(
name|ua
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
specifier|static
name|int
name|ua_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ua_info
modifier|*
name|sc
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Mark for deletion */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
condition|)
name|func
operator|->
name|varinfo
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/************************************************************/
specifier|static
name|device_method_t
name|ua_pcm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ua_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ua_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ua_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|driver_t
name|ua_pcm_driver
init|=
block|{
literal|"pcm"
block|,
name|ua_pcm_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
name|DRIVER_MODULE
argument_list|(
name|ua_pcm
argument_list|,
name|uaudio
argument_list|,
name|ua_pcm_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|ua_pcm
argument_list|,
name|uaudio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|ua_pcm
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
name|MODULE_VERSION
argument_list|(
name|ua_pcm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_function

end_unit

