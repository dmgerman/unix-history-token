begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000-2002 Hiroyuki Aizu<aizu@navi.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/usb/uaudio.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_struct_decl
struct_decl|struct
name|ua_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ua_chinfo
block|{
name|struct
name|ua_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|hwch
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|,
name|blksz
decl_stmt|;
comment|/* XXXXX */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ua_info
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|u_int32_t
name|bufsz
decl_stmt|;
name|struct
name|ua_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_int32_t
name|ua_playfmt
index|[
literal|8
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8 format * (stereo or mono) + endptr */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|ua_playcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|ua_playfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|ua_recfmt
index|[
literal|8
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8 format * (stereo or mono) + endptr */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|ua_reccaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|ua_recfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UAUDIO_DEFAULT_BUFSZ
value|16*1024
end_define

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ua_chan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|pch
else|:
operator|&
name|sc
operator|->
name|rch
decl_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
comment|/* Create ua_playfmt[]& ua_recfmt[] */
name|uaudio_query_formats
argument_list|(
name|pa_dev
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|ua_playfmt
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|ua_recfmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|ua_playfmt
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"play channel supported format list invalid\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ua_recfmt
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"record channel supported format list invalid\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|ch
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ch
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|uaudio_chan_set_param_pcm_dma_buff
argument_list|(
name|pa_dev
argument_list|,
name|ch
operator|->
name|buf
argument_list|,
name|ch
operator|->
name|buf
operator|+
name|sc
operator|->
name|bufsz
argument_list|,
name|ch
operator|->
name|channel
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|pa_dev
argument_list|,
literal|"%s buf %p\n"
argument_list|,
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
literal|"play"
else|:
literal|"rec"
argument_list|,
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
name|ch
operator|->
name|hwch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|ch
operator|->
name|hwch
operator|=
literal|2
expr_stmt|;
else|#
directive|else
name|ch
operator|->
name|hwch
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_free
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ua_chinfo
modifier|*
name|ua
init|=
name|data
decl_stmt|;
if|if
condition|(
name|ua
operator|->
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ua
operator|->
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param_format
argument_list|(
name|pa_dev
argument_list|,
name|format
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param_speed
argument_list|(
name|pa_dev
argument_list|,
name|speed
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|blocksize
condition|)
block|{
name|RANGE
argument_list|(
name|blocksize
argument_list|,
literal|128
argument_list|,
name|ua
operator|->
name|bufsz
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|ua
operator|->
name|bufsz
operator|/
name|blocksize
argument_list|,
name|blocksize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
block|}
block|}
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_chan_set_param_blocksize
argument_list|(
name|pa_dev
argument_list|,
name|blocksize
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|blksz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_EMLDMAWR
operator|||
name|go
operator|==
name|PCMTRIG_EMLDMARD
condition|)
return|return
literal|0
return|;
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
comment|/* XXXXX */
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|uaudio_trigger_output
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uaudio_halt_out_dma
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
name|uaudio_trigger_input
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
else|else
name|uaudio_halt_in_dma
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_chan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ua
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
name|uaudio_chan_getptr
argument_list|(
name|pa_dev
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|ua_chan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ua_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|ua_playcaps
else|:
operator|&
name|ua_reccaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ua_chan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|ua_chan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|ua_chan_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|ua_chan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|ua_chan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|ua_chan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|ua_chan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|ua_chan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|ua_chan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|ua_chan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ua_mixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|u_int32_t
name|mask
decl_stmt|;
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|mask
operator|=
name|uaudio_query_mix_info
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|=
name|uaudio_query_recsrc_info
argument_list|(
name|pa_dev
argument_list|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_mixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|type
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|uaudio_mixer_set
argument_list|(
name|pa_dev
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_mixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|device_t
name|pa_dev
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|ua
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|pa_dev
operator|=
name|device_get_parent
argument_list|(
name|ua
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
return|return
name|uaudio_mixer_setrecsrc
argument_list|(
name|pa_dev
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ua_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|ua_mixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|ua_mixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|ua_mixer_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|ua_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ua_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* The parent device has already been probed. */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|func
operator|->
name|func
operator|!=
name|SCF_PCM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
literal|"USB Audio"
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ua_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ua_info
modifier|*
name|ua
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|ua
operator|=
operator|(
expr|struct
name|ua_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ua
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ua
condition|)
return|return
name|ENXIO
return|;
name|bzero
argument_list|(
name|ua
argument_list|,
sizeof|sizeof
expr|*
name|ua
argument_list|)
expr_stmt|;
name|ua
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|ua
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|UAUDIO_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"uaudio: using a default buffer size of %d\n"
argument_list|,
name|ua
operator|->
name|bufsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|ua_mixer_class
argument_list|,
name|ua
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at addr ?"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|ua
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|ua
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|ua_chan_class
argument_list|,
name|ua
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RECORDING
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|ua_chan_class
argument_list|,
name|ua
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|ua_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|ua_info
modifier|*
name|sc
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/************************************************************/
specifier|static
name|device_method_t
name|ua_pcm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ua_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ua_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ua_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|driver_t
name|ua_pcm_driver
init|=
block|{
literal|"pcm"
block|,
name|ua_pcm_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
name|DRIVER_MODULE
argument_list|(
name|ua_pcm
argument_list|,
name|uaudio
argument_list|,
name|ua_pcm_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|ua_pcm
argument_list|,
name|uaudio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|ua_pcm
argument_list|,
name|snd_pcm
argument_list|,
name|PCM_MINVER
argument_list|,
name|PCM_PREFVER
argument_list|,
name|PCM_MAXVER
argument_list|)
expr_stmt|;
name|MODULE_VERSION
argument_list|(
name|ua_pcm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_function

end_unit

