begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2008 by Marco Trillo. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *	Apple DAVbus audio controller.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/macio/aoa.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/macio/davbusreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_struct
struct|struct
name|davbus_softc
block|{
name|struct
name|aoa_softc
name|aoa
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|phandle_t
name|soundnode
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|;
name|struct
name|mtx
name|mutex
decl_stmt|;
name|int
name|device_id
decl_stmt|;
name|u_int
name|output_mask
decl_stmt|;
name|u_int
function_decl|(
modifier|*
name|read_status
function_decl|)
parameter_list|(
name|struct
name|davbus_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|set_outputs
function_decl|)
parameter_list|(
name|struct
name|davbus_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|davbus_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|davbus_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|davbus_cint
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pcm_davbus_methods
index|[]
init|=
block|{
comment|/* Device interface. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|davbus_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|davbus_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pcm_davbus_driver
init|=
block|{
literal|"pcm"
block|,
name|pcm_davbus_methods
block|,
name|PCM_SOFTC_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcm_davbus
argument_list|,
name|macio
argument_list|,
name|pcm_davbus_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pcm_davbus
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***************************************************************************** 			Probe and attachment routines.  *****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|davbus_probe
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|ofw_bus_get_name
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"davbus"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|self
argument_list|,
literal|"Apple DAVBus Audio Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Burgundy codec control  */
end_comment

begin_function_decl
specifier|static
name|int
name|burgundy_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|burgundy_uninit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|burgundy_reinit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|burgundy_write_locked
parameter_list|(
name|struct
name|davbus_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|burgundy_set_outputs
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|burgundy_read_status
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|burgundy_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|burgundy_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|burgundy_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|burgundy_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_uninit
argument_list|,
name|burgundy_uninit
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_reinit
argument_list|,
name|burgundy_reinit
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|burgundy_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|burgundy_setrecsrc
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|burgundy_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|burgundy_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|davbus_softc
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|d
operator|->
name|read_status
operator|=
name|burgundy_read_status
expr_stmt|;
name|d
operator|->
name|set_outputs
operator|=
name|burgundy_set_outputs
expr_stmt|;
comment|/* 	 * We configure the Burgundy codec as follows: 	 * 	 * 	o Input subframe 0 is connected to input digital 	 *	  stream A (ISA). 	 *	o Stream A (ISA) is mixed in mixer 2 (MIX2). 	 *	o Output of mixer 2 (MIX2) is routed to output sources 	 *	  OS0 and OS1 which can be converted to analog. 	 * 	 */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
literal|0x16700
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MIX0_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MIX1_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MIX2_REG
argument_list|,
name|BURGUNDY_MIX_ISA
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MIX3_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OS_REG
argument_list|,
name|BURGUNDY_OS0_MIX2
operator||
name|BURGUNDY_OS1_MIX2
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_SDIN_REG
argument_list|,
name|BURGUNDY_ISA_SF0
argument_list|)
expr_stmt|;
comment|/* Set several digital scalers to unity gain. */
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MXS2L_REG
argument_list|,
name|BURGUNDY_MXS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MXS2R_REG
argument_list|,
name|BURGUNDY_MXS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OSS0L_REG
argument_list|,
name|BURGUNDY_OSS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OSS0R_REG
argument_list|,
name|BURGUNDY_OSS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OSS1L_REG
argument_list|,
name|BURGUNDY_OSS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OSS1R_REG
argument_list|,
name|BURGUNDY_OSS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_ISSAL_REG
argument_list|,
name|BURGUNDY_ISS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_ISSAR_REG
argument_list|,
name|BURGUNDY_ISS_UNITY
argument_list|)
expr_stmt|;
name|burgundy_set_outputs
argument_list|(
name|d
argument_list|,
name|burgundy_read_status
argument_list|(
name|d
argument_list|,
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_STATUS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|SOUND_MASK_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|burgundy_uninit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|burgundy_reinit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|burgundy_write_locked
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|u_int
name|size
decl_stmt|,
name|addr
decl_stmt|,
name|offset
decl_stmt|,
name|data
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
operator|(
name|reg
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|addr
operator|=
operator|(
name|reg
operator|&
literal|0x0000FF00
operator|)
operator|>>
literal|8
expr_stmt|;
name|offset
operator|=
name|reg
operator|&
literal|0xFF
expr_stmt|;
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|offset
operator|+
name|size
condition|;
operator|++
name|i
control|)
block|{
name|data
operator|=
name|BURGUNDY_CTRL_WRITE
operator||
operator|(
name|addr
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|size
operator|+
name|offset
operator|-
literal|1
operator|)
operator|<<
literal|10
operator|)
operator||
operator|(
name|i
operator|<<
literal|8
operator|)
operator||
operator|(
name|val
operator|&
literal|0xFF
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|offset
condition|)
name|data
operator||=
name|BURGUNDY_CTRL_RESET
expr_stmt|;
name|bus_write_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_CTRL
argument_list|,
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_CTRL
argument_list|)
operator|&
name|DAVBUS_CODEC_BUSY
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
comment|/* next byte. */
block|}
block|}
end_function

begin_comment
comment|/* Must be called with d->mutex held. */
end_comment

begin_function
specifier|static
name|void
name|burgundy_set_outputs
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|mask
parameter_list|)
block|{
name|u_int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|==
name|d
operator|->
name|output_mask
condition|)
return|return;
comment|/* 	 *	Bordeaux card wirings: 	 *		Port 15:	RCA out 	 *		Port 16:	Minijack out 	 *		Port 17:	Internal speaker 	 * 	 *	B&W G3 wirings: 	 *		Port 14:	Minijack out 	 *		Port 17:	Internal speaker 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"Enabled outputs:"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|" SPEAKER"
operator|)
argument_list|)
expr_stmt|;
name|x
operator||=
name|BURGUNDY_P17M_EN
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|" HEADPHONES"
operator|)
argument_list|)
expr_stmt|;
name|x
operator||=
name|BURGUNDY_P14L_EN
operator||
name|BURGUNDY_P14R_EN
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_MUTE_REG
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|d
operator|->
name|output_mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|burgundy_read_status
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|&
literal|0x4
condition|)
return|return
operator|(
literal|1
operator|<<
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|<<
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|burgundy_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|davbus_softc
modifier|*
name|d
decl_stmt|;
name|int
name|lval
decl_stmt|,
name|rval
decl_stmt|;
name|lval
operator|=
operator|(
operator|(
literal|100
operator|-
name|left
operator|)
operator|*
literal|15
operator|/
literal|100
operator|)
operator|&
literal|0xf
expr_stmt|;
name|rval
operator|=
operator|(
operator|(
literal|100
operator|-
name|right
operator|)
operator|*
literal|15
operator|/
literal|100
operator|)
operator|&
literal|0xf
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"volume %d %d\n"
operator|,
name|lval
operator|,
name|rval
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|SOUND_MIXER_VOLUME
case|:
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OL13_REG
argument_list|,
name|lval
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OL14_REG
argument_list|,
operator|(
name|rval
operator|<<
literal|4
operator|)
operator||
name|lval
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OL15_REG
argument_list|,
operator|(
name|rval
operator|<<
literal|4
operator|)
operator||
name|lval
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OL16_REG
argument_list|,
operator|(
name|rval
operator|<<
literal|4
operator|)
operator||
name|lval
argument_list|)
expr_stmt|;
name|burgundy_write_locked
argument_list|(
name|d
argument_list|,
name|BURGUNDY_OL17_REG
argument_list|,
name|lval
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|burgundy_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Screamer Codec Control  */
end_comment

begin_function_decl
specifier|static
name|int
name|screamer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|screamer_uninit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|screamer_reinit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|screamer_write_locked
parameter_list|(
name|struct
name|davbus_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|screamer_set_outputs
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|screamer_read_status
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|screamer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|screamer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|screamer_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|screamer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_uninit
argument_list|,
name|screamer_uninit
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_reinit
argument_list|,
name|screamer_reinit
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|screamer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|screamer_setrecsrc
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|screamer_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|screamer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|davbus_softc
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|d
operator|->
name|read_status
operator|=
name|screamer_read_status
expr_stmt|;
name|d
operator|->
name|set_outputs
operator|=
name|screamer_set_outputs
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR0
argument_list|,
name|SCREAMER_INPUT_CD
operator||
name|SCREAMER_DEFAULT_CD_GAIN
argument_list|)
expr_stmt|;
name|screamer_set_outputs
argument_list|(
name|d
argument_list|,
name|screamer_read_status
argument_list|(
name|d
argument_list|,
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_STATUS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|SOUND_MASK_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|screamer_uninit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|screamer_reinit
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|screamer_write_locked
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|u_int
name|x
decl_stmt|;
name|KASSERT
argument_list|(
name|val
operator|==
operator|(
name|val
operator|&
literal|0xfff
operator|)
argument_list|,
operator|(
literal|"bad val"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_CTRL
argument_list|)
operator|&
name|DAVBUS_CODEC_BUSY
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|x
operator|=
name|reg
expr_stmt|;
name|x
operator||=
name|SCREAMER_CODEC_EMSEL0
expr_stmt|;
name|x
operator||=
name|val
expr_stmt|;
name|bus_write_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_CTRL
argument_list|,
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_CTRL
argument_list|)
operator|&
name|DAVBUS_CODEC_BUSY
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with d->mutex held. */
end_comment

begin_function
specifier|static
name|void
name|screamer_set_outputs
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|mask
parameter_list|)
block|{
name|u_int
name|x
decl_stmt|;
if|if
condition|(
name|mask
operator|==
name|d
operator|->
name|output_mask
condition|)
block|{
return|return;
block|}
name|x
operator|=
name|SCREAMER_MUTE_SPEAKER
operator||
name|SCREAMER_MUTE_HEADPHONES
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Enabled outputs: "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"SPEAKER "
operator|)
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|SCREAMER_MUTE_SPEAKER
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"HEADPHONES "
operator|)
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|SCREAMER_MUTE_HEADPHONES
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|device_id
operator|==
literal|5
operator|||
name|d
operator|->
name|device_id
operator|==
literal|11
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Enabling programmable output.\n"
operator|)
argument_list|)
expr_stmt|;
name|x
operator||=
name|SCREAMER_PROG_OUTPUT0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|device_id
operator|==
literal|8
operator|||
name|d
operator|->
name|device_id
operator|==
literal|11
condition|)
block|{
name|x
operator|&=
operator|~
name|SCREAMER_MUTE_SPEAKER
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|x
operator||=
name|SCREAMER_PROG_OUTPUT1
expr_stmt|;
comment|/* enable speaker. */
block|}
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR1
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|d
operator|->
name|output_mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|screamer_read_status
parameter_list|(
name|struct
name|davbus_softc
modifier|*
name|d
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
name|int
name|headphones
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|device_id
condition|)
block|{
case|case
literal|5
case|:
comment|/* Sawtooth */
name|headphones
operator|=
operator|(
name|status
operator|&
literal|0x4
operator|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
case|case
literal|11
case|:
comment|/* iMac DV */
comment|/* The iMac DV has 2 headphone outputs. */
name|headphones
operator|=
operator|(
name|status
operator|&
literal|0x7
operator|)
expr_stmt|;
break|break;
default|default:
name|headphones
operator|=
operator|(
name|status
operator|&
literal|0x8
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|headphones
condition|)
return|return
operator|(
literal|1
operator|<<
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|<<
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|screamer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|davbus_softc
modifier|*
name|d
decl_stmt|;
name|int
name|lval
decl_stmt|,
name|rval
decl_stmt|;
name|lval
operator|=
operator|(
operator|(
literal|100
operator|-
name|left
operator|)
operator|*
literal|15
operator|/
literal|100
operator|)
operator|&
literal|0xf
expr_stmt|;
name|rval
operator|=
operator|(
operator|(
literal|100
operator|-
name|right
operator|)
operator|*
literal|15
operator|/
literal|100
operator|)
operator|&
literal|0xf
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"volume %d %d\n"
operator|,
name|lval
operator|,
name|rval
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|SOUND_MIXER_VOLUME
case|:
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR2
argument_list|,
operator|(
name|lval
operator|<<
literal|6
operator|)
operator||
name|rval
argument_list|)
expr_stmt|;
name|screamer_write_locked
argument_list|(
name|d
argument_list|,
name|SCREAMER_CODEC_ADDR4
argument_list|,
operator|(
name|lval
operator|<<
literal|6
operator|)
operator||
name|rval
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|screamer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|davbus_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|davbus_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|dbdma_irq
decl_stmt|,
modifier|*
name|cintr
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|char
name|compat
index|[
literal|64
index|]
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|oirq
decl_stmt|,
name|err
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|aoa
operator|.
name|sc_dev
operator|=
name|self
expr_stmt|;
name|sc
operator|->
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|sc
operator|->
name|soundnode
operator|=
name|OF_child
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Map the controller register space. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Map the DBDMA channel register space. */
name|rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|aoa
operator|.
name|sc_odma
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|aoa
operator|.
name|sc_odma
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Establish the DBDMA channel edge-triggered interrupt. */
name|rid
operator|=
literal|1
expr_stmt|;
name|dbdma_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbdma_irq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|oirq
operator|=
name|rman_get_start
argument_list|(
name|dbdma_irq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"interrupting at irq %d\n"
operator|,
name|oirq
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|powerpc_config_intr
argument_list|(
name|oirq
argument_list|,
name|INTR_TRIGGER_EDGE
argument_list|,
name|INTR_POLARITY_LOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|snd_setup_intr
argument_list|(
name|self
argument_list|,
name|dbdma_irq
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|aoa_interrupt
argument_list|,
name|sc
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
comment|/* Now initialize the controller. */
name|bzero
argument_list|(
name|compat
argument_list|,
sizeof|sizeof
argument_list|(
name|compat
argument_list|)
argument_list|)
expr_stmt|;
name|OF_getprop
argument_list|(
name|sc
operator|->
name|soundnode
argument_list|,
literal|"compatible"
argument_list|,
name|compat
argument_list|,
sizeof|sizeof
argument_list|(
name|compat
argument_list|)
argument_list|)
expr_stmt|;
name|OF_getprop
argument_list|(
name|sc
operator|->
name|soundnode
argument_list|,
literal|"device-id"
argument_list|,
operator|&
name|sc
operator|->
name|device_id
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|,
literal|"DAVbus"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"codec:<%s>\n"
argument_list|,
name|compat
argument_list|)
expr_stmt|;
comment|/* Setup the control interrupt. */
name|rid
operator|=
literal|0
expr_stmt|;
name|cintr
operator|=
name|bus_alloc_resource_any
argument_list|(
name|self
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cintr
operator|!=
name|NULL
condition|)
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|cintr
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|davbus_cint
argument_list|,
name|sc
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
comment|/* Initialize controller registers. */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|reg
argument_list|,
name|DAVBUS_SOUND_CTRL
argument_list|,
name|DAVBUS_INPUT_SUBFRAME0
operator||
name|DAVBUS_OUTPUT_SUBFRAME0
operator||
name|DAVBUS_RATE_44100
operator||
name|DAVBUS_INTR_PORTCHG
argument_list|)
expr_stmt|;
comment|/* Attach DBDMA engine and PCM layer */
name|err
operator|=
name|aoa_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Install codec module */
if|if
condition|(
name|strcmp
argument_list|(
name|compat
argument_list|,
literal|"screamer"
argument_list|)
operator|==
literal|0
condition|)
name|mixer_init
argument_list|(
name|self
argument_list|,
operator|&
name|screamer_mixer_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|compat
argument_list|,
literal|"burgundy"
argument_list|)
operator|==
literal|0
condition|)
name|mixer_init
argument_list|(
name|self
argument_list|,
operator|&
name|burgundy_mixer_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|davbus_cint
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|davbus_softc
modifier|*
name|d
init|=
name|ptr
decl_stmt|;
name|u_int
name|reg
decl_stmt|,
name|status
decl_stmt|,
name|mask
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reg
operator|=
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_SOUND_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|DAVBUS_PORTCHG
condition|)
block|{
name|status
operator|=
name|bus_read_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_CODEC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|read_status
operator|&&
name|d
operator|->
name|set_outputs
condition|)
block|{
name|mask
operator|=
call|(
modifier|*
name|d
operator|->
name|read_status
call|)
argument_list|(
name|d
argument_list|,
name|status
argument_list|)
expr_stmt|;
call|(
modifier|*
name|d
operator|->
name|set_outputs
call|)
argument_list|(
name|d
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the interrupt. */
name|bus_write_4
argument_list|(
name|d
operator|->
name|reg
argument_list|,
name|DAVBUS_SOUND_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

