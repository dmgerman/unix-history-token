begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Orion Hodson<oho@acm.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THEPOSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * als4000.c - driver for the Avance Logic ALS 4000 chipset.  *  * The ALS4000 is effectively an SB16 with a PCI interface.  *  * This driver derives from ALS4000a.PDF, Bart Hartgers alsa driver, and  * SB16 register descriptions.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/isa/sb.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/als4000.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Debugging macro's */
end_comment

begin_undef
undef|#
directive|undef
name|DEB
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|DEB
end_ifndef

begin_define
define|#
directive|define
name|DEB
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* x */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEB */
end_comment

begin_define
define|#
directive|define
name|ALS_DEFAULT_BUFSZ
value|16384
end_define

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Structures */
end_comment

begin_struct_decl
struct_decl|struct
name|sc_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|sc_chinfo
block|{
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|format
decl_stmt|,
name|speed
decl_stmt|,
name|phys_buf
decl_stmt|,
name|bps
decl_stmt|;
name|u_int32_t
name|dma_active
range|:
literal|1
decl_stmt|,
name|dma_was_active
range|:
literal|1
decl_stmt|;
name|u_int8_t
name|gcr_fifo_status
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sc_info
block|{
name|device_t
name|dev
decl_stmt|;
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|int
name|regid
decl_stmt|,
name|irqid
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|struct
name|sc_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Channel caps */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|als_format
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|als_caps
init|=
block|{
literal|4000
block|,
literal|48000
block|,
name|als_format
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Register Utilities */
end_comment

begin_function
specifier|static
name|u_int32_t
name|als_gcr_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_GCR_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_GCR_DATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_gcr_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_GCR_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_GCR_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|als_intr_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_SB_MPU_IRQ
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_intr_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_SB_MPU_IRQ
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|als_mix_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|index
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_MIXER_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_MIXER_DATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_mix_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|index
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_MIXER_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_MIXER_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_esp_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|u_int32_t
name|tries
decl_stmt|,
name|v
decl_stmt|;
name|tries
operator|=
literal|1000
expr_stmt|;
do|do
block|{
name|v
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_ESP_WR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|~
name|v
operator|&
literal|0x80
condition|)
break|break;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|tries
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|tries
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"als_esp_wr timeout"
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_ESP_WR_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_esp_reset
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|tries
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_ESP_RST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_ESP_RST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|tries
operator|=
literal|1000
expr_stmt|;
do|do
block|{
name|u
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_ESP_RD_STATUS8
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|&
literal|0x80
condition|)
block|{
name|v
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|ALS_ESP_RD_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0xaa
condition|)
return|return
literal|0
return|;
else|else
break|break;
block|}
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|tries
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|tries
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"als_esp_reset timeout"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|als_ack_read
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|addr
parameter_list|)
block|{
name|u_int8_t
name|r
init|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|addr
argument_list|)
decl_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Common pcm channel implementation */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|alschan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|pch
expr_stmt|;
name|ch
operator|->
name|gcr_fifo_status
operator|=
name|ALS_GCR_FIFO0_STATUS
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|rch
expr_stmt|;
name|ch
operator|->
name|gcr_fifo_status
operator|=
name|ALS_GCR_FIFO1_STATUS
expr_stmt|;
block|}
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|bps
operator|=
literal|1
expr_stmt|;
name|ch
operator|->
name|format
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|speed
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|sc
operator|->
name|parent_dmat
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alschan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|format
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alschan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|,
modifier|*
name|other
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|other
operator|=
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|rch
else|:
operator|&
name|sc
operator|->
name|pch
expr_stmt|;
comment|/* Deny request if other dma channel is active */
if|if
condition|(
name|other
operator|->
name|dma_active
condition|)
block|{
name|ch
operator|->
name|speed
operator|=
name|other
operator|->
name|speed
expr_stmt|;
return|return
name|other
operator|->
name|speed
return|;
block|}
name|ch
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alschan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|blocksize
operator|>
name|sc
operator|->
name|bufsz
operator|/
literal|2
condition|)
block|{
name|blocksize
operator|=
name|sc
operator|->
name|bufsz
operator|/
literal|2
expr_stmt|;
block|}
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
literal|2
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alschan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int32_t
name|pos
decl_stmt|,
name|sz
decl_stmt|;
name|pos
operator|=
name|als_gcr_rd
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|ch
operator|->
name|gcr_fifo_status
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|sz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|*
name|sz
operator|-
name|pos
operator|-
literal|1
operator|)
operator|%
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|alschan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|&
name|als_caps
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_set_speed
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|other
decl_stmt|;
name|other
operator|=
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|rch
else|:
operator|&
name|sc
operator|->
name|pch
expr_stmt|;
if|if
condition|(
name|other
operator|->
name|dma_active
operator|==
literal|0
condition|)
block|{
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|ALS_ESP_SAMPLE_RATE
argument_list|)
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|speed
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"speed locked at %d (tried %d)\n"
argument_list|,
name|other
operator|->
name|speed
argument_list|,
name|ch
operator|->
name|speed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Playback channel implementation */
end_comment

begin_define
define|#
directive|define
name|ALS_8BIT_CMD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ (x), (y), DSP_DMA8,  DSP_CMD_DMAPAUSE_8  }
end_define

begin_define
define|#
directive|define
name|ALS_16BIT_CMD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ (x), (y),	DSP_DMA16, DSP_CMD_DMAPAUSE_16 }
end_define

begin_struct
struct|struct
name|playback_command
block|{
name|u_int32_t
name|pcm_format
decl_stmt|;
comment|/* newpcm format */
name|u_int8_t
name|format_val
decl_stmt|;
comment|/* sb16 format value */
name|u_int8_t
name|dma_prog
decl_stmt|;
comment|/* sb16 dma program */
name|u_int8_t
name|dma_stop
decl_stmt|;
comment|/* sb16 stop register */
block|}
decl|static const
name|playback_cmds
index|[]
init|=
block|{
name|ALS_8BIT_CMD
argument_list|(
name|AFMT_U8
argument_list|,
name|DSP_MODE_U8MONO
argument_list|)
block|,
name|ALS_8BIT_CMD
argument_list|(
name|AFMT_U8
operator||
name|AFMT_STEREO
argument_list|,
name|DSP_MODE_U8STEREO
argument_list|)
block|,
name|ALS_16BIT_CMD
argument_list|(
name|AFMT_S16_LE
argument_list|,
name|DSP_MODE_S16MONO
argument_list|)
block|,
name|ALS_16BIT_CMD
argument_list|(
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
argument_list|,
name|DSP_MODE_S16STEREO
argument_list|)
block|, }
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|struct
name|playback_command
modifier|*
name|als_get_playback_command
parameter_list|(
name|u_int32_t
name|format
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|playback_cmds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|playback_cmds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|playback_cmds
index|[
name|i
index|]
operator|.
name|pcm_format
operator|==
name|format
condition|)
block|{
return|return
operator|&
name|playback_cmds
index|[
name|i
index|]
return|;
block|}
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"als_get_playback_command: invalid format 0x%08x\n"
argument_list|,
name|format
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|playback_cmds
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_playback_start
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
specifier|const
name|struct
name|playback_command
modifier|*
name|p
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|buf
decl_stmt|,
name|bufsz
decl_stmt|,
name|count
decl_stmt|,
name|dma_prog
decl_stmt|;
name|buf
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|bufsz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|count
operator|=
name|bufsz
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|format
operator|&
name|AFMT_16BIT
condition|)
name|count
operator|/=
literal|2
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|DSP_CMD_SPKON
argument_list|)
expr_stmt|;
name|als_set_speed
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_DMA0_START
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_DMA0_MODE
argument_list|,
operator|(
name|bufsz
operator|-
literal|1
operator|)
operator||
literal|0x180000
argument_list|)
expr_stmt|;
name|p
operator|=
name|als_get_playback_command
argument_list|(
name|ch
operator|->
name|format
argument_list|)
expr_stmt|;
name|dma_prog
operator|=
name|p
operator|->
name|dma_prog
operator||
name|DSP_F16_DAC
operator||
name|DSP_F16_AUTO
operator||
name|DSP_F16_FIFO_ON
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|dma_prog
argument_list|)
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|format_val
argument_list|)
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|count
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|count
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_playback_stop
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
specifier|const
name|struct
name|playback_command
modifier|*
name|p
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|active
decl_stmt|;
name|active
operator|=
name|ch
operator|->
name|dma_active
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|p
operator|=
name|als_get_playback_command
argument_list|(
name|ch
operator|->
name|format
argument_list|)
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|dma_stop
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
return|return
name|active
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alspchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|als_playback_start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|als_playback_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|alspchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|alschan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|alschan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|alschan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|alschan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|alspchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|alschan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|alschan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|alspchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Capture channel implementation */
end_comment

begin_function
specifier|static
name|u_int8_t
name|als_get_fifo_format
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|AFMT_U8
case|:
return|return
name|ALS_FIFO1_8BIT
return|;
case|case
name|AFMT_U8
operator||
name|AFMT_STEREO
case|:
return|return
name|ALS_FIFO1_8BIT
operator||
name|ALS_FIFO1_STEREO
return|;
case|case
name|AFMT_S16_LE
case|:
return|return
name|ALS_FIFO1_SIGNED
return|;
case|case
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
case|:
return|return
name|ALS_FIFO1_SIGNED
operator||
name|ALS_FIFO1_STEREO
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"format not found: 0x%08x\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
name|ALS_FIFO1_8BIT
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_capture_start
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|buf
decl_stmt|,
name|bufsz
decl_stmt|,
name|count
decl_stmt|,
name|dma_prog
decl_stmt|;
name|buf
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|bufsz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|count
operator|=
name|bufsz
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|format
operator|&
name|AFMT_16BIT
condition|)
name|count
operator|/=
literal|2
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|als_esp_wr
argument_list|(
name|sc
argument_list|,
name|DSP_CMD_SPKON
argument_list|)
expr_stmt|;
name|als_set_speed
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_FIFO1_START
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_FIFO1_COUNT
argument_list|,
operator|(
name|bufsz
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_FIFO1_LENGTH_LO
argument_list|,
name|count
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_FIFO1_LENGTH_HI
argument_list|,
name|count
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|dma_prog
operator|=
name|ALS_FIFO1_RUN
operator||
name|als_get_fifo_format
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|format
argument_list|)
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_FIFO1_CONTROL
argument_list|,
name|dma_prog
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_capture_stop
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|active
decl_stmt|;
name|active
operator|=
name|ch
operator|->
name|dma_active
expr_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_FIFO1_CONTROL
argument_list|,
name|ALS_FIFO1_STOP
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
return|return
name|active
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alsrchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|als_capture_start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|als_capture_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|alsrchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|alschan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|alschan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|alschan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|alschan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|alsrchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|alschan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|alschan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|alsrchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Mixer related */
end_comment

begin_comment
comment|/*  * ALS4000 has an sb16 mixer, with some additional controls that we do  * not yet a means to support.  */
end_comment

begin_struct
struct|struct
name|sb16props
block|{
name|u_int8_t
name|lreg
decl_stmt|;
name|u_int8_t
name|rreg
decl_stmt|;
name|u_int8_t
name|bits
decl_stmt|;
name|u_int8_t
name|oselect
decl_stmt|;
name|u_int8_t
name|iselect
decl_stmt|;
comment|/* left input mask */
block|}
decl|static const
name|amt
index|[
name|SOUND_MIXER_NRDEVICES
index|]
init|=
block|{
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|=
block|{
literal|0x30
block|,
literal|0x31
block|,
literal|5
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
index|[
name|SOUND_MIXER_PCM
index|]
operator|=
block|{
literal|0x32
block|,
literal|0x33
block|,
literal|5
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
index|[
name|SOUND_MIXER_SYNTH
index|]
operator|=
block|{
literal|0x34
block|,
literal|0x35
block|,
literal|5
block|,
literal|0x60
block|,
literal|0x40
block|}
block|,
index|[
name|SOUND_MIXER_CD
index|]
operator|=
block|{
literal|0x36
block|,
literal|0x37
block|,
literal|5
block|,
literal|0x06
block|,
literal|0x04
block|}
block|,
index|[
name|SOUND_MIXER_LINE
index|]
operator|=
block|{
literal|0x38
block|,
literal|0x39
block|,
literal|5
block|,
literal|0x18
block|,
literal|0x10
block|}
block|,
index|[
name|SOUND_MIXER_MIC
index|]
operator|=
block|{
literal|0x3a
block|,
literal|0x00
block|,
literal|5
block|,
literal|0x01
block|,
literal|0x01
block|}
block|,
index|[
name|SOUND_MIXER_SPEAKER
index|]
operator|=
block|{
literal|0x3b
block|,
literal|0x00
block|,
literal|2
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
index|[
name|SOUND_MIXER_IGAIN
index|]
operator|=
block|{
literal|0x3f
block|,
literal|0x40
block|,
literal|2
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
index|[
name|SOUND_MIXER_OGAIN
index|]
operator|=
block|{
literal|0x41
block|,
literal|0x42
block|,
literal|2
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* The following have register values but no h/w implementation */
index|[
name|SOUND_MIXER_TREBLE
index|]
operator|=
block|{
literal|0x44
block|,
literal|0x45
block|,
literal|4
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
index|[
name|SOUND_MIXER_BASS
index|]
operator|=
block|{
literal|0x46
block|,
literal|0x47
block|,
literal|4
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|alsmix_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|amt
index|[
name|i
index|]
operator|.
name|bits
condition|)
name|v
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|amt
index|[
name|i
index|]
operator|.
name|iselect
condition|)
name|v
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alsmix_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int32_t
name|r
decl_stmt|,
name|l
decl_stmt|,
name|v
decl_stmt|,
name|mask
decl_stmt|;
comment|/* Fill upper n bits in mask with 1's */
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|amt
index|[
name|dev
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
literal|8
operator|-
name|amt
index|[
name|dev
index|]
operator|.
name|bits
operator|)
expr_stmt|;
name|l
operator|=
operator|(
name|left
operator|*
name|mask
operator|/
literal|100
operator|)
operator|&
name|mask
expr_stmt|;
name|v
operator|=
name|als_mix_rd
argument_list|(
name|sc
argument_list|,
name|amt
index|[
name|dev
index|]
operator|.
name|lreg
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|amt
index|[
name|dev
index|]
operator|.
name|lreg
argument_list|,
name|l
operator||
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|amt
index|[
name|dev
index|]
operator|.
name|rreg
condition|)
block|{
name|r
operator|=
operator|(
name|right
operator|*
name|mask
operator|/
literal|100
operator|)
operator|&
name|mask
expr_stmt|;
name|v
operator|=
name|als_mix_rd
argument_list|(
name|sc
argument_list|,
name|amt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|amt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|,
name|r
operator||
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Zero gain does not mute channel from output, but this does. */
name|v
operator|=
name|als_mix_rd
argument_list|(
name|sc
argument_list|,
name|SB16_OMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|r
operator|==
literal|0
condition|)
block|{
name|v
operator|&=
operator|~
name|amt
index|[
name|dev
index|]
operator|.
name|oselect
expr_stmt|;
block|}
else|else
block|{
name|v
operator||=
name|amt
index|[
name|dev
index|]
operator|.
name|oselect
expr_stmt|;
block|}
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|SB16_OMASK
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alsmix_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
name|l
operator|=
name|r
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|l
operator||=
name|amt
index|[
name|i
index|]
operator|.
name|iselect
expr_stmt|;
name|r
operator||=
name|amt
index|[
name|i
index|]
operator|.
name|iselect
operator|<<
literal|1
expr_stmt|;
block|}
block|}
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|SB16_IMASK_L
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|SB16_IMASK_R
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|als_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|alsmix_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|alsmix_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|alsmix_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|als_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Interrupt Handler */
end_comment

begin_function
specifier|static
name|void
name|als_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|p
decl_stmt|;
name|u_int8_t
name|intr
decl_stmt|,
name|sb_status
decl_stmt|;
name|intr
operator|=
name|als_intr_rd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|&
literal|0x80
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|&
literal|0x40
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
comment|/* ACK interrupt in PCI core */
name|als_intr_wr
argument_list|(
name|sc
argument_list|,
name|intr
argument_list|)
expr_stmt|;
comment|/* ACK interrupt in SB core */
name|sb_status
operator|=
name|als_mix_rd
argument_list|(
name|sc
argument_list|,
name|IRQ_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb_status
operator|&
name|ALS_IRQ_STATUS8
condition|)
name|als_ack_read
argument_list|(
name|sc
argument_list|,
name|ALS_ESP_RD_STATUS8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb_status
operator|&
name|ALS_IRQ_STATUS16
condition|)
name|als_ack_read
argument_list|(
name|sc
argument_list|,
name|ALS_ESP_RD_STATUS16
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb_status
operator|&
name|ALS_IRQ_MPUIN
condition|)
name|als_ack_read
argument_list|(
name|sc
argument_list|,
name|ALS_MIDI_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb_status
operator|&
name|ALS_IRQ_CR1E
condition|)
name|als_ack_read
argument_list|(
name|sc
argument_list|,
name|ALS_CR1E_ACK_PORT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* H/W initialization */
end_comment

begin_function
specifier|static
name|int
name|als_init
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|v
decl_stmt|;
comment|/* Reset Chip */
if|if
condition|(
name|als_esp_reset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Enable write on DMA_SETUP register */
name|v
operator|=
name|als_mix_rd
argument_list|(
name|sc
argument_list|,
name|ALS_SB16_CONFIG
argument_list|)
expr_stmt|;
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_SB16_CONFIG
argument_list|,
name|v
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Select DMA0 */
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_SB16_DMA_SETUP
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Disable write on DMA_SETUP register */
name|als_mix_wr
argument_list|(
name|sc
argument_list|,
name|ALS_SB16_CONFIG
argument_list|,
name|v
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
name|v
operator|=
name|als_gcr_rd
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_MISC
argument_list|)
expr_stmt|;
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_MISC
argument_list|,
name|v
operator||
literal|0x28000
argument_list|)
expr_stmt|;
comment|/* Black out GCR DMA registers */
for|for
control|(
name|i
operator|=
literal|0x91
init|;
name|i
operator|<=
literal|0x96
condition|;
name|i
operator|++
control|)
block|{
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Emulation mode */
name|v
operator|=
name|als_gcr_rd
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_DMA_EMULATION
argument_list|)
expr_stmt|;
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_DMA_EMULATION
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"GCR_DMA_EMULATION 0x%08x\n"
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_uninit
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Disable interrupts */
name|als_gcr_wr
argument_list|(
name|sc
argument_list|,
name|ALS_GCR_MISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Probe and attach card */
end_comment

begin_function
specifier|static
name|int
name|als_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|ALS_PCI_ID0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Avance Logic ALS4000"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|als_resource_free
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|reg
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|regid
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ih
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|parent_dmat
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|parent_dmat
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|als_resource_grab
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|regid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|regid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ALS_CONFIG_SPACE_BYTES
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate register space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_AV
argument_list|,
name|als_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to setup interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|ALS_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|2
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|sc
operator|->
name|bufsz
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
return|return
literal|0
return|;
name|bad
label|:
name|als_resource_free
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * By default the power to the various components on the          * ALS4000 is entirely controlled by the pci powerstate.  We          * could attempt finer grained control by setting GCR6.31. 	 */
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500000
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
block|{
comment|/* Reset the power state. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"chip is in D%d power mode "
literal|"-- setting to D0\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ALS_PCI_POWERREG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x03
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"chip is in D%d power mode "
literal|"-- setting to D0\n"
argument_list|,
name|data
operator|&
literal|0x03
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
literal|0x03
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|ALS_PCI_POWERREG
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|als_resource_grab
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad_attach
goto|;
block|}
if|if
condition|(
name|als_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize hardware\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad_attach
goto|;
block|}
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|als_mixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad_attach
goto|;
block|}
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to register pcm entries\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad_attach
goto|;
block|}
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|alspchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|alsrchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx irq %ld %s"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_als4000
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad_attach
label|:
name|als_resource_free
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|als_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|als_resource_free
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|pch
operator|.
name|dma_was_active
operator|=
name|als_playback_stop
argument_list|(
operator|&
name|sc
operator|->
name|pch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rch
operator|.
name|dma_was_active
operator|=
name|als_capture_stop
argument_list|(
operator|&
name|sc
operator|->
name|rch
argument_list|)
expr_stmt|;
name|als_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|als_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|als_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the card\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mixer_reinit
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|pch
operator|.
name|dma_was_active
condition|)
block|{
name|als_playback_start
argument_list|(
operator|&
name|sc
operator|->
name|pch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rch
operator|.
name|dma_was_active
condition|)
block|{
name|als_capture_start
argument_list|(
operator|&
name|sc
operator|->
name|rch
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|als_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|als_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|als_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|als_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|als_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|als_pci_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|als_driver
init|=
block|{
literal|"pcm"
block|,
name|als_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_als4000
argument_list|,
name|pci
argument_list|,
name|als_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_als4000
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_als4000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

