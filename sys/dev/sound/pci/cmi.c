begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Orion Hodson<O.Hodson@cs.ucl.ac.uk>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THEPOSSIBILITY OF  * SUCH DAMAGE.  *  * This driver exists largely as a result of other people's efforts.  * Much of register handling is based on NetBSD CMI8x38 audio driver  * by Takuya Shiozaki<AoiMoe@imou.to>.  Chen-Li Tien  *<cltien@cmedia.com.tw> clarified points regarding the DMA related  * registers and the 8738 mixer devices.  His Linux driver was also a  * useful reference point.  *  * TODO: MIDI  *  * SPDIF contributed by Gerhard Gonter<gonter@whisky.wu-wien.ac.at>.  *  * This card/code does not always manage to sample at 44100 - actual  * rate drifts slightly between recordings (usually 0-3%).  No  * differences visible in register dumps between times that work and  * those that don't.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/cmireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/isa/sb.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/mpu401.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_include
include|#
directive|include
file|"mpufoi_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Supported chip ID's */
end_comment

begin_define
define|#
directive|define
name|CMI8338A_PCI_ID
value|0x010013f6
end_define

begin_define
define|#
directive|define
name|CMI8338B_PCI_ID
value|0x010113f6
end_define

begin_define
define|#
directive|define
name|CMI8738_PCI_ID
value|0x011113f6
end_define

begin_define
define|#
directive|define
name|CMI8738B_PCI_ID
value|0x011213f6
end_define

begin_comment
comment|/* Buffer size max is 64k for permitted DMA boundaries */
end_comment

begin_define
define|#
directive|define
name|CMI_DEFAULT_BUFSZ
value|16384
end_define

begin_comment
comment|/* Interrupts per length of buffer */
end_comment

begin_define
define|#
directive|define
name|CMI_INTR_PER_BUFFER
value|2
end_define

begin_comment
comment|/* Clarify meaning of named defines in cmireg.h */
end_comment

begin_define
define|#
directive|define
name|CMPCI_REG_DMA0_MAX_SAMPLES
value|CMPCI_REG_DMA0_BYTES
end_define

begin_define
define|#
directive|define
name|CMPCI_REG_DMA0_INTR_SAMPLES
value|CMPCI_REG_DMA0_SAMPLES
end_define

begin_define
define|#
directive|define
name|CMPCI_REG_DMA1_MAX_SAMPLES
value|CMPCI_REG_DMA1_BYTES
end_define

begin_define
define|#
directive|define
name|CMPCI_REG_DMA1_INTR_SAMPLES
value|CMPCI_REG_DMA1_SAMPLES
end_define

begin_comment
comment|/* Our indication of custom mixer control */
end_comment

begin_define
define|#
directive|define
name|CMPCI_NON_SB16_CONTROL
value|0xff
end_define

begin_comment
comment|/* Debugging macro's */
end_comment

begin_undef
undef|#
directive|undef
name|DEB
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|DEB
end_ifndef

begin_define
define|#
directive|define
name|DEB
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* x */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEB */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBMIX
end_ifndef

begin_define
define|#
directive|define
name|DEBMIX
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* x */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBMIX */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Structures */
end_comment

begin_struct_decl
struct_decl|struct
name|sc_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|sc_chinfo
block|{
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|,
name|phys_buf
decl_stmt|,
name|bps
decl_stmt|;
name|u_int32_t
name|dma_active
range|:
literal|1
decl_stmt|,
name|dma_was_active
range|:
literal|1
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sc_info
block|{
name|device_t
name|dev
decl_stmt|;
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|int
name|regid
decl_stmt|,
name|irqid
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
name|int
name|spdif_enabled
decl_stmt|;
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|struct
name|sc_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
name|struct
name|mpu401
modifier|*
name|mpu
decl_stmt|;
name|mpu401_intr_t
modifier|*
name|mpu_intr
decl_stmt|;
name|struct
name|resource
modifier|*
name|mpu_reg
decl_stmt|;
name|int
name|mpu_regid
decl_stmt|;
name|bus_space_tag_t
name|mpu_bt
decl_stmt|;
name|bus_space_handle_t
name|mpu_bh
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Channel caps */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|cmi_fmt
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|cmi_caps
init|=
block|{
literal|5512
block|,
literal|48000
block|,
name|cmi_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Register Utilities */
end_comment

begin_function
specifier|static
name|u_int32_t
name|cmi_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmi_rd: failed 0x%04x %d\n"
argument_list|,
name|regno
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0xFFFFFFFF
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_partial_wr4
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|shift
parameter_list|,
name|u_int32_t
name|mask
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|r
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r
operator|&=
operator|~
operator|(
name|mask
operator|<<
name|shift
operator|)
expr_stmt|;
name|r
operator||=
name|val
operator|<<
name|shift
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|r
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_clr4
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
name|mask
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|r
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r
operator|&=
operator|~
name|mask
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|r
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_set4
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
name|mask
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|r
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r
operator||=
name|mask
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|r
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Rate Mapping */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmi_rates
index|[]
init|=
block|{
literal|5512
block|,
literal|8000
block|,
literal|11025
block|,
literal|16000
block|,
literal|22050
block|,
literal|32000
block|,
literal|44100
block|,
literal|48000
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_CMI_RATES
value|(sizeof(cmi_rates)/sizeof(cmi_rates[0]))
end_define

begin_comment
comment|/* cmpci_rate_to_regvalue returns sampling freq selector for FCR1  * register - reg order is 5k,11k,22k,44k,8k,16k,32k,48k */
end_comment

begin_function
specifier|static
name|u_int32_t
name|cmpci_rate_to_regvalue
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CMI_RATES
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rate
operator|<
operator|(
operator|(
name|cmi_rates
index|[
name|i
index|]
operator|+
name|cmi_rates
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|2
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmpci_rate_to_regvalue: %d -> %d\n"
argument_list|,
name|rate
argument_list|,
name|cmi_rates
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator||
operator|(
name|i
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0x07
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmpci_regvalue_to_rate
parameter_list|(
name|u_int32_t
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
operator|(
name|r
operator|<<
literal|1
operator|)
operator||
operator|(
name|r
operator|>>
literal|2
operator|)
operator|)
operator|&
literal|0x07
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmpci_regvalue_to_rate: %d -> %d\n"
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cmi_rates
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ADC/DAC control - there are 2 dma channels on 8738, either can be  * playback or capture.  We use ch0 for playback and ch1 for capture. */
end_comment

begin_function
specifier|static
name|void
name|cmi_dma_prog
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|,
name|u_int32_t
name|base
parameter_list|)
block|{
name|u_int32_t
name|s
decl_stmt|,
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|ch
operator|->
name|phys_buf
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
name|ch
operator|->
name|phys_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sz
operator|=
operator|(
name|u_int32_t
operator|)
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|s
operator|=
name|sz
operator|/
name|ch
operator|->
name|bps
operator|-
literal|1
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|base
operator|+
literal|4
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|i
operator|=
name|sz
operator|/
operator|(
name|ch
operator|->
name|bps
operator|*
name|CMI_INTR_PER_BUFFER
operator|)
operator|-
literal|1
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|base
operator|+
literal|6
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_ch0_start
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|cmi_dma_prog
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CMPCI_REG_DMA0_BASE
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_ENABLE
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|CMPCI_REG_CH0_INTR_ENABLE
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|cmi_ch0_stop
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|r
init|=
name|ch
operator|->
name|dma_active
decl_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|CMPCI_REG_CH0_INTR_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_ENABLE
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_RESET
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_RESET
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_ch1_start
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|cmi_dma_prog
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CMPCI_REG_DMA1_BASE
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH1_ENABLE
argument_list|)
expr_stmt|;
comment|/* Enable Interrupts */
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|CMPCI_REG_CH1_INTR_ENABLE
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmi_ch1_start: dma prog\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|cmi_ch1_stop
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|r
init|=
name|ch
operator|->
name|dma_active
decl_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|CMPCI_REG_CH1_INTR_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH1_ENABLE
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH1_RESET
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH1_RESET
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_spdif_speed
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|speed
parameter_list|)
block|{
name|u_int32_t
name|fcr1
decl_stmt|,
name|lcr
decl_stmt|,
name|mcr
decl_stmt|;
if|if
condition|(
name|speed
operator|>=
literal|44100
condition|)
block|{
name|fcr1
operator|=
name|CMPCI_REG_SPDIF0_ENABLE
expr_stmt|;
name|lcr
operator|=
name|CMPCI_REG_XSPDIF_ENABLE
expr_stmt|;
name|mcr
operator|=
operator|(
name|speed
operator|==
literal|48000
operator|)
condition|?
name|CMPCI_REG_W_SPDIF_48L
operator||
name|CMPCI_REG_SPDIF_48K
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fcr1
operator|=
name|mcr
operator|=
name|lcr
operator|=
literal|0
expr_stmt|;
block|}
name|cmi_partial_wr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_MISC
argument_list|,
literal|0
argument_list|,
name|CMPCI_REG_W_SPDIF_48L
operator||
name|CMPCI_REG_SPDIF_48K
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cmi_partial_wr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
literal|0
argument_list|,
name|CMPCI_REG_SPDIF0_ENABLE
argument_list|,
name|fcr1
argument_list|)
expr_stmt|;
name|cmi_partial_wr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_LEGACY_CTRL
argument_list|,
literal|0
argument_list|,
name|CMPCI_REG_XSPDIF_ENABLE
argument_list|,
name|lcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Channel Interface implementation */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|cmichan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|pch
else|:
operator|&
name|sc
operator|->
name|rch
decl_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|bps
operator|=
literal|1
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|sc
operator|->
name|parent_dmat
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmichan_init failed\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|cmi_dma_prog
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CMPCI_REG_DMA0_BASE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmi_dma_prog
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CMPCI_REG_DMA1_BASE
argument_list|)
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmichan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|f
decl_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_S16_LE
condition|)
block|{
name|f
operator|=
name|CMPCI_REG_FORMAT_16BIT
expr_stmt|;
name|ch
operator|->
name|bps
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|CMPCI_REG_FORMAT_8BIT
expr_stmt|;
name|ch
operator|->
name|bps
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|AFMT_STEREO
condition|)
block|{
name|f
operator||=
name|CMPCI_REG_FORMAT_STEREO
expr_stmt|;
name|ch
operator|->
name|bps
operator|*=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|f
operator||=
name|CMPCI_REG_FORMAT_MONO
expr_stmt|;
block|}
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|cmi_partial_wr4
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|CMPCI_REG_CHANNEL_FORMAT
argument_list|,
name|CMPCI_REG_CH0_FORMAT_SHIFT
argument_list|,
name|CMPCI_REG_CH0_FORMAT_MASK
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmi_partial_wr4
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|CMPCI_REG_CHANNEL_FORMAT
argument_list|,
name|CMPCI_REG_CH1_FORMAT_SHIFT
argument_list|,
name|CMPCI_REG_CH1_FORMAT_MASK
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmichan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|r
decl_stmt|,
name|rsp
decl_stmt|;
name|r
operator|=
name|cmpci_rate_to_regvalue
argument_list|(
name|speed
argument_list|)
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|speed
operator|<
literal|44100
condition|)
block|{
comment|/* disable if req before rate change */
name|cmi_spdif_speed
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
name|cmi_partial_wr4
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_DAC_FS_SHIFT
argument_list|,
name|CMPCI_REG_DAC_FS_MASK
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|>=
literal|44100
operator|&&
name|ch
operator|->
name|parent
operator|->
name|spdif_enabled
condition|)
block|{
comment|/* enable if req after rate change */
name|cmi_spdif_speed
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
name|rsp
operator|=
name|cmi_rd
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rsp
operator|>>=
name|CMPCI_REG_DAC_FS_SHIFT
expr_stmt|;
name|rsp
operator|&=
name|CMPCI_REG_DAC_FS_MASK
expr_stmt|;
block|}
else|else
block|{
name|cmi_partial_wr4
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_ADC_FS_SHIFT
argument_list|,
name|CMPCI_REG_ADC_FS_MASK
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|rsp
operator|=
name|cmi_rd
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rsp
operator|>>=
name|CMPCI_REG_ADC_FS_SHIFT
expr_stmt|;
name|rsp
operator|&=
name|CMPCI_REG_ADC_FS_MASK
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|cmpci_regvalue_to_rate
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmichan_setspeed (%s) %d -> %d (%d)\n"
argument_list|,
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
literal|"play"
else|:
literal|"rec"
argument_list|,
name|speed
argument_list|,
name|ch
operator|->
name|spd
argument_list|,
name|cmpci_regvalue_to_rate
argument_list|(
name|rsp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmichan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
comment|/* user has requested interrupts every blocksize bytes */
if|if
condition|(
name|blocksize
operator|>
name|sc
operator|->
name|bufsz
operator|/
name|CMI_INTR_PER_BUFFER
condition|)
block|{
name|blocksize
operator|=
name|sc
operator|->
name|bufsz
operator|/
name|CMI_INTR_PER_BUFFER
expr_stmt|;
block|}
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|CMI_INTR_PER_BUFFER
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmichan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|cmi_ch0_start
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|cmi_ch0_stop
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|cmi_ch1_start
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|cmi_ch1_stop
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmichan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|physptr
decl_stmt|,
name|bufptr
decl_stmt|,
name|sz
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|physptr
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_DMA0_BASE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|physptr
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_DMA1_BASE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|bufptr
operator|=
operator|(
name|physptr
operator|-
name|ch
operator|->
name|phys_buf
operator|+
name|sz
operator|-
name|ch
operator|->
name|bps
operator|)
operator|%
name|sz
expr_stmt|;
return|return
name|bufptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|u_int32_t
name|intrstat
decl_stmt|;
name|u_int32_t
name|toclear
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|intrstat
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_STATUS
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intrstat
operator|&
name|CMPCI_REG_ANY_INTR
operator|)
operator|!=
literal|0
condition|)
block|{
name|toclear
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|intrstat
operator|&
name|CMPCI_REG_CH0_INTR
condition|)
block|{
name|toclear
operator||=
name|CMPCI_REG_CH0_INTR_ENABLE
expr_stmt|;
comment|//cmi_clr4(sc, CMPCI_REG_INTR_CTRL, CMPCI_REG_CH0_INTR_ENABLE);
block|}
if|if
condition|(
name|intrstat
operator|&
name|CMPCI_REG_CH1_INTR
condition|)
block|{
name|toclear
operator||=
name|CMPCI_REG_CH1_INTR_ENABLE
expr_stmt|;
comment|//cmi_clr4(sc, CMPCI_REG_INTR_CTRL, CMPCI_REG_CH1_INTR_ENABLE);
block|}
if|if
condition|(
name|toclear
condition|)
block|{
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|toclear
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Signal interrupts to channel */
if|if
condition|(
name|intrstat
operator|&
name|CMPCI_REG_CH0_INTR
condition|)
block|{
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intrstat
operator|&
name|CMPCI_REG_CH1_INTR
condition|)
block|{
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|toclear
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|mpu_intr
condition|)
block|{
call|(
name|sc
operator|->
name|mpu_intr
call|)
argument_list|(
name|sc
operator|->
name|mpu
argument_list|)
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|cmichan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|&
name|cmi_caps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|cmichan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|cmichan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|cmichan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|cmichan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|cmichan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|cmichan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|cmichan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|cmichan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|cmichan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Mixer - sb16 with kinks */
end_comment

begin_function
specifier|static
name|void
name|cmimix_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|port
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_SBADDR
argument_list|,
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_SBDATA
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|cmimix_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|port
parameter_list|)
block|{
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_SBADDR
argument_list|,
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_int8_t
operator|)
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_SBDATA
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|sb16props
block|{
name|u_int8_t
name|rreg
decl_stmt|;
comment|/* right reg chan register */
name|u_int8_t
name|stereo
range|:
literal|1
decl_stmt|;
comment|/* (no explanation needed, honest) */
name|u_int8_t
name|rec
range|:
literal|1
decl_stmt|;
comment|/* recording source */
name|u_int8_t
name|bits
range|:
literal|3
decl_stmt|;
comment|/* num bits to represent maximum gain rep */
name|u_int8_t
name|oselect
decl_stmt|;
comment|/* output select mask */
name|u_int8_t
name|iselect
decl_stmt|;
comment|/* right input select mask */
block|}
decl|static const
name|cmt
index|[
name|SOUND_MIXER_NRDEVICES
index|]
init|=
block|{
index|[
name|SOUND_MIXER_SYNTH
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_FM_R
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
name|CMPCI_SB16_SW_FM
block|,
name|CMPCI_SB16_MIXER_FM_SRC_R
block|}
block|,
index|[
name|SOUND_MIXER_CD
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_CDDA_R
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
name|CMPCI_SB16_SW_CD
block|,
name|CMPCI_SB16_MIXER_CD_SRC_R
block|}
block|,
index|[
name|SOUND_MIXER_LINE
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_LINE_R
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
name|CMPCI_SB16_SW_LINE
block|,
name|CMPCI_SB16_MIXER_LINE_SRC_R
block|}
block|,
index|[
name|SOUND_MIXER_MIC
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_MIC
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
name|CMPCI_SB16_SW_MIC
block|,
name|CMPCI_SB16_MIXER_MIC_SRC
block|}
block|,
index|[
name|SOUND_MIXER_SPEAKER
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_SPEAKER
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_PCM
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_VOICE_R
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_MASTER_R
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* These controls are not implemented in CMI8738, but maybe at a 	   future date.  They are not documented in C-Media documentation, 	   though appear in other drivers for future h/w (ALSA, Linux, NetBSD). 	*/
index|[
name|SOUND_MIXER_IGAIN
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_INGAIN_R
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_OGAIN
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_OUTGAIN_R
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_BASS
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_BASS_R
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_TREBLE
index|]
operator|=
block|{
name|CMPCI_SB16_MIXER_TREBLE_R
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* The mic pre-amp is implemented with non-SB16 compatible 	   registers. */
index|[
name|SOUND_MIXER_MONITOR
index|]
operator|=
block|{
name|CMPCI_NON_SB16_CONTROL
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|MIXER_GAIN_REG_RTOL
parameter_list|(
name|r
parameter_list|)
value|(r - 1)
end_define

begin_function
specifier|static
name|int
name|cmimix_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmt
index|[
name|i
index|]
operator|.
name|bits
condition|)
name|v
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmt
index|[
name|i
index|]
operator|.
name|rec
condition|)
name|v
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_ADCMIX_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_ADCMIX_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_OUTMIX
argument_list|,
name|CMPCI_SB16_SW_CD
operator||
name|CMPCI_SB16_SW_MIC
operator||
name|CMPCI_SB16_SW_LINE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmimix_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int32_t
name|r
decl_stmt|,
name|l
decl_stmt|,
name|max
decl_stmt|;
name|u_int8_t
name|v
decl_stmt|;
name|max
operator|=
operator|(
literal|1
operator|<<
name|cmt
index|[
name|dev
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cmt
index|[
name|dev
index|]
operator|.
name|rreg
operator|==
name|CMPCI_NON_SB16_CONTROL
condition|)
block|{
comment|/* For time being this can only be one thing (mic in 		 * mic/aux reg) */
name|v
operator|=
name|cmi_rd
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_AUX_MIC
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xf0
expr_stmt|;
name|l
operator|=
name|left
operator|*
name|max
operator|/
literal|100
expr_stmt|;
comment|/* 3 bit gain with LSB MICGAIN off(1),on(1) -> 4 bit value */
name|v
operator||=
operator|(
operator|(
name|l
operator|<<
literal|1
operator|)
operator||
operator|(
operator|~
name|l
operator|>>
literal|3
operator|)
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|cmi_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_AUX_MIC
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|l
operator|=
operator|(
name|left
operator|*
name|max
operator|/
literal|100
operator|)
operator|<<
operator|(
literal|8
operator|-
name|cmt
index|[
name|dev
index|]
operator|.
name|bits
operator|)
expr_stmt|;
if|if
condition|(
name|cmt
index|[
name|dev
index|]
operator|.
name|stereo
condition|)
block|{
name|r
operator|=
operator|(
name|right
operator|*
name|max
operator|/
literal|100
operator|)
operator|<<
operator|(
literal|8
operator|-
name|cmt
index|[
name|dev
index|]
operator|.
name|bits
operator|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|MIXER_GAIN_REG_RTOL
argument_list|(
name|cmt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|cmt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|DEBMIX
argument_list|(
name|printf
argument_list|(
literal|"Mixer stereo write dev %d reg 0x%02x "
expr|\
literal|"value 0x%02x:0x%02x\n"
argument_list|,
name|dev
argument_list|,
name|MIXER_GAIN_REG_RTOL
argument_list|(
name|cmt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|)
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|l
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|cmt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|DEBMIX
argument_list|(
name|printf
argument_list|(
literal|"Mixer mono write dev %d reg 0x%02x "
expr|\
literal|"value 0x%02x:0x%02x\n"
argument_list|,
name|dev
argument_list|,
name|cmt
index|[
name|dev
index|]
operator|.
name|rreg
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Zero gain does not mute channel from output, but this does... */
name|v
operator|=
name|cmimix_rd
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_OUTMIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|r
operator|==
literal|0
condition|)
block|{
name|v
operator|&=
operator|~
name|cmt
index|[
name|dev
index|]
operator|.
name|oselect
expr_stmt|;
block|}
else|else
block|{
name|v
operator||=
name|cmt
index|[
name|dev
index|]
operator|.
name|oselect
expr_stmt|;
block|}
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_OUTMIX
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmimix_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|ml
decl_stmt|,
name|sl
decl_stmt|;
name|ml
operator|=
name|sl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|src
condition|)
block|{
if|if
condition|(
name|cmt
index|[
name|i
index|]
operator|.
name|stereo
condition|)
block|{
name|sl
operator||=
name|cmt
index|[
name|i
index|]
operator|.
name|iselect
expr_stmt|;
block|}
else|else
block|{
name|ml
operator||=
name|cmt
index|[
name|i
index|]
operator|.
name|iselect
expr_stmt|;
block|}
block|}
block|}
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_ADCMIX_R
argument_list|,
name|sl
operator||
name|ml
argument_list|)
expr_stmt|;
name|DEBMIX
argument_list|(
name|printf
argument_list|(
literal|"cmimix_setrecsrc: reg 0x%02x val 0x%02x\n"
argument_list|,
name|CMPCI_SB16_MIXER_ADCMIX_R
argument_list|,
name|sl
operator||
name|ml
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|=
name|CMPCI_SB16_MIXER_SRC_R_TO_L
argument_list|(
name|ml
argument_list|)
expr_stmt|;
name|cmimix_wr
argument_list|(
name|sc
argument_list|,
name|CMPCI_SB16_MIXER_ADCMIX_L
argument_list|,
name|sl
operator||
name|ml
argument_list|)
expr_stmt|;
name|DEBMIX
argument_list|(
name|printf
argument_list|(
literal|"cmimix_setrecsrc: reg 0x%02x val 0x%02x\n"
argument_list|,
name|CMPCI_SB16_MIXER_ADCMIX_L
argument_list|,
name|sl
operator||
name|ml
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/* Optional SPDIF support. */
end_comment

begin_function
specifier|static
name|int
name|cmi_initsys
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
comment|/* XXX: an user should be able to set this with a control tool, 	   if not done before 7.0-RELEASE, this needs to be converted 	   to a device specific sysctl "dev.pcm.X.yyy" via 	   device_get_sysctl_*() as discussed on multimedia@ in msg-id<861wujij2q.fsf@xps.des.no> */
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"spdif_enabled"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|spdif_enabled
argument_list|,
literal|0
argument_list|,
literal|"enable SPDIF output at 44.1 kHz and above"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SND_DYNSYSCTL */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|kobj_method_t
name|cmi_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|cmimix_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|cmimix_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|cmimix_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|cmi_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * mpu401 functions  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|cmi_mread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|d
decl_stmt|;
name|d
operator|=
name|bus_space_read_1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x330
operator|+
name|reg
argument_list|)
expr_stmt|;
comment|/*	printf("cmi_mread: reg %x %x\n",reg, d); 	*/
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_mwrite
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|char
name|b
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x330
operator|+
name|reg
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmi_muninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpu_intr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mpu
operator|=
literal|0
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|cmi_mpu_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mpufoi_read
argument_list|,
name|cmi_mread
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mpufoi_write
argument_list|,
name|cmi_mwrite
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mpufoi_uninit
argument_list|,
name|cmi_muninit
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_CLASS
argument_list|(
name|cmi_mpu
argument_list|,
name|cmi_mpu_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cmi_midiattach
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	const struct { 		int port,bits; 	} *p, ports[] = {  		{0x330,0},  		{0x320,1},  		{0x310,2},  		{0x300,3},  		{0,0} } ; 	Notes, CMPCI_REG_VMPUSEL sets the io port for the mpu.  Does 	anyone know how to bus_space tag? */
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_UART_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_LEGACY_CTRL
argument_list|,
name|CMPCI_REG_VMPUSEL_MASK
operator|<<
name|CMPCI_REG_VMPUSEL_SHIFT
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_LEGACY_CTRL
argument_list|,
literal|0
operator|<<
name|CMPCI_REG_VMPUSEL_SHIFT
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_UART_ENABLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mpu
operator|=
name|mpu401_init
argument_list|(
operator|&
name|cmi_mpu_class
argument_list|,
name|sc
argument_list|,
name|cmi_intr
argument_list|,
operator|&
name|sc
operator|->
name|mpu_intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Power and reset */
end_comment

begin_function
specifier|static
name|void
name|cmi_power
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* full power */
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_MISC
argument_list|,
name|CMPCI_REG_POWER_DOWN
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* power off */
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_MISC
argument_list|,
name|CMPCI_REG_POWER_DOWN
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cmi_init
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Effect reset */
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_MISC
argument_list|,
name|CMPCI_REG_BUS_AND_DSP_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_MISC
argument_list|,
name|CMPCI_REG_BUS_AND_DSP_RESET
argument_list|)
expr_stmt|;
comment|/* Disable interrupts and channels */
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_ENABLE
operator||
name|CMPCI_REG_CH1_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|CMPCI_REG_CH0_INTR_ENABLE
operator||
name|CMPCI_REG_CH1_INTR_ENABLE
argument_list|)
expr_stmt|;
comment|/* Configure DMA channels, ch0 = play, ch1 = capture */
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_DIR
argument_list|)
expr_stmt|;
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH1_DIR
argument_list|)
expr_stmt|;
comment|/* Attempt to enable 4 Channel output */
name|cmi_set4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_MISC
argument_list|,
name|CMPCI_REG_N4SPK3D
argument_list|)
expr_stmt|;
comment|/* Disable SPDIF1 - not compatible with config */
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_SPDIF1_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_SPDIF_LOOP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cmi_uninit
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Disable interrupts and channels */
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_INTR_CTRL
argument_list|,
name|CMPCI_REG_CH0_INTR_ENABLE
operator||
name|CMPCI_REG_CH1_INTR_ENABLE
operator||
name|CMPCI_REG_TDMA_INTR_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_0
argument_list|,
name|CMPCI_REG_CH0_ENABLE
operator||
name|CMPCI_REG_CH1_ENABLE
argument_list|)
expr_stmt|;
name|cmi_clr4
argument_list|(
name|sc
argument_list|,
name|CMPCI_REG_FUNC_1
argument_list|,
name|CMPCI_REG_UART_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpu
condition|)
name|sc
operator|->
name|mpu_intr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Bus and device registration */
end_comment

begin_function
specifier|static
name|int
name|cmi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|CMI8338A_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"CMedia CMI8338A"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
case|case
name|CMI8338B_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"CMedia CMI8338B"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
case|case
name|CMI8738_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"CMedia CMI8738"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
case|case
name|CMI8738B_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"CMedia CMI8738B"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
default|default:
return|return
name|ENXIO
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cmi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sc_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sound softc"
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|regid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|reg
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cmi_attach: Cannot allocate bus resource\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|cmi_midiattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
operator|||
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|cmi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cmi_attach: Unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|CMI_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|2
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|sc
operator|->
name|bufsz
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
comment|/*lockfunc*/
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cmi_attach: Unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|cmi_power
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmi_init
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|cmi_mixer_class
argument_list|,
name|sc
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|cmi_initsys
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|cmichan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|cmichan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx irq %ld %s"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_cmi
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cmi_attach: succeeded\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|sc
operator|->
name|parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|regid
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lock
condition|)
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
condition|)
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cmi_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmi_power
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpu
condition|)
name|mpu401_uninit
argument_list|(
name|sc
operator|->
name|mpu
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|regid
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpu_reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|mpu_regid
argument_list|,
name|sc
operator|->
name|mpu_reg
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmi_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pch
operator|.
name|dma_was_active
operator|=
name|cmi_ch0_stop
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rch
operator|.
name|dma_was_active
operator|=
name|cmi_ch1_stop
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rch
argument_list|)
expr_stmt|;
name|cmi_power
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmi_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cmi_power
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmi_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the card\n"
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mixer_reinit
argument_list|(
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|pch
operator|.
name|dma_was_active
condition|)
block|{
name|cmichan_setspeed
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|pch
argument_list|,
name|sc
operator|->
name|pch
operator|.
name|spd
argument_list|)
expr_stmt|;
name|cmichan_setformat
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|pch
argument_list|,
name|sc
operator|->
name|pch
operator|.
name|fmt
argument_list|)
expr_stmt|;
name|cmi_ch0_start
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rch
operator|.
name|dma_was_active
condition|)
block|{
name|cmichan_setspeed
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rch
argument_list|,
name|sc
operator|->
name|rch
operator|.
name|spd
argument_list|)
expr_stmt|;
name|cmichan_setformat
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rch
argument_list|,
name|sc
operator|->
name|rch
operator|.
name|fmt
argument_list|)
expr_stmt|;
name|cmi_ch1_start
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rch
argument_list|)
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|cmi_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cmi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cmi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cmi_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|cmi_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|cmi_suspend
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cmi_driver
init|=
block|{
literal|"pcm"
block|,
name|cmi_methods
block|,
name|PCM_SOFTC_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_cmi
argument_list|,
name|pci
argument_list|,
name|cmi_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_cmi
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_cmi
argument_list|,
name|midi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_cmi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

