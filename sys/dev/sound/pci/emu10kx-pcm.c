begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<gandalf@vilnya.demon.co.uk>  * Copyright (c) 2003-2006 Yuriy Tsibizov<yuriy.tsibizov@gfk.ru>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_include
include|#
directive|include
file|"opt_emu10kx.h"
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/emu10kx.h>
end_include

begin_include
include|#
directive|include
file|"emu10k1-alsa%diked.h"
end_include

begin_struct
struct|struct
name|emu_pcm_pchinfo
block|{
name|int
name|spd
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|int
name|blksz
decl_stmt|;
name|int
name|run
decl_stmt|;
name|struct
name|emu_voice
modifier|*
name|master
decl_stmt|;
name|struct
name|emu_voice
modifier|*
name|slave
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|pcm
decl_stmt|;
name|int
name|timer
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_pcm_rchinfo
block|{
name|int
name|spd
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|int
name|blksz
decl_stmt|;
name|int
name|run
decl_stmt|;
name|uint32_t
name|idxreg
decl_stmt|;
name|uint32_t
name|basereg
decl_stmt|;
name|uint32_t
name|sizereg
decl_stmt|;
name|uint32_t
name|setupreg
decl_stmt|;
name|uint32_t
name|irqmask
decl_stmt|;
name|uint32_t
name|iprmask
decl_stmt|;
name|int
name|ihandle
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|pcm
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* XXX Hardware playback channels */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANNELS
value|4
end_define

begin_if
if|#
directive|if
name|MAX_CHANNELS
operator|>
literal|13
end_if

begin_error
error|#
directive|error
error|Too many hardware channels defined. 13 is the maximum
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|emu_pcm_info
block|{
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* device information */
name|struct
name|snddev_info
modifier|*
name|devinfo
decl_stmt|;
comment|/* pcm device information */
name|struct
name|emu_sc_info
modifier|*
name|card
decl_stmt|;
name|struct
name|emu_pcm_pchinfo
name|pch
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/* hardware channels */
name|int
name|pnum
decl_stmt|;
comment|/* next free channel number */
name|struct
name|emu_pcm_rchinfo
name|rch_adc
decl_stmt|;
name|struct
name|emu_pcm_rchinfo
name|rch_efx
decl_stmt|;
name|struct
name|emu_route
name|rt
decl_stmt|;
name|struct
name|emu_route
name|rt_mono
decl_stmt|;
name|int
name|route
decl_stmt|;
name|int
name|ihandle
decl_stmt|;
comment|/* interrupt handler */
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|int
name|is_emu10k1
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|uint32_t
name|ac97_state
index|[
literal|0x7F
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|uint32_t
name|emu_rfmt_adc
index|[]
init|=
block|{
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_reccaps_adc
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|emu_rfmt_adc
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|emu_rfmt_efx
index|[]
init|=
block|{
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_reccaps_efx_live
init|=
block|{
literal|48000
operator|*
literal|32
block|,
literal|48000
operator|*
literal|32
block|,
name|emu_rfmt_efx
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_reccaps_efx_audigy
init|=
block|{
literal|48000
operator|*
literal|64
block|,
literal|48000
operator|*
literal|64
block|,
name|emu_rfmt_efx
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|emu_pfmt
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|emu_pfmt_mono
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_playcaps
init|=
block|{
literal|4000
block|,
literal|48000
block|,
name|emu_pfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_playcaps_mono
init|=
block|{
literal|4000
block|,
literal|48000
block|,
name|emu_pfmt_mono
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|emu10k1_adcspeed
index|[
literal|8
index|]
init|=
block|{
literal|48000
block|,
literal|44100
block|,
literal|32000
block|,
literal|24000
block|,
literal|22050
block|,
literal|16000
block|,
literal|11025
block|,
literal|8000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* audigy supports 12kHz. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|emu10k2_adcspeed
index|[
literal|9
index|]
init|=
block|{
literal|48000
block|,
literal|44100
block|,
literal|32000
block|,
literal|24000
block|,
literal|22050
block|,
literal|16000
block|,
literal|12000
block|,
literal|11025
block|,
literal|8000
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint32_t
name|emu_pcm_intr
parameter_list|(
name|void
modifier|*
name|pcm
parameter_list|,
name|uint32_t
name|stat
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
specifier|const
struct|struct
name|emu_dspmix_props
block|{
name|u_int8_t
name|present
decl_stmt|;
block|}
name|dspmix
index|[
name|SOUND_MIXER_NRDEVICES
index|]
init|=
block|{
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|=
block|{
literal|1
block|}
block|,
index|[
name|SOUND_MIXER_PCM
index|]
operator|=
block|{
literal|1
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|emu_dspmixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dspmix
index|[
name|i
index|]
operator|.
name|present
condition|)
name|v
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_dspmixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|SOUND_MIXER_VOLUME
case|:
switch|switch
condition|(
name|sc
operator|->
name|route
condition|)
block|{
case|case
name|RT_REAR
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_REAR_L
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_REAR_R
argument_list|,
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_CENTER
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_CENTER
argument_list|,
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_SUB
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_SUBWOOFER
argument_list|,
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOUND_MIXER_PCM
case|:
switch|switch
condition|(
name|sc
operator|->
name|route
condition|)
block|{
case|case
name|RT_REAR
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_FX2_REAR_L
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_FX3_REAR_R
argument_list|,
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_CENTER
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_FX4_CENTER
argument_list|,
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_SUB
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_FX5_SUBWOOFER
argument_list|,
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mixer error: unknown device %d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_dspmixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
name|__unused
parameter_list|,
name|u_int32_t
name|src
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emudspmixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|emu_dspmixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|emu_dspmixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|emu_dspmixer_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|emudspmixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * AC97 emulation code for Audigy and later cards.  * Some parts of AC97 codec are not used by hardware, but can be used  * to change some DSP controls via AC97 mixer interface. This includes:  * - master volume controls MASTER_FRONT_[R|L]  * - pcm volume controls FX[0|1]_FRONT_[R|L]  * - rec volume controls MASTER_REC_[R|L]  * We do it because we need to put it under user control....  * We also keep some parts of AC97 disabled to get better sound quality  */
end_comment

begin_define
define|#
directive|define
name|AC97LEFT
parameter_list|(
name|x
parameter_list|)
value|((x& 0x7F00)>>8)
end_define

begin_define
define|#
directive|define
name|AC97RIGHT
parameter_list|(
name|x
parameter_list|)
value|(x& 0x007F)
end_define

begin_define
define|#
directive|define
name|AC97MUTE
parameter_list|(
name|x
parameter_list|)
value|((x& 0x8000)>>15)
end_define

begin_define
define|#
directive|define
name|BIT4_TO100
parameter_list|(
name|x
parameter_list|)
value|(100-(x)*100/(0x0f))
end_define

begin_define
define|#
directive|define
name|BIT6_TO100
parameter_list|(
name|x
parameter_list|)
value|(100-(x)*100/(0x3f))
end_define

begin_define
define|#
directive|define
name|BIT4_TO255
parameter_list|(
name|x
parameter_list|)
value|(255-(x)*255/(0x0f))
end_define

begin_define
define|#
directive|define
name|BIT6_TO255
parameter_list|(
name|x
parameter_list|)
value|(255-(x)*255/(0x3f))
end_define

begin_define
define|#
directive|define
name|V100_TOBIT6
parameter_list|(
name|x
parameter_list|)
value|(0x3f*(100-x)/100)
end_define

begin_define
define|#
directive|define
name|V100_TOBIT4
parameter_list|(
name|x
parameter_list|)
value|(0x0f*(100-x)/100)
end_define

begin_define
define|#
directive|define
name|AC97ENCODE
parameter_list|(
name|x_muted
parameter_list|,
name|x_left
parameter_list|,
name|x_right
parameter_list|)
value|(((x_muted&1)<<15) | ((x_left&0x3f)<<8) | (x_right&0x3f))
end_define

begin_function
specifier|static
name|int
name|emu_ac97_read_emulation
parameter_list|(
name|struct
name|emu_pcm_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|use_ac97
decl_stmt|;
name|int
name|emulated
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|use_ac97
operator|=
literal|1
expr_stmt|;
name|emulated
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|AC97_MIX_MASTER
case|:
name|emulated
operator|=
name|sc
operator|->
name|ac97_state
index|[
name|AC97_MIX_MASTER
index|]
expr_stmt|;
name|use_ac97
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AC97_MIX_PCM
case|:
name|emulated
operator|=
name|sc
operator|->
name|ac97_state
index|[
name|AC97_MIX_PCM
index|]
expr_stmt|;
name|use_ac97
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AC97_REG_RECSEL
case|:
name|emulated
operator|=
literal|0x0505
expr_stmt|;
name|use_ac97
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AC97_MIX_RGAIN
case|:
name|emulated
operator|=
name|sc
operator|->
name|ac97_state
index|[
name|AC97_MIX_RGAIN
index|]
expr_stmt|;
name|use_ac97
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|emu_wr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97ADDRESS
argument_list|,
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emu_rd
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97DATA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_ac97
condition|)
name|emulated
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
name|emulated
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_ac97_write_emulation
parameter_list|(
name|struct
name|emu_pcm_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|int
name|write_ac97
decl_stmt|;
name|int
name|left
decl_stmt|,
name|right
decl_stmt|;
name|uint32_t
name|emu_left
decl_stmt|,
name|emu_right
decl_stmt|;
name|int
name|is_mute
decl_stmt|;
name|write_ac97
operator|=
literal|1
expr_stmt|;
name|left
operator|=
name|AC97LEFT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|emu_left
operator|=
name|BIT6_TO100
argument_list|(
name|left
argument_list|)
expr_stmt|;
comment|/* We show us as 6-bit AC97 mixer */
name|right
operator|=
name|AC97RIGHT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|emu_right
operator|=
name|BIT6_TO100
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|is_mute
operator|=
name|AC97MUTE
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_mute
condition|)
name|emu_left
operator|=
name|emu_right
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
comment|/* TODO: reset emulator on AC97_RESET */
case|case
name|AC97_MIX_MASTER
case|:
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|emu_left
argument_list|)
expr_stmt|;
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|emu_right
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ac97_state
index|[
name|AC97_MIX_MASTER
index|]
operator|=
name|data
operator|&
operator|(
literal|0x8000
operator||
literal|0x3f3f
operator|)
expr_stmt|;
name|data
operator|=
literal|0x8000
expr_stmt|;
comment|/* Mute AC97 main out */
break|break;
case|case
name|AC97_MIX_PCM
case|:
comment|/* PCM OUT VOL */
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_FX0_FRONT_L
argument_list|,
name|emu_left
argument_list|)
expr_stmt|;
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_FX1_FRONT_R
argument_list|,
name|emu_right
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ac97_state
index|[
name|AC97_MIX_PCM
index|]
operator|=
name|data
operator|&
operator|(
literal|0x8000
operator||
literal|0x3f3f
operator|)
expr_stmt|;
name|data
operator|=
literal|0x8000
expr_stmt|;
comment|/* Mute AC97 PCM out */
break|break;
case|case
name|AC97_REG_RECSEL
case|:
comment|/* 		 * PCM recording source is set to "stereo mix" (labeled "vol" 		 * in mixer) XXX !I can't remember why! 		 */
name|data
operator|=
literal|0x0505
expr_stmt|;
break|break;
case|case
name|AC97_MIX_RGAIN
case|:
comment|/* RECORD GAIN */
name|emu_left
operator|=
name|BIT4_TO100
argument_list|(
name|left
argument_list|)
expr_stmt|;
comment|/* rgain is 4-bit */
name|emu_right
operator|=
name|BIT4_TO100
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_REC_L
argument_list|,
literal|100
operator|-
name|emu_left
argument_list|)
expr_stmt|;
name|emumix_set_volume
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|M_MASTER_REC_R
argument_list|,
literal|100
operator|-
name|emu_right
argument_list|)
expr_stmt|;
comment|/* 		 * Record gain on AC97 should stay zero to get AC97 sound on 		 * AC97_[RL] connectors on EMU10K2 chip. AC97 on Audigy is not 		 * directly connected to any output, only to EMU10K2 chip Use 		 * this control to set AC97 mix volume inside EMU10K2 chip 		 */
name|sc
operator|->
name|ac97_state
index|[
name|AC97_MIX_RGAIN
index|]
operator|=
name|data
operator|&
operator|(
literal|0x8000
operator||
literal|0x0f0f
operator|)
expr_stmt|;
name|data
operator|=
literal|0x0000
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|write_ac97
condition|)
block|{
name|emu_wr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97ADDRESS
argument_list|,
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|emu_erdcd
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|emu_pcm_info
operator|*
operator|)
name|devinfo
decl_stmt|;
return|return
operator|(
name|emu_ac97_read_emulation
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_ewrcd
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|emu_pcm_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|emu_ac97_write_emulation
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emu_eac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|emu_erdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|emu_ewrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|emu_eac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* real ac97 codec */
end_comment

begin_function
specifier|static
name|int
name|emu_rdcd
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|rd
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|emu_pcm_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|card
operator|!=
name|NULL
argument_list|,
operator|(
literal|"emu_rdcd: no soundcard"
operator|)
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97ADDRESS
argument_list|,
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rd
operator|=
name|emu_rd
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97DATA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|rd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_wrcd
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|emu_pcm_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|card
operator|!=
name|NULL
argument_list|,
operator|(
literal|"emu_wrcd: no soundcard"
operator|)
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97ADDRESS
argument_list|,
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|AC97DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emu_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|emu_rdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|emu_wrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|emu_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|emu_k1_recval
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|val
operator|<
literal|7
operator|)
operator|&&
operator|(
name|speed
operator|<
name|emu10k1_adcspeed
index|[
name|val
index|]
operator|)
condition|)
name|val
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|6
condition|)
name|val
operator|=
literal|5
expr_stmt|;
comment|/* XXX 8kHz does not work */
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_k2_recval
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|val
operator|<
literal|8
operator|)
operator|&&
operator|(
name|speed
operator|<
name|emu10k2_adcspeed
index|[
name|val
index|]
operator|)
condition|)
name|val
operator|++
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|7
condition|)
name|val
operator|=
literal|6
expr_stmt|;
comment|/* XXX 8kHz does not work */
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|emupchan_init
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
name|__unused
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_PLAY
argument_list|,
operator|(
literal|"emupchan_init: bad direction"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|card
operator|!=
name|NULL
argument_list|,
operator|(
literal|"empchan_init: no soundcard"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pnum
operator|>=
name|MAX_CHANNELS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ch
operator|=
operator|&
operator|(
name|sc
operator|->
name|pch
index|[
name|sc
operator|->
name|pnum
operator|++
index|]
operator|)
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|pcm
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
literal|8000
expr_stmt|;
name|ch
operator|->
name|master
operator|=
name|emu_valloc
argument_list|(
name|sc
operator|->
name|card
argument_list|)
expr_stmt|;
comment|/* 	 * XXX we have to allocate slave even for mono channel until we 	 * fix emu_vfree to handle this case. 	 */
name|ch
operator|->
name|slave
operator|=
name|emu_valloc
argument_list|(
name|sc
operator|->
name|card
argument_list|)
expr_stmt|;
name|ch
operator|->
name|timer
operator|=
name|emu_timer_create
argument_list|(
name|sc
operator|->
name|card
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|emu_vinit
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|master
argument_list|,
name|ch
operator|->
name|slave
argument_list|,
name|EMU_PLAY_BUFSZ
argument_list|,
name|ch
operator|->
name|buffer
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|ch
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_free
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
name|emu_timer_clear
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|slave
operator|!=
name|NULL
condition|)
name|emu_vfree
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|slave
argument_list|)
expr_stmt|;
name|emu_vfree
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_setformat
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_setspeed
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
if|if
condition|(
name|blocksize
operator|>
name|ch
operator|->
name|pcm
operator|->
name|bufsz
condition|)
name|blocksize
operator|=
name|ch
operator|->
name|pcm
operator|->
name|bufsz
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
name|emu_timer_set
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|timer
argument_list|,
name|ch
operator|->
name|blksz
operator|/
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|blocksize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_trigger
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_EMLDMAWR
operator|||
name|go
operator|==
name|PCMTRIG_EMLDMARD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* XXX can we trigger on parallel threads ? */
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|emu_vsetup
argument_list|(
name|ch
operator|->
name|master
argument_list|,
name|ch
operator|->
name|fmt
argument_list|,
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
operator|)
operator|==
name|AFMT_STEREO
condition|)
name|emu_vroute
argument_list|(
name|sc
operator|->
name|card
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|rt
operator|)
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
else|else
name|emu_vroute
argument_list|(
name|sc
operator|->
name|card
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|rt_mono
operator|)
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
name|emu_vwrite
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
name|emu_timer_set
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|timer
argument_list|,
name|ch
operator|->
name|blksz
operator|/
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|emu_timer_enable
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* PCM interrupt handler will handle PCMTRIG_STOP event */
name|ch
operator|->
name|run
operator|=
operator|(
name|go
operator|==
name|PCMTRIG_START
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|emu_vtrigger
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|master
argument_list|,
name|ch
operator|->
name|run
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_getptr
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|emu_vpos
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|emupchan_getcaps
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
name|__unused
parameter_list|)
block|{
name|struct
name|emu_pcm_pchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|route
condition|)
block|{
case|case
name|RT_FRONT
case|:
comment|/* FALLTHROUGH */
case|case
name|RT_REAR
case|:
comment|/* FALLTHROUGH */
case|case
name|RT_SIDE
case|:
return|return
operator|(
operator|&
name|emu_playcaps
operator|)
return|;
break|break;
case|case
name|RT_CENTER
case|:
comment|/* FALLTHROUGH */
case|case
name|RT_SUB
case|:
return|return
operator|(
operator|&
name|emu_playcaps_mono
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emupchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|emupchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|emupchan_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|emupchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|emupchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|emupchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|emupchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|emupchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|emupchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|emupchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
modifier|*
name|emurchan_init
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
name|__unused
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
decl_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"emurchan_init: bad direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|rch_adc
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|pcm
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
operator|/
literal|2
expr_stmt|;
comment|/* We rise interrupt for half-full buffer */
name|ch
operator|->
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
literal|8000
expr_stmt|;
name|ch
operator|->
name|idxreg
operator|=
name|sc
operator|->
name|is_emu10k1
condition|?
name|ADCIDX
else|:
name|A_ADCIDX
expr_stmt|;
name|ch
operator|->
name|basereg
operator|=
name|ADCBA
expr_stmt|;
name|ch
operator|->
name|sizereg
operator|=
name|ADCBS
expr_stmt|;
name|ch
operator|->
name|setupreg
operator|=
name|ADCCR
expr_stmt|;
name|ch
operator|->
name|irqmask
operator|=
name|INTE_ADCBUFENABLE
expr_stmt|;
name|ch
operator|->
name|iprmask
operator|=
name|IPR_ADCBUFFULL
operator||
name|IPR_ADCBUFHALFFULL
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|emu_gettag
argument_list|(
name|sc
operator|->
name|card
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|basereg
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off */
return|return
operator|(
name|ch
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_setformat
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_setspeed
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|pcm
operator|->
name|is_emu10k1
condition|)
block|{
name|speed
operator|=
name|emu10k1_adcspeed
index|[
name|emu_k1_recval
argument_list|(
name|speed
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|speed
operator|=
name|emu10k2_adcspeed
index|[
name|emu_k2_recval
argument_list|(
name|speed
argument_list|)
index|]
expr_stmt|;
block|}
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
comment|/* If blocksize is less than half of buffer size we will not get 	interrupt in time and channel will die due to interrupt timeout */
if|if
condition|(
name|ch
operator|->
name|blksz
operator|<
operator|(
name|ch
operator|->
name|pcm
operator|->
name|bufsz
operator|/
literal|2
operator|)
condition|)
name|ch
operator|->
name|blksz
operator|=
name|ch
operator|->
name|pcm
operator|->
name|bufsz
operator|/
literal|2
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|blksz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_trigger
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|sz
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|bufsz
condition|)
block|{
case|case
literal|4096
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_4096
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_8192
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_16384
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_32768
expr_stmt|;
break|break;
case|case
literal|65536
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_65536
expr_stmt|;
break|break;
default|default:
name|sz
operator|=
name|ADCBS_BUFSIZE_4096
expr_stmt|;
block|}
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|ch
operator|->
name|run
operator|=
literal|1
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|val
operator|=
name|sc
operator|->
name|is_emu10k1
condition|?
name|ADCCR_LCHANENABLE
else|:
name|A_ADCCR_LCHANENABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
condition|)
name|val
operator||=
name|sc
operator|->
name|is_emu10k1
condition|?
name|ADCCR_RCHANENABLE
else|:
name|A_ADCCR_RCHANENABLE
expr_stmt|;
name|val
operator||=
name|sc
operator|->
name|is_emu10k1
condition|?
name|emu_k1_recval
argument_list|(
name|ch
operator|->
name|spd
argument_list|)
else|:
name|emu_k2_recval
argument_list|(
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|setupreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|setupreg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ch
operator|->
name|ihandle
operator|=
name|emu_intr_register
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|irqmask
argument_list|,
name|ch
operator|->
name|iprmask
argument_list|,
operator|&
name|emu_pcm_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
comment|/* FALLTHROUGH */
case|case
name|PCMTRIG_ABORT
case|:
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|setupreg
condition|)
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|setupreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|emu_intr_unregister
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|ihandle
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_EMLDMAWR
case|:
comment|/* FALLTHROUGH */
case|case
name|PCMTRIG_EMLDMARD
case|:
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_getptr
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|emu_rdptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|idxreg
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|emurchan_getcaps
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
name|__unused
parameter_list|)
block|{
return|return
operator|(
operator|&
name|emu_reccaps_adc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emurchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|emurchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|emurchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|emurchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|emurchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|emurchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|emurchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|emurchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|emurchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
modifier|*
name|emufxrchan_init
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
name|__unused
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
decl_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"emurchan_init: bad direction"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ch
operator|=
operator|&
operator|(
name|sc
operator|->
name|rch_efx
operator|)
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|sc
operator|->
name|is_emu10k1
condition|?
literal|48000
operator|*
literal|32
else|:
literal|48000
operator|*
literal|64
expr_stmt|;
name|ch
operator|->
name|idxreg
operator|=
name|FXIDX
expr_stmt|;
name|ch
operator|->
name|basereg
operator|=
name|FXBA
expr_stmt|;
name|ch
operator|->
name|sizereg
operator|=
name|FXBS
expr_stmt|;
name|ch
operator|->
name|irqmask
operator|=
name|INTE_EFXBUFENABLE
expr_stmt|;
name|ch
operator|->
name|iprmask
operator|=
name|IPR_EFXBUFFULL
operator||
name|IPR_EFXBUFHALFFULL
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|pcm
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|emu_gettag
argument_list|(
name|sc
operator|->
name|card
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|basereg
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off */
return|return
operator|(
name|ch
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|emufxrchan_setformat
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
name|__unused
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
operator|==
name|AFMT_S16_LE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emufxrchan_setspeed
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
comment|/* FIXED RATE CHANNEL */
return|return
operator|(
name|ch
operator|->
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emufxrchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
comment|/* If blocksize is less than half of buffer size we will not get 	interrupt in time and channel will die due to interrupt timeout */
if|if
condition|(
name|ch
operator|->
name|blksz
operator|<
operator|(
name|ch
operator|->
name|pcm
operator|->
name|bufsz
operator|/
literal|2
operator|)
condition|)
name|ch
operator|->
name|blksz
operator|=
name|ch
operator|->
name|pcm
operator|->
name|bufsz
operator|/
literal|2
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|blksz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emufxrchan_trigger
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
name|uint32_t
name|sz
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|bufsz
condition|)
block|{
case|case
literal|4096
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_4096
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_8192
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_16384
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_32768
expr_stmt|;
break|break;
case|case
literal|65536
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_65536
expr_stmt|;
break|break;
default|default:
name|sz
operator|=
name|ADCBS_BUFSIZE_4096
expr_stmt|;
block|}
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|ch
operator|->
name|run
operator|=
literal|1
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ch
operator|->
name|ihandle
operator|=
name|emu_intr_register
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|irqmask
argument_list|,
name|ch
operator|->
name|iprmask
argument_list|,
operator|&
name|emu_pcm_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/*  		 SB Live! is limited to 32 mono channels. Audigy 		 has 64 mono channels, each of them is selected from 		 one of two A_FXWC[1|2] registers. 		 */
comment|/* XXX there is no way to demultiplex this streams for now */
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|FXWC
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|A_FXWC1
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|A_FXWC2
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCMTRIG_STOP
case|:
comment|/* FALLTHROUGH */
case|case
name|PCMTRIG_ABORT
case|:
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|FXWC
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|A_FXWC1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|A_FXWC2
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
name|emu_wrptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|emu_intr_unregister
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|ch
operator|->
name|ihandle
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_EMLDMAWR
case|:
comment|/* FALLTHROUGH */
case|case
name|PCMTRIG_EMLDMARD
case|:
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emufxrchan_getptr
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|emu_rdptr
argument_list|(
name|sc
operator|->
name|card
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|idxreg
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|emufxrchan_getcaps
parameter_list|(
name|kobj_t
name|obj
name|__unused
parameter_list|,
name|void
modifier|*
name|c_devinfo
parameter_list|)
block|{
name|struct
name|emu_pcm_rchinfo
modifier|*
name|ch
init|=
name|c_devinfo
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|pcm
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
return|return
operator|(
operator|&
name|emu_reccaps_efx_live
operator|)
return|;
return|return
operator|(
operator|&
name|emu_reccaps_efx_audigy
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emufxrchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|emufxrchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|emufxrchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|emufxrchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|emufxrchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|emufxrchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|emufxrchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|emufxrchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|emufxrchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint32_t
name|emu_pcm_intr
parameter_list|(
name|void
modifier|*
name|pcm
parameter_list|,
name|uint32_t
name|stat
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|emu_pcm_info
operator|*
operator|)
name|pcm
decl_stmt|;
name|uint32_t
name|ack
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|IPR_INTERVALTIMER
condition|)
block|{
name|ack
operator||=
name|IPR_INTERVALTIMER
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|channel
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|run
operator|==
literal|1
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|channel
argument_list|)
expr_stmt|;
else|else
name|emu_timer_enable
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|sc
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat
operator|&
operator|(
name|IPR_ADCBUFFULL
operator||
name|IPR_ADCBUFHALFFULL
operator|)
condition|)
block|{
name|ack
operator||=
name|stat
operator|&
operator|(
name|IPR_ADCBUFFULL
operator||
name|IPR_ADCBUFHALFFULL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rch_adc
operator|.
name|channel
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch_adc
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
operator|(
name|IPR_EFXBUFFULL
operator||
name|IPR_EFXBUFHALFFULL
operator|)
condition|)
block|{
name|ack
operator||=
name|stat
operator|&
operator|(
name|IPR_EFXBUFFULL
operator||
name|IPR_EFXBUFHALFFULL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rch_efx
operator|.
name|channel
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch_efx
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ack
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pcm_init
parameter_list|(
name|struct
name|emu_pcm_info
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|EMUPAGESIZE
argument_list|,
name|EMU_REC_BUFSZ
argument_list|,
name|EMU_MAX_BUFSZ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pcm_uninit
parameter_list|(
name|struct
name|emu_pcm_info
modifier|*
name|sc
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pcm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uintptr_t
name|func
decl_stmt|,
name|route
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|rt
decl_stmt|;
name|char
name|buffer
index|[
literal|255
index|]
decl_stmt|;
name|r
operator|=
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|EMU_VAR_FUNC
argument_list|,
operator|&
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|SCF_PCM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|rt
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|r
operator|=
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|EMU_VAR_ROUTE
argument_list|,
operator|&
name|route
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|route
condition|)
block|{
case|case
name|RT_FRONT
case|:
name|rt
operator|=
literal|"front"
expr_stmt|;
break|break;
case|case
name|RT_REAR
case|:
name|rt
operator|=
literal|"rear"
expr_stmt|;
break|break;
case|case
name|RT_CENTER
case|:
name|rt
operator|=
literal|"center"
expr_stmt|;
break|break;
case|case
name|RT_SUB
case|:
name|rt
operator|=
literal|"subwoofer"
expr_stmt|;
break|break;
case|case
name|RT_SIDE
case|:
name|rt
operator|=
literal|"side"
expr_stmt|;
break|break;
case|case
name|RT_MCHRECORD
case|:
name|rt
operator|=
literal|"multichannel recording"
expr_stmt|;
break|break;
block|}
name|snprintf
argument_list|(
name|buffer
argument_list|,
literal|255
argument_list|,
literal|"EMU10Kx DSP %s PCM interface"
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pcm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|emu_pcm_info
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|uint32_t
name|inte
decl_stmt|,
name|ipr
decl_stmt|;
name|uintptr_t
name|route
decl_stmt|,
name|r
decl_stmt|,
name|is_emu10k1
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|card
operator|=
operator|(
expr|struct
name|emu_sc_info
operator|*
operator|)
operator|(
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|card
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get bridge conf\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"snd_emu10kx softc"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|r
operator|=
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|EMU_VAR_ISEMU10K1
argument_list|,
operator|&
name|is_emu10k1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|is_emu10k1
operator|=
name|is_emu10k1
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|codec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rt
operator|.
name|routing_left
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|rt
operator|.
name|amounts_left
index|[
name|i
index|]
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|rt
operator|.
name|routing_right
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|rt
operator|.
name|amounts_right
index|[
name|i
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rt_mono
operator|.
name|routing_left
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
name|i
index|]
operator|=
literal|0x00
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|routing_right
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_right
index|[
name|i
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
name|r
operator|=
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|EMU_VAR_ROUTE
argument_list|,
operator|&
name|route
argument_list|)
expr_stmt|;
name|sc
operator|->
name|route
operator|=
name|route
expr_stmt|;
switch|switch
condition|(
name|route
condition|)
block|{
case|case
name|RT_FRONT
case|:
name|sc
operator|->
name|rt
operator|.
name|amounts_left
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt
operator|.
name|amounts_right
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
name|sc
operator|->
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|emu_ac97
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|emu_eac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|codec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|emudspmixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize DSP mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|sc
operator|->
name|codec
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't initialize AC97 mixer!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|RT_REAR
case|:
name|sc
operator|->
name|rt
operator|.
name|amounts_left
index|[
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt
operator|.
name|amounts_right
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|emudspmixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|RT_CENTER
case|:
name|sc
operator|->
name|rt
operator|.
name|amounts_left
index|[
literal|4
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|4
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|emudspmixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|RT_SUB
case|:
name|sc
operator|->
name|rt
operator|.
name|amounts_left
index|[
literal|5
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|5
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|emudspmixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|RT_SIDE
case|:
name|sc
operator|->
name|rt
operator|.
name|amounts_left
index|[
literal|6
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt
operator|.
name|amounts_right
index|[
literal|7
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|6
index|]
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rt_mono
operator|.
name|amounts_left
index|[
literal|7
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|emudspmixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
case|case
name|RT_MCHRECORD
case|:
comment|/* XXX add mixer here */
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid default route\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|inte
operator|=
name|INTE_INTERVALTIMERENB
expr_stmt|;
name|ipr
operator|=
name|IPR_INTERVALTIMER
expr_stmt|;
comment|/* Used by playback */
name|sc
operator|->
name|ihandle
operator|=
name|emu_intr_register
argument_list|(
name|sc
operator|->
name|card
argument_list|,
name|inte
argument_list|,
name|ipr
argument_list|,
operator|&
name|emu_pcm_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|emu_pcm_init
argument_list|(
name|sc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize PCM part of the card\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* XXX we should better get number of available channels from parent */
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
operator|(
name|route
operator|==
name|RT_FRONT
operator|)
condition|?
name|MAX_CHANNELS
else|:
literal|1
argument_list|,
operator|(
name|route
operator|==
name|RT_FRONT
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't register PCM channels!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|pnum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|route
operator|!=
name|RT_MCHRECORD
condition|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|emupchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|route
operator|==
name|RT_FRONT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|emupchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|emurchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|route
operator|==
name|RT_MCHRECORD
condition|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|emufxrchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"on %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|sc
operator|->
name|codec
condition|)
name|ac97_destroy
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lock
condition|)
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pcm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|emu_pcm_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|emu_pcm_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lock
condition|)
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|emu_pcm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|emu_pcm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|emu_pcm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|emu_pcm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|emu_pcm_driver
init|=
block|{
literal|"pcm"
block|,
name|emu_pcm_methods
block|,
name|PCM_SOFTC_SIZE
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_emu10kx_pcm
argument_list|,
name|emu10kx
argument_list|,
name|emu_pcm_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_emu10kx_pcm
argument_list|,
name|snd_emu10kx
argument_list|,
name|SND_EMU10KX_MINVER
argument_list|,
name|SND_EMU10KX_PREFVER
argument_list|,
name|SND_EMU10KX_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_emu10kx_pcm
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_emu10kx_pcm
argument_list|,
name|SND_EMU10KX_PREFVER
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

