begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 David O'Brien<obrien@FreeBSD.org>  * Copyright (c) 2003 Orlando Bassotto<orlando.bassotto@ieo-research.it>  * Copyright (c) 1999 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<gnu/dev/sound/pci/emu10k1.h>
end_include

begin_include
include|#
directive|include
file|"emu10k1-alsa%diked.h"
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|NUM_G
value|64
end_define

begin_comment
comment|/* use all channels */
end_comment

begin_define
define|#
directive|define
name|WAVEOUT_MAXBUFSIZE
value|32768
end_define

begin_define
define|#
directive|define
name|EMUPAGESIZE
value|4096
end_define

begin_comment
comment|/* don't change */
end_comment

begin_define
define|#
directive|define
name|EMUMAXPAGES
value|(WAVEOUT_MAXBUFSIZE * NUM_G / EMUPAGESIZE)
end_define

begin_define
define|#
directive|define
name|EMU10K1_PCI_ID
value|0x00021102
end_define

begin_comment
comment|/* 1102 => Creative Labs Vendor ID */
end_comment

begin_define
define|#
directive|define
name|EMU10K2_PCI_ID
value|0x00041102
end_define

begin_define
define|#
directive|define
name|EMU_DEFAULT_BUFSZ
value|4096
end_define

begin_define
define|#
directive|define
name|EMU_MAX_CHANS
value|8
end_define

begin_define
define|#
directive|define
name|EMU_CHANS
value|4
end_define

begin_define
define|#
directive|define
name|MAXREQVOICES
value|8
end_define

begin_define
define|#
directive|define
name|RESERVED
value|0
end_define

begin_define
define|#
directive|define
name|NUM_MIDI
value|16
end_define

begin_define
define|#
directive|define
name|NUM_FXSENDS
value|4
end_define

begin_define
define|#
directive|define
name|TMEMSIZE
value|256*1024
end_define

begin_define
define|#
directive|define
name|TMEMSIZEREG
value|4
end_define

begin_define
define|#
directive|define
name|ENABLE
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|DISABLE
value|0x00000000
end_define

begin_define
define|#
directive|define
name|ENV_ON
value|DCYSUSV_CHANNELENABLE_MASK
end_define

begin_define
define|#
directive|define
name|ENV_OFF
value|0x00
end_define

begin_comment
comment|/* XXX: should this be 1? */
end_comment

begin_define
define|#
directive|define
name|A_IOCFG_GPOUT_A
value|0x40
end_define

begin_comment
comment|/* Analog Output */
end_comment

begin_define
define|#
directive|define
name|A_IOCFG_GPOUT_D
value|0x04
end_define

begin_comment
comment|/* Digital Output */
end_comment

begin_define
define|#
directive|define
name|A_IOCFG_GPOUT_AD
value|(A_IOCFG_GPOUT_A|A_IOCFG_GPOUT_D)
end_define

begin_comment
comment|/* A_IOCFG_GPOUT0 */
end_comment

begin_struct
struct|struct
name|emu_memblk
block|{
name|SLIST_ENTRY
argument_list|(
argument|emu_memblk
argument_list|)
name|link
expr_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_addr_t
name|buf_addr
decl_stmt|;
name|u_int32_t
name|pte_start
decl_stmt|,
name|pte_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_mem
block|{
name|u_int8_t
name|bmap
index|[
name|EMUMAXPAGES
operator|/
literal|8
index|]
decl_stmt|;
name|u_int32_t
modifier|*
name|ptb_pages
decl_stmt|;
name|void
modifier|*
name|silent_page
decl_stmt|;
name|bus_addr_t
name|silent_page_addr
decl_stmt|;
name|bus_addr_t
name|ptb_pages_addr
decl_stmt|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|emu_memblk
argument_list|)
name|blocks
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_voice
block|{
name|int
name|vnum
decl_stmt|;
name|int
name|b16
range|:
literal|1
decl_stmt|,
name|stereo
range|:
literal|1
decl_stmt|,
name|busy
range|:
literal|1
decl_stmt|,
name|running
range|:
literal|1
decl_stmt|,
name|ismaster
range|:
literal|1
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|vol
decl_stmt|;
name|int
name|fxrt1
decl_stmt|;
comment|/* FX routing */
name|int
name|fxrt2
decl_stmt|;
comment|/* FX routing (only for audigy) */
name|u_int32_t
name|buf
decl_stmt|;
name|struct
name|emu_voice
modifier|*
name|slave
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|sc_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* channel registers */
end_comment

begin_struct
struct|struct
name|sc_pchinfo
block|{
name|int
name|spd
decl_stmt|,
name|fmt
decl_stmt|,
name|blksz
decl_stmt|,
name|run
decl_stmt|;
name|struct
name|emu_voice
modifier|*
name|master
decl_stmt|,
modifier|*
name|slave
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sc_rchinfo
block|{
name|int
name|spd
decl_stmt|,
name|fmt
decl_stmt|,
name|run
decl_stmt|,
name|blksz
decl_stmt|,
name|num
decl_stmt|;
name|u_int32_t
name|idxreg
decl_stmt|,
name|basereg
decl_stmt|,
name|sizereg
decl_stmt|,
name|setupreg
decl_stmt|,
name|irqmask
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* device private data */
end_comment

begin_struct
struct|struct
name|sc_info
block|{
name|device_t
name|dev
decl_stmt|;
name|u_int32_t
name|type
decl_stmt|,
name|rev
decl_stmt|;
name|u_int32_t
name|tos_link
range|:
literal|1
decl_stmt|,
name|APS
range|:
literal|1
decl_stmt|,
name|audigy
range|:
literal|1
decl_stmt|,
name|audigy2
range|:
literal|1
decl_stmt|;
name|u_int32_t
name|addrmask
decl_stmt|;
comment|/* wider if audigy */
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|int
name|timer
decl_stmt|,
name|timerinterval
decl_stmt|;
name|int
name|pnum
decl_stmt|,
name|rnum
decl_stmt|;
name|int
name|nchans
decl_stmt|;
name|struct
name|emu_mem
name|mem
decl_stmt|;
name|struct
name|emu_voice
name|voice
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|sc_pchinfo
name|pch
index|[
name|EMU_MAX_CHANS
index|]
decl_stmt|;
name|struct
name|sc_rchinfo
name|rch
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * prototypes  */
end_comment

begin_comment
comment|/* stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|emu_init
parameter_list|(
name|struct
name|sc_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|emu_malloc
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|emu_memalloc
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_memfree
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_memstart
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|EMUDEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|emu_vdump
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* talk to the card */
end_comment

begin_function_decl
specifier|static
name|u_int32_t
name|emu_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|emu_rfmt_ac97
index|[]
init|=
block|{
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|emu_rfmt_mic
index|[]
init|=
block|{
name|AFMT_U8
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|emu_rfmt_efx
index|[]
init|=
block|{
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_reccaps
index|[
literal|3
index|]
init|=
block|{
block|{
literal|8000
block|,
literal|48000
block|,
name|emu_rfmt_ac97
block|,
literal|0
block|}
block|,
block|{
literal|8000
block|,
literal|8000
block|,
name|emu_rfmt_mic
block|,
literal|0
block|}
block|,
block|{
literal|48000
block|,
literal|48000
block|,
name|emu_rfmt_efx
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|emu_pfmt
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|emu_playcaps
init|=
block|{
literal|4000
block|,
literal|48000
block|,
name|emu_pfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adcspeed
index|[
literal|8
index|]
init|=
block|{
literal|48000
block|,
literal|44100
block|,
literal|32000
block|,
literal|24000
block|,
literal|22050
block|,
literal|16000
block|,
literal|11025
block|,
literal|8000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* audigy supports 12kHz. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audigy_adcspeed
index|[
literal|9
index|]
init|=
block|{
literal|48000
block|,
literal|44100
block|,
literal|32000
block|,
literal|24000
block|,
literal|22050
block|,
literal|16000
block|,
literal|12000
block|,
literal|11025
block|,
literal|8000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Hardware */
end_comment

begin_function
specifier|static
name|u_int32_t
name|emu_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
default|default:
return|return
literal|0xffffffff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emu_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|emu_rdptr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u_int32_t
name|ptr
decl_stmt|,
name|val
decl_stmt|,
name|mask
decl_stmt|,
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|ptr
operator|=
operator|(
operator|(
name|reg
operator|<<
literal|16
operator|)
operator|&
name|sc
operator|->
name|addrmask
operator|)
operator||
operator|(
name|chn
operator|&
name|PTR_CHANNELNUM_MASK
operator|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|PTR
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|DATA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
literal|0xff000000
condition|)
block|{
name|size
operator|=
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|offset
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|offset
expr_stmt|;
name|val
operator|&=
name|mask
expr_stmt|;
name|val
operator|>>=
name|offset
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_wrptr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|u_int32_t
name|ptr
decl_stmt|,
name|mask
decl_stmt|,
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|ptr
operator|=
operator|(
operator|(
name|reg
operator|<<
literal|16
operator|)
operator|&
name|sc
operator|->
name|addrmask
operator|)
operator||
operator|(
name|chn
operator|&
name|PTR_CHANNELNUM_MASK
operator|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|PTR
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
literal|0xff000000
condition|)
block|{
name|size
operator|=
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|offset
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|offset
expr_stmt|;
name|data
operator|<<=
name|offset
expr_stmt|;
name|data
operator|&=
name|mask
expr_stmt|;
name|data
operator||=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|DATA
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
block|}
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|DATA
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_wrefx
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|pc
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|pc
operator|+=
name|sc
operator|->
name|audigy
condition|?
name|AUDIGY_CODEBASE
else|:
name|MICROCODEBASE
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ac97 codec */
end_comment

begin_comment
comment|/* no locking needed */
end_comment

begin_function
specifier|static
name|int
name|emu_rdcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|AC97ADDRESS
argument_list|,
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|AC97DATA
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_wrcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|AC97ADDRESS
argument_list|,
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|AC97DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emu_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|emu_rdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|emu_wrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|emu_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* stuff */
end_comment

begin_function
specifier|static
name|int
name|emu_settimer
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|pch
decl_stmt|;
name|struct
name|sc_rchinfo
modifier|*
name|rch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tmp
decl_stmt|,
name|rate
decl_stmt|;
name|rate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nchans
condition|;
name|i
operator|++
control|)
block|{
name|pch
operator|=
operator|&
name|sc
operator|->
name|pch
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pch
operator|->
name|buffer
condition|)
block|{
name|tmp
operator|=
operator|(
name|pch
operator|->
name|spd
operator|*
name|sndbuf_getbps
argument_list|(
name|pch
operator|->
name|buffer
argument_list|)
operator|)
operator|/
name|pch
operator|->
name|blksz
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|rate
condition|)
name|rate
operator|=
name|tmp
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|rch
operator|=
operator|&
name|sc
operator|->
name|rch
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rch
operator|->
name|buffer
condition|)
block|{
name|tmp
operator|=
operator|(
name|rch
operator|->
name|spd
operator|*
name|sndbuf_getbps
argument_list|(
name|rch
operator|->
name|buffer
argument_list|)
operator|)
operator|/
name|rch
operator|->
name|blksz
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|rate
condition|)
name|rate
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|RANGE
argument_list|(
name|rate
argument_list|,
literal|48
argument_list|,
literal|9600
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timerinterval
operator|=
literal|48000
operator|/
name|rate
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|TIMER
argument_list|,
name|sc
operator|->
name|timerinterval
operator|&
literal|0x03ff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|sc
operator|->
name|timerinterval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_enatimer
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|u_int32_t
name|x
decl_stmt|;
if|if
condition|(
name|go
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|timer
operator|++
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator||=
name|INTE_INTERVALTIMERENB
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|timer
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|INTE_INTERVALTIMERENB
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_enastop
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|reg
init|=
operator|(
name|channel
operator|&
literal|0x20
operator|)
condition|?
name|SOLEH
else|:
name|SOLEL
decl_stmt|;
name|channel
operator|&=
literal|0x1f
expr_stmt|;
name|reg
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
name|reg
operator||=
name|channel
operator|<<
literal|16
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_recval
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
operator|<
literal|7
operator|&&
name|speed
operator|<
name|adcspeed
index|[
name|val
index|]
condition|)
name|val
operator|++
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|audigy_recval
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|val
operator|<
literal|8
operator|&&
name|speed
operator|<
name|audigy_adcspeed
index|[
name|val
index|]
condition|)
name|val
operator|++
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|emu_rate_to_pitch
parameter_list|(
name|u_int32_t
name|rate
parameter_list|)
block|{
specifier|static
name|u_int32_t
name|logMagTable
index|[
literal|128
index|]
init|=
block|{
literal|0x00000
block|,
literal|0x02dfc
block|,
literal|0x05b9e
block|,
literal|0x088e6
block|,
literal|0x0b5d6
block|,
literal|0x0e26f
block|,
literal|0x10eb3
block|,
literal|0x13aa2
block|,
literal|0x1663f
block|,
literal|0x1918a
block|,
literal|0x1bc84
block|,
literal|0x1e72e
block|,
literal|0x2118b
block|,
literal|0x23b9a
block|,
literal|0x2655d
block|,
literal|0x28ed5
block|,
literal|0x2b803
block|,
literal|0x2e0e8
block|,
literal|0x30985
block|,
literal|0x331db
block|,
literal|0x359eb
block|,
literal|0x381b6
block|,
literal|0x3a93d
block|,
literal|0x3d081
block|,
literal|0x3f782
block|,
literal|0x41e42
block|,
literal|0x444c1
block|,
literal|0x46b01
block|,
literal|0x49101
block|,
literal|0x4b6c4
block|,
literal|0x4dc49
block|,
literal|0x50191
block|,
literal|0x5269e
block|,
literal|0x54b6f
block|,
literal|0x57006
block|,
literal|0x59463
block|,
literal|0x5b888
block|,
literal|0x5dc74
block|,
literal|0x60029
block|,
literal|0x623a7
block|,
literal|0x646ee
block|,
literal|0x66a00
block|,
literal|0x68cdd
block|,
literal|0x6af86
block|,
literal|0x6d1fa
block|,
literal|0x6f43c
block|,
literal|0x7164b
block|,
literal|0x73829
block|,
literal|0x759d4
block|,
literal|0x77b4f
block|,
literal|0x79c9a
block|,
literal|0x7bdb5
block|,
literal|0x7dea1
block|,
literal|0x7ff5e
block|,
literal|0x81fed
block|,
literal|0x8404e
block|,
literal|0x86082
block|,
literal|0x88089
block|,
literal|0x8a064
block|,
literal|0x8c014
block|,
literal|0x8df98
block|,
literal|0x8fef1
block|,
literal|0x91e20
block|,
literal|0x93d26
block|,
literal|0x95c01
block|,
literal|0x97ab4
block|,
literal|0x9993e
block|,
literal|0x9b79f
block|,
literal|0x9d5d9
block|,
literal|0x9f3ec
block|,
literal|0xa11d8
block|,
literal|0xa2f9d
block|,
literal|0xa4d3c
block|,
literal|0xa6ab5
block|,
literal|0xa8808
block|,
literal|0xaa537
block|,
literal|0xac241
block|,
literal|0xadf26
block|,
literal|0xafbe7
block|,
literal|0xb1885
block|,
literal|0xb3500
block|,
literal|0xb5157
block|,
literal|0xb6d8c
block|,
literal|0xb899f
block|,
literal|0xba58f
block|,
literal|0xbc15e
block|,
literal|0xbdd0c
block|,
literal|0xbf899
block|,
literal|0xc1404
block|,
literal|0xc2f50
block|,
literal|0xc4a7b
block|,
literal|0xc6587
block|,
literal|0xc8073
block|,
literal|0xc9b3f
block|,
literal|0xcb5ed
block|,
literal|0xcd07c
block|,
literal|0xceaec
block|,
literal|0xd053f
block|,
literal|0xd1f73
block|,
literal|0xd398a
block|,
literal|0xd5384
block|,
literal|0xd6d60
block|,
literal|0xd8720
block|,
literal|0xda0c3
block|,
literal|0xdba4a
block|,
literal|0xdd3b4
block|,
literal|0xded03
block|,
literal|0xe0636
block|,
literal|0xe1f4e
block|,
literal|0xe384a
block|,
literal|0xe512c
block|,
literal|0xe69f3
block|,
literal|0xe829f
block|,
literal|0xe9b31
block|,
literal|0xeb3a9
block|,
literal|0xecc08
block|,
literal|0xee44c
block|,
literal|0xefc78
block|,
literal|0xf148a
block|,
literal|0xf2c83
block|,
literal|0xf4463
block|,
literal|0xf5c2a
block|,
literal|0xf73da
block|,
literal|0xf8b71
block|,
literal|0xfa2f0
block|,
literal|0xfba57
block|,
literal|0xfd1a7
block|,
literal|0xfe8df
block|}
decl_stmt|;
specifier|static
name|char
name|logSlopeTable
index|[
literal|128
index|]
init|=
block|{
literal|0x5c
block|,
literal|0x5c
block|,
literal|0x5b
block|,
literal|0x5a
block|,
literal|0x5a
block|,
literal|0x59
block|,
literal|0x58
block|,
literal|0x58
block|,
literal|0x57
block|,
literal|0x56
block|,
literal|0x56
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0x54
block|,
literal|0x53
block|,
literal|0x53
block|,
literal|0x52
block|,
literal|0x52
block|,
literal|0x51
block|,
literal|0x51
block|,
literal|0x50
block|,
literal|0x50
block|,
literal|0x4f
block|,
literal|0x4f
block|,
literal|0x4e
block|,
literal|0x4d
block|,
literal|0x4d
block|,
literal|0x4d
block|,
literal|0x4c
block|,
literal|0x4c
block|,
literal|0x4b
block|,
literal|0x4b
block|,
literal|0x4a
block|,
literal|0x4a
block|,
literal|0x49
block|,
literal|0x49
block|,
literal|0x48
block|,
literal|0x48
block|,
literal|0x47
block|,
literal|0x47
block|,
literal|0x47
block|,
literal|0x46
block|,
literal|0x46
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x44
block|,
literal|0x44
block|,
literal|0x43
block|,
literal|0x43
block|,
literal|0x43
block|,
literal|0x42
block|,
literal|0x42
block|,
literal|0x42
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x3f
block|,
literal|0x3f
block|,
literal|0x3f
block|,
literal|0x3e
block|,
literal|0x3e
block|,
literal|0x3e
block|,
literal|0x3d
block|,
literal|0x3d
block|,
literal|0x3d
block|,
literal|0x3c
block|,
literal|0x3c
block|,
literal|0x3c
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3a
block|,
literal|0x3a
block|,
literal|0x3a
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x2f
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Bail out if no leading "1" */
name|rate
operator|*=
literal|11185
expr_stmt|;
comment|/* Scale 48000 to 0x20002380 */
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|rate
operator|&
literal|0x80000000
condition|)
block|{
comment|/* Detect leading "1" */
return|return
operator|(
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|i
operator|-
literal|15
argument_list|)
operator|<<
literal|20
operator|)
operator|+
name|logMagTable
index|[
literal|0x7f
operator|&
operator|(
name|rate
operator|>>
literal|24
operator|)
index|]
operator|+
operator|(
literal|0x7f
operator|&
operator|(
name|rate
operator|>>
literal|17
operator|)
operator|)
operator|*
name|logSlopeTable
index|[
literal|0x7f
operator|&
operator|(
name|rate
operator|>>
literal|24
operator|)
index|]
operator|)
return|;
block|}
name|rate
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* Should never reach this point */
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|emu_rate_to_linearpitch
parameter_list|(
name|u_int32_t
name|rate
parameter_list|)
block|{
name|rate
operator|=
operator|(
name|rate
operator|<<
literal|8
operator|)
operator|/
literal|375
expr_stmt|;
return|return
operator|(
name|rate
operator|>>
literal|1
operator|)
operator|+
operator|(
name|rate
operator|&
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|emu_voice
modifier|*
name|emu_valloc
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|emu_voice
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
operator|&&
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|busy
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
block|{
name|v
operator|=
operator|&
name|sc
operator|->
name|voice
index|[
name|i
index|]
expr_stmt|;
name|v
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_vinit
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|m
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|s
parameter_list|,
name|u_int32_t
name|sz
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_addr_t
name|tmp_addr
decl_stmt|;
name|buf
operator|=
name|emu_memalloc
argument_list|(
name|sc
argument_list|,
name|sz
argument_list|,
operator|&
name|tmp_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|m
operator|->
name|start
operator|=
name|emu_memstart
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|)
operator|*
name|EMUPAGESIZE
expr_stmt|;
name|m
operator|->
name|end
operator|=
name|m
operator|->
name|start
operator|+
name|sz
expr_stmt|;
name|m
operator|->
name|channel
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|b16
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|stereo
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|ismaster
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|vol
operator|=
literal|0xff
expr_stmt|;
name|m
operator|->
name|buf
operator|=
name|tmp_addr
expr_stmt|;
name|m
operator|->
name|slave
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
name|m
operator|->
name|fxrt1
operator|=
name|FXBUS_MIDI_CHORUS
operator||
name|FXBUS_PCM_LEFT
operator|<<
literal|8
operator||
name|FXBUS_PCM_RIGHT
operator|<<
literal|16
operator||
name|FXBUS_MIDI_REVERB
operator|<<
literal|24
expr_stmt|;
name|m
operator|->
name|fxrt2
operator|=
literal|0x3f3f3f3f
expr_stmt|;
comment|/* No effects on second route */
block|}
else|else
block|{
name|m
operator|->
name|fxrt1
operator|=
name|FXBUS_MIDI_CHORUS
operator||
name|FXBUS_PCM_LEFT
operator|<<
literal|4
operator||
name|FXBUS_PCM_RIGHT
operator|<<
literal|8
operator||
name|FXBUS_MIDI_REVERB
operator|<<
literal|12
expr_stmt|;
name|m
operator|->
name|fxrt2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|start
operator|=
name|m
operator|->
name|start
expr_stmt|;
name|s
operator|->
name|end
operator|=
name|m
operator|->
name|end
expr_stmt|;
name|s
operator|->
name|channel
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|b16
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stereo
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ismaster
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|vol
operator|=
name|m
operator|->
name|vol
expr_stmt|;
name|s
operator|->
name|buf
operator|=
name|m
operator|->
name|buf
expr_stmt|;
name|s
operator|->
name|fxrt1
operator|=
name|m
operator|->
name|fxrt1
expr_stmt|;
name|s
operator|->
name|fxrt2
operator|=
name|m
operator|->
name|fxrt2
expr_stmt|;
name|s
operator|->
name|slave
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_vsetup
parameter_list|(
name|struct
name|sc_pchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|emu_voice
modifier|*
name|v
init|=
name|ch
operator|->
name|master
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
condition|)
block|{
name|v
operator|->
name|b16
operator|=
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|v
operator|->
name|stereo
operator|=
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
block|{
name|v
operator|->
name|slave
operator|->
name|b16
operator|=
name|v
operator|->
name|b16
expr_stmt|;
name|v
operator|->
name|slave
operator|->
name|stereo
operator|=
name|v
operator|->
name|stereo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|spd
condition|)
block|{
name|v
operator|->
name|speed
operator|=
name|ch
operator|->
name|spd
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
name|v
operator|->
name|slave
operator|->
name|speed
operator|=
name|v
operator|->
name|speed
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emu_vwrite
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|u_int32_t
name|sa
decl_stmt|,
name|ea
decl_stmt|,
name|start
decl_stmt|,
name|val
decl_stmt|,
name|silent_page
decl_stmt|;
name|s
operator|=
operator|(
name|v
operator|->
name|stereo
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|sa
operator|=
name|v
operator|->
name|start
operator|>>
name|s
expr_stmt|;
name|ea
operator|=
name|v
operator|->
name|end
operator|>>
name|s
expr_stmt|;
name|l
operator|=
name|r
operator|=
name|x
operator|=
name|y
operator|=
name|v
operator|->
name|vol
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|stereo
condition|)
block|{
name|l
operator|=
name|v
operator|->
name|ismaster
condition|?
name|l
else|:
literal|0
expr_stmt|;
name|r
operator|=
name|v
operator|->
name|ismaster
condition|?
literal|0
else|:
name|r
expr_stmt|;
block|}
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CPF
argument_list|,
name|v
operator|->
name|stereo
condition|?
name|CPF_STEREO_MASK
else|:
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|v
operator|->
name|stereo
condition|?
literal|28
else|:
literal|30
expr_stmt|;
name|val
operator|*=
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|start
operator|=
name|sa
operator|+
name|val
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|A_FXRT1
argument_list|,
name|v
operator|->
name|fxrt1
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|A_FXRT2
argument_list|,
name|v
operator|->
name|fxrt2
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|A_SENDAMOUNTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|FXRT
argument_list|,
name|v
operator|->
name|fxrt1
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|PTRX
argument_list|,
operator|(
name|x
operator|<<
literal|8
operator|)
operator||
name|r
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|DSL
argument_list|,
name|ea
operator||
operator|(
name|y
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|PSST
argument_list|,
name|sa
operator||
operator|(
name|l
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CCCA
argument_list|,
name|start
operator||
operator|(
name|v
operator|->
name|b16
condition|?
literal|0
else|:
name|CCCA_8BITSELECT
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|Z1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|Z2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|silent_page
operator|=
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|MAP_PTI_MASK
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|MAPA
argument_list|,
name|silent_page
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|MAPB
argument_list|,
name|silent_page
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CVCF
argument_list|,
name|CVCF_CURRENTFILTER_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|VTFT
argument_list|,
name|VTFT_FILTERTARGET_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|ATKHLDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|DCYSUSM
argument_list|,
name|DCYSUSM_DECAYTIME_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|LFOVAL1
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|LFOVAL2
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|FMMOD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|TREMFRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|FM2FRQ2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|ENVVAL
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|ATKHLDV
argument_list|,
name|ATKHLDV_HOLDTIME_MASK
operator||
name|ATKHLDV_ATTACKTIME_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|ENVVOL
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|PEFE_FILTERAMOUNT
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|PEFE_PITCHAMOUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
name|emu_vwrite
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|slave
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_vtrigger
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|u_int32_t
name|pitch_target
decl_stmt|,
name|initial_pitch
decl_stmt|;
name|u_int32_t
name|cra
decl_stmt|,
name|cs
decl_stmt|,
name|ccis
decl_stmt|;
name|u_int32_t
name|sample
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|go
condition|)
block|{
name|cra
operator|=
literal|64
expr_stmt|;
name|cs
operator|=
name|v
operator|->
name|stereo
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|ccis
operator|=
name|v
operator|->
name|stereo
condition|?
literal|28
else|:
literal|30
expr_stmt|;
name|ccis
operator|*=
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|sample
operator|=
name|v
operator|->
name|b16
condition|?
literal|0x00000000
else|:
literal|0x80808080
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cs
condition|;
name|i
operator|++
control|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CD0
operator|+
name|i
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CCR_CACHEINVALIDSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CCR_READADDRESS
argument_list|,
name|cra
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CCR_CACHEINVALIDSIZE
argument_list|,
name|ccis
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|IFATN
argument_list|,
literal|0xff00
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|VTFT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CVCF
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|DCYSUSV
argument_list|,
literal|0x00007f7f
argument_list|)
expr_stmt|;
name|emu_enastop
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pitch_target
operator|=
name|emu_rate_to_linearpitch
argument_list|(
name|v
operator|->
name|speed
argument_list|)
expr_stmt|;
name|initial_pitch
operator|=
name|emu_rate_to_pitch
argument_list|(
name|v
operator|->
name|speed
argument_list|)
operator|>>
literal|8
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|PTRX_PITCHTARGET
argument_list|,
name|pitch_target
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CPF_CURRENTPITCH
argument_list|,
name|pitch_target
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|IP
argument_list|,
name|initial_pitch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|PTRX_PITCHTARGET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CPF_CURRENTPITCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|IFATN
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|VTFT
argument_list|,
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CVCF
argument_list|,
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|IP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_enastop
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
name|emu_vtrigger
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|slave
argument_list|,
name|go
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_vpos
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|ptr
decl_stmt|;
name|s
operator|=
operator|(
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|v
operator|->
name|stereo
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|CCCA_CURRADDR
argument_list|)
operator|-
operator|(
name|v
operator|->
name|start
operator|>>
name|s
operator|)
operator|)
operator|<<
name|s
expr_stmt|;
return|return
name|ptr
operator|&
operator|~
literal|0x0000001f
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EMUDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|emu_vdump
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
name|regname
index|[]
init|=
block|{
literal|"cpf"
block|,
literal|"ptrx"
block|,
literal|"cvcf"
block|,
literal|"vtft"
block|,
literal|"z2"
block|,
literal|"z1"
block|,
literal|"psst"
block|,
literal|"dsl"
block|,
literal|"ccca"
block|,
literal|"ccr"
block|,
literal|"clp"
block|,
literal|"fxrt"
block|,
literal|"mapa"
block|,
literal|"mapb"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"envvol"
block|,
literal|"atkhldv"
block|,
literal|"dcysusv"
block|,
literal|"lfoval1"
block|,
literal|"envval"
block|,
literal|"atkhldm"
block|,
literal|"dcysusm"
block|,
literal|"lfoval2"
block|,
literal|"ip"
block|,
literal|"ifatn"
block|,
literal|"pefe"
block|,
literal|"fmmod"
block|,
literal|"tremfrq"
block|,
literal|"fmfrq2"
block|,
literal|"tempenv"
block|}
decl_stmt|;
name|char
modifier|*
name|regname2
index|[]
init|=
block|{
literal|"mudata1"
block|,
literal|"mustat1"
block|,
literal|"mudata2"
block|,
literal|"mustat2"
block|,
literal|"fxwc1"
block|,
literal|"fxwc2"
block|,
literal|"spdrate"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fxrt2"
block|,
literal|"sndamnt"
block|,
literal|"fxrt1"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|printf
argument_list|(
literal|"voice number %d\n"
argument_list|,
name|v
operator|->
name|vnum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x
operator|=
literal|0
init|;
name|i
operator|<=
literal|0x1e
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regname
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s\t[%08x]"
argument_list|,
name|regname
index|[
name|i
index|]
argument_list|,
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|x
operator|==
literal|2
operator|)
condition|?
literal|"\n"
else|:
literal|"\t"
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|2
condition|)
name|x
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Print out audigy extra registers */
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|0xe
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regname2
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s\t[%08x]"
argument_list|,
name|regname2
index|[
name|i
index|]
argument_list|,
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|i
operator|+
literal|0x70
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|x
operator|==
literal|2
operator|)
condition|?
literal|"\n"
else|:
literal|"\t"
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|2
condition|)
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|emupchan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_pchinfo
modifier|*
name|ch
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_PLAY
argument_list|,
operator|(
literal|"emupchan_init: bad direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|pch
index|[
name|sc
operator|->
name|pnum
operator|++
index|]
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
operator|/
literal|2
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
literal|8000
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ch
operator|->
name|master
operator|=
name|emu_valloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|slave
operator|=
name|emu_valloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|emu_vinit
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|master
argument_list|,
name|ch
operator|->
name|slave
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|,
name|ch
operator|->
name|buffer
argument_list|)
operator|)
condition|?
name|NULL
else|:
name|ch
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_free
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|int
name|r
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|emu_memfree
argument_list|(
name|sc
argument_list|,
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|int
name|irqrate
decl_stmt|,
name|blksz
decl_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|emu_settimer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|irqrate
operator|=
literal|48000
operator|/
name|sc
operator|->
name|timerinterval
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|blksz
operator|=
operator|(
name|ch
operator|->
name|spd
operator|*
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|)
operator|/
name|irqrate
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_EMLDMAWR
operator|||
name|go
operator|==
name|PCMTRIG_EMLDMARD
condition|)
return|return
literal|0
return|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|emu_vsetup
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|emu_vwrite
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
name|emu_settimer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|emu_enatimer
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMUDEBUG
name|printf
argument_list|(
literal|"start [%d bit, %s, %d hz]\n"
argument_list|,
name|ch
operator|->
name|master
operator|->
name|b16
condition|?
literal|16
else|:
literal|8
argument_list|,
name|ch
operator|->
name|master
operator|->
name|stereo
condition|?
literal|"stereo"
else|:
literal|"mono"
argument_list|,
name|ch
operator|->
name|master
operator|->
name|speed
argument_list|)
expr_stmt|;
name|emu_vdump
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
name|emu_vdump
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|slave
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ch
operator|->
name|run
operator|=
operator|(
name|go
operator|==
name|PCMTRIG_START
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|emu_vtrigger
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|master
argument_list|,
name|ch
operator|->
name|run
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emupchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_pchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|int
name|r
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|emu_vpos
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|master
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|emupchan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|&
name|emu_playcaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emupchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|emupchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|emupchan_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|emupchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|emupchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|emupchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|emupchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|emupchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|emupchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|emupchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|emurchan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_rchinfo
modifier|*
name|ch
decl_stmt|;
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"emurchan_init: bad direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|rch
index|[
name|sc
operator|->
name|rnum
index|]
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
operator|/
literal|2
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
literal|8000
expr_stmt|;
name|ch
operator|->
name|num
operator|=
name|sc
operator|->
name|rnum
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|rnum
condition|)
block|{
case|case
literal|0
case|:
name|ch
operator|->
name|idxreg
operator|=
name|sc
operator|->
name|audigy
condition|?
name|A_ADCIDX
else|:
name|ADCIDX
expr_stmt|;
name|ch
operator|->
name|basereg
operator|=
name|ADCBA
expr_stmt|;
name|ch
operator|->
name|sizereg
operator|=
name|ADCBS
expr_stmt|;
name|ch
operator|->
name|setupreg
operator|=
name|ADCCR
expr_stmt|;
name|ch
operator|->
name|irqmask
operator|=
name|INTE_ADCBUFENABLE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ch
operator|->
name|idxreg
operator|=
name|FXIDX
expr_stmt|;
name|ch
operator|->
name|basereg
operator|=
name|FXBA
expr_stmt|;
name|ch
operator|->
name|sizereg
operator|=
name|FXBS
expr_stmt|;
name|ch
operator|->
name|setupreg
operator|=
name|FXWC
expr_stmt|;
name|ch
operator|->
name|irqmask
operator|=
name|INTE_EFXBUFENABLE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ch
operator|->
name|idxreg
operator|=
name|MICIDX
expr_stmt|;
name|ch
operator|->
name|basereg
operator|=
name|MICBA
expr_stmt|;
name|ch
operator|->
name|sizereg
operator|=
name|MICBS
expr_stmt|;
name|ch
operator|->
name|setupreg
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|irqmask
operator|=
name|INTE_MICBUFENABLE
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|rnum
operator|++
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|sc
operator|->
name|parent_dmat
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|basereg
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* off */
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|sc_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|num
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|parent
operator|->
name|audigy
condition|)
name|speed
operator|=
name|audigy_adcspeed
index|[
name|audigy_recval
argument_list|(
name|speed
argument_list|)
index|]
expr_stmt|;
else|else
name|speed
operator|=
name|adcspeed
index|[
name|emu_recval
argument_list|(
name|speed
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|num
operator|==
literal|1
condition|)
name|speed
operator|=
literal|48000
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|num
operator|==
literal|2
condition|)
name|speed
operator|=
literal|8000
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|int
name|irqrate
decl_stmt|,
name|blksz
decl_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|emu_settimer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|irqrate
operator|=
literal|48000
operator|/
name|sc
operator|->
name|timerinterval
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|blksz
operator|=
operator|(
name|ch
operator|->
name|spd
operator|*
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|)
operator|/
name|irqrate
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_comment
comment|/* semantic note: must start at beginning of buffer */
end_comment

begin_function
specifier|static
name|int
name|emurchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|,
name|sz
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|bufsz
condition|)
block|{
case|case
literal|4096
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_4096
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_8192
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_16384
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_32768
expr_stmt|;
break|break;
case|case
literal|65536
case|:
name|sz
operator|=
name|ADCBS_BUFSIZE_65536
expr_stmt|;
break|break;
default|default:
name|sz
operator|=
name|ADCBS_BUFSIZE_4096
expr_stmt|;
block|}
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|ch
operator|->
name|run
operator|=
literal|1
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|num
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
name|val
operator|=
name|A_ADCCR_LCHANENABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
condition|)
name|val
operator||=
name|A_ADCCR_RCHANENABLE
expr_stmt|;
name|val
operator||=
name|audigy_recval
argument_list|(
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|ADCCR_LCHANENABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
condition|)
name|val
operator||=
name|ADCCR_RCHANENABLE
expr_stmt|;
name|val
operator||=
name|emu_recval
argument_list|(
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
block|}
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|setupreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|setupreg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator||=
name|ch
operator|->
name|irqmask
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|sizereg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|setupreg
condition|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|setupreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|ch
operator|->
name|irqmask
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_EMLDMAWR
case|:
case|case
name|PCMTRIG_EMLDMARD
case|:
default|default:
break|break;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emurchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|int
name|r
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|idxreg
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|emurchan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
operator|&
name|emu_reccaps
index|[
name|ch
operator|->
name|num
index|]
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|emurchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|emurchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|emurchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|emurchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|emurchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|emurchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|emurchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|emurchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|emurchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|emu_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|p
decl_stmt|;
name|u_int32_t
name|stat
decl_stmt|,
name|ack
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|stat
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|IPR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|ack
operator|=
literal|0
expr_stmt|;
comment|/* process irq */
if|if
condition|(
name|stat
operator|&
name|IPR_INTERVALTIMER
condition|)
block|{
name|ack
operator||=
name|IPR_INTERVALTIMER
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nchans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|run
condition|)
block|{
name|x
operator|=
literal|1
expr_stmt|;
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|emu_enatimer
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
operator|(
name|IPR_ADCBUFFULL
operator||
name|IPR_ADCBUFHALFFULL
operator|)
condition|)
block|{
name|ack
operator||=
name|stat
operator|&
operator|(
name|IPR_ADCBUFFULL
operator||
name|IPR_ADCBUFHALFFULL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rch
index|[
literal|0
index|]
operator|.
name|channel
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch
index|[
literal|0
index|]
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
operator|(
name|IPR_EFXBUFFULL
operator||
name|IPR_EFXBUFHALFFULL
operator|)
condition|)
block|{
name|ack
operator||=
name|stat
operator|&
operator|(
name|IPR_EFXBUFFULL
operator||
name|IPR_EFXBUFHALFFULL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rch
index|[
literal|1
index|]
operator|.
name|channel
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch
index|[
literal|1
index|]
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
operator|(
name|IPR_MICBUFFULL
operator||
name|IPR_MICBUFHALFFULL
operator|)
condition|)
block|{
name|ack
operator||=
name|stat
operator|&
operator|(
name|IPR_MICBUFFULL
operator||
name|IPR_MICBUFHALFFULL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rch
index|[
literal|2
index|]
operator|.
name|channel
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch
index|[
literal|2
index|]
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IPR_PCIERROR
condition|)
block|{
name|ack
operator||=
name|IPR_PCIERROR
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pci error\n"
argument_list|)
expr_stmt|;
comment|/* we still get an nmi with ecc ram even if we ack this */
block|}
if|if
condition|(
name|stat
operator|&
name|IPR_SAMPLERATETRACKER
condition|)
block|{
name|ack
operator||=
name|IPR_SAMPLERATETRACKER
expr_stmt|;
ifdef|#
directive|ifdef
name|EMUDEBUG
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"sample rate tracker lock status change\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|stat
operator|&
operator|~
name|ack
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"dodgy irq: %x (harmless)\n"
argument_list|,
name|stat
operator|&
operator|~
name|ack
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|IPR
argument_list|,
name|stat
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|emu_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|phys
init|=
name|arg
decl_stmt|;
operator|*
name|phys
operator|=
name|error
condition|?
literal|0
else|:
operator|(
name|bus_addr_t
operator|)
name|segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"emu: setmap (%lx, %lx), nseg=%d, error=%d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_len
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|emu_malloc
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
operator|*
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
operator|&
name|buf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|map
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|map
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|,
name|emu_setmap
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
operator|*
name|addr
condition|)
return|return
name|NULL
return|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_free
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|emu_memalloc
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|)
block|{
name|u_int32_t
name|blksz
decl_stmt|,
name|start
decl_stmt|,
name|idx
decl_stmt|,
name|ofs
decl_stmt|,
name|tmp
decl_stmt|,
name|found
decl_stmt|;
name|struct
name|emu_mem
modifier|*
name|mem
init|=
operator|&
name|sc
operator|->
name|mem
decl_stmt|;
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|blksz
operator|=
name|sz
operator|/
name|EMUPAGESIZE
expr_stmt|;
if|if
condition|(
name|sz
operator|>
operator|(
name|blksz
operator|*
name|EMUPAGESIZE
operator|)
condition|)
name|blksz
operator|++
expr_stmt|;
comment|/* find a free block in the bitmap */
name|found
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|found
operator|&&
name|start
operator|+
name|blksz
operator|<
name|EMUMAXPAGES
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<
name|start
operator|+
name|blksz
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|mem
operator|->
name|bmap
index|[
name|idx
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
condition|)
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
name|NULL
return|;
name|blk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|blk
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|buf
operator|=
name|emu_malloc
argument_list|(
name|sc
argument_list|,
name|sz
argument_list|,
operator|&
name|blk
operator|->
name|buf_addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|blk
operator|->
name|buf_addr
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|blk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|blk
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|blk
operator|->
name|pte_start
operator|=
name|start
expr_stmt|;
name|blk
operator|->
name|pte_size
operator|=
name|blksz
expr_stmt|;
ifdef|#
directive|ifdef
name|EMUDEBUG
name|printf
argument_list|(
literal|"buf %p, pte_start %d, pte_size %d\n"
argument_list|,
name|blk
operator|->
name|buf
argument_list|,
name|blk
operator|->
name|pte_start
argument_list|,
name|blk
operator|->
name|pte_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ofs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<
name|start
operator|+
name|blksz
condition|;
name|idx
operator|++
control|)
block|{
name|mem
operator|->
name|bmap
index|[
name|idx
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|idx
operator|&
literal|7
operator|)
expr_stmt|;
name|tmp
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|u_long
argument_list|)
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|blk
operator|->
name|buf_addr
operator|+
name|ofs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMUDEBUG
name|printf
argument_list|(
literal|"pte[%d] -> %x phys, %x virt\n"
argument_list|,
name|idx
argument_list|,
name|tmp
argument_list|,
operator|(
operator|(
name|u_int32_t
operator|)
name|buf
operator|)
operator|+
name|ofs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mem
operator|->
name|ptb_pages
index|[
name|idx
index|]
operator|=
operator|(
name|tmp
operator|<<
literal|1
operator|)
operator||
name|idx
expr_stmt|;
name|ofs
operator|+=
name|EMUPAGESIZE
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mem
operator|->
name|blocks
argument_list|,
name|blk
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_memfree
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|u_int32_t
name|idx
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|emu_mem
modifier|*
name|mem
init|=
operator|&
name|sc
operator|->
name|mem
decl_stmt|;
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|blk
operator|=
name|NULL
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|i
argument_list|,
argument|&mem->blocks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|i
operator|->
name|buf
operator|==
name|buf
condition|)
name|blk
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|mem
operator|->
name|blocks
argument_list|,
name|blk
argument_list|,
name|emu_memblk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|emu_free
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tmp
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|blk
operator|->
name|pte_start
init|;
name|idx
operator|<
name|blk
operator|->
name|pte_start
operator|+
name|blk
operator|->
name|pte_size
condition|;
name|idx
operator|++
control|)
block|{
name|mem
operator|->
name|bmap
index|[
name|idx
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|mem
operator|->
name|ptb_pages
index|[
name|idx
index|]
operator|=
name|tmp
operator||
name|idx
expr_stmt|;
block|}
name|free
argument_list|(
name|blk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_memstart
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|emu_mem
modifier|*
name|mem
init|=
operator|&
name|sc
operator|->
name|mem
decl_stmt|;
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|blk
operator|=
name|NULL
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|i
argument_list|,
argument|&mem->blocks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|i
operator|->
name|buf
operator|==
name|buf
condition|)
name|blk
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|blk
operator|->
name|pte_start
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_addefxop
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|z
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|u_int32_t
modifier|*
name|pc
parameter_list|)
block|{
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
operator|(
operator|*
name|pc
operator|)
operator|*
literal|2
argument_list|,
operator|(
name|x
operator|<<
literal|10
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
operator|(
operator|*
name|pc
operator|)
operator|*
literal|2
operator|+
literal|1
argument_list|,
operator|(
name|op
operator|<<
literal|20
operator|)
operator||
operator|(
name|z
operator|<<
literal|10
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|audigy_addefxop
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|z
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|u_int32_t
modifier|*
name|pc
parameter_list|)
block|{
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
operator|(
operator|*
name|pc
operator|)
operator|*
literal|2
argument_list|,
operator|(
name|x
operator|<<
literal|12
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
operator|(
operator|*
name|pc
operator|)
operator|*
literal|2
operator|+
literal|1
argument_list|,
operator|(
name|op
operator|<<
literal|24
operator|)
operator||
operator|(
name|z
operator|<<
literal|12
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|audigy_initefx
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|pc
init|=
literal|0
decl_stmt|;
comment|/* skip 0, 0, -1, 0 - NOPs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
literal|0x0f
argument_list|,
literal|0x0c0
argument_list|,
literal|0x0c0
argument_list|,
literal|0x0cf
argument_list|,
literal|0x0c0
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|A_FXGPREGBASE
operator|+
name|i
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|pc
operator|=
literal|16
expr_stmt|;
comment|/* stop fx processor */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|A_DBG
argument_list|,
name|A_DBG_SINGLE_STEP
argument_list|)
expr_stmt|;
comment|/* Audigy 2 (EMU10K2) DSP Registers: 	   FX Bus 		0x000-0x00f : 16 registers (???) 	   Input 		0x040/0x041 : AC97 Codec (l/r) 		0x042/0x043 : ADC, S/PDIF (l/r) 		0x044/0x045 : Optical S/PDIF in (l/r) 		0x046/0x047 : ??? 		0x048/0x049 : Line/Mic 2 (l/r) 		0x04a/0x04b : RCA S/PDIF (l/r) 		0x04c/0x04d : Aux 2 (l/r) 	   Output 		0x060/0x061 : Digital Front (l/r) 		0x062/0x063 : Digital Center/LFE 		0x064/0x065 : AudigyDrive Heaphone (l/r) 		0x066/0x067 : Digital Rear (l/r) 		0x068/0x069 : Analog Front (l/r) 		0x06a/0x06b : Analog Center/LFE 		0x06c/0x06d : ??? 		0x06e/0x06f : Analog Rear (l/r) 		0x070/0x071 : AC97 Output (l/r) 		0x072/0x073 : ??? 		0x074/0x075 : ??? 		0x076/0x077 : ADC Recording Buffer (l/r) 	   Constants 		0x0c0 - 0x0c4 = 0 - 4 		0x0c5 = 0x8, 0x0c6 = 0x10, 0x0c7 = 0x20 		0x0c8 = 0x100, 0x0c9 = 0x10000, 0x0ca = 0x80000 		0x0cb = 0x10000000, 0x0cc = 0x20000000, 0x0cd = 0x40000000 		0x0ce = 0x80000000, 0x0cf = 0x7fffffff, 0x0d0 = 0xffffffff 		0x0d1 = 0xfffffffe, 0x0d2 = 0xc0000000, 0x0d3 = 0x41fbbcdc 		0x0d4 = 0x5a7ef9db, 0x0d5 = 0x00100000, 0x0dc = 0x00000001 (???) 	   Temporary Values 		0x0d6 : Accumulator (???) 		0x0d7 : Condition Register 		0x0d8 : Noise source 		0x0d9 : Noise source 	   Tank Memory Data Registers 		0x200 - 0x2ff 	   Tank Memory Address Registers 		0x300 - 0x3ff 	   General Purpose Registers 		0x400 - 0x5ff 	 */
comment|/* AC97Output[l/r] = FXBus PCM[l/r] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_AC97_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_FXBUS
argument_list|(
name|FXBUS_PCM_LEFT
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_AC97_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_FXBUS
argument_list|(
name|FXBUS_PCM_RIGHT
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* GPR[0/1] = RCA S/PDIF[l/r] -- Master volume */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_EXTIN
argument_list|(
name|EXTIN_COAX_SPDIF_L
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_EXTIN
argument_list|(
name|EXTIN_COAX_SPDIF_R
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* GPR[2] = GPR[0] (Left) / 2 + GPR[1] (Right) / 2 -- Central volume */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iINTERP
argument_list|,
name|A_GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|A_C_40000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Headphones[l/r] = GPR[0/1] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_HEADPHONE_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_HEADPHONE_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Analog Front[l/r] = GPR[0/1] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_AFRONT_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_AFRONT_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Digital Front[l/r] = GPR[0/1] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_FRONT_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_FRONT_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Center and Subwoofer configuration */
comment|/* Analog Center = GPR[0] + GPR[2] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_ACENTER
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|A_GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Analog Sub = GPR[1] + GPR[2] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_ALFE
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|A_GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Digital Center = GPR[0] + GPR[2] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_CENTER
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|A_GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Digital Sub = GPR[1] + GPR[2] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_LFE
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|A_GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Analog Rear[l/r] = (GPR[0/1] * RearVolume[l/r])>> 31 */
comment|/*   RearVolume = GPR[0x10/0x11] (Will this ever be implemented?) */
block|audigy_addefxop(sc, iMAC0, A_EXTOUT(A_EXTOUT_AREAR_L), A_C_00000000, 			A_GPR(16), A_GPR(0),&pc); 	audigy_addefxop(sc, iMAC0, A_EXTOUT(A_EXTOUT_AREAR_R), A_C_00000000, 			A_GPR(17), A_GPR(1),&pc);
comment|/* Digital Rear[l/r] = (GPR[0/1] * RearVolume[l/r])>> 31 */
comment|/*   RearVolume = GPR[0x10/0x11] (Will this ever be implemented?) */
block|audigy_addefxop(sc, iMAC0, A_EXTOUT(A_EXTOUT_REAR_L), A_C_00000000, 			A_GPR(16), A_GPR(0),&pc); 	audigy_addefxop(sc, iMAC0, A_EXTOUT(A_EXTOUT_REAR_R), A_C_00000000, 			A_GPR(17), A_GPR(1),&pc);
else|#
directive|else
comment|/* XXX This is just a copy to the channel, since we do not have 	 *     a patch manager, it is useful for have another output enabled. 	 */
comment|/* Analog Rear[l/r] = GPR[0/1] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_AREAR_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_AREAR_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Digital Rear[l/r] = GPR[0/1] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_REAR_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_REAR_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ADC Recording buffer[l/r] = AC97Input[l/r] */
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_ADC_CAP_L
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_EXTIN
argument_list|(
name|A_EXTIN_AC97_L
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|audigy_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|A_EXTOUT
argument_list|(
name|A_EXTOUT_ADC_CAP_R
argument_list|)
argument_list|,
name|A_C_00000000
argument_list|,
name|A_C_00000000
argument_list|,
name|A_EXTIN
argument_list|(
name|A_EXTIN_AC97_R
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* resume normal operations */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|A_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_initefx
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|pc
init|=
literal|16
decl_stmt|;
comment|/* acc3 0,0,0,0 - NOPs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
block|{
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
name|i
operator|*
literal|2
argument_list|,
literal|0x10040
argument_list|)
expr_stmt|;
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
name|i
operator|*
literal|2
operator|+
literal|1
argument_list|,
literal|0x610040
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FXGPREGBASE
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FX-8010 DSP Registers: 	   FX Bus 	     0x000-0x00f : 16 registers 	   Input 	     0x010/0x011 : AC97 Codec (l/r) 	     0x012/0x013 : ADC, S/PDIF (l/r) 	     0x014/0x015 : Mic(left), Zoom (l/r) 	     0x016/0x017 : TOS link in (l/r) 	     0x018/0x019 : Line/Mic 1 (l/r) 	     0x01a/0x01b : COAX S/PDIF (l/r) 	     0x01c/0x01d : Line/Mic 2 (l/r) 	   Output 	     0x020/0x021 : AC97 Output (l/r) 	     0x022/0x023 : TOS link out (l/r) 	     0x024/0x025 : Center/LFE 	     0x026/0x027 : LiveDrive Headphone (l/r) 	     0x028/0x029 : Rear Channel (l/r) 	     0x02a/0x02b : ADC Recording Buffer (l/r) 	     0x02c       : Mic Recording Buffer 	     0x031/0x032 : Analog Center/LFE 	   Constants 	     0x040 - 0x044 = 0 - 4 	     0x045 = 0x8, 0x046 = 0x10, 0x047 = 0x20 	     0x048 = 0x100, 0x049 = 0x10000, 0x04a = 0x80000 	     0x04b = 0x10000000, 0x04c = 0x20000000, 0x04d = 0x40000000 	     0x04e = 0x80000000, 0x04f = 0x7fffffff, 0x050 = 0xffffffff 	     0x051 = 0xfffffffe, 0x052 = 0xc0000000, 0x053 = 0x41fbbcdc 	     0x054 = 0x5a7ef9db, 0x055 = 0x00100000 	   Temporary Values 	     0x056 : Accumulator 	     0x057 : Condition Register 	     0x058 : Noise source 	     0x059 : Noise source 	     0x05a : IRQ Register 	     0x05b : TRAM Delay Base Address Count 	   General Purpose Registers 	     0x100 - 0x1ff 	   Tank Memory Data Registers 	     0x200 - 0x2ff 	   Tank Memory Address Registers 	     0x300 - 0x3ff 	     */
comment|/* Routing - this will be configurable in later version */
comment|/* GPR[0/1] = FX * 4 + SPDIF-in */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iMACINT0
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|EXTIN
argument_list|(
name|EXTIN_SPDIF_CD_L
argument_list|)
argument_list|,
name|FXBUS
argument_list|(
name|FXBUS_PCM_LEFT
argument_list|)
argument_list|,
name|C_00000004
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iMACINT0
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|EXTIN
argument_list|(
name|EXTIN_SPDIF_CD_R
argument_list|)
argument_list|,
name|FXBUS
argument_list|(
name|FXBUS_PCM_RIGHT
argument_list|)
argument_list|,
name|C_00000004
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* GPR[0/1] += APS-input */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|sc
operator|->
name|APS
condition|?
name|EXTIN
argument_list|(
name|EXTIN_TOSLINK_L
argument_list|)
else|:
name|C_00000000
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|sc
operator|->
name|APS
condition|?
name|EXTIN
argument_list|(
name|EXTIN_TOSLINK_R
argument_list|)
else|:
name|C_00000000
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* FrontOut (AC97) = GPR[0/1] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_AC97_L
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_AC97_R
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000001
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* GPR[2] = GPR[0] (Left) / 2 + GPR[1] (Right) / 2 -- Central volume */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iINTERP
argument_list|,
name|GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|C_40000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* RearOut = (GPR[0/1] * RearVolume)>> 31 */
comment|/*   RearVolume = GPR[0x10/0x11] */
block|emu_addefxop(sc, iMAC0, EXTOUT(EXTOUT_REAR_L), C_00000000, 			GPR(16), GPR(0),&pc); 	emu_addefxop(sc, iMAC0, EXTOUT(EXTOUT_REAR_R), C_00000000, 			GPR(17), GPR(1),&pc);
else|#
directive|else
comment|/* XXX This is just a copy to the channel, since we do not have 	 *     a patch manager, it is useful for have another output enabled. 	 */
comment|/* Rear[l/r] = GPR[0/1] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_REAR_L
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_REAR_R
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TOS out[l/r] = GPR[0/1] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_TOSLINK_L
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_TOSLINK_R
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Center and Subwoofer configuration */
comment|/* Analog Center = GPR[0] + GPR[2] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_ACENTER
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Analog Sub = GPR[1] + GPR[2] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_ALFE
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Digital Center = GPR[0] + GPR[2] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_CENTER
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Digital Sub = GPR[1] + GPR[2] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_LFE
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GPR
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* Headphones[l/r] = GPR[0/1] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_HEADPHONE_L
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_HEADPHONE_R
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|GPR
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* ADC Recording buffer[l/r] = AC97Input[l/r] */
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_ADC_CAP_L
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|EXTIN
argument_list|(
name|EXTIN_AC97_L
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|iACC3
argument_list|,
name|EXTOUT
argument_list|(
name|EXTOUT_ADC_CAP_R
argument_list|)
argument_list|,
name|C_00000000
argument_list|,
name|C_00000000
argument_list|,
name|EXTIN
argument_list|(
name|EXTIN_AC97_R
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* resume normal operations */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Probe and attach the card */
end_comment

begin_function
specifier|static
name|int
name|emu_init
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|spcs
decl_stmt|,
name|ch
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
comment|/* enable additional AC97 slots */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|AC97SLOT
argument_list|,
name|AC97SLOT_CNTR
operator||
name|AC97SLOT_LFE
argument_list|)
expr_stmt|;
block|}
comment|/* disable audio and lock cache */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|HCFG_LOCKSOUNDCACHE
operator||
name|HCFG_LOCKTANKCACHE_MASK
operator||
name|HCFG_MUTEBUTTONENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* reset recording buffers */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|MICBS
argument_list|,
name|ADCBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|MICBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FXBS
argument_list|,
name|ADCBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FXBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ADCBS
argument_list|,
name|ADCBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ADCBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable channel interrupt */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
name|INTE_INTERVALTIMERENB
operator||
name|INTE_SAMPLERATETRACKER
operator||
name|INTE_PCIERRORENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|CLIEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|CLIEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SOLEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SOLEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wonder what these do... */
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SPBYPASS
argument_list|,
literal|0xf00
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|AC97SLOT
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
block|}
comment|/* init envelope engine */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|DCYSUSV
argument_list|,
name|ENV_OFF
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|IP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|VTFT
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CVCF
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|PTRX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CPF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|PSST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|DSL
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CCCA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|Z1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|Z2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|FXRT
argument_list|,
literal|0xd01c0000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|ATKHLDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|DCYSUSM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|IFATN
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|PEFE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|FMMOD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|TREMFRQ
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* 1 Hz */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|FM2FRQ2
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* 1 Hz */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|TEMPENV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*** these are last so OFF prevents writing ***/
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|LFOVAL2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|LFOVAL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|ATKHLDV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|ENVVOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|ENVVAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
comment|/* audigy cards need this to initialize correctly */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set default routing */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|A_FXRT1
argument_list|,
literal|0x03020100
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|A_FXRT2
argument_list|,
literal|0x3f3f3f3f
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|A_SENDAMOUNTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|vnum
operator|=
name|ch
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|slave
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|ismaster
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|b16
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|stereo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|ch
index|]
operator|.
name|channel
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|pnum
operator|=
name|sc
operator|->
name|rnum
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Init to 0x02109204 : 	 *  Clock accuracy    = 0     (1000ppm) 	 *  Sample Rate       = 2     (48kHz) 	 *  Audio Channel     = 1     (Left of 2) 	 *  Source Number     = 0     (Unspecified) 	 *  Generation Status = 1     (Original for Cat Code 12) 	 *  Cat Code          = 12    (Digital Signal Mixer) 	 *  Mode              = 0     (Mode 0) 	 *  Emphasis          = 0     (None) 	 *  CP                = 1     (Copyright unasserted) 	 *  AN                = 0     (Audio data) 	 *  P                 = 0     (Consumer) 	 */
name|spcs
operator|=
name|SPCS_CLKACCY_1000PPM
operator||
name|SPCS_SAMPLERATE_48
operator||
name|SPCS_CHANNELNUM_LEFT
operator||
name|SPCS_SOURCENUM_UNSPEC
operator||
name|SPCS_GENERATIONSTATUS
operator||
literal|0x00001200
operator||
literal|0x00000000
operator||
name|SPCS_EMPHASIS_NONE
operator||
name|SPCS_COPYRIGHT
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SPCS0
argument_list|,
name|spcs
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SPCS1
argument_list|,
name|spcs
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SPCS2
argument_list|,
name|spcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|audigy
condition|)
name|emu_initefx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|audigy2
condition|)
block|{
comment|/* Audigy 2 */
comment|/* from ALSA initialization code: */
comment|/* Hack for Alice3 to work independent of haP16V driver */
name|u_int32_t
name|tmp
decl_stmt|;
comment|/* Setup SRCMulti_I2S SamplingRate */
name|tmp
operator|=
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|A_SPDIF_SAMPLERATE
argument_list|)
operator|&
literal|0xfffff1ff
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|A_SPDIF_SAMPLERATE
argument_list|,
name|tmp
operator||
literal|0x400
argument_list|)
expr_stmt|;
comment|/* Setup SRCSel (Enable SPDIF, I2S SRCMulti) */
name|emu_wr
argument_list|(
name|sc
argument_list|,
literal|0x20
argument_list|,
literal|0x00600000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
literal|0x24
argument_list|,
literal|0x00000014
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Setup SRCMulti Input Audio Enable */
name|emu_wr
argument_list|(
name|sc
argument_list|,
literal|0x20
argument_list|,
literal|0x006e0000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
literal|0x24
argument_list|,
literal|0xff00ff00
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mem
operator|.
name|blocks
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
operator|=
name|emu_malloc
argument_list|(
name|sc
argument_list|,
name|EMUMAXPAGES
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|ptb_pages_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|sc
operator|->
name|mem
operator|.
name|silent_page
operator|=
name|emu_malloc
argument_list|(
name|sc
argument_list|,
name|EMUPAGESIZE
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|.
name|silent_page
operator|==
name|NULL
condition|)
block|{
name|emu_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Clear page with silence& setup all pointers to this page */
name|bzero
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page
argument_list|,
name|EMUPAGESIZE
argument_list|)
expr_stmt|;
name|tmp
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMUMAXPAGES
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
index|[
name|i
index|]
operator|=
name|tmp
operator||
name|i
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|PTB
argument_list|,
operator|(
name|sc
operator|->
name|mem
operator|.
name|ptb_pages_addr
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TCB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* taken from original driver */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TCBS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* taken from original driver */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|MAPA
argument_list|,
name|tmp
operator||
name|MAP_PTI_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|MAPB
argument_list|,
name|tmp
operator||
name|MAP_PTI_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* emu_memalloc(sc, EMUPAGESIZE); */
comment|/* 	 *  Hokay, now enable the AUD bit 	 * 	 *  Audigy 	 *   Enable Audio = 0 (enabled after fx processor initialization) 	 *   Mute Disable Audio = 0 	 *   Joystick = 1 	 * 	 *  Audigy 2 	 *   Enable Audio = 1 	 *   Mute Disable Audio = 0 	 *   Joystick = 1 	 *   GP S/PDIF AC3 Enable = 1 	 *   CD S/PDIF AC3 Enable = 1 	 * 	 *  EMU10K1 	 *   Enable Audio = 1 	 *   Mute Disable Audio = 0 	 *   Lock Tank Memory = 1 	 *   Lock Sound Memory = 0 	 *   Auto Mute = 1 	 */
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
name|tmp
operator|=
name|HCFG_AUTOMUTE
operator||
name|HCFG_JOYENABLE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|audigy2
condition|)
comment|/* Audigy 2 */
name|tmp
operator|=
name|HCFG_AUDIOENABLE
operator||
name|HCFG_AC3ENABLE_CDSPDIF
operator||
name|HCFG_AC3ENABLE_GPSPDIF
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|audigy_initefx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* from ALSA initialization code: */
comment|/* enable audio and disable both audio/digital outputs */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
literal|4
argument_list|)
operator||
name|HCFG_AUDIOENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|A_IOCFG
argument_list|,
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|A_IOCFG
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
name|A_IOCFG_GPOUT_AD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|audigy2
condition|)
block|{
comment|/* Audigy 2 */
comment|/* Unmute Analog. 			 * Set GPO6 to 1 for Apollo. This has to be done after 			 * init Alice3 I2SOut beyond 48kHz. 			 * So, sequence is important. 			 */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|A_IOCFG
argument_list|,
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|A_IOCFG
argument_list|,
literal|4
argument_list|)
operator||
name|A_IOCFG_GPOUT_A
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* EMU10K1 initialization code */
name|tmp
operator|=
name|HCFG_AUDIOENABLE
operator||
name|HCFG_LOCKTANKCACHE_MASK
operator||
name|HCFG_AUTOMUTE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rev
operator|>=
literal|6
condition|)
name|tmp
operator||=
name|HCFG_JOYENABLE
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* TOSLink detection */
name|sc
operator|->
name|tos_link
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
operator|(
name|HCFG_GPINPUT0
operator||
name|HCFG_GPINPUT1
operator|)
condition|)
block|{
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|tmp
operator||
name|HCFG_GPOUT1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
operator|(
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
name|HCFG_GPOUT1
operator|)
condition|)
block|{
name|sc
operator|->
name|tos_link
operator|=
literal|1
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|tmp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_uninit
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|ch
decl_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|INTE
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|DCYSUSV
argument_list|,
name|ENV_OFF
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|VTFT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CVCF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|PTRX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|CPF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|audigy
condition|)
block|{
comment|/* stop fx processor */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|A_DBG
argument_list|,
name|A_DBG_SINGLE_STEP
argument_list|)
expr_stmt|;
block|}
comment|/* disable audio and lock cache */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|HCFG
argument_list|,
name|HCFG_LOCKSOUNDCACHE
operator||
name|HCFG_LOCKTANKCACHE_MASK
operator||
name|HCFG_MUTEBUTTONENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|PTB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset recording buffers */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|MICBS
argument_list|,
name|ADCBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|MICBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FXBS
argument_list|,
name|ADCBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FXBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FXWC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ADCBS
argument_list|,
name|ADCBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|ADCBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TCB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|TCBS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable channel interrupt */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|CLIEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|CLIEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SOLEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|SOLEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* init envelope engine */
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|mem
operator|.
name|blocks
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"warning: memblock list not empty\n"
argument_list|)
expr_stmt|;
name|emu_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
argument_list|)
expr_stmt|;
name|emu_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|silent_page
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|EMU10K1_PCI_ID
case|:
name|s
operator|=
literal|"Creative EMU10K1"
expr_stmt|;
break|break;
case|case
name|EMU10K2_PCI_ID
case|:
if|if
condition|(
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x04
condition|)
name|s
operator|=
literal|"Creative Audigy 2 (EMU10K2)"
expr_stmt|;
else|else
name|s
operator|=
literal|"Creative Audigy (EMU10K2)"
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|NULL
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|gotmic
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sound softc"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|audigy
operator|=
operator|(
name|sc
operator|->
name|type
operator|==
name|EMU10K2_PCI_ID
operator|)
expr_stmt|;
name|sc
operator|->
name|audigy2
operator|=
operator|(
name|sc
operator|->
name|audigy
operator|&&
name|sc
operator|->
name|rev
operator|==
literal|0x04
operator|)
expr_stmt|;
name|sc
operator|->
name|nchans
operator|=
name|sc
operator|->
name|audigy
condition|?
literal|8
else|:
literal|4
expr_stmt|;
name|sc
operator|->
name|addrmask
operator|=
name|sc
operator|->
name|audigy
condition|?
name|A_PTR_ADDRESS_MASK
else|:
name|PTR_ADDRESS_MASK
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|i
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|i
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map register space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|EMU_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|2
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
literal|1
operator|<<
literal|31
argument_list|,
comment|/* can only access 0-2gb */
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|sc
operator|->
name|bufsz
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|emu_init
argument_list|(
name|sc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize the card\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|emu_ac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|gotmic
operator|=
operator|(
name|ac97_getcaps
argument_list|(
name|codec
argument_list|)
operator|&
name|AC97_CAP_MICCHANNEL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|codec
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|bad
goto|;
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|i
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
operator|||
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
literal|0
argument_list|,
name|emu_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx irq %ld %s"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_emu10k1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|nchans
argument_list|,
name|gotmic
condition|?
literal|3
else|:
literal|2
argument_list|)
condition|)
goto|goto
name|bad
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nchans
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|emupchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|gotmic
condition|?
literal|3
else|:
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|emurchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|codec
condition|)
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lock
condition|)
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* shutdown chip */
name|emu_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* add suspend, resume */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|emu_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|emu_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|emu_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|emu_pci_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|emu_driver
init|=
block|{
literal|"pcm"
block|,
name|emu_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_emu10k1
argument_list|,
name|pci
argument_list|,
name|emu_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_emu10k1
argument_list|,
name|snd_pcm
argument_list|,
name|PCM_MINVER
argument_list|,
name|PCM_PREFVER
argument_list|,
name|PCM_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_emu10k1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* dummy driver to silence the joystick device */
end_comment

begin_function
specifier|static
name|int
name|emujoy_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x70021102
case|:
name|s
operator|=
literal|"Creative EMU10K1 Joystick"
expr_stmt|;
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70031102
case|:
name|s
operator|=
literal|"Creative EMU10K2 Joystick"
expr_stmt|;
name|device_quiet
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|s
condition|?
operator|-
literal|1000
else|:
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emujoy_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emujoy_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|emujoy_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|emujoy_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|emujoy_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|emujoy_pci_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|emujoy_driver
init|=
block|{
literal|"emujoy"
block|,
name|emujoy_methods
block|,
literal|8
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|emujoy_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|emujoy
argument_list|,
name|pci
argument_list|,
name|emujoy_driver
argument_list|,
name|emujoy_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

