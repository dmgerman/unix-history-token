begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Seigo Tanimura  * All rights reserved.  *  * Portions of this source are based on cwcealdr.cpp and dhwiface.cpp in  * cwcealdr1.zip, the sample sources by Crystal Semiconductor.  * Copyright (c) 1996-1998 Crystal Semiconductor Corp.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/csareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/csavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Buffer size on dma transfer. Fixed for CS416x. */
end_comment

begin_define
define|#
directive|define
name|CS461x_BUFFSIZE
value|(4 * 1024)
end_define

begin_define
define|#
directive|define
name|GOF_PER_SEC
value|200
end_define

begin_comment
comment|/* device private data */
end_comment

begin_struct_decl
struct_decl|struct
name|csa_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|csa_chinfo
block|{
name|struct
name|csa_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|;
name|int
name|dma
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|csa_info
block|{
name|csa_res
name|res
decl_stmt|;
comment|/* resource */
name|void
modifier|*
name|ih
decl_stmt|;
comment|/* Interrupt cookie */
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
comment|/* DMA tag */
name|struct
name|csa_bridgeinfo
modifier|*
name|binfo
decl_stmt|;
comment|/* The state of the parent. */
name|struct
name|csa_card
modifier|*
name|card
decl_stmt|;
name|int
name|active
decl_stmt|;
comment|/* Contents of board's registers */
name|u_long
name|pfie
decl_stmt|;
name|u_long
name|pctl
decl_stmt|;
name|u_long
name|cctl
decl_stmt|;
name|struct
name|csa_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
name|u_int32_t
name|ac97
index|[
name|CS461x_AC97_NUMBER_RESTORE_REGS
index|]
decl_stmt|;
name|u_int32_t
name|ac97_powerdown
decl_stmt|;
name|u_int32_t
name|ac97_general_purpose
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|csa_init
parameter_list|(
name|struct
name|csa_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_setplaysamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulInRate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_setcapturesamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulOutRate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_startplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_startcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_stopplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_stopcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csa_startdsp
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csa_stopdsp
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csa_allocres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_releaseres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_ac97_suspend
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_ac97_resume
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int32_t
name|csa_playfmt
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S8
block|,
name|AFMT_STEREO
operator||
name|AFMT_S8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
name|AFMT_S16_BE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_BE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|csa_playcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|csa_playfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|csa_recfmt
index|[]
init|=
block|{
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|csa_reccaps
init|=
block|{
literal|11025
block|,
literal|48000
block|,
name|csa_recfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|csa_active
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|,
name|int
name|run
parameter_list|)
block|{
name|int
name|old
decl_stmt|;
name|old
operator|=
name|csa
operator|->
name|active
expr_stmt|;
name|csa
operator|->
name|active
operator|+=
name|run
expr_stmt|;
if|if
condition|(
operator|(
name|csa
operator|->
name|active
operator|>
literal|1
operator|)
operator|||
operator|(
name|csa
operator|->
name|active
operator|<
operator|-
literal|1
operator|)
condition|)
name|csa
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|card
operator|->
name|active
condition|)
return|return
operator|(
name|csa
operator|->
name|card
operator|->
name|active
argument_list|(
operator|!
operator|(
name|csa
operator|->
name|active
operator|&&
name|old
operator|)
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ac97 codec */
end_comment

begin_function
specifier|static
name|int
name|csa_rdcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
operator|(
expr|struct
name|csa_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|regno
operator|+
name|BA0_AC97_RESET
argument_list|,
operator|&
name|data
argument_list|)
condition|)
name|data
operator|=
literal|0
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csa_wrcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
operator|(
expr|struct
name|csa_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|regno
operator|+
name|BA0_AC97_RESET
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|csa_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|csa_rdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|csa_wrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|csa_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|csa_setplaysamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulInRate
parameter_list|)
block|{
name|u_long
name|ulTemp1
decl_stmt|,
name|ulTemp2
decl_stmt|;
name|u_long
name|ulPhiIncr
decl_stmt|;
name|u_long
name|ulCorrectionPerGOF
decl_stmt|,
name|ulCorrectionPerSec
decl_stmt|;
name|u_long
name|ulOutRate
decl_stmt|;
name|ulOutRate
operator|=
literal|48000
expr_stmt|;
comment|/* 	 * Compute the values used to drive the actual sample rate conversion. 	 * The following formulas are being computed, using inline assembly 	 * since we need to use 64 bit arithmetic to compute the values: 	 * 	 *     ulPhiIncr = floor((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF = floor((Fs,in * 2^26 - Fs,out * ulPhiIncr) / 	 *                                GOF_PER_SEC) 	 *     ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr - 	 *                          GOF_PER_SEC * ulCorrectionPerGOF 	 * 	 * i.e. 	 * 	 *     ulPhiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF:ulCorrectionPerSec = 	 *         dividend:remainder(ulOther / GOF_PER_SEC) 	 */
name|ulTemp1
operator|=
name|ulInRate
operator|<<
literal|16
expr_stmt|;
name|ulPhiIncr
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|-=
name|ulPhiIncr
operator|*
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|<<=
literal|10
expr_stmt|;
name|ulPhiIncr
operator|<<=
literal|10
expr_stmt|;
name|ulTemp2
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulPhiIncr
operator|+=
name|ulTemp2
expr_stmt|;
name|ulTemp1
operator|-=
name|ulTemp2
operator|*
name|ulOutRate
expr_stmt|;
name|ulCorrectionPerGOF
operator|=
name|ulTemp1
operator|/
name|GOF_PER_SEC
expr_stmt|;
name|ulTemp1
operator|-=
name|ulCorrectionPerGOF
operator|*
name|GOF_PER_SEC
expr_stmt|;
name|ulCorrectionPerSec
operator|=
name|ulTemp1
expr_stmt|;
comment|/* 	 * Fill in the SampleRateConverter control block. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PSRC
argument_list|,
operator|(
operator|(
name|ulCorrectionPerSec
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
operator||
operator|(
name|ulCorrectionPerGOF
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PPI
argument_list|,
name|ulPhiIncr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_setcapturesamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulOutRate
parameter_list|)
block|{
name|u_long
name|ulPhiIncr
decl_stmt|,
name|ulCoeffIncr
decl_stmt|,
name|ulTemp1
decl_stmt|,
name|ulTemp2
decl_stmt|;
name|u_long
name|ulCorrectionPerGOF
decl_stmt|,
name|ulCorrectionPerSec
decl_stmt|,
name|ulInitialDelay
decl_stmt|;
name|u_long
name|dwFrameGroupLength
decl_stmt|,
name|dwCnt
decl_stmt|;
name|u_long
name|ulInRate
decl_stmt|;
name|ulInRate
operator|=
literal|48000
expr_stmt|;
comment|/* 	 * We can only decimate by up to a factor of 1/9th the hardware rate. 	 * Return an error if an attempt is made to stray outside that limit. 	 */
if|if
condition|(
operator|(
name|ulOutRate
operator|*
literal|9
operator|)
operator|<
name|ulInRate
condition|)
return|return;
comment|/* 	 * We can not capture at at rate greater than the Input Rate (48000). 	 * Return an error if an attempt is made to stray outside that limit. 	 */
if|if
condition|(
name|ulOutRate
operator|>
name|ulInRate
condition|)
return|return;
comment|/* 	 * Compute the values used to drive the actual sample rate conversion. 	 * The following formulas are being computed, using inline assembly 	 * since we need to use 64 bit arithmetic to compute the values: 	 * 	 *     ulCoeffIncr = -floor((Fs,out * 2^23) / Fs,in) 	 *     ulPhiIncr = floor((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF = floor((Fs,in * 2^26 - Fs,out * ulPhiIncr) / 	 *                                GOF_PER_SEC) 	 *     ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr - 	 *                          GOF_PER_SEC * ulCorrectionPerGOF 	 *     ulInitialDelay = ceil((24 * Fs,in) / Fs,out) 	 * 	 * i.e. 	 * 	 *     ulCoeffIncr = neg(dividend((Fs,out * 2^23) / Fs,in)) 	 *     ulPhiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF:ulCorrectionPerSec = 	 *         dividend:remainder(ulOther / GOF_PER_SEC) 	 *     ulInitialDelay = dividend(((24 * Fs,in) + Fs,out - 1) / Fs,out) 	 */
name|ulTemp1
operator|=
name|ulOutRate
operator|<<
literal|16
expr_stmt|;
name|ulCoeffIncr
operator|=
name|ulTemp1
operator|/
name|ulInRate
expr_stmt|;
name|ulTemp1
operator|-=
name|ulCoeffIncr
operator|*
name|ulInRate
expr_stmt|;
name|ulTemp1
operator|<<=
literal|7
expr_stmt|;
name|ulCoeffIncr
operator|<<=
literal|7
expr_stmt|;
name|ulCoeffIncr
operator|+=
name|ulTemp1
operator|/
name|ulInRate
expr_stmt|;
name|ulCoeffIncr
operator|^=
literal|0xFFFFFFFF
expr_stmt|;
name|ulCoeffIncr
operator|++
expr_stmt|;
name|ulTemp1
operator|=
name|ulInRate
operator|<<
literal|16
expr_stmt|;
name|ulPhiIncr
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|-=
name|ulPhiIncr
operator|*
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|<<=
literal|10
expr_stmt|;
name|ulPhiIncr
operator|<<=
literal|10
expr_stmt|;
name|ulTemp2
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulPhiIncr
operator|+=
name|ulTemp2
expr_stmt|;
name|ulTemp1
operator|-=
name|ulTemp2
operator|*
name|ulOutRate
expr_stmt|;
name|ulCorrectionPerGOF
operator|=
name|ulTemp1
operator|/
name|GOF_PER_SEC
expr_stmt|;
name|ulTemp1
operator|-=
name|ulCorrectionPerGOF
operator|*
name|GOF_PER_SEC
expr_stmt|;
name|ulCorrectionPerSec
operator|=
name|ulTemp1
expr_stmt|;
name|ulInitialDelay
operator|=
operator|(
operator|(
name|ulInRate
operator|*
literal|24
operator|)
operator|+
name|ulOutRate
operator|-
literal|1
operator|)
operator|/
name|ulOutRate
expr_stmt|;
comment|/* 	 * Fill in the VariDecimate control block. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CSRC
argument_list|,
operator|(
operator|(
name|ulCorrectionPerSec
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
operator||
operator|(
name|ulCorrectionPerGOF
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCI
argument_list|,
name|ulCoeffIncr
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CD
argument_list|,
operator|(
operator|(
operator|(
name|BA1_VARIDEC_BUF_1
operator|+
operator|(
name|ulInitialDelay
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CPI
argument_list|,
name|ulPhiIncr
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the frame group length for the write back task.  Basically, 	 * this is just the factors of 24000 (2^6*3*5^3) that are not present in 	 * the output sample rate. 	 */
name|dwFrameGroupLength
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|dwCnt
operator|=
literal|2
init|;
name|dwCnt
operator|<=
literal|64
condition|;
name|dwCnt
operator|*=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ulOutRate
operator|/
name|dwCnt
operator|)
operator|*
name|dwCnt
operator|)
operator|!=
name|ulOutRate
condition|)
block|{
name|dwFrameGroupLength
operator|*=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ulOutRate
operator|/
literal|3
operator|)
operator|*
literal|3
operator|)
operator|!=
name|ulOutRate
condition|)
block|{
name|dwFrameGroupLength
operator|*=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|dwCnt
operator|=
literal|5
init|;
name|dwCnt
operator|<=
literal|125
condition|;
name|dwCnt
operator|*=
literal|5
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ulOutRate
operator|/
name|dwCnt
operator|)
operator|*
name|dwCnt
operator|)
operator|!=
name|ulOutRate
condition|)
block|{
name|dwFrameGroupLength
operator|*=
literal|5
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill in the WriteBack control block. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CFG1
argument_list|,
name|dwFrameGroupLength
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CFG2
argument_list|,
operator|(
literal|0x00800000
operator||
name|dwFrameGroupLength
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCST
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CSPB
argument_list|,
operator|(
operator|(
literal|65536
operator|*
name|ulOutRate
operator|)
operator|/
literal|24000
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
operator|(
name|BA1_CSPB
operator|+
literal|4
operator|)
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_startplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
if|if
condition|(
operator|!
name|csa
operator|->
name|pch
operator|.
name|dma
condition|)
block|{
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|)
expr_stmt|;
name|ul
operator|&=
literal|0x0000ffff
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|,
name|ul
operator||
name|csa
operator|->
name|pctl
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PVOL
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
name|csa
operator|->
name|pch
operator|.
name|dma
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|csa_startcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
if|if
condition|(
operator|!
name|csa
operator|->
name|rch
operator|.
name|dma
condition|)
block|{
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|)
expr_stmt|;
name|ul
operator|&=
literal|0xffff0000
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|,
name|ul
operator||
name|csa
operator|->
name|cctl
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CVOL
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
name|csa
operator|->
name|rch
operator|.
name|dma
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|csa_stopplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
if|if
condition|(
name|csa
operator|->
name|pch
operator|.
name|dma
condition|)
block|{
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|)
expr_stmt|;
name|csa
operator|->
name|pctl
operator|=
name|ul
operator|&
literal|0xffff0000
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|,
name|ul
operator|&
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PVOL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|csa
operator|->
name|pch
operator|.
name|dma
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The bitwise pointer of the serial FIFO in the DSP 		 * seems to make an error upon starting or stopping the 		 * DSP. Clear the FIFO and correct the pointer if we 		 * are not capturing. 		 */
if|if
condition|(
operator|!
name|csa
operator|->
name|rch
operator|.
name|dma
condition|)
block|{
name|csa_clearserialfifos
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_SERBSP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|csa_stopcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
if|if
condition|(
name|csa
operator|->
name|rch
operator|.
name|dma
condition|)
block|{
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|)
expr_stmt|;
name|csa
operator|->
name|cctl
operator|=
name|ul
operator|&
literal|0x0000ffff
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|,
name|ul
operator|&
literal|0xffff0000
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CVOL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|csa
operator|->
name|rch
operator|.
name|dma
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The bitwise pointer of the serial FIFO in the DSP 		 * seems to make an error upon starting or stopping the 		 * DSP. Clear the FIFO and correct the pointer if we 		 * are not playing. 		 */
if|if
condition|(
operator|!
name|csa
operator|->
name|pch
operator|.
name|dma
condition|)
block|{
name|csa_clearserialfifos
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_SERBSP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|csa_startdsp
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
comment|/* 	 * Set the frame timer to reflect the number of cycles per frame. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_FRMT
argument_list|,
literal|0xadf
argument_list|)
expr_stmt|;
comment|/* 	 * Turn on the run, run at frame, and DMA enable bits in the local copy of 	 * the SP control register. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_SPCR
argument_list|,
name|SPCR_RUN
operator||
name|SPCR_RUNFR
operator||
name|SPCR_DRQEN
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until the run at frame bit resets itself in the SP control 	 * register. 	 */
name|ul
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait a little bit, so we don't issue PCI reads too frequently. 		 */
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 		 * Fetch the current value of the SP status register. 		 */
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_SPCR
argument_list|)
expr_stmt|;
comment|/* 		 * If the run at frame bit has reset, then stop waiting. 		 */
if|if
condition|(
operator|(
name|ul
operator|&
name|SPCR_RUNFR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If the run at frame bit never reset, then return an error. 	 */
if|if
condition|(
operator|(
name|ul
operator|&
name|SPCR_RUNFR
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csa_stopdsp
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
block|{
comment|/* 	 * Turn off the run, run at frame, and DMA enable bits in 	 * the local copy of the SP control register. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_SPCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csa_setupchan
parameter_list|(
name|struct
name|csa_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|csa_res
modifier|*
name|resp
init|=
operator|&
name|csa
operator|->
name|res
decl_stmt|;
name|u_long
name|pdtc
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
comment|/* direction */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PBA
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* format */
name|csa
operator|->
name|pfie
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|)
operator|&
operator|~
literal|0x0000f03f
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_SIGNED
operator|)
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x8000
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_BIGENDIAN
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x4000
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
operator|)
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x2000
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_8BIT
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x1000
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|,
name|csa
operator|->
name|pfie
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_16BIT
condition|)
name|tmp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
condition|)
name|tmp
operator|<<=
literal|1
expr_stmt|;
name|tmp
operator|--
expr_stmt|;
name|pdtc
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PDTC
argument_list|)
operator|&
operator|~
literal|0x000001ff
expr_stmt|;
name|pdtc
operator||=
name|tmp
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PDTC
argument_list|,
name|pdtc
argument_list|)
expr_stmt|;
comment|/* rate */
name|csa_setplaysamplerate
argument_list|(
name|resp
argument_list|,
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
comment|/* direction */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CBA
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* format */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|)
operator|&
operator|~
literal|0x0000003f
operator|)
operator||
literal|0x00000001
argument_list|)
expr_stmt|;
comment|/* rate */
name|csa_setcapturesamplerate
argument_list|(
name|resp
argument_list|,
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|csachan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|devinfo
decl_stmt|;
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|csa
operator|->
name|pch
else|:
operator|&
name|csa
operator|->
name|rch
decl_stmt|;
name|ch
operator|->
name|parent
operator|=
name|csa
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|csa
operator|->
name|parent_dmat
argument_list|,
literal|0
argument_list|,
name|CS461x_BUFFSIZE
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
comment|/* XXX calc real speed */
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
return|return
name|CS461x_BUFFSIZE
operator|/
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
operator|!
name|PCMTRIG_COMMON
argument_list|(
name|go
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|csa_active
argument_list|(
name|csa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csa_setupchan
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|csa_startplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
else|else
name|csa_startcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|csa_stopplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
else|else
name|csa_stopcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|int
name|ptr
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|ptr
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PBA
argument_list|)
operator|-
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_U8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S8
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CBA
argument_list|)
operator|-
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_U8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S8
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|csachan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|csa_playcaps
else|:
operator|&
name|csa_reccaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|csachan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|csachan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|csachan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|csachan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|csachan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|csachan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|csachan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|csachan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|csachan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|csa_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|csa
operator|->
name|binfo
operator|->
name|hisr
operator|&
name|HISR_VC0
operator|)
operator|!=
literal|0
condition|)
name|chn_intr
argument_list|(
name|csa
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csa
operator|->
name|binfo
operator|->
name|hisr
operator|&
name|HISR_VC1
operator|)
operator|!=
literal|0
condition|)
name|chn_intr
argument_list|(
name|csa
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Probe and attach the card  */
end_comment

begin_function
specifier|static
name|int
name|csa_init
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|csa
operator|->
name|pfie
operator|=
literal|0
expr_stmt|;
name|csa_stopplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_stopcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa_startdsp
argument_list|(
name|resp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Crank up the power on the DAC and ADC. */
name|csa_setplaysamplerate
argument_list|(
name|resp
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
name|csa_setcapturesamplerate
argument_list|(
name|resp
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
comment|/* Set defaults */
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_EGPIODR
argument_list|,
name|EGPIODR_GPOE0
argument_list|)
expr_stmt|;
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_EGPIOPTR
argument_list|,
name|EGPIOPTR_GPPT0
argument_list|)
expr_stmt|;
comment|/* Power up amplifier */
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_EGPIODR
argument_list|,
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_EGPIODR
argument_list|)
operator||
name|EGPIODR_GPOE2
argument_list|)
expr_stmt|;
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_EGPIOPTR
argument_list|,
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_EGPIOPTR
argument_list|)
operator||
name|EGPIOPTR_GPPT2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Allocates resources. */
end_comment

begin_function
specifier|static
name|int
name|csa_allocres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|io
operator|==
name|NULL
condition|)
block|{
name|resp
operator|->
name|io
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|resp
operator|->
name|io_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|io
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|resp
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|resp
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|resp
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|mem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|resp
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|resp
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|resp
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|irq
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/*alignment*/
name|CS461x_BUFFSIZE
argument_list|,
comment|/*boundary*/
name|CS461x_BUFFSIZE
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|CS461x_BUFFSIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|csa
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Releases resources. */
end_comment

begin_function
specifier|static
name|void
name|csa_releaseres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|KASSERT
argument_list|(
name|csa
operator|!=
name|NULL
argument_list|,
operator|(
literal|"called with bogus resource structure"
operator|)
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|csa
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|resp
operator|->
name|irq
argument_list|,
name|csa
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|resp
operator|->
name|irq_rid
argument_list|,
name|resp
operator|->
name|irq
argument_list|)
expr_stmt|;
name|resp
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|->
name|io
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|resp
operator|->
name|io_rid
argument_list|,
name|resp
operator|->
name|io
argument_list|)
expr_stmt|;
name|resp
operator|->
name|io
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|->
name|mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|resp
operator|->
name|mem_rid
argument_list|,
name|resp
operator|->
name|mem
argument_list|)
expr_stmt|;
name|resp
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|csa
operator|->
name|parent_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|csa
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|csa
operator|->
name|parent_dmat
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|csa
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcmcsa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* The parent device has already been probed. */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|func
operator|->
name|func
operator|!=
name|SCF_PCM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
literal|"CS461x PCM Audio"
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcmcsa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
name|csa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|csa
operator|->
name|binfo
operator|=
name|func
operator|->
name|varinfo
expr_stmt|;
comment|/* 	 * Fake the status of DMA so that the initial value of 	 * PCTL and CCTL can be stored into csa->pctl and csa->cctl, 	 * respectively. 	 */
name|csa
operator|->
name|pch
operator|.
name|dma
operator|=
name|csa
operator|->
name|rch
operator|.
name|dma
operator|=
literal|1
expr_stmt|;
name|csa
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|csa
operator|->
name|card
operator|=
name|csa
operator|->
name|binfo
operator|->
name|card
expr_stmt|;
comment|/* Allocate the resources. */
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|resp
operator|->
name|io_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|resp
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|resp
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csa_allocres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|csa_active
argument_list|(
name|csa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa_init
argument_list|(
name|csa
argument_list|)
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|csa
argument_list|,
name|csa_ac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|csa
operator|->
name|card
operator|->
name|inv_eapd
condition|)
name|ac97_setflags
argument_list|(
name|codec
argument_list|,
name|AC97_F_EAPD_INV
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|codec
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at irq %ld %s"
argument_list|,
name|rman_get_start
argument_list|(
name|resp
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_csa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable interrupt. */
if|if
condition|(
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|resp
operator|->
name|irq
argument_list|,
literal|0
argument_list|,
name|csa_intr
argument_list|,
name|csa
argument_list|,
operator|&
name|csa
operator|->
name|ih
argument_list|)
condition|)
block|{
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|,
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|)
operator|&
operator|~
literal|0x0000f03f
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|)
operator|&
operator|~
literal|0x0000003f
operator|)
operator||
literal|0x00000001
argument_list|)
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|csa
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|csachan_class
argument_list|,
name|csa
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|csachan_class
argument_list|,
name|csa
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcmcsa_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|csa
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_ac97_suspend
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0x2
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|count
operator|<=
name|CS461x_AC97_HIGHESTREGTORESTORE
operator|)
operator|&&
operator|(
name|i
operator|<
name|CS461x_AC97_NUMBER_RESTORE_REGS
operator|)
condition|;
name|count
operator|+=
literal|2
operator|,
name|i
operator|++
control|)
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_RESET
operator|+
name|count
argument_list|,
operator|&
name|csa
operator|->
name|ac97
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* mute the outputs */
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_MASTER_VOLUME
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_HEADPHONE_VOLUME
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_MASTER_VOLUME_MONO
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_PCM_OUT_VOLUME
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* save the registers that cause pops */
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
operator|&
name|csa
operator|->
name|ac97_powerdown
argument_list|)
expr_stmt|;
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_GENERAL_PURPOSE
argument_list|,
operator|&
name|csa
operator|->
name|ac97_general_purpose
argument_list|)
expr_stmt|;
comment|/* 	 * And power down everything on the AC97 codec. Well, for now, 	 * only power down the DAC/ADC and MIXER VREFON components. 	 * trouble with removing VREF. 	 */
comment|/* MIXVON */
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
name|tmp
operator||
name|CS_AC97_POWER_CONTROL_MIXVON
argument_list|)
expr_stmt|;
comment|/* ADC */
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
name|tmp
operator||
name|CS_AC97_POWER_CONTROL_ADC
argument_list|)
expr_stmt|;
comment|/* DAC */
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
name|tmp
operator||
name|CS_AC97_POWER_CONTROL_DAC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_ac97_resume
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * First, we restore the state of the general purpose register.  This 	 * contains the mic select (mic1 or mic2) and if we restore this after 	 * we restore the mic volume/boost state and mic2 was selected at 	 * suspend time, we will end up with a brief period of time where mic1 	 * is selected with the volume/boost settings for mic2, causing 	 * acoustic feedback.  So we restore the general purpose register 	 * first, thereby getting the correct mic selected before we restore 	 * the mic volume/boost. 	 */
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_GENERAL_PURPOSE
argument_list|,
name|csa
operator|->
name|ac97_general_purpose
argument_list|)
expr_stmt|;
comment|/* 	 * Now, while the outputs are still muted, restore the state of power 	 * on the AC97 part. 	 */
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
name|csa
operator|->
name|ac97_powerdown
argument_list|)
expr_stmt|;
comment|/* 	 * Restore just the first set of registers, from register number 	 * 0x02 to the register number that ulHighestRegToRestore specifies. 	 */
for|for
control|(
name|count
operator|=
literal|0x2
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|count
operator|<=
name|CS461x_AC97_HIGHESTREGTORESTORE
operator|)
operator|&&
operator|(
name|i
operator|<
name|CS461x_AC97_NUMBER_RESTORE_REGS
operator|)
condition|;
name|count
operator|+=
literal|2
operator|,
name|i
operator|++
control|)
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_RESET
operator|+
name|count
argument_list|,
name|csa
operator|->
name|ac97
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcmcsa_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|csa
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* playback interrupt disable */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|)
operator|&
operator|~
literal|0x0000f03f
operator|)
operator||
literal|0x00000010
argument_list|)
expr_stmt|;
comment|/* capture interrupt disable */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|)
operator|&
operator|~
literal|0x0000003f
operator|)
operator||
literal|0x00000011
argument_list|)
expr_stmt|;
name|csa_stopplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_stopcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_ac97_suspend
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_resetdsp
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|csa_stopdsp
argument_list|(
name|resp
argument_list|)
expr_stmt|;
comment|/* 	 *  Power down the DAC and ADC.  For now leave the other areas on. 	 */
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
literal|0x300
argument_list|)
expr_stmt|;
comment|/* 	 *  Power down the PLL. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA0_CLKCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off the Processor by turning off the software clock 	 * enable flag in the clock control register. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA0_CLKCR1
argument_list|,
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA0_CLKCR1
argument_list|)
operator|&
operator|~
name|CLKCR1_SWCE
argument_list|)
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcmcsa_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|csa
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* cs_hardware_init */
name|csa_stopplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_stopcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_ac97_resume
argument_list|(
name|csa
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa_startdsp
argument_list|(
name|resp
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Enable interrupts on the part. */
if|if
condition|(
operator|(
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_HISR
argument_list|)
operator|&
name|HISR_INTENA
operator|)
operator|==
literal|0
condition|)
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_HICR
argument_list|,
name|HICR_IEV
operator||
name|HICR_CHGM
argument_list|)
expr_stmt|;
comment|/* playback interrupt enable */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|,
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|)
operator|&
operator|~
literal|0x0000f03f
argument_list|)
expr_stmt|;
comment|/* capture interrupt enable */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|)
operator|&
operator|~
literal|0x0000003f
operator|)
operator||
literal|0x00000001
argument_list|)
expr_stmt|;
comment|/* cs_restart_part */
name|csa_setupchan
argument_list|(
operator|&
name|csa
operator|->
name|pch
argument_list|)
expr_stmt|;
name|csa_startplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_setupchan
argument_list|(
operator|&
name|csa
operator|->
name|rch
argument_list|)
expr_stmt|;
name|csa_startcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_active
argument_list|(
name|csa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|pcmcsa_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pcmcsa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pcmcsa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|pcmcsa_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|pcmcsa_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pcmcsa_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pcmcsa_driver
init|=
block|{
literal|"pcm"
block|,
name|pcmcsa_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_csapcm
argument_list|,
name|csa
argument_list|,
name|pcmcsa_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_csapcm
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_csapcm
argument_list|,
name|snd_csa
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_csapcm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

