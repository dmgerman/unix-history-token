begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Seigo Tanimura  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_include
include|#
directive|include
file|"csa.h"
end_include

begin_include
include|#
directive|include
file|"pcm.h"
end_include

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/csareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/csavar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_if
if|#
directive|if
name|NCSA
operator|>
literal|0
end_if

begin_comment
comment|/* device private data */
end_comment

begin_struct_decl
struct_decl|struct
name|csa_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|csa_chinfo
block|{
name|struct
name|csa_info
modifier|*
name|parent
decl_stmt|;
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|csa_info
block|{
name|csa_res
name|res
decl_stmt|;
comment|/* resource */
name|void
modifier|*
name|ih
decl_stmt|;
comment|/* Interrupt cookie */
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
comment|/* DMA tag */
comment|/* Contents of board's registers */
name|u_long
name|pfie
decl_stmt|;
name|u_long
name|pctl
decl_stmt|;
name|u_long
name|cctl
decl_stmt|;
name|struct
name|csa_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|csa_init
parameter_list|(
name|struct
name|csa_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_setplaysamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulInRate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_setcapturesamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulOutRate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_startplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_startcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_stopplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_stopcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_powerupadc
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_powerupdac
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csa_startdsp
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csa_allocres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_releaseres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* talk to the codec - called from ac97.c */
end_comment

begin_function_decl
specifier|static
name|u_int32_t
name|csa_rdcd
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|csa_wrcd
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* channel interface */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|csachan_init
parameter_list|(
name|void
modifier|*
name|devinfo
parameter_list|,
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csachan_setdir
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csachan_setformat
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csachan_setspeed
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csachan_setblocksize
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csachan_trigger
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|csachan_getptr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pcmchan_caps
modifier|*
name|csachan_getcaps
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|pcmchan_caps
name|csa_playcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
operator||
name|AFMT_S8
operator||
name|AFMT_S16_LE
operator||
name|AFMT_S16_BE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcmchan_caps
name|csa_reccaps
init|=
block|{
literal|11025
block|,
literal|48000
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcm_channel
name|csa_chantemplate
init|=
block|{
name|csachan_init
block|,
name|csachan_setdir
block|,
name|csachan_setformat
block|,
name|csachan_setspeed
block|,
name|csachan_setblocksize
block|,
name|csachan_trigger
block|,
name|csachan_getptr
block|,
name|csachan_getcaps
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|csachan_init
parameter_list|(
name|void
modifier|*
name|devinfo
parameter_list|,
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|devinfo
decl_stmt|;
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|csa
operator|->
name|pch
else|:
operator|&
name|csa
operator|->
name|rch
decl_stmt|;
name|ch
operator|->
name|parent
operator|=
name|csa
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|buffer
operator|->
name|bufsize
operator|=
name|CS461x_BUFFSIZE
expr_stmt|;
if|if
condition|(
name|chn_allocbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|csa
operator|->
name|parent_dmat
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setdir
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PBA
argument_list|,
name|vtophys
argument_list|(
name|ch
operator|->
name|buffer
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CBA
argument_list|,
name|vtophys
argument_list|(
name|ch
operator|->
name|buffer
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setformat
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_long
name|pdtc
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|)
operator|&
operator|~
literal|0x0000003f
operator|)
operator||
literal|0x00000001
argument_list|)
expr_stmt|;
else|else
block|{
name|csa
operator|->
name|pfie
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|)
operator|&
operator|~
literal|0x0000f03f
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_U8
operator|||
name|format
operator|&
name|AFMT_U16_LE
operator|||
name|format
operator|&
name|AFMT_U16_BE
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x8000
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_S16_BE
operator|||
name|format
operator|&
name|AFMT_U16_BE
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x4000
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x2000
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_U8
operator|||
name|format
operator|&
name|AFMT_S8
condition|)
name|csa
operator|->
name|pfie
operator||=
literal|0x1000
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|,
name|csa
operator|->
name|pfie
argument_list|)
expr_stmt|;
name|pdtc
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PDTC
argument_list|)
operator|&
operator|~
literal|0x000003ff
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|&
name|AFMT_S16_BE
operator|||
name|format
operator|&
name|AFMT_U16_BE
operator|||
name|format
operator|&
name|AFMT_S16_LE
operator|||
name|format
operator|&
name|AFMT_U16_LE
operator|)
operator|&&
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|)
name|pdtc
operator||=
literal|0x00f
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|format
operator|&
name|AFMT_S16_BE
operator|||
name|format
operator|&
name|AFMT_U16_BE
operator|||
name|format
operator|&
name|AFMT_S16_LE
operator|||
name|format
operator|&
name|AFMT_U16_LE
operator|)
operator|||
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|)
name|pdtc
operator||=
literal|0x007
expr_stmt|;
else|else
name|pdtc
operator||=
literal|0x003
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PDTC
argument_list|,
name|pdtc
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setspeed
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|csa_setplaysamplerate
argument_list|(
name|resp
argument_list|,
name|speed
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
name|csa_setcapturesamplerate
argument_list|(
name|resp
argument_list|,
name|speed
argument_list|)
expr_stmt|;
comment|/* rec/play speeds locked together - should indicate in flags */
if|#
directive|if
literal|0
block|if (ch->direction == PCMDIR_PLAY) d->rec[0].speed = speed; 	else d->play[0].speed = speed;
endif|#
directive|endif
return|return
name|speed
return|;
comment|/* XXX calc real speed */
block|}
end_function

begin_function
specifier|static
name|void
name|csa_setplaysamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulInRate
parameter_list|)
block|{
name|u_long
name|ulTemp1
decl_stmt|,
name|ulTemp2
decl_stmt|;
name|u_long
name|ulPhiIncr
decl_stmt|;
name|u_long
name|ulCorrectionPerGOF
decl_stmt|,
name|ulCorrectionPerSec
decl_stmt|;
name|u_long
name|ulOutRate
decl_stmt|;
name|ulOutRate
operator|=
literal|48000
expr_stmt|;
comment|/* 	 * Compute the values used to drive the actual sample rate conversion. 	 * The following formulas are being computed, using inline assembly 	 * since we need to use 64 bit arithmetic to compute the values: 	 * 	 *     ulPhiIncr = floor((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF = floor((Fs,in * 2^26 - Fs,out * ulPhiIncr) / 	 *                                GOF_PER_SEC) 	 *     ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr - 	 *                          GOF_PER_SEC * ulCorrectionPerGOF 	 * 	 * i.e. 	 * 	 *     ulPhiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF:ulCorrectionPerSec = 	 *         dividend:remainder(ulOther / GOF_PER_SEC) 	 */
name|ulTemp1
operator|=
name|ulInRate
operator|<<
literal|16
expr_stmt|;
name|ulPhiIncr
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|-=
name|ulPhiIncr
operator|*
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|<<=
literal|10
expr_stmt|;
name|ulPhiIncr
operator|<<=
literal|10
expr_stmt|;
name|ulTemp2
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulPhiIncr
operator|+=
name|ulTemp2
expr_stmt|;
name|ulTemp1
operator|-=
name|ulTemp2
operator|*
name|ulOutRate
expr_stmt|;
name|ulCorrectionPerGOF
operator|=
name|ulTemp1
operator|/
name|GOF_PER_SEC
expr_stmt|;
name|ulTemp1
operator|-=
name|ulCorrectionPerGOF
operator|*
name|GOF_PER_SEC
expr_stmt|;
name|ulCorrectionPerSec
operator|=
name|ulTemp1
expr_stmt|;
comment|/* 	 * Fill in the SampleRateConverter control block. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PSRC
argument_list|,
operator|(
operator|(
name|ulCorrectionPerSec
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
operator||
operator|(
name|ulCorrectionPerGOF
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PPI
argument_list|,
name|ulPhiIncr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_setcapturesamplerate
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|,
name|u_long
name|ulOutRate
parameter_list|)
block|{
name|u_long
name|ulPhiIncr
decl_stmt|,
name|ulCoeffIncr
decl_stmt|,
name|ulTemp1
decl_stmt|,
name|ulTemp2
decl_stmt|;
name|u_long
name|ulCorrectionPerGOF
decl_stmt|,
name|ulCorrectionPerSec
decl_stmt|,
name|ulInitialDelay
decl_stmt|;
name|u_long
name|dwFrameGroupLength
decl_stmt|,
name|dwCnt
decl_stmt|;
name|u_long
name|ulInRate
decl_stmt|;
name|ulInRate
operator|=
literal|48000
expr_stmt|;
comment|/* 	 * We can only decimate by up to a factor of 1/9th the hardware rate. 	 * Return an error if an attempt is made to stray outside that limit. 	 */
if|if
condition|(
operator|(
name|ulOutRate
operator|*
literal|9
operator|)
operator|<
name|ulInRate
condition|)
return|return;
comment|/* 	 * We can not capture at at rate greater than the Input Rate (48000). 	 * Return an error if an attempt is made to stray outside that limit. 	 */
if|if
condition|(
name|ulOutRate
operator|>
name|ulInRate
condition|)
return|return;
comment|/* 	 * Compute the values used to drive the actual sample rate conversion. 	 * The following formulas are being computed, using inline assembly 	 * since we need to use 64 bit arithmetic to compute the values: 	 * 	 *     ulCoeffIncr = -floor((Fs,out * 2^23) / Fs,in) 	 *     ulPhiIncr = floor((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF = floor((Fs,in * 2^26 - Fs,out * ulPhiIncr) / 	 *                                GOF_PER_SEC) 	 *     ulCorrectionPerSec = Fs,in * 2^26 - Fs,out * phiIncr - 	 *                          GOF_PER_SEC * ulCorrectionPerGOF 	 *     ulInitialDelay = ceil((24 * Fs,in) / Fs,out) 	 * 	 * i.e. 	 * 	 *     ulCoeffIncr = neg(dividend((Fs,out * 2^23) / Fs,in)) 	 *     ulPhiIncr:ulOther = dividend:remainder((Fs,in * 2^26) / Fs,out) 	 *     ulCorrectionPerGOF:ulCorrectionPerSec = 	 *         dividend:remainder(ulOther / GOF_PER_SEC) 	 *     ulInitialDelay = dividend(((24 * Fs,in) + Fs,out - 1) / Fs,out) 	 */
name|ulTemp1
operator|=
name|ulOutRate
operator|<<
literal|16
expr_stmt|;
name|ulCoeffIncr
operator|=
name|ulTemp1
operator|/
name|ulInRate
expr_stmt|;
name|ulTemp1
operator|-=
name|ulCoeffIncr
operator|*
name|ulInRate
expr_stmt|;
name|ulTemp1
operator|<<=
literal|7
expr_stmt|;
name|ulCoeffIncr
operator|<<=
literal|7
expr_stmt|;
name|ulCoeffIncr
operator|+=
name|ulTemp1
operator|/
name|ulInRate
expr_stmt|;
name|ulCoeffIncr
operator|^=
literal|0xFFFFFFFF
expr_stmt|;
name|ulCoeffIncr
operator|++
expr_stmt|;
name|ulTemp1
operator|=
name|ulInRate
operator|<<
literal|16
expr_stmt|;
name|ulPhiIncr
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|-=
name|ulPhiIncr
operator|*
name|ulOutRate
expr_stmt|;
name|ulTemp1
operator|<<=
literal|10
expr_stmt|;
name|ulPhiIncr
operator|<<=
literal|10
expr_stmt|;
name|ulTemp2
operator|=
name|ulTemp1
operator|/
name|ulOutRate
expr_stmt|;
name|ulPhiIncr
operator|+=
name|ulTemp2
expr_stmt|;
name|ulTemp1
operator|-=
name|ulTemp2
operator|*
name|ulOutRate
expr_stmt|;
name|ulCorrectionPerGOF
operator|=
name|ulTemp1
operator|/
name|GOF_PER_SEC
expr_stmt|;
name|ulTemp1
operator|-=
name|ulCorrectionPerGOF
operator|*
name|GOF_PER_SEC
expr_stmt|;
name|ulCorrectionPerSec
operator|=
name|ulTemp1
expr_stmt|;
name|ulInitialDelay
operator|=
operator|(
operator|(
name|ulInRate
operator|*
literal|24
operator|)
operator|+
name|ulOutRate
operator|-
literal|1
operator|)
operator|/
name|ulOutRate
expr_stmt|;
comment|/* 	 * Fill in the VariDecimate control block. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CSRC
argument_list|,
operator|(
operator|(
name|ulCorrectionPerSec
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
operator||
operator|(
name|ulCorrectionPerGOF
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCI
argument_list|,
name|ulCoeffIncr
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CD
argument_list|,
operator|(
operator|(
operator|(
name|BA1_VARIDEC_BUF_1
operator|+
operator|(
name|ulInitialDelay
operator|<<
literal|2
operator|)
operator|)
operator|<<
literal|16
operator|)
operator|&
literal|0xFFFF0000
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CPI
argument_list|,
name|ulPhiIncr
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out the frame group length for the write back task.  Basically, 	 * this is just the factors of 24000 (2^6*3*5^3) that are not present in 	 * the output sample rate. 	 */
name|dwFrameGroupLength
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|dwCnt
operator|=
literal|2
init|;
name|dwCnt
operator|<=
literal|64
condition|;
name|dwCnt
operator|*=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ulOutRate
operator|/
name|dwCnt
operator|)
operator|*
name|dwCnt
operator|)
operator|!=
name|ulOutRate
condition|)
block|{
name|dwFrameGroupLength
operator|*=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|ulOutRate
operator|/
literal|3
operator|)
operator|*
literal|3
operator|)
operator|!=
name|ulOutRate
condition|)
block|{
name|dwFrameGroupLength
operator|*=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|dwCnt
operator|=
literal|5
init|;
name|dwCnt
operator|<=
literal|125
condition|;
name|dwCnt
operator|*=
literal|5
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ulOutRate
operator|/
name|dwCnt
operator|)
operator|*
name|dwCnt
operator|)
operator|!=
name|ulOutRate
condition|)
block|{
name|dwFrameGroupLength
operator|*=
literal|5
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill in the WriteBack control block. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CFG1
argument_list|,
name|dwFrameGroupLength
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CFG2
argument_list|,
operator|(
literal|0x00800000
operator||
name|dwFrameGroupLength
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCST
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CSPB
argument_list|,
operator|(
operator|(
literal|65536
operator|*
name|ulOutRate
operator|)
operator|/
literal|24000
operator|)
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
operator|(
name|BA1_CSPB
operator|+
literal|4
operator|)
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_setblocksize
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
if|#
directive|if
name|notdef
return|return
name|blocksize
return|;
else|#
directive|else
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
name|ch
operator|->
name|buffer
operator|->
name|bufsize
operator|/
literal|2
return|;
endif|#
directive|endif
comment|/* notdef */
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_trigger
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
name|csa_startplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
else|else
name|csa_stopplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
name|csa_startcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
else|else
name|csa_stopcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_startplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|)
expr_stmt|;
name|ul
operator|&=
literal|0x0000ffff
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|,
name|ul
operator||
name|csa
operator|->
name|pctl
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PVOL
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_startcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|)
expr_stmt|;
name|ul
operator|&=
literal|0xffff0000
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|,
name|ul
operator||
name|csa
operator|->
name|cctl
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CVOL
argument_list|,
literal|0x80008000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_stopplaydma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|)
expr_stmt|;
name|csa
operator|->
name|pctl
operator|=
name|ul
operator|&
literal|0xffff0000
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PCTL
argument_list|,
name|ul
operator|&
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PVOL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_stopcapturedma
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|)
expr_stmt|;
name|csa
operator|->
name|cctl
operator|=
name|ul
operator|&
literal|0x0000ffff
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CCTL
argument_list|,
name|ul
operator|&
literal|0xffff0000
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CVOL
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_powerupdac
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
comment|/* 	 * Power on the DACs on the AC97 codec.  We turn off the DAC 	 * powerdown bit and write the new value of the power control 	 * register. 	 */
name|ul
operator|=
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|)
expr_stmt|;
name|ul
operator|&=
literal|0xfdff
expr_stmt|;
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
name|ul
argument_list|)
expr_stmt|;
comment|/* 	 * Now, we wait until we sample a DAC ready state. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * First, lets wait a short while to let things settle out a 		 * bit, and to prevent retrying the read too quickly. 		 */
name|DELAY
argument_list|(
literal|125
argument_list|)
expr_stmt|;
comment|/* 		 * Read the current state of the power control register. 		 */
name|ul
operator|=
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|)
expr_stmt|;
comment|/* 		 * If the DAC ready state bit is set, then stop waiting. 		 */
if|if
condition|(
operator|(
name|ul
operator|&
literal|0x2
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * The DACs are now calibrated, so we can unmute the DAC output. 	 */
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_PCM_OUT_VOLUME
argument_list|,
literal|0x0808
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_powerupadc
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
comment|/* 	 * Power on the ADCs on the AC97 codec.  We turn off the ADC 	 * powerdown bit and write the new value of the power control 	 * register. 	 */
name|ul
operator|=
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|)
expr_stmt|;
name|ul
operator|&=
literal|0xfeff
expr_stmt|;
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|,
name|ul
argument_list|)
expr_stmt|;
comment|/* 	 * Now, we wait until we sample a ADC ready state. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * First, lets wait a short while to let things settle out a 		 * bit, and to prevent retrying the read too quickly. 		 */
name|DELAY
argument_list|(
literal|125
argument_list|)
expr_stmt|;
comment|/* 		 * Read the current state of the power control register. 		 */
name|ul
operator|=
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_AC97_POWERDOWN
argument_list|)
expr_stmt|;
comment|/* 		 * If the ADC ready state bit is set, then stop waiting. 		 */
if|if
condition|(
operator|(
name|ul
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|csa_startdsp
parameter_list|(
name|csa_res
modifier|*
name|resp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
comment|/* 	 * Set the frame timer to reflect the number of cycles per frame. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_FRMT
argument_list|,
literal|0xadf
argument_list|)
expr_stmt|;
comment|/* 	 * Turn on the run, run at frame, and DMA enable bits in the local copy of 	 * the SP control register. 	 */
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_SPCR
argument_list|,
name|SPCR_RUN
operator||
name|SPCR_RUNFR
operator||
name|SPCR_DRQEN
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until the run at frame bit resets itself in the SP control 	 * register. 	 */
name|ul
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait a little bit, so we don't issue PCI reads too frequently. 		 */
if|#
directive|if
name|notdef
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|DELAY
argument_list|(
literal|125
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
comment|/* 		 * Fetch the current value of the SP status register. 		 */
name|ul
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_SPCR
argument_list|)
expr_stmt|;
comment|/* 		 * If the run at frame bit has reset, then stop waiting. 		 */
if|if
condition|(
operator|(
name|ul
operator|&
name|SPCR_RUNFR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If the run at frame bit never reset, then return an error. 	 */
if|if
condition|(
operator|(
name|ul
operator|&
name|SPCR_RUNFR
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|csachan_getptr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|int
name|ptr
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|ptr
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PBA
argument_list|)
operator|-
name|vtophys
argument_list|(
name|ch
operator|->
name|buffer
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_U8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S8
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CBA
argument_list|)
operator|-
name|vtophys
argument_list|(
name|ch
operator|->
name|buffer
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_U8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S8
operator|)
operator|!=
literal|0
condition|)
name|ptr
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pcmchan_caps
modifier|*
name|csachan_getcaps
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|csa_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|csa_playcaps
else|:
operator|&
name|csa_reccaps
return|;
block|}
end_function

begin_comment
comment|/* The interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|csa_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
name|p
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|u_int
name|hisr
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
comment|/* Is this interrupt for us? */
comment|/* XXX The parent device should handle this. */
name|hisr
operator|=
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_HISR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hisr
operator|&
operator|~
name|HISR_INTENA
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Throw an eoi. */
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_HICR
argument_list|,
name|HICR_IEV
operator||
name|HICR_CHGM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|hisr
operator|&
name|HISR_VC0
operator|)
operator|!=
literal|0
condition|)
name|chn_intr
argument_list|(
name|csa
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hisr
operator|&
name|HISR_VC1
operator|)
operator|!=
literal|0
condition|)
name|chn_intr
argument_list|(
name|csa
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
comment|/* Throw an eoi. */
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_HICR
argument_list|,
name|HICR_IEV
operator||
name|HICR_CHGM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Probe and attach the card  */
end_comment

begin_function
specifier|static
name|int
name|csa_init
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|csa
operator|->
name|pfie
operator|=
literal|0
expr_stmt|;
name|csa_stopplaydma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
name|csa_stopcapturedma
argument_list|(
name|csa
argument_list|)
expr_stmt|;
comment|/* Crank up the power on the DAC and ADC. */
name|csa_powerupadc
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|csa_powerupdac
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|csa_setplaysamplerate
argument_list|(
name|resp
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
name|csa_setcapturesamplerate
argument_list|(
name|resp
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa_startdsp
argument_list|(
name|resp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Allocates resources. */
end_comment

begin_function
specifier|static
name|int
name|csa_allocres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|io
operator|==
name|NULL
condition|)
block|{
name|resp
operator|->
name|io
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|resp
operator|->
name|io_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|CS461x_IO_SIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|io
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|resp
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|resp
operator|->
name|mem
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|resp
operator|->
name|mem_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|CS461x_MEM_SIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|mem
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|resp
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|resp
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|resp
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|irq
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
name|CS461x_BUFFSIZE
argument_list|,
comment|/*boundary*/
name|CS461x_BUFFSIZE
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|CS461x_BUFFSIZE
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|csa
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Releases resources. */
end_comment

begin_function
specifier|static
name|void
name|csa_releaseres
parameter_list|(
name|struct
name|csa_info
modifier|*
name|csa
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|resp
operator|->
name|irq_rid
argument_list|,
name|resp
operator|->
name|irq
argument_list|)
expr_stmt|;
name|resp
operator|->
name|irq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|->
name|io
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|resp
operator|->
name|io_rid
argument_list|,
name|resp
operator|->
name|io
argument_list|)
expr_stmt|;
name|resp
operator|->
name|io
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|->
name|mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|resp
operator|->
name|mem_rid
argument_list|,
name|resp
operator|->
name|mem
argument_list|)
expr_stmt|;
name|resp
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|pcmcsa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcmcsa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|pcmcsa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* The parent device has already been probed. */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|func
operator|->
name|func
operator|!=
name|SCF_PCM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
literal|"CS461x PCM Audio"
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcmcsa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|snddev_info
modifier|*
name|devinfo
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
decl_stmt|;
name|csa_res
modifier|*
name|resp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|devinfo
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|csa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|csa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate the resources. */
name|resp
operator|=
operator|&
name|csa
operator|->
name|res
expr_stmt|;
name|resp
operator|->
name|io_rid
operator|=
name|CS461x_IO_OFFSET
expr_stmt|;
name|resp
operator|->
name|mem_rid
operator|=
name|CS461x_MEM_OFFSET
expr_stmt|;
name|resp
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|csa_allocres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|csa_init
argument_list|(
name|csa
argument_list|)
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|codec
operator|=
name|ac97_create
argument_list|(
name|csa
argument_list|,
name|csa_rdcd
argument_list|,
name|csa_wrcd
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mixer_init
argument_list|(
name|devinfo
argument_list|,
operator|&
name|ac97_mixer
argument_list|,
name|codec
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at irq %ld"
argument_list|,
name|rman_get_start
argument_list|(
name|resp
operator|->
name|irq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable interrupt. */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|resp
operator|->
name|irq
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
name|csa_intr
argument_list|,
name|csa
argument_list|,
operator|&
name|csa
operator|->
name|ih
argument_list|)
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|csa_readio
argument_list|(
name|resp
argument_list|,
name|BA0_HISR
argument_list|)
operator|&
name|HISR_INTENA
operator|)
operator|==
literal|0
condition|)
name|csa_writeio
argument_list|(
name|resp
argument_list|,
name|BA0_HICR
argument_list|,
name|HICR_IEV
operator||
name|HICR_CHGM
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|,
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_PFIE
argument_list|)
operator|&
operator|~
literal|0x0000f03f
argument_list|)
expr_stmt|;
name|csa_writemem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|,
operator|(
name|csa_readmem
argument_list|(
name|resp
argument_list|,
name|BA1_CIE
argument_list|)
operator|&
operator|~
literal|0x0000003f
operator|)
operator||
literal|0x00000001
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|csa
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|csa_releaseres
argument_list|(
name|csa
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|csa_chantemplate
argument_list|,
name|csa
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|csa_chantemplate
argument_list|,
name|csa
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ac97 codec */
end_comment

begin_function
specifier|static
name|u_int32_t
name|csa_rdcd
parameter_list|(
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|struct
name|csa_info
modifier|*
name|csa
init|=
operator|(
expr|struct
name|csa_info
operator|*
operator|)
name|devinfo
decl_stmt|;
if|if
condition|(
name|csa_readcodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|regno
operator|+
name|BA0_AC97_RESET
argument_list|,
operator|&
name|data
argument_list|)
condition|)
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|csa_wrcd
parameter_list|(
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|csa_info
modifier|*
name|csa
init|=
operator|(
expr|struct
name|csa_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|csa_writecodec
argument_list|(
operator|&
name|csa
operator|->
name|res
argument_list|,
name|regno
operator|+
name|BA0_AC97_RESET
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|pcmcsa_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pcmcsa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pcmcsa_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pcmcsa_driver
init|=
block|{
literal|"pcm"
block|,
name|pcmcsa_methods
block|,
sizeof|sizeof
argument_list|(
name|snddev_info
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pcm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcmcsa
argument_list|,
name|csa
argument_list|,
name|pcmcsa_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCSA> 0 */
end_comment

end_unit

