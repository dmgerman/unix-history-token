begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000-2004 Taku YAMAMOTO<taku@tackymt.homeip.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	maestro.c,v 1.23.2.1 2003/10/03 18:21:38 taku Exp  */
end_comment

begin_comment
comment|/*  * Credits:  *  * Part of this code (especially in many magic numbers) was heavily inspired  * by the Linux driver originally written by  * Alan Cox<alan.cox@linux.org>, modified heavily by  * Zach Brown<zab@zabbo.net>.  *  * busdma()-ize and buffer size reduction were suggested by  * Cameron Grant<cg@freebsd.org>.  * Also he showed me the way to use busdma() suite.  *  * Internal speaker problems on NEC VersaPro's and Dell Inspiron 7500  * were looked at by  * Munehiro Matsuda<haro@tk.kubota.co.jp>,  * who brought patches based on the Linux driver with some simplification.  *  * Hardware volume controller was implemented by  * John Baldwin<jhb@freebsd.org>.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/maestro_reg.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PCI IDs of supported chips:  *  * MAESTRO-1	0x01001285  * MAESTRO-2	0x1968125d  * MAESTRO-2E	0x1978125d  */
end_comment

begin_define
define|#
directive|define
name|MAESTRO_1_PCI_ID
value|0x01001285
end_define

begin_define
define|#
directive|define
name|MAESTRO_2_PCI_ID
value|0x1968125d
end_define

begin_define
define|#
directive|define
name|MAESTRO_2E_PCI_ID
value|0x1978125d
end_define

begin_define
define|#
directive|define
name|NEC_SUBID1
value|0x80581033
end_define

begin_comment
comment|/* Taken from Linux driver */
end_comment

begin_define
define|#
directive|define
name|NEC_SUBID2
value|0x803c1033
end_define

begin_comment
comment|/* NEC VersaProNX VA26D    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AGG_MAXPLAYCH
end_ifdef

begin_if
if|#
directive|if
name|AGG_MAXPLAYCH
operator|>
literal|4
end_if

begin_undef
undef|#
directive|undef
name|AGG_MAXPLAYCH
end_undef

begin_define
define|#
directive|define
name|AGG_MAXPLAYCH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AGG_MAXPLAYCH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AGG_DEFAULT_BUFSZ
value|0x4000
end_define

begin_comment
comment|/* 0x1000, but gets underflows */
end_comment

begin_comment
comment|/* compatibility */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
end_if

begin_define
define|#
directive|define
name|critical_enter
parameter_list|()
value|disable_intr()
end_define

begin_define
define|#
directive|define
name|critical_exit
parameter_list|()
value|enable_intr()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCIR_BAR
end_ifndef

begin_define
define|#
directive|define
name|PCIR_BAR
parameter_list|(
name|x
parameter_list|)
value|(PCIR_MAPS + (x) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* -----------------------------  * Data structures.  */
end_comment

begin_struct
struct|struct
name|agg_chinfo
block|{
comment|/* parent softc */
name|struct
name|agg_info
modifier|*
name|parent
decl_stmt|;
comment|/* FreeBSD newpcm related */
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
comment|/* OS independent */
name|bus_addr_t
name|phys
decl_stmt|;
comment|/* channel buffer physical address */
name|bus_addr_t
name|base
decl_stmt|;
comment|/* channel buffer segment base */
name|u_int32_t
name|blklen
decl_stmt|;
comment|/* DMA block length in WORDs */
name|u_int32_t
name|buflen
decl_stmt|;
comment|/* channel buffer length in WORDs */
name|u_int32_t
name|speed
decl_stmt|;
name|unsigned
name|num
range|:
literal|3
decl_stmt|;
name|unsigned
name|stereo
range|:
literal|1
decl_stmt|;
name|unsigned
name|qs16
range|:
literal|1
decl_stmt|;
comment|/* quantum size is 16bit */
name|unsigned
name|us
range|:
literal|1
decl_stmt|;
comment|/* in unsigned format */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|agg_rchinfo
block|{
comment|/* parent softc */
name|struct
name|agg_info
modifier|*
name|parent
decl_stmt|;
comment|/* FreeBSD newpcm related */
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
comment|/* OS independent */
name|bus_addr_t
name|phys
decl_stmt|;
comment|/* channel buffer physical address */
name|bus_addr_t
name|base
decl_stmt|;
comment|/* channel buffer segment base */
name|u_int32_t
name|blklen
decl_stmt|;
comment|/* DMA block length in WORDs */
name|u_int32_t
name|buflen
decl_stmt|;
comment|/* channel buffer length in WORDs */
name|u_int32_t
name|speed
decl_stmt|;
name|unsigned
label|:
literal|3
expr_stmt|;
name|unsigned
name|stereo
range|:
literal|1
decl_stmt|;
name|bus_addr_t
name|srcphys
decl_stmt|;
name|int16_t
modifier|*
name|src
decl_stmt|;
comment|/* stereo peer buffer */
name|int16_t
modifier|*
name|sink
decl_stmt|;
comment|/* channel buffer pointer */
specifier|volatile
name|u_int32_t
name|hwptr
decl_stmt|;
comment|/* ready point in 16bit sample */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|agg_info
block|{
comment|/* FreeBSD newbus related */
name|device_t
name|dev
decl_stmt|;
comment|/* I wonder whether bus_space_* are in common in *BSD... */
name|struct
name|resource
modifier|*
name|reg
decl_stmt|;
name|int
name|regid
decl_stmt|;
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
decl_stmt|;
name|int
name|irqid
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|bus_dma_tag_t
name|buf_dmat
decl_stmt|;
name|bus_dma_tag_t
name|stat_dmat
decl_stmt|;
comment|/* FreeBSD SMPng related */
ifdef|#
directive|ifdef
name|USING_MUTEX
name|struct
name|mtx
name|lock
decl_stmt|;
comment|/* mutual exclusion */
endif|#
directive|endif
comment|/* FreeBSD newpcm related */
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
comment|/* OS independent */
name|u_int8_t
modifier|*
name|stat
decl_stmt|;
comment|/* status buffer pointer */
name|bus_addr_t
name|phys
decl_stmt|;
comment|/* status buffer physical address */
name|unsigned
name|int
name|bufsz
decl_stmt|;
comment|/* channel buffer size in bytes */
name|u_int
name|playchns
decl_stmt|;
specifier|volatile
name|u_int
name|active
decl_stmt|;
name|struct
name|agg_chinfo
name|pch
index|[
name|AGG_MAXPLAYCH
index|]
decl_stmt|;
name|struct
name|agg_rchinfo
name|rch
decl_stmt|;
specifier|volatile
name|u_int8_t
name|curpwr
decl_stmt|;
comment|/* current power status: D[0-3] */
block|}
struct|;
end_struct

begin_comment
comment|/* -----------------------------  * Sysctls for debug.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|powerstate_active
init|=
name|PCI_POWERSTATE_D1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAESTRO_AGGRESSIVE_POWERSAVE
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|powerstate_idle
init|=
name|PCI_POWERSTATE_D2
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|powerstate_idle
init|=
name|PCI_POWERSTATE_D1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|powerstate_init
init|=
name|PCI_POWERSTATE_D2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: this should move to a device specific sysctl dev.pcm.X.debug.Y via    device_get_sysctl_*() as discussed on multimedia@ in msg-id<861wujij2q.fsf@xps.des.no> */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|maestro
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_maestro
argument_list|,
name|OID_AUTO
argument_list|,
name|powerstate_active
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|powerstate_active
argument_list|,
literal|0
argument_list|,
literal|"The Dx power state when active (0-1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_maestro
argument_list|,
name|OID_AUTO
argument_list|,
name|powerstate_idle
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|powerstate_idle
argument_list|,
literal|0
argument_list|,
literal|"The Dx power state when idle (0-2)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_maestro
argument_list|,
name|OID_AUTO
argument_list|,
name|powerstate_init
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|powerstate_init
argument_list|,
literal|0
argument_list|,
literal|"The Dx power state prior to the first use (0-2)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -----------------------------  * Prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|agg_sleep
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|agg_rd
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|agg_wr
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_rdcodec
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_wrcodec
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ringbus_setdest
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|wp_rdreg
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wp_wrreg
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|wp_rdapu
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wp_wrapu
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wp_settimer
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wp_starttimer
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wp_stoptimer
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int16_t	wc_rdreg(struct agg_info*, u_int16_t);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|wc_wrreg
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int16_t	wc_rdchctl(struct agg_info*, int);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|wc_wrchctl
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|agg_stopclock
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
name|part
parameter_list|,
name|int
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|agg_initcodec
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|agg_init
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|agg_power
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aggch_start_dac
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aggch_stop_dac
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aggch_start_adc
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aggch_stop_adc
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aggch_feed_adc_stereo
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aggch_feed_adc_mono
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AGG_JITTER_CORRECTION
end_ifdef

begin_function_decl
specifier|static
name|void
name|suppress_jitter
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|suppress_rec_jitter
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|set_timer
parameter_list|(
name|struct
name|agg_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|agg_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|agg_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|dma_malloc
parameter_list|(
name|bus_dma_tag_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|bus_addr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dma_free
parameter_list|(
name|bus_dma_tag_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -----------------------------  * Subsystems.  */
end_comment

begin_comment
comment|/* locking */
end_comment

begin_define
define|#
directive|define
name|agg_lock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxlock(&((sc)->lock))
end_define

begin_define
define|#
directive|define
name|agg_unlock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxunlock(&((sc)->lock))
end_define

begin_function
specifier|static
name|void
name|agg_sleep
parameter_list|(
name|struct
name|agg_info
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|msec
parameter_list|)
block|{
name|int
name|timo
decl_stmt|;
name|timo
operator|=
name|msec
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|timo
operator|==
literal|0
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MUTEX
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|PWAIT
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
else|#
directive|else
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PWAIT
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* I/O port */
end_comment

begin_function
specifier|static
name|__inline
name|u_int32_t
name|agg_rd
parameter_list|(
name|struct
name|agg_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
return|;
default|default:
return|return
operator|~
operator|(
name|u_int32_t
operator|)
literal|0
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|AGG_RD
parameter_list|(
name|sc
parameter_list|,
name|regno
parameter_list|,
name|size
parameter_list|)
define|\
value|bus_space_read_##size(            \ 	    ((struct agg_info*)(sc))->st, \ 	    ((struct agg_info*)(sc))->sh, (regno))
end_define

begin_function
specifier|static
name|__inline
name|void
name|agg_wr
parameter_list|(
name|struct
name|agg_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|AGG_WR
parameter_list|(
name|sc
parameter_list|,
name|regno
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|)
define|\
value|bus_space_write_##size(           \ 	    ((struct agg_info*)(sc))->st, \ 	    ((struct agg_info*)(sc))->sh, (regno), (data))
end_define

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Codec/Ringbus */
end_comment

begin_function
specifier|static
name|int
name|agg_codec_wait4idle
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|)
block|{
name|unsigned
name|t
init|=
literal|26
decl_stmt|;
while|while
condition|(
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_CODEC_STAT
argument_list|,
literal|1
argument_list|)
operator|&
name|CODEC_STAT_MASK
condition|)
block|{
if|if
condition|(
operator|--
name|t
operator|==
literal|0
condition|)
return|return
name|EBUSY
return|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 20.8us / 13 */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_rdcodec
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* We have to wait for a SAFE time to write addr/data */
if|if
condition|(
name|agg_codec_wait4idle
argument_list|(
name|ess
argument_list|)
condition|)
block|{
comment|/* Timed out. No read performed. */
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"agg_rdcodec() PROGLESS timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_CODEC_CMD
argument_list|,
name|CODEC_CMD_READ
operator||
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*DELAY(21);	* AC97 cycle = 20.8usec */
comment|/* Wait for data retrieve */
if|if
condition|(
operator|!
name|agg_codec_wait4idle
argument_list|(
name|ess
argument_list|)
condition|)
block|{
name|ret
operator|=
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_CODEC_REG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Timed out. No read performed. */
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"agg_rdcodec() RW_DONE timed out.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_wrcodec
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
comment|/* We have to wait for a SAFE time to write addr/data */
if|if
condition|(
name|agg_codec_wait4idle
argument_list|(
name|ess
argument_list|)
condition|)
block|{
comment|/* Timed out. Abort writing. */
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"agg_wrcodec() PROGLESS timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_CODEC_REG
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_CODEC_CMD
argument_list|,
name|CODEC_CMD_WRITE
operator||
name|regno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait for write completion */
if|if
condition|(
name|agg_codec_wait4idle
argument_list|(
name|ess
argument_list|)
condition|)
block|{
comment|/* Timed out. */
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"agg_wrcodec() RW_DONE timed out.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ringbus_setdest
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|data
operator|=
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
operator|(
literal|0xfU
operator|<<
name|src
operator|)
expr_stmt|;
name|data
operator||=
operator|(
literal|0xfU
operator|&
name|dest
operator|)
operator|<<
name|src
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Wave Processor */
end_comment

begin_function
specifier|static
name|u_int16_t
name|wp_rdreg
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_DSP_INDEX
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_DSP_DATA
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wp_wrreg
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_DSP_INDEX
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_DSP_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wp_wait_data
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|unsigned
name|t
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_DSP_DATA
argument_list|,
literal|2
argument_list|)
operator|!=
name|data
condition|)
block|{
if|if
condition|(
operator|++
name|t
operator|==
literal|1000
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_DSP_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|wp_rdapu
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|unsigned
name|ch
parameter_list|,
name|u_int16_t
name|reg
parameter_list|)
block|{
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_CRAM_PTR
argument_list|,
name|reg
operator||
operator|(
name|ch
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp_wait_data
argument_list|(
name|ess
argument_list|,
name|reg
operator||
operator|(
name|ch
operator|<<
literal|4
operator|)
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"wp_rdapu() indexing timed out.\n"
argument_list|)
expr_stmt|;
return|return
name|wp_rdreg
argument_list|(
name|ess
argument_list|,
name|WPREG_DATA_PORT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wp_wrapu
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|unsigned
name|ch
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_CRAM_PTR
argument_list|,
name|reg
operator||
operator|(
name|ch
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp_wait_data
argument_list|(
name|ess
argument_list|,
name|reg
operator||
operator|(
name|ch
operator|<<
literal|4
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_DATA_PORT
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp_wait_data
argument_list|(
name|ess
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"wp_wrapu() write timed out.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"wp_wrapu() indexing timed out.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|apu_setparam
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|apuch
parameter_list|,
name|u_int32_t
name|wpwa
parameter_list|,
name|u_int16_t
name|size
parameter_list|,
name|int16_t
name|pan
parameter_list|,
name|u_int
name|dv
parameter_list|)
block|{
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_WAVESPACE
argument_list|,
operator|(
name|wpwa
operator|>>
literal|8
operator|)
operator|&
name|APU_64KPAGE_MASK
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_CURPTR
argument_list|,
name|wpwa
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_ENDPTR
argument_list|,
name|wpwa
operator|+
name|size
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_LOOPLEN
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_ROUTING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_AMPLITUDE
argument_list|,
literal|0xf000
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_POSITION
argument_list|,
literal|0x8f00
operator||
operator|(
name|APU_RADIUS_MASK
operator|&
operator|(
name|RADIUS_CENTERCIRCLE
operator|<<
name|APU_RADIUS_SHIFT
operator|)
operator|)
operator||
operator|(
name|APU_PAN_MASK
operator|&
operator|(
operator|(
name|pan
operator|+
name|PAN_FRONT
operator|)
operator|<<
name|APU_PAN_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_FREQ_LOBYTE
argument_list|,
name|APU_plus6dB
operator||
operator|(
operator|(
name|dv
operator|&
literal|0xff
operator|)
operator|<<
name|APU_FREQ_LOBYTE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ess
argument_list|,
name|apuch
argument_list|,
name|APUREG_FREQ_HIWORD
argument_list|,
name|dv
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wp_settimer
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|u_int
name|divide
parameter_list|)
block|{
name|u_int
name|prescale
init|=
literal|0
decl_stmt|;
name|RANGE
argument_list|(
name|divide
argument_list|,
literal|2
argument_list|,
literal|32
operator|<<
literal|7
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|divide
operator|>
literal|32
condition|;
name|divide
operator|>>=
literal|1
control|)
block|{
name|prescale
operator|++
expr_stmt|;
name|divide
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|prescale
operator|<
literal|7
operator|&&
name|divide
operator|>
literal|2
operator|&&
operator|!
operator|(
name|divide
operator|&
literal|1
operator|)
condition|;
name|divide
operator|>>=
literal|1
control|)
name|prescale
operator|++
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_TIMER_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_TIMER_FREQ
argument_list|,
literal|0x9000
operator||
operator|(
name|prescale
operator|<<
name|WP_TIMER_FREQ_PRESCALE_SHIFT
operator|)
operator||
operator|(
name|divide
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_TIMER_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wp_starttimer
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_INT_STAT
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
name|HOSTINT_CTRL_DSOUND_INT_ENABLED
operator||
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_TIMER_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wp_stoptimer
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
operator|~
name|HOSTINT_CTRL_DSOUND_INT_ENABLED
operator|&
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_INT_STAT
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_TIMER_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* WaveCache */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int16_t wc_rdreg(struct agg_info *ess, u_int16_t reg) { 	AGG_WR(ess, PORT_WAVCACHE_INDEX, reg, 2); 	return AGG_RD(ess, PORT_WAVCACHE_DATA, 2); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|wc_wrreg
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|u_int16_t
name|reg
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_WAVCACHE_INDEX
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_WAVCACHE_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int16_t wc_rdchctl(struct agg_info *ess, int ch) { 	return wc_rdreg(ess, ch<< 3); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|wc_wrchctl
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|ch
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|wc_wrreg
argument_list|(
name|ess
argument_list|,
name|ch
operator|<<
literal|3
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Power management */
end_comment

begin_function
specifier|static
name|void
name|agg_stopclock
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|part
parameter_list|,
name|int
name|st
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_ACPI_STOPCLOCK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|st
operator|==
name|PCI_POWERSTATE_D1
condition|)
name|data
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|part
operator|)
expr_stmt|;
else|else
name|data
operator||=
operator|(
literal|1
operator|<<
name|part
operator|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|PCI_POWERSTATE_D1
operator|||
name|st
operator|==
name|PCI_POWERSTATE_D2
condition|)
name|data
operator||=
operator|(
literal|0x10000
operator|<<
name|part
operator|)
expr_stmt|;
else|else
name|data
operator|&=
operator|~
operator|(
literal|0x10000
operator|<<
name|part
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_ACPI_STOPCLOCK
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* -----------------------------  * Controller.  */
end_comment

begin_function
specifier|static
name|void
name|agg_initcodec
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|)
block|{
name|u_int16_t
name|data
decl_stmt|;
if|if
condition|(
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|4
argument_list|)
operator|&
name|RINGBUS_CTRL_ACLINK_ENABLED
condition|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|104
argument_list|)
expr_stmt|;
comment|/* 20.8us * (4 + 1) */
block|}
comment|/* XXX - 2nd codec should be looked at. */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|RINGBUS_CTRL_AC97_SWRESET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|RINGBUS_CTRL_ACLINK_ENABLED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg_rdcodec
argument_list|(
name|ess
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|21
argument_list|)
expr_stmt|;
comment|/* Try cold reset. */
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"will perform cold reset.\n"
argument_list|)
expr_stmt|;
name|data
operator|=
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DIR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|0x58
argument_list|,
literal|2
argument_list|)
operator|&
literal|1
condition|)
name|data
operator||=
literal|0x10
expr_stmt|;
name|data
operator||=
literal|0x009
operator|&
operator|~
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DATA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_MASK
argument_list|,
literal|0xff6
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DIR
argument_list|,
name|data
operator||
literal|0x009
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DATA
argument_list|,
literal|0x000
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DATA
argument_list|,
literal|0x001
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DATA
argument_list|,
literal|0x009
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|agg_sleep
argument_list|(
name|ess
argument_list|,
literal|"agginicd"
argument_list|,
literal|500
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DIR
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|84
argument_list|)
expr_stmt|;
comment|/* 20.8us * 4 */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|RINGBUS_CTRL_ACLINK_ENABLED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|agg_init
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
comment|/* Setup PCI config registers. */
comment|/* Disable all legacy emulations. */
name|data
operator|=
name|pci_read_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_LEGACY
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
name|LEGACY_DISABLED
expr_stmt|;
name|pci_write_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_LEGACY
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Disconnect from CHI. (Makes Dell inspiron 7500 work?) 	 * Enable posted write. 	 * Prefer PCI timing rather than that of ISA. 	 * Don't swap L/R. */
name|data
operator|=
name|pci_read_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_MAESTRO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator||=
name|MAESTRO_PMC
expr_stmt|;
name|data
operator||=
name|MAESTRO_CHIBUS
operator||
name|MAESTRO_POSTEDWRITE
operator||
name|MAESTRO_DMA_PCITIMING
expr_stmt|;
name|data
operator|&=
operator|~
name|MAESTRO_SWAP_LR
expr_stmt|;
name|pci_write_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_MAESTRO
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Turn off unused parts if necessary. */
comment|/* consult CONF_MAESTRO. */
if|if
condition|(
name|data
operator|&
name|MAESTRO_SPDIF
condition|)
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_SPDIF
argument_list|,
name|PCI_POWERSTATE_D2
argument_list|)
expr_stmt|;
else|else
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_SPDIF
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|MAESTRO_HWVOL
condition|)
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_HW_VOL
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
else|else
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_HW_VOL
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
comment|/* parts that never be used */
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_978
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_DAA
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_GPIO
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_SB
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_FM
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_MIDI
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_GAME_PORT
argument_list|,
name|PCI_POWERSTATE_D1
argument_list|)
expr_stmt|;
comment|/* parts that will be used only when play/recording */
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_WP
argument_list|,
name|PCI_POWERSTATE_D2
argument_list|)
expr_stmt|;
comment|/* parts that should always be turned on */
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_CODEC_CLOCK
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_GLUE
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_PCI_IF
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
name|agg_stopclock
argument_list|(
name|ess
argument_list|,
name|ACPI_PART_RINGBUS
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
comment|/* Reset direct sound. */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
name|HOSTINT_CTRL_SOFT_RESET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
name|HOSTINT_CTRL_DSOUND_RESET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Enable hardware volume control interruption. */
if|if
condition|(
name|data
operator|&
name|MAESTRO_HWVOL
condition|)
comment|/* XXX - why not use device flags? */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
name|HOSTINT_CTRL_HWVOL_ENABLED
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Setup Wave Processor. */
comment|/* Enable WaveCache, set DMA base address. */
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_WAVE_ROMRAM
argument_list|,
name|WP_WAVE_VIRTUAL_ENABLED
operator||
name|WP_WAVE_DRAM_ENABLED
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_CRAM_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_WAVCACHE_CTRL
argument_list|,
name|WAVCACHE_ENABLED
operator||
name|WAVCACHE_WTSIZE_2MB
operator||
name|WAVCACHE_SGC_32_47
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
name|WAVCACHE_PCMBAR
init|;
name|data
operator|<
name|WAVCACHE_PCMBAR
operator|+
literal|4
condition|;
name|data
operator|++
control|)
name|wc_wrreg
argument_list|(
name|ess
argument_list|,
name|data
argument_list|,
name|ess
operator|->
name|phys
operator|>>
name|WAVCACHE_BASEADDR_SHIFT
argument_list|)
expr_stmt|;
comment|/* Setup Codec/Ringbus. */
name|agg_initcodec
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|RINGBUS_CTRL_RINGBUS_ENABLED
operator||
name|RINGBUS_CTRL_ACLINK_ENABLED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
literal|0x08
argument_list|,
literal|0xB004
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
literal|0x09
argument_list|,
literal|0x001B
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
literal|0x0A
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
literal|0x0B
argument_list|,
literal|0x3F37
argument_list|)
expr_stmt|;
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_BASE
argument_list|,
literal|0x8598
argument_list|)
expr_stmt|;
comment|/* Parallel I/O */
name|wp_wrreg
argument_list|(
name|ess
argument_list|,
name|WPREG_BASE
operator|+
literal|1
argument_list|,
literal|0x7632
argument_list|)
expr_stmt|;
name|ringbus_setdest
argument_list|(
name|ess
argument_list|,
name|RINGBUS_SRC_ADC
argument_list|,
name|RINGBUS_DEST_STEREO
operator||
name|RINGBUS_DEST_DSOUND_IN
argument_list|)
expr_stmt|;
name|ringbus_setdest
argument_list|(
name|ess
argument_list|,
name|RINGBUS_SRC_DSOUND
argument_list|,
name|RINGBUS_DEST_STEREO
operator||
name|RINGBUS_DEST_DAC
argument_list|)
expr_stmt|;
comment|/* Enable S/PDIF if necessary. */
if|if
condition|(
name|pci_read_config
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|CONF_MAESTRO
argument_list|,
literal|4
argument_list|)
operator|&
name|MAESTRO_SPDIF
condition|)
comment|/* XXX - why not use device flags? */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL_B
argument_list|,
name|RINGBUS_CTRL_SPDIF
operator||
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL_B
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup ASSP. Needed for Dell Inspiron 7500? */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_ASSP_CTRL_B
argument_list|,
literal|0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_ASSP_CTRL_A
argument_list|,
literal|0x03
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_ASSP_CTRL_C
argument_list|,
literal|0x00
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Setup GPIO. 	 * There seems to be speciality with NEC systems. 	 */
switch|switch
condition|(
name|pci_get_subvendor
argument_list|(
name|ess
operator|->
name|dev
argument_list|)
operator||
operator|(
name|pci_get_subdevice
argument_list|(
name|ess
operator|->
name|dev
argument_list|)
operator|<<
literal|16
operator|)
condition|)
block|{
case|case
name|NEC_SUBID1
case|:
case|case
name|NEC_SUBID2
case|:
comment|/* Matthew Braithwaite<matt@braithwaite.net> reported that 		 * NEC Versa LX doesn't need GPIO operation. */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_MASK
argument_list|,
literal|0x9ff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DIR
argument_list|,
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DIR
argument_list|,
literal|2
argument_list|)
operator||
literal|0x600
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_GPIO_DATA
argument_list|,
literal|0x200
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Deals power state transition. Must be called with softc->lock held. */
end_comment

begin_function
specifier|static
name|void
name|agg_power
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|u_int8_t
name|lastpwr
decl_stmt|;
name|lastpwr
operator|=
name|ess
operator|->
name|curpwr
expr_stmt|;
if|if
condition|(
name|lastpwr
operator|==
name|status
condition|)
return|return;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|PCI_POWERSTATE_D0
case|:
case|case
name|PCI_POWERSTATE_D1
case|:
switch|switch
condition|(
name|lastpwr
condition|)
block|{
case|case
name|PCI_POWERSTATE_D2
case|:
name|pci_set_powerstate
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Turn on PCM-related parts. */
name|agg_wrcodec
argument_list|(
name|ess
argument_list|,
name|AC97_REG_POWER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ((agg_rdcodec(ess, AC97_REG_POWER)& 3) != 3) 				device_printf(ess->dev, 				    "warning: codec not ready.\n");
endif|#
directive|endif
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
operator|(
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
name|RINGBUS_CTRL_ACLINK_ENABLED
operator|)
operator||
name|RINGBUS_CTRL_RINGBUS_ENABLED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|4
argument_list|)
operator||
name|RINGBUS_CTRL_ACLINK_ENABLED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D3
case|:
comment|/* Initialize. */
name|pci_set_powerstate
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|agg_init
argument_list|(
name|ess
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PCI_POWERSTATE_D0
case|:
case|case
name|PCI_POWERSTATE_D1
case|:
name|pci_set_powerstate
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PCI_POWERSTATE_D2
case|:
switch|switch
condition|(
name|lastpwr
condition|)
block|{
case|case
name|PCI_POWERSTATE_D3
case|:
comment|/* Initialize. */
name|pci_set_powerstate
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|agg_init
argument_list|(
name|ess
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PCI_POWERSTATE_D0
case|:
case|case
name|PCI_POWERSTATE_D1
case|:
comment|/* Turn off PCM-related parts. */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
name|RINGBUS_CTRL_RINGBUS_ENABLED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|agg_wrcodec
argument_list|(
name|ess
argument_list|,
name|AC97_REG_POWER
argument_list|,
literal|0x300
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
break|break;
block|}
name|pci_set_powerstate
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_POWERSTATE_D3
case|:
comment|/* Entirely power down. */
name|agg_wrcodec
argument_list|(
name|ess
argument_list|,
name|AC97_REG_POWER
argument_list|,
literal|0xdf00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_RINGBUS_CTRL
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/*DELAY(1);*/
if|if
condition|(
name|lastpwr
operator|!=
name|PCI_POWERSTATE_D2
condition|)
name|wp_stoptimer
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_STAT
argument_list|,
literal|0xff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid power state; let it ignored. */
name|status
operator|=
name|lastpwr
expr_stmt|;
break|break;
block|}
name|ess
operator|->
name|curpwr
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Channel controller. */
end_comment

begin_function
specifier|static
name|void
name|aggch_start_dac
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|bus_addr_t
name|wpwa
decl_stmt|;
name|u_int32_t
name|speed
decl_stmt|;
name|u_int16_t
name|size
decl_stmt|,
name|apuch
decl_stmt|,
name|wtbar
decl_stmt|,
name|wcreg
decl_stmt|,
name|aputype
decl_stmt|;
name|u_int
name|dv
decl_stmt|;
name|int
name|pan
decl_stmt|;
name|speed
operator|=
name|ch
operator|->
name|speed
expr_stmt|;
name|wpwa
operator|=
operator|(
name|ch
operator|->
name|phys
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
expr_stmt|;
name|wtbar
operator|=
literal|0xc
operator|&
operator|(
name|wpwa
operator|>>
name|WPWA_WTBAR_SHIFT
argument_list|(
literal|2
argument_list|)
operator|)
expr_stmt|;
name|wcreg
operator|=
operator|(
name|ch
operator|->
name|phys
operator|-
literal|16
operator|)
operator|&
name|WAVCACHE_CHCTL_ADDRTAG_MASK
expr_stmt|;
name|size
operator|=
name|ch
operator|->
name|buflen
expr_stmt|;
name|apuch
operator|=
operator|(
name|ch
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
literal|32
expr_stmt|;
name|pan
operator|=
name|PAN_RIGHT
operator|-
name|PAN_FRONT
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|stereo
condition|)
block|{
name|wcreg
operator||=
name|WAVCACHE_CHCTL_STEREO
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|qs16
condition|)
block|{
name|aputype
operator|=
name|APUTYPE_16BITSTEREO
expr_stmt|;
name|wpwa
operator|>>=
literal|1
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
name|pan
operator|=
operator|-
name|pan
expr_stmt|;
block|}
else|else
name|aputype
operator|=
name|APUTYPE_8BITSTEREO
expr_stmt|;
block|}
else|else
block|{
name|pan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|qs16
condition|)
name|aputype
operator|=
name|APUTYPE_16BITLINEAR
expr_stmt|;
else|else
block|{
name|aputype
operator|=
name|APUTYPE_8BITLINEAR
expr_stmt|;
name|speed
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|us
condition|)
name|wcreg
operator||=
name|WAVCACHE_CHCTL_U8
expr_stmt|;
if|if
condition|(
name|wtbar
operator|>
literal|8
condition|)
name|wtbar
operator|=
operator|(
name|wtbar
operator|>>
literal|1
operator|)
operator|+
literal|4
expr_stmt|;
name|dv
operator|=
operator|(
operator|(
operator|(
name|speed
operator|%
literal|48000
operator|)
operator|<<
literal|16
operator|)
operator|+
literal|24000
operator|)
operator|/
literal|48000
operator|+
operator|(
operator|(
name|speed
operator|/
literal|48000
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|powerstate_active
argument_list|)
expr_stmt|;
name|wc_wrreg
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|WAVCACHE_WTBAR
operator|+
name|wtbar
argument_list|,
name|ch
operator|->
name|base
operator|>>
name|WAVCACHE_BASEADDR_SHIFT
argument_list|)
expr_stmt|;
name|wc_wrreg
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|WAVCACHE_WTBAR
operator|+
name|wtbar
operator|+
literal|1
argument_list|,
name|ch
operator|->
name|base
operator|>>
name|WAVCACHE_BASEADDR_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|wtbar
operator|<
literal|8
condition|)
block|{
name|wc_wrreg
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|WAVCACHE_WTBAR
operator|+
name|wtbar
operator|+
literal|2
argument_list|,
name|ch
operator|->
name|base
operator|>>
name|WAVCACHE_BASEADDR_SHIFT
argument_list|)
expr_stmt|;
name|wc_wrreg
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|WAVCACHE_WTBAR
operator|+
name|wtbar
operator|+
literal|3
argument_list|,
name|ch
operator|->
name|base
operator|>>
name|WAVCACHE_BASEADDR_SHIFT
argument_list|)
expr_stmt|;
block|}
name|wc_wrchctl
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
argument_list|,
name|wcreg
argument_list|)
expr_stmt|;
name|wc_wrchctl
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
operator|+
literal|1
argument_list|,
name|wcreg
argument_list|)
expr_stmt|;
name|apu_setparam
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
argument_list|,
name|wpwa
argument_list|,
name|size
argument_list|,
name|pan
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|stereo
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|qs16
condition|)
name|wpwa
operator||=
operator|(
name|WPWA_STEREO
operator|>>
literal|1
operator|)
expr_stmt|;
name|apu_setparam
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
operator|+
literal|1
argument_list|,
name|wpwa
argument_list|,
name|size
argument_list|,
operator|-
name|pan
argument_list|,
name|dv
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|aputype
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
name|APU_DMA_ENABLED
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
operator|+
literal|1
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|aputype
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
name|APU_DMA_ENABLED
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|aputype
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
name|APU_DMA_ENABLED
operator||
literal|0xf
argument_list|)
expr_stmt|;
block|}
comment|/* to mark that this channel is ready for intr. */
name|ch
operator|->
name|parent
operator|->
name|active
operator||=
operator|(
literal|1
operator|<<
name|ch
operator|->
name|num
operator|)
expr_stmt|;
name|set_timer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|wp_starttimer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aggch_stop_dac
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* to mark that this channel no longer needs further intrs. */
name|ch
operator|->
name|parent
operator|->
name|active
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ch
operator|->
name|num
operator|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
operator|(
name|ch
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
literal|32
argument_list|,
name|APUREG_APUTYPE
argument_list|,
name|APUTYPE_INACTIVE
operator|<<
name|APU_APUTYPE_SHIFT
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
operator|(
name|ch
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
literal|33
argument_list|,
name|APUREG_APUTYPE
argument_list|,
name|APUTYPE_INACTIVE
operator|<<
name|APU_APUTYPE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|parent
operator|->
name|active
condition|)
block|{
name|set_timer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|wp_starttimer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wp_stoptimer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|powerstate_idle
argument_list|)
expr_stmt|;
block|}
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aggch_start_adc
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|bus_addr_t
name|wpwa
decl_stmt|,
name|wpwa2
decl_stmt|;
name|u_int16_t
name|wcreg
decl_stmt|,
name|wcreg2
decl_stmt|;
name|u_int
name|dv
decl_stmt|;
name|int
name|pan
decl_stmt|;
comment|/* speed> 48000 not cared */
name|dv
operator|=
operator|(
operator|(
name|ch
operator|->
name|speed
operator|<<
literal|16
operator|)
operator|+
literal|24000
operator|)
operator|/
literal|48000
expr_stmt|;
comment|/* RATECONV doesn't seem to like dv == 0x10000. */
if|if
condition|(
name|dv
operator|==
literal|0x10000
condition|)
name|dv
operator|--
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|stereo
condition|)
block|{
name|wpwa
operator|=
operator|(
name|ch
operator|->
name|srcphys
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
expr_stmt|;
name|wpwa2
operator|=
operator|(
name|ch
operator|->
name|srcphys
operator|+
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|/
literal|2
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
expr_stmt|;
name|wcreg
operator|=
operator|(
name|ch
operator|->
name|srcphys
operator|-
literal|16
operator|)
operator|&
name|WAVCACHE_CHCTL_ADDRTAG_MASK
expr_stmt|;
name|wcreg2
operator|=
operator|(
name|ch
operator|->
name|base
operator|-
literal|16
operator|)
operator|&
name|WAVCACHE_CHCTL_ADDRTAG_MASK
expr_stmt|;
name|pan
operator|=
name|PAN_LEFT
operator|-
name|PAN_FRONT
expr_stmt|;
block|}
else|else
block|{
name|wpwa
operator|=
operator|(
name|ch
operator|->
name|phys
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
expr_stmt|;
name|wpwa2
operator|=
operator|(
name|ch
operator|->
name|srcphys
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
expr_stmt|;
name|wcreg
operator|=
operator|(
name|ch
operator|->
name|phys
operator|-
literal|16
operator|)
operator|&
name|WAVCACHE_CHCTL_ADDRTAG_MASK
expr_stmt|;
name|wcreg2
operator|=
operator|(
name|ch
operator|->
name|base
operator|-
literal|16
operator|)
operator|&
name|WAVCACHE_CHCTL_ADDRTAG_MASK
expr_stmt|;
name|pan
operator|=
literal|0
expr_stmt|;
block|}
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hwptr
operator|=
literal|0
expr_stmt|;
name|agg_power
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|powerstate_active
argument_list|)
expr_stmt|;
comment|/* Invalidate WaveCache. */
name|wc_wrchctl
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|wcreg
operator||
name|WAVCACHE_CHCTL_STEREO
argument_list|)
expr_stmt|;
name|wc_wrchctl
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|1
argument_list|,
name|wcreg
operator||
name|WAVCACHE_CHCTL_STEREO
argument_list|)
expr_stmt|;
name|wc_wrchctl
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|2
argument_list|,
name|wcreg2
operator||
name|WAVCACHE_CHCTL_STEREO
argument_list|)
expr_stmt|;
name|wc_wrchctl
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|3
argument_list|,
name|wcreg2
operator||
name|WAVCACHE_CHCTL_STEREO
argument_list|)
expr_stmt|;
comment|/* Load APU registers. */
comment|/* APU #0 : Sample rate converter for left/center. */
name|apu_setparam
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|WPWA_USE_SYSMEM
operator||
name|wpwa
argument_list|,
name|ch
operator|->
name|buflen
operator|>>
name|ch
operator|->
name|stereo
argument_list|,
literal|0
argument_list|,
name|dv
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|APUREG_AMPLITUDE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|APUREG_ROUTING
argument_list|,
literal|2
operator|<<
name|APU_DATASRC_A_SHIFT
argument_list|)
expr_stmt|;
comment|/* APU #1 : Sample rate converter for right. */
name|apu_setparam
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|1
argument_list|,
name|WPWA_USE_SYSMEM
operator||
name|wpwa2
argument_list|,
name|ch
operator|->
name|buflen
operator|>>
name|ch
operator|->
name|stereo
argument_list|,
literal|0
argument_list|,
name|dv
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|1
argument_list|,
name|APUREG_AMPLITUDE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|1
argument_list|,
name|APUREG_ROUTING
argument_list|,
literal|3
operator|<<
name|APU_DATASRC_A_SHIFT
argument_list|)
expr_stmt|;
comment|/* APU #2 : Input mixer for left. */
name|apu_setparam
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|2
argument_list|,
name|WPWA_USE_SYSMEM
operator||
literal|0
argument_list|,
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|>>
literal|2
argument_list|,
name|pan
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|2
argument_list|,
name|APUREG_AMPLITUDE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|2
argument_list|,
name|APUREG_EFFECT_GAIN
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|2
argument_list|,
name|APUREG_ROUTING
argument_list|,
literal|0x15
operator|<<
name|APU_DATASRC_A_SHIFT
argument_list|)
expr_stmt|;
comment|/* APU #3 : Input mixer for right. */
name|apu_setparam
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|3
argument_list|,
name|WPWA_USE_SYSMEM
operator||
operator|(
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|>>
literal|2
operator|)
argument_list|,
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|>>
literal|2
argument_list|,
operator|-
name|pan
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|3
argument_list|,
name|APUREG_AMPLITUDE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|3
argument_list|,
name|APUREG_EFFECT_GAIN
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|3
argument_list|,
name|APUREG_ROUTING
argument_list|,
literal|0x14
operator|<<
name|APU_DATASRC_A_SHIFT
argument_list|)
expr_stmt|;
comment|/* to mark this channel ready for intr. */
name|ch
operator|->
name|parent
operator|->
name|active
operator||=
operator|(
literal|1
operator|<<
name|ch
operator|->
name|parent
operator|->
name|playchns
operator|)
expr_stmt|;
comment|/* start adc */
name|critical_enter
argument_list|()
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|APUTYPE_RATECONV
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
name|APU_DMA_ENABLED
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|1
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|APUTYPE_RATECONV
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
name|APU_DMA_ENABLED
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|2
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|APUTYPE_INPUTMIXER
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|3
argument_list|,
name|APUREG_APUTYPE
argument_list|,
operator|(
name|APUTYPE_INPUTMIXER
operator|<<
name|APU_APUTYPE_SHIFT
operator|)
operator||
literal|0xf
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|set_timer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|wp_starttimer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aggch_stop_adc
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|apuch
decl_stmt|;
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* to mark that this channel no longer needs further intrs. */
name|ch
operator|->
name|parent
operator|->
name|active
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ch
operator|->
name|parent
operator|->
name|playchns
operator|)
expr_stmt|;
for|for
control|(
name|apuch
operator|=
literal|0
init|;
name|apuch
operator|<
literal|4
condition|;
name|apuch
operator|++
control|)
name|wp_wrapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|apuch
argument_list|,
name|APUREG_APUTYPE
argument_list|,
name|APUTYPE_INACTIVE
operator|<<
name|APU_APUTYPE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|parent
operator|->
name|active
condition|)
block|{
name|set_timer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|wp_starttimer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wp_stoptimer
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|powerstate_idle
argument_list|)
expr_stmt|;
block|}
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Feed from L/R channel of ADC to destination with stereo interleaving.  * This function expects n not overwrapping the buffer boundary.  * Note that n is measured in sample unit.  *  * XXX - this function works in 16bit stereo format only.  */
end_comment

begin_function
specifier|static
name|void
name|interleave
parameter_list|(
name|int16_t
modifier|*
name|l
parameter_list|,
name|int16_t
modifier|*
name|r
parameter_list|,
name|int16_t
modifier|*
name|p
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|int16_t
modifier|*
name|end
decl_stmt|;
for|for
control|(
name|end
operator|=
name|l
operator|+
name|n
init|;
name|l
operator|<
name|end
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|l
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aggch_feed_adc_stereo
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|unsigned
name|cur
decl_stmt|,
name|last
decl_stmt|;
name|int16_t
modifier|*
name|src2
decl_stmt|;
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|=
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|-=
literal|0xffff
operator|&
operator|(
operator|(
name|ch
operator|->
name|srcphys
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|last
operator|=
name|ch
operator|->
name|hwptr
expr_stmt|;
name|src2
operator|=
name|ch
operator|->
name|src
operator|+
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|cur
operator|<
name|last
condition|)
block|{
name|interleave
argument_list|(
name|ch
operator|->
name|src
operator|+
name|last
argument_list|,
name|src2
operator|+
name|last
argument_list|,
name|ch
operator|->
name|sink
operator|+
literal|2
operator|*
name|last
argument_list|,
name|ch
operator|->
name|buflen
operator|/
literal|2
operator|-
name|last
argument_list|)
expr_stmt|;
name|interleave
argument_list|(
name|ch
operator|->
name|src
argument_list|,
name|src2
argument_list|,
name|ch
operator|->
name|sink
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|>
name|last
condition|)
name|interleave
argument_list|(
name|ch
operator|->
name|src
operator|+
name|last
argument_list|,
name|src2
operator|+
name|last
argument_list|,
name|ch
operator|->
name|sink
operator|+
literal|2
operator|*
name|last
argument_list|,
name|cur
operator|-
name|last
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hwptr
operator|=
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Feed from R channel of ADC and mixdown to destination L/center.  * This function expects n not overwrapping the buffer boundary.  * Note that n is measured in sample unit.  *  * XXX - this function works in 16bit monoral format only.  */
end_comment

begin_function
specifier|static
name|void
name|mixdown
parameter_list|(
name|int16_t
modifier|*
name|src
parameter_list|,
name|int16_t
modifier|*
name|dest
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|int16_t
modifier|*
name|end
decl_stmt|;
for|for
control|(
name|end
operator|=
name|dest
operator|+
name|n
init|;
name|dest
operator|<
name|end
condition|;
name|dest
operator|++
control|)
operator|*
name|dest
operator|=
call|(
name|int16_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|dest
operator|-
operator|(
name|int
operator|)
operator|*
name|src
operator|++
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aggch_feed_adc_mono
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|unsigned
name|cur
decl_stmt|,
name|last
decl_stmt|;
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|=
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|-=
literal|0xffff
operator|&
operator|(
operator|(
name|ch
operator|->
name|phys
operator|-
name|ch
operator|->
name|base
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|last
operator|=
name|ch
operator|->
name|hwptr
expr_stmt|;
if|if
condition|(
name|cur
operator|<
name|last
condition|)
block|{
name|mixdown
argument_list|(
name|ch
operator|->
name|src
operator|+
name|last
argument_list|,
name|ch
operator|->
name|sink
operator|+
name|last
argument_list|,
name|ch
operator|->
name|buflen
operator|-
name|last
argument_list|)
expr_stmt|;
name|mixdown
argument_list|(
name|ch
operator|->
name|src
argument_list|,
name|ch
operator|->
name|sink
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|>
name|last
condition|)
name|mixdown
argument_list|(
name|ch
operator|->
name|src
operator|+
name|last
argument_list|,
name|ch
operator|->
name|sink
operator|+
name|last
argument_list|,
name|cur
operator|-
name|last
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hwptr
operator|=
name|cur
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AGG_JITTER_CORRECTION
end_ifdef

begin_comment
comment|/*  * Stereo jitter suppressor.  * Sometimes playback pointers differ in stereo-paired channels.  * Calling this routine within intr fixes the problem.  */
end_comment

begin_function
specifier|static
name|void
name|suppress_jitter
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|->
name|stereo
condition|)
block|{
name|int
name|cp1
decl_stmt|,
name|cp2
decl_stmt|,
name|diff
comment|/*, halfsize*/
decl_stmt|;
comment|/*halfsize = (ch->qs16? ch->buflen>> 2 : ch->buflen>> 1);*/
name|cp1
operator|=
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
operator|(
name|ch
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
literal|32
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
operator|(
name|ch
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
literal|33
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp1
operator|!=
name|cp2
condition|)
block|{
name|diff
operator|=
operator|(
name|cp1
operator|>
name|cp2
condition|?
name|cp1
operator|-
name|cp2
else|:
name|cp2
operator|-
name|cp1
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|1
comment|/*&& diff< halfsize*/
condition|)
name|AGG_WR
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|PORT_DSP_DATA
argument_list|,
name|cp1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|suppress_rec_jitter
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|cp1
decl_stmt|,
name|cp2
decl_stmt|,
name|diff
comment|/*, halfsize*/
decl_stmt|;
comment|/*halfsize = (ch->stereo? ch->buflen>> 2 : ch->buflen>> 1);*/
name|cp1
operator|=
operator|(
name|ch
operator|->
name|stereo
condition|?
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|>>
literal|2
else|:
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|>>
literal|1
operator|)
operator|+
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
literal|1
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp1
operator|!=
name|cp2
condition|)
block|{
name|diff
operator|=
operator|(
name|cp1
operator|>
name|cp2
condition|?
name|cp1
operator|-
name|cp2
else|:
name|cp2
operator|-
name|cp1
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|1
comment|/*&& diff< halfsize*/
condition|)
name|AGG_WR
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
name|PORT_DSP_DATA
argument_list|,
name|cp1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_int
name|calc_timer_div
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|u_int
name|speed
decl_stmt|;
name|speed
operator|=
name|ch
operator|->
name|speed
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"snd_maestro: pch[%d].speed == 0, which shouldn't\n"
argument_list|,
name|ch
operator|->
name|num
argument_list|)
expr_stmt|;
name|speed
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|48000
operator|*
operator|(
name|ch
operator|->
name|blklen
operator|<<
operator|(
operator|!
name|ch
operator|->
name|qs16
operator|+
operator|!
name|ch
operator|->
name|stereo
operator|)
operator|)
operator|+
name|speed
operator|-
literal|1
operator|)
operator|/
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|calc_timer_div_rch
parameter_list|(
name|struct
name|agg_rchinfo
modifier|*
name|ch
parameter_list|)
block|{
name|u_int
name|speed
decl_stmt|;
name|speed
operator|=
name|ch
operator|->
name|speed
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"snd_maestro: rch.speed == 0, which shouldn't\n"
argument_list|)
expr_stmt|;
name|speed
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|48000
operator|*
operator|(
name|ch
operator|->
name|blklen
operator|<<
operator|(
operator|!
name|ch
operator|->
name|stereo
operator|)
operator|)
operator|+
name|speed
operator|-
literal|1
operator|)
operator|/
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_timer
parameter_list|(
name|struct
name|agg_info
modifier|*
name|ess
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|dv
init|=
literal|32
operator|<<
literal|7
decl_stmt|,
name|newdv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ess
operator|->
name|playchns
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ess
operator|->
name|active
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|&&
operator|(
name|dv
operator|>
operator|(
name|newdv
operator|=
name|calc_timer_div
argument_list|(
name|ess
operator|->
name|pch
operator|+
name|i
argument_list|)
operator|)
operator|)
condition|)
name|dv
operator|=
name|newdv
expr_stmt|;
if|if
condition|(
operator|(
name|ess
operator|->
name|active
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|&&
operator|(
name|dv
operator|>
operator|(
name|newdv
operator|=
name|calc_timer_div_rch
argument_list|(
operator|&
name|ess
operator|->
name|rch
argument_list|)
operator|)
operator|)
condition|)
name|dv
operator|=
name|newdv
expr_stmt|;
name|wp_settimer
argument_list|(
name|ess
argument_list|,
name|dv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -----------------------------  * Newpcm glue.  */
end_comment

begin_comment
comment|/* AC97 mixer interface. */
end_comment

begin_function
specifier|static
name|u_int32_t
name|agg_ac97_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|sc
decl_stmt|;
return|return
operator|(
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_CODEC_STAT
argument_list|,
literal|1
argument_list|)
operator|&
name|CODEC_STAT_MASK
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_ac97_read
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|sc
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* XXX sound locking violation: agg_lock(ess); */
name|ret
operator|=
name|agg_rdcodec
argument_list|(
name|ess
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* agg_unlock(ess); */
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_ac97_write
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|sc
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* XXX sound locking violation: agg_lock(ess); */
name|ret
operator|=
name|agg_wrcodec
argument_list|(
name|ess
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* agg_unlock(ess); */
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|agg_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_init
argument_list|,
name|agg_ac97_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|agg_ac97_read
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|agg_ac97_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|agg_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Playback channel. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|aggpch_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|devinfo
decl_stmt|;
name|struct
name|agg_chinfo
modifier|*
name|ch
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
argument_list|,
operator|(
literal|"aggpch_init() called for RECORDING channel!"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
name|ess
operator|->
name|pch
operator|+
name|ess
operator|->
name|playchns
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|ess
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|num
operator|=
name|ess
operator|->
name|playchns
expr_stmt|;
name|p
operator|=
name|dma_malloc
argument_list|(
name|ess
operator|->
name|buf_dmat
argument_list|,
name|ess
operator|->
name|bufsz
argument_list|,
operator|&
name|physaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ch
operator|->
name|phys
operator|=
name|physaddr
expr_stmt|;
name|ch
operator|->
name|base
operator|=
name|physaddr
operator|&
operator|(
operator|(
operator|~
operator|(
name|bus_addr_t
operator|)
literal|0
operator|)
operator|<<
name|WAVCACHE_BASEADDR_SHIFT
operator|)
expr_stmt|;
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|ess
operator|->
name|bufsz
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blklen
operator|=
name|sndbuf_getblksz
argument_list|(
name|b
argument_list|)
operator|/
literal|2
expr_stmt|;
name|ch
operator|->
name|buflen
operator|=
name|sndbuf_getsize
argument_list|(
name|b
argument_list|)
operator|/
literal|2
expr_stmt|;
name|ess
operator|->
name|playchns
operator|++
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_pchbase
parameter_list|(
name|struct
name|agg_chinfo
modifier|*
name|chans
parameter_list|,
name|u_int
name|n
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|struct
name|agg_chinfo
modifier|*
name|pchs
index|[
name|AGG_MAXPLAYCH
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|bus_addr_t
name|base
decl_stmt|;
comment|/* sort pchs by phys address */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|chans
index|[
name|i
index|]
operator|.
name|phys
operator|<
name|pchs
index|[
name|j
index|]
operator|->
name|phys
condition|)
block|{
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|--
control|)
name|pchs
index|[
name|k
index|]
operator|=
name|pchs
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
break|break;
block|}
name|pchs
index|[
name|j
index|]
operator|=
name|chans
operator|+
name|i
expr_stmt|;
block|}
comment|/* use new base register if next buffer can not be addressed 	   via current base. */
define|#
directive|define
name|BASE_SHIFT
value|(WPWA_WTBAR_SHIFT(2) + 2 + 1)
name|base
operator|=
name|pchs
index|[
literal|0
index|]
operator|->
name|base
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pchs
index|[
name|i
index|]
operator|->
name|phys
operator|+
name|size
operator|-
name|base
operator|>=
literal|1
operator|<<
name|BASE_SHIFT
condition|)
comment|/* not addressable: assign new base */
name|base
operator|=
operator|(
name|pchs
index|[
name|i
index|]
operator|->
name|base
operator|-=
name|k
operator|++
operator|<<
name|BASE_SHIFT
operator|)
expr_stmt|;
else|else
name|pchs
index|[
name|i
index|]
operator|->
name|base
operator|=
name|base
expr_stmt|;
block|}
undef|#
directive|undef
name|BASE_SHIFT
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"Total of %d bases are assigned.\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"ch.%d: phys 0x%llx, wpwa 0x%llx\n"
argument_list|,
name|i
argument_list|,
operator|(
name|long
name|long
operator|)
name|chans
index|[
name|i
index|]
operator|.
name|phys
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|chans
index|[
name|i
index|]
operator|.
name|phys
operator|-
name|chans
index|[
name|i
index|]
operator|.
name|base
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aggpch_free
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|agg_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|ch
operator|->
name|parent
decl_stmt|;
comment|/* free up buffer - called after channel stopped */
name|dma_free
argument_list|(
name|ess
operator|->
name|buf_dmat
argument_list|,
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return 0 if ok */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggpch_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|agg_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_BIGENDIAN
operator|||
name|format
operator|&
name|AFMT_U16_LE
condition|)
return|return
name|EINVAL
return|;
name|ch
operator|->
name|stereo
operator|=
name|ch
operator|->
name|qs16
operator|=
name|ch
operator|->
name|us
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_STEREO
condition|)
name|ch
operator|->
name|stereo
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|AFMT_U8
operator|||
name|format
operator|&
name|AFMT_S8
condition|)
block|{
if|if
condition|(
name|format
operator|&
name|AFMT_U8
condition|)
name|ch
operator|->
name|us
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ch
operator|->
name|qs16
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggpch_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|agg_chinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|speed
operator|=
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggpch_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|agg_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int
name|blkcnt
decl_stmt|;
comment|/* try to keep at least 20msec DMA space */
name|blkcnt
operator|=
operator|(
name|ch
operator|->
name|speed
operator|<<
operator|(
name|ch
operator|->
name|stereo
operator|+
name|ch
operator|->
name|qs16
operator|)
operator|)
operator|/
operator|(
literal|50
operator|*
name|blocksize
operator|)
expr_stmt|;
name|RANGE
argument_list|(
name|blkcnt
argument_list|,
literal|2
argument_list|,
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|/
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|!=
name|blkcnt
operator|*
name|blocksize
condition|)
block|{
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blkcnt
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|blkcnt
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sndbuf_setblkcnt
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blkcnt
argument_list|)
expr_stmt|;
name|sndbuf_setblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|blklen
operator|=
name|blocksize
operator|/
literal|2
expr_stmt|;
name|ch
operator|->
name|buflen
operator|=
name|blkcnt
operator|*
name|blocksize
operator|/
literal|2
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggpch_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|agg_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_EMLDMAWR
case|:
break|break;
case|case
name|PCMTRIG_START
case|:
name|aggch_start_dac
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
case|case
name|PCMTRIG_STOP
case|:
name|aggch_stop_dac
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggpch_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|agg_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|u_int
name|cp
decl_stmt|;
name|agg_lock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
name|cp
operator|=
name|wp_rdapu
argument_list|(
name|ch
operator|->
name|parent
argument_list|,
operator|(
name|ch
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
literal|32
argument_list|,
name|APUREG_CURPTR
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ch
operator|->
name|parent
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|qs16
operator|&&
name|ch
operator|->
name|stereo
condition|?
operator|(
name|cp
operator|<<
literal|2
operator|)
operator|-
operator|(
operator|(
literal|0xffff
operator|<<
literal|2
operator|)
operator|&
operator|(
name|ch
operator|->
name|phys
operator|-
name|ch
operator|->
name|base
operator|)
operator|)
else|:
operator|(
name|cp
operator|<<
literal|1
operator|)
operator|-
operator|(
operator|(
literal|0xffff
operator|<<
literal|1
operator|)
operator|&
operator|(
name|ch
operator|->
name|phys
operator|-
name|ch
operator|->
name|base
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|aggpch_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|static
name|u_int32_t
name|playfmt
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S8
block|,
name|AFMT_STEREO
operator||
name|AFMT_S8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|pcmchan_caps
name|playcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|playfmt
block|,
literal|0
block|}
decl_stmt|;
return|return
operator|&
name|playcaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|aggpch_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|aggpch_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|aggpch_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|aggpch_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|aggpch_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|aggpch_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|aggpch_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|aggpch_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|aggpch_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|aggpch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Recording channel. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|aggrch_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|devinfo
decl_stmt|;
name|struct
name|agg_rchinfo
modifier|*
name|ch
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|dir
operator|==
name|PCMDIR_REC
operator|)
argument_list|,
operator|(
literal|"aggrch_init() called for PLAYBACK channel!"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|ess
operator|->
name|rch
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|ess
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
comment|/* Uses the bottom-half of the status buffer. */
name|p
operator|=
name|ess
operator|->
name|stat
operator|+
name|ess
operator|->
name|bufsz
expr_stmt|;
name|ch
operator|->
name|phys
operator|=
name|ess
operator|->
name|phys
operator|+
name|ess
operator|->
name|bufsz
expr_stmt|;
name|ch
operator|->
name|base
operator|=
name|ess
operator|->
name|phys
expr_stmt|;
name|ch
operator|->
name|src
operator|=
operator|(
name|int16_t
operator|*
operator|)
operator|(
name|p
operator|+
name|ess
operator|->
name|bufsz
operator|)
expr_stmt|;
name|ch
operator|->
name|srcphys
operator|=
name|ch
operator|->
name|phys
operator|+
name|ess
operator|->
name|bufsz
expr_stmt|;
name|ch
operator|->
name|sink
operator|=
operator|(
name|int16_t
operator|*
operator|)
name|p
expr_stmt|;
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|ess
operator|->
name|bufsz
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blklen
operator|=
name|sndbuf_getblksz
argument_list|(
name|b
argument_list|)
operator|/
literal|2
expr_stmt|;
name|ch
operator|->
name|buflen
operator|=
name|sndbuf_getsize
argument_list|(
name|b
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggrch_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|agg_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|format
operator|&
name|AFMT_S16_LE
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|format
operator|&
name|AFMT_STEREO
condition|)
name|ch
operator|->
name|stereo
operator|=
literal|1
expr_stmt|;
else|else
name|ch
operator|->
name|stereo
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggrch_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|agg_rchinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|speed
operator|=
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggrch_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|agg_rchinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int
name|blkcnt
decl_stmt|;
comment|/* try to keep at least 20msec DMA space */
name|blkcnt
operator|=
operator|(
name|ch
operator|->
name|speed
operator|<<
name|ch
operator|->
name|stereo
operator|)
operator|/
operator|(
literal|25
operator|*
name|blocksize
operator|)
expr_stmt|;
name|RANGE
argument_list|(
name|blkcnt
argument_list|,
literal|2
argument_list|,
name|ch
operator|->
name|parent
operator|->
name|bufsz
operator|/
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|!=
name|blkcnt
operator|*
name|blocksize
condition|)
block|{
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blkcnt
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|blkcnt
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sndbuf_setblkcnt
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blkcnt
argument_list|)
expr_stmt|;
name|sndbuf_setblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|blklen
operator|=
name|blocksize
operator|/
literal|2
expr_stmt|;
name|ch
operator|->
name|buflen
operator|=
name|blkcnt
operator|*
name|blocksize
operator|/
literal|2
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggrch_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|agg_rchinfo
modifier|*
name|ch
init|=
name|sc
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_EMLDMARD
case|:
if|if
condition|(
name|ch
operator|->
name|stereo
condition|)
name|aggch_feed_adc_stereo
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
name|aggch_feed_adc_mono
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_START
case|:
name|aggch_start_adc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
case|case
name|PCMTRIG_STOP
case|:
name|aggch_stop_adc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aggrch_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|agg_rchinfo
modifier|*
name|ch
init|=
name|sc
decl_stmt|;
return|return
name|ch
operator|->
name|stereo
condition|?
name|ch
operator|->
name|hwptr
operator|<<
literal|2
else|:
name|ch
operator|->
name|hwptr
operator|<<
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|aggrch_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|u_int32_t
name|recfmt
index|[]
init|=
block|{
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|pcmchan_caps
name|reccaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|recfmt
block|,
literal|0
block|}
decl_stmt|;
return|return
operator|&
name|reccaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|aggrch_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|aggrch_init
argument_list|)
block|,
comment|/* channel_free: no-op */
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|aggrch_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|aggrch_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|aggrch_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|aggrch_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|aggrch_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|aggrch_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|aggrch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -----------------------------  * Bus space.  */
end_comment

begin_function
specifier|static
name|void
name|agg_intr
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|sc
decl_stmt|;
specifier|register
name|u_int8_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|m
decl_stmt|;
name|status
operator|=
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_STAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return;
comment|/* Acknowledge intr. */
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_STAT
argument_list|,
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HOSTINT_STAT_DSOUND
condition|)
block|{
ifdef|#
directive|ifdef
name|AGG_JITTER_CORRECTION
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ess
operator|->
name|curpwr
operator|<=
name|PCI_POWERSTATE_D1
condition|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_INT_STAT
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AGG_JITTER_CORRECTION
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
literal|1
init|;
name|i
operator|<
name|ess
operator|->
name|playchns
condition|;
name|i
operator|++
operator|,
name|m
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|ess
operator|->
name|active
operator|&
name|m
condition|)
name|suppress_jitter
argument_list|(
name|ess
operator|->
name|pch
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ess
operator|->
name|active
operator|&
name|m
condition|)
name|suppress_rec_jitter
argument_list|(
operator|&
name|ess
operator|->
name|rch
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
literal|1
init|;
name|i
operator|<
name|ess
operator|->
name|playchns
condition|;
name|i
operator|++
operator|,
name|m
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|ess
operator|->
name|active
operator|&
name|m
condition|)
block|{
if|if
condition|(
name|ess
operator|->
name|curpwr
operator|<=
name|PCI_POWERSTATE_D1
condition|)
name|chn_intr
argument_list|(
name|ess
operator|->
name|pch
index|[
name|i
index|]
operator|.
name|channel
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ess
operator|->
name|active
operator|&
name|m
operator|)
operator|&&
name|ess
operator|->
name|curpwr
operator|<=
name|PCI_POWERSTATE_D1
condition|)
name|chn_intr
argument_list|(
name|ess
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AGG_JITTER_CORRECTION
else|else
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|HOSTINT_STAT_HWVOL
condition|)
block|{
specifier|register
name|u_int8_t
name|event
decl_stmt|;
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|event
operator|=
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_HWVOL_MASTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HWVOL_MASTER
argument_list|,
name|HWVOL_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|HWVOL_UP
case|:
name|mixer_hwvol_step
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|HWVOL_DOWN
case|:
name|mixer_hwvol_step
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|HWVOL_NOP
case|:
break|break;
default|default:
if|if
condition|(
name|event
operator|&
name|HWVOL_MUTE
condition|)
block|{
name|mixer_hwvol_mute
argument_list|(
name|ess
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|ess
operator|->
name|dev
argument_list|,
literal|"%s: unknown HWVOL event 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ess
operator|->
name|dev
argument_list|)
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|phys
init|=
name|arg
decl_stmt|;
operator|*
name|phys
operator|=
name|error
condition|?
literal|0
else|:
name|segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"setmap (%lx, %lx), nseg=%d, error=%d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_len
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dma_malloc
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|u_int32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|phys
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|dmat
argument_list|,
operator|&
name|buf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|map
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|dmat
argument_list|,
name|map
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|,
name|setmap
argument_list|,
name|phys
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
operator|*
name|phys
operator|||
name|map
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|dmat
argument_list|,
name|buf
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dma_free
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|bus_dmamem_free
argument_list|(
name|dmat
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|MAESTRO_1_PCI_ID
case|:
name|s
operator|=
literal|"ESS Technology Maestro-1"
expr_stmt|;
break|break;
case|case
name|MAESTRO_2_PCI_ID
case|:
name|s
operator|=
literal|"ESS Technology Maestro-2"
expr_stmt|;
break|break;
case|case
name|MAESTRO_2E_PCI_ID
case|:
name|s
operator|=
literal|"ESS Technology Maestro-2E"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_MULTIMEDIA
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|int
name|regid
init|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
init|=
name|NULL
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
init|=
name|NULL
decl_stmt|;
name|int
name|irqid
init|=
literal|0
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ih
init|=
name|NULL
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ess
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ess
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ess
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MUTEX
name|mtx_init
argument_list|(
operator|&
name|ess
operator|->
name|lock
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"hardware status lock"
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_initialized
argument_list|(
operator|&
name|ess
operator|->
name|lock
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create a mutex.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
name|ess
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|AGG_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*align */
literal|4
argument_list|,
literal|1
operator|<<
operator|(
literal|16
operator|+
literal|1
operator|)
argument_list|,
comment|/*limit */
name|MAESTRO_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*size  */
name|ess
operator|->
name|bufsz
argument_list|,
literal|1
argument_list|,
literal|0x3ffff
argument_list|,
comment|/*flags */
literal|0
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lock  */
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
endif|#
directive|endif
operator|&
name|ess
operator|->
name|buf_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*align */
literal|1
operator|<<
name|WAVCACHE_BASEADDR_SHIFT
argument_list|,
literal|1
operator|<<
operator|(
literal|16
operator|+
literal|1
operator|)
argument_list|,
comment|/*limit */
name|MAESTRO_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*size  */
literal|3
operator|*
name|ess
operator|->
name|bufsz
argument_list|,
literal|1
argument_list|,
literal|0x3ffff
argument_list|,
comment|/*flags */
literal|0
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|501102
comment|/*lock  */
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
endif|#
directive|endif
operator|&
name|ess
operator|->
name|stat_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Allocate the room for brain-damaging status buffer. */
name|ess
operator|->
name|stat
operator|=
name|dma_malloc
argument_list|(
name|ess
operator|->
name|stat_dmat
argument_list|,
literal|3
operator|*
name|ess
operator|->
name|bufsz
argument_list|,
operator|&
name|ess
operator|->
name|phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|ess
operator|->
name|stat
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate status buffer\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Maestro status/record buffer: %#llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|ess
operator|->
name|phys
argument_list|)
expr_stmt|;
comment|/* State D0-uninitialized. */
name|ess
operator|->
name|curpwr
operator|=
name|PCI_POWERSTATE_D3
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Allocate resources. */
if|if
condition|(
name|data
operator|&
name|PCIM_CMD_PORTEN
condition|)
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
name|ess
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|ess
operator|->
name|regid
operator|=
name|regid
expr_stmt|;
name|ess
operator|->
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|ess
operator|->
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map register space\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irqid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|!=
name|NULL
condition|)
block|{
name|ess
operator|->
name|irq
operator|=
name|irq
expr_stmt|;
name|ess
operator|->
name|irqid
operator|=
name|irqid
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Setup resources. */
if|if
condition|(
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|agg_intr
argument_list|,
name|ess
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to setup interrupt\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
name|ess
operator|->
name|ih
operator|=
name|ih
expr_stmt|;
comment|/* Transition from D0-uninitialized to D0. */
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ess
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
if|if
condition|(
name|agg_rdcodec
argument_list|(
name|ess
argument_list|,
literal|0
argument_list|)
operator|==
literal|0x80
condition|)
block|{
comment|/* XXX - TODO: PT101 */
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PT101 codec detected!\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|ess
argument_list|,
name|agg_ac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create AC97 codec softc!\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|codec
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"mixer initialization failed!\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ess
operator|->
name|codec
operator|=
name|codec
expr_stmt|;
name|ret
operator|=
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|ess
argument_list|,
name|AGG_MAXPLAYCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|bad
goto|;
name|mixer_hwvol_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ess
argument_list|,
name|powerstate_init
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
init|;
name|data
operator|<
name|AGG_MAXPLAYCH
condition|;
name|data
operator|++
control|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|aggpch_class
argument_list|,
name|ess
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|aggrch_class
argument_list|,
name|ess
argument_list|)
expr_stmt|;
name|adjust_pchbase
argument_list|(
name|ess
operator|->
name|pch
argument_list|,
name|ess
operator|->
name|playchns
argument_list|,
name|ess
operator|->
name|bufsz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"port 0x%lx-0x%lx irq %ld at device %d.%d on pci%d"
argument_list|,
name|rman_get_start
argument_list|(
name|reg
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|codec
operator|!=
name|NULL
condition|)
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irqid
argument_list|,
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|regid
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ess
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ess
operator|->
name|stat
operator|!=
name|NULL
condition|)
name|dma_free
argument_list|(
name|ess
operator|->
name|stat_dmat
argument_list|,
name|ess
operator|->
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|ess
operator|->
name|stat_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|ess
operator|->
name|stat_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|ess
operator|->
name|buf_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|ess
operator|->
name|buf_dmat
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MUTEX
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|ess
operator|->
name|lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|ess
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ess
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|u_int16_t
name|icr
decl_stmt|;
name|icr
operator|=
name|AGG_RD
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
if|if
condition|(
name|ess
operator|->
name|active
condition|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
name|icr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
name|icr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ess
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ess
operator|->
name|irq
argument_list|,
name|ess
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ess
operator|->
name|irqid
argument_list|,
name|ess
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ess
operator|->
name|regid
argument_list|,
name|ess
operator|->
name|reg
argument_list|)
expr_stmt|;
name|dma_free
argument_list|(
name|ess
operator|->
name|stat_dmat
argument_list|,
name|ess
operator|->
name|stat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|ess
operator|->
name|stat_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|ess
operator|->
name|buf_dmat
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USING_MUTEX
name|mtx_destroy
argument_list|(
operator|&
name|ess
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ess
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|USING_MUTEX
name|int
name|x
decl_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|AGG_WR
argument_list|(
name|ess
argument_list|,
name|PORT_HOSTINT_CTRL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ess
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USING_MUTEX
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|USING_MUTEX
name|int
name|x
decl_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ess
operator|->
name|playchns
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ess
operator|->
name|active
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|aggch_start_dac
argument_list|(
name|ess
operator|->
name|pch
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ess
operator|->
name|active
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|aggch_start_adc
argument_list|(
operator|&
name|ess
operator|->
name|rch
argument_list|)
expr_stmt|;
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ess
operator|->
name|active
condition|)
name|agg_power
argument_list|(
name|ess
argument_list|,
name|powerstate_init
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USING_MUTEX
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mixer_reinit
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|agg_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|agg_info
modifier|*
name|ess
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|agg_lock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
name|agg_power
argument_list|(
name|ess
argument_list|,
name|PCI_POWERSTATE_D3
argument_list|)
expr_stmt|;
name|agg_unlock
argument_list|(
name|ess
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|agg_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|agg_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|agg_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|agg_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|agg_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|agg_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|agg_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|agg_driver
init|=
block|{
literal|"pcm"
block|,
name|agg_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static devclass_t pcm_devclass;*/
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_maestro
argument_list|,
name|pci
argument_list|,
name|agg_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_maestro
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_maestro
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

