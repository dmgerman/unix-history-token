begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Katsurajima Naoto<raven@katsurajima.seya.yokohama.jp>  * Copyright (c) 2001 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THEPOSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/ich.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|ICH_TIMEOUT
value|1000
end_define

begin_comment
comment|/* semaphore timeout polling count */
end_comment

begin_define
define|#
directive|define
name|ICH_DTBL_LENGTH
value|32
end_define

begin_define
define|#
directive|define
name|ICH_DEFAULT_BUFSZ
value|16384
end_define

begin_define
define|#
directive|define
name|ICH_MAX_BUFSZ
value|65536
end_define

begin_define
define|#
directive|define
name|SIS7012ID
value|0x70121039
end_define

begin_comment
comment|/* SiS 7012 needs special handling */
end_comment

begin_comment
comment|/* buffer descriptor */
end_comment

begin_struct
struct|struct
name|ich_desc
block|{
specifier|volatile
name|u_int32_t
name|buffer
decl_stmt|;
specifier|volatile
name|u_int32_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|sc_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* channel registers */
end_comment

begin_struct
struct|struct
name|sc_chinfo
block|{
name|u_int32_t
name|num
range|:
literal|8
decl_stmt|,
name|run
range|:
literal|1
decl_stmt|,
name|run_save
range|:
literal|1
decl_stmt|;
name|u_int32_t
name|blksz
decl_stmt|,
name|blkcnt
decl_stmt|,
name|spd
decl_stmt|;
name|u_int32_t
name|regbase
decl_stmt|,
name|spdreg
decl_stmt|;
name|u_int32_t
name|imask
decl_stmt|;
name|u_int32_t
name|civ
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|ich_desc
modifier|*
name|dtbl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* device private data */
end_comment

begin_struct
struct|struct
name|sc_info
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|hasvra
decl_stmt|,
name|hasvrm
decl_stmt|,
name|hasmic
decl_stmt|;
name|unsigned
name|int
name|chnum
decl_stmt|,
name|bufsz
decl_stmt|;
name|int
name|sample_size
decl_stmt|,
name|swap_reg
decl_stmt|;
name|struct
name|resource
modifier|*
name|nambar
decl_stmt|,
modifier|*
name|nabmbar
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|int
name|nambarid
decl_stmt|,
name|nabmbarid
decl_stmt|,
name|irqid
decl_stmt|;
name|bus_space_tag_t
name|nambart
decl_stmt|,
name|nabmbart
decl_stmt|;
name|bus_space_handle_t
name|nambarh
decl_stmt|,
name|nabmbarh
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|bus_dmamap_t
name|dtmap
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|struct
name|sc_chinfo
name|ch
index|[
literal|3
index|]
decl_stmt|;
name|int
name|ac97rate
decl_stmt|;
name|struct
name|ich_desc
modifier|*
name|dtbl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|ich_fmt
index|[]
init|=
block|{
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|ich_vrcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|ich_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|ich_caps
init|=
block|{
literal|48000
block|,
literal|48000
block|,
name|ich_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Hardware */
end_comment

begin_function
specifier|static
name|u_int32_t
name|ich_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|)
return|;
default|default:
return|return
literal|0xffffffff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ich_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ac97 codec */
end_comment

begin_function
specifier|static
name|int
name|ich_waitcd
parameter_list|(
name|void
modifier|*
name|devinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_ACC_SEMA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CODEC semaphore timeout\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_rdcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|regno
operator|&=
literal|0xff
expr_stmt|;
name|ich_waitcd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|nambart
argument_list|,
name|sc
operator|->
name|nambarh
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_wrcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|regno
operator|&=
literal|0xff
expr_stmt|;
name|ich_waitcd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|nambart
argument_list|,
name|sc
operator|->
name|nambarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ich_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|ich_rdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|ich_wrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|ich_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* common routines */
end_comment

begin_function
specifier|static
name|void
name|ich_filldtbl
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base
operator|=
name|vtophys
argument_list|(
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
name|ch
operator|->
name|blksz
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|blkcnt
operator|!=
literal|2
operator|&&
name|ch
operator|->
name|blkcnt
operator|!=
literal|4
operator|&&
name|ch
operator|->
name|blkcnt
operator|!=
literal|8
operator|&&
name|ch
operator|->
name|blkcnt
operator|!=
literal|16
operator|&&
name|ch
operator|->
name|blkcnt
operator|!=
literal|32
condition|)
block|{
name|ch
operator|->
name|blkcnt
operator|=
literal|2
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
name|ch
operator|->
name|blkcnt
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_DTBL_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|->
name|dtbl
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|base
operator|+
operator|(
name|ch
operator|->
name|blksz
operator|*
operator|(
name|i
operator|%
name|ch
operator|->
name|blkcnt
operator|)
operator|)
expr_stmt|;
name|ch
operator|->
name|dtbl
index|[
name|i
index|]
operator|.
name|length
operator|=
name|ICH_BDC_IOC
operator||
operator|(
name|ch
operator|->
name|blksz
operator|/
name|ch
operator|->
name|parent
operator|->
name|sample_size
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ich_resetchan
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cr
decl_stmt|,
name|regbase
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|regbase
operator|=
name|ICH_REG_PO_BASE
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|regbase
operator|=
name|ICH_REG_PI_BASE
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|2
condition|)
name|regbase
operator|=
name|ICH_REG_MC_BASE
expr_stmt|;
else|else
return|return
name|ENXIO
return|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|cr
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot reset channel %d\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ichchan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
name|num
operator|=
name|sc
operator|->
name|chnum
operator|++
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|ch
index|[
name|num
index|]
expr_stmt|;
name|ch
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dtbl
operator|=
name|sc
operator|->
name|dtbl
operator|+
operator|(
name|ch
operator|->
name|num
operator|*
name|ICH_DTBL_LENGTH
operator|)
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
literal|2
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
operator|/
name|ch
operator|->
name|blkcnt
expr_stmt|;
switch|switch
condition|(
name|ch
operator|->
name|num
condition|)
block|{
case|case
literal|0
case|:
comment|/* play */
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_PLAY
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|regbase
operator|=
name|ICH_REG_PO_BASE
expr_stmt|;
name|ch
operator|->
name|spdreg
operator|=
name|sc
operator|->
name|hasvra
condition|?
name|AC97_REGEXT_FDACRATE
else|:
literal|0
expr_stmt|;
name|ch
operator|->
name|imask
operator|=
name|ICH_GLOB_STA_POINT
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* record */
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|regbase
operator|=
name|ICH_REG_PI_BASE
expr_stmt|;
name|ch
operator|->
name|spdreg
operator|=
name|sc
operator|->
name|hasvra
condition|?
name|AC97_REGEXT_LADCRATE
else|:
literal|0
expr_stmt|;
name|ch
operator|->
name|imask
operator|=
name|ICH_GLOB_STA_PIINT
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* mic */
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|regbase
operator|=
name|ICH_REG_MC_BASE
expr_stmt|;
name|ch
operator|->
name|spdreg
operator|=
name|sc
operator|->
name|hasvrm
condition|?
name|AC97_REGEXT_MADCRATE
else|:
literal|0
expr_stmt|;
name|ch
operator|->
name|imask
operator|=
name|ICH_GLOB_STA_MINT
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_BDBAR
argument_list|,
operator|(
name|u_int32_t
operator|)
name|vtophys
argument_list|(
name|ch
operator|->
name|dtbl
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|spdreg
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ac97rate
operator|<=
literal|32000
operator|||
name|sc
operator|->
name|ac97rate
operator|>=
literal|64000
condition|)
name|sc
operator|->
name|ac97rate
operator|=
literal|48000
expr_stmt|;
name|r
operator|=
operator|(
name|speed
operator|*
literal|48000
operator|)
operator|/
name|sc
operator|->
name|ac97rate
expr_stmt|;
comment|/* 		 * Cast the return value of ac97_setrate() to u_int so that 		 * the math don't overflow into the negative range. 		 */
name|ch
operator|->
name|spd
operator|=
operator|(
operator|(
name|u_int
operator|)
name|ac97_setrate
argument_list|(
name|sc
operator|->
name|codec
argument_list|,
name|ch
operator|->
name|spdreg
argument_list|,
name|r
argument_list|)
operator|*
name|sc
operator|->
name|ac97rate
operator|)
operator|/
literal|48000
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|spd
operator|=
literal|48000
expr_stmt|;
block|}
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
name|ich_filldtbl
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_LVI
argument_list|,
name|ch
operator|->
name|blkcnt
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|blksz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|ch
operator|->
name|run
operator|=
literal|1
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_BDBAR
argument_list|,
operator|(
name|u_int32_t
operator|)
name|vtophys
argument_list|(
name|ch
operator|->
name|dtbl
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RPBM
operator||
name|ICH_X_CR_LVBIE
operator||
name|ICH_X_CR_IOCE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|num
argument_list|)
expr_stmt|;
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|pos
decl_stmt|;
name|ch
operator|->
name|civ
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CIV
argument_list|,
literal|1
argument_list|)
operator|%
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|pos
operator|=
name|ch
operator|->
name|civ
operator|*
name|ch
operator|->
name|blksz
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|ichchan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
name|ch
operator|->
name|spdreg
condition|?
operator|&
name|ich_vrcaps
else|:
operator|&
name|ich_caps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ichchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|ichchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|ichchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|ichchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|ichchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|ichchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|ichchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|ichchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|ichchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|ich_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|u_int32_t
name|cbi
decl_stmt|,
name|lbi
decl_stmt|,
name|lvi
decl_stmt|,
name|st
decl_stmt|,
name|gs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gs
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
literal|4
argument_list|)
operator|&
name|ICH_GLOB_STA_IMASK
expr_stmt|;
if|if
condition|(
name|gs
operator|&
operator|(
name|ICH_GLOB_STA_PRES
operator||
name|ICH_GLOB_STA_SRES
operator|)
condition|)
block|{
comment|/* Clear resume interrupt(s) - nothing doing with them */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
name|gs
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|gs
operator|&=
operator|~
operator|(
name|ICH_GLOB_STA_PRES
operator||
name|ICH_GLOB_STA_SRES
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|ch
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|imask
operator|&
name|gs
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|gs
operator|&=
operator|~
name|ch
operator|->
name|imask
expr_stmt|;
name|st
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
operator|(
name|sc
operator|->
name|swap_reg
condition|?
name|ICH_REG_X_PICB
else|:
name|ICH_REG_X_SR
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|st
operator|&=
name|ICH_X_SR_FIFOE
operator||
name|ICH_X_SR_BCIS
operator||
name|ICH_X_SR_LVBCI
expr_stmt|;
if|if
condition|(
name|st
operator|&
operator|(
name|ICH_X_SR_BCIS
operator||
name|ICH_X_SR_LVBCI
operator|)
condition|)
block|{
comment|/* block complete - update buffer */
if|if
condition|(
name|ch
operator|->
name|run
condition|)
name|chn_intr
argument_list|(
name|ch
operator|->
name|channel
argument_list|)
expr_stmt|;
name|lvi
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_LVI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cbi
operator|=
name|ch
operator|->
name|civ
operator|%
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
name|cbi
operator|==
literal|0
condition|)
name|cbi
operator|=
name|ch
operator|->
name|blkcnt
operator|-
literal|1
expr_stmt|;
else|else
name|cbi
operator|--
expr_stmt|;
name|lbi
operator|=
name|lvi
operator|%
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
name|cbi
operator|>=
name|lbi
condition|)
name|lvi
operator|+=
name|cbi
operator|-
name|lbi
expr_stmt|;
else|else
name|lvi
operator|+=
name|cbi
operator|+
name|ch
operator|->
name|blkcnt
operator|-
name|lbi
expr_stmt|;
name|lvi
operator|%=
name|ICH_DTBL_LENGTH
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_LVI
argument_list|,
name|lvi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* clear status bit */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
operator|(
name|sc
operator|->
name|swap_reg
condition|?
name|ICH_REG_X_PICB
else|:
name|ICH_REG_X_SR
operator|)
argument_list|,
name|st
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gs
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unhandled interrupt, gs_intr = %x\n"
argument_list|,
name|gs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Sysctl to control ac97 speed (some boards overclocked ac97). */
end_comment

begin_function
specifier|static
name|int
name|ich_initsys
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
name|SYSCTL_ADD_INT
argument_list|(
name|snd_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|snd_sysctl_tree_top
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ac97rate"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|ac97rate
argument_list|,
literal|48000
argument_list|,
literal|"AC97 link rate (default = 48000)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SND_DYNSYSCTL */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Calibrate card (some boards are overclocked and need scaling) */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ich_calibrate
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|ch
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|u_int8_t
name|ociv
decl_stmt|,
name|nciv
decl_stmt|;
name|u_int32_t
name|wait_us
decl_stmt|,
name|actual_48k_rate
decl_stmt|,
name|bytes
decl_stmt|;
comment|/* 	 * Grab audio from input for fixed interval and compare how 	 * much we actually get with what we expect.  Interval needs 	 * to be sufficiently short that no interrupts are 	 * generated. 	 */
name|KASSERT
argument_list|(
name|ch
operator|->
name|regbase
operator|==
name|ICH_REG_PI_BASE
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
literal|2
expr_stmt|;
name|ichchan_setblocksize
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* 	 * our data format is stereo, 16 bit so each sample is 4 bytes. 	 * assuming we get 48000 samples per second, we get 192000 bytes/sec. 	 * we're going to start recording with interrupts disabled and measure 	 * the time taken for one block to complete.  we know the block size, 	 * we know the time in microseconds, we calculate the sample rate: 	 * 	 * actual_rate [bps] = bytes / (time [s] * 4) 	 * actual_rate [bps] = (bytes * 1000000) / (time [us] * 4) 	 * actual_rate [Hz] = (bytes * 250000) / time [us] 	 */
comment|/* prepare */
name|ociv
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CIV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nciv
operator|=
name|ociv
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_BDBAR
argument_list|,
operator|(
name|u_int32_t
operator|)
name|vtophys
argument_list|(
name|ch
operator|->
name|dtbl
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* start */
name|microtime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RPBM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* wait */
while|while
condition|(
name|nciv
operator|==
name|ociv
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|-
name|t1
operator|.
name|tv_sec
operator|>
literal|1
condition|)
break|break;
name|nciv
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CIV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
comment|/* stop */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reset */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn time delta into us */
name|wait_us
operator|=
operator|(
operator|(
name|t2
operator|.
name|tv_sec
operator|-
name|t1
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|)
operator|+
name|t2
operator|.
name|tv_usec
operator|-
name|t1
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|nciv
operator|==
name|ociv
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ac97 link rate calibration timed out after %d us\n"
argument_list|,
name|wait_us
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|actual_48k_rate
operator|=
operator|(
name|bytes
operator|*
literal|250000
operator|)
operator|/
name|wait_us
expr_stmt|;
if|if
condition|(
name|actual_48k_rate
operator|<
literal|47500
operator|||
name|actual_48k_rate
operator|>
literal|48500
condition|)
block|{
name|sc
operator|->
name|ac97rate
operator|=
name|actual_48k_rate
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ac97rate
operator|=
literal|48000
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|sc
operator|->
name|ac97rate
operator|!=
literal|48000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"measured ac97 link rate at %d Hz"
argument_list|,
name|actual_48k_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ac97rate
operator|!=
name|actual_48k_rate
condition|)
name|printf
argument_list|(
literal|", will use %d Hz"
argument_list|,
name|sc
operator|->
name|ac97rate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|ac97rate
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Probe and attach the card */
end_comment

begin_function
specifier|static
name|void
name|ich_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_init
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|stat
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
name|ICH_GLOB_CTL_COLD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|600000
argument_list|)
expr_stmt|;
name|stat
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|ICH_GLOB_STA_PCR
operator|)
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
name|ICH_GLOB_CTL_COLD
operator||
name|ICH_GLOB_CTL_PRES
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|||
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|sc
operator|->
name|hasmic
operator|&&
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|dtbl
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|dtmap
argument_list|)
condition|)
return|return
name|ENOSPC
return|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ich_desc
argument_list|)
operator|*
name|ICH_DTBL_LENGTH
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|dtmap
argument_list|,
name|sc
operator|->
name|dtbl
argument_list|,
name|sz
argument_list|,
name|ich_setmap
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|dtbl
argument_list|,
name|sc
operator|->
name|dtmap
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x71958086
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 443MX"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|0x24158086
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 82801AA (ICH)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|0x24258086
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 82801AB (ICH)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|0x24458086
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 82801BA (ICH2)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|0x24858086
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 82801CA (ICH3)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIS7012ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SiS 7012"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|ENXIO
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|u_int16_t
name|extcaps
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * The SiS 7012 register set isn't quite like the standard ich. 	 * There really should be a general "quirks" mechanism. 	 */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
name|SIS7012ID
condition|)
block|{
name|sc
operator|->
name|swap_reg
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sample_size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|swap_reg
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sample_size
operator|=
literal|2
expr_stmt|;
block|}
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nambarid
operator|=
name|PCIR_NAMBAR
expr_stmt|;
name|sc
operator|->
name|nabmbarid
operator|=
name|PCIR_NABMBAR
expr_stmt|;
name|sc
operator|->
name|nambar
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|nambarid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nabmbar
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|nabmbarid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|nambar
operator|||
operator|!
name|sc
operator|->
name|nabmbar
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map IO port space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|nambart
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nambarh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nabmbart
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nabmbarh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|ICH_DEFAULT_BUFSZ
argument_list|,
name|ICH_MAX_BUFSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|,
literal|1
argument_list|,
literal|0x3ffff
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
operator|||
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|ich_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ich_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize the card\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|ich_ac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|codec
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
comment|/* check and set VRA function */
name|extcaps
operator|=
name|ac97_getextcaps
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hasvra
operator|=
name|extcaps
operator|&
name|AC97_EXTCAP_VRA
expr_stmt|;
name|sc
operator|->
name|hasvrm
operator|=
name|extcaps
operator|&
name|AC97_EXTCAP_VRM
expr_stmt|;
name|sc
operator|->
name|hasmic
operator|=
name|ac97_getcaps
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
operator|&
name|AC97_CAP_MICCHANNEL
expr_stmt|;
name|ac97_setextmode
argument_list|(
name|sc
operator|->
name|codec
argument_list|,
name|sc
operator|->
name|hasvra
operator||
name|sc
operator|->
name|hasvrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|hasmic
condition|?
literal|2
else|:
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|ichchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* play */
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|ichchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* record */
if|if
condition|(
name|sc
operator|->
name|hasmic
condition|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|ichchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* record mic */
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx, 0x%lx irq %ld bufsz %u"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|nambar
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|nabmbar
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ich_initsys
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_calibrate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|sc
operator|->
name|codec
condition|)
name|ac97_destroy
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nambar
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|nambarid
argument_list|,
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nabmbar
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|nabmbarid
argument_list|,
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|nambarid
argument_list|,
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|nabmbarid
argument_list|,
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run_save
operator|=
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run
condition|)
block|{
name|ichchan_trigger
argument_list|(
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|ch
index|[
name|i
index|]
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ACLINK shut off */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
name|ICH_GLOB_CTL_SHUT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Reinit audio device */
if|if
condition|(
name|ich_init
argument_list|(
name|sc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the card\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Reinit mixer */
if|if
condition|(
name|mixer_reinit
argument_list|(
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Re-start DMA engines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|ch
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run_save
condition|)
block|{
name|ichchan_setblocksize
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|blksz
argument_list|)
expr_stmt|;
name|ichchan_setspeed
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
name|ichchan_trigger
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ich_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ich_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ich_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ich_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ich_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ich_pci_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ich_driver
init|=
block|{
literal|"pcm"
block|,
name|ich_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_ich
argument_list|,
name|pci
argument_list|,
name|ich_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_ich
argument_list|,
name|snd_pcm
argument_list|,
name|PCM_MINVER
argument_list|,
name|PCM_PREFVER
argument_list|,
name|PCM_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_ich
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

