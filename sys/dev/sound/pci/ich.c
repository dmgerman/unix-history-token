begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Katsurajima Naoto<raven@katsurajima.seya.yokohama.jp>  * Copyright (c) 2001 Cameron Grant<cg@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THEPOSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/ich.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|ICH_TIMEOUT
value|1000
end_define

begin_comment
comment|/* semaphore timeout polling count */
end_comment

begin_define
define|#
directive|define
name|ICH_DTBL_LENGTH
value|32
end_define

begin_define
define|#
directive|define
name|ICH_DEFAULT_BUFSZ
value|16384
end_define

begin_define
define|#
directive|define
name|ICH_MAX_BUFSZ
value|65536
end_define

begin_define
define|#
directive|define
name|ICH_MIN_BUFSZ
value|4096
end_define

begin_define
define|#
directive|define
name|ICH_DEFAULT_BLKCNT
value|2
end_define

begin_define
define|#
directive|define
name|ICH_MAX_BLKCNT
value|32
end_define

begin_define
define|#
directive|define
name|ICH_MIN_BLKCNT
value|2
end_define

begin_define
define|#
directive|define
name|INTEL_VENDORID
value|0x8086
end_define

begin_define
define|#
directive|define
name|SIS_VENDORID
value|0x1039
end_define

begin_define
define|#
directive|define
name|NVIDIA_VENDORID
value|0x10de
end_define

begin_define
define|#
directive|define
name|AMD_VENDORID
value|0x1022
end_define

begin_define
define|#
directive|define
name|INTEL_82440MX
value|0x7195
end_define

begin_define
define|#
directive|define
name|INTEL_82801AA
value|0x2415
end_define

begin_define
define|#
directive|define
name|INTEL_82801AB
value|0x2425
end_define

begin_define
define|#
directive|define
name|INTEL_82801BA
value|0x2445
end_define

begin_define
define|#
directive|define
name|INTEL_82801CA
value|0x2485
end_define

begin_define
define|#
directive|define
name|INTEL_82801DB
value|0x24c5
end_define

begin_comment
comment|/* ICH4 needs special handling */
end_comment

begin_define
define|#
directive|define
name|INTEL_82801EB
value|0x24d5
end_define

begin_comment
comment|/* ICH5 needs to be treated as ICH4 */
end_comment

begin_define
define|#
directive|define
name|INTEL_6300ESB
value|0x25a6
end_define

begin_comment
comment|/* 6300ESB needs to be treated as ICH4 */
end_comment

begin_define
define|#
directive|define
name|INTEL_82801FB
value|0x266e
end_define

begin_comment
comment|/* ICH6 needs to be treated as ICH4 */
end_comment

begin_define
define|#
directive|define
name|INTEL_82801GB
value|0x27de
end_define

begin_comment
comment|/* ICH7 needs to be treated as ICH4 */
end_comment

begin_define
define|#
directive|define
name|SIS_7012
value|0x7012
end_define

begin_comment
comment|/* SiS 7012 needs special handling */
end_comment

begin_define
define|#
directive|define
name|NVIDIA_NFORCE
value|0x01b1
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE2
value|0x006a
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE2_400
value|0x008a
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE3
value|0x00da
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE3_250
value|0x00ea
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE4
value|0x0059
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE_410_MCP
value|0x026b
end_define

begin_define
define|#
directive|define
name|NVIDIA_NFORCE4_MCP
value|0x003a
end_define

begin_define
define|#
directive|define
name|AMD_768
value|0x7445
end_define

begin_define
define|#
directive|define
name|AMD_8111
value|0x746d
end_define

begin_define
define|#
directive|define
name|ICH_LOCK
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxlock((sc)->ich_lock)
end_define

begin_define
define|#
directive|define
name|ICH_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxunlock((sc)->ich_lock)
end_define

begin_define
define|#
directive|define
name|ICH_LOCK_ASSERT
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxassert((sc)->ich_lock)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ICH_DEBUG
parameter_list|(
name|stmt
parameter_list|)
value|do {	\ 	stmt				\ } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ICH_DEBUG
parameter_list|(
name|stmt
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
specifier|const
struct|struct
name|ich_type
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|devid
decl_stmt|;
name|uint32_t
name|options
decl_stmt|;
define|#
directive|define
name|PROBE_LOW
value|0x01
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|ich_devs
index|[]
init|=
block|{
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82440MX
block|,
literal|0
block|,
literal|"Intel 440MX"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801AA
block|,
literal|0
block|,
literal|"Intel ICH (82801AA)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801AB
block|,
literal|0
block|,
literal|"Intel ICH (82801AB)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801BA
block|,
literal|0
block|,
literal|"Intel ICH2 (82801BA)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801CA
block|,
literal|0
block|,
literal|"Intel ICH3 (82801CA)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801DB
block|,
name|PROBE_LOW
block|,
literal|"Intel ICH4 (82801DB)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801EB
block|,
name|PROBE_LOW
block|,
literal|"Intel ICH5 (82801EB)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_6300ESB
block|,
name|PROBE_LOW
block|,
literal|"Intel 6300ESB"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801FB
block|,
name|PROBE_LOW
block|,
literal|"Intel ICH6 (82801FB)"
block|}
block|,
block|{
name|INTEL_VENDORID
block|,
name|INTEL_82801GB
block|,
name|PROBE_LOW
block|,
literal|"Intel ICH7 (82801GB)"
block|}
block|,
block|{
name|SIS_VENDORID
block|,
name|SIS_7012
block|,
literal|0
block|,
literal|"SiS 7012"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE
block|,
literal|0
block|,
literal|"nVidia nForce"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE2
block|,
literal|0
block|,
literal|"nVidia nForce2"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE2_400
block|,
literal|0
block|,
literal|"nVidia nForce2 400"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE3
block|,
literal|0
block|,
literal|"nVidia nForce3"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE3_250
block|,
literal|0
block|,
literal|"nVidia nForce3 250"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE4
block|,
literal|0
block|,
literal|"nVidia nForce4"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE_410_MCP
block|,
literal|0
block|,
literal|"nVidia nForce 410 MCP"
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
name|NVIDIA_NFORCE4_MCP
block|,
literal|0
block|,
literal|"nVidia nForce 4 MCP"
block|}
block|,
block|{
name|AMD_VENDORID
block|,
name|AMD_768
block|,
literal|0
block|,
literal|"AMD-768"
block|}
block|,
block|{
name|AMD_VENDORID
block|,
name|AMD_8111
block|,
literal|0
block|,
literal|"AMD-8111"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* buffer descriptor */
end_comment

begin_struct
struct|struct
name|ich_desc
block|{
specifier|volatile
name|uint32_t
name|buffer
decl_stmt|;
specifier|volatile
name|uint32_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|sc_info
struct_decl|;
end_struct_decl

begin_comment
comment|/* channel registers */
end_comment

begin_struct
struct|struct
name|sc_chinfo
block|{
name|uint32_t
name|num
range|:
literal|8
decl_stmt|,
name|run
range|:
literal|1
decl_stmt|,
name|run_save
range|:
literal|1
decl_stmt|;
name|uint32_t
name|blksz
decl_stmt|,
name|blkcnt
decl_stmt|,
name|spd
decl_stmt|;
name|uint32_t
name|regbase
decl_stmt|,
name|spdreg
decl_stmt|;
name|uint32_t
name|imask
decl_stmt|;
name|uint32_t
name|civ
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|ich_desc
modifier|*
name|dtbl
decl_stmt|;
name|bus_addr_t
name|desc_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* device private data */
end_comment

begin_struct
struct|struct
name|sc_info
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|hasvra
decl_stmt|,
name|hasvrm
decl_stmt|,
name|hasmic
decl_stmt|;
name|unsigned
name|int
name|chnum
decl_stmt|,
name|bufsz
decl_stmt|,
name|blkcnt
decl_stmt|;
name|int
name|sample_size
decl_stmt|,
name|swap_reg
decl_stmt|,
name|fixedrate
decl_stmt|;
name|struct
name|resource
modifier|*
name|nambar
decl_stmt|,
modifier|*
name|nabmbar
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|int
name|regtype
decl_stmt|,
name|nambarid
decl_stmt|,
name|nabmbarid
decl_stmt|,
name|irqid
decl_stmt|;
name|bus_space_tag_t
name|nambart
decl_stmt|,
name|nabmbart
decl_stmt|;
name|bus_space_handle_t
name|nambarh
decl_stmt|,
name|nabmbarh
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|bus_dmamap_t
name|dtmap
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
decl_stmt|;
name|struct
name|sc_chinfo
name|ch
index|[
literal|3
index|]
decl_stmt|;
name|int
name|ac97rate
decl_stmt|,
name|calibrated
decl_stmt|;
name|struct
name|ich_desc
modifier|*
name|dtbl
decl_stmt|;
name|bus_addr_t
name|desc_addr
decl_stmt|;
name|struct
name|intr_config_hook
name|intrhook
decl_stmt|;
name|int
name|use_intrhook
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|devid
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
define|#
directive|define
name|IGNORE_PCR
value|0x01
name|struct
name|mtx
modifier|*
name|ich_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|ich_fmt
index|[]
init|=
block|{
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|ich_vrcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|ich_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|ich_caps
init|=
block|{
literal|48000
block|,
literal|48000
block|,
name|ich_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Hardware */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|ich_rd
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ich_wr
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|nabmbart
argument_list|,
name|sc
operator|->
name|nabmbarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ac97 codec */
end_comment

begin_function
specifier|static
name|int
name|ich_waitcd
parameter_list|(
name|void
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_ACC_SEMA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|IGNORE_PCR
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CODEC semaphore timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_rdcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|regno
operator|&=
literal|0xff
expr_stmt|;
name|ich_waitcd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|nambart
argument_list|,
name|sc
operator|->
name|nambarh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_wrcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|regno
operator|&=
literal|0xff
expr_stmt|;
name|ich_waitcd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|nambart
argument_list|,
name|sc
operator|->
name|nambarh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ich_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|ich_rdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|ich_wrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|ich_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* common routines */
end_comment

begin_function
specifier|static
name|void
name|ich_filldtbl
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
operator|)
operator|>
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
condition|)
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
operator|(
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|!=
name|ch
operator|->
name|blksz
operator|||
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|!=
name|ch
operator|->
name|blkcnt
operator|)
operator|&&
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|ch
operator|->
name|blkcnt
argument_list|,
name|ch
operator|->
name|blksz
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed blksz=%u blkcnt=%u\n"
argument_list|,
name|__func__
argument_list|,
name|ch
operator|->
name|blksz
argument_list|,
name|ch
operator|->
name|blkcnt
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_DTBL_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|->
name|dtbl
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|base
operator|+
operator|(
name|ch
operator|->
name|blksz
operator|*
operator|(
name|i
operator|%
name|ch
operator|->
name|blkcnt
operator|)
operator|)
expr_stmt|;
name|ch
operator|->
name|dtbl
index|[
name|i
index|]
operator|.
name|length
operator|=
name|ICH_BDC_IOC
operator||
operator|(
name|ch
operator|->
name|blksz
operator|/
name|ch
operator|->
name|parent
operator|->
name|sample_size
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ich_resetchan
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cr
decl_stmt|,
name|regbase
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|regbase
operator|=
name|ICH_REG_PO_BASE
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|regbase
operator|=
name|ICH_REG_PI_BASE
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|2
condition|)
name|regbase
operator|=
name|ICH_REG_MC_BASE
expr_stmt|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* This may result in no sound output on NForce 2 MBs, see PR 73987 */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICH_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|cr
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot reset channel %d\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ichchan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|num
operator|=
name|sc
operator|->
name|chnum
operator|++
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|ch
index|[
name|num
index|]
expr_stmt|;
name|ch
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dtbl
operator|=
name|sc
operator|->
name|dtbl
operator|+
operator|(
name|ch
operator|->
name|num
operator|*
name|ICH_DTBL_LENGTH
operator|)
expr_stmt|;
name|ch
operator|->
name|desc_addr
operator|=
name|sc
operator|->
name|desc_addr
operator|+
operator|(
name|ch
operator|->
name|num
operator|*
name|ICH_DTBL_LENGTH
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ich_desc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|sc
operator|->
name|blkcnt
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|bufsz
operator|/
name|ch
operator|->
name|blkcnt
expr_stmt|;
switch|switch
condition|(
name|ch
operator|->
name|num
condition|)
block|{
case|case
literal|0
case|:
comment|/* play */
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_PLAY
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|regbase
operator|=
name|ICH_REG_PO_BASE
expr_stmt|;
name|ch
operator|->
name|spdreg
operator|=
operator|(
name|sc
operator|->
name|hasvra
operator|)
condition|?
name|AC97_REGEXT_FDACRATE
else|:
literal|0
expr_stmt|;
name|ch
operator|->
name|imask
operator|=
name|ICH_GLOB_STA_POINT
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* record */
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|regbase
operator|=
name|ICH_REG_PI_BASE
expr_stmt|;
name|ch
operator|->
name|spdreg
operator|=
operator|(
name|sc
operator|->
name|hasvra
operator|)
condition|?
name|AC97_REGEXT_LADCRATE
else|:
literal|0
expr_stmt|;
name|ch
operator|->
name|imask
operator|=
name|ICH_GLOB_STA_PIINT
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* mic */
name|KASSERT
argument_list|(
name|dir
operator|==
name|PCMDIR_REC
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|regbase
operator|=
name|ICH_REG_MC_BASE
expr_stmt|;
name|ch
operator|->
name|spdreg
operator|=
operator|(
name|sc
operator|->
name|hasvrm
operator|)
condition|?
name|AC97_REGEXT_MADCRATE
else|:
literal|0
expr_stmt|;
name|ch
operator|->
name|imask
operator|=
name|ICH_GLOB_STA_MINT
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|fixedrate
operator|!=
literal|0
condition|)
name|ch
operator|->
name|spdreg
operator|=
literal|0
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_BDBAR
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ch
operator|->
name|desc_addr
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|ICH_DEBUG
argument_list|(
argument|struct sc_chinfo *ch = data; 		struct sc_info *sc = ch->parent; 		if (sc->calibrated ==
literal|0
argument|) 			device_printf(sc->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|ICH_DEBUG
argument_list|(
argument|if (sc->calibrated ==
literal|0
argument|) 			device_printf(sc->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
if|if
condition|(
name|ch
operator|->
name|spdreg
condition|)
block|{
name|int
name|r
decl_stmt|,
name|ac97rate
decl_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ac97rate
operator|<=
literal|32000
operator|||
name|sc
operator|->
name|ac97rate
operator|>=
literal|64000
condition|)
name|sc
operator|->
name|ac97rate
operator|=
literal|48000
expr_stmt|;
name|ac97rate
operator|=
name|sc
operator|->
name|ac97rate
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|speed
operator|*
literal|48000
operator|)
operator|/
name|ac97rate
expr_stmt|;
comment|/* 		 * Cast the return value of ac97_setrate() to uint64 so that 		 * the math don't overflow into the negative range. 		 */
name|ch
operator|->
name|spd
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ac97_setrate
argument_list|(
name|sc
operator|->
name|codec
argument_list|,
name|ch
operator|->
name|spdreg
argument_list|,
name|r
argument_list|)
operator|*
name|ac97rate
operator|)
operator|/
literal|48000
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|spd
operator|=
literal|48000
expr_stmt|;
block|}
return|return
operator|(
name|ch
operator|->
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|ICH_DEBUG
argument_list|(
argument|if (sc->calibrated ==
literal|0
argument|) 			device_printf(sc->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|blocksize
expr_stmt|;
name|ich_filldtbl
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_LVI
argument_list|,
name|ch
operator|->
name|blkcnt
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|blksz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|ICH_DEBUG
argument_list|(
argument|if (sc->calibrated ==
literal|0
argument|) 			device_printf(sc->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|ch
operator|->
name|run
operator|=
literal|1
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_BDBAR
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ch
operator|->
name|desc_addr
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RPBM
operator||
name|ICH_X_CR_LVBIE
operator||
name|ICH_X_CR_IOCE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|num
argument_list|)
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ichchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|uint32_t
name|pos
decl_stmt|;
name|ICH_DEBUG
argument_list|(
argument|if (sc->calibrated ==
literal|0
argument|) 			device_printf(sc->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|civ
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CIV
argument_list|,
literal|1
argument_list|)
operator|%
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pos
operator|=
name|ch
operator|->
name|civ
operator|*
name|ch
operator|->
name|blksz
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|ichchan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|ICH_DEBUG
argument_list|(
argument|struct sc_info *sc = ch->parent;  		if (sc->calibrated ==
literal|0
argument|) 			device_printf(ch->parent->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
return|return
operator|(
operator|(
name|ch
operator|->
name|spdreg
operator|)
condition|?
operator|&
name|ich_vrcaps
else|:
operator|&
name|ich_caps
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|ichchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|ichchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|ichchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|ichchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|ichchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|ichchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|ichchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|ichchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|ichchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* The interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|ich_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|uint32_t
name|cbi
decl_stmt|,
name|lbi
decl_stmt|,
name|lvi
decl_stmt|,
name|st
decl_stmt|,
name|gs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ICH_DEBUG
argument_list|(
argument|if (sc->calibrated ==
literal|0
argument|) 			device_printf(sc->dev,
literal|"WARNING: %s() called before calibration!\n"
argument|, 			    __func__);
argument_list|)
empty_stmt|;
name|gs
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
literal|4
argument_list|)
operator|&
name|ICH_GLOB_STA_IMASK
expr_stmt|;
if|if
condition|(
name|gs
operator|&
operator|(
name|ICH_GLOB_STA_PRES
operator||
name|ICH_GLOB_STA_SRES
operator|)
condition|)
block|{
comment|/* Clear resume interrupt(s) - nothing doing with them */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
name|gs
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|gs
operator|&=
operator|~
operator|(
name|ICH_GLOB_STA_PRES
operator||
name|ICH_GLOB_STA_SRES
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|ch
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|imask
operator|&
name|gs
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|gs
operator|&=
operator|~
name|ch
operator|->
name|imask
expr_stmt|;
name|st
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
operator|(
operator|(
name|sc
operator|->
name|swap_reg
operator|)
condition|?
name|ICH_REG_X_PICB
else|:
name|ICH_REG_X_SR
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|st
operator|&=
name|ICH_X_SR_FIFOE
operator||
name|ICH_X_SR_BCIS
operator||
name|ICH_X_SR_LVBCI
expr_stmt|;
if|if
condition|(
name|st
operator|&
operator|(
name|ICH_X_SR_BCIS
operator||
name|ICH_X_SR_LVBCI
operator|)
condition|)
block|{
comment|/* block complete - update buffer */
if|if
condition|(
name|ch
operator|->
name|run
condition|)
block|{
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|channel
argument_list|)
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|lvi
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_LVI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cbi
operator|=
name|ch
operator|->
name|civ
operator|%
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
name|cbi
operator|==
literal|0
condition|)
name|cbi
operator|=
name|ch
operator|->
name|blkcnt
operator|-
literal|1
expr_stmt|;
else|else
name|cbi
operator|--
expr_stmt|;
name|lbi
operator|=
name|lvi
operator|%
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
name|cbi
operator|>=
name|lbi
condition|)
name|lvi
operator|+=
name|cbi
operator|-
name|lbi
expr_stmt|;
else|else
name|lvi
operator|+=
name|cbi
operator|+
name|ch
operator|->
name|blkcnt
operator|-
name|lbi
expr_stmt|;
name|lvi
operator|%=
name|ICH_DTBL_LENGTH
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_LVI
argument_list|,
name|lvi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* clear status bit */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
operator|(
operator|(
name|sc
operator|->
name|swap_reg
operator|)
condition|?
name|ICH_REG_X_PICB
else|:
name|ICH_REG_X_SR
operator|)
argument_list|,
name|st
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unhandled interrupt, gs_intr = %x\n"
argument_list|,
name|gs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Sysctl to control ac97 speed (some boards appear to end up using  * XTAL_IN rather than BIT_CLK for link timing).  */
end_comment

begin_function
specifier|static
name|int
name|ich_initsys
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
comment|/* XXX: this should move to a device specific sysctl "dev.pcm.X.yyy" 	   via device_get_sysctl_*() as discussed on multimedia@ in msg-id<861wujij2q.fsf@xps.des.no> */
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ac97rate"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|ac97rate
argument_list|,
literal|48000
argument_list|,
literal|"AC97 link rate (default = 48000)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SND_DYNSYSCTL */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ich_setstatus
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx, 0x%lx irq %ld bufsz %u %s"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|nambar
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|nabmbar
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_ich
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Calibrate card to determine the clock source.  The source maybe a  * function of the ac97 codec initialization code (to be investigated).  */
end_comment

begin_function
specifier|static
name|void
name|ich_calibrate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|uint8_t
name|ociv
decl_stmt|,
name|nciv
decl_stmt|;
name|uint32_t
name|wait_us
decl_stmt|,
name|actual_48k_rate
decl_stmt|,
name|oblkcnt
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|arg
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|ch
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_intrhook
condition|)
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
expr_stmt|;
comment|/* 	 * Grab audio from input for fixed interval and compare how 	 * much we actually get with what we expect.  Interval needs 	 * to be sufficiently short that no interrupts are 	 * generated. 	 */
name|KASSERT
argument_list|(
name|ch
operator|->
name|regbase
operator|==
name|ICH_REG_PI_BASE
argument_list|,
operator|(
literal|"wrong direction"
operator|)
argument_list|)
expr_stmt|;
name|oblkcnt
operator|=
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|calibrated
operator|=
literal|1
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ichchan_setblocksize
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calibrated
operator|=
literal|0
expr_stmt|;
comment|/* 	 * our data format is stereo, 16 bit so each sample is 4 bytes. 	 * assuming we get 48000 samples per second, we get 192000 bytes/sec. 	 * we're going to start recording with interrupts disabled and measure 	 * the time taken for one block to complete.  we know the block size, 	 * we know the time in microseconds, we calculate the sample rate: 	 * 	 * actual_rate [bps] = bytes / (time [s] * 4) 	 * actual_rate [bps] = (bytes * 1000000) / (time [us] * 4) 	 * actual_rate [Hz] = (bytes * 250000) / time [us] 	 */
comment|/* prepare */
name|ociv
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CIV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nciv
operator|=
name|ociv
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_BDBAR
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ch
operator|->
name|desc_addr
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* start */
name|microtime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RPBM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* wait */
do|do
block|{
name|microtime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|.
name|tv_sec
operator|-
name|t1
operator|.
name|tv_sec
operator|>
literal|1
condition|)
break|break;
name|nciv
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CIV
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nciv
operator|==
name|ociv
condition|)
do|;
comment|/* stop */
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reset */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|regbase
operator|+
name|ICH_REG_X_CR
argument_list|,
name|ICH_X_CR_RR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|oblkcnt
expr_stmt|;
comment|/* turn time delta into us */
name|wait_us
operator|=
operator|(
operator|(
name|t2
operator|.
name|tv_sec
operator|-
name|t1
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|)
operator|+
name|t2
operator|.
name|tv_usec
operator|-
name|t1
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|nciv
operator|==
name|ociv
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ac97 link rate calibration timed out after %d us\n"
argument_list|,
name|wait_us
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calibrated
operator|=
literal|1
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_setstatus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|actual_48k_rate
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ch
operator|->
name|blksz
operator|*
literal|250000
operator|)
operator|/
name|wait_us
expr_stmt|;
if|if
condition|(
name|actual_48k_rate
operator|<
literal|47500
operator|||
name|actual_48k_rate
operator|>
literal|48500
condition|)
block|{
name|sc
operator|->
name|ac97rate
operator|=
name|actual_48k_rate
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ac97rate
operator|=
literal|48000
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|||
name|sc
operator|->
name|ac97rate
operator|!=
literal|48000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"measured ac97 link rate at %d Hz"
argument_list|,
name|actual_48k_rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ac97rate
operator|!=
name|actual_48k_rate
condition|)
name|printf
argument_list|(
literal|", will use %d Hz"
argument_list|,
name|sc
operator|->
name|ac97rate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|calibrated
operator|=
literal|1
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ich_setstatus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Probe and attach the card */
end_comment

begin_function
specifier|static
name|void
name|ich_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sc_info
operator|*
operator|)
name|arg
decl_stmt|;
name|sc
operator|->
name|desc_addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_init
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|stat
decl_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
name|ICH_GLOB_CTL_COLD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|600000
argument_list|)
expr_stmt|;
name|stat
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|ICH_GLOB_STA_PCR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* ICH4/ICH5 may fail when busmastering is enabled. Continue */
if|if
condition|(
name|sc
operator|->
name|vendor
operator|==
name|INTEL_VENDORID
operator|&&
operator|(
name|sc
operator|->
name|devid
operator|==
name|INTEL_82801DB
operator|||
name|sc
operator|->
name|devid
operator|==
name|INTEL_82801EB
operator|||
name|sc
operator|->
name|devid
operator|==
name|INTEL_6300ESB
operator|||
name|sc
operator|->
name|devid
operator|==
name|INTEL_82801FB
operator|||
name|sc
operator|->
name|devid
operator|==
name|INTEL_82801GB
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|IGNORE_PCR
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"primary codec not ready!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|ich_wr(sc, ICH_REG_GLOB_CNT, ICH_GLOB_CTL_COLD | ICH_GLOB_CTL_PRES, 4);
else|#
directive|else
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
name|ICH_GLOB_CTL_COLD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|||
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|hasmic
operator|&&
name|ich_resetchan
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|devid
decl_stmt|,
name|vendor
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ich_devs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ich_devs
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|ich_devs
index|[
name|i
index|]
operator|.
name|vendor
operator|&&
name|devid
operator|==
name|ich_devs
index|[
name|i
index|]
operator|.
name|devid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ich_devs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* allow a better driver to override us */
if|if
condition|(
operator|(
name|ich_devs
index|[
name|i
index|]
operator|.
name|options
operator|&
name|PROBE_LOW
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|BUS_PROBE_LOW_PRIORITY
operator|)
return|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|subdev
decl_stmt|;
name|uint16_t
name|extcaps
decl_stmt|;
name|uint16_t
name|devid
decl_stmt|,
name|vendor
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|ich_lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sound softc"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|vendor
operator|=
name|sc
operator|->
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|sc
operator|->
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subdev
operator|=
operator|(
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * The SiS 7012 register set isn't quite like the standard ich. 	 * There really should be a general "quirks" mechanism. 	 */
if|if
condition|(
name|vendor
operator|==
name|SIS_VENDORID
operator|&&
name|devid
operator|==
name|SIS_7012
condition|)
block|{
name|sc
operator|->
name|swap_reg
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sample_size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|swap_reg
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sample_size
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Enable bus master. On ich4/5 this may prevent the detection of 	 * the primary codec becoming ready in ich_init(). 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * By default, ich4 has NAMBAR and NABMBAR i/o spaces as 	 * read-only.  Need to enable "legacy support", by poking into 	 * pci config space.  The driver should use MMBAR and MBBAR, 	 * but doing so will mess things up here.  ich4 has enough new 	 * features it warrants it's own driver.  	 */
if|if
condition|(
name|vendor
operator|==
name|INTEL_VENDORID
operator|&&
operator|(
name|devid
operator|==
name|INTEL_82801DB
operator|||
name|devid
operator|==
name|INTEL_82801EB
operator|||
name|devid
operator|==
name|INTEL_6300ESB
operator|||
name|devid
operator|==
name|INTEL_82801FB
operator|||
name|devid
operator|==
name|INTEL_82801GB
operator|)
condition|)
block|{
name|sc
operator|->
name|nambarid
operator|=
name|PCIR_MMBAR
expr_stmt|;
name|sc
operator|->
name|nabmbarid
operator|=
name|PCIR_MBBAR
expr_stmt|;
name|sc
operator|->
name|regtype
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_ICH_LEGACY
argument_list|,
name|ICH_LEGACY_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|nambarid
operator|=
name|PCIR_NAMBAR
expr_stmt|;
name|sc
operator|->
name|nabmbarid
operator|=
name|PCIR_NABMBAR
expr_stmt|;
name|sc
operator|->
name|regtype
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
block|}
name|sc
operator|->
name|nambar
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|regtype
argument_list|,
operator|&
name|sc
operator|->
name|nambarid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nabmbar
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|regtype
argument_list|,
operator|&
name|sc
operator|->
name|nabmbarid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|nambar
operator|||
operator|!
name|sc
operator|->
name|nabmbar
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map IO port space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|nambart
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nambarh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nabmbart
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nabmbarh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
name|ICH_MIN_BUFSZ
argument_list|,
name|ICH_DEFAULT_BUFSZ
argument_list|,
name|ICH_MAX_BUFSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"blocksize"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|blkcnt
operator|=
name|sc
operator|->
name|bufsz
operator|/
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|blkcnt
operator|>>
name|i
condition|)
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|blkcnt
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|blkcnt
operator|<
name|ICH_MIN_BLKCNT
condition|)
name|sc
operator|->
name|blkcnt
operator|=
name|ICH_MIN_BLKCNT
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|blkcnt
operator|>
name|ICH_MAX_BLKCNT
condition|)
name|sc
operator|->
name|blkcnt
operator|=
name|ICH_MAX_BLKCNT
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|blkcnt
operator|=
name|ICH_DEFAULT_BLKCNT
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"fixedrate"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
name|sc
operator|->
name|fixedrate
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|fixedrate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|,
literal|1
argument_list|,
literal|0x3ffff
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
operator|||
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|ich_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ich_init
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize the card\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|dtbl
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|dtmap
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|dtmap
argument_list|,
name|sc
operator|->
name|dtbl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ich_desc
argument_list|)
operator|*
name|ICH_DTBL_LENGTH
operator|*
literal|3
argument_list|,
name|ich_setmap
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|sc
operator|->
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
name|ich_ac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|codec
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Turn on inverted external amplifier sense flags for few 	 * 'special' boards. 	 */
switch|switch
condition|(
name|subdev
condition|)
block|{
case|case
literal|0x202f161f
case|:
comment|/* Gateway 7326GZ */
case|case
literal|0x203a161f
case|:
comment|/* Gateway 4028GZ */
case|case
literal|0x204c161f
case|:
comment|/* Kvazar-Micro Senator 3592XT */
case|case
literal|0x8144104d
case|:
comment|/* Sony VAIO PCG-TR* */
case|case
literal|0x8197104d
case|:
comment|/* Sony S1XP */
case|case
literal|0x81c0104d
case|:
comment|/* Sony VAIO type T */
case|case
literal|0x81c5104d
case|:
comment|/* Sony VAIO VGN B1VP/B1XP */
case|case
literal|0x3089103c
case|:
comment|/* Compaq Presario B3800 */
case|case
literal|0x309a103c
case|:
comment|/* HP Compaq nx4300 */
case|case
literal|0x82131033
case|:
comment|/* NEC VersaPro VJ10F/BH */
case|case
literal|0x82be1033
case|:
comment|/* NEC VersaPro VJ12F/CH */
name|ac97_setflags
argument_list|(
name|sc
operator|->
name|codec
argument_list|,
name|ac97_getflags
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
operator||
name|AC97_F_EAPD_INV
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
comment|/* check and set VRA function */
name|extcaps
operator|=
name|ac97_getextcaps
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hasvra
operator|=
name|extcaps
operator|&
name|AC97_EXTCAP_VRA
expr_stmt|;
name|sc
operator|->
name|hasvrm
operator|=
name|extcaps
operator|&
name|AC97_EXTCAP_VRM
expr_stmt|;
name|sc
operator|->
name|hasmic
operator|=
name|ac97_getcaps
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
operator|&
name|AC97_CAP_MICCHANNEL
expr_stmt|;
name|ac97_setextmode
argument_list|(
name|sc
operator|->
name|codec
argument_list|,
name|sc
operator|->
name|hasvra
operator||
name|sc
operator|->
name|hasvrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
operator|(
name|sc
operator|->
name|hasmic
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|ichchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* play */
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|ichchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* record */
if|if
condition|(
name|sc
operator|->
name|hasmic
condition|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|ichchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* record mic */
if|if
condition|(
name|sc
operator|->
name|fixedrate
operator|==
literal|0
condition|)
block|{
name|ich_initsys
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|ich_calibrate
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|use_intrhook
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot establish calibration hook, will calibrate now\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|use_intrhook
operator|=
literal|0
expr_stmt|;
name|ich_calibrate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|calibrated
operator|=
literal|1
expr_stmt|;
name|ich_setstatus
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|sc
operator|->
name|codec
condition|)
name|ac97_destroy
argument_list|(
name|sc
operator|->
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nambar
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|regtype
argument_list|,
name|sc
operator|->
name|nambarid
argument_list|,
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nabmbar
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|regtype
argument_list|,
name|sc
operator|->
name|nabmbarid
argument_list|,
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dtmap
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|dtmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ich_lock
condition|)
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|ich_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|regtype
argument_list|,
name|sc
operator|->
name|nambarid
argument_list|,
name|sc
operator|->
name|nambar
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|regtype
argument_list|,
name|sc
operator|->
name|nabmbarid
argument_list|,
name|sc
operator|->
name|nabmbar
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|dmat
argument_list|,
name|sc
operator|->
name|dtmap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|ich_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ich_pci_codec_reset
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|control
decl_stmt|;
name|control
operator|=
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|control
operator|&=
operator|~
operator|(
name|ICH_GLOB_CTL_SHUT
operator|)
expr_stmt|;
name|control
operator||=
operator|(
name|control
operator|&
name|ICH_GLOB_CTL_COLD
operator|)
condition|?
name|ICH_GLOB_CTL_WARM
else|:
name|ICH_GLOB_CTL_COLD
expr_stmt|;
name|ich_wr
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_CNT
argument_list|,
name|control
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|500000
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ich_rd
argument_list|(
name|sc
argument_list|,
name|ICH_REG_GLOB_STA
argument_list|,
literal|4
argument_list|)
operator|&
name|ICH_GLOB_STA_PCR
condition|)
break|break;
comment|/*		or ICH_SCR? */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: time out\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run_save
operator|=
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run
condition|)
block|{
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ichchan_trigger
argument_list|(
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|ch
index|[
name|i
index|]
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ich_pci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regtype
operator|==
name|SYS_RES_IOPORT
condition|)
name|pci_enable_io
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|)
expr_stmt|;
else|else
name|pci_enable_io
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ICH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reinit audio device */
if|if
condition|(
name|ich_init
argument_list|(
name|sc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the card\n"
argument_list|)
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Reinit mixer */
name|ich_pci_codec_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ICH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ac97_setextmode
argument_list|(
name|sc
operator|->
name|codec
argument_list|,
name|sc
operator|->
name|hasvra
operator||
name|sc
operator|->
name|hasvrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_reinit
argument_list|(
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Re-start DMA engines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|ch
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ch
index|[
name|i
index|]
operator|.
name|run_save
condition|)
block|{
name|ichchan_setblocksize
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|blksz
argument_list|)
expr_stmt|;
name|ichchan_setspeed
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
name|ichchan_trigger
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ich_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ich_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ich_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ich_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ich_pci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ich_pci_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ich_driver
init|=
block|{
literal|"pcm"
block|,
name|ich_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_ich
argument_list|,
name|pci
argument_list|,
name|ich_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_ich
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_ich
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

