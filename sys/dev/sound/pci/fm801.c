begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Dmitry Dicky diwil@dataart.com  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS `AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PCI_VENDOR_FORTEMEDIA
value|0x1319
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_FORTEMEDIA1
value|0x08011319
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_FORTEMEDIA2
value|0x08021319
end_define

begin_comment
comment|/* ??? have no idea what's this... */
end_comment

begin_define
define|#
directive|define
name|FM_PCM_VOLUME
value|0x00
end_define

begin_define
define|#
directive|define
name|FM_FM_VOLUME
value|0x02
end_define

begin_define
define|#
directive|define
name|FM_I2S_VOLUME
value|0x04
end_define

begin_define
define|#
directive|define
name|FM_RECORD_SOURCE
value|0x06
end_define

begin_define
define|#
directive|define
name|FM_PLAY_CTL
value|0x08
end_define

begin_define
define|#
directive|define
name|FM_PLAY_RATE_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|FM_PLAY_BUF1_LAST
value|0x0001
end_define

begin_define
define|#
directive|define
name|FM_PLAY_BUF2_LAST
value|0x0002
end_define

begin_define
define|#
directive|define
name|FM_PLAY_START
value|0x0020
end_define

begin_define
define|#
directive|define
name|FM_PLAY_PAUSE
value|0x0040
end_define

begin_define
define|#
directive|define
name|FM_PLAY_STOPNOW
value|0x0080
end_define

begin_define
define|#
directive|define
name|FM_PLAY_16BIT
value|0x4000
end_define

begin_define
define|#
directive|define
name|FM_PLAY_STEREO
value|0x8000
end_define

begin_define
define|#
directive|define
name|FM_PLAY_DMALEN
value|0x0a
end_define

begin_define
define|#
directive|define
name|FM_PLAY_DMABUF1
value|0x0c
end_define

begin_define
define|#
directive|define
name|FM_PLAY_DMABUF2
value|0x10
end_define

begin_define
define|#
directive|define
name|FM_REC_CTL
value|0x14
end_define

begin_define
define|#
directive|define
name|FM_REC_RATE_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|FM_REC_BUF1_LAST
value|0x0001
end_define

begin_define
define|#
directive|define
name|FM_REC_BUF2_LAST
value|0x0002
end_define

begin_define
define|#
directive|define
name|FM_REC_START
value|0x0020
end_define

begin_define
define|#
directive|define
name|FM_REC_PAUSE
value|0x0040
end_define

begin_define
define|#
directive|define
name|FM_REC_STOPNOW
value|0x0080
end_define

begin_define
define|#
directive|define
name|FM_REC_16BIT
value|0x4000
end_define

begin_define
define|#
directive|define
name|FM_REC_STEREO
value|0x8000
end_define

begin_define
define|#
directive|define
name|FM_REC_DMALEN
value|0x16
end_define

begin_define
define|#
directive|define
name|FM_REC_DMABUF1
value|0x18
end_define

begin_define
define|#
directive|define
name|FM_REC_DMABUF2
value|0x1c
end_define

begin_define
define|#
directive|define
name|FM_CODEC_CTL
value|0x22
end_define

begin_define
define|#
directive|define
name|FM_VOLUME
value|0x26
end_define

begin_define
define|#
directive|define
name|FM_VOLUME_MUTE
value|0x8000
end_define

begin_define
define|#
directive|define
name|FM_CODEC_CMD
value|0x2a
end_define

begin_define
define|#
directive|define
name|FM_CODEC_CMD_READ
value|0x0080
end_define

begin_define
define|#
directive|define
name|FM_CODEC_CMD_VALID
value|0x0100
end_define

begin_define
define|#
directive|define
name|FM_CODEC_CMD_BUSY
value|0x0200
end_define

begin_define
define|#
directive|define
name|FM_CODEC_DATA
value|0x2c
end_define

begin_define
define|#
directive|define
name|FM_IO_CTL
value|0x52
end_define

begin_define
define|#
directive|define
name|FM_CARD_CTL
value|0x54
end_define

begin_define
define|#
directive|define
name|FM_INTMASK
value|0x56
end_define

begin_define
define|#
directive|define
name|FM_INTMASK_PLAY
value|0x0001
end_define

begin_define
define|#
directive|define
name|FM_INTMASK_REC
value|0x0002
end_define

begin_define
define|#
directive|define
name|FM_INTMASK_VOL
value|0x0040
end_define

begin_define
define|#
directive|define
name|FM_INTMASK_MPU
value|0x0080
end_define

begin_define
define|#
directive|define
name|FM_INTSTATUS
value|0x5a
end_define

begin_define
define|#
directive|define
name|FM_INTSTATUS_PLAY
value|0x0100
end_define

begin_define
define|#
directive|define
name|FM_INTSTATUS_REC
value|0x0200
end_define

begin_define
define|#
directive|define
name|FM_INTSTATUS_VOL
value|0x4000
end_define

begin_define
define|#
directive|define
name|FM_INTSTATUS_MPU
value|0x8000
end_define

begin_define
define|#
directive|define
name|FM801_DEFAULT_BUFSZ
value|4096
end_define

begin_comment
comment|/* Other values do not work!!! */
end_comment

begin_comment
comment|/* debug purposes */
end_comment

begin_define
define|#
directive|define
name|DPRINT
value|if(0) printf
end_define

begin_comment
comment|/* static int fm801ch_setup(struct pcm_channel *c); */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|fmts
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|fm801ch_caps
init|=
block|{
literal|4000
block|,
literal|48000
block|,
name|fmts
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|fm801_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|fm801_chinfo
block|{
name|struct
name|fm801_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|spd
decl_stmt|,
name|dir
decl_stmt|,
name|fmt
decl_stmt|;
comment|/* speed, direction, format */
name|u_int32_t
name|shift
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fm801_info
block|{
name|int
name|type
decl_stmt|;
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|num
decl_stmt|;
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|,
modifier|*
name|irq
decl_stmt|;
name|int
name|regtype
decl_stmt|,
name|regid
decl_stmt|,
name|irqid
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|u_int32_t
name|play_flip
decl_stmt|,
name|play_nextblk
decl_stmt|,
name|play_start
decl_stmt|,
name|play_blksize
decl_stmt|,
name|play_fmt
decl_stmt|,
name|play_shift
decl_stmt|,
name|play_size
decl_stmt|;
name|u_int32_t
name|rec_flip
decl_stmt|,
name|rec_nextblk
decl_stmt|,
name|rec_start
decl_stmt|,
name|rec_blksize
decl_stmt|,
name|rec_fmt
decl_stmt|,
name|rec_shift
decl_stmt|,
name|rec_size
decl_stmt|;
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|struct
name|fm801_chinfo
name|pch
decl_stmt|,
name|rch
decl_stmt|;
name|device_t
name|radio
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bus Read / Write routines */
end_comment

begin_function
specifier|static
name|u_int32_t
name|fm801_rd
parameter_list|(
name|struct
name|fm801_info
modifier|*
name|fm801
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|fm801
operator|->
name|st
argument_list|,
name|fm801
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|bus_space_read_2
argument_list|(
name|fm801
operator|->
name|st
argument_list|,
name|fm801
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|fm801
operator|->
name|st
argument_list|,
name|fm801
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
default|default:
return|return
literal|0xffffffff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fm801_wr
parameter_list|(
name|struct
name|fm801_info
modifier|*
name|fm801
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|fm801
operator|->
name|st
argument_list|,
name|fm801
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|fm801
operator|->
name|st
argument_list|,
name|fm801
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|fm801
operator|->
name|st
argument_list|,
name|fm801
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  *  ac97 codec routines  */
end_comment

begin_define
define|#
directive|define
name|TIMO
value|50
end_define

begin_function
specifier|static
name|int
name|fm801_rdcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
operator|(
expr|struct
name|fm801_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMO
operator|&&
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CMD
argument_list|,
literal|2
argument_list|)
operator|&
name|FM_CODEC_CMD_BUSY
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
literal|"fm801 rdcd: 1 - DELAY\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|TIMO
condition|)
block|{
name|printf
argument_list|(
literal|"fm801 rdcd: codec busy\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CMD
argument_list|,
name|regno
operator||
name|FM_CODEC_CMD_READ
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMO
operator|&&
operator|!
operator|(
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CMD
argument_list|,
literal|2
argument_list|)
operator|&
name|FM_CODEC_CMD_VALID
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
literal|"fm801 rdcd: 2 - DELAY\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|TIMO
condition|)
block|{
name|printf
argument_list|(
literal|"fm801 rdcd: write codec invalid\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_DATA
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801_wrcd
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|int
name|regno
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
operator|(
expr|struct
name|fm801_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINT
argument_list|(
literal|"fm801_wrcd reg 0x%x val 0x%x\n"
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 	if(regno == AC97_REG_RECSEL)	return; */
comment|/* Poll until codec is ready */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMO
operator|&&
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CMD
argument_list|,
literal|2
argument_list|)
operator|&
name|FM_CODEC_CMD_BUSY
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
literal|"fm801 rdcd: 1 - DELAY\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|TIMO
condition|)
block|{
name|printf
argument_list|(
literal|"fm801 wrcd: read codec busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_DATA
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CMD
argument_list|,
name|regno
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* wait until codec is ready */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMO
operator|&&
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CMD
argument_list|,
literal|2
argument_list|)
operator|&
name|FM_CODEC_CMD_BUSY
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
literal|"fm801 wrcd: 2 - DELAY\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|TIMO
condition|)
block|{
name|printf
argument_list|(
literal|"fm801 wrcd: read codec busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DPRINT
argument_list|(
literal|"fm801 wrcd release reg 0x%x val 0x%x\n"
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|fm801_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|fm801_rdcd
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|fm801_wrcd
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|fm801_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * The interrupt handler  */
end_comment

begin_function
specifier|static
name|void
name|fm801_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
operator|(
expr|struct
name|fm801_info
operator|*
operator|)
name|p
decl_stmt|;
name|u_int32_t
name|intsrc
init|=
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_INTSTATUS
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|DPRINT
argument_list|(
literal|"\nfm801_intr intsrc 0x%x "
argument_list|,
name|intsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|intsrc
operator|&
name|FM_INTSTATUS_PLAY
condition|)
block|{
name|fm801
operator|->
name|play_flip
operator|++
expr_stmt|;
if|if
condition|(
name|fm801
operator|->
name|play_flip
operator|&
literal|1
condition|)
block|{
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_DMABUF1
argument_list|,
name|fm801
operator|->
name|play_start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_DMABUF2
argument_list|,
name|fm801
operator|->
name|play_nextblk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|chn_intr
argument_list|(
name|fm801
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intsrc
operator|&
name|FM_INTSTATUS_REC
condition|)
block|{
name|fm801
operator|->
name|rec_flip
operator|++
expr_stmt|;
if|if
condition|(
name|fm801
operator|->
name|rec_flip
operator|&
literal|1
condition|)
block|{
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_DMABUF1
argument_list|,
name|fm801
operator|->
name|rec_start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_DMABUF2
argument_list|,
name|fm801
operator|->
name|rec_nextblk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|chn_intr
argument_list|(
name|fm801
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intsrc
operator|&
name|FM_INTSTATUS_MPU
condition|)
block|{
comment|/* This is a TODOish thing... */
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_INTSTATUS
argument_list|,
name|intsrc
operator|&
name|FM_INTSTATUS_MPU
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intsrc
operator|&
name|FM_INTSTATUS_VOL
condition|)
block|{
comment|/* This is a TODOish thing... */
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_INTSTATUS
argument_list|,
name|intsrc
operator|&
name|FM_INTSTATUS_VOL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|DPRINT
argument_list|(
literal|"fm801_intr clear\n\n"
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_INTSTATUS
argument_list|,
name|intsrc
operator|&
operator|(
name|FM_INTSTATUS_PLAY
operator||
name|FM_INTSTATUS_REC
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* channel interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|fm801ch_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
operator|(
expr|struct
name|fm801_info
operator|*
operator|)
name|devinfo
decl_stmt|;
name|struct
name|fm801_chinfo
modifier|*
name|ch
init|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|fm801
operator|->
name|pch
else|:
operator|&
name|fm801
operator|->
name|rch
decl_stmt|;
name|DPRINT
argument_list|(
literal|"fm801ch_init, direction = %d\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|fm801
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|fm801
operator|->
name|parent_dmat
argument_list|,
name|fm801
operator|->
name|bufsz
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|void
operator|*
operator|)
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801ch_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|fm801_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|DPRINT
argument_list|(
literal|"fm801ch_setformat 0x%x : %s, %s, %s, %s\n"
argument_list|,
name|format
argument_list|,
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
literal|"stereo"
else|:
literal|"mono"
argument_list|,
operator|(
name|format
operator|&
operator|(
name|AFMT_S16_LE
operator||
name|AFMT_S16_BE
operator||
name|AFMT_U16_LE
operator||
name|AFMT_U16_BE
operator|)
operator|)
condition|?
literal|"16bit"
else|:
literal|"8bit"
argument_list|,
operator|(
name|format
operator|&
name|AFMT_SIGNED
operator|)
condition|?
literal|"signed"
else|:
literal|"unsigned"
argument_list|,
operator|(
name|format
operator|&
name|AFMT_BIGENDIAN
operator|)
condition|?
literal|"bigendiah"
else|:
literal|"littleendian"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|fm801
operator|->
name|play_fmt
operator|=
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
name|FM_PLAY_STEREO
else|:
literal|0
expr_stmt|;
name|fm801
operator|->
name|play_fmt
operator||=
operator|(
name|format
operator|&
name|AFMT_16BIT
operator|)
condition|?
name|FM_PLAY_16BIT
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
name|fm801
operator|->
name|rec_fmt
operator|=
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
name|FM_REC_STEREO
else|:
literal|0
expr_stmt|;
name|fm801
operator|->
name|rec_fmt
operator||=
operator|(
name|format
operator|&
name|AFMT_16BIT
operator|)
condition|?
name|FM_PLAY_16BIT
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
block|{
name|int
name|limit
decl_stmt|;
name|int
name|rate
decl_stmt|;
block|}
name|fm801_rates
index|[
literal|11
index|]
init|=
block|{
block|{
literal|6600
block|,
literal|5500
block|}
block|,
block|{
literal|8750
block|,
literal|8000
block|}
block|,
block|{
literal|10250
block|,
literal|9600
block|}
block|,
block|{
literal|13200
block|,
literal|11025
block|}
block|,
block|{
literal|17500
block|,
literal|16000
block|}
block|,
block|{
literal|20500
block|,
literal|19200
block|}
block|,
block|{
literal|26500
block|,
literal|22050
block|}
block|,
block|{
literal|35000
block|,
literal|32000
block|}
block|,
block|{
literal|41000
block|,
literal|38400
block|}
block|,
block|{
literal|46000
block|,
literal|44100
block|}
block|,
block|{
literal|48000
block|,
literal|48000
block|}
block|,
comment|/* anything above -> 48000 */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|fm801ch_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|fm801_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
name|ch
operator|->
name|parent
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
operator|&&
name|fm801_rates
index|[
name|i
index|]
operator|.
name|limit
operator|<=
name|speed
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|fm801
operator|->
name|pch
operator|.
name|spd
operator|=
name|fm801_rates
index|[
name|i
index|]
operator|.
name|rate
expr_stmt|;
name|fm801
operator|->
name|play_shift
operator|=
operator|(
name|i
operator|<<
literal|8
operator|)
expr_stmt|;
name|fm801
operator|->
name|play_shift
operator|&=
name|FM_PLAY_RATE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
name|fm801
operator|->
name|rch
operator|.
name|spd
operator|=
name|fm801_rates
index|[
name|i
index|]
operator|.
name|rate
expr_stmt|;
name|fm801
operator|->
name|rec_shift
operator|=
operator|(
name|i
operator|<<
literal|8
operator|)
expr_stmt|;
name|fm801
operator|->
name|rec_shift
operator|&=
name|FM_REC_RATE_MASK
expr_stmt|;
block|}
name|ch
operator|->
name|spd
operator|=
name|fm801_rates
index|[
name|i
index|]
operator|.
name|rate
expr_stmt|;
return|return
name|fm801_rates
index|[
name|i
index|]
operator|.
name|rate
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801ch_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|fm801_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|fm801
operator|->
name|play_flip
condition|)
return|return
name|fm801
operator|->
name|play_blksize
return|;
name|fm801
operator|->
name|play_blksize
operator|=
name|blocksize
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
if|if
condition|(
name|fm801
operator|->
name|rec_flip
condition|)
return|return
name|fm801
operator|->
name|rec_blksize
return|;
name|fm801
operator|->
name|rec_blksize
operator|=
name|blocksize
expr_stmt|;
block|}
name|DPRINT
argument_list|(
literal|"fm801ch_setblocksize %d (dir %d)\n"
argument_list|,
name|blocksize
argument_list|,
name|ch
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801ch_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|fm801_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|baseaddr
init|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
decl_stmt|;
name|u_int32_t
name|k1
decl_stmt|;
name|DPRINT
argument_list|(
literal|"fm801ch_trigger go %d , "
argument_list|,
name|go
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
operator|==
name|PCMTRIG_EMLDMAWR
operator|||
name|go
operator|==
name|PCMTRIG_EMLDMARD
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|fm801
operator|->
name|play_start
operator|=
name|baseaddr
expr_stmt|;
name|fm801
operator|->
name|play_nextblk
operator|=
name|fm801
operator|->
name|play_start
operator|+
name|fm801
operator|->
name|play_blksize
expr_stmt|;
name|fm801
operator|->
name|play_flip
operator|=
literal|0
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_DMALEN
argument_list|,
name|fm801
operator|->
name|play_blksize
operator|-
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_DMABUF1
argument_list|,
name|fm801
operator|->
name|play_start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_DMABUF2
argument_list|,
name|fm801
operator|->
name|play_nextblk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_CTL
argument_list|,
name|FM_PLAY_START
operator||
name|FM_PLAY_STOPNOW
operator||
name|fm801
operator|->
name|play_fmt
operator||
name|fm801
operator|->
name|play_shift
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fm801
operator|->
name|play_flip
operator|=
literal|0
expr_stmt|;
name|k1
operator|=
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PLAY_CTL
argument_list|,
operator|(
name|k1
operator|&
operator|~
operator|(
name|FM_PLAY_STOPNOW
operator||
name|FM_PLAY_START
operator|)
operator|)
operator||
name|FM_PLAY_BUF1_LAST
operator||
name|FM_PLAY_BUF2_LAST
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
if|if
condition|(
name|go
operator|==
name|PCMTRIG_START
condition|)
block|{
name|fm801
operator|->
name|rec_start
operator|=
name|baseaddr
expr_stmt|;
name|fm801
operator|->
name|rec_nextblk
operator|=
name|fm801
operator|->
name|rec_start
operator|+
name|fm801
operator|->
name|rec_blksize
expr_stmt|;
name|fm801
operator|->
name|rec_flip
operator|=
literal|0
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_DMALEN
argument_list|,
name|fm801
operator|->
name|rec_blksize
operator|-
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_DMABUF1
argument_list|,
name|fm801
operator|->
name|rec_start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_DMABUF2
argument_list|,
name|fm801
operator|->
name|rec_nextblk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_CTL
argument_list|,
name|FM_REC_START
operator||
name|FM_REC_STOPNOW
operator||
name|fm801
operator|->
name|rec_fmt
operator||
name|fm801
operator|->
name|rec_shift
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fm801
operator|->
name|rec_flip
operator|=
literal|0
expr_stmt|;
name|k1
operator|=
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
name|FM_REC_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_REC_CTL
argument_list|,
operator|(
name|k1
operator|&
operator|~
operator|(
name|FM_REC_STOPNOW
operator||
name|FM_REC_START
operator|)
operator|)
operator||
name|FM_REC_BUF1_LAST
operator||
name|FM_REC_BUF2_LAST
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Almost ALSA copy */
end_comment

begin_function
specifier|static
name|int
name|fm801ch_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|fm801_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|result
operator|=
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
operator|(
name|fm801
operator|->
name|play_flip
operator|&
literal|1
operator|)
condition|?
name|FM_PLAY_DMABUF2
else|:
name|FM_PLAY_DMABUF1
argument_list|,
literal|4
argument_list|)
operator|-
name|fm801
operator|->
name|play_start
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
name|result
operator|=
name|fm801_rd
argument_list|(
name|fm801
argument_list|,
operator|(
name|fm801
operator|->
name|rec_flip
operator|&
literal|1
operator|)
condition|?
name|FM_REC_DMABUF2
else|:
name|FM_REC_DMABUF1
argument_list|,
literal|4
argument_list|)
operator|-
name|fm801
operator|->
name|rec_start
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|fm801ch_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|&
name|fm801ch_caps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|fm801ch_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|fm801ch_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|fm801ch_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|fm801ch_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|fm801ch_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|fm801ch_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|fm801ch_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|fm801ch_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|fm801ch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  *  Init routine is taken from an original NetBSD driver  */
end_comment

begin_function
specifier|static
name|int
name|fm801_init
parameter_list|(
name|struct
name|fm801_info
modifier|*
name|fm801
parameter_list|)
block|{
name|u_int32_t
name|k1
decl_stmt|;
comment|/* reset codec */
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CTL
argument_list|,
literal|0x0020
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_CODEC_CTL
argument_list|,
literal|0x0000
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_PCM_VOLUME
argument_list|,
literal|0x0808
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_FM_VOLUME
argument_list|,
literal|0x0808
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_I2S_VOLUME
argument_list|,
literal|0x0808
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
literal|0x40
argument_list|,
literal|0x107f
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* enable legacy audio */
name|fm801_wr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fm801
argument_list|,
name|FM_RECORD_SOURCE
argument_list|,
literal|0x0000
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Unmask playback, record and mpu interrupts, mask the rest */
name|k1
operator|=
name|fm801_rd
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fm801
argument_list|,
name|FM_INTMASK
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_INTMASK
argument_list|,
operator|(
name|k1
operator|&
operator|~
operator|(
name|FM_INTMASK_PLAY
operator||
name|FM_INTMASK_REC
operator||
name|FM_INTMASK_MPU
operator|)
operator|)
operator||
name|FM_INTMASK_VOL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fm801_wr
argument_list|(
name|fm801
argument_list|,
name|FM_INTSTATUS
argument_list|,
name|FM_INTSTATUS_PLAY
operator||
name|FM_INTSTATUS_REC
operator||
name|FM_INTSTATUS_MPU
operator||
name|FM_INTSTATUS_VOL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
literal|"FM801 init Ok\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|struct
name|ac97_info
modifier|*
name|codec
init|=
literal|0
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fm801
operator|=
operator|(
expr|struct
name|fm801_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fm801
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|fm801
operator|->
name|type
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|mapped
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|PCI_MAXMAPS_0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fm801
operator|->
name|regid
operator|=
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fm801
operator|->
name|regtype
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|fm801
operator|->
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|regtype
argument_list|,
operator|&
name|fm801
operator|->
name|regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fm801
operator|->
name|reg
condition|)
block|{
name|fm801
operator|->
name|regtype
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|fm801
operator|->
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|regtype
argument_list|,
operator|&
name|fm801
operator|->
name|regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fm801
operator|->
name|reg
condition|)
block|{
name|fm801
operator|->
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|fm801
operator|->
name|reg
argument_list|)
expr_stmt|;
name|fm801
operator|->
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|fm801
operator|->
name|reg
argument_list|)
expr_stmt|;
name|mapped
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapped
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map register space\n"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
name|fm801
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|FM801_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|fm801_init
argument_list|(
name|fm801
argument_list|)
expr_stmt|;
name|codec
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|fm801
argument_list|,
name|fm801_ac97
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|codec
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|oops
goto|;
name|fm801
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|fm801
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|fm801
operator|->
name|irqid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fm801
operator|->
name|irq
operator|||
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|irq
argument_list|,
literal|0
argument_list|,
name|fm801_intr
argument_list|,
name|fm801
argument_list|,
operator|&
name|fm801
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|2
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|fm801
operator|->
name|bufsz
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|fm801
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
literal|64
argument_list|,
literal|"at %s 0x%lx irq %ld %s"
argument_list|,
operator|(
name|fm801
operator|->
name|regtype
operator|==
name|SYS_RES_IOPORT
operator|)
condition|?
literal|"io"
else|:
literal|"memory"
argument_list|,
name|rman_get_start
argument_list|(
name|fm801
operator|->
name|reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|fm801
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_fm801
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|FM801_MAXPLAYCH
value|1
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|fm801
argument_list|,
name|FM801_MAXPLAYCH
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|oops
goto|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|fm801ch_class
argument_list|,
name|fm801
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|fm801ch_class
argument_list|,
name|fm801
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|fm801
operator|->
name|radio
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"radio"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|oops
label|:
if|if
condition|(
name|codec
condition|)
name|ac97_destroy
argument_list|(
name|codec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm801
operator|->
name|reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|regtype
argument_list|,
name|fm801
operator|->
name|regid
argument_list|,
name|fm801
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm801
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|irq
argument_list|,
name|fm801
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm801
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|fm801
operator|->
name|irqid
argument_list|,
name|fm801
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm801
operator|->
name|parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|fm801
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm801
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|fm801_info
modifier|*
name|fm801
decl_stmt|;
name|DPRINT
argument_list|(
literal|"Forte Media FM801 detach\n"
argument_list|)
expr_stmt|;
name|fm801
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|r
operator|=
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
if|if
condition|(
name|fm801
operator|->
name|radio
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|radio
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|fm801
operator|->
name|radio
operator|=
name|NULL
expr_stmt|;
block|}
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|regtype
argument_list|,
name|fm801
operator|->
name|regid
argument_list|,
name|fm801
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|fm801
operator|->
name|irq
argument_list|,
name|fm801
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|fm801
operator|->
name|irqid
argument_list|,
name|fm801
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|fm801
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fm801
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|data
decl_stmt|;
name|int
name|id
decl_stmt|,
name|regtype
decl_stmt|,
name|regid
decl_stmt|,
name|result
decl_stmt|;
name|struct
name|resource
modifier|*
name|reg
decl_stmt|;
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|result
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|PCI_DEVICE_FORTEMEDIA1
condition|)
block|{
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|regid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|regtype
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|regtype
argument_list|,
operator|&
name|regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: quick check that device actually has sound capabilities. 		 * The problem is that some cards built around FM801 chip only 		 * have radio tuner onboard, but no sound capabilities. There 		 * is no "official" way to quickly check this, because all 		 * IDs are exactly the same. The only difference is 0x28 		 * device control register, described in FM801 specification 		 * as "SRC/Mixer Test Control/DFC Status", but without 		 * any more detailed explanation. According to specs, and 		 * available sample cards (SF256-PCP-R and SF256-PCS-R) its 		 * power-on value should be `0', while on AC97-less tuner 		 * card (SF64-PCR) it was 0x80. 		 */
if|if
condition|(
name|bus_space_read_1
argument_list|(
name|st
argument_list|,
name|sh
argument_list|,
literal|0x28
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Forte Media FM801 Audio Controller"
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|regtype
argument_list|,
name|regid
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* 	if ((id = pci_get_devid(dev)) == PCI_DEVICE_FORTEMEDIA2 ) { 		device_set_desc(dev, "Forte Media FM801 Joystick (Not Supported)"); 		return ENXIO; 	} */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|fm801_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|fm801_info
modifier|*
name|fm801
decl_stmt|;
name|fm801
operator|=
name|pcm_getdevinfo
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
operator|&&
operator|*
name|rid
operator|==
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
name|fm801
operator|->
name|reg
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fm801_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fm801_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fm801_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fm801_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|fm801_pci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|fm801_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|fm801_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fm801_driver
init|=
block|{
literal|"pcm"
block|,
name|fm801_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_fm801
argument_list|,
name|pci
argument_list|,
name|fm801_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_fm801
argument_list|,
name|snd_pcm
argument_list|,
name|PCM_MINVER
argument_list|,
name|PCM_PREFVER
argument_list|,
name|PCM_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_fm801
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

