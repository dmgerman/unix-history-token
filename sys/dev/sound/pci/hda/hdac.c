begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Stephane E. Potvin<sepotvin@videotron.ca>  * Copyright (c) 2006 Ariff Abdullah<ariff@FreeBSD.org>  * Copyright (c) 2008-2012 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Intel High Definition Audio (Controller) driver for FreeBSD.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hda_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac.h>
end_include

begin_define
define|#
directive|define
name|HDA_DRV_TEST_REV
value|"20120111_0001"
end_define

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|hdac_lock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxlock((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_unlock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxunlock((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_lockassert
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxassert((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_lockowned
parameter_list|(
name|sc
parameter_list|)
value|mtx_owned((sc)->lock)
end_define

begin_define
define|#
directive|define
name|HDAC_QUIRK_64BIT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDAC_QUIRK_DMAPOS
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDAC_QUIRK_MSI
value|(1<< 2)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|hdac_quirks_tab
index|[]
init|=
block|{
block|{
literal|"64bit"
block|,
name|HDAC_QUIRK_DMAPOS
block|}
block|,
block|{
literal|"dmapos"
block|,
name|HDAC_QUIRK_DMAPOS
block|}
block|,
block|{
literal|"msi"
block|,
name|HDAC_QUIRK_MSI
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_QUIRKS_TAB_LEN
define|\
value|(sizeof(hdac_quirks_tab) / sizeof(hdac_quirks_tab[0]))
end_define

begin_define
define|#
directive|define
name|HDA_BDL_MIN
value|2
end_define

begin_define
define|#
directive|define
name|HDA_BDL_MAX
value|256
end_define

begin_define
define|#
directive|define
name|HDA_BDL_DEFAULT
value|HDA_BDL_MIN
end_define

begin_define
define|#
directive|define
name|HDA_BLK_MIN
value|HDA_DMA_ALIGNMENT
end_define

begin_define
define|#
directive|define
name|HDA_BLK_ALIGN
value|(~(HDA_BLK_MIN - 1))
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_MIN
value|4096
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_MAX
value|65536
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_DEFAULT
value|16384
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HDAC
argument_list|,
literal|"hdac"
argument_list|,
literal|"HDA Controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|char
name|quirks_on
decl_stmt|;
name|char
name|quirks_off
decl_stmt|;
block|}
name|hdac_devices
index|[]
init|=
block|{
block|{
name|HDA_INTEL_CPT
block|,
literal|"Intel Cougar Point"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_PATSBURG
block|,
literal|"Intel Patsburg"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_PPT1
block|,
literal|"Intel Panther Point"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_82801F
block|,
literal|"Intel 82801F"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_63XXESB
block|,
literal|"Intel 631x/632xESB"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_82801G
block|,
literal|"Intel 82801G"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_82801H
block|,
literal|"Intel 82801H"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_82801I
block|,
literal|"Intel 82801I"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_82801JI
block|,
literal|"Intel 82801JI"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_82801JD
block|,
literal|"Intel 82801JD"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_PCH
block|,
literal|"Intel 5 Series/3400 Series"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_PCH2
block|,
literal|"Intel 5 Series/3400 Series"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_INTEL_SCH
block|,
literal|"Intel SCH"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP51
block|,
literal|"NVIDIA MCP51"
block|,
literal|0
block|,
name|HDAC_QUIRK_MSI
block|}
block|,
block|{
name|HDA_NVIDIA_MCP55
block|,
literal|"NVIDIA MCP55"
block|,
literal|0
block|,
name|HDAC_QUIRK_MSI
block|}
block|,
block|{
name|HDA_NVIDIA_MCP61_1
block|,
literal|"NVIDIA MCP61"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP61_2
block|,
literal|"NVIDIA MCP61"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP65_1
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP65_2
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP67_1
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP67_2
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP73_1
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP73_2
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_1
block|,
literal|"NVIDIA MCP78"
block|,
literal|0
block|,
name|HDAC_QUIRK_64BIT
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_2
block|,
literal|"NVIDIA MCP78"
block|,
literal|0
block|,
name|HDAC_QUIRK_64BIT
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_3
block|,
literal|"NVIDIA MCP78"
block|,
literal|0
block|,
name|HDAC_QUIRK_64BIT
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_4
block|,
literal|"NVIDIA MCP78"
block|,
literal|0
block|,
name|HDAC_QUIRK_64BIT
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_1
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_2
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_3
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_4
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP89_1
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP89_2
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP89_3
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_MCP89_4
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_SB450
block|,
literal|"ATI SB450"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_SB600
block|,
literal|"ATI SB600"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RS600
block|,
literal|"ATI RS600"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RS690
block|,
literal|"ATI RS690"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RS780
block|,
literal|"ATI RS780"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_R600
block|,
literal|"ATI R600"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV610
block|,
literal|"ATI RV610"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV620
block|,
literal|"ATI RV620"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV630
block|,
literal|"ATI RV630"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV635
block|,
literal|"ATI RV635"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV710
block|,
literal|"ATI RV710"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV730
block|,
literal|"ATI RV730"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV740
block|,
literal|"ATI RV740"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_RV770
block|,
literal|"ATI RV770"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_RDC_M3010
block|,
literal|"RDC M3010"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_VIA_VT82XX
block|,
literal|"VIA VT8251/8237A"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_SIS_966
block|,
literal|"SiS 966"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ULI_M5461
block|,
literal|"ULI M5461"
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Unknown */
block|{
name|HDA_INTEL_ALL
block|,
literal|"Intel (Unknown)"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_NVIDIA_ALL
block|,
literal|"NVIDIA (Unknown)"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ATI_ALL
block|,
literal|"ATI (Unknown)"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_VIA_ALL
block|,
literal|"VIA (Unknown)"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_SIS_ALL
block|,
literal|"SiS (Unknown)"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|HDA_ULI_ALL
block|,
literal|"ULI (Unknown)"
block|,
literal|0
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_DEVICES_LEN
value|(sizeof(hdac_devices) / sizeof(hdac_devices[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint8_t
name|reg
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|;
name|uint8_t
name|enable
decl_stmt|;
block|}
name|hdac_pcie_snoop
index|[]
init|=
block|{
block|{
name|INTEL_VENDORID
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
name|ATI_VENDORID
block|,
literal|0x42
block|,
literal|0xf8
block|,
literal|0x02
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
literal|0x4e
block|,
literal|0xf0
block|,
literal|0x0f
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_PCIESNOOP_LEN
define|\
value|(sizeof(hdac_pcie_snoop) / sizeof(hdac_pcie_snoop[0]))
end_define

begin_comment
comment|/****************************************************************************  * Function prototypes  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|hdac_intr_handler
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_reset
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_get_capabilities
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dma_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_dma_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_dma
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dma_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_dma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_mem_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_mem_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_irq_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_irq_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_corb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_rirb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_corb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_rirb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_attach2
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|hdac_send_command
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_rirb_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_unsolq_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|hdac_command
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
define|\
value|hdac_send_command(a1, a3, a2)
end_define

begin_comment
comment|/* This function surely going to make its way into upper level someday. */
end_comment

begin_function
specifier|static
name|void
name|hdac_config_fetch
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|on
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|,
name|inv
decl_stmt|;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"config"
argument_list|,
operator|&
name|res
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|res
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|res
argument_list|)
operator|>
literal|0
operator|)
condition|)
return|return;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Config options:"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|res
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|res
index|[
name|i
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|res
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
return|return;
block|}
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|res
index|[
name|j
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|res
index|[
name|j
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|res
index|[
name|j
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|j
operator|++
expr_stmt|;
name|len
operator|=
name|j
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|res
operator|+
name|i
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|inv
operator|=
literal|2
expr_stmt|;
else|else
name|inv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|len
operator|>
name|inv
operator|&&
name|k
operator|<
name|HDAC_QUIRKS_TAB_LEN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
operator|+
name|i
operator|+
name|inv
argument_list|,
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|,
name|len
operator|-
name|inv
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|len
operator|-
name|inv
operator|!=
name|strlen
argument_list|(
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|)
condition|)
continue|continue;
name|HDA_BOOTVERBOSE
argument_list|(
argument|printf(
literal|" %s%s"
argument|, (inv !=
literal|0
argument|) ?
literal|"no"
argument|:
literal|""
argument|, 				    hdac_quirks_tab[k].key);
argument_list|)
empty_stmt|;
if|if
condition|(
name|inv
operator|==
literal|0
condition|)
block|{
operator|*
name|on
operator||=
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|on
operator|&=
operator|~
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inv
operator|!=
literal|0
condition|)
block|{
operator|*
name|off
operator||=
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|off
operator|&=
operator|~
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
block|}
break|break;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_intr_handler(void *)  *  * Interrupt handler. Processes interrupts received from the hdac.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_intr_handler
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|intsts
decl_stmt|;
name|uint8_t
name|rirbsts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|context
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do we have anything to do? */
name|intsts
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intsts
operator|&
name|HDAC_INTSTS_GIS
operator|)
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Was this a controller interrupt? */
if|if
condition|(
name|intsts
operator|&
name|HDAC_INTSTS_CIS
condition|)
block|{
name|rirbsts
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|)
expr_stmt|;
comment|/* Get as many responses that we can */
while|while
condition|(
name|rirbsts
operator|&
name|HDAC_RIRBSTS_RINTFL
condition|)
block|{
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|,
name|HDAC_RIRBSTS_RINTFL
argument_list|)
expr_stmt|;
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rirbsts
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|unsolq_rp
operator|!=
name|sc
operator|->
name|unsolq_wp
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intsts
operator|&
name|HDAC_INTSTS_SIS_MASK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ss
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|intsts
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
operator|(
name|i
operator|<<
literal|5
operator|)
operator|+
name|HDAC_SDSTS
argument_list|,
name|HDAC_SDSTS_DESE
operator||
name|HDAC_SDSTS_FIFOE
operator||
name|HDAC_SDSTS_BCIS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|=
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|dev
operator|)
operator|!=
name|NULL
condition|)
block|{
name|HDAC_STREAM_INTR
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|dir
argument_list|,
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|,
name|intsts
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_callout
argument_list|,
name|sc
operator|->
name|poll_ival
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_reset(hdac_softc *, int)  *  * Reset the hdac to a quiescent and known state.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_reset
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|wakeup
parameter_list|)
block|{
name|uint32_t
name|gctl
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Stop all Streams DMA engine 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_iss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_ISDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_oss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_OSDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_bss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_BSDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Stop Control DMA engines. 	 */
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset DMA position buffer. 	 */
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBLBASE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBUBASE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the controller. The reset must remain asserted for 	 * a minimum of 100us. 	 */
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|gctl
operator|&
operator|~
name|HDAC_GCTL_CRST
argument_list|)
expr_stmt|;
name|count
operator|=
literal|10000
expr_stmt|;
do|do
block|{
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
if|if
condition|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to put hdac in reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* If wakeup is not requested - leave the controller in reset state. */
if|if
condition|(
operator|!
name|wakeup
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|gctl
operator||
name|HDAC_GCTL_CRST
argument_list|)
expr_stmt|;
name|count
operator|=
literal|10000
expr_stmt|;
do|do
block|{
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Device stuck in reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Wait for codecs to finish their own reset sequence. The delay here 	 * should be of 250us but for some reasons, on it's not enough on my 	 * computer. Let's use twice as much as necessary to make sure that 	 * it's reset properly. 	 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_get_capabilities(struct hdac_softc *);  *  * Retreive the general capabilities of the hdac;  *	Number of Input Streams  *	Number of Output Streams  *	Number of bidirectional Streams  *	64bit ready  *	CORB and RIRB sizes  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_get_capabilities
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|gcap
decl_stmt|;
name|uint8_t
name|corbsize
decl_stmt|,
name|rirbsize
decl_stmt|;
name|gcap
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCAP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_iss
operator|=
name|HDAC_GCAP_ISS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_oss
operator|=
name|HDAC_GCAP_OSS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_bss
operator|=
name|HDAC_GCAP_BSS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_ss
operator|=
name|sc
operator|->
name|num_iss
operator|+
name|sc
operator|->
name|num_oss
operator|+
name|sc
operator|->
name|num_bss
expr_stmt|;
name|sc
operator|->
name|num_sdo
operator|=
name|HDAC_GCAP_NSDO
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|support_64bit
operator|=
operator|(
name|gcap
operator|&
name|HDAC_GCAP_64OK
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|quirks_on
operator|&
name|HDAC_QUIRK_64BIT
condition|)
name|sc
operator|->
name|support_64bit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|quirks_off
operator|&
name|HDAC_QUIRK_64BIT
condition|)
name|sc
operator|->
name|support_64bit
operator|=
literal|0
expr_stmt|;
name|corbsize
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_256
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_256
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_16
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_16
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_2
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_2
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Invalid corb size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|corbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rirbsize
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_256
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_256
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_16
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_16
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_2
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_2
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Invalid rirb size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rirbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Caps: OSS %d, ISS %d, BSS %d, "
literal|"NSDO %d%s, CORB %d, RIRB %d\n"
argument|, 		    sc->num_oss, sc->num_iss, sc->num_bss,
literal|1
argument|<< sc->num_sdo, 		    sc->support_64bit ?
literal|", 64bit"
argument|:
literal|""
argument|, 		    sc->corb_size, sc->rirb_size);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_dma_cb  *  * This function is called by bus_dmamap_load when the mapping has been  * established. We just record the physical address of the mapping into  * the struct hdac_dma passed in.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_dma_cb
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|hdac_dma
modifier|*
name|dma
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dma
operator|=
operator|(
expr|struct
name|hdac_dma
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|dma
operator|->
name|dma_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_dma_alloc  *  * This function allocate and setup a dma region (struct hdac_dma).  * It must be freed by a corresponding hdac_dma_free.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_dma_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_dma
modifier|*
name|dma
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
name|bus_size_t
name|roundsz
decl_stmt|;
name|int
name|result
decl_stmt|;
name|roundsz
operator|=
name|roundup2
argument_list|(
name|size
argument_list|,
name|HDA_DMA_ALIGNMENT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create a DMA tag 	 */
name|result
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|HDA_DMA_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
operator|(
name|sc
operator|->
name|support_64bit
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
comment|/* filtfunc */
name|NULL
argument_list|,
comment|/* fistfuncarg */
name|roundsz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|roundsz
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_dma_alloc_fail
goto|;
block|}
comment|/* 	 * Allocate DMA memory 	 */
name|result
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
operator|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|HDAC_F_DMA_NOCACHE
operator|)
condition|?
name|BUS_DMA_NOCACHE
else|:
literal|0
operator|)
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_alloc failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_dma_alloc_fail
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|roundsz
expr_stmt|;
comment|/* 	 * Map the memory 	 */
name|result
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|roundsz
argument_list|,
name|hdac_dma_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dma
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|||
name|dma
operator|->
name|dma_paddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|ENOMEM
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_load failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_dma_alloc_fail
goto|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: size=%ju -> roundsz=%ju\n"
argument|, 		    __func__, (uintmax_t)size, (uintmax_t)roundsz);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_dma_alloc_fail
label|:
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
name|dma
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_dma_free(struct hdac_softc *, struct hdac_dma *)  *  * Free a struct dhac_dma that has been previously allocated via the  * hdac_dma_alloc function.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_dma_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_dma
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|dma_map
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Flush caches */
block|bus_dmamap_sync(dma->dma_tag, dma->dma_map, 		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
endif|#
directive|endif
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|dma_vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_vaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|dma_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|dma
operator|->
name|dma_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_mem_alloc(struct hdac_softc *)  *  * Allocate all the bus resources necessary to speak with the physical  * controller.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_mem_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_mem
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|&
name|sc
operator|->
name|mem
expr_stmt|;
name|mem
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|mem
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate memory resource\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mem
operator|->
name|mem_tag
operator|=
name|rman_get_bustag
argument_list|(
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_mem_free(struct hdac_softc *)  *  * Free up resources previously allocated by hdac_mem_alloc.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_mem_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_mem
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|&
name|sc
operator|->
name|mem
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|mem
operator|->
name|mem_rid
argument_list|,
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_res
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_irq_alloc(struct hdac_softc *)  *  * Allocate and setup the resources necessary for interrupt handling.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_irq_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|result
decl_stmt|;
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
expr_stmt|;
name|irq
operator|->
name|irq_rid
operator|=
literal|0x0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|quirks_off
operator|&
name|HDAC_QUIRK_MSI
operator|)
operator|==
literal|0
operator|&&
operator|(
name|result
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|result
argument_list|)
operator|==
literal|0
condition|)
name|irq
operator|->
name|irq_rid
operator|=
literal|0x1
expr_stmt|;
name|irq
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate irq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|hdac_irq_alloc_fail
goto|;
block|}
name|result
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_AV
argument_list|,
name|NULL
argument_list|,
name|hdac_intr_handler
argument_list|,
name|sc
argument_list|,
operator|&
name|irq
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to setup interrupt handler (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_irq_alloc_fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_irq_alloc_fail
label|:
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_irq_free(struct hdac_softc *)  *  * Free up resources previously allocated by hdac_irq_alloc.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_irq_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_irq
modifier|*
name|irq
decl_stmt|;
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|!=
name|NULL
operator|&&
name|irq
operator|->
name|irq_handle
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|,
name|irq
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|irq_rid
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_rid
operator|==
literal|0x1
condition|)
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|irq
operator|->
name|irq_handle
operator|=
name|NULL
expr_stmt|;
name|irq
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
name|irq
operator|->
name|irq_rid
operator|=
literal|0x0
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_corb_init(struct hdac_softc *)  *  * Initialize the corb registers for operations but do not start it up yet.  * The CORB engine must not be running when this function is called.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_corb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|corbsize
decl_stmt|;
name|uint64_t
name|corbpaddr
decl_stmt|;
comment|/* Setup the CORB size. */
switch|switch
condition|(
name|sc
operator|->
name|corb_size
condition|)
block|{
case|case
literal|256
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_256
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CORB size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|corb_size
argument_list|)
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBSIZE
argument_list|,
name|corbsize
argument_list|)
expr_stmt|;
comment|/* Setup the CORB Address in the hdac */
name|corbpaddr
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|corb_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBLBASE
argument_list|,
operator|(
name|uint32_t
operator|)
name|corbpaddr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|corbpaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the WP and RP */
name|sc
operator|->
name|corb_wp
operator|=
literal|0
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBWP
argument_list|,
name|sc
operator|->
name|corb_wp
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|,
name|HDAC_CORBRP_CORBRPRST
argument_list|)
expr_stmt|;
comment|/* 	 * The HDA specification indicates that the CORBRPRST bit will always 	 * read as zero. Unfortunately, it seems that at least the 82801G 	 * doesn't reset the bit to zero, which stalls the corb engine. 	 * manually reset the bit to zero before continuing. 	 */
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Enable CORB error reporting */
if|#
directive|if
literal|0
block|HDAC_WRITE_1(&sc->mem, HDAC_CORBCTL, HDAC_CORBCTL_CMEIE);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_rirb_init(struct hdac_softc *)  *  * Initialize the rirb registers for operations but do not start it up yet.  * The RIRB engine must not be running when this function is called.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_rirb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|rirbsize
decl_stmt|;
name|uint64_t
name|rirbpaddr
decl_stmt|;
comment|/* Setup the RIRB size. */
switch|switch
condition|(
name|sc
operator|->
name|rirb_size
condition|)
block|{
case|case
literal|256
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_256
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid RIRB size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rirb_size
argument_list|)
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSIZE
argument_list|,
name|rirbsize
argument_list|)
expr_stmt|;
comment|/* Setup the RIRB Address in the hdac */
name|rirbpaddr
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBLBASE
argument_list|,
operator|(
name|uint32_t
operator|)
name|rirbpaddr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|rirbpaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the WP and RP */
name|sc
operator|->
name|rirb_rp
operator|=
literal|0
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBWP
argument_list|,
name|HDAC_RIRBWP_RIRBWPRST
argument_list|)
expr_stmt|;
comment|/* Setup the interrupt threshold */
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RINTCNT
argument_list|,
name|sc
operator|->
name|rirb_size
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable Overrun and response received reporting */
if|#
directive|if
literal|0
block|HDAC_WRITE_1(&sc->mem, HDAC_RIRBCTL, 	    HDAC_RIRBCTL_RIRBOIC | HDAC_RIRBCTL_RINTCTL);
else|#
directive|else
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|HDAC_RIRBCTL_RINTCTL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * Make sure that the Host CPU cache doesn't contain any dirty 	 * cache lines that falls in the rirb. If I understood correctly, it 	 * should be sufficient to do this only once as the rirb is purely 	 * read-only from now on. 	 */
block|bus_dmamap_sync(sc->rirb_dma.dma_tag, sc->rirb_dma.dma_map, 	    BUS_DMASYNC_PREREAD);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_corb_start(hdac_softc *)  *  * Startup the corb DMA engine  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_corb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|corbctl
decl_stmt|;
name|corbctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|)
expr_stmt|;
name|corbctl
operator||=
name|HDAC_CORBCTL_CORBRUN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|,
name|corbctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_rirb_start(hdac_softc *)  *  * Startup the rirb DMA engine  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_rirb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|rirbctl
decl_stmt|;
name|rirbctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|)
expr_stmt|;
name|rirbctl
operator||=
name|HDAC_RIRBCTL_RIRBDMAEN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|rirbctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_rirb_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|,
modifier|*
name|rirb
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|resp
decl_stmt|;
name|uint8_t
name|rirbwp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirbwp
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBWP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_dmamap_sync(sc->rirb_dma.dma_tag, sc->rirb_dma.dma_map, 	    BUS_DMASYNC_POSTREAD);
endif|#
directive|endif
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rirb_rp
operator|!=
name|rirbwp
condition|)
block|{
name|sc
operator|->
name|rirb_rp
operator|++
expr_stmt|;
name|sc
operator|->
name|rirb_rp
operator|%=
name|sc
operator|->
name|rirb_size
expr_stmt|;
name|rirb
operator|=
operator|&
name|rirb_base
index|[
name|sc
operator|->
name|rirb_rp
index|]
expr_stmt|;
name|cad
operator|=
name|HDAC_RIRB_RESPONSE_EX_SDATA_IN
argument_list|(
name|rirb
operator|->
name|response_ex
argument_list|)
expr_stmt|;
name|resp
operator|=
name|rirb
operator|->
name|response
expr_stmt|;
if|if
condition|(
name|rirb
operator|->
name|response_ex
operator|&
name|HDAC_RIRB_RESPONSE_EX_UNSOLICITED
condition|)
block|{
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_wp
operator|++
index|]
operator|=
name|resp
expr_stmt|;
name|sc
operator|->
name|unsolq_wp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_wp
operator|++
index|]
operator|=
name|cad
expr_stmt|;
name|sc
operator|->
name|unsolq_wp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|pending
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unexpected unsolicited "
literal|"response from address %d: %08x\n"
argument_list|,
name|cad
argument_list|,
name|resp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|response
operator|=
name|resp
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|pending
operator|--
expr_stmt|;
block|}
name|ret
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_unsolq_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|resp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|unsolq_st
operator|==
name|HDAC_UNSOLQ_READY
condition|)
block|{
name|sc
operator|->
name|unsolq_st
operator|=
name|HDAC_UNSOLQ_BUSY
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|unsolq_rp
operator|!=
name|sc
operator|->
name|unsolq_wp
condition|)
block|{
name|resp
operator|=
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_rp
operator|++
index|]
expr_stmt|;
name|sc
operator|->
name|unsolq_rp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
name|cad
operator|=
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_rp
operator|++
index|]
expr_stmt|;
name|sc
operator|->
name|unsolq_rp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|dev
operator|)
operator|!=
name|NULL
condition|)
name|HDAC_UNSOL_INTR
argument_list|(
name|child
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|unsolq_st
operator|=
name|HDAC_UNSOLQ_READY
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * uint32_t hdac_command_sendone_internal  *  * Wrapper function that sends only one command to a given codec  ****************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|hdac_send_command
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|nid_t
name|cad
parameter_list|,
name|uint32_t
name|verb
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|uint32_t
modifier|*
name|corb
decl_stmt|;
if|if
condition|(
operator|!
name|hdac_lockowned
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING!!!! mtx not owned!!!!\n"
argument_list|)
expr_stmt|;
name|verb
operator|&=
operator|~
name|HDA_CMD_CAD_MASK
expr_stmt|;
name|verb
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|cad
operator|)
operator|<<
name|HDA_CMD_CAD_SHIFT
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|response
operator|=
name|HDA_INVALID
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|pending
operator|++
expr_stmt|;
name|sc
operator|->
name|corb_wp
operator|++
expr_stmt|;
name|sc
operator|->
name|corb_wp
operator|%=
name|sc
operator|->
name|corb_size
expr_stmt|;
name|corb
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|corb_dma
operator|.
name|dma_vaddr
expr_stmt|;
if|#
directive|if
literal|0
block|bus_dmamap_sync(sc->corb_dma.dma_tag, 	    sc->corb_dma.dma_map, BUS_DMASYNC_PREWRITE);
endif|#
directive|endif
name|corb
index|[
name|sc
operator|->
name|corb_wp
index|]
operator|=
name|verb
expr_stmt|;
if|#
directive|if
literal|0
block|bus_dmamap_sync(sc->corb_dma.dma_tag, 	    sc->corb_dma.dma_map, BUS_DMASYNC_POSTWRITE);
endif|#
directive|endif
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBWP
argument_list|,
name|sc
operator|->
name|corb_wp
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|10000
expr_stmt|;
do|do
block|{
if|if
condition|(
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|pending
operator|!=
literal|0
operator|&&
operator|--
name|timeout
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|pending
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Command timeout on address %d\n"
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|pending
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|unsolq_rp
operator|!=
name|sc
operator|->
name|unsolq_wp
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|response
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * Device Methods  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  * int hdac_probe(device_t)  *  * Probe for the presence of an hdac. If none is found, check for a generic  * match using the subclass of the device.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|class
decl_stmt|,
name|subclass
decl_stmt|;
name|char
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|model
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|model
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ENXIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_DEVICES_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
operator|==
name|model
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|hdac_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|model
argument_list|)
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|hdac_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ENXIO
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
literal|"Generic"
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ENXIO
condition|)
block|{
name|strlcat
argument_list|(
name|desc
argument_list|,
literal|" HDA Controller"
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_unsolq_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|context
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_attach(device_t)  *  * Attach the device into the kernel. Interrupts usually won't be enabled  * when this function is called. Setup everything that doesn't require  * interrupts and defer probing of codecs until interrupts are enabled.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|devid
init|=
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|class
decl_stmt|,
name|subclass
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"HDA Driver Revision: %s\n"
argument|, 		    HDA_DRV_TEST_REV);
argument_list|)
empty_stmt|;
name|model
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|model
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_DEVICES_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
operator|==
name|model
condition|)
block|{
name|devid
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|model
argument_list|)
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|devid
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"HDA driver mutex"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|,
literal|0
argument_list|,
name|hdac_unsolq_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|poll_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|.
name|dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devid
operator|>=
literal|0
condition|)
block|{
name|sc
operator|->
name|quirks_on
operator|=
name|hdac_devices
index|[
name|devid
index|]
operator|.
name|quirks_on
expr_stmt|;
name|sc
operator|->
name|quirks_off
operator|=
name|hdac_devices
index|[
name|devid
index|]
operator|.
name|quirks_off
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|quirks_on
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|quirks_off
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"msi"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sc
operator|->
name|quirks_off
operator||=
name|HDAC_QUIRK_MSI
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|quirks_on
operator||=
name|HDAC_QUIRK_MSI
expr_stmt|;
name|sc
operator|->
name|quirks_off
operator||=
operator|~
name|HDAC_QUIRK_MSI
expr_stmt|;
block|}
block|}
name|hdac_config_fetch
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|quirks_on
argument_list|,
operator|&
name|sc
operator|->
name|quirks_off
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Config options: on=0x%08x off=0x%08x\n"
argument|, 		    sc->quirks_on, sc->quirks_off);
argument_list|)
empty_stmt|;
name|sc
operator|->
name|poll_ival
operator|=
name|hz
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"polling"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|INTEL_VENDORID
condition|)
block|{
comment|/* TCSEL -> TC0 */
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x44
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x44
argument_list|,
name|v
operator|&
literal|0xf8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"TCSEL: 0x%02d -> 0x%02d\n"
argument|, v, 			    pci_read_config(dev,
literal|0x44
argument|,
literal|1
argument|));
argument_list|)
empty_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|sc
operator|->
name|flags
operator||=
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"snoop"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Try to enable PCIe snoop to avoid messing around with 		 * uncacheable DMA attribute. Since PCIe snoop register 		 * config is pretty much vendor specific, there are no 		 * general solutions on how to enable it, forcing us (even 		 * Microsoft) to enable uncacheable or write combined DMA 		 * by default. 		 * 		 * http://msdn2.microsoft.com/en-us/library/ms790324.aspx 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_PCIESNOOP_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|vendor
condition|)
continue|continue;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
if|if
condition|(
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0x00
condition|)
break|break;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
operator|)
operator|==
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
condition|)
break|break;
name|v
operator|&=
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|mask
expr_stmt|;
name|v
operator||=
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
operator|)
operator|!=
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"WARNING: Failed to enable PCIe "
literal|"snoop!\n"
argument|);
argument_list|)
empty_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|sc
operator|->
name|flags
operator||=
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
block|}
endif|#
directive|endif
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"DMA Coherency: %s / vendor=0x%04x\n"
argument|, 		    (sc->flags& HDAC_F_DMA_NOCACHE) ?
literal|"Uncacheable"
argument|:
literal|"PCIe snoop"
argument|, vendor);
argument_list|)
empty_stmt|;
comment|/* Allocate resources */
name|result
operator|=
name|hdac_mem_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|result
operator|=
name|hdac_irq_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Get Capabilities */
name|result
operator|=
name|hdac_get_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Allocate CORB, RIRB, POS and BDLs dma memory */
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|,
name|sc
operator|->
name|corb_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|,
name|sc
operator|->
name|rirb_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_rirb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|sc
operator|->
name|streams
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_stream
argument_list|)
operator|*
name|sc
operator|->
name|num_ss
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ss
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|bdl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_bdle
argument_list|)
operator|*
name|HDA_BDL_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|quirks_on
operator|&
name|HDAC_QUIRK_DMAPOS
condition|)
block|{
if|if
condition|(
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pos_dma
argument_list|,
operator|(
name|sc
operator|->
name|num_ss
operator|)
operator|*
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Failed to "
literal|"allocate DMA pos buffer "
literal|"(non-fatal)\n"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|uint64_t
name|addr
init|=
name|sc
operator|->
name|pos_dma
operator|.
name|dma_paddr
decl_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBUBASE
argument_list|,
name|addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBLBASE
argument_list|,
operator|(
name|addr
operator|&
name|HDAC_DPLBASE_DPLBASE_MASK
operator|)
operator||
name|HDAC_DPLBASE_DPLBASE_DMAPBE
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|HDA_DMA_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
operator|(
name|sc
operator|->
name|support_64bit
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
comment|/* filtfunc */
name|NULL
argument_list|,
comment|/* fistfuncarg */
name|HDA_BUFSZ_MAX
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|HDA_BUFSZ_MAX
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|chan_dmat
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_attach_fail
goto|;
block|}
comment|/* Quiesce everything */
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reset controller...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the CORB and RIRB */
name|hdac_corb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_rirb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Defer remaining of initialization until interrupts are enabled */
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|hdac_attach2
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
if|if
condition|(
name|cold
operator|==
literal|0
operator|||
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|NULL
expr_stmt|;
name|hdac_attach2
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_attach_fail
label|:
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ss
condition|;
name|i
operator|++
control|)
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|bdl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|streams
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|)
expr_stmt|;
name|hdac_mem_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hdac_pindump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|devcount
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX: Temporary. For debugging. */
if|if
condition|(
name|val
operator|==
literal|100
condition|)
block|{
name|hdac_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|101
condition|)
block|{
name|hdac_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
name|HDAC_PINDUMP
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_data_rate
parameter_list|(
name|uint16_t
name|fmt
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|bits
index|[
literal|8
index|]
init|=
block|{
literal|8
block|,
literal|16
block|,
literal|20
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|}
decl_stmt|;
name|int
name|rate
decl_stmt|;
if|if
condition|(
name|fmt
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|rate
operator|=
literal|44100
expr_stmt|;
else|else
name|rate
operator|=
literal|48000
expr_stmt|;
name|rate
operator|*=
operator|(
operator|(
name|fmt
operator|>>
literal|11
operator|)
operator|&
literal|0x07
operator|)
operator|+
literal|1
expr_stmt|;
name|rate
operator|/=
operator|(
operator|(
name|fmt
operator|>>
literal|8
operator|)
operator|&
literal|0x07
operator|)
operator|+
literal|1
expr_stmt|;
name|rate
operator|*=
operator|(
operator|(
name|bits
index|[
operator|(
name|fmt
operator|>>
literal|4
operator|)
operator|&
literal|0x03
index|]
operator|)
operator|*
operator|(
operator|(
name|fmt
operator|&
literal|0x0f
operator|)
operator|+
literal|1
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
return|return
operator|(
name|rate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_poll_reinit
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pollticks
decl_stmt|,
name|min
init|=
literal|1000000
decl_stmt|;
name|struct
name|hdac_stream
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|unsol_registered
operator|>
literal|0
condition|)
name|min
operator|=
name|hz
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ss
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|&
name|sc
operator|->
name|streams
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|running
operator|==
literal|0
condition|)
continue|continue;
name|pollticks
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|hz
operator|*
name|s
operator|->
name|blksz
operator|)
operator|/
name|hdac_data_rate
argument_list|(
name|s
operator|->
name|format
argument_list|)
expr_stmt|;
name|pollticks
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|pollticks
operator|>
name|hz
condition|)
name|pollticks
operator|=
name|hz
expr_stmt|;
if|if
condition|(
name|pollticks
operator|<
literal|1
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"poll interval< 1 tick !\n"
argument|);
argument_list|)
empty_stmt|;
name|pollticks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>
name|pollticks
condition|)
name|min
operator|=
name|pollticks
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"poll interval %d -> %d ticks\n"
argument|, 		    sc->poll_ival, min);
argument_list|)
empty_stmt|;
name|sc
operator|->
name|poll_ival
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|min
operator|==
literal|1000000
condition|)
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_callout
argument_list|)
expr_stmt|;
else|else
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_callout
argument_list|,
literal|1
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hdac_polling
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|sc
operator|->
name|polling
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|sc
operator|->
name|polling
condition|)
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_callout
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_callout
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_INTCTL_GIE
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_INTCTL_GIE
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_attach2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|uint32_t
name|vendorid
decl_stmt|,
name|revisionid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|statests
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Remove ourselves from the config hooks */
if|if
condition|(
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|!=
name|NULL
condition|)
block|{
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|NULL
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Starting CORB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_corb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Starting RIRB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_rirb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Enabling controller interrupt...\n"
argument|);
argument_list|)
empty_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
operator||
name|HDAC_GCTL_UNSOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|HDAC_INTCTL_CIE
operator||
name|HDAC_INTCTL_GIE
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Scanning HDA codecs ...\n"
argument|);
argument_list|)
empty_stmt|;
name|statests
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_STATESTS
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDAC_STATESTS_SDIWAKE
argument_list|(
name|statests
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Found CODEC at address %d\n"
argument|, i);
argument_list|)
empty_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vendorid
operator|=
name|hdac_send_command
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_VENDOR_ID
argument_list|)
argument_list|)
expr_stmt|;
name|revisionid
operator|=
name|hdac_send_command
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_REVISION_ID
argument_list|)
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendorid
operator|==
name|HDA_INVALID
operator|&&
name|revisionid
operator|==
name|HDA_INVALID
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CODEC is not responding!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|.
name|vendor_id
operator|=
name|HDA_PARAM_VENDOR_ID_VENDOR_ID
argument_list|(
name|vendorid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|.
name|device_id
operator|=
name|HDA_PARAM_VENDOR_ID_DEVICE_ID
argument_list|(
name|vendorid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|.
name|revision_id
operator|=
name|HDA_PARAM_REVISION_ID_REVISION_ID
argument_list|(
name|revisionid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|.
name|stepping_id
operator|=
name|HDA_PARAM_REVISION_ID_STEPPING_ID
argument_list|(
name|revisionid
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"hdacc"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to add CODEC device\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|.
name|dev
operator|=
name|child
expr_stmt|;
block|}
block|}
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pindump"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sysctl_hdac_pindump
argument_list|,
literal|"I"
argument_list|,
literal|"Dump pin states/data"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"polling"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sysctl_hdac_polling
argument_list|,
literal|"I"
argument_list|,
literal|"Enable polling mode"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_suspend(device_t)  *  * Suspend and power down HDA bus and codecs.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Suspend...\n"
argument|);
argument_list|)
empty_stmt|;
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reset controller...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Suspend done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_resume(device_t)  *  * Powerup and restore HDA bus and codecs state.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Resume...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Quiesce everything */
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reset controller...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the CORB and RIRB */
name|hdac_corb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_rirb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Starting CORB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_corb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Starting RIRB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_rirb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Enabling controller interrupt...\n"
argument|);
argument_list|)
empty_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
operator||
name|HDAC_GCTL_UNSOL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|HDAC_INTCTL_CIE
operator||
name|HDAC_INTCTL_GIE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Resume done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_detach(device_t)  *  * Detach and free up resources utilized by the hdac device.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|int
name|cad
decl_stmt|,
name|i
decl_stmt|,
name|devcount
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
name|cad
operator|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|devlist
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|dev
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_ss
condition|;
name|i
operator|++
control|)
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|bdl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|streams
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pos_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chan_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|chan_dmat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chan_dmat
operator|=
name|NULL
expr_stmt|;
block|}
name|hdac_mem_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_dma_tag_t
name|hdac_get_dma_tag
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|chan_dmat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at cad %d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"cad=%d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_child_pnpinfo_str_method
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|nid_t
name|cad
init|=
operator|(
name|uintptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"vendor=0x%04x device=0x%04x revision=0x%02x "
literal|"stepping=0x%02x"
argument_list|,
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|vendor_id
argument_list|,
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|device_id
argument_list|,
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|revision_id
argument_list|,
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|stepping_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|nid_t
name|cad
init|=
operator|(
name|uintptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|HDA_IVAR_CODEC_ID
case|:
operator|*
name|result
operator|=
name|cad
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_VENDOR_ID
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|vendor_id
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_DEVICE_ID
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|device_id
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_REVISION_ID
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|revision_id
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_STEPPING_ID
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|.
name|stepping_id
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_SUBVENDOR_ID
case|:
operator|*
name|result
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_SUBDEVICE_ID
case|:
operator|*
name|result
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDA_IVAR_DMA_NOCACHE
case|:
operator|*
name|result
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|HDAC_F_DMA_NOCACHE
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mtx
modifier|*
name|hdac_get_mtx
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|lock
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_codec_command
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|uint32_t
name|verb
parameter_list|)
block|{
return|return
operator|(
name|hdac_send_command
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|,
name|verb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_find_stream
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ss
decl_stmt|;
name|ss
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allocate ISS/BSS first. */
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_iss
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|streams
index|[
name|i
index|]
operator|.
name|stream
operator|==
name|stream
condition|)
block|{
name|ss
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_oss
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|streams
index|[
name|i
operator|+
name|sc
operator|->
name|num_iss
index|]
operator|.
name|stream
operator|==
name|stream
condition|)
block|{
name|ss
operator|=
name|i
operator|+
name|sc
operator|->
name|num_iss
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Fallback to BSS. */
if|if
condition|(
name|ss
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_bss
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|streams
index|[
name|i
operator|+
name|sc
operator|->
name|num_iss
operator|+
name|sc
operator|->
name|num_oss
index|]
operator|.
name|stream
operator|==
name|stream
condition|)
block|{
name|ss
operator|=
name|i
operator|+
name|sc
operator|->
name|num_iss
operator|+
name|sc
operator|->
name|num_oss
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|ss
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_stream_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|format
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|dmapos
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|stream
decl_stmt|,
name|ss
decl_stmt|;
comment|/* Look for empty stream. */
name|ss
operator|=
name|hdac_find_stream
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return if found nothing. */
if|if
condition|(
name|ss
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate stream number */
if|if
condition|(
name|ss
operator|>=
name|sc
operator|->
name|num_iss
operator|+
name|sc
operator|->
name|num_oss
condition|)
name|stream
operator|=
literal|15
operator|-
operator|(
name|ss
operator|-
name|sc
operator|->
name|num_iss
operator|+
name|sc
operator|->
name|num_oss
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ss
operator|>=
name|sc
operator|->
name|num_iss
condition|)
name|stream
operator|=
name|ss
operator|-
name|sc
operator|->
name|num_iss
operator|+
literal|1
expr_stmt|;
else|else
name|stream
operator|=
name|ss
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|dev
operator|=
name|child
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|format
operator|=
name|format
expr_stmt|;
if|if
condition|(
name|dmapos
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|pos_dma
operator|.
name|dma_vaddr
operator|!=
name|NULL
condition|)
operator|*
name|dmapos
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|pos_dma
operator|.
name|dma_vaddr
operator|+
name|ss
operator|*
literal|8
operator|)
expr_stmt|;
else|else
operator|*
name|dmapos
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|stream
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_free
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|ss
decl_stmt|;
name|ss
operator|=
name|hdac_find_stream
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ss
operator|>=
literal|0
argument_list|,
operator|(
literal|"Free for not allocated stream (%d/%d)\n"
operator|,
name|dir
operator|,
name|stream
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|stream
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|dev
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_stream_start
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|,
name|bus_addr_t
name|buf
parameter_list|,
name|int
name|blksz
parameter_list|,
name|int
name|blkcnt
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdac_bdle
modifier|*
name|bdle
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ss
decl_stmt|,
name|off
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ss
operator|=
name|hdac_find_stream
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ss
operator|>=
literal|0
argument_list|,
operator|(
literal|"Start for not allocated stream (%d/%d)\n"
operator|,
name|dir
operator|,
name|stream
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|uint64_t
operator|)
name|buf
expr_stmt|;
name|bdle
operator|=
operator|(
expr|struct
name|hdac_bdle
operator|*
operator|)
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|bdl
operator|.
name|dma_vaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blkcnt
condition|;
name|i
operator|++
operator|,
name|bdle
operator|++
control|)
block|{
name|bdle
operator|->
name|addrl
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|bdle
operator|->
name|addrh
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|bdle
operator|->
name|len
operator|=
name|blksz
expr_stmt|;
name|bdle
operator|->
name|ioc
operator|=
literal|1
expr_stmt|;
name|addr
operator|+=
name|blksz
expr_stmt|;
block|}
name|off
operator|=
name|ss
operator|<<
literal|5
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCBL
argument_list|,
name|blksz
operator|*
name|blkcnt
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDLVI
argument_list|,
name|blkcnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|bdl
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDBDPL
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDBDPU
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
name|ctl
operator||=
name|HDAC_SDCTL2_DIR
expr_stmt|;
else|else
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL2_DIR
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL2_STRM_MASK
expr_stmt|;
name|ctl
operator||=
name|stream
operator|<<
name|HDAC_SDCTL2_STRM_SHIFT
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL2
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDFMT
argument_list|,
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|format
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
literal|1
operator|<<
name|ss
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_IOCE
operator||
name|HDAC_SDCTL_FEIE
operator||
name|HDAC_SDCTL_DEIE
operator||
name|HDAC_SDCTL_RUN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|blksz
operator|=
name|blksz
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_stop
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|ss
decl_stmt|,
name|off
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ss
operator|=
name|hdac_find_stream
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ss
operator|>=
literal|0
argument_list|,
operator|(
literal|"Stop for not allocated stream (%d/%d)\n"
operator|,
name|dir
operator|,
name|stream
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|ss
operator|<<
literal|5
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|HDAC_SDCTL_IOCE
operator||
name|HDAC_SDCTL_FEIE
operator||
name|HDAC_SDCTL_DEIE
operator||
name|HDAC_SDCTL_RUN
operator|)
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ss
operator|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|streams
index|[
name|ss
index|]
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
init|=
literal|1000
decl_stmt|;
name|int
name|to
init|=
name|timeout
decl_stmt|;
name|int
name|ss
decl_stmt|,
name|off
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ss
operator|=
name|hdac_find_stream
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ss
operator|>=
literal|0
argument_list|,
operator|(
literal|"Reset for not allocated stream (%d/%d)\n"
operator|,
name|dir
operator|,
name|stream
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|ss
operator|<<
literal|5
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_SRST
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
do|do
block|{
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Reset setting timeout\n"
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL_SRST
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|to
operator|=
name|timeout
expr_stmt|;
do|do
block|{
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to
condition|)
do|;
if|if
condition|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Reset timeout!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_stream_getptr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|ss
decl_stmt|,
name|off
decl_stmt|;
name|ss
operator|=
name|hdac_find_stream
argument_list|(
name|sc
argument_list|,
name|dir
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ss
operator|>=
literal|0
argument_list|,
operator|(
literal|"Reset for not allocated stream (%d/%d)\n"
operator|,
name|dir
operator|,
name|stream
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|ss
operator|<<
literal|5
expr_stmt|;
return|return
operator|(
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|off
operator|+
name|HDAC_SDLPIB
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_unsol_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|unsol_registered
operator|++
expr_stmt|;
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_unsol_free
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|unsol_registered
operator|--
expr_stmt|;
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdac_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdac_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdac_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdac_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|hdac_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|hdac_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|hdac_get_dma_tag
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|hdac_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|hdac_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|hdac_child_pnpinfo_str_method
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|hdac_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_get_mtx
argument_list|,
name|hdac_get_mtx
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_codec_command
argument_list|,
name|hdac_codec_command
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_alloc
argument_list|,
name|hdac_stream_alloc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_free
argument_list|,
name|hdac_stream_free
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_start
argument_list|,
name|hdac_stream_start
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_stop
argument_list|,
name|hdac_stream_stop
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_reset
argument_list|,
name|hdac_stream_reset
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_getptr
argument_list|,
name|hdac_stream_getptr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_unsol_alloc
argument_list|,
name|hdac_unsol_alloc
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_unsol_free
argument_list|,
name|hdac_unsol_free
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdac_driver
init|=
block|{
literal|"hdac"
block|,
name|hdac_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hdac_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hda
argument_list|,
name|pci
argument_list|,
name|hdac_driver
argument_list|,
name|hdac_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

