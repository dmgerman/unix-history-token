begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Stephane E. Potvin<sepotvin@videotron.ca>  * Copyright (c) 2006 Ariff Abdullah<ariff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Intel High Definition Audio (Controller) driver for FreeBSD. Be advised  * that this driver still in its early stage, and possible of rewrite are  * pretty much guaranteed. There are supposedly several distinct parent/child  * busses to make this "perfect", but as for now and for the sake of  * simplicity, everything is gobble up within single source.  *  * List of subsys:  *     1) HDA Controller support  *     2) HDA Codecs support, which may include  *        - HDA  *        - Modem  *        - HDMI  *     3) Widget parser - the real magic of why this driver works on so  *        many hardwares with minimal vendor specific quirk. The original  *        parser was written using Ruby and can be found at  *        http://people.freebsd.org/~ariff/HDA/parser.rb . This crude  *        ruby parser take the verbose dmesg dump as its input. Refer to  *        http://www.microsoft.com/whdc/device/audio/default.mspx for various  *        interesting documents, especially UAA (Universal Audio Architecture).  *     4) Possible vendor specific support.  *        (snd_hda_intel, snd_hda_ati, etc..)  *  * Thanks to Ahmad Ubaidah Omar @ Defenxis Sdn. Bhd. for the  * Compaq V3000 with Conexant HDA.  *  *    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *    *                                                                 *  *    *        This driver is a collaborative effort made by:           *  *    *                                                                 *  *    *          Stephane E. Potvin<sepotvin@videotron.ca>             *  *    *               Andrea Bittau<a.bittau@cs.ucl.ac.uk>             *  *    *               Wesley Morgan<morganw@chemikals.org>             *  *    *              Daniel Eischen<deischen@FreeBSD.org>              *  *    *             Maxime Guillaud<bsd-ports@mguillaud.net>           *  *    *              Ariff Abdullah<ariff@FreeBSD.org>                 *  *    *                                                                 *  *    *   ....and various people from freebsd-multimedia@FreeBSD.org    *  *    *                                                                 *  *    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  */
end_comment

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hda_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_define
define|#
directive|define
name|HDA_DRV_TEST_REV
value|"20061210_0036"
end_define

begin_define
define|#
directive|define
name|HDA_WIDGET_PARSER_REV
value|1
end_define

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|HDA_DEBUG_ENABLED
end_undef

begin_define
define|#
directive|define
name|HDA_DEBUG_ENABLED
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HDA_DEBUG_ENABLED
end_ifdef

begin_define
define|#
directive|define
name|HDA_DEBUG
parameter_list|(
name|stmt
parameter_list|)
value|do {	\ 	stmt			\ } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HDA_DEBUG
parameter_list|(
name|stmt
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HDA_BOOTVERBOSE
parameter_list|(
name|stmt
parameter_list|)
value|do {	\ 	if (bootverbose) {			\ 		stmt				\ 	}					\ } while(0)
end_define

begin_if
if|#
directive|if
literal|1
end_if

begin_undef
undef|#
directive|undef
name|HDAC_INTR_EXTRA
end_undef

begin_define
define|#
directive|define
name|HDAC_INTR_EXTRA
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|hdac_lock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxlock((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_unlock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxunlock((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_lockassert
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxassert((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_lockowned
parameter_list|(
name|sc
parameter_list|)
value|mtx_owned((sc)->lock)
end_define

begin_define
define|#
directive|define
name|HDA_FLAG_MATCH
parameter_list|(
name|fl
parameter_list|,
name|v
parameter_list|)
value|(((fl)& (v)) == (v))
end_define

begin_define
define|#
directive|define
name|HDA_DEV_MATCH
parameter_list|(
name|fl
parameter_list|,
name|v
parameter_list|)
value|((fl) == (v) || \ 				(fl) == 0xffffffff || \ 				(((fl)& 0xffff0000) == 0xffff0000&& \ 				((fl)& 0x0000ffff) == ((v)& 0x0000ffff)) || \ 				(((fl)& 0x0000ffff) == 0x0000ffff&& \ 				((fl)& 0xffff0000) == ((v)& 0xffff0000)))
end_define

begin_define
define|#
directive|define
name|HDA_MATCH_ALL
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|HDAC_INVALID
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|HDA_MODEL_CONSTRUCT
parameter_list|(
name|vendor
parameter_list|,
name|model
parameter_list|)
define|\
value|(((uint32_t)(model)<< 16) | ((vendor##_VENDORID)& 0xffff))
end_define

begin_comment
comment|/* Controller models */
end_comment

begin_comment
comment|/* Intel */
end_comment

begin_define
define|#
directive|define
name|INTEL_VENDORID
value|0x8086
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801F
value|HDA_MODEL_CONSTRUCT(INTEL, 0x2668)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801G
value|HDA_MODEL_CONSTRUCT(INTEL, 0x27d8)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801H
value|HDA_MODEL_CONSTRUCT(INTEL, 0x284b)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_63XXESB
value|HDA_MODEL_CONSTRUCT(INTEL, 0x269a)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_ALL
value|HDA_MODEL_CONSTRUCT(INTEL, 0xffff)
end_define

begin_comment
comment|/* Nvidia */
end_comment

begin_define
define|#
directive|define
name|NVIDIA_VENDORID
value|0x10de
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP51
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x026c)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP55
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0371)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP61A
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x03e4)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP61B
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x03f0)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP65A
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x044a)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP65B
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x044b)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_ALL
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0xffff)
end_define

begin_comment
comment|/* ATI */
end_comment

begin_define
define|#
directive|define
name|ATI_VENDORID
value|0x1002
end_define

begin_define
define|#
directive|define
name|HDA_ATI_SB450
value|HDA_MODEL_CONSTRUCT(ATI, 0x437b)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_SB600
value|HDA_MODEL_CONSTRUCT(ATI, 0x4383)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_ALL
value|HDA_MODEL_CONSTRUCT(ATI, 0xffff)
end_define

begin_comment
comment|/* VIA */
end_comment

begin_define
define|#
directive|define
name|VIA_VENDORID
value|0x1106
end_define

begin_define
define|#
directive|define
name|HDA_VIA_VT82XX
value|HDA_MODEL_CONSTRUCT(VIA, 0x3288)
end_define

begin_define
define|#
directive|define
name|HDA_VIA_ALL
value|HDA_MODEL_CONSTRUCT(VIA, 0xffff)
end_define

begin_comment
comment|/* SiS */
end_comment

begin_define
define|#
directive|define
name|SIS_VENDORID
value|0x1039
end_define

begin_define
define|#
directive|define
name|HDA_SIS_966
value|HDA_MODEL_CONSTRUCT(SIS, 0x7502)
end_define

begin_define
define|#
directive|define
name|HDA_SIS_ALL
value|HDA_MODEL_CONSTRUCT(SIS, 0xffff)
end_define

begin_comment
comment|/* OEM/subvendors */
end_comment

begin_comment
comment|/* HP/Compaq */
end_comment

begin_define
define|#
directive|define
name|HP_VENDORID
value|0x103c
end_define

begin_define
define|#
directive|define
name|HP_V3000_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30b5)
end_define

begin_define
define|#
directive|define
name|HP_NX7400_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30a2)
end_define

begin_define
define|#
directive|define
name|HP_NX6310_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30aa)
end_define

begin_define
define|#
directive|define
name|HP_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0xffff)
end_define

begin_comment
comment|/* Dell */
end_comment

begin_define
define|#
directive|define
name|DELL_VENDORID
value|0x1028
end_define

begin_define
define|#
directive|define
name|DELL_D820_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01cc)
end_define

begin_define
define|#
directive|define
name|DELL_I1300_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01c9)
end_define

begin_define
define|#
directive|define
name|DELL_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0xffff)
end_define

begin_comment
comment|/* Clevo */
end_comment

begin_define
define|#
directive|define
name|CLEVO_VENDORID
value|0x1558
end_define

begin_define
define|#
directive|define
name|CLEVO_D900T_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(CLEVO, 0x0900)
end_define

begin_define
define|#
directive|define
name|CLEVO_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(CLEVO, 0xffff)
end_define

begin_comment
comment|/* Acer */
end_comment

begin_define
define|#
directive|define
name|ACER_VENDORID
value|0x1025
end_define

begin_define
define|#
directive|define
name|ACER_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0xffff)
end_define

begin_comment
comment|/* Asus */
end_comment

begin_define
define|#
directive|define
name|ASUS_VENDORID
value|0x1043
end_define

begin_define
define|#
directive|define
name|ASUS_M5200_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1993)
end_define

begin_define
define|#
directive|define
name|ASUS_U5F_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1263)
end_define

begin_define
define|#
directive|define
name|ASUS_A8JC_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1153)
end_define

begin_define
define|#
directive|define
name|ASUS_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0xffff)
end_define

begin_comment
comment|/* IBM / Lenovo */
end_comment

begin_define
define|#
directive|define
name|IBM_VENDORID
value|0x1014
end_define

begin_define
define|#
directive|define
name|IBM_M52_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(IBM, 0x02f6)
end_define

begin_define
define|#
directive|define
name|IBM_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(IBM, 0xffff)
end_define

begin_comment
comment|/* Lenovo */
end_comment

begin_define
define|#
directive|define
name|LENOVO_VENDORID
value|0x17aa
end_define

begin_define
define|#
directive|define
name|LENOVO_3KN100_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LENOVO, 0x2066)
end_define

begin_define
define|#
directive|define
name|LENOVO_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LENOVO, 0xffff)
end_define

begin_comment
comment|/* Samsung */
end_comment

begin_define
define|#
directive|define
name|SAMSUNG_VENDORID
value|0x144d
end_define

begin_define
define|#
directive|define
name|SAMSUNG_Q1_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(SAMSUNG, 0xc027)
end_define

begin_define
define|#
directive|define
name|SAMSUNG_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(SAMSUNG, 0xffff)
end_define

begin_comment
comment|/* Medion ? */
end_comment

begin_define
define|#
directive|define
name|MEDION_VENDORID
value|0x161f
end_define

begin_define
define|#
directive|define
name|MEDION_MD95257_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MEDION, 0x203d)
end_define

begin_define
define|#
directive|define
name|MEDION_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MEDION, 0xffff)
end_define

begin_comment
comment|/*  * Apple Intel MacXXXX seems using Sigmatel codec/vendor id  * instead of their own, which is beyond my comprehension  * (see HDA_CODEC_STAC9221 below).  */
end_comment

begin_define
define|#
directive|define
name|APPLE_INTEL_MAC
value|0x76808384
end_define

begin_comment
comment|/* Misc constants.. */
end_comment

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_DEFAULT
value|(0xffffffff)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_NONE
value|(0)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_LEFT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_RIGHT
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_ALL
value|(HDA_AMP_MUTE_LEFT | HDA_AMP_MUTE_RIGHT)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_LEFT_MUTED
parameter_list|(
name|v
parameter_list|)
value|((v)& (HDA_AMP_MUTE_LEFT))
end_define

begin_define
define|#
directive|define
name|HDA_AMP_RIGHT_MUTED
parameter_list|(
name|v
parameter_list|)
value|(((v)& HDA_AMP_MUTE_RIGHT)>> 1)
end_define

begin_define
define|#
directive|define
name|HDA_DAC_PATH
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_ADC_PATH
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_ADC_RECSEL
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|HDA_CTL_OUT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_CTL_IN
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_CTL_BOTH
value|(HDA_CTL_IN | HDA_CTL_OUT)
end_define

begin_define
define|#
directive|define
name|HDA_GPIO_MAX
value|15
end_define

begin_comment
comment|/* 0 - 14 = GPIO */
end_comment

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO0
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO1
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO2
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIOFLUSH
value|(1<< 15)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_SOFTPCMVOL
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_FIXEDRATE
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_FORCESTEREO
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_EAPDINV
value|(1<< 19)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|hdac_quirks_tab
index|[]
init|=
block|{
block|{
literal|"gpio0"
block|,
name|HDA_QUIRK_GPIO0
block|}
block|,
block|{
literal|"gpio1"
block|,
name|HDA_QUIRK_GPIO1
block|}
block|,
block|{
literal|"gpio2"
block|,
name|HDA_QUIRK_GPIO2
block|}
block|,
block|{
literal|"gpioflush"
block|,
name|HDA_QUIRK_GPIOFLUSH
block|}
block|,
block|{
literal|"softpcmvol"
block|,
name|HDA_QUIRK_SOFTPCMVOL
block|}
block|,
block|{
literal|"fixedrate"
block|,
name|HDA_QUIRK_FIXEDRATE
block|}
block|,
block|{
literal|"forcestereo"
block|,
name|HDA_QUIRK_FORCESTEREO
block|}
block|,
block|{
literal|"eapdinv"
block|,
name|HDA_QUIRK_EAPDINV
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_QUIRKS_TAB_LEN
define|\
value|(sizeof(hdac_quirks_tab) / sizeof(hdac_quirks_tab[0]))
end_define

begin_define
define|#
directive|define
name|HDA_BDL_MIN
value|2
end_define

begin_define
define|#
directive|define
name|HDA_BDL_MAX
value|256
end_define

begin_define
define|#
directive|define
name|HDA_BDL_DEFAULT
value|HDA_BDL_MIN
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_MIN
value|4096
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_MAX
value|65536
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_DEFAULT
value|16384
end_define

begin_define
define|#
directive|define
name|HDA_PARSE_MAXDEPTH
value|10
end_define

begin_define
define|#
directive|define
name|HDAC_UNSOLTAG_EVENT_HP
value|0x00
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_HDAC
argument_list|,
literal|"hdac"
argument_list|,
literal|"High Definition Audio Controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|HDA_PARSE_MIXER
block|,
name|HDA_PARSE_DIRECT
block|}
enum|;
end_enum

begin_comment
comment|/* Default */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|hdac_fmt
index|[]
init|=
block|{
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|hdac_caps
init|=
block|{
literal|48000
block|,
literal|48000
block|,
name|hdac_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|hdac_devices
index|[]
init|=
block|{
block|{
name|HDA_INTEL_82801F
block|,
literal|"Intel 82801F"
block|}
block|,
block|{
name|HDA_INTEL_82801G
block|,
literal|"Intel 82801G"
block|}
block|,
block|{
name|HDA_INTEL_82801H
block|,
literal|"Intel 82801H"
block|}
block|,
block|{
name|HDA_INTEL_63XXESB
block|,
literal|"Intel 631x/632xESB"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP51
block|,
literal|"NVidia MCP51"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP55
block|,
literal|"NVidia MCP55"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP61A
block|,
literal|"NVidia MCP61A"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP61B
block|,
literal|"NVidia MCP61B"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP65A
block|,
literal|"NVidia MCP65A"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP65B
block|,
literal|"NVidia MCP65B"
block|}
block|,
block|{
name|HDA_ATI_SB450
block|,
literal|"ATI SB450"
block|}
block|,
block|{
name|HDA_ATI_SB600
block|,
literal|"ATI SB600"
block|}
block|,
block|{
name|HDA_VIA_VT82XX
block|,
literal|"VIA VT8251/8237A"
block|}
block|,
block|{
name|HDA_SIS_966
block|,
literal|"SiS 966"
block|}
block|,
comment|/* Unknown */
block|{
name|HDA_INTEL_ALL
block|,
literal|"Intel (Unknown)"
block|}
block|,
block|{
name|HDA_NVIDIA_ALL
block|,
literal|"NVidia (Unknown)"
block|}
block|,
block|{
name|HDA_ATI_ALL
block|,
literal|"ATI (Unknown)"
block|}
block|,
block|{
name|HDA_VIA_ALL
block|,
literal|"VIA (Unknown)"
block|}
block|,
block|{
name|HDA_SIS_ALL
block|,
literal|"SiS (Unknown)"
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_DEVICES_LEN
value|(sizeof(hdac_devices) / sizeof(hdac_devices[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|rate
decl_stmt|;
name|int
name|valid
decl_stmt|;
name|uint16_t
name|base
decl_stmt|;
name|uint16_t
name|mul
decl_stmt|;
name|uint16_t
name|div
decl_stmt|;
block|}
name|hda_rate_tab
index|[]
init|=
block|{
block|{
literal|8000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0500
block|}
block|,
comment|/* (48000 * 1) / 6 */
block|{
literal|9600
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 1) / 5 */
block|{
literal|12000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
comment|/* (48000 * 1) / 4 */
block|{
literal|16000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 1) / 3 */
block|{
literal|18000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0700
block|}
block|,
comment|/* (48000 * 3) / 8 */
block|{
literal|19200
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 2) / 5 */
block|{
literal|24000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0100
block|}
block|,
comment|/* (48000 * 1) / 2 */
block|{
literal|28800
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 3) / 5 */
block|{
literal|32000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 2) / 3 */
block|{
literal|36000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0300
block|}
block|,
comment|/* (48000 * 3) / 4 */
block|{
literal|38400
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 4) / 5 */
block|{
literal|48000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 1) / 1 */
block|{
literal|64000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 4) / 3 */
block|{
literal|72000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0100
block|}
block|,
comment|/* (48000 * 3) / 2 */
block|{
literal|96000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 2) / 1 */
block|{
literal|144000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 3) / 1 */
block|{
literal|192000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 4) / 1 */
block|{
literal|8820
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 1) / 5 */
block|{
literal|11025
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
comment|/* (44100 * 1) / 4 */
block|{
literal|12600
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 2) / 7 */
block|{
literal|14700
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 1) / 3 */
block|{
literal|17640
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 2) / 5 */
block|{
literal|18900
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 3) / 7 */
block|{
literal|22050
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0100
block|}
block|,
comment|/* (44100 * 1) / 2 */
block|{
literal|25200
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 4) / 7 */
block|{
literal|26460
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 3) / 5 */
block|{
literal|29400
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 2) / 3 */
block|{
literal|33075
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0300
block|}
block|,
comment|/* (44100 * 3) / 4 */
block|{
literal|35280
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 4) / 5 */
block|{
literal|44100
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 1) / 1 */
block|{
literal|58800
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 4) / 3 */
block|{
literal|66150
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0100
block|}
block|,
comment|/* (44100 * 3) / 2 */
block|{
literal|88200
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 2) / 1 */
block|{
literal|132300
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 3) / 1 */
block|{
literal|176400
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 4) / 1 */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HDA_RATE_TAB_LEN
value|(sizeof(hda_rate_tab) / sizeof(hda_rate_tab[0]))
end_define

begin_comment
comment|/* All codecs you can eat... */
end_comment

begin_define
define|#
directive|define
name|HDA_CODEC_CONSTRUCT
parameter_list|(
name|vendor
parameter_list|,
name|id
parameter_list|)
define|\
value|(((uint32_t)(vendor##_VENDORID)<< 16) | ((id)& 0xffff))
end_define

begin_comment
comment|/* Realtek */
end_comment

begin_define
define|#
directive|define
name|REALTEK_VENDORID
value|0x10ec
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC260
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0260)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC861
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0861)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC880
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0880)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC882
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0882)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC883
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0883)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALCXXXX
value|HDA_CODEC_CONSTRUCT(REALTEK, 0xffff)
end_define

begin_comment
comment|/* Analog Device */
end_comment

begin_define
define|#
directive|define
name|ANALOGDEVICE_VENDORID
value|0x11d4
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1981HD
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICE, 0x1981)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1983
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICE, 0x1983)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1986A
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICE, 0x1986)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ADXXXX
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICE, 0xffff)
end_define

begin_comment
comment|/* CMedia */
end_comment

begin_define
define|#
directive|define
name|CMEDIA_VENDORID
value|0x434d
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CMI9880
value|HDA_CODEC_CONSTRUCT(CMEDIA, 0x4980)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CMIXXXX
value|HDA_CODEC_CONSTRUCT(CMEDIA, 0xffff)
end_define

begin_comment
comment|/* Sigmatel */
end_comment

begin_define
define|#
directive|define
name|SIGMATEL_VENDORID
value|0x8384
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9221
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7680)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9221D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7683)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9220
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7690)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC922XD
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7681)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STACXXXX
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0xffff)
end_define

begin_comment
comment|/*  * Conexant  *  * Ok, the truth is, I don't have any idea at all whether  * it is "Venice" or "Waikiki" or other unnamed CXyadayada. The only  * place that tell me it is "Venice" is from its Windows driver INF.  *  *  Venice - CX?????  * Waikiki - CX20551-22  */
end_comment

begin_define
define|#
directive|define
name|CONEXANT_VENDORID
value|0x14f1
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CXVENICE
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0x5045)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CXWAIKIKI
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0x5047)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CXXXXX
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0xffff)
end_define

begin_comment
comment|/* Codecs */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|hdac_codecs
index|[]
init|=
block|{
block|{
name|HDA_CODEC_ALC260
block|,
literal|"Realtek ALC260"
block|}
block|,
block|{
name|HDA_CODEC_ALC861
block|,
literal|"Realtek ALC861"
block|}
block|,
block|{
name|HDA_CODEC_ALC880
block|,
literal|"Realtek ALC880"
block|}
block|,
block|{
name|HDA_CODEC_ALC882
block|,
literal|"Realtek ALC882"
block|}
block|,
block|{
name|HDA_CODEC_ALC883
block|,
literal|"Realtek ALC883"
block|}
block|,
block|{
name|HDA_CODEC_AD1981HD
block|,
literal|"Analog Device AD1981HD"
block|}
block|,
block|{
name|HDA_CODEC_AD1983
block|,
literal|"Analog Device AD1983"
block|}
block|,
block|{
name|HDA_CODEC_AD1986A
block|,
literal|"Analog Device AD1986A"
block|}
block|,
block|{
name|HDA_CODEC_CMI9880
block|,
literal|"CMedia CMI9880"
block|}
block|,
block|{
name|HDA_CODEC_STAC9221
block|,
literal|"Sigmatel STAC9221"
block|}
block|,
block|{
name|HDA_CODEC_STAC9221D
block|,
literal|"Sigmatel STAC9221D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9220
block|,
literal|"Sigmatel STAC9220"
block|}
block|,
block|{
name|HDA_CODEC_STAC922XD
block|,
literal|"Sigmatel STAC9220D/9223D"
block|}
block|,
block|{
name|HDA_CODEC_CXVENICE
block|,
literal|"Conexant Venice"
block|}
block|,
block|{
name|HDA_CODEC_CXWAIKIKI
block|,
literal|"Conexant Waikiki"
block|}
block|,
comment|/* Unknown codec */
block|{
name|HDA_CODEC_ALCXXXX
block|,
literal|"Realtek (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_ADXXXX
block|,
literal|"Analog Device (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_CMIXXXX
block|,
literal|"CMedia (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_STACXXXX
block|,
literal|"Sigmatel (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_CXXXXX
block|,
literal|"Conexant (Unknown)"
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_CODECS_LEN
value|(sizeof(hdac_codecs) / sizeof(hdac_codecs[0]))
end_define

begin_enum
enum|enum
block|{
name|HDAC_HP_SWITCH_CTL
block|,
name|HDAC_HP_SWITCH_CTRL
block|}
enum|;
end_enum

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|inverted
decl_stmt|;
name|nid_t
name|hpnid
decl_stmt|;
name|nid_t
name|spkrnid
index|[
literal|8
index|]
decl_stmt|;
name|nid_t
name|eapdnid
decl_stmt|;
block|}
name|hdac_hp_switch
index|[]
init|=
block|{
comment|/* Specific OEM models */
block|{
name|HP_V3000_SUBVENDOR
block|,
name|HDA_CODEC_CXVENICE
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|0
block|,
literal|17
block|,
block|{
literal|16
block|,
operator|-
literal|1
block|}
block|,
literal|16
block|}
block|,
block|{
name|HP_NX7400_SUBVENDOR
block|,
name|HDA_CODEC_AD1981HD
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|0
block|,
literal|6
block|,
block|{
literal|5
block|,
operator|-
literal|1
block|}
block|,
literal|5
block|}
block|,
block|{
name|HP_NX6310_SUBVENDOR
block|,
name|HDA_CODEC_AD1981HD
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|0
block|,
literal|6
block|,
block|{
literal|5
block|,
operator|-
literal|1
block|}
block|,
literal|5
block|}
block|,
block|{
name|DELL_D820_SUBVENDOR
block|,
name|HDA_CODEC_STAC9220
block|,
name|HDAC_HP_SWITCH_CTRL
block|,
literal|0
block|,
literal|13
block|,
block|{
literal|14
block|,
operator|-
literal|1
block|}
block|,
operator|-
literal|1
block|}
block|,
block|{
name|DELL_I1300_SUBVENDOR
block|,
name|HDA_CODEC_STAC9220
block|,
name|HDAC_HP_SWITCH_CTRL
block|,
literal|0
block|,
literal|13
block|,
block|{
literal|14
block|,
operator|-
literal|1
block|}
block|,
operator|-
literal|1
block|}
block|,
block|{
name|APPLE_INTEL_MAC
block|,
name|HDA_CODEC_STAC9221
block|,
name|HDAC_HP_SWITCH_CTRL
block|,
literal|0
block|,
literal|10
block|,
block|{
literal|13
block|,
operator|-
literal|1
block|}
block|,
operator|-
literal|1
block|}
block|,
block|{
name|LENOVO_3KN100_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|1
block|,
literal|26
block|,
block|{
literal|27
block|,
operator|-
literal|1
block|}
block|,
operator|-
literal|1
block|}
block|,
comment|/* 	 * All models that at least come from the same vendor with 	 * simmilar codec. 	 */
block|{
name|HP_ALL_SUBVENDOR
block|,
name|HDA_CODEC_CXVENICE
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|0
block|,
literal|17
block|,
block|{
literal|16
block|,
operator|-
literal|1
block|}
block|,
literal|16
block|}
block|,
block|{
name|HP_ALL_SUBVENDOR
block|,
name|HDA_CODEC_AD1981HD
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|0
block|,
literal|6
block|,
block|{
literal|5
block|,
operator|-
literal|1
block|}
block|,
literal|5
block|}
block|,
block|{
name|DELL_ALL_SUBVENDOR
block|,
name|HDA_CODEC_STAC9220
block|,
name|HDAC_HP_SWITCH_CTRL
block|,
literal|0
block|,
literal|13
block|,
block|{
literal|14
block|,
operator|-
literal|1
block|}
block|,
operator|-
literal|1
block|}
block|,
block|{
name|LENOVO_ALL_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDAC_HP_SWITCH_CTL
block|,
literal|1
block|,
literal|26
block|,
block|{
literal|27
block|,
operator|-
literal|1
block|}
block|,
operator|-
literal|1
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_HP_SWITCH_LEN
define|\
value|(sizeof(hdac_hp_switch) / sizeof(hdac_hp_switch[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|nid_t
name|eapdnid
decl_stmt|;
name|int
name|hp_switch
decl_stmt|;
block|}
name|hdac_eapd_switch
index|[]
init|=
block|{
block|{
name|HP_V3000_SUBVENDOR
block|,
name|HDA_CODEC_CXVENICE
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
name|HP_NX7400_SUBVENDOR
block|,
name|HDA_CODEC_AD1981HD
block|,
literal|5
block|,
literal|1
block|}
block|,
block|{
name|HP_NX6310_SUBVENDOR
block|,
name|HDA_CODEC_AD1981HD
block|,
literal|5
block|,
literal|1
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_EAPD_SWITCH_LEN
define|\
value|(sizeof(hdac_eapd_switch) / sizeof(hdac_eapd_switch[0]))
end_define

begin_comment
comment|/****************************************************************************  * Function prototypes  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|hdac_intr_handler
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_reset
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_get_capabilities
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dma_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_dma_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_dma
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dma_free
parameter_list|(
name|struct
name|hdac_dma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_mem_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_mem_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_irq_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_irq_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_corb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_rirb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_corb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_rirb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_scan_codecs
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_probe_codec
parameter_list|(
name|struct
name|hdac_codec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hdac_devinfo
modifier|*
name|hdac_probe_function
parameter_list|(
name|struct
name|hdac_codec
modifier|*
parameter_list|,
name|nid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_add_child
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_attach2
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|hdac_command_sendone_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_command_send_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_command_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_widget_connection_select
parameter_list|(
name|struct
name|hdac_widget
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_audio_ctl_amp_set
parameter_list|(
name|struct
name|hdac_audio_ctl
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hdac_audio_ctl
modifier|*
name|hdac_audio_ctl_amp_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_audio_ctl_amp_set_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|nid_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_getnextdev
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hdac_widget
modifier|*
name|hdac_widget_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
parameter_list|,
name|nid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_rirb_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_unsolq_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|hdac_command
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
define|\
value|hdac_command_sendone_internal(a1, a2, a3)
end_define

begin_define
define|#
directive|define
name|hdac_codec_id
parameter_list|(
name|d
parameter_list|)
define|\
value|((uint32_t)((d == NULL) ? 0x00000000 :			\ 		((((uint32_t)(d)->vendor_id& 0x0000ffff)<< 16) |	\ 		((uint32_t)(d)->device_id& 0x0000ffff))))
end_define

begin_function
specifier|static
name|char
modifier|*
name|hdac_codec_name
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|uint32_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODECS_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_codecs
index|[
name|i
index|]
operator|.
name|id
argument_list|,
name|id
argument_list|)
condition|)
return|return
operator|(
name|hdac_codecs
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|id
operator|==
literal|0x00000000
operator|)
condition|?
literal|"NULL Codec"
else|:
literal|"Unknown Codec"
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|hdac_audio_ctl_ossmixer_mask2name
parameter_list|(
name|uint32_t
name|devmask
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ossname
index|[]
init|=
name|SOUND_DEVICE_NAMES
decl_stmt|;
specifier|static
name|char
modifier|*
name|unknown
init|=
literal|"???"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SOUND_MIXER_NRDEVICES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|devmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
return|return
operator|(
name|ossname
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|unknown
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_ossmixer_mask2allname
parameter_list|(
name|uint32_t
name|mask
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ossname
index|[]
init|=
name|SOUND_DEVICE_NAMES
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|ossname
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_audio_ctl
modifier|*
name|hdac_audio_ctl_each
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|node_type
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
operator|||
name|index
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
operator|<
literal|1
operator|||
operator|*
name|index
operator|<
literal|0
operator|||
operator|*
name|index
operator|>=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_audio_ctl
modifier|*
name|hdac_audio_ctl_amp_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|retctl
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|at
decl_stmt|,
name|atindex
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|at
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|at
operator|==
literal|0
condition|)
name|at
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|at
operator|<
literal|0
condition|)
name|at
operator|=
operator|-
literal|1
expr_stmt|;
name|atindex
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|atindex
operator|<
literal|0
condition|)
name|atindex
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|nid
operator|&&
operator|(
name|atindex
operator|==
operator|-
literal|1
operator|||
name|ctl
operator|->
name|index
operator|==
name|atindex
operator|)
operator|)
condition|)
continue|continue;
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|cnt
condition|)
return|return
operator|(
name|ctl
operator|)
return|;
name|retctl
operator|=
name|ctl
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|at
operator|==
operator|-
literal|1
operator|)
condition|?
name|retctl
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_hp_switch_handler
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|id
decl_stmt|,
name|res
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|forcemute
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_HP_SWITCH_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
operator|&&
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|id
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|HDAC_HP_SWITCH_LEN
condition|)
return|return;
name|forcemute
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|eapdnid
operator|!=
operator|-
literal|1
condition|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|eapdnid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDAC_INVALID
condition|)
name|forcemute
operator|=
operator|(
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
name|cad
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|hpnid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Pin sense: nid=%d res=0x%08x\n"
argument|, 		    hdac_hp_switch[i].hpnid, res);
argument_list|)
empty_stmt|;
name|res
operator|>>=
literal|31
expr_stmt|;
name|res
operator|^=
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|inverted
expr_stmt|;
switch|switch
condition|(
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|HDAC_HP_SWITCH_CTL
case|:
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|hpnid
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
condition|)
block|{
name|ctl
operator|->
name|muted
operator|=
operator|(
name|res
operator|!=
literal|0
operator|&&
name|forcemute
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_NONE
else|:
name|HDA_AMP_MUTE_ALL
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_DEFAULT
argument_list|,
name|ctl
operator|->
name|left
argument_list|,
name|ctl
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|spkrnid
index|[
name|j
index|]
operator|!=
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|spkrnid
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
condition|)
block|{
name|ctl
operator|->
name|muted
operator|=
operator|(
name|res
operator|!=
literal|0
operator|||
name|forcemute
operator|==
literal|1
operator|)
condition|?
name|HDA_AMP_MUTE_ALL
else|:
name|HDA_AMP_MUTE_NONE
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_DEFAULT
argument_list|,
name|ctl
operator|->
name|left
argument_list|,
name|ctl
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HDAC_HP_SWITCH_CTRL
case|:
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
comment|/* HP in */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|hpnid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
name|forcemute
operator|==
literal|0
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
else|else
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|spkrnid
index|[
name|j
index|]
operator|!=
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|spkrnid
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* HP out */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|hpnid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|spkrnid
index|[
name|j
index|]
operator|!=
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|spkrnid
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
name|forcemute
operator|==
literal|0
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
else|else
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_unsolicited_handler
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|,
name|uint32_t
name|tag
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|NULL
decl_stmt|;
name|device_t
modifier|*
name|devlist
init|=
name|NULL
decl_stmt|;
name|int
name|devcount
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
operator|||
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|codec
operator|->
name|sc
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Unsol Tag: 0x%08x\n"
argument|, tag);
argument_list|)
empty_stmt|;
name|device_get_children
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devlist
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|=
operator|(
expr|struct
name|hdac_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|!=
name|NULL
operator|&&
name|devinfo
operator|->
name|node_type
operator|==
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
operator|&&
name|devinfo
operator|->
name|codec
operator|!=
name|NULL
operator|&&
name|devinfo
operator|->
name|codec
operator|->
name|cad
operator|==
name|codec
operator|->
name|cad
condition|)
block|{
break|break;
block|}
else|else
name|devinfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|devlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|HDAC_UNSOLTAG_EVENT_HP
case|:
name|hdac_hp_switch_handler
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_stream_intr
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|uint32_t
name|res
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ch
operator|->
name|blkcnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|res
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDSTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (res& (HDAC_SDSTS_DESE | HDAC_SDSTS_FIFOE)) 			device_printf(sc->dev,
literal|"PCMDIR_%s intr triggered beyond stream boundary:"
literal|"%08x\n"
argument|, 			    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, res);
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDSTS
argument_list|,
name|HDAC_SDSTS_DESE
operator||
name|HDAC_SDSTS_FIFOE
operator||
name|HDAC_SDSTS_BCIS
argument_list|)
expr_stmt|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
if|if
condition|(
name|res
operator|&
name|HDAC_SDSTS_BCIS
condition|)
block|{
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_intr_handler(void *)  *  * Interrupt handler. Processes interrupts received from the hdac.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_intr_handler
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|intsts
decl_stmt|;
name|uint8_t
name|rirbsts
decl_stmt|;
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|;
name|uint32_t
name|trigger
init|=
literal|0
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|context
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do we have anything to do? */
name|intsts
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HDA_FLAG_MATCH
argument_list|(
name|intsts
argument_list|,
name|HDAC_INTSTS_GIS
argument_list|)
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Was this a controller interrupt? */
if|if
condition|(
name|HDA_FLAG_MATCH
argument_list|(
name|intsts
argument_list|,
name|HDAC_INTSTS_CIS
argument_list|)
condition|)
block|{
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirbsts
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|)
expr_stmt|;
comment|/* Get as many responses that we can */
while|while
condition|(
name|HDA_FLAG_MATCH
argument_list|(
name|rirbsts
argument_list|,
name|HDAC_RIRBSTS_RINTFL
argument_list|)
condition|)
block|{
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|,
name|HDAC_RIRBSTS_RINTFL
argument_list|)
expr_stmt|;
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rirbsts
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|)
expr_stmt|;
block|}
comment|/* XXX to be removed */
comment|/* Clear interrupt and exit */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|,
name|HDAC_INTSTS_CIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|intsts
operator|&
name|HDAC_INTSTS_SIS_MASK
condition|)
block|{
if|if
condition|(
operator|(
name|intsts
operator|&
operator|(
literal|1
operator|<<
name|sc
operator|->
name|num_iss
operator|)
operator|)
operator|&&
name|hdac_stream_intr
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|play
argument_list|)
operator|!=
literal|0
condition|)
name|trigger
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|intsts
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|&&
name|hdac_stream_intr
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rec
argument_list|)
operator|!=
literal|0
condition|)
name|trigger
operator||=
literal|2
expr_stmt|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|,
name|intsts
operator|&
name|HDAC_INTSTS_SIS_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|&
literal|1
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|play
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|&
literal|2
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rec
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_reset(hdac_softc *)  *  * Reset the hdac to a quiescent and known state.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_reset
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|gctl
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Stop all Streams DMA engine 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_iss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_ISDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_oss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_OSDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_bss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_BSDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Stop Control DMA engines 	 */
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the controller. The reset must remain asserted for 	 * a minimum of 100us. 	 */
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|gctl
operator|&
operator|~
name|HDAC_GCTL_CRST
argument_list|)
expr_stmt|;
name|count
operator|=
literal|10000
expr_stmt|;
do|do
block|{
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
if|if
condition|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to put hdac in reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|gctl
operator||
name|HDAC_GCTL_CRST
argument_list|)
expr_stmt|;
name|count
operator|=
literal|10000
expr_stmt|;
do|do
block|{
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Device stuck in reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Wait for codecs to finish their own reset sequence. The delay here 	 * should be of 250us but for some reasons, on it's not enough on my 	 * computer. Let's use twice as much as necessary to make sure that 	 * it's reset properly. 	 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_get_capabilities(struct hdac_softc *);  *  * Retreive the general capabilities of the hdac;  *	Number of Input Streams  *	Number of Output Streams  *	Number of bidirectional Streams  *	64bit ready  *	CORB and RIRB sizes  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_get_capabilities
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|gcap
decl_stmt|;
name|uint8_t
name|corbsize
decl_stmt|,
name|rirbsize
decl_stmt|;
name|gcap
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCAP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_iss
operator|=
name|HDAC_GCAP_ISS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_oss
operator|=
name|HDAC_GCAP_OSS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_bss
operator|=
name|HDAC_GCAP_BSS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|support_64bit
operator|=
name|HDA_FLAG_MATCH
argument_list|(
name|gcap
argument_list|,
name|HDAC_GCAP_64OK
argument_list|)
expr_stmt|;
name|corbsize
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_256
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_256
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_16
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_16
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_2
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_2
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Invalid corb size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|corbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rirbsize
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_256
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_256
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_16
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_16
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_2
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_2
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Invalid rirb size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rirbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_dma_cb  *  * This function is called by bus_dmamap_load when the mapping has been  * established. We just record the physical address of the mapping into  * the struct hdac_dma passed in.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_dma_cb
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|hdac_dma
modifier|*
name|dma
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dma
operator|=
operator|(
expr|struct
name|hdac_dma
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|dma
operator|->
name|dma_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dma_nocache
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|ptr
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
condition|)
block|{
operator|*
name|pte
operator||=
name|PG_N
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_dma_alloc  *  * This function allocate and setup a dma region (struct hdac_dma).  * It must be freed by a corresponding hdac_dma_free.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_dma_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_dma
modifier|*
name|dma
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|int
name|lowaddr
decl_stmt|;
name|lowaddr
operator|=
operator|(
name|sc
operator|->
name|support_64bit
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
name|bzero
argument_list|(
name|dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create a DMA tag 	 */
name|result
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|HDAC_DMA_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|lowaddr
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
comment|/* filtfunc */
name|NULL
argument_list|,
comment|/* fistfuncarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate DMA memory 	 */
name|result
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_alloc failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Map the memory 	 */
name|result
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|hdac_dma_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|||
name|dma
operator|->
name|dma_paddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_load failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hdac_dma_nocache
argument_list|(
name|dma
operator|->
name|dma_vaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|dma
operator|->
name|dma_map
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|dma_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_dma_free(struct hdac_dma *)  *  * Free a struct dhac_dma that has been previously allocated via the  * hdac_dma_alloc function.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_dma_free
parameter_list|(
name|struct
name|hdac_dma
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|dma_tag
operator|!=
name|NULL
condition|)
block|{
comment|/* Flush caches */
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_mem_alloc(struct hdac_softc *)  *  * Allocate all the bus resources necessary to speak with the physical  * controller.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_mem_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_mem
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|&
name|sc
operator|->
name|mem
expr_stmt|;
name|mem
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|mem
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate memory resource\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mem
operator|->
name|mem_tag
operator|=
name|rman_get_bustag
argument_list|(
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_mem_free(struct hdac_softc *)  *  * Free up resources previously allocated by hdac_mem_alloc.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_mem_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_mem
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|&
name|sc
operator|->
name|mem
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|mem
operator|->
name|mem_rid
argument_list|,
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_res
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_irq_alloc(struct hdac_softc *)  *  * Allocate and setup the resources necessary for interrupt handling.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_irq_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|result
decl_stmt|;
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
expr_stmt|;
name|irq
operator|->
name|irq_rid
operator|=
literal|0x0
expr_stmt|;
name|irq
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate irq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|snd_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|hdac_intr_handler
argument_list|,
name|sc
argument_list|,
operator|&
name|irq
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to setup interrupt handler (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_irq_free(struct hdac_softc *)  *  * Free up resources previously allocated by hdac_irq_alloc.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_irq_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_irq
modifier|*
name|irq
decl_stmt|;
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|!=
name|NULL
operator|&&
name|irq
operator|->
name|irq_handle
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|,
name|irq
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|irq_rid
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|irq
operator|->
name|irq_handle
operator|=
name|NULL
expr_stmt|;
name|irq
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_corb_init(struct hdac_softc *)  *  * Initialize the corb registers for operations but do not start it up yet.  * The CORB engine must not be running when this function is called.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_corb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|corbsize
decl_stmt|;
name|uint64_t
name|corbpaddr
decl_stmt|;
comment|/* Setup the CORB size. */
switch|switch
condition|(
name|sc
operator|->
name|corb_size
condition|)
block|{
case|case
literal|256
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_256
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CORB size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|corb_size
argument_list|)
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBSIZE
argument_list|,
name|corbsize
argument_list|)
expr_stmt|;
comment|/* Setup the CORB Address in the hdac */
name|corbpaddr
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|corb_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBLBASE
argument_list|,
operator|(
name|uint32_t
operator|)
name|corbpaddr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|corbpaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the WP and RP */
name|sc
operator|->
name|corb_wp
operator|=
literal|0
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBWP
argument_list|,
name|sc
operator|->
name|corb_wp
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|,
name|HDAC_CORBRP_CORBRPRST
argument_list|)
expr_stmt|;
comment|/* 	 * The HDA specification indicates that the CORBRPRST bit will always 	 * read as zero. Unfortunately, it seems that at least the 82801G 	 * doesn't reset the bit to zero, which stalls the corb engine. 	 * manually reset the bit to zero before continuing. 	 */
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Enable CORB error reporting */
if|#
directive|if
literal|0
block|HDAC_WRITE_1(&sc->mem, HDAC_CORBCTL, HDAC_CORBCTL_CMEIE);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_rirb_init(struct hdac_softc *)  *  * Initialize the rirb registers for operations but do not start it up yet.  * The RIRB engine must not be running when this function is called.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_rirb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|rirbsize
decl_stmt|;
name|uint64_t
name|rirbpaddr
decl_stmt|;
comment|/* Setup the RIRB size. */
switch|switch
condition|(
name|sc
operator|->
name|rirb_size
condition|)
block|{
case|case
literal|256
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_256
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid RIRB size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rirb_size
argument_list|)
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSIZE
argument_list|,
name|rirbsize
argument_list|)
expr_stmt|;
comment|/* Setup the RIRB Address in the hdac */
name|rirbpaddr
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBLBASE
argument_list|,
operator|(
name|uint32_t
operator|)
name|rirbpaddr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|rirbpaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the WP and RP */
name|sc
operator|->
name|rirb_rp
operator|=
literal|0
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBWP
argument_list|,
name|HDAC_RIRBWP_RIRBWPRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
comment|/* Setup the interrupt threshold */
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RINTCNT
argument_list|,
name|sc
operator|->
name|rirb_size
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable Overrun and response received reporting */
if|#
directive|if
literal|0
block|HDAC_WRITE_1(&sc->mem, HDAC_RIRBCTL, 		    HDAC_RIRBCTL_RIRBOIC | HDAC_RIRBCTL_RINTCTL);
else|#
directive|else
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|HDAC_RIRBCTL_RINTCTL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Make sure that the Host CPU cache doesn't contain any dirty 	 * cache lines that falls in the rirb. If I understood correctly, it 	 * should be sufficient to do this only once as the rirb is purely 	 * read-only from now on. 	 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_tag
argument_list|,
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_corb_start(hdac_softc *)  *  * Startup the corb DMA engine  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_corb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|corbctl
decl_stmt|;
name|corbctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|)
expr_stmt|;
name|corbctl
operator||=
name|HDAC_CORBCTL_CORBRUN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|,
name|corbctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_rirb_start(hdac_softc *)  *  * Startup the rirb DMA engine  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_rirb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|rirbctl
decl_stmt|;
name|rirbctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|)
expr_stmt|;
name|rirbctl
operator||=
name|HDAC_RIRBCTL_RIRBDMAEN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|rirbctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_scan_codecs(struct hdac_softc *)  *  * Scan the bus for available codecs.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_scan_codecs
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|statests
decl_stmt|;
name|statests
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_STATESTS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDAC_STATESTS_SDIWAKE
argument_list|(
name|statests
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* We have found a codec. */
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|codec
operator|=
operator|(
expr|struct
name|hdac_codec
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|codec
argument_list|)
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to allocate memory for codec\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|codec
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|codec
operator|->
name|responses_received
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|verbs_sent
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|codec
operator|->
name|cad
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|=
name|codec
expr_stmt|;
if|if
condition|(
name|hdac_probe_codec
argument_list|(
name|codec
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* All codecs have been probed, now try to attach drivers to them */
comment|/* bus_generic_attach(sc->dev); */
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_probe_codec(struct hdac_softc *, int)  *  * Probe a the given codec_id for available function groups.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_probe_codec
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|uint32_t
name|vendorid
decl_stmt|,
name|revisionid
decl_stmt|,
name|subnode
decl_stmt|;
name|int
name|startnode
decl_stmt|;
name|int
name|endnode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nid_t
name|cad
init|=
name|codec
operator|->
name|cad
decl_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Probing codec: %d\n"
argument|, cad);
argument_list|)
empty_stmt|;
name|vendorid
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_VENDOR_ID
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|revisionid
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_REVISION_ID
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|subnode
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_SUB_NODE_COUNT
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|startnode
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_START
argument_list|(
name|subnode
argument_list|)
expr_stmt|;
name|endnode
operator|=
name|startnode
operator|+
name|HDA_PARAM_SUB_NODE_COUNT_TOTAL
argument_list|(
name|subnode
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: \tstartnode=%d endnode=%d\n"
argument|, 		    startnode, endnode);
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
name|startnode
init|;
name|i
operator|<
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|=
name|hdac_probe_function
argument_list|(
name|codec
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX Ignore other FG. */
name|devinfo
operator|->
name|vendor_id
operator|=
name|HDA_PARAM_VENDOR_ID_VENDOR_ID
argument_list|(
name|vendorid
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|device_id
operator|=
name|HDA_PARAM_VENDOR_ID_DEVICE_ID
argument_list|(
name|vendorid
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|revision_id
operator|=
name|HDA_PARAM_REVISION_ID_REVISION_ID
argument_list|(
name|revisionid
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|stepping_id
operator|=
name|HDA_PARAM_REVISION_ID_STEPPING_ID
argument_list|(
name|revisionid
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: \tFound AFG nid=%d "
literal|"[startnode=%d endnode=%d]\n"
argument|, 				    devinfo->nid, startnode, endnode);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: \tAFG not found\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_devinfo
modifier|*
name|hdac_probe_function
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|,
name|nid_t
name|nid
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|uint32_t
name|fctgrptype
decl_stmt|;
name|nid_t
name|cad
init|=
name|codec
operator|->
name|cad
decl_stmt|;
name|fctgrptype
operator|=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE
argument_list|(
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_FCT_GRP_TYPE
argument_list|)
argument_list|,
name|cad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX For now, ignore other FG. */
if|if
condition|(
name|fctgrptype
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|devinfo
operator|=
operator|(
expr|struct
name|hdac_devinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|devinfo
argument_list|)
argument_list|,
name|M_HDAC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate ivar\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|devinfo
operator|->
name|nid
operator|=
name|nid
expr_stmt|;
name|devinfo
operator|->
name|node_type
operator|=
name|fctgrptype
expr_stmt|;
name|devinfo
operator|->
name|codec
operator|=
name|codec
expr_stmt|;
name|hdac_add_child
argument_list|(
name|sc
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|devinfo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_add_child
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|devinfo
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|devinfo
argument_list|)
expr_stmt|;
comment|/* XXX - Print more information when booting verbose??? */
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_connection_parse
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max
decl_stmt|,
name|found
decl_stmt|,
name|entnum
decl_stmt|,
name|cnid
decl_stmt|;
name|nid_t
name|cad
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_CONN_LIST_LENGTH
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|nconns
operator|=
name|HDA_PARAM_CONN_LIST_LENGTH_LIST_LENGTH
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|<
literal|1
condition|)
return|return;
name|entnum
operator|=
name|HDA_PARAM_CONN_LIST_LENGTH_LONG_FORM
argument_list|(
name|res
argument_list|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|w
operator|->
name|conns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|w
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|w
operator|->
name|nconns
condition|)
block|{
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_CONN_LIST_ENTRY
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|i
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|entnum
condition|;
name|j
operator|++
control|)
block|{
name|cnid
operator|=
name|res
expr_stmt|;
name|cnid
operator|>>=
operator|(
literal|32
operator|/
name|entnum
operator|)
operator|*
name|j
expr_stmt|;
name|cnid
operator|&=
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|/
name|entnum
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cnid
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|found
operator|>
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"node %d: Adding %d: "
literal|"Max connection reached!\n"
argument_list|,
name|nid
argument_list|,
name|cnid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|w
operator|->
name|conns
index|[
name|found
operator|++
index|]
operator|=
name|cnid
expr_stmt|;
block|}
name|i
operator|+=
name|entnum
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (w->nconns != found) { 			device_printf(sc->dev,
literal|"HDA_DEBUG: nid=%d WARNING!!! Connection "
literal|"length=%d != found=%d\n"
argument|, 			    nid, w->nconns, found); 		}
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_widget_pin_getconfig
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|config
decl_stmt|,
name|id
decl_stmt|;
name|nid_t
name|cad
decl_stmt|,
name|nid
decl_stmt|;
name|sc
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|w
operator|->
name|nid
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|w
operator|->
name|devinfo
argument_list|)
expr_stmt|;
name|config
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_CONFIGURATION_DEFAULT
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
comment|/* 	 * XXX REWRITE!!!! Don't argue! 	 */
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC880
operator|&&
operator|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|CLEVO_D900T_SUBVENDOR
operator|||
name|sc
operator|->
name|pci_subvendor
operator|==
name|ASUS_M5200_SUBVENDOR
operator|)
condition|)
block|{
comment|/* 		 * Super broken BIOS 		 */
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|20
case|:
break|break;
case|case
literal|21
case|:
break|break;
case|case
literal|22
case|:
break|break;
case|case
literal|23
case|:
break|break;
case|case
literal|24
case|:
comment|/* MIC1 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* XXX MIC2 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
expr_stmt|;
break|break;
case|case
literal|26
case|:
comment|/* LINE1 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
expr_stmt|;
break|break;
case|case
literal|27
case|:
comment|/* XXX LINE2 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
expr_stmt|;
break|break;
case|case
literal|28
case|:
comment|/* CD */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
expr_stmt|;
break|break;
case|case
literal|30
case|:
break|break;
case|case
literal|31
case|:
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_pin_parse
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|config
decl_stmt|,
name|pincap
decl_stmt|;
name|char
modifier|*
name|devstr
decl_stmt|,
modifier|*
name|connstr
decl_stmt|;
name|nid_t
name|cad
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|config
operator|=
name|hdac_widget_pin_getconfig
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|pincap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_PIN_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
operator|=
name|pincap
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
operator|&
operator|~
operator|(
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_EAPD_BTL_ENABLE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&=
literal|0x7
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator||=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|HDAC_INVALID
expr_stmt|;
switch|switch
condition|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
case|:
name|devstr
operator|=
literal|"line out"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
case|:
name|devstr
operator|=
literal|"speaker"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
case|:
name|devstr
operator|=
literal|"headphones out"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
case|:
name|devstr
operator|=
literal|"CD"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_OUT
case|:
name|devstr
operator|=
literal|"SPDIF out"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_OUT
case|:
name|devstr
operator|=
literal|"digital (other) out"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MODEM_LINE
case|:
name|devstr
operator|=
literal|"modem, line side"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MODEM_HANDSET
case|:
name|devstr
operator|=
literal|"modem, handset side"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
case|:
name|devstr
operator|=
literal|"line in"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_AUX
case|:
name|devstr
operator|=
literal|"AUX"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
case|:
name|devstr
operator|=
literal|"Mic in"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_TELEPHONY
case|:
name|devstr
operator|=
literal|"telephony"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_IN
case|:
name|devstr
operator|=
literal|"SPDIF in"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_IN
case|:
name|devstr
operator|=
literal|"digital (other) in"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_OTHER
case|:
name|devstr
operator|=
literal|"other"
expr_stmt|;
break|break;
default|default:
name|devstr
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
case|:
name|connstr
operator|=
literal|"jack"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
case|:
name|connstr
operator|=
literal|"none"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
case|:
name|connstr
operator|=
literal|"fixed"
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_BOTH
case|:
name|connstr
operator|=
literal|"jack / fixed"
expr_stmt|;
break|break;
default|default:
name|connstr
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|": "
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|devstr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|" ("
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|connstr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|")"
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_parse
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|wcap
decl_stmt|,
name|cap
decl_stmt|;
name|char
modifier|*
name|typestr
decl_stmt|;
name|nid_t
name|cad
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|wcap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_AUDIO_WIDGET_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|widget_cap
operator|=
name|wcap
expr_stmt|;
name|w
operator|->
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE
argument_list|(
name|wcap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
name|typestr
operator|=
literal|"audio output"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
name|typestr
operator|=
literal|"audio input"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
name|typestr
operator|=
literal|"audio mixer"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
name|typestr
operator|=
literal|"audio selector"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
name|typestr
operator|=
literal|"pin"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_POWER_WIDGET
case|:
name|typestr
operator|=
literal|"power widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VOLUME_WIDGET
case|:
name|typestr
operator|=
literal|"volume widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
case|:
name|typestr
operator|=
literal|"beep widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VENDOR_WIDGET
case|:
name|typestr
operator|=
literal|"vendor widget"
expr_stmt|;
break|break;
default|default:
name|typestr
operator|=
literal|"unknown type"
expr_stmt|;
break|break;
block|}
name|strlcpy
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|typestr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_POWER_CTRL
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|hdac_widget_connection_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_OUT_AMP
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_AMP_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|outamp_cap
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_IN_AMP
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_AMP_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_INPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|inamp_cap
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_FORMAT_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
name|cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_STREAM_FORMATS
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
operator|(
name|cap
operator|!=
literal|0
operator|)
condition|?
name|cap
else|:
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
expr_stmt|;
name|cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_PCM_SIZE_RATE
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
operator|(
name|cap
operator|!=
literal|0
operator|)
condition|?
name|cap
else|:
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|hdac_widget_pin_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_widget
modifier|*
name|hdac_widget_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|)
block|{
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|widget
operator|==
name|NULL
operator|||
name|nid
operator|<
name|devinfo
operator|->
name|startnode
operator|||
name|nid
operator|>=
name|devinfo
operator|->
name|endnode
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|devinfo
operator|->
name|widget
index|[
name|nid
operator|-
name|devinfo
operator|->
name|startnode
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hda_poll_channel
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|uint32_t
name|sz
decl_stmt|,
name|delta
decl_stmt|;
specifier|volatile
name|uint32_t
name|ptr
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|active
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sz
operator|=
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|ptr
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDLPIB
argument_list|)
expr_stmt|;
name|ch
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|%=
name|sz
expr_stmt|;
name|ptr
operator|&=
operator|~
operator|(
name|ch
operator|->
name|blksz
operator|-
literal|1
operator|)
expr_stmt|;
name|delta
operator|=
operator|(
name|sz
operator|+
name|ptr
operator|-
name|ch
operator|->
name|prevptr
operator|)
operator|%
name|sz
expr_stmt|;
if|if
condition|(
name|delta
operator|<
name|ch
operator|->
name|blksz
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch
operator|->
name|prevptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|hda_chan_active
parameter_list|(
name|sc
parameter_list|)
value|((sc)->play.active + (sc)->rec.active)
end_define

begin_function
specifier|static
name|void
name|hda_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|trigger
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
operator|||
name|hda_chan_active
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|trigger
operator||=
operator|(
name|hda_poll_channel
argument_list|(
operator|&
name|sc
operator|->
name|play
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|trigger
operator||=
operator|(
name|hda_poll_channel
argument_list|(
operator|&
name|sc
operator|->
name|rec
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|/* XXX */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
literal|1
comment|/*sc->poll_ticks*/
argument_list|,
name|hda_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|&
literal|1
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|play
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|trigger
operator|&
literal|2
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rec
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_rirb_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|,
modifier|*
name|rirb
decl_stmt|;
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|struct
name|hdac_command_list
modifier|*
name|commands
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|resp
decl_stmt|;
name|uint8_t
name|rirbwp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirbwp
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBWP
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_tag
argument_list|,
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rirb_rp
operator|!=
name|rirbwp
condition|)
block|{
name|sc
operator|->
name|rirb_rp
operator|++
expr_stmt|;
name|sc
operator|->
name|rirb_rp
operator|%=
name|sc
operator|->
name|rirb_size
expr_stmt|;
name|rirb
operator|=
operator|&
name|rirb_base
index|[
name|sc
operator|->
name|rirb_rp
index|]
expr_stmt|;
name|cad
operator|=
name|HDAC_RIRB_RESPONSE_EX_SDATA_IN
argument_list|(
name|rirb
operator|->
name|response_ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|cad
operator|<
literal|0
operator|||
name|cad
operator|>=
name|HDAC_CODEC_MAX
operator|||
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|resp
operator|=
name|rirb
operator|->
name|response
expr_stmt|;
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
expr_stmt|;
name|commands
operator|=
name|codec
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|rirb
operator|->
name|response_ex
operator|&
name|HDAC_RIRB_RESPONSE_EX_UNSOLICITED
condition|)
block|{
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_wp
operator|++
index|]
operator|=
operator|(
name|cad
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|resp
operator|>>
literal|26
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sc
operator|->
name|unsolq_wp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commands
operator|!=
name|NULL
operator|&&
name|commands
operator|->
name|num_commands
operator|>
literal|0
operator|&&
name|codec
operator|->
name|responses_received
operator|<
name|commands
operator|->
name|num_commands
condition|)
name|commands
operator|->
name|responses
index|[
name|codec
operator|->
name|responses_received
operator|++
index|]
operator|=
name|resp
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_unsolq_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|unsolq_st
operator|==
name|HDAC_UNSOLQ_READY
condition|)
block|{
name|sc
operator|->
name|unsolq_st
operator|=
name|HDAC_UNSOLQ_BUSY
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|unsolq_rp
operator|!=
name|sc
operator|->
name|unsolq_wp
condition|)
block|{
name|cad
operator|=
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_rp
index|]
operator|>>
literal|16
expr_stmt|;
name|tag
operator|=
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_rp
operator|++
index|]
operator|&
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|unsolq_rp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
name|hdac_unsolicited_handler
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|unsolq_st
operator|=
name|HDAC_UNSOLQ_READY
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
name|max
argument_list|(
name|hz
operator|>>
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_stop
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|HDAC_SDCTL_IOCE
operator||
name|HDAC_SDCTL_FEIE
operator||
name|HDAC_SDCTL_DEIE
operator||
name|HDAC_SDCTL_RUN
operator|)
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ch
operator|->
name|active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
block|{
name|int
name|pollticks
decl_stmt|;
if|if
condition|(
name|hda_chan_active
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|sc
operator|->
name|poll_ticks
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|play
operator|.
name|active
operator|!=
literal|0
condition|)
name|ch
operator|=
operator|&
name|sc
operator|->
name|play
expr_stmt|;
else|else
name|ch
operator|=
operator|&
name|sc
operator|->
name|rec
expr_stmt|;
name|pollticks
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|hz
operator|*
name|ch
operator|->
name|blksz
operator|)
operator|/
operator|(
operator|(
name|uint64_t
operator|)
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|*
name|sndbuf_getspd
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|)
expr_stmt|;
name|pollticks
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|pollticks
operator|>
name|hz
condition|)
name|pollticks
operator|=
name|hz
expr_stmt|;
if|if
condition|(
name|pollticks
operator|<
literal|1
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: pollticks=%d< 1 !\n"
argument|, 					    __func__, pollticks);
argument_list|)
empty_stmt|;
name|pollticks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pollticks
operator|>
name|sc
operator|->
name|poll_ticks
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: pollticks %d -> %d\n"
argument|, 					    __func__, sc->poll_ticks, 					    pollticks);
argument_list|)
empty_stmt|;
name|sc
operator|->
name|poll_ticks
operator|=
name|pollticks
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
literal|1
argument_list|,
name|hda_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|ch
operator|->
name|off
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_start
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
block|{
name|int
name|pollticks
decl_stmt|;
name|pollticks
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|hz
operator|*
name|ch
operator|->
name|blksz
operator|)
operator|/
operator|(
operator|(
name|uint64_t
operator|)
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|*
name|sndbuf_getspd
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|)
expr_stmt|;
name|pollticks
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|pollticks
operator|>
name|hz
condition|)
name|pollticks
operator|=
name|hz
expr_stmt|;
if|if
condition|(
name|pollticks
operator|<
literal|1
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: pollticks=%d< 1 !\n"
argument|, 				    __func__, pollticks);
argument_list|)
empty_stmt|;
name|pollticks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hda_chan_active
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|||
name|pollticks
operator|<
name|sc
operator|->
name|poll_ticks
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (hda_chan_active(sc) ==
literal|0
argument|) { 					device_printf(sc->dev,
literal|"%s: pollticks=%d\n"
argument|, 					    __func__, pollticks); 				} else { 					device_printf(sc->dev,
literal|"%s: pollticks %d -> %d\n"
argument|, 					    __func__, sc->poll_ticks, 					    pollticks); 				}
argument_list|)
empty_stmt|;
name|sc
operator|->
name|poll_ticks
operator|=
name|pollticks
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
literal|1
argument_list|,
name|hda_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_RUN
expr_stmt|;
block|}
else|else
block|{
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
literal|1
operator|<<
operator|(
name|ch
operator|->
name|off
operator|>>
literal|5
operator|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_IOCE
operator||
name|HDAC_SDCTL_FEIE
operator||
name|HDAC_SDCTL_DEIE
operator||
name|HDAC_SDCTL_RUN
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ch
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_reset
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|timeout
init|=
literal|1000
decl_stmt|;
name|int
name|to
init|=
name|timeout
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_SRST
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
do|do
block|{
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timeout in reset\n"
argument_list|)
expr_stmt|;
block|}
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL_SRST
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|to
operator|=
name|timeout
expr_stmt|;
do|do
block|{
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to
condition|)
do|;
if|if
condition|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't reset!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_setid
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL2
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL2_STRM_MASK
expr_stmt|;
name|ctl
operator||=
name|ch
operator|->
name|sid
operator|<<
name|HDAC_SDCTL2_STRM_SHIFT
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL2
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_bdl_setup
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_bdle
modifier|*
name|bdle
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|blksz
decl_stmt|,
name|blkcnt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
operator|(
name|uint64_t
operator|)
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
name|bdle
operator|=
operator|(
expr|struct
name|hdac_bdle
operator|*
operator|)
name|ch
operator|->
name|bdl_dma
operator|.
name|dma_vaddr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
block|{
name|blksz
operator|=
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|blkcnt
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|blksz
operator|=
name|ch
operator|->
name|blksz
expr_stmt|;
name|blkcnt
operator|=
name|ch
operator|->
name|blkcnt
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blkcnt
condition|;
name|i
operator|++
operator|,
name|bdle
operator|++
control|)
block|{
name|bdle
operator|->
name|addrl
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|bdle
operator|->
name|addrh
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|bdle
operator|->
name|len
operator|=
name|blksz
expr_stmt|;
name|bdle
operator|->
name|ioc
operator|=
literal|1
operator|^
name|sc
operator|->
name|polling
expr_stmt|;
name|addr
operator|+=
name|blksz
expr_stmt|;
block|}
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCBL
argument_list|,
name|blksz
operator|*
name|blkcnt
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDLVI
argument_list|,
name|blkcnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|ch
operator|->
name|bdl_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDBDPL
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDBDPU
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_bdl_alloc
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ch
operator|->
name|bdl_dma
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_bdle
argument_list|)
operator|*
name|HDA_BDL_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't alloc bdl\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|hdac_dma_nocache
argument_list|(
name|ch
operator|->
name|bdl_dma
operator|.
name|dma_vaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_amp_set_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|nid_t
name|cad
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|lmute
parameter_list|,
name|int
name|rmute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|uint16_t
name|v
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|left
operator|!=
name|right
operator|||
name|lmute
operator|!=
name|rmute
condition|)
block|{
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|lmute
operator|<<
literal|7
operator|)
operator||
name|left
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_AMP_GAIN_MUTE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|v
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|rmute
operator|<<
literal|7
operator|)
operator||
name|right
expr_stmt|;
block|}
else|else
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|3
operator|<<
literal|12
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|lmute
operator|<<
literal|7
operator|)
operator||
name|left
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_AMP_GAIN_MUTE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|v
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_amp_set
parameter_list|(
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
parameter_list|,
name|uint32_t
name|mute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|nid_t
name|nid
decl_stmt|,
name|cad
decl_stmt|;
name|int
name|lmute
decl_stmt|,
name|rmute
decl_stmt|;
if|if
condition|(
name|ctl
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|->
name|codec
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|ctl
operator|->
name|widget
operator|->
name|nid
expr_stmt|;
if|if
condition|(
name|mute
operator|==
name|HDA_AMP_MUTE_DEFAULT
condition|)
block|{
name|lmute
operator|=
name|HDA_AMP_LEFT_MUTED
argument_list|(
name|ctl
operator|->
name|muted
argument_list|)
expr_stmt|;
name|rmute
operator|=
name|HDA_AMP_RIGHT_MUTED
argument_list|(
name|ctl
operator|->
name|muted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lmute
operator|=
name|HDA_AMP_LEFT_MUTED
argument_list|(
name|mute
argument_list|)
expr_stmt|;
name|rmute
operator|=
name|HDA_AMP_RIGHT_MUTED
argument_list|(
name|mute
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_OUT
condition|)
name|hdac_audio_ctl_amp_set_internal
argument_list|(
name|sc
argument_list|,
name|cad
argument_list|,
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|,
name|lmute
argument_list|,
name|rmute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_IN
condition|)
name|hdac_audio_ctl_amp_set_internal
argument_list|(
name|sc
argument_list|,
name|cad
argument_list|,
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|,
name|lmute
argument_list|,
name|rmute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
name|right
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_connection_select
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|nconns
operator|<
literal|1
operator|||
name|index
operator|>
operator|(
name|w
operator|->
name|nconns
operator|-
literal|1
operator|)
condition|)
return|return;
name|hdac_command
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
argument_list|,
name|HDA_CMD_SET_CONNECTION_SELECT_CONTROL
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|index
argument_list|)
argument_list|,
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * uint32_t hdac_command_sendone_internal  *  * Wrapper function that sends only one command to a given codec  ****************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|hdac_command_sendone_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|verb
parameter_list|,
name|nid_t
name|cad
parameter_list|)
block|{
name|struct
name|hdac_command_list
name|cl
decl_stmt|;
name|uint32_t
name|response
init|=
name|HDAC_INVALID
decl_stmt|;
if|if
condition|(
operator|!
name|hdac_lockowned
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING!!!! mtx not owned!!!!\n"
argument_list|)
expr_stmt|;
name|cl
operator|.
name|num_commands
operator|=
literal|1
expr_stmt|;
name|cl
operator|.
name|verbs
operator|=
operator|&
name|verb
expr_stmt|;
name|cl
operator|.
name|responses
operator|=
operator|&
name|response
expr_stmt|;
name|hdac_command_send_internal
argument_list|(
name|sc
argument_list|,
operator|&
name|cl
argument_list|,
name|cad
argument_list|)
expr_stmt|;
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * hdac_command_send_internal  *  * Send a command list to the codec via the corb. We queue as much verbs as  * we can and msleep on the codec. When the interrupt get the responses  * back from the rirb, it will wake us up so we can queue the remaining verbs  * if any.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_command_send_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_command_list
modifier|*
name|commands
parameter_list|,
name|nid_t
name|cad
parameter_list|)
block|{
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|int
name|corbrp
decl_stmt|;
name|uint32_t
modifier|*
name|corb
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|retry
init|=
literal|10
decl_stmt|;
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|==
name|NULL
operator|||
name|commands
operator|==
name|NULL
operator|||
name|commands
operator|->
name|num_commands
operator|<
literal|1
condition|)
return|return;
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
expr_stmt|;
name|codec
operator|->
name|commands
operator|=
name|commands
expr_stmt|;
name|codec
operator|->
name|responses_received
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|verbs_sent
operator|=
literal|0
expr_stmt|;
name|corb
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|corb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
do|do
block|{
if|if
condition|(
name|codec
operator|->
name|verbs_sent
operator|!=
name|commands
operator|->
name|num_commands
condition|)
block|{
comment|/* Queue as many verbs as possible */
name|corbrp
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|corb_dma
operator|.
name|dma_tag
argument_list|,
name|sc
operator|->
name|corb_dma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|codec
operator|->
name|verbs_sent
operator|!=
name|commands
operator|->
name|num_commands
operator|&&
operator|(
operator|(
name|sc
operator|->
name|corb_wp
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|corb_size
operator|)
operator|!=
name|corbrp
condition|)
block|{
name|sc
operator|->
name|corb_wp
operator|++
expr_stmt|;
name|sc
operator|->
name|corb_wp
operator|%=
name|sc
operator|->
name|corb_size
expr_stmt|;
name|corb
index|[
name|sc
operator|->
name|corb_wp
index|]
operator|=
name|commands
operator|->
name|verbs
index|[
name|codec
operator|->
name|verbs_sent
operator|++
index|]
expr_stmt|;
block|}
comment|/* Send the verbs to the codecs */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|corb_dma
operator|.
name|dma_tag
argument_list|,
name|sc
operator|->
name|corb_dma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBWP
argument_list|,
name|sc
operator|->
name|corb_wp
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|&&
operator|--
name|timeout
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|codec
operator|->
name|verbs_sent
operator|!=
name|commands
operator|->
name|num_commands
operator|||
name|codec
operator|->
name|responses_received
operator|!=
name|commands
operator|->
name|num_commands
operator|)
operator|&&
operator|--
name|retry
condition|)
do|;
if|if
condition|(
name|retry
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: TIMEOUT numcmd=%d, sent=%d, received=%d\n"
argument_list|,
name|__func__
argument_list|,
name|commands
operator|->
name|num_commands
argument_list|,
name|codec
operator|->
name|verbs_sent
argument_list|,
name|codec
operator|->
name|responses_received
argument_list|)
expr_stmt|;
name|codec
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|codec
operator|->
name|responses_received
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|verbs_sent
operator|=
literal|0
expr_stmt|;
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * Device Methods  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  * int hdac_probe(device_t)  *  * Probe for the presence of an hdac. If none is found, check for a generic  * match using the subclass of the device.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|class
decl_stmt|,
name|subclass
decl_stmt|;
name|char
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|model
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|model
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ENXIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_DEVICES_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
operator|==
name|model
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|hdac_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|model
argument_list|)
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|hdac_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ENXIO
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
literal|"Generic"
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ENXIO
condition|)
block|{
name|strlcat
argument_list|(
name|desc
argument_list|,
literal|" High Definition Audio Controller"
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hdac_channel_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_chan
modifier|*
name|ch
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|play
expr_stmt|;
name|ch
operator|->
name|off
operator|=
operator|(
name|sc
operator|->
name|num_iss
operator|+
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|playcnt
operator|)
operator|<<
literal|5
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|PCMDIR_PLAY
expr_stmt|;
name|ch
operator|->
name|sid
operator|=
operator|++
name|sc
operator|->
name|streamcnt
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|playcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|rec
expr_stmt|;
name|ch
operator|->
name|off
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|reccnt
operator|<<
literal|5
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|PCMDIR_REC
expr_stmt|;
name|ch
operator|->
name|sid
operator|=
operator|++
name|sc
operator|->
name|streamcnt
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|reccnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_FIXEDRATE
condition|)
block|{
name|ch
operator|->
name|caps
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|caps
operator|.
name|maxspeed
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ch
operator|->
name|b
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sc
operator|->
name|chan_size
operator|/
name|sc
operator|->
name|chan_blkcnt
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|sc
operator|->
name|chan_blkcnt
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdac_bdl_alloc
argument_list|(
name|ch
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ch
operator|->
name|blkcnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|b
argument_list|,
name|sc
operator|->
name|chan_dmat
argument_list|,
name|sc
operator|->
name|chan_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hdac_dma_nocache
argument_list|(
name|ch
operator|->
name|b
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|caps
operator|.
name|fmtlist
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|format
operator|==
name|ch
operator|->
name|caps
operator|.
name|fmtlist
index|[
name|i
index|]
condition|)
block|{
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|uint32_t
name|spd
init|=
literal|0
decl_stmt|,
name|threshold
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|spd
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
expr_stmt|;
name|threshold
operator|=
name|spd
operator|+
operator|(
operator|(
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|spd
operator|)
operator|>>
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<
name|threshold
condition|)
break|break;
block|}
if|if
condition|(
name|spd
operator|==
literal|0
condition|)
comment|/* impossible */
name|ch
operator|->
name|spd
operator|=
literal|48000
expr_stmt|;
else|else
name|ch
operator|->
name|spd
operator|=
name|spd
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_setup
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nid_t
name|cad
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|uint16_t
name|fmt
decl_stmt|;
name|fmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S16_LE
condition|)
name|fmt
operator||=
name|ch
operator|->
name|bit16
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S32_LE
condition|)
name|fmt
operator||=
name|ch
operator|->
name|bit32
operator|<<
literal|4
expr_stmt|;
else|else
name|fmt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_RATE_TAB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|valid
operator|&&
name|ch
operator|->
name|spd
operator|==
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|rate
condition|)
block|{
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|mul
expr_stmt|;
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|div
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_STEREO
condition|)
name|fmt
operator||=
literal|1
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDFMT
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: PCMDIR_%s: Stream setup nid=%d "
literal|"fmt=0x%08x\n"
argument|, 			    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, 			    ch->io[i], fmt);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_CONV_FMT
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|fmt
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_CONV_STREAM_CHAN
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|ch
operator|->
name|sid
operator|<<
literal|4
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blksz
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|blksz
operator|&=
operator|~
literal|0x7f
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
literal|0x80
condition|)
name|blksz
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
operator|(
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
operator|)
operator|>
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
condition|)
name|blksz
operator|=
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|/
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
operator|(
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|!=
name|blksz
operator|||
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|!=
name|ch
operator|->
name|blkcnt
operator|)
operator|&&
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|b
argument_list|,
name|ch
operator|->
name|blkcnt
argument_list|,
name|blksz
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed blksz=%u blkcnt=%u\n"
argument_list|,
name|__func__
argument_list|,
name|blksz
argument_list|,
name|ch
operator|->
name|blkcnt
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|blksz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_channel_stop
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|nid_t
name|cad
init|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdac_stream_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_CONV_STREAM_CHAN
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_channel_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|ch
operator|->
name|ptr
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|prevptr
operator|=
literal|0
expr_stmt|;
name|hdac_stream_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_bdl_setup
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_setid
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_setup
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|hdac_channel_start
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|hdac_channel_stop
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ptr
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
name|ptr
operator|=
name|ch
operator|->
name|ptr
expr_stmt|;
else|else
name|ptr
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDLPIB
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Round to available space and force 128 bytes aligment. 	 */
name|ptr
operator|%=
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|ptr
operator|&=
operator|~
literal|0x7f
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|hdac_channel_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|&
operator|(
operator|(
expr|struct
name|hdac_chan
operator|*
operator|)
name|data
operator|)
operator|->
name|caps
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdac_channel_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|hdac_channel_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|hdac_channel_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|hdac_channel_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|hdac_channel_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|hdac_channel_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|hdac_channel_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|hdac_channel_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|hdac_channel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|recmask
decl_stmt|,
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|softpcmvol
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|recmask
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_HP_SWITCH_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
operator|&&
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|id
operator|==
name|id
operator|)
condition|)
continue|continue;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_hp_switch
index|[
name|i
index|]
operator|.
name|hpnid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|enable
operator|!=
literal|0
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|HDA_PARAM_AUDIO_WIDGET_CAP_UNSOL_CAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE_ENABLE
operator||
name|HDAC_UNSOLTAG_EVENT_HP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|hdac_hp_switch_handler
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Enabling headphone/speaker "
literal|"audio routing switching:\n"
argument|); 				device_printf(sc->dev,
literal|"HDA_DEBUG: \tindex=%d nid=%d "
literal|"pci_subvendor=0x%08x "
literal|"codec=0x%08x\n"
argument|, 				    i, w->nid, sc->pci_subvendor, id);
argument_list|)
empty_stmt|;
block|}
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_EAPD_SWITCH_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
operator|&&
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|id
operator|==
name|id
operator|)
condition|)
continue|continue;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|eapdnid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|==
name|HDAC_INVALID
condition|)
break|break;
name|mask
operator||=
name|SOUND_MASK_OGAIN
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|mask
operator||=
name|w
operator|->
name|ctlflags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_RECSEL
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|recmask
operator||=
name|cw
operator|->
name|ctlflags
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|SOUND_MASK_PCM
operator|)
condition|)
block|{
name|softpcmvol
operator|=
literal|1
expr_stmt|;
name|mask
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
block|}
else|else
name|softpcmvol
operator|=
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_SOFTPCMVOL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ctl
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
name|SOUND_MASK_PCM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|step
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|softpcmvol
operator|==
literal|1
operator|||
name|ctl
operator|==
name|NULL
condition|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
name|d
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|d
operator|->
name|flags
operator||=
name|SD_F_SOFTPCMVOL
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: %s Soft PCM volume\n"
argument|, 				    (softpcmvol ==
literal|1
argument|) ?
literal|"Forcing"
argument|:
literal|"Enabling"
argument|);
argument_list|)
empty_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 		 * XXX Temporary quirk for STAC9220, until the parser 		 *     become smarter. 		 */
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_STAC9220
condition|)
block|{
name|mask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
literal|11
operator|&&
name|ctl
operator|->
name|index
operator|==
literal|0
condition|)
block|{
name|ctl
operator|->
name|ossmask
operator|=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|ctl
operator|->
name|ossval
operator|=
literal|100
operator||
operator|(
literal|100
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
name|ctl
operator|->
name|ossmask
operator|&=
operator|~
name|SOUND_MASK_VOLUME
expr_stmt|;
block|}
block|}
else|else
block|{
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MASK_PCM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|SOUND_MASK_VOLUME
operator|)
condition|)
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|HDA_FLAG_MATCH
argument_list|(
name|ctl
operator|->
name|ossmask
argument_list|,
name|SOUND_MASK_VOLUME
operator||
name|SOUND_MASK_PCM
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|->
name|mute
operator|==
literal|1
operator|&&
name|ctl
operator|->
name|step
operator|==
literal|0
operator|)
condition|)
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|recmask
operator|&=
operator|~
operator|(
name|SOUND_MASK_PCM
operator||
name|SOUND_MASK_RECLEV
operator||
name|SOUND_MASK_SPEAKER
operator|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|recmask
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|id
decl_stmt|,
name|mute
decl_stmt|;
name|int
name|lvol
decl_stmt|,
name|rvol
decl_stmt|,
name|mlvol
decl_stmt|,
name|mrvol
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_OGAIN
condition|)
block|{
name|uint32_t
name|orig
decl_stmt|;
comment|/*if (left != right || !(left == 0 || left == 1)) { 			hdac_unlock(sc); 			return (-1); 		}*/
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_EAPD_SWITCH_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
operator|&&
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|id
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|HDAC_EAPD_SWITCH_LEN
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|eapdnid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|==
name|HDAC_INVALID
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|orig
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&=
operator|~
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator||=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
if|if
condition|(
name|orig
operator|!=
name|w
operator|->
name|param
operator|.
name|eapdbtl
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|hdac_eapd_switch
index|[
name|i
index|]
operator|.
name|hp_switch
operator|!=
literal|0
condition|)
name|hdac_hp_switch_handler
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|val
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_EAPDINV
condition|)
name|val
operator|^=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_EAPD_BTL_ENABLE
argument_list|(
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|val
argument_list|)
argument_list|,
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|left
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_VOLUME
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|mvol
operator|=
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
expr_stmt|;
name|mlvol
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|mvol
operator|&
literal|0x7f
expr_stmt|;
name|mrvol
operator|=
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|mvol
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|lvol
operator|=
literal|0
expr_stmt|;
name|rvol
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|SOUND_MIXER_VOLUME
case|:
name|lvol
operator|=
operator|(
operator|(
name|ctl
operator|->
name|ossval
operator|&
literal|0x7f
operator|)
operator|*
name|left
operator|)
operator|/
literal|100
expr_stmt|;
name|lvol
operator|=
operator|(
name|lvol
operator|*
name|ctl
operator|->
name|step
operator|)
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
operator|(
operator|(
operator|(
name|ctl
operator|->
name|ossval
operator|>>
literal|8
operator|)
operator|&
literal|0x7f
operator|)
operator|*
name|right
operator|)
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
operator|(
name|rvol
operator|*
name|ctl
operator|->
name|step
operator|)
operator|/
literal|100
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ctl
operator|->
name|ossmask
operator|&
name|SOUND_MASK_VOLUME
condition|)
block|{
name|lvol
operator|=
operator|(
name|left
operator|*
name|mlvol
operator|)
operator|/
literal|100
expr_stmt|;
name|lvol
operator|=
operator|(
name|lvol
operator|*
name|ctl
operator|->
name|step
operator|)
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
operator|(
name|right
operator|*
name|mrvol
operator|)
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
operator|(
name|rvol
operator|*
name|ctl
operator|->
name|step
operator|)
operator|/
literal|100
expr_stmt|;
block|}
else|else
block|{
name|lvol
operator|=
operator|(
name|left
operator|*
name|ctl
operator|->
name|step
operator|)
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
operator|(
name|right
operator|*
name|ctl
operator|->
name|step
operator|)
operator|/
literal|100
expr_stmt|;
block|}
name|ctl
operator|->
name|ossval
operator|=
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
block|}
name|mute
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|step
operator|<
literal|1
condition|)
block|{
name|mute
operator||=
operator|(
name|left
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_LEFT
else|:
operator|(
name|ctl
operator|->
name|muted
operator|&
name|HDA_AMP_MUTE_LEFT
operator|)
expr_stmt|;
name|mute
operator||=
operator|(
name|right
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_RIGHT
else|:
operator|(
name|ctl
operator|->
name|muted
operator|&
name|HDA_AMP_MUTE_RIGHT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mute
operator||=
operator|(
name|lvol
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_LEFT
else|:
operator|(
name|ctl
operator|->
name|muted
operator|&
name|HDA_AMP_MUTE_LEFT
operator|)
expr_stmt|;
name|mute
operator||=
operator|(
name|rvol
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_RIGHT
else|:
operator|(
name|ctl
operator|->
name|muted
operator|&
name|HDA_AMP_MUTE_RIGHT
operator|)
expr_stmt|;
block|}
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|)
expr_stmt|;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|uint32_t
name|src
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ret
init|=
name|src
decl_stmt|,
name|target
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|target
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|target
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
break|break;
block|}
block|}
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_RECSEL
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|target
operator|==
name|SOUND_MASK_VOLUME
operator|&&
name|cw
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|)
operator|||
operator|(
name|target
operator|!=
name|SOUND_MASK_VOLUME
operator|&&
name|cw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|ctlflags
operator|&
name|target
condition|)
block|{
name|hdac_widget_connection_select
argument_list|(
name|w
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ret
operator|=
name|target
expr_stmt|;
name|j
operator|+=
name|w
operator|->
name|nconns
expr_stmt|;
block|}
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdac_audio_ctl_ossmixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|hdac_audio_ctl_ossmixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|hdac_audio_ctl_ossmixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|hdac_audio_ctl_ossmixer_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|hdac_audio_ctl_ossmixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************************  * int hdac_attach(device_t)  *  * Attach the device into the kernel. Interrupts usually won't be enabled  * when this function is called. Setup everything that doesn't require  * interrupts and defer probing of codecs until interrupts are enabled.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|HDAC_MTX_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lock
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"mutex creation failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|pci_subvendor
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_subdevice
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|sc
operator|->
name|pci_subvendor
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|poll_ticks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"polling"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|chan_size
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
name|HDA_BUFSZ_MIN
argument_list|,
name|HDA_BUFSZ_DEFAULT
argument_list|,
name|HDA_BUFSZ_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"blocksize"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|&=
operator|~
literal|0x7f
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0x80
condition|)
name|i
operator|=
literal|0x80
expr_stmt|;
name|sc
operator|->
name|chan_blkcnt
operator|=
name|sc
operator|->
name|chan_size
operator|/
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|chan_blkcnt
operator|>>
name|i
condition|)
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|chan_blkcnt
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chan_blkcnt
operator|<
name|HDA_BDL_MIN
condition|)
name|sc
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_MIN
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|chan_blkcnt
operator|>
name|HDA_BDL_MAX
condition|)
name|sc
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_MAX
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_DEFAULT
expr_stmt|;
name|result
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|HDAC_DMA_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
comment|/* filtfunc */
name|NULL
argument_list|,
comment|/* fistfuncarg */
name|sc
operator|->
name|chan_size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sc
operator|->
name|chan_size
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|chan_dmat
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|hdabus
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate resources */
name|result
operator|=
name|hdac_mem_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|result
operator|=
name|hdac_irq_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Get Capabilities */
name|result
operator|=
name|hdac_get_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Allocate CORB and RIRB dma memory */
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|,
name|sc
operator|->
name|corb_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|,
name|sc
operator|->
name|rirb_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_rirb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Quiesce everything */
name|hdac_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable PCI-Express QOS */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0x44
argument_list|,
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0x44
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xf8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the CORB and RIRB */
name|hdac_corb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_rirb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Defer remaining of initialization until interrupts are enabled */
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|hdac_attach2
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
if|if
condition|(
name|cold
operator|==
literal|0
operator|||
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|NULL
expr_stmt|;
name|hdac_attach2
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_attach_fail
label|:
name|hdac_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|corb_dma
argument_list|)
expr_stmt|;
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_mem_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nid_t
name|cad
decl_stmt|,
name|nid
decl_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|devinfo
operator|->
name|nid
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUB_NODE_COUNT
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|nodecnt
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_TOTAL
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|startnode
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_START
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|endnode
operator|=
name|devinfo
operator|->
name|startnode
operator|+
name|devinfo
operator|->
name|nodecnt
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"       Vendor: 0x%08x\n"
argument|, 		    devinfo->vendor_id); 		device_printf(sc->dev,
literal|"       Device: 0x%08x\n"
argument|, 		    devinfo->device_id); 		device_printf(sc->dev,
literal|"     Revision: 0x%08x\n"
argument|, 		    devinfo->revision_id); 		device_printf(sc->dev,
literal|"     Stepping: 0x%08x\n"
argument|, 		    devinfo->stepping_id); 		device_printf(sc->dev,
literal|"PCI Subvendor: 0x%08x\n"
argument|, 		    sc->pci_subvendor); 		device_printf(sc->dev,
literal|"        Nodes: start=%d "
literal|"endnode=%d total=%d\n"
argument|, 		    devinfo->startnode, devinfo->endnode, devinfo->nodecnt);
argument_list|)
empty_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_STREAM_FORMATS
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_PCM_SIZE_RATE
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|outamp_cap
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_INPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|inamp_cap
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|nodecnt
operator|>
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|widget
operator|=
operator|(
expr|struct
name|hdac_widget
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|devinfo
operator|->
name|widget
operator|)
argument_list|)
operator|*
name|devinfo
operator|->
name|nodecnt
argument_list|,
name|M_HDAC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|devinfo
operator|->
name|widget
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|widget
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to allocate widgets!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|endnode
operator|=
name|devinfo
operator|->
name|startnode
expr_stmt|;
name|devinfo
operator|->
name|nodecnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Ghost widget! nid=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|->
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|w
operator|->
name|nid
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|enable
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|pflags
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|ctlflags
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|HDAC_INVALID
expr_stmt|;
name|hdac_widget_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctls
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|,
name|max
decl_stmt|,
name|ocap
decl_stmt|,
name|icap
decl_stmt|;
name|int
name|mute
decl_stmt|,
name|offset
decl_stmt|,
name|step
decl_stmt|,
name|size
decl_stmt|;
comment|/* XXX This is redundant */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|!=
literal|0
condition|)
name|max
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|max
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|max
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|1
condition|)
return|return;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ctls
operator|=
operator|(
expr|struct
name|hdac_audio_ctl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctls
argument_list|)
operator|*
name|max
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctls
operator|==
name|NULL
condition|)
block|{
comment|/* Blekh! */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to allocate ctls!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|cnt
operator|<
name|max
operator|&&
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ocap
operator|=
name|w
operator|->
name|param
operator|.
name|outamp_cap
expr_stmt|;
name|icap
operator|=
name|w
operator|->
name|param
operator|.
name|inamp_cap
expr_stmt|;
if|if
condition|(
name|ocap
operator|!=
literal|0
condition|)
block|{
name|mute
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|step
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|size
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
comment|/*if (offset> step) { 				HDA_BOOTVERBOSE( 					device_printf(sc->dev, 					    "HDA_DEBUG: BUGGY outamp: nid=%d " 					    "[offset=%d> step=%d]\n", 					    w->nid, offset, step); 				); 				offset = step; 			}*/
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDA_CTL_OUT
expr_stmt|;
block|}
if|if
condition|(
name|icap
operator|!=
literal|0
condition|)
block|{
name|mute
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|step
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|size
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|icap
argument_list|)
expr_stmt|;
comment|/*if (offset> step) { 				HDA_BOOTVERBOSE( 					device_printf(sc->dev, 					    "HDA_DEBUG: BUGGY inamp: nid=%d " 					    "[offset=%d> step=%d]\n", 					    w->nid, offset, step); 				); 				offset = step; 			}*/
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|childwidget
operator|=
name|cw
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|index
operator|=
name|j
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDA_CTL_IN
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDA_CTL_IN
expr_stmt|;
break|break;
block|}
block|}
block|}
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|=
name|ctls
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|set
decl_stmt|,
name|unset
decl_stmt|;
block|}
name|hdac_quirks
index|[]
init|=
block|{
comment|/* 	 * XXX Force stereo quirk. Monoural recording / playback 	 *     on few codecs (especially ALC880) seems broken or 	 *     perhaps unsupported. 	 */
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_MATCH_ALL
block|,
name|HDA_QUIRK_FORCESTEREO
block|,
literal|0
block|}
block|,
block|{
name|ACER_ALL_SUBVENDOR
block|,
name|HDA_MATCH_ALL
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_M5200_SUBVENDOR
block|,
name|HDA_CODEC_ALC880
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|MEDION_MD95257_SUBVENDOR
block|,
name|HDA_CODEC_ALC880
block|,
name|HDA_QUIRK_GPIO1
block|,
literal|0
block|}
block|,
block|{
name|ASUS_U5F_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|ASUS_A8JC_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|LENOVO_3KN100_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|SAMSUNG_Q1_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|APPLE_INTEL_MAC
block|,
name|HDA_CODEC_STAC9221
block|,
name|HDA_QUIRK_GPIO0
operator||
name|HDA_QUIRK_GPIO1
block|,
literal|0
block|}
block|,
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_CODEC_CXVENICE
block|,
literal|0
block|,
name|HDA_QUIRK_FORCESTEREO
block|}
block|,
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_CODEC_STACXXXX
block|,
name|HDA_QUIRK_SOFTPCMVOL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_QUIRKS_LEN
value|(sizeof(hdac_quirks) / sizeof(hdac_quirks[0]))
end_define

begin_function
specifier|static
name|void
name|hdac_vendor_patch_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|id
decl_stmt|,
name|subvendor
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|subvendor
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|pci_subvendor
expr_stmt|;
comment|/* 	 * Quirks 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_QUIRKS_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|subvendor
argument_list|)
operator|&&
name|HDA_DEV_MATCH
argument_list|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|id
argument_list|,
name|id
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|set
operator|!=
literal|0
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator||=
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|set
expr_stmt|;
if|if
condition|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|unset
operator|!=
literal|0
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&=
operator|~
operator|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|unset
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|HDA_CODEC_ALC260
case|:
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nid
operator|!=
literal|5
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|HDA_CODEC_ALC880
case|:
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
operator|&&
name|w
operator|->
name|nid
operator|!=
literal|9
operator|&&
name|w
operator|->
name|nid
operator|!=
literal|29
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
operator|&&
name|w
operator|->
name|nid
operator|==
literal|29
condition|)
block|{
name|w
operator|->
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|widget_cap
operator|&=
operator|~
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_MASK
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|widget_cap
operator||=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
operator|<<
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_SHIFT
expr_stmt|;
name|strlcpy
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|"beep widget"
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HDA_CODEC_AD1981HD
case|:
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|enable
operator|!=
literal|0
operator|&&
name|w
operator|->
name|nconns
operator|>
literal|3
condition|)
name|w
operator|->
name|selconn
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|subvendor
operator|==
name|IBM_M52_SUBVENDOR
condition|)
block|{
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
condition|)
name|ctl
operator|->
name|ossmask
operator|=
name|SOUND_MASK_SPEAKER
expr_stmt|;
block|}
break|break;
case|case
name|HDA_CODEC_AD1986A
case|:
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nid
operator|!=
literal|3
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|HDA_CODEC_STAC9221
case|:
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nid
operator|!=
literal|2
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|HDA_CODEC_STAC9221D
case|:
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
operator|&&
name|w
operator|->
name|nid
operator|!=
literal|6
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_getnextdev
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|int
modifier|*
name|dev
init|=
operator|&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ossidx
decl_stmt|;
while|while
condition|(
operator|*
name|dev
operator|<
name|SOUND_MIXER_NRDEVICES
condition|)
block|{
switch|switch
condition|(
operator|*
name|dev
condition|)
block|{
case|case
name|SOUND_MIXER_VOLUME
case|:
case|case
name|SOUND_MIXER_BASS
case|:
case|case
name|SOUND_MIXER_TREBLE
case|:
case|case
name|SOUND_MIXER_PCM
case|:
case|case
name|SOUND_MIXER_SPEAKER
case|:
case|case
name|SOUND_MIXER_LINE
case|:
case|case
name|SOUND_MIXER_MIC
case|:
case|case
name|SOUND_MIXER_CD
case|:
case|case
name|SOUND_MIXER_RECLEV
case|:
case|case
name|SOUND_MIXER_OGAIN
case|:
comment|/* reserved for EAPD switch */
operator|(
operator|*
name|dev
operator|)
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|*
name|dev
operator|)
operator|++
return|;
break|break;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_widget_find_dac_path
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
name|w
operator|->
name|pflags
operator||=
name|HDA_DAC_PATH
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_widget_find_dac_path
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|selconn
operator|=
name|i
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|pflags
operator||=
name|HDA_DAC_PATH
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_widget_find_adc_path
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|conndev
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_widget_find_adc_path
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|selconn
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|pflags
operator||=
name|HDA_ADC_PATH
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
name|conndev
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|&&
operator|(
name|conndev
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
operator|||
name|conndev
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
operator|||
name|conndev
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
operator|)
condition|)
block|{
name|w
operator|->
name|pflags
operator||=
name|HDA_ADC_PATH
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/*case HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER: 		if (w->pflags& HDA_DAC_PATH) { 			w->pflags |= HDA_ADC_PATH; 			ret = 1; 		} 		break;*/
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_audio_ctl_outamp_build
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|nid_t
name|pnid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|pw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|fl
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ossdev
decl_stmt|,
name|conndev
decl_stmt|,
name|strategy
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|pnid
argument_list|)
expr_stmt|;
name|strategy
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|parsing_strategy
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
name|fl
operator||=
name|hdac_audio_ctl_outamp_build
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|i
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|ctlflags
operator||=
name|fl
expr_stmt|;
return|return
operator|(
name|fl
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|&&
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_DAC_PATH
operator|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
comment|/* XXX This should be compressed! */
if|if
condition|(
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|w
operator|->
name|nid
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|pnid
operator|&&
name|ctl
operator|->
name|index
operator|==
name|index
operator|&&
operator|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_IN
operator|)
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|pnid
operator|&&
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
operator|(
name|pw
operator|->
name|nconns
operator|<
literal|2
operator|||
name|pw
operator|->
name|selconn
operator|==
name|index
operator|||
name|pw
operator|->
name|selconn
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_OUT
operator|)
operator|)
operator|||
operator|(
name|strategy
operator|==
name|HDA_PARSE_DIRECT
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|w
operator|->
name|nid
operator|)
condition|)
block|{
comment|/*if (pw != NULL&& pw->selconn == -1) 					pw->selconn = index; 				fl |= SOUND_MASK_VOLUME; 				fl |= SOUND_MASK_PCM; 				ctl->ossmask |= SOUND_MASK_VOLUME; 				ctl->ossmask |= SOUND_MASK_PCM; 				ctl->ossdev = SOUND_MIXER_PCM;*/
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|ctlflags
operator|&
name|SOUND_MASK_PCM
operator|)
operator|||
operator|(
name|pw
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|pw
operator|->
name|ctlflags
operator|&
name|SOUND_MASK_PCM
operator|)
operator|)
condition|)
block|{
name|fl
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|fl
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
name|ctl
operator|->
name|ossdev
operator|=
name|SOUND_MIXER_PCM
expr_stmt|;
name|w
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|w
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pw
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|pw
operator|->
name|selconn
operator|=
name|index
expr_stmt|;
name|pw
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|pw
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
block|}
block|}
block|}
block|}
name|w
operator|->
name|ctlflags
operator||=
name|fl
expr_stmt|;
return|return
operator|(
name|fl
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|&&
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_PATH
operator|)
condition|)
block|{
name|conndev
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
comment|/* XXX This should be compressed! */
if|if
condition|(
operator|(
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|pnid
operator|&&
name|ctl
operator|->
name|index
operator|==
name|index
operator|&&
operator|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_IN
operator|)
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|pnid
operator|&&
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
operator|(
name|pw
operator|->
name|nconns
operator|<
literal|2
operator|||
name|pw
operator|->
name|selconn
operator|==
name|index
operator|||
name|pw
operator|->
name|selconn
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_OUT
operator|)
operator|)
operator|||
operator|(
name|strategy
operator|==
name|HDA_PARSE_DIRECT
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|w
operator|->
name|nid
operator|)
operator|)
operator|&&
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|~
name|SOUND_MASK_VOLUME
operator|)
condition|)
block|{
if|if
condition|(
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|pw
operator|->
name|selconn
operator|=
name|index
expr_stmt|;
name|ossdev
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|conndev
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
case|:
name|ossdev
operator|=
name|SOUND_MIXER_MIC
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
case|:
name|ossdev
operator|=
name|SOUND_MIXER_LINE
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
case|:
name|ossdev
operator|=
name|SOUND_MIXER_CD
expr_stmt|;
break|break;
default|default:
name|ossdev
operator|=
name|hdac_audio_ctl_ossmixer_getnextdev
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ossdev
operator|<
literal|0
condition|)
name|ossdev
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strategy
operator|==
name|HDA_PARSE_MIXER
condition|)
block|{
name|fl
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
block|}
name|fl
operator||=
literal|1
operator|<<
name|ossdev
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
literal|1
operator|<<
name|ossdev
expr_stmt|;
name|ctl
operator|->
name|ossdev
operator|=
name|ossdev
expr_stmt|;
block|}
block|}
name|w
operator|->
name|ctlflags
operator||=
name|fl
expr_stmt|;
return|return
operator|(
name|fl
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
comment|/* XXX This should be compressed! */
if|if
condition|(
operator|(
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|pnid
operator|&&
name|ctl
operator|->
name|index
operator|==
name|index
operator|&&
operator|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_IN
operator|)
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|pnid
operator|&&
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
operator|(
name|pw
operator|->
name|nconns
operator|<
literal|2
operator|||
name|pw
operator|->
name|selconn
operator|==
name|index
operator|||
name|pw
operator|->
name|selconn
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_OUT
operator|)
operator|)
operator|||
operator|(
name|strategy
operator|==
name|HDA_PARSE_DIRECT
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|w
operator|->
name|nid
operator|)
operator|)
operator|&&
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|~
name|SOUND_MASK_VOLUME
operator|)
condition|)
block|{
if|if
condition|(
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|pw
operator|->
name|selconn
operator|=
name|index
expr_stmt|;
name|fl
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|fl
operator||=
name|SOUND_MASK_SPEAKER
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_SPEAKER
expr_stmt|;
name|ctl
operator|->
name|ossdev
operator|=
name|SOUND_MIXER_SPEAKER
expr_stmt|;
block|}
block|}
name|w
operator|->
name|ctlflags
operator||=
name|fl
expr_stmt|;
return|return
operator|(
name|fl
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_audio_ctl_inamp_build
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|fl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*if (!(w->pflags& HDA_ADC_PATH)) 		return (0); 	if (!(w->type == HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT || 	    w->type == HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR)) 		return (0);*/
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|==
name|nid
condition|)
block|{
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_RECLEV
expr_stmt|;
name|w
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_RECLEV
expr_stmt|;
return|return
operator|(
name|SOUND_MASK_RECLEV
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
condition|)
continue|continue;
name|fl
operator|=
name|hdac_audio_ctl_inamp_build
argument_list|(
name|devinfo
argument_list|,
name|cw
operator|->
name|nid
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|!=
literal|0
condition|)
block|{
name|cw
operator|->
name|ctlflags
operator||=
name|fl
expr_stmt|;
name|w
operator|->
name|ctlflags
operator||=
name|fl
expr_stmt|;
return|return
operator|(
name|fl
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_audio_ctl_recsel_build
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|child
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*if (!(w->pflags& HDA_ADC_PATH)) 		return (0); 	if (!(w->type == HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT || 	    w->type == HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR)) 		return (0);*/
comment|/* XXX weak! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|++
name|child
operator|>
literal|1
condition|)
block|{
name|w
operator|->
name|pflags
operator||=
name|HDA_ADC_RECSEL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_audio_ctl_recsel_build
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_audio_build_tree_strategy
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|conndev
decl_stmt|,
name|found_dac
init|=
literal|0
decl_stmt|;
name|int
name|strategy
decl_stmt|;
name|strategy
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|parsing_strategy
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
operator|!
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
continue|continue;
name|conndev
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|conndev
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator|||
name|conndev
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
operator|||
name|conndev
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strategy
operator|==
name|HDA_PARSE_MIXER
operator|&&
operator|!
operator|(
name|cw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|||
name|cw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|hdac_widget_find_dac_path
argument_list|(
name|devinfo
argument_list|,
name|cw
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|selconn
operator|=
name|j
expr_stmt|;
name|w
operator|->
name|pflags
operator||=
name|HDA_DAC_PATH
expr_stmt|;
name|found_dac
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|found_dac
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_build_tree
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|dacs
decl_stmt|,
name|strategy
decl_stmt|;
comment|/* Construct DAC path */
name|strategy
operator|=
name|HDA_PARSE_MIXER
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|parsing_strategy
operator|=
name|strategy
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"HDA_DEBUG: HWiP: HDA Widget Parser - Revision %d\n"
argument|, 		    HDA_WIDGET_PARSER_REV);
argument_list|)
empty_stmt|;
name|dacs
operator|=
name|hdac_audio_build_tree_strategy
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dacs
operator|==
literal|0
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"HDA_DEBUG: HWiP: 0 DAC path found! "
literal|"Retrying parser "
literal|"using HDA_PARSE_DIRECT strategy.\n"
argument|);
argument_list|)
empty_stmt|;
name|strategy
operator|=
name|HDA_PARSE_DIRECT
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|parsing_strategy
operator|=
name|strategy
expr_stmt|;
name|dacs
operator|=
name|hdac_audio_build_tree_strategy
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"HDA_DEBUG: HWiP: Found %d DAC path using HDA_PARSE_%s "
literal|"strategy.\n"
argument|, 		    dacs, (strategy == HDA_PARSE_MIXER) ?
literal|"MIXER"
argument|:
literal|"DIRECT"
argument|);
argument_list|)
empty_stmt|;
comment|/* Construct ADC path */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
operator|(
name|void
operator|)
name|hdac_widget_find_adc_path
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Output mixers */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strategy
operator|==
name|HDA_PARSE_MIXER
operator|&&
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|)
operator|&&
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_DAC_PATH
operator|)
operator|)
operator|||
operator|(
name|strategy
operator|==
name|HDA_PARSE_DIRECT
operator|&&
operator|(
name|w
operator|->
name|pflags
operator|&
operator|(
name|HDA_DAC_PATH
operator||
name|HDA_ADC_PATH
operator|)
operator|)
operator|)
condition|)
block|{
name|w
operator|->
name|ctlflags
operator||=
name|hdac_audio_ctl_outamp_build
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|devinfo
operator|->
name|startnode
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|j
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|!=
name|w
operator|->
name|nid
condition|)
continue|continue;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|ctl
operator|->
name|ossmask
operator||=
name|SOUND_MASK_SPEAKER
expr_stmt|;
name|ctl
operator|->
name|ossdev
operator|=
name|SOUND_MIXER_SPEAKER
expr_stmt|;
name|w
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|w
operator|->
name|ctlflags
operator||=
name|SOUND_MASK_SPEAKER
expr_stmt|;
block|}
block|}
block|}
comment|/* Input mixers (rec) */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
operator|&&
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_PATH
operator|)
condition|)
continue|continue;
name|hdac_audio_ctl_inamp_build
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdac_audio_ctl_recsel_build
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|HDA_COMMIT_CONN
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_COMMIT_CTRL
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_COMMIT_EAPD
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|HDA_COMMIT_GPIO
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|HDA_COMMIT_ALL
value|(HDA_COMMIT_CONN | HDA_COMMIT_CTRL | \ 				HDA_COMMIT_EAPD | HDA_COMMIT_GPIO)
end_define

begin_function
specifier|static
name|void
name|hdac_audio_commit
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|uint32_t
name|cfl
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cfl
operator|&
name|HDA_COMMIT_ALL
operator|)
condition|)
return|return;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
if|if
condition|(
name|cfl
operator|&
name|HDA_COMMIT_GPIO
condition|)
block|{
name|uint32_t
name|gdata
decl_stmt|,
name|gmask
decl_stmt|,
name|gdir
decl_stmt|;
name|int
name|commitgpio
init|=
literal|0
decl_stmt|;
name|gdata
operator|=
literal|0
expr_stmt|;
name|gmask
operator|=
literal|0
expr_stmt|;
name|gdir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|APPLE_INTEL_MAC
condition|)
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_12BIT
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
literal|0x7e7
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_GPIOFLUSH
condition|)
name|commitgpio
operator|=
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_GPIO_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|commitgpio
operator|==
literal|0
condition|)
block|{
name|commitgpio
operator|=
literal|1
expr_stmt|;
name|gdata
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_DATA
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|gmask
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|gdir
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_DIRECTION
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"GPIO init: data=0x%08x "
literal|"mask=0x%08x dir=0x%08x\n"
argument|, 						    gdata, gmask, gdir);
argument_list|)
empty_stmt|;
block|}
name|gdata
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|gmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|gdir
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|commitgpio
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"GPIO commit: data=0x%08x mask=0x%08x "
literal|"dir=0x%08x\n"
argument|, 				    gdata, gmask, gdir);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_GPIO_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gmask
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_GPIO_DIRECTION
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdir
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_GPIO_DATA
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdata
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|nodecnt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
operator|&
name|devinfo
operator|->
name|widget
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cfl
operator|&
name|HDA_COMMIT_CONN
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|selconn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|0
condition|)
name|hdac_widget_connection_select
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|selconn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cfl
operator|&
name|HDA_COMMIT_CTRL
operator|)
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|pflags
operator|&
operator|(
name|HDA_DAC_PATH
operator||
name|HDA_ADC_PATH
operator|)
operator|)
operator|==
operator|(
name|HDA_DAC_PATH
operator||
name|HDA_ADC_PATH
operator|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING: node %d "
literal|"participate both for DAC/ADC!\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|pflags
operator|&
name|HDA_DAC_PATH
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
operator|!=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_PATH
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
operator|(
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
operator|)
expr_stmt|;
block|}
else|else
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
operator|(
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
operator|)
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cfl
operator|&
name|HDA_COMMIT_EAPD
operator|)
operator|&&
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDAC_INVALID
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_EAPDINV
condition|)
name|val
operator|^=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_EAPD_BTL_ENABLE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|val
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_commit
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|mvol
operator|=
literal|100
operator||
operator|(
literal|100
operator|<<
literal|8
operator|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"[%2d] Ctl nid=%d"
argument|, 				    i, (ctl->widget != NULL) ? 				    ctl->widget->nid : -
literal|1
argument|); 				if (ctl->childwidget != NULL) 					printf(
literal|" childnid=%d"
argument|, 					    ctl->childwidget->nid); 				if (ctl->widget == NULL) 					printf(
literal|" NULL WIDGET!"
argument|); 				printf(
literal|" DISABLED\n"
argument|);
argument_list|)
empty_stmt|;
continue|continue;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (ctl->ossmask ==
literal|0
argument|) { 				device_printf(sc->dev,
literal|"[%2d] Ctl nid=%d"
argument|, 				    i, ctl->widget->nid); 				if (ctl->childwidget != NULL) 					printf(
literal|" childnid=%d"
argument|, 					ctl->childwidget->nid); 				printf(
literal|" Bind to NONE\n"
argument|); 		}
argument_list|)
empty_stmt|;
if|if
condition|(
name|ctl
operator|->
name|step
operator|>
literal|0
condition|)
block|{
name|ctl
operator|->
name|ossval
operator|=
operator|(
name|ctl
operator|->
name|left
operator|*
literal|100
operator|)
operator|/
name|ctl
operator|->
name|step
expr_stmt|;
name|ctl
operator|->
name|ossval
operator||=
operator|(
operator|(
name|ctl
operator|->
name|right
operator|*
literal|100
operator|)
operator|/
name|ctl
operator|->
name|step
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
else|else
name|ctl
operator|->
name|ossval
operator|=
literal|0
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_DEFAULT
argument_list|,
name|ctl
operator|->
name|left
argument_list|,
name|ctl
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_pcmchannel_setup
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|cap
decl_stmt|,
name|fmtcap
decl_stmt|,
name|pcmcap
decl_stmt|,
name|path
decl_stmt|;
name|int
name|i
decl_stmt|,
name|type
decl_stmt|,
name|ret
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
expr_stmt|;
name|ch
operator|=
operator|&
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|play
expr_stmt|;
name|path
operator|=
name|HDA_DAC_PATH
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
expr_stmt|;
name|ch
operator|=
operator|&
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|rec
expr_stmt|;
name|path
operator|=
name|HDA_ADC_PATH
expr_stmt|;
block|}
name|ch
operator|->
name|caps
operator|=
name|hdac_caps
expr_stmt|;
name|ch
operator|->
name|caps
operator|.
name|fmtlist
operator|=
name|ch
operator|->
name|fmtlist
expr_stmt|;
name|ch
operator|->
name|bit16
operator|=
literal|1
expr_stmt|;
name|ch
operator|->
name|bit32
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|fmtcap
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
expr_stmt|;
name|pcmcap
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
expr_stmt|;
name|max
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|io
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|io
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
operator|&&
name|ret
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|type
operator|||
operator|!
operator|(
name|w
operator|->
name|pflags
operator|&
name|path
operator|)
condition|)
continue|continue;
name|cap
operator|=
name|w
operator|->
name|param
operator|.
name|widget_cap
expr_stmt|;
comment|/*if (HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL(cap)) 			continue;*/
if|if
condition|(
operator|!
name|HDA_PARAM_AUDIO_WIDGET_CAP_STEREO
argument_list|(
name|cap
argument_list|)
condition|)
continue|continue;
name|cap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
expr_stmt|;
comment|/*if (HDA_PARAM_SUPP_STREAM_FORMATS_AC3(cap)) { 		} 		if (HDA_PARAM_SUPP_STREAM_FORMATS_FLOAT32(cap)) { 		}*/
if|if
condition|(
operator|!
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|cap
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|fmtcap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
expr_stmt|;
name|pcmcap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
else|else
block|{
name|fmtcap
operator|&=
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
expr_stmt|;
name|pcmcap
operator|&=
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
name|ch
operator|->
name|io
index|[
name|ret
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
name|ch
operator|->
name|io
index|[
name|ret
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|->
name|supp_stream_formats
operator|=
name|fmtcap
expr_stmt|;
name|ch
operator|->
name|supp_pcm_size_rate
operator|=
name|pcmcap
expr_stmt|;
comment|/* 	 *  8bit = 0 	 * 16bit = 1 	 * 20bit = 2 	 * 24bit = 3 	 * 32bit = 4 	 */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|cap
operator|=
name|pcmcap
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|bit16
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|bit16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|2
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_FORCESTEREO
operator|)
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S16_LE
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_FORCESTEREO
operator|)
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S32_LE
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S32_LE
operator||
name|AFMT_STEREO
expr_stmt|;
block|}
name|ch
operator|->
name|fmtlist
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|8000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_11KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|11025
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|16000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_22KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|22050
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|32000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_44KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|44100
expr_stmt|;
comment|/* if (HDA_PARAM_SUPP_PCM_SIZE_RATE_48KHZ(cap)) */
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|48000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_88KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|88200
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_96KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|96000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_176KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|176400
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_192KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|192000
expr_stmt|;
comment|/* if (HDA_PARAM_SUPP_PCM_SIZE_RATE_384KHZ(cap)) */
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ch
operator|->
name|caps
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
expr_stmt|;
name|ch
operator|->
name|caps
operator|.
name|maxspeed
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_ctls
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|banner
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|fl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|fl
operator|=
name|SOUND_MASK_VOLUME
operator||
name|SOUND_MASK_PCM
operator||
name|SOUND_MASK_CD
operator||
name|SOUND_MASK_LINE
operator||
name|SOUND_MASK_RECLEV
operator||
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_SPEAKER
operator||
name|SOUND_MASK_OGAIN
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|widget
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|flag
operator|==
literal|0
operator|&&
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|~
name|fl
operator|)
operator|)
operator|||
operator|(
name|flag
operator|!=
literal|0
operator|&&
operator|(
name|ctl
operator|->
name|ossmask
operator|&
name|flag
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|banner
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s\n"
argument_list|,
name|banner
argument_list|)
expr_stmt|;
block|}
goto|goto
name|hdac_ctl_dump_it_all
goto|;
block|}
block|}
return|return;
name|hdac_ctl_dump_it_all
label|:
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|==
name|NULL
operator|||
name|ctl
operator|->
name|widget
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
name|flag
operator|==
literal|0
operator|&&
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|~
name|fl
operator|)
operator|)
operator|||
operator|(
name|flag
operator|!=
literal|0
operator|&&
operator|(
name|ctl
operator|->
name|ossmask
operator|&
name|flag
operator|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown Ctl (OSS: %s)\n"
argument_list|,
name|hdac_audio_ctl_ossmixer_mask2name
argument_list|(
name|ctl
operator|->
name|ossmask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"   |\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"   +-  nid: %2d index: %2d "
argument_list|,
name|ctl
operator|->
name|widget
operator|->
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|childwidget
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"(nid: %2d) "
argument_list|,
name|ctl
operator|->
name|childwidget
operator|->
name|nid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mute: %d step: %3d size: %3d off: %3d dir=0x%x ossmask=0x%08x\n"
argument_list|,
name|ctl
operator|->
name|mute
argument_list|,
name|ctl
operator|->
name|step
argument_list|,
name|ctl
operator|->
name|size
argument_list|,
name|ctl
operator|->
name|offset
argument_list|,
name|ctl
operator|->
name|dir
argument_list|,
name|ctl
operator|->
name|ossmask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_audio_formats
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|fcap
parameter_list|,
name|uint32_t
name|pcmcap
parameter_list|)
block|{
name|uint32_t
name|cap
decl_stmt|;
name|cap
operator|=
name|fcap
expr_stmt|;
if|if
condition|(
name|cap
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     Stream cap: 0x%08x\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"         Format:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AC3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_FLOAT32
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" FLOAT32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PCM"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cap
operator|=
name|pcmcap
expr_stmt|;
if|if
condition|(
name|cap
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"        PCM cap: 0x%08x\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"       PCM size:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 20"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 24"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 32"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"       PCM rate:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_11KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 11"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_22KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 22"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_44KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 44"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 48"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_88KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_96KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 96"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_176KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 176"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_192KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 192"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_pin
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|uint32_t
name|pincap
decl_stmt|,
name|wcap
decl_stmt|;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
name|wcap
operator|=
name|w
operator|->
name|param
operator|.
name|widget_cap
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"        Pin cap: 0x%08x\n"
argument_list|,
name|pincap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_IMP_SENSE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" ISC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_TRIGGER_REQD
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" TRQD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PDC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_BALANCED_IO_PINS
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" BAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" EAPD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_UNSOL_CAP
argument_list|(
name|wcap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" : UNSOL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     Pin config: 0x%08x\n"
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    Pin control: 0x%08x"
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
condition|)
name|printf
argument_list|(
literal|" HP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
condition|)
name|printf
argument_list|(
literal|" IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
condition|)
name|printf
argument_list|(
literal|" OUT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_amp
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cap
parameter_list|,
name|char
modifier|*
name|banner
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     %s amp: 0x%08x\n"
argument_list|,
name|banner
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                 "
literal|"mute=%d step=%d size=%d offset=%d\n"
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|cap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_nodes
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Default Parameter\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"-----------------\n"
argument_list|)
expr_stmt|;
name|hdac_dump_audio_formats
argument_list|(
name|sc
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"         IN amp: 0x%08x\n"
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|inamp_cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"        OUT amp: 0x%08x\n"
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|outamp_cap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Ghost widget nid=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"            nid: %d [%s]%s\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|?
literal|"DIGITAL"
else|:
literal|"ANALOG"
argument_list|,
operator|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|)
condition|?
literal|" [DISABLED]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"           name: %s\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     widget_cap: 0x%08x\n"
argument_list|,
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    Parse flags: 0x%08x\n"
argument_list|,
name|w
operator|->
name|pflags
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"      Ctl flags: 0x%08x\n"
argument_list|,
name|w
operator|->
name|ctlflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|hdac_dump_audio_formats
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
argument_list|,
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|hdac_dump_pin
argument_list|(
name|sc
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDAC_INVALID
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"           EAPD: 0x%08x\n"
argument_list|,
name|w
operator|->
name|param
operator|.
name|eapdbtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_OUT_AMP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|!=
literal|0
condition|)
name|hdac_dump_amp
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|param
operator|.
name|outamp_cap
argument_list|,
literal|"Output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_IN_AMP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|!=
literal|0
condition|)
name|hdac_dump_amp
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|param
operator|.
name|inamp_cap
argument_list|,
literal|" Input"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    connections: %d\n"
argument_list|,
name|w
operator|->
name|nconns
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"          |\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"          +<- nid=%d [%s]"
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|,
operator|(
name|cw
operator|==
name|NULL
operator|)
condition|?
literal|"GHOST!"
else|:
name|cw
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|" [UNKNOWN]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" [DISABLED]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|w
operator|->
name|selconn
operator|==
name|j
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
name|printf
argument_list|(
literal|" (selected)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_dump_dac_internal
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
operator|!
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_DAC_PATH
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    nid=%d [%s]\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"      ^\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"      |\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"      +-----<------+\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                   ^\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                   |\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"               "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  nid=%d [%s]\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
operator|||
name|cw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|hdac_dump_dac_internal
argument_list|(
name|devinfo
argument_list|,
name|cw
operator|->
name|nid
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
operator|&&
name|w
operator|->
name|selconn
operator|>
operator|-
literal|1
operator|&&
name|w
operator|->
name|selconn
operator|<
name|w
operator|->
name|nconns
condition|)
block|{
if|if
condition|(
name|hdac_dump_dac_internal
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|w
operator|->
name|selconn
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_dac
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
operator|!
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_DAC_PATH
operator|)
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Playback path:\n"
argument_list|)
expr_stmt|;
block|}
name|hdac_dump_dac_internal
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_adc
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|char
name|ossdevs
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_RECSEL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Recording sources:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    nid=%d [%s]\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|hdac_audio_ctl_ossmixer_mask2allname
argument_list|(
name|cw
operator|->
name|ctlflags
argument_list|,
name|ossdevs
argument_list|,
sizeof|sizeof
argument_list|(
name|ossdevs
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"      |\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"      +<- nid=%d [%s]"
argument_list|,
name|cw
operator|->
name|nid
argument_list|,
name|cw
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ossdevs
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" [recsrc: %s]"
argument_list|,
name|ossdevs
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_pcmchannels
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|pcnt
parameter_list|,
name|int
name|rcnt
parameter_list|)
block|{
name|nid_t
modifier|*
name|nids
decl_stmt|;
if|if
condition|(
name|pcnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"   PCM Playback: %d\n"
argument_list|,
name|pcnt
argument_list|)
expr_stmt|;
name|hdac_dump_audio_formats
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|play
operator|.
name|supp_stream_formats
argument_list|,
name|sc
operator|->
name|play
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"            DAC:"
argument_list|)
expr_stmt|;
for|for
control|(
name|nids
operator|=
name|sc
operator|->
name|play
operator|.
name|io
init|;
operator|*
name|nids
operator|!=
operator|-
literal|1
condition|;
name|nids
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|nids
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     PCM Record: %d\n"
argument_list|,
name|rcnt
argument_list|)
expr_stmt|;
name|hdac_dump_audio_formats
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|play
operator|.
name|supp_stream_formats
argument_list|,
name|sc
operator|->
name|rec
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"            ADC:"
argument_list|)
expr_stmt|;
for|for
control|(
name|nids
operator|=
name|sc
operator|->
name|rec
operator|.
name|io
init|;
operator|*
name|nids
operator|!=
operator|-
literal|1
condition|;
name|nids
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|nids
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_release_resources
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|NULL
decl_stmt|;
name|device_t
modifier|*
name|devlist
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|devcount
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|device_get_children
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devlist
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|=
operator|(
expr|struct
name|hdac_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|devinfo
operator|->
name|widget
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|devinfo
operator|->
name|widget
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|node_type
operator|==
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
operator|&&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devinfo
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|hdac_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|corb_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|play
operator|.
name|blkcnt
operator|>
literal|0
condition|)
name|hdac_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|play
operator|.
name|bdl_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rec
operator|.
name|blkcnt
operator|>
literal|0
condition|)
name|hdac_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|rec
operator|.
name|bdl_dma
argument_list|)
expr_stmt|;
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_mem_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function surely going to make its way into upper level someday. */
end_comment

begin_function
specifier|static
name|void
name|hdac_config_fetch
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|on
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|,
name|inv
decl_stmt|;
if|if
condition|(
name|on
operator|!=
name|NULL
condition|)
operator|*
name|on
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"config"
argument_list|,
operator|&
name|res
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|res
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|res
argument_list|)
operator|>
literal|0
operator|)
condition|)
return|return;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: HDA Config:"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|res
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|res
index|[
name|i
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|res
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
return|return;
block|}
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|res
index|[
name|j
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|res
index|[
name|j
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|res
index|[
name|j
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|j
operator|++
expr_stmt|;
name|len
operator|=
name|j
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|res
operator|+
name|i
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|inv
operator|=
literal|2
expr_stmt|;
else|else
name|inv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|len
operator|>
name|inv
operator|&&
name|k
operator|<
name|HDAC_QUIRKS_TAB_LEN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
operator|+
name|i
operator|+
name|inv
argument_list|,
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|,
name|len
operator|-
name|inv
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|len
operator|-
name|inv
operator|!=
name|strlen
argument_list|(
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|)
condition|)
break|break;
name|HDA_BOOTVERBOSE
argument_list|(
argument|printf(
literal|" %s%s"
argument|, (inv !=
literal|0
argument|) ?
literal|"no"
argument|:
literal|""
argument|, 				    hdac_quirks_tab[k].key);
argument_list|)
empty_stmt|;
if|if
condition|(
name|inv
operator|==
literal|0
operator|&&
name|on
operator|!=
name|NULL
condition|)
operator|*
name|on
operator||=
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|inv
operator|!=
literal|0
operator|&&
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator||=
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_hdac_polling
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|devinfo
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|sc
operator|->
name|polling
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|sc
operator|->
name|polling
condition|)
block|{
if|if
condition|(
name|hda_chan_active
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|err
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RINTCNT
argument_list|,
name|sc
operator|->
name|rirb_size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_RIRBCTL_RINTCTL
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|HDAC_INTCTL_CIE
operator||
name|HDAC_INTCTL_GIE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RINTCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_RIRBCTL_RINTCTL
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
literal|1
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|hdac_attach2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|quirks_on
decl_stmt|,
name|quirks_off
decl_stmt|;
name|int
name|pcnt
decl_stmt|,
name|rcnt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|device_t
modifier|*
name|devlist
init|=
name|NULL
decl_stmt|;
name|int
name|devcount
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|NULL
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|hdac_config_fetch
argument_list|(
name|sc
argument_list|,
operator|&
name|quirks_on
argument_list|,
operator|&
name|quirks_off
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: HDA Config: on=0x%08x off=0x%08x\n"
argument|, 		    quirks_on, quirks_off);
argument_list|)
empty_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Remove ourselves from the config hooks */
if|if
condition|(
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|!=
name|NULL
condition|)
block|{
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Start the corb and rirb engines */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Starting CORB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_corb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Starting RIRB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_rirb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Enabling controller interrupt...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|HDAC_INTCTL_CIE
operator||
name|HDAC_INTCTL_GIE
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
operator||
name|HDAC_GCTL_UNSOL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Scanning HDA codecs...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_scan_codecs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_get_children
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devlist
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|=
operator|(
expr|struct
name|hdac_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|!=
name|NULL
operator|&&
name|devinfo
operator|->
name|node_type
operator|==
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
block|{
break|break;
block|}
else|else
name|devinfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|devlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Audio Function Group not found!\n"
argument_list|)
expr_stmt|;
name|hdac_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Parsing AFG nid=%d cad=%d\n"
argument|, 		    devinfo->nid, devinfo->codec->cad);
argument_list|)
empty_stmt|;
name|hdac_audio_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Parsing Ctls...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_ctl_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Parsing vendor patch...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_vendor_patch_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|quirks_on
operator|!=
literal|0
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator||=
name|quirks_on
expr_stmt|;
if|if
condition|(
name|quirks_off
operator|!=
literal|0
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&=
operator|~
name|quirks_off
expr_stmt|;
comment|/* XXX Disable all DIGITAL path. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* XXX Disable useless pin ? */
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|widget
operator|==
name|NULL
condition|)
continue|continue;
name|w
operator|=
name|ctl
operator|->
name|widget
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|ctl
operator|->
name|childwidget
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Building AFG tree...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_build_tree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: AFG commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_commit
argument_list|(
name|devinfo
argument_list|,
name|HDA_COMMIT_ALL
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Ctls commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_ctl_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: PCMDIR_PLAY setup...\n"
argument|);
argument_list|)
empty_stmt|;
name|pcnt
operator|=
name|hdac_pcmchannel_setup
argument_list|(
name|devinfo
argument_list|,
name|PCMDIR_PLAY
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: PCMDIR_REC setup...\n"
argument|);
argument_list|)
empty_stmt|;
name|rcnt
operator|=
name|hdac_pcmchannel_setup
argument_list|(
name|devinfo
argument_list|,
name|PCMDIR_REC
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: OSS mixer initialization...\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* 	 * There is no point of return after this. If the driver failed, 	 * so be it. Let the detach procedure do all the cleanup. 	 */
if|if
condition|(
name|mixer_init
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|hdac_audio_ctl_ossmixer_class
argument_list|,
name|devinfo
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Can't register mixer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcnt
operator|>
literal|0
condition|)
name|pcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rcnt
operator|>
literal|0
condition|)
name|rcnt
operator|=
literal|1
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA_DEBUG: Registering PCM channels...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|devinfo
argument_list|,
name|pcnt
argument_list|,
name|rcnt
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Can't register PCM\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|registered
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|hdac_channel_class
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rcnt
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|hdac_channel_class
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"polling"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sysctl_hdac_polling
argument_list|,
literal|"I"
argument_list|,
literal|"Enable polling mode"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at memory 0x%lx irq %ld %s [%s]"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|mem_res
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
operator|.
name|irq_res
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_hda
argument_list|)
argument_list|,
name|HDA_DRV_TEST_REV
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"<HDA Codec: %s>\n"
argument_list|,
name|hdac_codec_name
argument_list|(
name|devinfo
argument_list|)
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"<HDA Codec ID: 0x%08x>\n"
argument|, 		    hdac_codec_id(devinfo));
argument_list|)
empty_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"<HDA Driver Revision: %s>\n"
argument_list|,
name|HDA_DRV_TEST_REV
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (devinfo->function.audio.quirks !=
literal|0
argument|) { 			device_printf(sc->dev,
literal|"\n"
argument|); 			device_printf(sc->dev,
literal|"HDA config/quirks:"
argument|); 			for (i =
literal|0
argument|; i< HDAC_QUIRKS_TAB_LEN; i++) { 				if (devinfo->function.audio.quirks& 				    hdac_quirks_tab[i].value) 					printf(
literal|" %s"
argument|, hdac_quirks_tab[i].key); 			} 			printf(
literal|"\n"
argument|); 		} 		device_printf(sc->dev,
literal|"\n"
argument|); 		device_printf(sc->dev,
literal|"+-------------------+\n"
argument|); 		device_printf(sc->dev,
literal|"| DUMPING HDA NODES |\n"
argument|); 		device_printf(sc->dev,
literal|"+-------------------+\n"
argument|); 		hdac_dump_nodes(devinfo); 		device_printf(sc->dev,
literal|"\n"
argument|); 		device_printf(sc->dev,
literal|"+------------------------+\n"
argument|); 		device_printf(sc->dev,
literal|"| DUMPING HDA AMPLIFIERS |\n"
argument|); 		device_printf(sc->dev,
literal|"+------------------------+\n"
argument|); 		device_printf(sc->dev,
literal|"\n"
argument|); 		i =
literal|0
argument|; 		while ((ctl = hdac_audio_ctl_each(devinfo,&i)) != NULL) { 			device_printf(sc->dev,
literal|"%3d: nid=%d"
argument|, i, 			    (ctl->widget != NULL) ? ctl->widget->nid : -
literal|1
argument|); 			if (ctl->childwidget != NULL) 				printf(
literal|" cnid=%d"
argument|, ctl->childwidget->nid); 			printf(
literal|" dir=0x%x index=%d "
literal|"ossmask=0x%08x ossdev=%d%s\n"
argument|, 			    ctl->dir, ctl->index, 			    ctl->ossmask, ctl->ossdev, 			    (ctl->enable ==
literal|0
argument|) ?
literal|" [DISABLED]"
argument|:
literal|""
argument|); 		} 		device_printf(sc->dev,
literal|"\n"
argument|); 		device_printf(sc->dev,
literal|"+-----------------------------------+\n"
argument|); 		device_printf(sc->dev,
literal|"| DUMPING HDA AUDIO/VOLUME CONTROLS |\n"
argument|); 		device_printf(sc->dev,
literal|"+-----------------------------------+\n"
argument|); 		hdac_dump_ctls(devinfo,
literal|"Master Volume (OSS: vol)"
argument|, SOUND_MASK_VOLUME); 		hdac_dump_ctls(devinfo,
literal|"PCM Volume (OSS: pcm)"
argument|, SOUND_MASK_PCM); 		hdac_dump_ctls(devinfo,
literal|"CD Volume (OSS: cd)"
argument|, SOUND_MASK_CD); 		hdac_dump_ctls(devinfo,
literal|"Microphone Volume (OSS: mic)"
argument|, SOUND_MASK_MIC); 		hdac_dump_ctls(devinfo,
literal|"Line-in Volume (OSS: line)"
argument|, SOUND_MASK_LINE); 		hdac_dump_ctls(devinfo,
literal|"Recording Level (OSS: rec)"
argument|, SOUND_MASK_RECLEV); 		hdac_dump_ctls(devinfo,
literal|"Speaker/Beep (OSS: speaker)"
argument|, SOUND_MASK_SPEAKER); 		hdac_dump_ctls(devinfo, NULL,
literal|0
argument|); 		hdac_dump_dac(devinfo); 		hdac_dump_adc(devinfo); 		device_printf(sc->dev,
literal|"\n"
argument|); 		device_printf(sc->dev,
literal|"+--------------------------------------+\n"
argument|); 		device_printf(sc->dev,
literal|"| DUMPING PCM Playback/Record Channels |\n"
argument|); 		device_printf(sc->dev,
literal|"+--------------------------------------+\n"
argument|); 		hdac_dump_pcmchannels(sc, pcnt, rcnt);
argument_list|)
empty_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
block|{
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
literal|1
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_detach(device_t)  *  * Detach and free up resources utilized by the hdac device.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|devinfo
operator|=
operator|(
expr|struct
name|hdac_devinfo
operator|*
operator|)
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|!=
name|NULL
operator|&&
name|devinfo
operator|->
name|codec
operator|!=
name|NULL
condition|)
name|sc
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|registered
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|hdac_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdac_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdac_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdac_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdac_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdac_driver
init|=
block|{
literal|"pcm"
block|,
name|hdac_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hda
argument_list|,
name|pci
argument_list|,
name|hdac_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_hda
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_hda
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

