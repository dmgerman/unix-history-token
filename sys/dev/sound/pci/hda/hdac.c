begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Stephane E. Potvin<sepotvin@videotron.ca>  * Copyright (c) 2006 Ariff Abdullah<ariff@FreeBSD.org>  * Copyright (c) 2008 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Intel High Definition Audio (Controller) driver for FreeBSD. Be advised  * that this driver still in its early stage, and possible of rewrite are  * pretty much guaranteed. There are supposedly several distinct parent/child  * busses to make this "perfect", but as for now and for the sake of  * simplicity, everything is gobble up within single source.  *  * List of subsys:  *     1) HDA Controller support  *     2) HDA Codecs support, which may include  *        - HDA  *        - Modem  *        - HDMI  *     3) Widget parser - the real magic of why this driver works on so  *        many hardwares with minimal vendor specific quirk. The original  *        parser was written using Ruby and can be found at  *        http://people.freebsd.org/~ariff/HDA/parser.rb . This crude  *        ruby parser take the verbose dmesg dump as its input. Refer to  *        http://www.microsoft.com/whdc/device/audio/default.mspx for various  *        interesting documents, especially UAA (Universal Audio Architecture).  *     4) Possible vendor specific support.  *        (snd_hda_intel, snd_hda_ati, etc..)  *  * Thanks to Ahmad Ubaidah Omar @ Defenxis Sdn. Bhd. for the  * Compaq V3000 with Conexant HDA.  *  *    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *    *                                                                 *  *    *        This driver is a collaborative effort made by:           *  *    *                                                                 *  *    *          Stephane E. Potvin<sepotvin@videotron.ca>             *  *    *               Andrea Bittau<a.bittau@cs.ucl.ac.uk>             *  *    *               Wesley Morgan<morganw@chemikals.org>             *  *    *              Daniel Eischen<deischen@FreeBSD.org>              *  *    *             Maxime Guillaud<bsd-ports@mguillaud.net>           *  *    *              Ariff Abdullah<ariff@FreeBSD.org>                 *  *    *             Alexander Motin<mav@FreeBSD.org>                   *  *    *                                                                 *  *    *   ....and various people from freebsd-multimedia@FreeBSD.org    *  *    *                                                                 *  *    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hda_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_define
define|#
directive|define
name|HDA_DRV_TEST_REV
value|"20081226_0122"
end_define

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HDA_BOOTVERBOSE
parameter_list|(
name|stmt
parameter_list|)
value|do {			\ 	if (bootverbose != 0 || snd_verbose> 3) {	\ 		stmt					\ 	}						\ } while(0)
end_define

begin_define
define|#
directive|define
name|HDA_BOOTHVERBOSE
parameter_list|(
name|stmt
parameter_list|)
value|do {			\ 	if (snd_verbose> 3) {				\ 		stmt					\ 	}						\ } while(0)
end_define

begin_if
if|#
directive|if
literal|1
end_if

begin_undef
undef|#
directive|undef
name|HDAC_INTR_EXTRA
end_undef

begin_define
define|#
directive|define
name|HDAC_INTR_EXTRA
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|hdac_lock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxlock((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_unlock
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxunlock((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_lockassert
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxassert((sc)->lock)
end_define

begin_define
define|#
directive|define
name|hdac_lockowned
parameter_list|(
name|sc
parameter_list|)
value|mtx_owned((sc)->lock)
end_define

begin_undef
undef|#
directive|undef
name|HDAC_MSI_ENABLED
end_undef

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700026
operator|||
expr|\
operator|(
name|__FreeBSD_version
operator|<
literal|700000
operator|&&
name|__FreeBSD_version
operator|>=
literal|602106
operator|)
end_if

begin_define
define|#
directive|define
name|HDAC_MSI_ENABLED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HDA_FLAG_MATCH
parameter_list|(
name|fl
parameter_list|,
name|v
parameter_list|)
value|(((fl)& (v)) == (v))
end_define

begin_define
define|#
directive|define
name|HDA_DEV_MATCH
parameter_list|(
name|fl
parameter_list|,
name|v
parameter_list|)
value|((fl) == (v) || \ 				(fl) == 0xffffffff || \ 				(((fl)& 0xffff0000) == 0xffff0000&& \ 				((fl)& 0x0000ffff) == ((v)& 0x0000ffff)) || \ 				(((fl)& 0x0000ffff) == 0x0000ffff&& \ 				((fl)& 0xffff0000) == ((v)& 0xffff0000)))
end_define

begin_define
define|#
directive|define
name|HDA_MATCH_ALL
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|HDAC_INVALID
value|0xffffffff
end_define

begin_comment
comment|/* Default controller / jack sense poll: 250ms */
end_comment

begin_define
define|#
directive|define
name|HDAC_POLL_INTERVAL
value|max(hz>> 2, 1)
end_define

begin_comment
comment|/*  * Make room for possible 4096 playback/record channels, in 100 years to come.  */
end_comment

begin_define
define|#
directive|define
name|HDAC_TRIGGER_NONE
value|0x00000000
end_define

begin_define
define|#
directive|define
name|HDAC_TRIGGER_PLAY
value|0x00000fff
end_define

begin_define
define|#
directive|define
name|HDAC_TRIGGER_REC
value|0x00fff000
end_define

begin_define
define|#
directive|define
name|HDAC_TRIGGER_UNSOL
value|0x80000000
end_define

begin_define
define|#
directive|define
name|HDA_MODEL_CONSTRUCT
parameter_list|(
name|vendor
parameter_list|,
name|model
parameter_list|)
define|\
value|(((uint32_t)(model)<< 16) | ((vendor##_VENDORID)& 0xffff))
end_define

begin_comment
comment|/* Controller models */
end_comment

begin_comment
comment|/* Intel */
end_comment

begin_define
define|#
directive|define
name|INTEL_VENDORID
value|0x8086
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801F
value|HDA_MODEL_CONSTRUCT(INTEL, 0x2668)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_63XXESB
value|HDA_MODEL_CONSTRUCT(INTEL, 0x269a)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801G
value|HDA_MODEL_CONSTRUCT(INTEL, 0x27d8)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801H
value|HDA_MODEL_CONSTRUCT(INTEL, 0x284b)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801I
value|HDA_MODEL_CONSTRUCT(INTEL, 0x293e)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_82801J
value|HDA_MODEL_CONSTRUCT(INTEL, 0x3a3e)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_PCH
value|HDA_MODEL_CONSTRUCT(INTEL, 0x3b56)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_SCH
value|HDA_MODEL_CONSTRUCT(INTEL, 0x811b)
end_define

begin_define
define|#
directive|define
name|HDA_INTEL_ALL
value|HDA_MODEL_CONSTRUCT(INTEL, 0xffff)
end_define

begin_comment
comment|/* Nvidia */
end_comment

begin_define
define|#
directive|define
name|NVIDIA_VENDORID
value|0x10de
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP51
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x026c)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP55
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0371)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP61_1
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x03e4)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP61_2
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x03f0)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP65_1
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x044a)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP65_2
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x044b)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP67_1
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x055c)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP67_2
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x055d)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP78_1
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0774)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP78_2
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0775)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP78_3
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0776)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP78_4
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0777)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP73_1
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x07fc)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP73_2
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x07fd)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP79_1
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0ac0)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP79_2
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0ac1)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP79_3
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0ac2)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_MCP79_4
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0x0ac3)
end_define

begin_define
define|#
directive|define
name|HDA_NVIDIA_ALL
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0xffff)
end_define

begin_comment
comment|/* ATI */
end_comment

begin_define
define|#
directive|define
name|ATI_VENDORID
value|0x1002
end_define

begin_define
define|#
directive|define
name|HDA_ATI_SB450
value|HDA_MODEL_CONSTRUCT(ATI, 0x437b)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_SB600
value|HDA_MODEL_CONSTRUCT(ATI, 0x4383)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RS600
value|HDA_MODEL_CONSTRUCT(ATI, 0x793b)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RS690
value|HDA_MODEL_CONSTRUCT(ATI, 0x7919)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RS780
value|HDA_MODEL_CONSTRUCT(ATI, 0x960f)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_R600
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa00)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV630
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa08)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV610
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa10)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV670
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa18)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV635
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa20)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV620
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa28)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV770
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa30)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV730
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa38)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV710
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa40)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_RV740
value|HDA_MODEL_CONSTRUCT(ATI, 0xaa48)
end_define

begin_define
define|#
directive|define
name|HDA_ATI_ALL
value|HDA_MODEL_CONSTRUCT(ATI, 0xffff)
end_define

begin_comment
comment|/* VIA */
end_comment

begin_define
define|#
directive|define
name|VIA_VENDORID
value|0x1106
end_define

begin_define
define|#
directive|define
name|HDA_VIA_VT82XX
value|HDA_MODEL_CONSTRUCT(VIA, 0x3288)
end_define

begin_define
define|#
directive|define
name|HDA_VIA_ALL
value|HDA_MODEL_CONSTRUCT(VIA, 0xffff)
end_define

begin_comment
comment|/* SiS */
end_comment

begin_define
define|#
directive|define
name|SIS_VENDORID
value|0x1039
end_define

begin_define
define|#
directive|define
name|HDA_SIS_966
value|HDA_MODEL_CONSTRUCT(SIS, 0x7502)
end_define

begin_define
define|#
directive|define
name|HDA_SIS_ALL
value|HDA_MODEL_CONSTRUCT(SIS, 0xffff)
end_define

begin_comment
comment|/* ULI */
end_comment

begin_define
define|#
directive|define
name|ULI_VENDORID
value|0x10b9
end_define

begin_define
define|#
directive|define
name|HDA_ULI_M5461
value|HDA_MODEL_CONSTRUCT(ULI, 0x5461)
end_define

begin_define
define|#
directive|define
name|HDA_ULI_ALL
value|HDA_MODEL_CONSTRUCT(ULI, 0xffff)
end_define

begin_comment
comment|/* OEM/subvendors */
end_comment

begin_comment
comment|/* Intel */
end_comment

begin_define
define|#
directive|define
name|INTEL_D101GGC_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(INTEL, 0xd600)
end_define

begin_comment
comment|/* HP/Compaq */
end_comment

begin_define
define|#
directive|define
name|HP_VENDORID
value|0x103c
end_define

begin_define
define|#
directive|define
name|HP_V3000_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30b5)
end_define

begin_define
define|#
directive|define
name|HP_NX7400_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30a2)
end_define

begin_define
define|#
directive|define
name|HP_NX6310_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30aa)
end_define

begin_define
define|#
directive|define
name|HP_NX6325_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30b0)
end_define

begin_define
define|#
directive|define
name|HP_XW4300_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x3013)
end_define

begin_define
define|#
directive|define
name|HP_3010_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x3010)
end_define

begin_define
define|#
directive|define
name|HP_DV5000_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x30a5)
end_define

begin_define
define|#
directive|define
name|HP_DC7700S_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x2801)
end_define

begin_define
define|#
directive|define
name|HP_DC7700_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0x2802)
end_define

begin_define
define|#
directive|define
name|HP_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(HP, 0xffff)
end_define

begin_comment
comment|/* What is wrong with XN 2563 anyway? (Got the picture ?) */
end_comment

begin_define
define|#
directive|define
name|HP_NX6325_SUBVENDORX
value|0x103c30b0
end_define

begin_comment
comment|/* Dell */
end_comment

begin_define
define|#
directive|define
name|DELL_VENDORID
value|0x1028
end_define

begin_define
define|#
directive|define
name|DELL_D630_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01f9)
end_define

begin_define
define|#
directive|define
name|DELL_D820_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01cc)
end_define

begin_define
define|#
directive|define
name|DELL_V1400_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x0227)
end_define

begin_define
define|#
directive|define
name|DELL_V1500_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x0228)
end_define

begin_define
define|#
directive|define
name|DELL_I1300_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01c9)
end_define

begin_define
define|#
directive|define
name|DELL_XPSM1210_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01d7)
end_define

begin_define
define|#
directive|define
name|DELL_OPLX745_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0x01da)
end_define

begin_define
define|#
directive|define
name|DELL_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(DELL, 0xffff)
end_define

begin_comment
comment|/* Clevo */
end_comment

begin_define
define|#
directive|define
name|CLEVO_VENDORID
value|0x1558
end_define

begin_define
define|#
directive|define
name|CLEVO_D900T_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(CLEVO, 0x0900)
end_define

begin_define
define|#
directive|define
name|CLEVO_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(CLEVO, 0xffff)
end_define

begin_comment
comment|/* Acer */
end_comment

begin_define
define|#
directive|define
name|ACER_VENDORID
value|0x1025
end_define

begin_define
define|#
directive|define
name|ACER_A5050_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0x010f)
end_define

begin_define
define|#
directive|define
name|ACER_A4520_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0x0127)
end_define

begin_define
define|#
directive|define
name|ACER_A4710_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0x012f)
end_define

begin_define
define|#
directive|define
name|ACER_A4715_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0x0133)
end_define

begin_define
define|#
directive|define
name|ACER_3681WXM_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0x0110)
end_define

begin_define
define|#
directive|define
name|ACER_T6292_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0x011b)
end_define

begin_define
define|#
directive|define
name|ACER_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ACER, 0xffff)
end_define

begin_comment
comment|/* Asus */
end_comment

begin_define
define|#
directive|define
name|ASUS_VENDORID
value|0x1043
end_define

begin_define
define|#
directive|define
name|ASUS_A8X_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1153)
end_define

begin_define
define|#
directive|define
name|ASUS_U5F_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1263)
end_define

begin_define
define|#
directive|define
name|ASUS_W6F_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1263)
end_define

begin_define
define|#
directive|define
name|ASUS_A7M_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1323)
end_define

begin_define
define|#
directive|define
name|ASUS_F3JC_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1338)
end_define

begin_define
define|#
directive|define
name|ASUS_G2K_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1339)
end_define

begin_define
define|#
directive|define
name|ASUS_A7T_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x13c2)
end_define

begin_define
define|#
directive|define
name|ASUS_W2J_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1971)
end_define

begin_define
define|#
directive|define
name|ASUS_M5200_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x1993)
end_define

begin_define
define|#
directive|define
name|ASUS_P1AH2_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x81cb)
end_define

begin_define
define|#
directive|define
name|ASUS_M2NPVMX_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x81cb)
end_define

begin_define
define|#
directive|define
name|ASUS_M2V_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x81e7)
end_define

begin_define
define|#
directive|define
name|ASUS_P5BWD_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x81ec)
end_define

begin_define
define|#
directive|define
name|ASUS_M2N_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0x8234)
end_define

begin_define
define|#
directive|define
name|ASUS_A8NVMCSM_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(NVIDIA, 0xcb84)
end_define

begin_define
define|#
directive|define
name|ASUS_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(ASUS, 0xffff)
end_define

begin_comment
comment|/* IBM / Lenovo */
end_comment

begin_define
define|#
directive|define
name|IBM_VENDORID
value|0x1014
end_define

begin_define
define|#
directive|define
name|IBM_M52_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(IBM, 0x02f6)
end_define

begin_define
define|#
directive|define
name|IBM_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(IBM, 0xffff)
end_define

begin_comment
comment|/* Lenovo */
end_comment

begin_define
define|#
directive|define
name|LENOVO_VENDORID
value|0x17aa
end_define

begin_define
define|#
directive|define
name|LENOVO_3KN100_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LENOVO, 0x2066)
end_define

begin_define
define|#
directive|define
name|LENOVO_3KN200_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LENOVO, 0x384e)
end_define

begin_define
define|#
directive|define
name|LENOVO_TCA55_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LENOVO, 0x1015)
end_define

begin_define
define|#
directive|define
name|LENOVO_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LENOVO, 0xffff)
end_define

begin_comment
comment|/* Samsung */
end_comment

begin_define
define|#
directive|define
name|SAMSUNG_VENDORID
value|0x144d
end_define

begin_define
define|#
directive|define
name|SAMSUNG_Q1_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(SAMSUNG, 0xc027)
end_define

begin_define
define|#
directive|define
name|SAMSUNG_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(SAMSUNG, 0xffff)
end_define

begin_comment
comment|/* Medion ? */
end_comment

begin_define
define|#
directive|define
name|MEDION_VENDORID
value|0x161f
end_define

begin_define
define|#
directive|define
name|MEDION_MD95257_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MEDION, 0x203d)
end_define

begin_define
define|#
directive|define
name|MEDION_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MEDION, 0xffff)
end_define

begin_comment
comment|/* Apple Computer Inc. */
end_comment

begin_define
define|#
directive|define
name|APPLE_VENDORID
value|0x106b
end_define

begin_define
define|#
directive|define
name|APPLE_MB3_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(APPLE, 0x00a1)
end_define

begin_comment
comment|/* Sony */
end_comment

begin_define
define|#
directive|define
name|SONY_VENDORID
value|0x104d
end_define

begin_define
define|#
directive|define
name|SONY_S5_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(SONY, 0x81cc)
end_define

begin_define
define|#
directive|define
name|SONY_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(SONY, 0xffff)
end_define

begin_comment
comment|/*  * Apple Intel MacXXXX seems using Sigmatel codec/vendor id  * instead of their own, which is beyond my comprehension  * (see HDA_CODEC_STAC9221 below).  */
end_comment

begin_define
define|#
directive|define
name|APPLE_INTEL_MAC
value|0x76808384
end_define

begin_comment
comment|/* LG Electronics */
end_comment

begin_define
define|#
directive|define
name|LG_VENDORID
value|0x1854
end_define

begin_define
define|#
directive|define
name|LG_LW20_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LG, 0x0018)
end_define

begin_define
define|#
directive|define
name|LG_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(LG, 0xffff)
end_define

begin_comment
comment|/* Fujitsu Siemens */
end_comment

begin_define
define|#
directive|define
name|FS_VENDORID
value|0x1734
end_define

begin_define
define|#
directive|define
name|FS_PA1510_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(FS, 0x10b8)
end_define

begin_define
define|#
directive|define
name|FS_SI1848_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(FS, 0x10cd)
end_define

begin_define
define|#
directive|define
name|FS_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(FS, 0xffff)
end_define

begin_comment
comment|/* Fujitsu Limited */
end_comment

begin_define
define|#
directive|define
name|FL_VENDORID
value|0x10cf
end_define

begin_define
define|#
directive|define
name|FL_S7020D_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(FL, 0x1326)
end_define

begin_define
define|#
directive|define
name|FL_U1010_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(FL, 0x142d)
end_define

begin_define
define|#
directive|define
name|FL_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(FL, 0xffff)
end_define

begin_comment
comment|/* Toshiba */
end_comment

begin_define
define|#
directive|define
name|TOSHIBA_VENDORID
value|0x1179
end_define

begin_define
define|#
directive|define
name|TOSHIBA_U200_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(TOSHIBA, 0x0001)
end_define

begin_define
define|#
directive|define
name|TOSHIBA_A135_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(TOSHIBA, 0xff01)
end_define

begin_define
define|#
directive|define
name|TOSHIBA_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(TOSHIBA, 0xffff)
end_define

begin_comment
comment|/* Micro-Star International (MSI) */
end_comment

begin_define
define|#
directive|define
name|MSI_VENDORID
value|0x1462
end_define

begin_define
define|#
directive|define
name|MSI_MS1034_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MSI, 0x0349)
end_define

begin_define
define|#
directive|define
name|MSI_MS034A_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MSI, 0x034a)
end_define

begin_define
define|#
directive|define
name|MSI_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(MSI, 0xffff)
end_define

begin_comment
comment|/* Giga-Byte Technology */
end_comment

begin_define
define|#
directive|define
name|GB_VENDORID
value|0x1458
end_define

begin_define
define|#
directive|define
name|GB_G33S2H_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(GB, 0xa022)
end_define

begin_define
define|#
directive|define
name|GP_ALL_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(GB, 0xffff)
end_define

begin_comment
comment|/* Uniwill ? */
end_comment

begin_define
define|#
directive|define
name|UNIWILL_VENDORID
value|0x1584
end_define

begin_define
define|#
directive|define
name|UNIWILL_9075_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(UNIWILL, 0x9075)
end_define

begin_define
define|#
directive|define
name|UNIWILL_9080_SUBVENDOR
value|HDA_MODEL_CONSTRUCT(UNIWILL, 0x9080)
end_define

begin_comment
comment|/* Misc constants.. */
end_comment

begin_define
define|#
directive|define
name|HDA_AMP_VOL_DEFAULT
value|(-1)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_DEFAULT
value|(0xffffffff)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_NONE
value|(0)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_LEFT
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_RIGHT
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_MUTE_ALL
value|(HDA_AMP_MUTE_LEFT | HDA_AMP_MUTE_RIGHT)
end_define

begin_define
define|#
directive|define
name|HDA_AMP_LEFT_MUTED
parameter_list|(
name|v
parameter_list|)
value|((v)& (HDA_AMP_MUTE_LEFT))
end_define

begin_define
define|#
directive|define
name|HDA_AMP_RIGHT_MUTED
parameter_list|(
name|v
parameter_list|)
value|(((v)& HDA_AMP_MUTE_RIGHT)>> 1)
end_define

begin_define
define|#
directive|define
name|HDA_ADC_MONITOR
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_CTL_OUT
value|1
end_define

begin_define
define|#
directive|define
name|HDA_CTL_IN
value|2
end_define

begin_define
define|#
directive|define
name|HDA_GPIO_MAX
value|8
end_define

begin_comment
comment|/* 0 - 7 = GPIO , 8 = Flush */
end_comment

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO0
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO1
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO2
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO3
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO4
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO5
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO6
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIO7
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_GPIOFLUSH
value|(1<< 8)
end_define

begin_comment
comment|/* 9 - 25 = anything else */
end_comment

begin_define
define|#
directive|define
name|HDA_QUIRK_SOFTPCMVOL
value|(1<< 9)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_FIXEDRATE
value|(1<< 10)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_FORCESTEREO
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_EAPDINV
value|(1<< 12)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_DMAPOS
value|(1<< 13)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_SENSEINV
value|(1<< 14)
end_define

begin_comment
comment|/* 26 - 31 = vrefs */
end_comment

begin_define
define|#
directive|define
name|HDA_QUIRK_IVREF50
value|(1<< 26)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_IVREF80
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_IVREF100
value|(1<< 28)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_OVREF50
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_OVREF80
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_OVREF100
value|(1<< 31)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_IVREF
value|(HDA_QUIRK_IVREF50 | HDA_QUIRK_IVREF80 | \ 							HDA_QUIRK_IVREF100)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_OVREF
value|(HDA_QUIRK_OVREF50 | HDA_QUIRK_OVREF80 | \ 							HDA_QUIRK_OVREF100)
end_define

begin_define
define|#
directive|define
name|HDA_QUIRK_VREF
value|(HDA_QUIRK_IVREF | HDA_QUIRK_OVREF)
end_define

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|600000
end_if

begin_define
define|#
directive|define
name|taskqueue_drain
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|hdac_quirks_tab
index|[]
init|=
block|{
block|{
literal|"gpio0"
block|,
name|HDA_QUIRK_GPIO0
block|}
block|,
block|{
literal|"gpio1"
block|,
name|HDA_QUIRK_GPIO1
block|}
block|,
block|{
literal|"gpio2"
block|,
name|HDA_QUIRK_GPIO2
block|}
block|,
block|{
literal|"gpio3"
block|,
name|HDA_QUIRK_GPIO3
block|}
block|,
block|{
literal|"gpio4"
block|,
name|HDA_QUIRK_GPIO4
block|}
block|,
block|{
literal|"gpio5"
block|,
name|HDA_QUIRK_GPIO5
block|}
block|,
block|{
literal|"gpio6"
block|,
name|HDA_QUIRK_GPIO6
block|}
block|,
block|{
literal|"gpio7"
block|,
name|HDA_QUIRK_GPIO7
block|}
block|,
block|{
literal|"gpioflush"
block|,
name|HDA_QUIRK_GPIOFLUSH
block|}
block|,
block|{
literal|"softpcmvol"
block|,
name|HDA_QUIRK_SOFTPCMVOL
block|}
block|,
block|{
literal|"fixedrate"
block|,
name|HDA_QUIRK_FIXEDRATE
block|}
block|,
block|{
literal|"forcestereo"
block|,
name|HDA_QUIRK_FORCESTEREO
block|}
block|,
block|{
literal|"eapdinv"
block|,
name|HDA_QUIRK_EAPDINV
block|}
block|,
block|{
literal|"dmapos"
block|,
name|HDA_QUIRK_DMAPOS
block|}
block|,
block|{
literal|"senseinv"
block|,
name|HDA_QUIRK_SENSEINV
block|}
block|,
block|{
literal|"ivref50"
block|,
name|HDA_QUIRK_IVREF50
block|}
block|,
block|{
literal|"ivref80"
block|,
name|HDA_QUIRK_IVREF80
block|}
block|,
block|{
literal|"ivref100"
block|,
name|HDA_QUIRK_IVREF100
block|}
block|,
block|{
literal|"ovref50"
block|,
name|HDA_QUIRK_OVREF50
block|}
block|,
block|{
literal|"ovref80"
block|,
name|HDA_QUIRK_OVREF80
block|}
block|,
block|{
literal|"ovref100"
block|,
name|HDA_QUIRK_OVREF100
block|}
block|,
block|{
literal|"ivref"
block|,
name|HDA_QUIRK_IVREF
block|}
block|,
block|{
literal|"ovref"
block|,
name|HDA_QUIRK_OVREF
block|}
block|,
block|{
literal|"vref"
block|,
name|HDA_QUIRK_VREF
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_QUIRKS_TAB_LEN
define|\
value|(sizeof(hdac_quirks_tab) / sizeof(hdac_quirks_tab[0]))
end_define

begin_define
define|#
directive|define
name|HDA_BDL_MIN
value|2
end_define

begin_define
define|#
directive|define
name|HDA_BDL_MAX
value|256
end_define

begin_define
define|#
directive|define
name|HDA_BDL_DEFAULT
value|HDA_BDL_MIN
end_define

begin_define
define|#
directive|define
name|HDA_BLK_MIN
value|HDAC_DMA_ALIGNMENT
end_define

begin_define
define|#
directive|define
name|HDA_BLK_ALIGN
value|(~(HDA_BLK_MIN - 1))
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_MIN
value|4096
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_MAX
value|65536
end_define

begin_define
define|#
directive|define
name|HDA_BUFSZ_DEFAULT
value|16384
end_define

begin_define
define|#
directive|define
name|HDA_PARSE_MAXDEPTH
value|10
end_define

begin_define
define|#
directive|define
name|HDAC_UNSOLTAG_EVENT_HP
value|0x00
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HDAC
argument_list|,
literal|"hdac"
argument_list|,
literal|"High Definition Audio Controller"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_COLORS
index|[
literal|16
index|]
init|=
block|{
literal|"Unknown"
block|,
literal|"Black"
block|,
literal|"Grey"
block|,
literal|"Blue"
block|,
literal|"Green"
block|,
literal|"Red"
block|,
literal|"Orange"
block|,
literal|"Yellow"
block|,
literal|"Purple"
block|,
literal|"Pink"
block|,
literal|"Res.A"
block|,
literal|"Res.B"
block|,
literal|"Res.C"
block|,
literal|"Res.D"
block|,
literal|"White"
block|,
literal|"Other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_DEVS
index|[
literal|16
index|]
init|=
block|{
literal|"Line-out"
block|,
literal|"Speaker"
block|,
literal|"Headphones"
block|,
literal|"CD"
block|,
literal|"SPDIF-out"
block|,
literal|"Digital-out"
block|,
literal|"Modem-line"
block|,
literal|"Modem-handset"
block|,
literal|"Line-in"
block|,
literal|"AUX"
block|,
literal|"Mic"
block|,
literal|"Telephony"
block|,
literal|"SPDIF-in"
block|,
literal|"Digital-in"
block|,
literal|"Res.E"
block|,
literal|"Other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_CONNS
index|[
literal|4
index|]
init|=
block|{
literal|"Jack"
block|,
literal|"None"
block|,
literal|"Fixed"
block|,
literal|"Both"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|hdac_fmt
index|[]
init|=
block|{
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|hdac_caps
init|=
block|{
literal|48000
block|,
literal|48000
block|,
name|hdac_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|hdac_devices
index|[]
init|=
block|{
block|{
name|HDA_INTEL_82801F
block|,
literal|"Intel 82801F"
block|}
block|,
block|{
name|HDA_INTEL_63XXESB
block|,
literal|"Intel 631x/632xESB"
block|}
block|,
block|{
name|HDA_INTEL_82801G
block|,
literal|"Intel 82801G"
block|}
block|,
block|{
name|HDA_INTEL_82801H
block|,
literal|"Intel 82801H"
block|}
block|,
block|{
name|HDA_INTEL_82801I
block|,
literal|"Intel 82801I"
block|}
block|,
block|{
name|HDA_INTEL_82801J
block|,
literal|"Intel 82801J"
block|}
block|,
block|{
name|HDA_INTEL_PCH
block|,
literal|"Intel PCH"
block|}
block|,
block|{
name|HDA_INTEL_SCH
block|,
literal|"Intel SCH"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP51
block|,
literal|"NVidia MCP51"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP55
block|,
literal|"NVidia MCP55"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP61_1
block|,
literal|"NVidia MCP61"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP61_2
block|,
literal|"NVidia MCP61"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP65_1
block|,
literal|"NVidia MCP65"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP65_2
block|,
literal|"NVidia MCP65"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP67_1
block|,
literal|"NVidia MCP67"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP67_2
block|,
literal|"NVidia MCP67"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP73_1
block|,
literal|"NVidia MCP73"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP73_2
block|,
literal|"NVidia MCP73"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_1
block|,
literal|"NVidia MCP78"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_2
block|,
literal|"NVidia MCP78"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_3
block|,
literal|"NVidia MCP78"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP78_4
block|,
literal|"NVidia MCP78"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_1
block|,
literal|"NVidia MCP79"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_2
block|,
literal|"NVidia MCP79"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_3
block|,
literal|"NVidia MCP79"
block|}
block|,
block|{
name|HDA_NVIDIA_MCP79_4
block|,
literal|"NVidia MCP79"
block|}
block|,
block|{
name|HDA_ATI_SB450
block|,
literal|"ATI SB450"
block|}
block|,
block|{
name|HDA_ATI_SB600
block|,
literal|"ATI SB600"
block|}
block|,
block|{
name|HDA_ATI_RS600
block|,
literal|"ATI RS600"
block|}
block|,
block|{
name|HDA_ATI_RS690
block|,
literal|"ATI RS690"
block|}
block|,
block|{
name|HDA_ATI_RS780
block|,
literal|"ATI RS780"
block|}
block|,
block|{
name|HDA_ATI_R600
block|,
literal|"ATI R600"
block|}
block|,
block|{
name|HDA_ATI_RV610
block|,
literal|"ATI RV610"
block|}
block|,
block|{
name|HDA_ATI_RV620
block|,
literal|"ATI RV620"
block|}
block|,
block|{
name|HDA_ATI_RV630
block|,
literal|"ATI RV630"
block|}
block|,
block|{
name|HDA_ATI_RV635
block|,
literal|"ATI RV635"
block|}
block|,
block|{
name|HDA_ATI_RV710
block|,
literal|"ATI RV710"
block|}
block|,
block|{
name|HDA_ATI_RV730
block|,
literal|"ATI RV730"
block|}
block|,
block|{
name|HDA_ATI_RV740
block|,
literal|"ATI RV740"
block|}
block|,
block|{
name|HDA_ATI_RV770
block|,
literal|"ATI RV770"
block|}
block|,
block|{
name|HDA_VIA_VT82XX
block|,
literal|"VIA VT8251/8237A"
block|}
block|,
block|{
name|HDA_SIS_966
block|,
literal|"SiS 966"
block|}
block|,
block|{
name|HDA_ULI_M5461
block|,
literal|"ULI M5461"
block|}
block|,
comment|/* Unknown */
block|{
name|HDA_INTEL_ALL
block|,
literal|"Intel (Unknown)"
block|}
block|,
block|{
name|HDA_NVIDIA_ALL
block|,
literal|"NVidia (Unknown)"
block|}
block|,
block|{
name|HDA_ATI_ALL
block|,
literal|"ATI (Unknown)"
block|}
block|,
block|{
name|HDA_VIA_ALL
block|,
literal|"VIA (Unknown)"
block|}
block|,
block|{
name|HDA_SIS_ALL
block|,
literal|"SiS (Unknown)"
block|}
block|,
block|{
name|HDA_ULI_ALL
block|,
literal|"ULI (Unknown)"
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_DEVICES_LEN
value|(sizeof(hdac_devices) / sizeof(hdac_devices[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint8_t
name|reg
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|;
name|uint8_t
name|enable
decl_stmt|;
block|}
name|hdac_pcie_snoop
index|[]
init|=
block|{
block|{
name|INTEL_VENDORID
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
name|ATI_VENDORID
block|,
literal|0x42
block|,
literal|0xf8
block|,
literal|0x02
block|}
block|,
block|{
name|NVIDIA_VENDORID
block|,
literal|0x4e
block|,
literal|0xf0
block|,
literal|0x0f
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_PCIESNOOP_LEN
define|\
value|(sizeof(hdac_pcie_snoop) / sizeof(hdac_pcie_snoop[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|rate
decl_stmt|;
name|int
name|valid
decl_stmt|;
name|uint16_t
name|base
decl_stmt|;
name|uint16_t
name|mul
decl_stmt|;
name|uint16_t
name|div
decl_stmt|;
block|}
name|hda_rate_tab
index|[]
init|=
block|{
block|{
literal|8000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0500
block|}
block|,
comment|/* (48000 * 1) / 6 */
block|{
literal|9600
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 1) / 5 */
block|{
literal|12000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
comment|/* (48000 * 1) / 4 */
block|{
literal|16000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 1) / 3 */
block|{
literal|18000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0700
block|}
block|,
comment|/* (48000 * 3) / 8 */
block|{
literal|19200
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 2) / 5 */
block|{
literal|24000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0100
block|}
block|,
comment|/* (48000 * 1) / 2 */
block|{
literal|28800
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 3) / 5 */
block|{
literal|32000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 2) / 3 */
block|{
literal|36000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0300
block|}
block|,
comment|/* (48000 * 3) / 4 */
block|{
literal|38400
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 4) / 5 */
block|{
literal|48000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 1) / 1 */
block|{
literal|64000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 4) / 3 */
block|{
literal|72000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0100
block|}
block|,
comment|/* (48000 * 3) / 2 */
block|{
literal|96000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 2) / 1 */
block|{
literal|144000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 3) / 1 */
block|{
literal|192000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 4) / 1 */
block|{
literal|8820
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 1) / 5 */
block|{
literal|11025
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
comment|/* (44100 * 1) / 4 */
block|{
literal|12600
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 2) / 7 */
block|{
literal|14700
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 1) / 3 */
block|{
literal|17640
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 2) / 5 */
block|{
literal|18900
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 3) / 7 */
block|{
literal|22050
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0100
block|}
block|,
comment|/* (44100 * 1) / 2 */
block|{
literal|25200
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 4) / 7 */
block|{
literal|26460
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 3) / 5 */
block|{
literal|29400
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 2) / 3 */
block|{
literal|33075
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0300
block|}
block|,
comment|/* (44100 * 3) / 4 */
block|{
literal|35280
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 4) / 5 */
block|{
literal|44100
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 1) / 1 */
block|{
literal|58800
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 4) / 3 */
block|{
literal|66150
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0100
block|}
block|,
comment|/* (44100 * 3) / 2 */
block|{
literal|88200
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 2) / 1 */
block|{
literal|132300
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 3) / 1 */
block|{
literal|176400
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 4) / 1 */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HDA_RATE_TAB_LEN
value|(sizeof(hda_rate_tab) / sizeof(hda_rate_tab[0]))
end_define

begin_comment
comment|/* All codecs you can eat... */
end_comment

begin_define
define|#
directive|define
name|HDA_CODEC_CONSTRUCT
parameter_list|(
name|vendor
parameter_list|,
name|id
parameter_list|)
define|\
value|(((uint32_t)(vendor##_VENDORID)<< 16) | ((id)& 0xffff))
end_define

begin_comment
comment|/* Realtek */
end_comment

begin_define
define|#
directive|define
name|REALTEK_VENDORID
value|0x10ec
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC260
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0260)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC262
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0262)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC267
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0267)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC268
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0268)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC269
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0269)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC272
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0272)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC660
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0660)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC662
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0662)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC663
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0663)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC861
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0861)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC861VD
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0862)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC880
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0880)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC882
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0882)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC883
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0883)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC885
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0885)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC888
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0888)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALC889
value|HDA_CODEC_CONSTRUCT(REALTEK, 0x0889)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ALCXXXX
value|HDA_CODEC_CONSTRUCT(REALTEK, 0xffff)
end_define

begin_comment
comment|/* Analog Devices */
end_comment

begin_define
define|#
directive|define
name|ANALOGDEVICES_VENDORID
value|0x11d4
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1884A
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x184a)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1882
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1882)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1883
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1883)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1884
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1884)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1984A
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x194a)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1984B
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x194b)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1981HD
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1981)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1983
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1983)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1984
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1984)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1986A
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1986)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1987
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1987)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1988
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x1988)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1988B
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x198b)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1882A
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x882a)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AD1989B
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0x989b)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ADXXXX
value|HDA_CODEC_CONSTRUCT(ANALOGDEVICES, 0xffff)
end_define

begin_comment
comment|/* CMedia */
end_comment

begin_define
define|#
directive|define
name|CMEDIA_VENDORID
value|0x434d
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CMI9880
value|HDA_CODEC_CONSTRUCT(CMEDIA, 0x4980)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CMIXXXX
value|HDA_CODEC_CONSTRUCT(CMEDIA, 0xffff)
end_define

begin_comment
comment|/* Sigmatel */
end_comment

begin_define
define|#
directive|define
name|SIGMATEL_VENDORID
value|0x8384
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9230X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7612)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9230D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7613)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9229X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7614)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9229D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7615)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9228X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7616)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9228D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7617)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9227X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7618)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9227D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7619)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9274
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7620)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9274D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7621)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9273X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7622)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9273D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7623)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9272X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7624)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9272D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7625)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9271X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7626)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9271D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7627)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9274X5NH
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7628)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9274D5NH
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7629)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9250
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7634)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9251
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7636)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD700X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7638)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD700D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7639)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD206X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7645)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD206D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7646)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9872AK
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7662)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9221
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7680)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC922XD
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7681)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9221_A2
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7682)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9221D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7683)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9220
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7690)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9200D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7691)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD005
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7698)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD005D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7699)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9205X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x76a0)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9205D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x76a1)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9204X
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x76a2)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9204D
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x76a3)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9220_A2
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7880)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STAC9220_A1
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0x7882)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_STACXXXX
value|HDA_CODEC_CONSTRUCT(SIGMATEL, 0xffff)
end_define

begin_comment
comment|/* IDT */
end_comment

begin_define
define|#
directive|define
name|IDT_VENDORID
value|0x111d
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD75BX
value|HDA_CODEC_CONSTRUCT(IDT, 0x7603)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD83C1X
value|HDA_CODEC_CONSTRUCT(IDT, 0x7604)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD81B1X
value|HDA_CODEC_CONSTRUCT(IDT, 0x7605)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD75B3
value|HDA_CODEC_CONSTRUCT(IDT, 0x7608)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD73D1
value|HDA_CODEC_CONSTRUCT(IDT, 0x7674)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD73C1
value|HDA_CODEC_CONSTRUCT(IDT, 0x7675)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD73E1
value|HDA_CODEC_CONSTRUCT(IDT, 0x7676)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD71B8
value|HDA_CODEC_CONSTRUCT(IDT, 0x76b0)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD71B7
value|HDA_CODEC_CONSTRUCT(IDT, 0x76b2)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD71B5
value|HDA_CODEC_CONSTRUCT(IDT, 0x76b6)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD83C1C
value|HDA_CODEC_CONSTRUCT(IDT, 0x76d4)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDT92HD81B1C
value|HDA_CODEC_CONSTRUCT(IDT, 0x76d5)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_IDTXXXX
value|HDA_CODEC_CONSTRUCT(IDT, 0xffff)
end_define

begin_comment
comment|/* Silicon Image */
end_comment

begin_define
define|#
directive|define
name|SII_VENDORID
value|0x1095
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_SII1390
value|HDA_CODEC_CONSTRUCT(SII, 0x1390)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_SII1392
value|HDA_CODEC_CONSTRUCT(SII, 0x1392)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_SIIXXXX
value|HDA_CODEC_CONSTRUCT(SII, 0xffff)
end_define

begin_comment
comment|/* Lucent/Agere */
end_comment

begin_define
define|#
directive|define
name|AGERE_VENDORID
value|0x11c1
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_AGEREXXXX
value|HDA_CODEC_CONSTRUCT(AGERE, 0xffff)
end_define

begin_comment
comment|/* Conexant */
end_comment

begin_define
define|#
directive|define
name|CONEXANT_VENDORID
value|0x14f1
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CX20549
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0x5045)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CX20551
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0x5047)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CX20561
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0x5051)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_CXXXXX
value|HDA_CODEC_CONSTRUCT(CONEXANT, 0xffff)
end_define

begin_comment
comment|/* VIA */
end_comment

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708_8
value|HDA_CODEC_CONSTRUCT(VIA, 0x1708)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708_9
value|HDA_CODEC_CONSTRUCT(VIA, 0x1709)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708_A
value|HDA_CODEC_CONSTRUCT(VIA, 0x170a)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708_B
value|HDA_CODEC_CONSTRUCT(VIA, 0x170b)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_0
value|HDA_CODEC_CONSTRUCT(VIA, 0xe710)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_1
value|HDA_CODEC_CONSTRUCT(VIA, 0xe711)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_2
value|HDA_CODEC_CONSTRUCT(VIA, 0xe712)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_3
value|HDA_CODEC_CONSTRUCT(VIA, 0xe713)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_4
value|HDA_CODEC_CONSTRUCT(VIA, 0xe714)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_5
value|HDA_CODEC_CONSTRUCT(VIA, 0xe715)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_6
value|HDA_CODEC_CONSTRUCT(VIA, 0xe716)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1709_7
value|HDA_CODEC_CONSTRUCT(VIA, 0xe717)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_0
value|HDA_CODEC_CONSTRUCT(VIA, 0xe720)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_1
value|HDA_CODEC_CONSTRUCT(VIA, 0xe721)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_2
value|HDA_CODEC_CONSTRUCT(VIA, 0xe722)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_3
value|HDA_CODEC_CONSTRUCT(VIA, 0xe723)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_4
value|HDA_CODEC_CONSTRUCT(VIA, 0xe724)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_5
value|HDA_CODEC_CONSTRUCT(VIA, 0xe725)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_6
value|HDA_CODEC_CONSTRUCT(VIA, 0xe726)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708B_7
value|HDA_CODEC_CONSTRUCT(VIA, 0xe727)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_0
value|HDA_CODEC_CONSTRUCT(VIA, 0x0397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_1
value|HDA_CODEC_CONSTRUCT(VIA, 0x1397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_2
value|HDA_CODEC_CONSTRUCT(VIA, 0x2397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_3
value|HDA_CODEC_CONSTRUCT(VIA, 0x3397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_4
value|HDA_CODEC_CONSTRUCT(VIA, 0x4397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_5
value|HDA_CODEC_CONSTRUCT(VIA, 0x5397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_6
value|HDA_CODEC_CONSTRUCT(VIA, 0x6397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1708S_7
value|HDA_CODEC_CONSTRUCT(VIA, 0x7397)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_0
value|HDA_CODEC_CONSTRUCT(VIA, 0x0398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_1
value|HDA_CODEC_CONSTRUCT(VIA, 0x1398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_2
value|HDA_CODEC_CONSTRUCT(VIA, 0x2398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_3
value|HDA_CODEC_CONSTRUCT(VIA, 0x3398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_4
value|HDA_CODEC_CONSTRUCT(VIA, 0x4398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_5
value|HDA_CODEC_CONSTRUCT(VIA, 0x5398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_6
value|HDA_CODEC_CONSTRUCT(VIA, 0x6398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VT1702_7
value|HDA_CODEC_CONSTRUCT(VIA, 0x7398)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_VTXXXX
value|HDA_CODEC_CONSTRUCT(VIA, 0xffff)
end_define

begin_comment
comment|/* ATI */
end_comment

begin_define
define|#
directive|define
name|HDA_CODEC_ATIRS600_1
value|HDA_CODEC_CONSTRUCT(ATI, 0x793c)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ATIRS600_2
value|HDA_CODEC_CONSTRUCT(ATI, 0x7919)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ATIRS690
value|HDA_CODEC_CONSTRUCT(ATI, 0x791a)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ATIR6XX
value|HDA_CODEC_CONSTRUCT(ATI, 0xaa01)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_ATIXXXX
value|HDA_CODEC_CONSTRUCT(ATI, 0xffff)
end_define

begin_comment
comment|/* NVIDIA */
end_comment

begin_define
define|#
directive|define
name|HDA_CODEC_NVIDIAMCP78
value|HDA_CODEC_CONSTRUCT(NVIDIA, 0x0002)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_NVIDIAMCP7A
value|HDA_CODEC_CONSTRUCT(NVIDIA, 0x0007)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_NVIDIAMCP67
value|HDA_CODEC_CONSTRUCT(NVIDIA, 0x0067)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_NVIDIAXXXX
value|HDA_CODEC_CONSTRUCT(NVIDIA, 0xffff)
end_define

begin_comment
comment|/* INTEL */
end_comment

begin_define
define|#
directive|define
name|HDA_CODEC_INTELG45_1
value|HDA_CODEC_CONSTRUCT(INTEL, 0x2801)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_INTELG45_2
value|HDA_CODEC_CONSTRUCT(INTEL, 0x2802)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_INTELG45_3
value|HDA_CODEC_CONSTRUCT(INTEL, 0x2803)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_INTELG45_4
value|HDA_CODEC_CONSTRUCT(INTEL, 0x29fb)
end_define

begin_define
define|#
directive|define
name|HDA_CODEC_INTELXXXX
value|HDA_CODEC_CONSTRUCT(INTEL, 0xffff)
end_define

begin_comment
comment|/* Codecs */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|hdac_codecs
index|[]
init|=
block|{
block|{
name|HDA_CODEC_ALC260
block|,
literal|"Realtek ALC260"
block|}
block|,
block|{
name|HDA_CODEC_ALC262
block|,
literal|"Realtek ALC262"
block|}
block|,
block|{
name|HDA_CODEC_ALC267
block|,
literal|"Realtek ALC267"
block|}
block|,
block|{
name|HDA_CODEC_ALC268
block|,
literal|"Realtek ALC268"
block|}
block|,
block|{
name|HDA_CODEC_ALC269
block|,
literal|"Realtek ALC269"
block|}
block|,
block|{
name|HDA_CODEC_ALC272
block|,
literal|"Realtek ALC272"
block|}
block|,
block|{
name|HDA_CODEC_ALC660
block|,
literal|"Realtek ALC660"
block|}
block|,
block|{
name|HDA_CODEC_ALC662
block|,
literal|"Realtek ALC662"
block|}
block|,
block|{
name|HDA_CODEC_ALC663
block|,
literal|"Realtek ALC663"
block|}
block|,
block|{
name|HDA_CODEC_ALC861
block|,
literal|"Realtek ALC861"
block|}
block|,
block|{
name|HDA_CODEC_ALC861VD
block|,
literal|"Realtek ALC861-VD"
block|}
block|,
block|{
name|HDA_CODEC_ALC880
block|,
literal|"Realtek ALC880"
block|}
block|,
block|{
name|HDA_CODEC_ALC882
block|,
literal|"Realtek ALC882"
block|}
block|,
block|{
name|HDA_CODEC_ALC883
block|,
literal|"Realtek ALC883"
block|}
block|,
block|{
name|HDA_CODEC_ALC885
block|,
literal|"Realtek ALC885"
block|}
block|,
block|{
name|HDA_CODEC_ALC888
block|,
literal|"Realtek ALC888"
block|}
block|,
block|{
name|HDA_CODEC_ALC889
block|,
literal|"Realtek ALC889"
block|}
block|,
block|{
name|HDA_CODEC_AD1882
block|,
literal|"Analog Devices AD1882"
block|}
block|,
block|{
name|HDA_CODEC_AD1882A
block|,
literal|"Analog Devices AD1882A"
block|}
block|,
block|{
name|HDA_CODEC_AD1883
block|,
literal|"Analog Devices AD1883"
block|}
block|,
block|{
name|HDA_CODEC_AD1884
block|,
literal|"Analog Devices AD1884"
block|}
block|,
block|{
name|HDA_CODEC_AD1884A
block|,
literal|"Analog Devices AD1884A"
block|}
block|,
block|{
name|HDA_CODEC_AD1981HD
block|,
literal|"Analog Devices AD1981HD"
block|}
block|,
block|{
name|HDA_CODEC_AD1983
block|,
literal|"Analog Devices AD1983"
block|}
block|,
block|{
name|HDA_CODEC_AD1984
block|,
literal|"Analog Devices AD1984"
block|}
block|,
block|{
name|HDA_CODEC_AD1984A
block|,
literal|"Analog Devices AD1984A"
block|}
block|,
block|{
name|HDA_CODEC_AD1984B
block|,
literal|"Analog Devices AD1984B"
block|}
block|,
block|{
name|HDA_CODEC_AD1986A
block|,
literal|"Analog Devices AD1986A"
block|}
block|,
block|{
name|HDA_CODEC_AD1987
block|,
literal|"Analog Devices AD1987"
block|}
block|,
block|{
name|HDA_CODEC_AD1988
block|,
literal|"Analog Devices AD1988A"
block|}
block|,
block|{
name|HDA_CODEC_AD1988B
block|,
literal|"Analog Devices AD1988B"
block|}
block|,
block|{
name|HDA_CODEC_AD1989B
block|,
literal|"Analog Devices AD1989B"
block|}
block|,
block|{
name|HDA_CODEC_CMI9880
block|,
literal|"CMedia CMI9880"
block|}
block|,
block|{
name|HDA_CODEC_STAC9200D
block|,
literal|"Sigmatel STAC9200D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9204X
block|,
literal|"Sigmatel STAC9204X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9204D
block|,
literal|"Sigmatel STAC9204D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9205X
block|,
literal|"Sigmatel STAC9205X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9205D
block|,
literal|"Sigmatel STAC9205D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9220
block|,
literal|"Sigmatel STAC9220"
block|}
block|,
block|{
name|HDA_CODEC_STAC9220_A1
block|,
literal|"Sigmatel STAC9220_A1"
block|}
block|,
block|{
name|HDA_CODEC_STAC9220_A2
block|,
literal|"Sigmatel STAC9220_A2"
block|}
block|,
block|{
name|HDA_CODEC_STAC9221
block|,
literal|"Sigmatel STAC9221"
block|}
block|,
block|{
name|HDA_CODEC_STAC9221_A2
block|,
literal|"Sigmatel STAC9221_A2"
block|}
block|,
block|{
name|HDA_CODEC_STAC9221D
block|,
literal|"Sigmatel STAC9221D"
block|}
block|,
block|{
name|HDA_CODEC_STAC922XD
block|,
literal|"Sigmatel STAC9220D/9223D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9227X
block|,
literal|"Sigmatel STAC9227X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9227D
block|,
literal|"Sigmatel STAC9227D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9228X
block|,
literal|"Sigmatel STAC9228X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9228D
block|,
literal|"Sigmatel STAC9228D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9229X
block|,
literal|"Sigmatel STAC9229X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9229D
block|,
literal|"Sigmatel STAC9229D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9230X
block|,
literal|"Sigmatel STAC9230X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9230D
block|,
literal|"Sigmatel STAC9230D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9250
block|,
literal|"Sigmatel STAC9250"
block|}
block|,
block|{
name|HDA_CODEC_STAC9251
block|,
literal|"Sigmatel STAC9251"
block|}
block|,
block|{
name|HDA_CODEC_STAC9271X
block|,
literal|"Sigmatel STAC9271X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9271D
block|,
literal|"Sigmatel STAC9271D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9272X
block|,
literal|"Sigmatel STAC9272X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9272D
block|,
literal|"Sigmatel STAC9272D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9273X
block|,
literal|"Sigmatel STAC9273X"
block|}
block|,
block|{
name|HDA_CODEC_STAC9273D
block|,
literal|"Sigmatel STAC9273D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9274
block|,
literal|"Sigmatel STAC9274"
block|}
block|,
block|{
name|HDA_CODEC_STAC9274D
block|,
literal|"Sigmatel STAC9274D"
block|}
block|,
block|{
name|HDA_CODEC_STAC9274X5NH
block|,
literal|"Sigmatel STAC9274X5NH"
block|}
block|,
block|{
name|HDA_CODEC_STAC9274D5NH
block|,
literal|"Sigmatel STAC9274D5NH"
block|}
block|,
block|{
name|HDA_CODEC_STAC9872AK
block|,
literal|"Sigmatel STAC9872AK"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD005
block|,
literal|"IDT 92HD005"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD005D
block|,
literal|"IDT 92HD005D"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD206X
block|,
literal|"IDT 92HD206X"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD206D
block|,
literal|"IDT 92HD206D"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD700X
block|,
literal|"IDT 92HD700X"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD700D
block|,
literal|"IDT 92HD700D"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD71B5
block|,
literal|"IDT 92HD71B5"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD71B7
block|,
literal|"IDT 92HD71B7"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD71B8
block|,
literal|"IDT 92HD71B8"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD73C1
block|,
literal|"IDT 92HD73C1"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD73D1
block|,
literal|"IDT 92HD73D1"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD73E1
block|,
literal|"IDT 92HD73E1"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD75B3
block|,
literal|"IDT 92HD75B3"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD75BX
block|,
literal|"IDT 92HD75BX"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD81B1C
block|,
literal|"IDT 92HD81B1C"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD81B1X
block|,
literal|"IDT 92HD81B1X"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD83C1C
block|,
literal|"IDT 92HD83C1C"
block|}
block|,
block|{
name|HDA_CODEC_IDT92HD83C1X
block|,
literal|"IDT 92HD83C1X"
block|}
block|,
block|{
name|HDA_CODEC_CX20549
block|,
literal|"Conexant CX20549 (Venice)"
block|}
block|,
block|{
name|HDA_CODEC_CX20551
block|,
literal|"Conexant CX20551 (Waikiki)"
block|}
block|,
block|{
name|HDA_CODEC_CX20561
block|,
literal|"Conexant CX20561 (Hermosa)"
block|}
block|,
block|{
name|HDA_CODEC_VT1708_8
block|,
literal|"VIA VT1708_8"
block|}
block|,
block|{
name|HDA_CODEC_VT1708_9
block|,
literal|"VIA VT1708_9"
block|}
block|,
block|{
name|HDA_CODEC_VT1708_A
block|,
literal|"VIA VT1708_A"
block|}
block|,
block|{
name|HDA_CODEC_VT1708_B
block|,
literal|"VIA VT1708_B"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_0
block|,
literal|"VIA VT1709_0"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_1
block|,
literal|"VIA VT1709_1"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_2
block|,
literal|"VIA VT1709_2"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_3
block|,
literal|"VIA VT1709_3"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_4
block|,
literal|"VIA VT1709_4"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_5
block|,
literal|"VIA VT1709_5"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_6
block|,
literal|"VIA VT1709_6"
block|}
block|,
block|{
name|HDA_CODEC_VT1709_7
block|,
literal|"VIA VT1709_7"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_0
block|,
literal|"VIA VT1708B_0"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_1
block|,
literal|"VIA VT1708B_1"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_2
block|,
literal|"VIA VT1708B_2"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_3
block|,
literal|"VIA VT1708B_3"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_4
block|,
literal|"VIA VT1708B_4"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_5
block|,
literal|"VIA VT1708B_5"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_6
block|,
literal|"VIA VT1708B_6"
block|}
block|,
block|{
name|HDA_CODEC_VT1708B_7
block|,
literal|"VIA VT1708B_7"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_0
block|,
literal|"VIA VT1708S_0"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_1
block|,
literal|"VIA VT1708S_1"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_2
block|,
literal|"VIA VT1708S_2"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_3
block|,
literal|"VIA VT1708S_3"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_4
block|,
literal|"VIA VT1708S_4"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_5
block|,
literal|"VIA VT1708S_5"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_6
block|,
literal|"VIA VT1708S_6"
block|}
block|,
block|{
name|HDA_CODEC_VT1708S_7
block|,
literal|"VIA VT1708S_7"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_0
block|,
literal|"VIA VT1702_0"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_1
block|,
literal|"VIA VT1702_1"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_2
block|,
literal|"VIA VT1702_2"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_3
block|,
literal|"VIA VT1702_3"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_4
block|,
literal|"VIA VT1702_4"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_5
block|,
literal|"VIA VT1702_5"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_6
block|,
literal|"VIA VT1702_6"
block|}
block|,
block|{
name|HDA_CODEC_VT1702_7
block|,
literal|"VIA VT1702_7"
block|}
block|,
block|{
name|HDA_CODEC_ATIRS600_1
block|,
literal|"ATI RS600 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_ATIRS600_2
block|,
literal|"ATI RS600 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_ATIRS690
block|,
literal|"ATI RS690/780 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_ATIR6XX
block|,
literal|"ATI R6xx HDMI"
block|}
block|,
block|{
name|HDA_CODEC_NVIDIAMCP67
block|,
literal|"NVidia MCP67 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_NVIDIAMCP78
block|,
literal|"NVidia MCP78 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_NVIDIAMCP7A
block|,
literal|"NVidia MCP7A HDMI"
block|}
block|,
block|{
name|HDA_CODEC_INTELG45_1
block|,
literal|"Intel G45 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_INTELG45_2
block|,
literal|"Intel G45 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_INTELG45_3
block|,
literal|"Intel G45 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_INTELG45_4
block|,
literal|"Intel G45 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_SII1390
block|,
literal|"Silicon Image SiI1390 HDMI"
block|}
block|,
block|{
name|HDA_CODEC_SII1392
block|,
literal|"Silicon Image SiI1392 HDMI"
block|}
block|,
comment|/* Unknown codec */
block|{
name|HDA_CODEC_ALCXXXX
block|,
literal|"Realtek (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_ADXXXX
block|,
literal|"Analog Devices (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_CMIXXXX
block|,
literal|"CMedia (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_STACXXXX
block|,
literal|"Sigmatel (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_SIIXXXX
block|,
literal|"Silicon Image (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_AGEREXXXX
block|,
literal|"Lucent/Agere Systems (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_CXXXXX
block|,
literal|"Conexant (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_VTXXXX
block|,
literal|"VIA (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_ATIXXXX
block|,
literal|"ATI (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_NVIDIAXXXX
block|,
literal|"NVidia (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_INTELXXXX
block|,
literal|"Intel (Unknown)"
block|}
block|,
block|{
name|HDA_CODEC_IDTXXXX
block|,
literal|"IDT (Unknown)"
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_CODECS_LEN
value|(sizeof(hdac_codecs) / sizeof(hdac_codecs[0]))
end_define

begin_comment
comment|/****************************************************************************  * Function prototypes  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|hdac_intr_handler
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_reset
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_get_capabilities
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dma_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_dma_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_dma
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dma_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_dma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_mem_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_mem_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_irq_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_irq_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_corb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_rirb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_corb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_rirb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_scan_codecs
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_probe_codec
parameter_list|(
name|struct
name|hdac_codec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_probe_function
parameter_list|(
name|struct
name|hdac_codec
modifier|*
parameter_list|,
name|nid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_pcmchannel_setup
parameter_list|(
name|struct
name|hdac_chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_attach2
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|hdac_command_sendone_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_command_send_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|struct
name|hdac_command_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_widget_connection_select
parameter_list|(
name|struct
name|hdac_widget
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_audio_ctl_amp_set
parameter_list|(
name|struct
name|hdac_audio_ctl
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hdac_audio_ctl
modifier|*
name|hdac_audio_ctl_amp_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_audio_ctl_amp_set_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|nid_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hdac_widget
modifier|*
name|hdac_widget_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
parameter_list|,
name|nid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_rirb_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hdac_unsolq_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdac_dump_pin_config
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|,
name|uint32_t
name|conf
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|hdac_command
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
define|\
value|hdac_command_sendone_internal(a1, a2, a3)
end_define

begin_define
define|#
directive|define
name|hdac_codec_id
parameter_list|(
name|c
parameter_list|)
define|\
value|((uint32_t)((c == NULL) ? 0x00000000 :	\ 		((((uint32_t)(c)->vendor_id& 0x0000ffff)<< 16) |	\ 		((uint32_t)(c)->device_id& 0x0000ffff))))
end_define

begin_function
specifier|static
name|char
modifier|*
name|hdac_codec_name
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|)
block|{
name|uint32_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|codec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODECS_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_codecs
index|[
name|i
index|]
operator|.
name|id
argument_list|,
name|id
argument_list|)
condition|)
return|return
operator|(
name|hdac_codecs
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|id
operator|==
literal|0x00000000
operator|)
condition|?
literal|"NULL Codec"
else|:
literal|"Unknown Codec"
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|hdac_audio_ctl_ossmixer_mask2allname
parameter_list|(
name|uint32_t
name|mask
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ossname
index|[]
init|=
name|SOUND_DEVICE_NAMES
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|ossname
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_audio_ctl
modifier|*
name|hdac_audio_ctl_each
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|node_type
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
operator|||
name|index
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
operator|<
literal|1
operator|||
operator|*
name|index
operator|<
literal|0
operator|||
operator|*
name|index
operator|>=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_audio_ctl
modifier|*
name|hdac_audio_ctl_amp_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|!=
name|nid
condition|)
continue|continue;
if|if
condition|(
name|dir
operator|&&
name|ctl
operator|->
name|ndir
operator|!=
name|dir
condition|)
continue|continue;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|ndir
operator|==
name|HDA_CTL_IN
operator|&&
name|ctl
operator|->
name|dir
operator|==
name|ctl
operator|->
name|ndir
operator|&&
name|ctl
operator|->
name|index
operator|!=
name|index
condition|)
continue|continue;
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|cnt
operator|||
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|ctl
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Jack detection (Speaker/HP redirection) event handler.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_hp_switch_handler
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|as
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|hpredir
operator|<
literal|0
condition|)
continue|continue;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
name|cad
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Pin sense: nid=%d res=0x%08x\n"
argument|, 			    as[i].pins[
literal|15
argument|], res);
argument_list|)
empty_stmt|;
name|res
operator|=
name|HDA_CMD_GET_PIN_SENSE_PRESENCE_DETECT
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_SENSEINV
condition|)
name|res
operator|^=
literal|1
expr_stmt|;
comment|/* (Un)Mute headphone pin. */
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|,
name|HDA_CTL_IN
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
operator|&&
name|ctl
operator|->
name|mute
condition|)
block|{
comment|/* If pin has muter - use it. */
name|val
operator|=
operator|(
name|res
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|ctl
operator|->
name|forcemute
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
name|val
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_DEFAULT
argument_list|,
name|HDA_AMP_VOL_DEFAULT
argument_list|,
name|HDA_AMP_VOL_DEFAULT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If there is no muter - disable pin output. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
name|val
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
else|else
name|val
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|val
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* (Un)Mute other pins. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|15
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
name|j
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
name|j
index|]
argument_list|,
name|HDA_CTL_IN
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
operator|&&
name|ctl
operator|->
name|mute
condition|)
block|{
comment|/* If pin has muter - use it. */
name|val
operator|=
operator|(
name|res
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|ctl
operator|->
name|forcemute
condition|)
continue|continue;
name|ctl
operator|->
name|forcemute
operator|=
name|val
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_DEFAULT
argument_list|,
name|HDA_AMP_VOL_DEFAULT
argument_list|,
name|HDA_AMP_VOL_DEFAULT
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If there is no muter - disable pin output. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
name|val
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
else|else
name|val
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|val
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Callback for poll based jack detection.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_jack_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|arg
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|poll_ival
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdac_hp_switch_handler
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|,
name|sc
operator|->
name|poll_ival
argument_list|,
name|hdac_jack_poll_callback
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jack detection initializer.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_hp_switch_init
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|enable
init|=
literal|0
decl_stmt|,
name|poll
init|=
literal|0
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
operator|->
name|codec
argument_list|)
expr_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|hpredir
operator|<
literal|0
condition|)
continue|continue;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"No jack detection support at pin %d\n"
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|enable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_UNSOL_CAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE_ENABLE
operator||
name|HDAC_UNSOLTAG_EVENT_HP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
else|else
name|poll
operator|=
literal|1
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Enabling headphone/speaker "
literal|"audio routing switching:\n"
argument|); 			device_printf(sc->dev,
literal|"\tas=%d sense nid=%d [%s]\n"
argument|, 			    i, w->nid, (poll !=
literal|0
argument|) ?
literal|"POLL"
argument|:
literal|"UNSOL"
argument|);
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
block|{
name|hdac_hp_switch_handler
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|poll
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|,
literal|1
argument_list|,
name|hdac_jack_poll_callback
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Unsolicited messages handler.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_unsolicited_handler
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|,
name|uint32_t
name|tag
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
operator|||
name|codec
operator|->
name|sc
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|codec
operator|->
name|sc
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Unsol Tag: 0x%08x\n"
argument|, tag);
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|codec
operator|->
name|num_fgs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|codec
operator|->
name|fgs
index|[
name|i
index|]
operator|.
name|node_type
operator|==
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
block|{
name|devinfo
operator|=
operator|&
name|codec
operator|->
name|fgs
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|HDAC_UNSOLTAG_EVENT_HP
case|:
name|hdac_hp_switch_handler
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown unsol tag: 0x%08x!\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_stream_intr
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|uint32_t
name|res
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|flags
operator|&
name|HDAC_CHN_RUNNING
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|res
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDSTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (res& (HDAC_SDSTS_DESE | HDAC_SDSTS_FIFOE)) 			device_printf(ch->pdevinfo->dev,
literal|"PCMDIR_%s intr triggered beyond stream boundary:"
literal|"%08x\n"
argument|, 			    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, res);
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDSTS
argument_list|,
name|HDAC_SDSTS_DESE
operator||
name|HDAC_SDSTS_FIFOE
operator||
name|HDAC_SDSTS_BCIS
argument_list|)
expr_stmt|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
if|if
condition|(
name|res
operator|&
name|HDAC_SDSTS_BCIS
condition|)
block|{
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_intr_handler(void *)  *  * Interrupt handler. Processes interrupts received from the hdac.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_intr_handler
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|intsts
decl_stmt|;
name|uint8_t
name|rirbsts
decl_stmt|;
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|;
name|uint32_t
name|trigger
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|context
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do we have anything to do? */
name|intsts
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HDA_FLAG_MATCH
argument_list|(
name|intsts
argument_list|,
name|HDAC_INTSTS_GIS
argument_list|)
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|trigger
operator|=
literal|0
expr_stmt|;
comment|/* Was this a controller interrupt? */
if|if
condition|(
name|HDA_FLAG_MATCH
argument_list|(
name|intsts
argument_list|,
name|HDAC_INTSTS_CIS
argument_list|)
condition|)
block|{
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirbsts
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|)
expr_stmt|;
comment|/* Get as many responses that we can */
while|while
condition|(
name|HDA_FLAG_MATCH
argument_list|(
name|rirbsts
argument_list|,
name|HDAC_RIRBSTS_RINTFL
argument_list|)
condition|)
block|{
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|,
name|HDAC_RIRBSTS_RINTFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|trigger
operator||=
name|HDAC_TRIGGER_UNSOL
expr_stmt|;
name|rirbsts
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSTS
argument_list|)
expr_stmt|;
block|}
comment|/* XXX to be removed */
comment|/* Clear interrupt and exit */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|,
name|HDAC_INTSTS_CIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|intsts
operator|&
name|HDAC_INTSTS_SIS_MASK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|intsts
operator|&
operator|(
literal|1
operator|<<
operator|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|off
operator|>>
literal|5
operator|)
operator|)
operator|)
operator|&&
name|hdac_stream_intr
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|chans
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|trigger
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
comment|/* XXX to be removed */
ifdef|#
directive|ifdef
name|HDAC_INTR_EXTRA
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTSTS
argument_list|,
name|intsts
operator|&
name|HDAC_INTSTS_SIS_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trigger
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trigger
operator|&
name|HDAC_TRIGGER_UNSOL
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_reset(hdac_softc *, int)  *  * Reset the hdac to a quiescent and known state.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_reset
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|int
name|wakeup
parameter_list|)
block|{
name|uint32_t
name|gctl
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Stop all Streams DMA engine 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_iss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_ISDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_oss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_OSDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_bss
condition|;
name|i
operator|++
control|)
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_BSDCTL
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Stop Control DMA engines. 	 */
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset DMA position buffer. 	 */
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBLBASE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBUBASE
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the controller. The reset must remain asserted for 	 * a minimum of 100us. 	 */
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|gctl
operator|&
operator|~
name|HDAC_GCTL_CRST
argument_list|)
expr_stmt|;
name|count
operator|=
literal|10000
expr_stmt|;
do|do
block|{
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
if|if
condition|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to put hdac in reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* If wakeup is not requested - leave the controller in reset state. */
if|if
condition|(
operator|!
name|wakeup
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|gctl
operator||
name|HDAC_GCTL_CRST
argument_list|)
expr_stmt|;
name|count
operator|=
literal|10000
expr_stmt|;
do|do
block|{
name|gctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|gctl
operator|&
name|HDAC_GCTL_CRST
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Device stuck in reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Wait for codecs to finish their own reset sequence. The delay here 	 * should be of 250us but for some reasons, on it's not enough on my 	 * computer. Let's use twice as much as necessary to make sure that 	 * it's reset properly. 	 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_get_capabilities(struct hdac_softc *);  *  * Retreive the general capabilities of the hdac;  *	Number of Input Streams  *	Number of Output Streams  *	Number of bidirectional Streams  *	64bit ready  *	CORB and RIRB sizes  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_get_capabilities
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|gcap
decl_stmt|;
name|uint8_t
name|corbsize
decl_stmt|,
name|rirbsize
decl_stmt|;
name|gcap
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCAP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_iss
operator|=
name|HDAC_GCAP_ISS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_oss
operator|=
name|HDAC_GCAP_OSS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|num_bss
operator|=
name|HDAC_GCAP_BSS
argument_list|(
name|gcap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|support_64bit
operator|=
name|HDA_FLAG_MATCH
argument_list|(
name|gcap
argument_list|,
name|HDAC_GCAP_64OK
argument_list|)
expr_stmt|;
name|corbsize
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_256
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_256
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_16
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_16
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|corbsize
operator|&
name|HDAC_CORBSIZE_CORBSZCAP_2
operator|)
operator|==
name|HDAC_CORBSIZE_CORBSZCAP_2
condition|)
name|sc
operator|->
name|corb_size
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Invalid corb size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|corbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rirbsize
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_256
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_256
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_16
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_16
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rirbsize
operator|&
name|HDAC_RIRBSIZE_RIRBSZCAP_2
operator|)
operator|==
name|HDAC_RIRBSIZE_RIRBSZCAP_2
condition|)
name|sc
operator|->
name|rirb_size
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Invalid rirb size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rirbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"    CORB size: %d\n"
argument|, sc->corb_size); 		device_printf(sc->dev,
literal|"    RIRB size: %d\n"
argument|, sc->rirb_size); 		device_printf(sc->dev,
literal|"      Streams: ISS=%d OSS=%d BSS=%d\n"
argument|, 		    sc->num_iss, sc->num_oss, sc->num_bss);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_dma_cb  *  * This function is called by bus_dmamap_load when the mapping has been  * established. We just record the physical address of the mapping into  * the struct hdac_dma passed in.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_dma_cb
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|hdac_dma
modifier|*
name|dma
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dma
operator|=
operator|(
expr|struct
name|hdac_dma
operator|*
operator|)
name|callback_arg
expr_stmt|;
name|dma
operator|->
name|dma_paddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_dma_alloc  *  * This function allocate and setup a dma region (struct hdac_dma).  * It must be freed by a corresponding hdac_dma_free.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_dma_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_dma
modifier|*
name|dma
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
name|bus_size_t
name|roundsz
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|lowaddr
decl_stmt|;
name|roundsz
operator|=
name|roundup2
argument_list|(
name|size
argument_list|,
name|HDAC_DMA_ALIGNMENT
argument_list|)
expr_stmt|;
name|lowaddr
operator|=
operator|(
name|sc
operator|->
name|support_64bit
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
name|bzero
argument_list|(
name|dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create a DMA tag 	 */
name|result
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|HDAC_DMA_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|lowaddr
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
comment|/* filtfunc */
name|NULL
argument_list|,
comment|/* fistfuncarg */
name|roundsz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|roundsz
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_dma_alloc_fail
goto|;
block|}
comment|/* 	 * Allocate DMA memory 	 */
name|result
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
operator|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|HDAC_F_DMA_NOCACHE
operator|)
condition|?
name|BUS_DMA_NOCACHE
else|:
literal|0
operator|)
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_alloc failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_dma_alloc_fail
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|roundsz
expr_stmt|;
comment|/* 	 * Map the memory 	 */
name|result
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|roundsz
argument_list|,
name|hdac_dma_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dma
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|||
name|dma
operator|->
name|dma_paddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|ENOMEM
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: bus_dmamem_load failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_dma_alloc_fail
goto|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: size=%ju -> roundsz=%ju\n"
argument|, 		    __func__, (uintmax_t)size, (uintmax_t)roundsz);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_dma_alloc_fail
label|:
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
name|dma
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_dma_free(struct hdac_softc *, struct hdac_dma *)  *  * Free a struct dhac_dma that has been previously allocated via the  * hdac_dma_alloc function.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_dma_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_dma
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|dma_map
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Flush caches */
block|bus_dmamap_sync(dma->dma_tag, dma->dma_map, 		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
endif|#
directive|endif
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|dma_vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_vaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|dma_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|dma
operator|->
name|dma_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_mem_alloc(struct hdac_softc *)  *  * Allocate all the bus resources necessary to speak with the physical  * controller.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_mem_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_mem
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|&
name|sc
operator|->
name|mem
expr_stmt|;
name|mem
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|mem
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate memory resource\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mem
operator|->
name|mem_tag
operator|=
name|rman_get_bustag
argument_list|(
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_mem_free(struct hdac_softc *)  *  * Free up resources previously allocated by hdac_mem_alloc.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_mem_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_mem
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
operator|&
name|sc
operator|->
name|mem
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|mem
operator|->
name|mem_rid
argument_list|,
name|mem
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|mem
operator|->
name|mem_res
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_irq_alloc(struct hdac_softc *)  *  * Allocate and setup the resources necessary for interrupt handling.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_irq_alloc
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_irq
modifier|*
name|irq
decl_stmt|;
name|int
name|result
decl_stmt|;
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
expr_stmt|;
name|irq
operator|->
name|irq_rid
operator|=
literal|0x0
expr_stmt|;
ifdef|#
directive|ifdef
name|HDAC_MSI_ENABLED
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|HDAC_F_MSI
operator|)
operator|&&
operator|(
name|result
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|result
argument_list|)
operator|==
literal|0
condition|)
name|irq
operator|->
name|irq_rid
operator|=
literal|0x1
expr_stmt|;
else|else
endif|#
directive|endif
name|sc
operator|->
name|flags
operator|&=
operator|~
name|HDAC_F_MSI
expr_stmt|;
name|irq
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate irq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|hdac_irq_alloc_fail
goto|;
block|}
name|result
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_AV
argument_list|,
name|NULL
argument_list|,
name|hdac_intr_handler
argument_list|,
name|sc
argument_list|,
operator|&
name|irq
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to setup interrupt handler (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|hdac_irq_alloc_fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_irq_alloc_fail
label|:
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_irq_free(struct hdac_softc *)  *  * Free up resources previously allocated by hdac_irq_alloc.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_irq_free
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_irq
modifier|*
name|irq
decl_stmt|;
name|irq
operator|=
operator|&
name|sc
operator|->
name|irq
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|!=
name|NULL
operator|&&
name|irq
operator|->
name|irq_handle
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|,
name|irq
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|irq_rid
argument_list|,
name|irq
operator|->
name|irq_res
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDAC_MSI_ENABLED
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|HDAC_F_MSI
operator|)
operator|&&
name|irq
operator|->
name|irq_rid
operator|==
literal|0x1
condition|)
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|irq
operator|->
name|irq_handle
operator|=
name|NULL
expr_stmt|;
name|irq
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
name|irq
operator|->
name|irq_rid
operator|=
literal|0x0
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_corb_init(struct hdac_softc *)  *  * Initialize the corb registers for operations but do not start it up yet.  * The CORB engine must not be running when this function is called.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_corb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|corbsize
decl_stmt|;
name|uint64_t
name|corbpaddr
decl_stmt|;
comment|/* Setup the CORB size. */
switch|switch
condition|(
name|sc
operator|->
name|corb_size
condition|)
block|{
case|case
literal|256
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_256
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corbsize
operator|=
name|HDAC_CORBSIZE_CORBSIZE
argument_list|(
name|HDAC_CORBSIZE_CORBSIZE_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid CORB size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|corb_size
argument_list|)
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBSIZE
argument_list|,
name|corbsize
argument_list|)
expr_stmt|;
comment|/* Setup the CORB Address in the hdac */
name|corbpaddr
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|corb_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBLBASE
argument_list|,
operator|(
name|uint32_t
operator|)
name|corbpaddr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|corbpaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the WP and RP */
name|sc
operator|->
name|corb_wp
operator|=
literal|0
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBWP
argument_list|,
name|sc
operator|->
name|corb_wp
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|,
name|HDAC_CORBRP_CORBRPRST
argument_list|)
expr_stmt|;
comment|/* 	 * The HDA specification indicates that the CORBRPRST bit will always 	 * read as zero. Unfortunately, it seems that at least the 82801G 	 * doesn't reset the bit to zero, which stalls the corb engine. 	 * manually reset the bit to zero before continuing. 	 */
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Enable CORB error reporting */
if|#
directive|if
literal|0
block|HDAC_WRITE_1(&sc->mem, HDAC_CORBCTL, HDAC_CORBCTL_CMEIE);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_rirb_init(struct hdac_softc *)  *  * Initialize the rirb registers for operations but do not start it up yet.  * The RIRB engine must not be running when this function is called.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_rirb_init
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|rirbsize
decl_stmt|;
name|uint64_t
name|rirbpaddr
decl_stmt|;
comment|/* Setup the RIRB size. */
switch|switch
condition|(
name|sc
operator|->
name|rirb_size
condition|)
block|{
case|case
literal|256
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_256
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rirbsize
operator|=
name|HDAC_RIRBSIZE_RIRBSIZE
argument_list|(
name|HDAC_RIRBSIZE_RIRBSIZE_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid RIRB size (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rirb_size
argument_list|)
expr_stmt|;
block|}
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBSIZE
argument_list|,
name|rirbsize
argument_list|)
expr_stmt|;
comment|/* Setup the RIRB Address in the hdac */
name|rirbpaddr
operator|=
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBLBASE
argument_list|,
operator|(
name|uint32_t
operator|)
name|rirbpaddr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|rirbpaddr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the WP and RP */
name|sc
operator|->
name|rirb_rp
operator|=
literal|0
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBWP
argument_list|,
name|HDAC_RIRBWP_RIRBWPRST
argument_list|)
expr_stmt|;
comment|/* Setup the interrupt threshold */
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RINTCNT
argument_list|,
name|sc
operator|->
name|rirb_size
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable Overrun and response received reporting */
if|#
directive|if
literal|0
block|HDAC_WRITE_1(&sc->mem, HDAC_RIRBCTL, 	    HDAC_RIRBCTL_RIRBOIC | HDAC_RIRBCTL_RINTCTL);
else|#
directive|else
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|HDAC_RIRBCTL_RINTCTL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * Make sure that the Host CPU cache doesn't contain any dirty 	 * cache lines that falls in the rirb. If I understood correctly, it 	 * should be sufficient to do this only once as the rirb is purely 	 * read-only from now on. 	 */
block|bus_dmamap_sync(sc->rirb_dma.dma_tag, sc->rirb_dma.dma_map, 	    BUS_DMASYNC_PREREAD);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_corb_start(hdac_softc *)  *  * Startup the corb DMA engine  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_corb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|corbctl
decl_stmt|;
name|corbctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|)
expr_stmt|;
name|corbctl
operator||=
name|HDAC_CORBCTL_CORBRUN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBCTL
argument_list|,
name|corbctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_rirb_start(hdac_softc *)  *  * Startup the rirb DMA engine  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_rirb_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|rirbctl
decl_stmt|;
name|rirbctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|)
expr_stmt|;
name|rirbctl
operator||=
name|HDAC_RIRBCTL_RIRBDMAEN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBCTL
argument_list|,
name|rirbctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_scan_codecs(struct hdac_softc *, int)  *  * Scan the bus for available codecs, starting with num.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_scan_codecs
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|statests
decl_stmt|;
name|statests
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_STATESTS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HDAC_STATESTS_SDIWAKE
argument_list|(
name|statests
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* We have found a codec. */
name|codec
operator|=
operator|(
expr|struct
name|hdac_codec
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|codec
argument_list|)
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to allocate memory for codec\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|codec
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|codec
operator|->
name|responses_received
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|verbs_sent
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|codec
operator|->
name|cad
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|=
name|codec
expr_stmt|;
name|hdac_probe_codec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All codecs have been probed, now try to attach drivers to them */
comment|/* bus_generic_attach(sc->dev); */
block|}
end_function

begin_comment
comment|/****************************************************************************  * void hdac_probe_codec(struct hdac_softc *, int)  *  * Probe a the given codec_id for available function groups.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_probe_codec
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|vendorid
decl_stmt|,
name|revisionid
decl_stmt|,
name|subnode
decl_stmt|;
name|int
name|startnode
decl_stmt|;
name|int
name|endnode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nid_t
name|cad
init|=
name|codec
operator|->
name|cad
decl_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Probing codec #%d...\n"
argument|, cad);
argument_list|)
empty_stmt|;
name|vendorid
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_VENDOR_ID
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|revisionid
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_REVISION_ID
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|codec
operator|->
name|vendor_id
operator|=
name|HDA_PARAM_VENDOR_ID_VENDOR_ID
argument_list|(
name|vendorid
argument_list|)
expr_stmt|;
name|codec
operator|->
name|device_id
operator|=
name|HDA_PARAM_VENDOR_ID_DEVICE_ID
argument_list|(
name|vendorid
argument_list|)
expr_stmt|;
name|codec
operator|->
name|revision_id
operator|=
name|HDA_PARAM_REVISION_ID_REVISION_ID
argument_list|(
name|revisionid
argument_list|)
expr_stmt|;
name|codec
operator|->
name|stepping_id
operator|=
name|HDA_PARAM_REVISION_ID_STEPPING_ID
argument_list|(
name|revisionid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendorid
operator|==
name|HDAC_INVALID
operator|&&
name|revisionid
operator|==
name|HDAC_INVALID
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Codec #%d is not responding!"
literal|" Probing aborted.\n"
argument_list|,
name|cad
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"HDA Codec #%d: %s\n"
argument_list|,
name|cad
argument_list|,
name|hdac_codec_name
argument_list|(
name|codec
argument_list|)
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|" HDA Codec ID: 0x%08x\n"
argument|, 		    hdac_codec_id(codec)); 		device_printf(sc->dev,
literal|"       Vendor: 0x%04x\n"
argument|, 		    codec->vendor_id); 		device_printf(sc->dev,
literal|"       Device: 0x%04x\n"
argument|, 		    codec->device_id); 		device_printf(sc->dev,
literal|"     Revision: 0x%02x\n"
argument|, 		    codec->revision_id); 		device_printf(sc->dev,
literal|"     Stepping: 0x%02x\n"
argument|, 		    codec->stepping_id); 		device_printf(sc->dev,
literal|"PCI Subvendor: 0x%08x\n"
argument|, 		    sc->pci_subvendor);
argument_list|)
empty_stmt|;
name|subnode
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
literal|0x0
argument_list|,
name|HDA_PARAM_SUB_NODE_COUNT
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|startnode
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_START
argument_list|(
name|subnode
argument_list|)
expr_stmt|;
name|endnode
operator|=
name|startnode
operator|+
name|HDA_PARAM_SUB_NODE_COUNT_TOTAL
argument_list|(
name|subnode
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"\tstartnode=%d endnode=%d\n"
argument|, 		    startnode, endnode);
argument_list|)
empty_stmt|;
name|codec
operator|->
name|fgs
operator|=
operator|(
expr|struct
name|hdac_devinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_devinfo
argument_list|)
operator|*
operator|(
name|endnode
operator|-
name|startnode
operator|)
argument_list|,
name|M_HDAC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|codec
operator|->
name|fgs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Unable to allocate function groups\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|startnode
init|;
name|i
operator|<
name|endnode
condition|;
name|i
operator|++
control|)
name|hdac_probe_function
argument_list|(
name|codec
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Probe codec function and add it to the list.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_probe_function
parameter_list|(
name|struct
name|hdac_codec
modifier|*
name|codec
parameter_list|,
name|nid_t
name|nid
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
operator|&
name|codec
operator|->
name|fgs
index|[
name|codec
operator|->
name|num_fgs
index|]
decl_stmt|;
name|uint32_t
name|fctgrptype
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|nid_t
name|cad
init|=
name|codec
operator|->
name|cad
decl_stmt|;
name|fctgrptype
operator|=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE
argument_list|(
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_FCT_GRP_TYPE
argument_list|)
argument_list|,
name|cad
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|nid
operator|=
name|nid
expr_stmt|;
name|devinfo
operator|->
name|node_type
operator|=
name|fctgrptype
expr_stmt|;
name|devinfo
operator|->
name|codec
operator|=
name|codec
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUB_NODE_COUNT
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|nodecnt
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_TOTAL
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|startnode
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_START
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|endnode
operator|=
name|devinfo
operator|->
name|startnode
operator|+
name|devinfo
operator|->
name|nodecnt
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"\tFound %s FG nid=%d startnode=%d endnode=%d total=%d\n"
argument|, 		    (fctgrptype == HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO) ?
literal|"audio"
argument|: 		    (fctgrptype == HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_MODEM) ?
literal|"modem"
argument|:
literal|"unknown"
argument|, nid, devinfo->startnode, devinfo->endnode, 		    devinfo->nodecnt);
argument_list|)
empty_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|nodecnt
operator|>
literal|0
condition|)
name|devinfo
operator|->
name|widget
operator|=
operator|(
expr|struct
name|hdac_widget
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|devinfo
operator|->
name|widget
operator|)
argument_list|)
operator|*
name|devinfo
operator|->
name|nodecnt
argument_list|,
name|M_HDAC
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|else
name|devinfo
operator|->
name|widget
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|widget
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to allocate widgets!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|endnode
operator|=
name|devinfo
operator|->
name|startnode
expr_stmt|;
name|devinfo
operator|->
name|nodecnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|codec
operator|->
name|num_fgs
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_connection_parse
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max
decl_stmt|,
name|ents
decl_stmt|,
name|entnum
decl_stmt|;
name|nid_t
name|cad
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|nid_t
name|cnid
decl_stmt|,
name|addcnid
decl_stmt|,
name|prevcnid
decl_stmt|;
name|w
operator|->
name|nconns
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_CONN_LIST_LENGTH
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|ents
operator|=
name|HDA_PARAM_CONN_LIST_LENGTH_LIST_LENGTH
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ents
operator|<
literal|1
condition|)
return|return;
name|entnum
operator|=
name|HDA_PARAM_CONN_LIST_LENGTH_LONG_FORM
argument_list|(
name|res
argument_list|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
name|max
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|w
operator|->
name|conns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|w
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|prevcnid
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CONN_RMASK
parameter_list|(
name|e
parameter_list|)
value|(1<< ((32 / (e)) - 1))
define|#
directive|define
name|CONN_NMASK
parameter_list|(
name|e
parameter_list|)
value|(CONN_RMASK(e) - 1)
define|#
directive|define
name|CONN_RESVAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|,
name|n
parameter_list|)
value|((r)>> ((32 / (e)) * (n)))
define|#
directive|define
name|CONN_RANGE
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|,
name|n
parameter_list|)
value|(CONN_RESVAL(r, e, n)& CONN_RMASK(e))
define|#
directive|define
name|CONN_CNID
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|,
name|n
parameter_list|)
value|(CONN_RESVAL(r, e, n)& CONN_NMASK(e))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ents
condition|;
name|i
operator|+=
name|entnum
control|)
block|{
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_CONN_LIST_ENTRY
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|i
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|entnum
condition|;
name|j
operator|++
control|)
block|{
name|cnid
operator|=
name|CONN_CNID
argument_list|(
name|res
argument_list|,
name|entnum
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|nconns
operator|<
name|ents
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: nid=%d WARNING: zero cnid "
literal|"entnum=%d j=%d index=%d "
literal|"entries=%d found=%d res=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|nid
argument_list|,
name|entnum
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|ents
argument_list|,
name|w
operator|->
name|nconns
argument_list|,
name|res
argument_list|)
expr_stmt|;
else|else
goto|goto
name|getconns_out
goto|;
block|}
if|if
condition|(
name|cnid
operator|<
name|w
operator|->
name|devinfo
operator|->
name|startnode
operator|||
name|cnid
operator|>=
name|w
operator|->
name|devinfo
operator|->
name|endnode
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"GHOST: nid=%d j=%d "
literal|"entnum=%d index=%d res=0x%08x\n"
argument|, 					    nid, j, entnum, i, res);
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|CONN_RANGE
argument_list|(
name|res
argument_list|,
name|entnum
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
name|addcnid
operator|=
name|cnid
expr_stmt|;
elseif|else
if|if
condition|(
name|prevcnid
operator|==
literal|0
operator|||
name|prevcnid
operator|>=
name|cnid
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: WARNING: Invalid child range "
literal|"nid=%d index=%d j=%d entnum=%d "
literal|"prevcnid=%d cnid=%d res=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|nid
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|entnum
argument_list|,
name|prevcnid
argument_list|,
name|cnid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|addcnid
operator|=
name|cnid
expr_stmt|;
block|}
else|else
name|addcnid
operator|=
name|prevcnid
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|addcnid
operator|<=
name|cnid
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Adding %d (nid=%d): "
literal|"Max connection reached! max=%d\n"
argument_list|,
name|addcnid
argument_list|,
name|nid
argument_list|,
name|max
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|getconns_out
goto|;
block|}
name|w
operator|->
name|connsenable
index|[
name|w
operator|->
name|nconns
index|]
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|conns
index|[
name|w
operator|->
name|nconns
operator|++
index|]
operator|=
name|addcnid
operator|++
expr_stmt|;
block|}
name|prevcnid
operator|=
name|cnid
expr_stmt|;
block|}
block|}
name|getconns_out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_widget_pin_patch
parameter_list|(
name|uint32_t
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|rest
decl_stmt|,
modifier|*
name|bad
decl_stmt|;
name|int
name|ival
decl_stmt|,
name|i
decl_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|strsep
argument_list|(
operator|&
name|rest
argument_list|,
literal|"="
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|strsep
argument_list|(
operator|&
name|rest
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
break|break;
name|ival
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
operator|&
name|bad
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"seq"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"as"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"misc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_MISC_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_MISC_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_MISC_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"color"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_COLOR_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_COLOR_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_COLOR_MASK
operator|)
expr_stmt|;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_COLORS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_COLOR_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"ctype"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"device"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_DEVS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"loc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_LOCATION_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_LOCATION_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_LOCATION_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"conn"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_CONNS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_widget_pin_getconfig
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|config
decl_stmt|,
name|orig
decl_stmt|,
name|id
decl_stmt|;
name|nid_t
name|cad
decl_stmt|,
name|nid
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|,
modifier|*
name|patch
init|=
name|NULL
decl_stmt|;
name|sc
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|w
operator|->
name|nid
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
argument_list|)
expr_stmt|;
name|config
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_CONFIGURATION_DEFAULT
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|orig
operator|=
name|config
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|hdac_dump_pin_config(w, orig);
argument_list|)
empty_stmt|;
comment|/* XXX: Old patches require complete review. 	 * Now they may create more problem then solve due to 	 * incorrect associations. 	 */
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC880
operator|&&
name|sc
operator|->
name|pci_subvendor
operator|==
name|LG_LW20_SUBVENDOR
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|26
case|:
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC880
operator|&&
operator|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|CLEVO_D900T_SUBVENDOR
operator|||
name|sc
operator|->
name|pci_subvendor
operator|==
name|ASUS_M5200_SUBVENDOR
operator|)
condition|)
block|{
comment|/* 		 * Super broken BIOS 		 */
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|24
case|:
comment|/* MIC1 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* XXX MIC2 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
expr_stmt|;
break|break;
case|case
literal|26
case|:
comment|/* LINE1 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
expr_stmt|;
break|break;
case|case
literal|27
case|:
comment|/* XXX LINE2 */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
expr_stmt|;
break|break;
case|case
literal|28
case|:
comment|/* CD */
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC883
operator|&&
operator|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|MSI_MS034A_SUBVENDOR
operator|||
name|HDA_DEV_MATCH
argument_list|(
name|ACER_ALL_SUBVENDOR
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|25
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
operator|)
expr_stmt|;
break|break;
case|case
literal|28
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_CX20549
operator|&&
name|sc
operator|->
name|pci_subvendor
operator|==
name|HP_V3000_SUBVENDOR
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|18
case|:
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
operator|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_CX20551
operator|&&
name|sc
operator|->
name|pci_subvendor
operator|==
name|HP_DV5000_SUBVENDOR
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|20
case|:
case|case
literal|21
case|:
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
expr_stmt|;
name|config
operator||=
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC861
operator|&&
name|sc
operator|->
name|pci_subvendor
operator|==
name|ASUS_W6F_SUBVENDOR
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|11
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
operator|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
case|case
literal|14
case|:
case|case
literal|16
case|:
case|case
literal|31
case|:
case|case
literal|32
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_FIXED
operator|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
operator|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC861
operator|&&
name|sc
operator|->
name|pci_subvendor
operator|==
name|UNIWILL_9075_SUBVENDOR
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|15
case|:
name|config
operator|&=
operator|~
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
name|config
operator||=
operator|(
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator||
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* New patches */
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_AD1986A
operator|&&
operator|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|ASUS_M2NPVMX_SUBVENDOR
operator|||
name|sc
operator|->
name|pci_subvendor
operator|==
name|ASUS_A8NVMCSM_SUBVENDOR
operator|)
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|28
case|:
comment|/* 5.1 out => 2.0 out + 2 inputs */
name|patch
operator|=
literal|"device=Line-in as=8 seq=1"
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|patch
operator|=
literal|"device=Mic as=8 seq=2"
expr_stmt|;
break|break;
case|case
literal|31
case|:
comment|/* Lot of inputs configured with as=15 and unusable */
name|patch
operator|=
literal|"as=8 seq=3"
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|patch
operator|=
literal|"as=8 seq=4"
expr_stmt|;
break|break;
case|case
literal|34
case|:
name|patch
operator|=
literal|"as=8 seq=5"
expr_stmt|;
break|break;
case|case
literal|36
case|:
name|patch
operator|=
literal|"as=8 seq=6"
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC260
operator|&&
name|HDA_DEV_MATCH
argument_list|(
name|SONY_S5_SUBVENDOR
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|16
case|:
name|patch
operator|=
literal|"seq=15 device=Headphones"
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|HDA_CODEC_ALC268
operator|&&
name|HDA_DEV_MATCH
argument_list|(
name|ACER_ALL_SUBVENDOR
argument_list|,
name|sc
operator|->
name|pci_subvendor
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
literal|28
case|:
name|patch
operator|=
literal|"device=CD conn=fixed"
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|patch
operator|!=
name|NULL
condition|)
name|config
operator|=
name|hdac_widget_pin_patch
argument_list|(
name|config
argument_list|,
name|patch
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cad%u.nid%u.config"
argument_list|,
name|cad
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|=
name|strtol
argument_list|(
name|res
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|hdac_widget_pin_patch
argument_list|(
name|config
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (config != orig) 			device_printf(sc->dev,
literal|"Patching pin config nid=%u 0x%08x -> 0x%08x\n"
argument|, 			    nid, orig, config);
argument_list|)
empty_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_widget_pin_getcaps
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|,
name|orig
decl_stmt|,
name|id
decl_stmt|;
name|nid_t
name|cad
decl_stmt|,
name|nid
decl_stmt|;
name|sc
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|w
operator|->
name|nid
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
argument_list|)
expr_stmt|;
name|caps
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_PIN_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|orig
operator|=
name|caps
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (caps != orig) 			device_printf(sc->dev,
literal|"Patching pin caps nid=%u 0x%08x -> 0x%08x\n"
argument|, 			    nid, orig, caps);
argument_list|)
empty_stmt|;
return|return
operator|(
name|caps
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_pin_parse
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|config
decl_stmt|,
name|pincap
decl_stmt|;
specifier|const
name|char
modifier|*
name|devstr
decl_stmt|;
name|nid_t
name|cad
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|int
name|conn
decl_stmt|,
name|color
decl_stmt|;
name|config
operator|=
name|hdac_widget_pin_getconfig
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|pincap
operator|=
name|hdac_widget_pin_getcaps
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
operator|=
name|pincap
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_EAPD_BTL_ENABLE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&=
literal|0x7
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator||=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|HDAC_INVALID
expr_stmt|;
name|devstr
operator|=
name|HDA_DEVS
index|[
operator|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
operator|>>
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SHIFT
index|]
expr_stmt|;
name|conn
operator|=
operator|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|>>
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_SHIFT
expr_stmt|;
name|color
operator|=
operator|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_COLOR_MASK
operator|)
operator|>>
name|HDA_CONFIG_DEFAULTCONF_COLOR_SHIFT
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|": "
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|devstr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|" ("
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
literal|0
operator|&&
name|color
operator|!=
literal|0
operator|&&
name|color
operator|!=
literal|15
condition|)
block|{
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|HDA_COLORS
index|[
name|color
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|" "
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|HDA_CONNS
index|[
name|conn
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|")"
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_widget_getcaps
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|,
name|int
modifier|*
name|waspin
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|caps
decl_stmt|,
name|orig
decl_stmt|,
name|id
decl_stmt|;
name|nid_t
name|cad
decl_stmt|,
name|nid
decl_stmt|,
name|beeper
init|=
operator|-
literal|1
decl_stmt|;
name|sc
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|w
operator|->
name|nid
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
argument_list|)
expr_stmt|;
name|caps
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_AUDIO_WIDGET_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|orig
operator|=
name|caps
expr_stmt|;
comment|/* On some codecs beeper is an input pin, but it is not recordable 	   alone. Also most of BIOSes does not declare beeper pin. 	   Change beeper pin node type to beeper to help parser. */
operator|*
name|waspin
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|HDA_CODEC_AD1988
case|:
case|case
name|HDA_CODEC_AD1988B
case|:
name|beeper
operator|=
literal|26
expr_stmt|;
break|break;
case|case
name|HDA_CODEC_ALC260
case|:
name|beeper
operator|=
literal|23
expr_stmt|;
break|break;
case|case
name|HDA_CODEC_ALC262
case|:
case|case
name|HDA_CODEC_ALC268
case|:
case|case
name|HDA_CODEC_ALC880
case|:
case|case
name|HDA_CODEC_ALC882
case|:
case|case
name|HDA_CODEC_ALC883
case|:
case|case
name|HDA_CODEC_ALC885
case|:
case|case
name|HDA_CODEC_ALC888
case|:
case|case
name|HDA_CODEC_ALC889
case|:
name|beeper
operator|=
literal|29
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nid
operator|==
name|beeper
condition|)
block|{
name|caps
operator|&=
operator|~
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_MASK
expr_stmt|;
name|caps
operator||=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
operator|<<
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_SHIFT
expr_stmt|;
operator|*
name|waspin
operator|=
literal|1
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (caps != orig) { 			device_printf(sc->dev,
literal|"Patching widget caps nid=%u 0x%08x -> 0x%08x\n"
argument|, 			    nid, orig, caps); 		}
argument_list|)
empty_stmt|;
return|return
operator|(
name|caps
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_parse
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|wcap
decl_stmt|,
name|cap
decl_stmt|;
name|char
modifier|*
name|typestr
decl_stmt|;
name|nid_t
name|cad
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|wcap
operator|=
name|hdac_widget_getcaps
argument_list|(
name|w
argument_list|,
operator|&
name|w
operator|->
name|waspin
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|widget_cap
operator|=
name|wcap
expr_stmt|;
name|w
operator|->
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE
argument_list|(
name|wcap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
name|typestr
operator|=
literal|"audio output"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
name|typestr
operator|=
literal|"audio input"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
name|typestr
operator|=
literal|"audio mixer"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
name|typestr
operator|=
literal|"audio selector"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
name|typestr
operator|=
literal|"pin"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_POWER_WIDGET
case|:
name|typestr
operator|=
literal|"power widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VOLUME_WIDGET
case|:
name|typestr
operator|=
literal|"volume widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
case|:
name|typestr
operator|=
literal|"beep widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VENDOR_WIDGET
case|:
name|typestr
operator|=
literal|"vendor widget"
expr_stmt|;
break|break;
default|default:
name|typestr
operator|=
literal|"unknown type"
expr_stmt|;
break|break;
block|}
name|strlcpy
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|typestr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|hdac_widget_connection_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_OUT_AMP
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_AMP_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|outamp_cap
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_IN_AMP
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_AMP_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_INPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|inamp_cap
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_FORMAT_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
name|cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_STREAM_FORMATS
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
operator|(
name|cap
operator|!=
literal|0
operator|)
condition|?
name|cap
else|:
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
expr_stmt|;
name|cap
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_PCM_SIZE_RATE
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
operator|(
name|cap
operator|!=
literal|0
operator|)
condition|?
name|cap
else|:
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
name|w
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|hdac_widget_pin_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdac_widget
modifier|*
name|hdac_widget_get
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|)
block|{
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|widget
operator|==
name|NULL
operator|||
name|nid
operator|<
name|devinfo
operator|->
name|startnode
operator|||
name|nid
operator|>=
name|devinfo
operator|->
name|endnode
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|devinfo
operator|->
name|widget
index|[
name|nid
operator|-
name|devinfo
operator|->
name|startnode
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hda_poll_channel
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|uint32_t
name|sz
decl_stmt|,
name|delta
decl_stmt|;
specifier|volatile
name|uint32_t
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|flags
operator|&
name|HDAC_CHN_RUNNING
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sz
operator|=
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dmapos
operator|!=
name|NULL
condition|)
name|ptr
operator|=
operator|*
operator|(
name|ch
operator|->
name|dmapos
operator|)
expr_stmt|;
else|else
name|ptr
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDLPIB
argument_list|)
expr_stmt|;
name|ch
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|%=
name|sz
expr_stmt|;
name|ptr
operator|&=
operator|~
operator|(
name|ch
operator|->
name|blksz
operator|-
literal|1
operator|)
expr_stmt|;
name|delta
operator|=
operator|(
name|sz
operator|+
name|ptr
operator|-
name|ch
operator|->
name|prevptr
operator|)
operator|%
name|sz
expr_stmt|;
if|if
condition|(
name|delta
operator|<
name|ch
operator|->
name|blksz
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch
operator|->
name|prevptr
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hda_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|trigger
decl_stmt|;
name|int
name|i
decl_stmt|,
name|active
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|trigger
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|HDAC_CHN_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hda_poll_channel
argument_list|(
operator|&
name|sc
operator|->
name|chans
index|[
name|i
index|]
argument_list|)
condition|)
name|trigger
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
comment|/* XXX */
if|if
condition|(
name|active
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
name|sc
operator|->
name|poll_ticks
argument_list|,
name|hda_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trigger
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_rirb_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|,
modifier|*
name|rirb
decl_stmt|;
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|struct
name|hdac_command_list
modifier|*
name|commands
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|resp
decl_stmt|;
name|uint8_t
name|rirbwp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirbwp
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_RIRBWP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_dmamap_sync(sc->rirb_dma.dma_tag, sc->rirb_dma.dma_map, 	    BUS_DMASYNC_POSTREAD);
endif|#
directive|endif
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rirb_rp
operator|!=
name|rirbwp
condition|)
block|{
name|sc
operator|->
name|rirb_rp
operator|++
expr_stmt|;
name|sc
operator|->
name|rirb_rp
operator|%=
name|sc
operator|->
name|rirb_size
expr_stmt|;
name|rirb
operator|=
operator|&
name|rirb_base
index|[
name|sc
operator|->
name|rirb_rp
index|]
expr_stmt|;
name|cad
operator|=
name|HDAC_RIRB_RESPONSE_EX_SDATA_IN
argument_list|(
name|rirb
operator|->
name|response_ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|cad
operator|<
literal|0
operator|||
name|cad
operator|>=
name|HDAC_CODEC_MAX
operator|||
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|resp
operator|=
name|rirb
operator|->
name|response
expr_stmt|;
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
expr_stmt|;
name|commands
operator|=
name|codec
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|rirb
operator|->
name|response_ex
operator|&
name|HDAC_RIRB_RESPONSE_EX_UNSOLICITED
condition|)
block|{
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_wp
operator|++
index|]
operator|=
operator|(
name|cad
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|resp
operator|>>
literal|26
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sc
operator|->
name|unsolq_wp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|commands
operator|!=
name|NULL
operator|&&
name|commands
operator|->
name|num_commands
operator|>
literal|0
operator|&&
name|codec
operator|->
name|responses_received
operator|<
name|commands
operator|->
name|num_commands
condition|)
name|commands
operator|->
name|responses
index|[
name|codec
operator|->
name|responses_received
operator|++
index|]
operator|=
name|resp
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_unsolq_flush
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|unsolq_st
operator|==
name|HDAC_UNSOLQ_READY
condition|)
block|{
name|sc
operator|->
name|unsolq_st
operator|=
name|HDAC_UNSOLQ_BUSY
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|unsolq_rp
operator|!=
name|sc
operator|->
name|unsolq_wp
condition|)
block|{
name|cad
operator|=
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_rp
index|]
operator|>>
literal|16
expr_stmt|;
name|tag
operator|=
name|sc
operator|->
name|unsolq
index|[
name|sc
operator|->
name|unsolq_rp
operator|++
index|]
operator|&
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|unsolq_rp
operator|%=
name|HDAC_UNSOLQ_MAX
expr_stmt|;
name|hdac_unsolicited_handler
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|unsolq_st
operator|=
name|HDAC_UNSOLQ_READY
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
operator|||
name|sc
operator|->
name|poll_ival
operator|==
literal|0
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
name|sc
operator|->
name|poll_ival
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_poll_reinit
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pollticks
decl_stmt|,
name|min
init|=
literal|1000000
decl_stmt|;
name|struct
name|hdac_chan
modifier|*
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|HDAC_CHN_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ch
operator|=
operator|&
name|sc
operator|->
name|chans
index|[
name|i
index|]
expr_stmt|;
name|pollticks
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|hz
operator|*
name|ch
operator|->
name|blksz
operator|)
operator|/
operator|(
operator|(
name|uint64_t
operator|)
name|sndbuf_getbps
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|*
name|sndbuf_getspd
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|)
expr_stmt|;
name|pollticks
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|pollticks
operator|>
name|hz
condition|)
name|pollticks
operator|=
name|hz
expr_stmt|;
if|if
condition|(
name|pollticks
operator|<
literal|1
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: pollticks=%d< 1 !\n"
argument|, 				    __func__, pollticks);
argument_list|)
empty_stmt|;
name|pollticks
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>
name|pollticks
condition|)
name|min
operator|=
name|pollticks
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%s: pollticks %d -> %d\n"
argument|, 		    __func__, sc->poll_ticks, min);
argument_list|)
empty_stmt|;
name|sc
operator|->
name|poll_ticks
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|min
operator|==
literal|1000000
condition|)
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
else|else
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
literal|1
argument_list|,
name|hda_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_stop
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|HDAC_SDCTL_IOCE
operator||
name|HDAC_SDCTL_FEIE
operator||
name|HDAC_SDCTL_DEIE
operator||
name|HDAC_SDCTL_RUN
operator|)
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ch
operator|->
name|flags
operator|&=
operator|~
name|HDAC_CHN_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|ch
operator|->
name|off
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_start
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ch
operator|->
name|flags
operator||=
name|HDAC_CHN_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
literal|1
operator|<<
operator|(
name|ch
operator|->
name|off
operator|>>
literal|5
operator|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_IOCE
operator||
name|HDAC_SDCTL_FEIE
operator||
name|HDAC_SDCTL_DEIE
operator||
name|HDAC_SDCTL_RUN
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_reset
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|timeout
init|=
literal|1000
decl_stmt|;
name|int
name|to
init|=
name|timeout
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_SDCTL_SRST
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
do|do
block|{
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timeout in reset\n"
argument_list|)
expr_stmt|;
block|}
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL_SRST
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|to
operator|=
name|timeout
expr_stmt|;
do|do
block|{
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|to
condition|)
do|;
if|if
condition|(
name|ctl
operator|&
name|HDAC_SDCTL_SRST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't reset!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_setid
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|ctl
operator|=
name|HDAC_READ_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL2
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_SDCTL2_STRM_MASK
expr_stmt|;
name|ctl
operator||=
name|ch
operator|->
name|sid
operator|<<
name|HDAC_SDCTL2_STRM_SHIFT
expr_stmt|;
name|HDAC_WRITE_1
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCTL2
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_bdl_setup
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_bdle
modifier|*
name|bdle
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint32_t
name|blksz
decl_stmt|,
name|blkcnt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|addr
operator|=
operator|(
name|uint64_t
operator|)
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
name|bdle
operator|=
operator|(
expr|struct
name|hdac_bdle
operator|*
operator|)
name|ch
operator|->
name|bdl_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|blksz
operator|=
name|ch
operator|->
name|blksz
expr_stmt|;
name|blkcnt
operator|=
name|ch
operator|->
name|blkcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blkcnt
condition|;
name|i
operator|++
operator|,
name|bdle
operator|++
control|)
block|{
name|bdle
operator|->
name|addrl
operator|=
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
name|bdle
operator|->
name|addrh
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|bdle
operator|->
name|len
operator|=
name|blksz
expr_stmt|;
name|bdle
operator|->
name|ioc
operator|=
literal|1
expr_stmt|;
name|addr
operator|+=
name|blksz
expr_stmt|;
block|}
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDCBL
argument_list|,
name|blksz
operator|*
name|blkcnt
argument_list|)
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDLVI
argument_list|,
name|blkcnt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|ch
operator|->
name|bdl_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDBDPL
argument_list|,
operator|(
name|uint32_t
operator|)
name|addr
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDBDPU
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dmapos
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBLBASE
argument_list|)
operator|&
literal|0x00000001
operator|)
condition|)
block|{
name|addr
operator|=
name|sc
operator|->
name|pos_dma
operator|.
name|dma_paddr
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBLBASE
argument_list|,
operator|(
operator|(
name|uint32_t
operator|)
name|addr
operator|&
name|HDAC_DPLBASE_DPLBASE_MASK
operator|)
operator||
literal|0x00000001
argument_list|)
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_DPIBUBASE
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_bdl_alloc
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ch
operator|->
name|bdl_dma
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_bdle
argument_list|)
operator|*
name|HDA_BDL_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't alloc bdl\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_amp_set_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|nid_t
name|cad
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|lmute
parameter_list|,
name|int
name|rmute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|uint16_t
name|v
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|left
operator|!=
name|right
operator|||
name|lmute
operator|!=
name|rmute
condition|)
block|{
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|lmute
operator|<<
literal|7
operator|)
operator||
name|left
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_AMP_GAIN_MUTE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|v
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|rmute
operator|<<
literal|7
operator|)
operator||
name|right
expr_stmt|;
block|}
else|else
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|3
operator|<<
literal|12
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|lmute
operator|<<
literal|7
operator|)
operator||
name|left
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_AMP_GAIN_MUTE
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|v
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_amp_set
parameter_list|(
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
parameter_list|,
name|uint32_t
name|mute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|nid_t
name|nid
decl_stmt|,
name|cad
decl_stmt|;
name|int
name|lmute
decl_stmt|,
name|rmute
decl_stmt|;
name|sc
operator|=
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
expr_stmt|;
name|cad
operator|=
name|ctl
operator|->
name|widget
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|ctl
operator|->
name|widget
operator|->
name|nid
expr_stmt|;
comment|/* Save new values if valid. */
if|if
condition|(
name|mute
operator|!=
name|HDA_AMP_MUTE_DEFAULT
condition|)
name|ctl
operator|->
name|muted
operator|=
name|mute
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|HDA_AMP_VOL_DEFAULT
condition|)
name|ctl
operator|->
name|left
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|right
operator|!=
name|HDA_AMP_VOL_DEFAULT
condition|)
name|ctl
operator|->
name|right
operator|=
name|right
expr_stmt|;
comment|/* Prepare effective values */
if|if
condition|(
name|ctl
operator|->
name|forcemute
condition|)
block|{
name|lmute
operator|=
literal|1
expr_stmt|;
name|rmute
operator|=
literal|1
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lmute
operator|=
name|HDA_AMP_LEFT_MUTED
argument_list|(
name|ctl
operator|->
name|muted
argument_list|)
expr_stmt|;
name|rmute
operator|=
name|HDA_AMP_RIGHT_MUTED
argument_list|(
name|ctl
operator|->
name|muted
argument_list|)
expr_stmt|;
name|left
operator|=
name|ctl
operator|->
name|left
expr_stmt|;
name|right
operator|=
name|ctl
operator|->
name|right
expr_stmt|;
block|}
comment|/* Apply effective values */
if|if
condition|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_OUT
condition|)
name|hdac_audio_ctl_amp_set_internal
argument_list|(
name|sc
argument_list|,
name|cad
argument_list|,
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|,
name|lmute
argument_list|,
name|rmute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|dir
operator|&
name|HDA_CTL_IN
condition|)
name|hdac_audio_ctl_amp_set_internal
argument_list|(
name|sc
argument_list|,
name|cad
argument_list|,
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|,
name|lmute
argument_list|,
name|rmute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_widget_connection_select
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|nconns
operator|<
literal|1
operator|||
name|index
operator|>
operator|(
name|w
operator|->
name|nconns
operator|-
literal|1
operator|)
condition|)
return|return;
name|hdac_command
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
argument_list|,
name|HDA_CMD_SET_CONNECTION_SELECT_CONTROL
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|index
argument_list|)
argument_list|,
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * uint32_t hdac_command_sendone_internal  *  * Wrapper function that sends only one command to a given codec  ****************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|hdac_command_sendone_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|verb
parameter_list|,
name|nid_t
name|cad
parameter_list|)
block|{
name|struct
name|hdac_command_list
name|cl
decl_stmt|;
name|uint32_t
name|response
init|=
name|HDAC_INVALID
decl_stmt|;
if|if
condition|(
operator|!
name|hdac_lockowned
argument_list|(
name|sc
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"WARNING!!!! mtx not owned!!!!\n"
argument_list|)
expr_stmt|;
name|cl
operator|.
name|num_commands
operator|=
literal|1
expr_stmt|;
name|cl
operator|.
name|verbs
operator|=
operator|&
name|verb
expr_stmt|;
name|cl
operator|.
name|responses
operator|=
operator|&
name|response
expr_stmt|;
name|hdac_command_send_internal
argument_list|(
name|sc
argument_list|,
operator|&
name|cl
argument_list|,
name|cad
argument_list|)
expr_stmt|;
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * hdac_command_send_internal  *  * Send a command list to the codec via the corb. We queue as much verbs as  * we can and msleep on the codec. When the interrupt get the responses  * back from the rirb, it will wake us up so we can queue the remaining verbs  * if any.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|hdac_command_send_internal
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_command_list
modifier|*
name|commands
parameter_list|,
name|nid_t
name|cad
parameter_list|)
block|{
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|int
name|corbrp
decl_stmt|;
name|uint32_t
modifier|*
name|corb
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|retry
init|=
literal|10
decl_stmt|;
name|struct
name|hdac_rirb
modifier|*
name|rirb_base
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
operator|==
name|NULL
operator|||
name|commands
operator|==
name|NULL
operator|||
name|commands
operator|->
name|num_commands
operator|<
literal|1
condition|)
return|return;
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|cad
index|]
expr_stmt|;
name|codec
operator|->
name|commands
operator|=
name|commands
expr_stmt|;
name|codec
operator|->
name|responses_received
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|verbs_sent
operator|=
literal|0
expr_stmt|;
name|corb
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|corb_dma
operator|.
name|dma_vaddr
expr_stmt|;
name|rirb_base
operator|=
operator|(
expr|struct
name|hdac_rirb
operator|*
operator|)
name|sc
operator|->
name|rirb_dma
operator|.
name|dma_vaddr
expr_stmt|;
do|do
block|{
if|if
condition|(
name|codec
operator|->
name|verbs_sent
operator|!=
name|commands
operator|->
name|num_commands
condition|)
block|{
comment|/* Queue as many verbs as possible */
name|corbrp
operator|=
name|HDAC_READ_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBRP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bus_dmamap_sync(sc->corb_dma.dma_tag, 			    sc->corb_dma.dma_map, BUS_DMASYNC_PREWRITE);
endif|#
directive|endif
while|while
condition|(
name|codec
operator|->
name|verbs_sent
operator|!=
name|commands
operator|->
name|num_commands
operator|&&
operator|(
operator|(
name|sc
operator|->
name|corb_wp
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|corb_size
operator|)
operator|!=
name|corbrp
condition|)
block|{
name|sc
operator|->
name|corb_wp
operator|++
expr_stmt|;
name|sc
operator|->
name|corb_wp
operator|%=
name|sc
operator|->
name|corb_size
expr_stmt|;
name|corb
index|[
name|sc
operator|->
name|corb_wp
index|]
operator|=
name|commands
operator|->
name|verbs
index|[
name|codec
operator|->
name|verbs_sent
operator|++
index|]
expr_stmt|;
block|}
comment|/* Send the verbs to the codecs */
if|#
directive|if
literal|0
block|bus_dmamap_sync(sc->corb_dma.dma_tag, 			    sc->corb_dma.dma_map, BUS_DMASYNC_POSTWRITE);
endif|#
directive|endif
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_CORBWP
argument_list|,
name|sc
operator|->
name|corb_wp
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|hdac_rirb_flush
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|&&
operator|--
name|timeout
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|codec
operator|->
name|verbs_sent
operator|!=
name|commands
operator|->
name|num_commands
operator|||
name|codec
operator|->
name|responses_received
operator|!=
name|commands
operator|->
name|num_commands
operator|)
operator|&&
operator|--
name|retry
condition|)
do|;
if|if
condition|(
name|retry
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: TIMEOUT numcmd=%d, sent=%d, received=%d\n"
argument_list|,
name|__func__
argument_list|,
name|commands
operator|->
name|num_commands
argument_list|,
name|codec
operator|->
name|verbs_sent
argument_list|,
name|codec
operator|->
name|responses_received
argument_list|)
expr_stmt|;
name|codec
operator|->
name|commands
operator|=
name|NULL
expr_stmt|;
name|codec
operator|->
name|responses_received
operator|=
literal|0
expr_stmt|;
name|codec
operator|->
name|verbs_sent
operator|=
literal|0
expr_stmt|;
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * Device Methods  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  * int hdac_probe(device_t)  *  * Probe for the presence of an hdac. If none is found, check for a generic  * match using the subclass of the device.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|uint32_t
name|model
decl_stmt|;
name|uint16_t
name|class
decl_stmt|,
name|subclass
decl_stmt|;
name|char
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|model
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|model
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ENXIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_DEVICES_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
operator|==
name|model
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|hdac_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_devices
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|model
argument_list|)
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
name|hdac_devices
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ENXIO
operator|&&
name|class
operator|==
name|PCIC_MULTIMEDIA
operator|&&
name|subclass
operator|==
name|PCIS_MULTIMEDIA_HDA
condition|)
block|{
name|strlcpy
argument_list|(
name|desc
argument_list|,
literal|"Generic"
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|BUS_PROBE_GENERIC
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ENXIO
condition|)
block|{
name|strlcat
argument_list|(
name|desc
argument_list|,
literal|" High Definition Audio Controller"
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hdac_channel_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|data
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_chan
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ord
init|=
literal|0
decl_stmt|,
name|chid
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|chid
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|pdevinfo
operator|->
name|play
else|:
name|pdevinfo
operator|->
name|rec
expr_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|chans
index|[
name|chid
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
operator|&&
name|i
operator|<
name|chid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|dir
condition|)
name|ord
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|ch
operator|->
name|off
operator|=
operator|(
name|sc
operator|->
name|num_iss
operator|+
name|ord
operator|)
operator|<<
literal|5
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|off
operator|=
name|ord
operator|<<
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_FIXEDRATE
condition|)
block|{
name|ch
operator|->
name|caps
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|caps
operator|.
name|maxspeed
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pos_dma
operator|.
name|dma_vaddr
operator|!=
name|NULL
condition|)
name|ch
operator|->
name|dmapos
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|pos_dma
operator|.
name|dma_vaddr
operator|+
operator|(
name|sc
operator|->
name|streamcnt
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
else|else
name|ch
operator|->
name|dmapos
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|sid
operator|=
operator|++
name|sc
operator|->
name|streamcnt
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|ch
operator|->
name|b
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|pdevinfo
operator|->
name|chan_size
operator|/
name|pdevinfo
operator|->
name|chan_blkcnt
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|pdevinfo
operator|->
name|chan_blkcnt
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdac_bdl_alloc
argument_list|(
name|ch
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ch
operator|->
name|blkcnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|b
argument_list|,
name|sc
operator|->
name|chan_dmat
argument_list|,
operator|(
name|sc
operator|->
name|flags
operator|&
name|HDAC_F_DMA_NOCACHE
operator|)
condition|?
name|BUS_DMA_NOCACHE
else|:
literal|0
argument_list|,
name|pdevinfo
operator|->
name|chan_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|caps
operator|.
name|fmtlist
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|format
operator|==
name|ch
operator|->
name|caps
operator|.
name|fmtlist
index|[
name|i
index|]
condition|)
block|{
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|uint32_t
name|spd
init|=
literal|0
decl_stmt|,
name|threshold
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|spd
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
expr_stmt|;
name|threshold
operator|=
name|spd
operator|+
operator|(
operator|(
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|spd
operator|)
operator|>>
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<
name|threshold
condition|)
break|break;
block|}
if|if
condition|(
name|spd
operator|==
literal|0
condition|)
comment|/* impossible */
name|ch
operator|->
name|spd
operator|=
literal|48000
expr_stmt|;
else|else
name|ch
operator|->
name|spd
operator|=
name|spd
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_stream_setup
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
operator|&
name|ch
operator|->
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
index|[
name|ch
operator|->
name|as
index|]
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chn
decl_stmt|,
name|totalchn
decl_stmt|,
name|c
decl_stmt|;
name|nid_t
name|cad
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|uint16_t
name|fmt
decl_stmt|,
name|dfmt
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(ch->pdevinfo->dev,
literal|"PCMDIR_%s: Stream setup fmt=%08x speed=%d\n"
argument|, 		    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, 		    ch->fmt, ch->spd);
argument_list|)
empty_stmt|;
name|fmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S16_LE
condition|)
name|fmt
operator||=
name|ch
operator|->
name|bit16
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S32_LE
condition|)
name|fmt
operator||=
name|ch
operator|->
name|bit32
operator|<<
literal|4
expr_stmt|;
else|else
name|fmt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_RATE_TAB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|valid
operator|&&
name|ch
operator|->
name|spd
operator|==
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|rate
condition|)
block|{
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|mul
expr_stmt|;
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|div
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
operator|(
name|AFMT_STEREO
operator||
name|AFMT_AC3
operator|)
condition|)
block|{
name|fmt
operator||=
literal|1
expr_stmt|;
name|totalchn
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|totalchn
operator|=
literal|1
expr_stmt|;
name|HDAC_WRITE_2
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDFMT
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|dfmt
operator|=
name|HDA_CMD_SET_DIGITAL_CONV_FMT1_DIGEN
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_AC3
condition|)
name|dfmt
operator||=
name|HDA_CMD_SET_DIGITAL_CONV_FMT1_NAUDIO
expr_stmt|;
name|chn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|as
operator|->
name|hpredir
operator|>=
literal|0
operator|&&
name|i
operator|==
name|as
operator|->
name|pincnt
condition|)
name|chn
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(ch->pdevinfo->dev,
literal|"PCMDIR_%s: Stream setup nid=%d: "
literal|"fmt=0x%04x, dfmt=0x%04x\n"
argument|, 			    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, 			    ch->io[i], fmt, dfmt);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_CONV_FMT
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|fmt
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_DIGITAL_CONV_FMT1
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|dfmt
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
comment|/* If HP redirection is enabled, but failed to use same 		   DAC make last DAC one to duplicate first one. */
if|if
condition|(
name|as
operator|->
name|hpredir
operator|>=
literal|0
operator|&&
name|i
operator|==
name|as
operator|->
name|pincnt
condition|)
block|{
name|c
operator|=
operator|(
name|ch
operator|->
name|sid
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chn
operator|>=
name|totalchn
condition|)
block|{
comment|/* This is until OSS will support multichannel. 			   Should be: c = 0; to disable unused DAC */
name|c
operator|=
operator|(
name|ch
operator|->
name|sid
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|(
name|ch
operator|->
name|sid
operator|<<
literal|4
operator|)
operator||
name|chn
expr_stmt|;
block|}
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_CONV_STREAM_CHAN
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|c
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|chn
operator|+=
name|HDA_PARAM_AUDIO_WIDGET_CAP_STEREO
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setfragments
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blksz
parameter_list|,
name|uint32_t
name|blkcnt
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|blksz
operator|&=
name|HDA_BLK_ALIGN
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
operator|(
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|/
name|HDA_BDL_MIN
operator|)
condition|)
name|blksz
operator|=
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|/
name|HDA_BDL_MIN
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
name|HDA_BLK_MIN
condition|)
name|blksz
operator|=
name|HDA_BLK_MIN
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|>
name|HDA_BDL_MAX
condition|)
name|blkcnt
operator|=
name|HDA_BDL_MAX
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|<
name|HDA_BDL_MIN
condition|)
name|blkcnt
operator|=
name|HDA_BDL_MIN
expr_stmt|;
while|while
condition|(
operator|(
name|blksz
operator|*
name|blkcnt
operator|)
operator|>
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|blkcnt
operator|>>
literal|1
operator|)
operator|>=
name|HDA_BDL_MIN
condition|)
name|blkcnt
operator|>>=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|blksz
operator|>>
literal|1
operator|)
operator|>=
name|HDA_BLK_MIN
condition|)
name|blksz
operator|>>=
literal|1
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|(
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|!=
name|blksz
operator|||
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|!=
name|blkcnt
operator|)
operator|&&
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|b
argument_list|,
name|blkcnt
argument_list|,
name|blksz
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: failed blksz=%u blkcnt=%u\n"
argument_list|,
name|__func__
argument_list|,
name|blksz
argument_list|,
name|blkcnt
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blksz
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|hdac_channel_setfragments
argument_list|(
name|obj
argument_list|,
name|data
argument_list|,
name|blksz
argument_list|,
name|ch
operator|->
name|pdevinfo
operator|->
name|chan_blkcnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|blksz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_channel_stop
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|nid_t
name|cad
init|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdac_stream_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_DIGITAL_CONV_FMT1
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_CONV_STREAM_CHAN
argument_list|(
name|cad
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_channel_start
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|ch
operator|->
name|ptr
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|prevptr
operator|=
literal|0
expr_stmt|;
name|hdac_stream_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_bdl_setup
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_setid
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_setup
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdac_stream_start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
if|if
condition|(
operator|!
name|PCMTRIG_COMMON
argument_list|(
name|go
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|hdac_channel_start
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|hdac_channel_stop
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_channel_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|ch
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ptr
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|!=
literal|0
condition|)
name|ptr
operator|=
name|ch
operator|->
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|dmapos
operator|!=
name|NULL
condition|)
name|ptr
operator|=
operator|*
operator|(
name|ch
operator|->
name|dmapos
operator|)
expr_stmt|;
else|else
name|ptr
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|ch
operator|->
name|off
operator|+
name|HDAC_SDLPIB
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Round to available space and force 128 bytes aligment. 	 */
name|ptr
operator|%=
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|ptr
operator|&=
name|HDA_BLK_ALIGN
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|hdac_channel_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|&
operator|(
operator|(
expr|struct
name|hdac_chan
operator|*
operator|)
name|data
operator|)
operator|->
name|caps
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdac_channel_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|hdac_channel_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|hdac_channel_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|hdac_channel_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|hdac_channel_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setfragments
argument_list|,
name|hdac_channel_setfragments
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|hdac_channel_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|hdac_channel_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|hdac_channel_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|hdac_channel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|recmask
decl_stmt|,
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|softpcmvol
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Make sure that in case of soft volume it won't stay muted. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
name|pdevinfo
operator|->
name|left
index|[
name|i
index|]
operator|=
literal|100
expr_stmt|;
name|pdevinfo
operator|->
name|right
index|[
name|i
index|]
operator|=
literal|100
expr_stmt|;
block|}
name|mask
operator|=
literal|0
expr_stmt|;
name|recmask
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
operator|->
name|codec
argument_list|)
expr_stmt|;
comment|/* Declate EAPD as ogain control. */
if|if
condition|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|==
name|HDAC_INVALID
operator|||
name|w
operator|->
name|bindas
operator|!=
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|play
index|]
operator|.
name|as
condition|)
continue|continue;
name|mask
operator||=
name|SOUND_MASK_OGAIN
expr_stmt|;
break|break;
block|}
block|}
comment|/* Declare volume controls assigned to this association. */
name|i
operator|=
literal|0
expr_stmt|;
name|ctl
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|play
index|]
operator|.
name|as
operator|)
operator|||
operator|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
operator|.
name|as
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|pdevinfo
operator|->
name|index
operator|==
literal|0
operator|)
condition|)
name|mask
operator||=
name|ctl
operator|->
name|ossmask
expr_stmt|;
block|}
comment|/* Declare record sources available to this association. */
if|if
condition|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
condition|)
block|{
name|struct
name|hdac_chan
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|bindas
operator|!=
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
operator|.
name|as
operator|&&
name|cw
operator|->
name|bindas
operator|!=
operator|-
literal|2
condition|)
continue|continue;
name|recmask
operator||=
name|cw
operator|->
name|ossmask
expr_stmt|;
block|}
block|}
block|}
comment|/* Declare soft PCM volume if needed. */
if|if
condition|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
operator|&&
operator|!
name|pdevinfo
operator|->
name|digital
condition|)
block|{
name|ctl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|SOUND_MASK_PCM
operator|)
operator|==
literal|0
operator|||
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_SOFTPCMVOL
operator|)
condition|)
block|{
name|softpcmvol
operator|=
literal|1
expr_stmt|;
name|mask
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
block|}
else|else
block|{
name|softpcmvol
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|!=
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|play
index|]
operator|.
name|as
operator|&&
operator|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|!=
operator|-
literal|2
operator|||
name|pdevinfo
operator|->
name|index
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
name|SOUND_MASK_PCM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|step
operator|>
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|softpcmvol
operator|==
literal|1
operator|||
name|ctl
operator|==
name|NULL
condition|)
block|{
name|pcm_setflags
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|)
operator||
name|SD_F_SOFTPCMVOL
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"%s Soft PCM volume\n"
argument|, 				    (softpcmvol ==
literal|1
argument|) ?
literal|"Forcing"
argument|:
literal|"Enabling"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Declare master volume if needed. */
if|if
condition|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|SOUND_MASK_VOLUME
operator||
name|SOUND_MASK_PCM
operator|)
operator|)
operator|==
name|SOUND_MASK_PCM
condition|)
block|{
name|mask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MASK_PCM
argument_list|)
expr_stmt|;
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Forcing master volume with PCM\n"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
name|recmask
operator|&=
operator|(
literal|1
operator|<<
name|SOUND_MIXER_NRDEVICES
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|(
literal|1
operator|<<
name|SOUND_MIXER_NRDEVICES
operator|)
operator|-
literal|1
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|recmask
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_audio_ctl_ossmixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|mute
decl_stmt|;
name|int
name|lvol
decl_stmt|,
name|rvol
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Save new values. */
name|pdevinfo
operator|->
name|left
index|[
name|dev
index|]
operator|=
name|left
expr_stmt|;
name|pdevinfo
operator|->
name|right
index|[
name|dev
index|]
operator|=
name|right
expr_stmt|;
comment|/* 'ogain' is the special case implemented with EAPD. */
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_OGAIN
condition|)
block|{
name|uint32_t
name|orig
decl_stmt|;
name|w
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|==
name|HDAC_INVALID
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|devinfo
operator|->
name|endnode
condition|)
block|{
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|orig
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&=
operator|~
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator||=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
if|if
condition|(
name|orig
operator|!=
name|w
operator|->
name|param
operator|.
name|eapdbtl
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_EAPDINV
condition|)
name|val
operator|^=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_EAPD_BTL_ENABLE
argument_list|(
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|val
argument_list|)
argument_list|,
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|left
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
comment|/* Recalculate all controls related to this OSS device. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|play
index|]
operator|.
name|as
operator|)
operator|||
operator|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
operator|.
name|as
operator|)
operator|||
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|)
condition|)
continue|continue;
name|lvol
operator|=
literal|100
expr_stmt|;
name|rvol
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ctl
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|lvol
operator|=
name|lvol
operator|*
name|pdevinfo
operator|->
name|left
index|[
name|j
index|]
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
name|rvol
operator|*
name|pdevinfo
operator|->
name|right
index|[
name|j
index|]
operator|/
literal|100
expr_stmt|;
block|}
block|}
name|mute
operator|=
operator|(
name|left
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_LEFT
else|:
literal|0
expr_stmt|;
name|mute
operator||=
operator|(
name|right
operator|==
literal|0
operator|)
condition|?
name|HDA_AMP_MUTE_RIGHT
else|:
literal|0
expr_stmt|;
name|lvol
operator|=
operator|(
name|lvol
operator|*
name|ctl
operator|->
name|step
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|rvol
operator|=
operator|(
name|rvol
operator|*
name|ctl
operator|->
name|step
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|)
expr_stmt|;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Commutate specified record source.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|hdac_audio_ctl_recsel_comm
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|uint32_t
name|src
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|muted
decl_stmt|;
name|uint32_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
operator|||
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Call recursively to trace signal to it's source if needed. */
if|if
condition|(
operator|(
name|src
operator|&
name|cw
operator|->
name|ossmask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cw
operator|->
name|ossdev
operator|<
literal|0
condition|)
block|{
name|res
operator||=
name|hdac_audio_ctl_recsel_comm
argument_list|(
name|pdevinfo
argument_list|,
name|src
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator||=
name|cw
operator|->
name|ossmask
expr_stmt|;
block|}
block|}
comment|/* We have two special cases: mixers and others (selectors). */
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
block|{
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_IN
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If we have input control on this node mute them 			 * according to requested sources. */
name|muted
operator|=
operator|(
name|src
operator|&
name|cw
operator|->
name|ossmask
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|muted
operator|!=
name|ctl
operator|->
name|forcemute
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
name|muted
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_DEFAULT
argument_list|,
name|HDA_AMP_VOL_DEFAULT
argument_list|,
name|HDA_AMP_VOL_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Recsel (%s): nid %d source %d %s\n"
argument|, 				    hdac_audio_ctl_ossmixer_mask2allname( 				    src, buf, sizeof(buf)), 				    nid, i, muted?
literal|"mute"
argument|:
literal|"unmute"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|w
operator|->
name|nconns
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|src
operator|&
name|cw
operator|->
name|ossmask
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If we found requested source - select it and exit. */
name|hdac_widget_connection_select
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Recsel (%s): nid %d source %d select\n"
argument|, 				    hdac_audio_ctl_ossmixer_mask2allname( 			    	    src, buf, sizeof(buf)), 				    nid, i);
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdac_audio_ctl_ossmixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|uint32_t
name|src
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_chan
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|ret
init|=
literal|0xffffffff
decl_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Commutate requested recsrc for each ADC. */
name|ch
operator|=
operator|&
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator|&=
name|hdac_audio_ctl_recsel_comm
argument_list|(
name|pdevinfo
argument_list|,
name|src
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ret
operator|==
literal|0xffffffff
operator|)
condition|?
literal|0
else|:
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdac_audio_ctl_ossmixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|hdac_audio_ctl_ossmixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|hdac_audio_ctl_ossmixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|hdac_audio_ctl_ossmixer_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|hdac_audio_ctl_ossmixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|hdac_unsolq_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|context
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_unsolq_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_attach(device_t)  *  * Attach the device into the kernel. Interrupts usually won't be enabled  * when this function is called. Setup everything that doesn't require  * interrupts and defer probing of codecs until interrupts are enabled.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|uint8_t
name|v
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"HDA Driver Revision: %s\n"
argument_list|,
name|HDA_DRV_TEST_REV
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|HDAC_MTX_NAME
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|pci_subvendor
operator|=
operator|(
name|uint32_t
operator|)
name|pci_get_subdevice
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|sc
operator|->
name|pci_subvendor
operator||=
operator|(
name|uint32_t
operator|)
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|&
literal|0x0000ffff
expr_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|HP_NX6325_SUBVENDORX
condition|)
block|{
comment|/* Screw nx6325 - subdevice/subvendor swapped */
name|sc
operator|->
name|pci_subvendor
operator|=
name|HP_NX6325_SUBVENDOR
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|,
literal|0
argument_list|,
name|hdac_unsolq_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|poll_ticks
operator|=
literal|1000000
expr_stmt|;
name|sc
operator|->
name|poll_ival
operator|=
name|HDAC_POLL_INTERVAL
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"polling"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|HDAC_DMA_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
comment|/* filtfunc */
name|NULL
argument_list|,
comment|/* fistfuncarg */
name|HDA_BUFSZ_MAX
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|HDA_BUFSZ_MAX
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|chan_dmat
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|hdabus
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|INTEL_VENDORID
condition|)
block|{
comment|/* TCSEL -> TC0 */
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x44
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x44
argument_list|,
name|v
operator|&
literal|0xf8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"TCSEL: 0x%02d -> 0x%02d\n"
argument|, v, 			    pci_read_config(dev,
literal|0x44
argument|,
literal|1
argument|));
argument_list|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|HDAC_MSI_ENABLED
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"msi"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
operator|&&
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
operator|==
literal|1
condition|)
name|sc
operator|->
name|flags
operator||=
name|HDAC_F_MSI
expr_stmt|;
else|else
endif|#
directive|endif
name|sc
operator|->
name|flags
operator|&=
operator|~
name|HDAC_F_MSI
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|sc
operator|->
name|flags
operator||=
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"snoop"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
name|sc
operator|->
name|flags
operator|&=
operator|~
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Try to enable PCIe snoop to avoid messing around with 		 * uncacheable DMA attribute. Since PCIe snoop register 		 * config is pretty much vendor specific, there are no 		 * general solutions on how to enable it, forcing us (even 		 * Microsoft) to enable uncacheable or write combined DMA 		 * by default. 		 * 		 * http://msdn2.microsoft.com/en-us/library/ms790324.aspx 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_PCIESNOOP_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|vendor
condition|)
continue|continue;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
if|if
condition|(
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
operator|==
literal|0x00
condition|)
break|break;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
operator|)
operator|==
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
condition|)
break|break;
name|v
operator|&=
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|mask
expr_stmt|;
name|v
operator||=
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
operator|)
operator|!=
name|hdac_pcie_snoop
index|[
name|i
index|]
operator|.
name|enable
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"WARNING: Failed to enable PCIe "
literal|"snoop!\n"
argument|);
argument_list|)
empty_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|sc
operator|->
name|flags
operator||=
name|HDAC_F_DMA_NOCACHE
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
block|}
endif|#
directive|endif
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"DMA Coherency: %s / vendor=0x%04x\n"
argument|, 		    (sc->flags& HDAC_F_DMA_NOCACHE) ?
literal|"Uncacheable"
argument|:
literal|"PCIe snoop"
argument|, vendor);
argument_list|)
empty_stmt|;
comment|/* Allocate resources */
name|result
operator|=
name|hdac_mem_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|result
operator|=
name|hdac_irq_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Get Capabilities */
name|result
operator|=
name|hdac_get_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Allocate CORB and RIRB dma memory */
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|,
name|sc
operator|->
name|corb_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
name|result
operator|=
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|,
name|sc
operator|->
name|rirb_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_rirb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
goto|goto
name|hdac_attach_fail
goto|;
comment|/* Quiesce everything */
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reset controller...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the CORB and RIRB */
name|hdac_corb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_rirb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Defer remaining of initialization until interrupts are enabled */
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|hdac_attach2
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
if|if
condition|(
name|cold
operator|==
literal|0
operator|||
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|NULL
expr_stmt|;
name|hdac_attach2
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|hdac_attach_fail
label|:
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|)
expr_stmt|;
name|hdac_mem_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_codec
modifier|*
name|codec
init|=
name|devinfo
operator|->
name|codec
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nid_t
name|cad
decl_stmt|,
name|nid
decl_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
name|nid
operator|=
name|devinfo
operator|->
name|nid
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_GPIO_COUNT
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
operator|=
name|res
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"GPIO: 0x%08x "
literal|"NumGPIO=%d NumGPO=%d "
literal|"NumGPI=%d GPIWake=%d GPIUnsol=%d\n"
argument|, 		    devinfo->function.audio.gpio, 		    HDA_PARAM_GPIO_COUNT_NUM_GPIO(devinfo->function.audio.gpio), 		    HDA_PARAM_GPIO_COUNT_NUM_GPO(devinfo->function.audio.gpio), 		    HDA_PARAM_GPIO_COUNT_NUM_GPI(devinfo->function.audio.gpio), 		    HDA_PARAM_GPIO_COUNT_GPI_WAKE(devinfo->function.audio.gpio), 		    HDA_PARAM_GPIO_COUNT_GPI_UNSOL(devinfo->function.audio.gpio));
argument_list|)
empty_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_STREAM_FORMATS
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_PCM_SIZE_RATE
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|outamp_cap
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
name|cad
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_INPUT_AMP_CAP
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|inamp_cap
operator|=
name|res
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Ghost widget! nid=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|->
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|w
operator|->
name|nid
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|enable
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|pflags
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|ossdev
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|HDAC_INVALID
expr_stmt|;
name|hdac_widget_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctls
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|,
name|max
decl_stmt|,
name|ocap
decl_stmt|,
name|icap
decl_stmt|;
name|int
name|mute
decl_stmt|,
name|offset
decl_stmt|,
name|step
decl_stmt|,
name|size
decl_stmt|;
comment|/* XXX This is redundant */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|!=
literal|0
condition|)
name|max
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|max
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|max
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|1
condition|)
return|return;
name|ctls
operator|=
operator|(
expr|struct
name|hdac_audio_ctl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctls
argument_list|)
operator|*
name|max
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctls
operator|==
name|NULL
condition|)
block|{
comment|/* Blekh! */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to allocate ctls!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctlcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|cnt
operator|<
name|max
operator|&&
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ocap
operator|=
name|w
operator|->
name|param
operator|.
name|outamp_cap
expr_stmt|;
name|icap
operator|=
name|w
operator|->
name|param
operator|.
name|inamp_cap
expr_stmt|;
if|if
condition|(
name|ocap
operator|!=
literal|0
condition|)
block|{
name|mute
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|step
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|size
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
comment|/*if (offset> step) { 				HDA_BOOTVERBOSE( 					device_printf(sc->dev, 					    "BUGGY outamp: nid=%d " 					    "[offset=%d> step=%d]\n", 					    w->nid, offset, step); 				); 				offset = step; 			}*/
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|waspin
condition|)
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDA_CTL_IN
expr_stmt|;
else|else
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDA_CTL_OUT
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDA_CTL_OUT
expr_stmt|;
block|}
if|if
condition|(
name|icap
operator|!=
literal|0
condition|)
block|{
name|mute
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|step
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|size
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|icap
argument_list|)
expr_stmt|;
comment|/*if (offset> step) { 				HDA_BOOTVERBOSE( 					device_printf(sc->dev, 					    "BUGGY inamp: nid=%d " 					    "[offset=%d> step=%d]\n", 					    w->nid, offset, step); 				); 				offset = step; 			}*/
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|childwidget
operator|=
name|cw
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|index
operator|=
name|j
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDA_CTL_IN
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDA_CTL_IN
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDA_CTL_OUT
expr_stmt|;
else|else
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDA_CTL_IN
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDA_CTL_IN
expr_stmt|;
break|break;
block|}
block|}
block|}
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ctl
operator|=
name|ctls
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_as_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|,
name|max
decl_stmt|,
name|type
decl_stmt|,
name|dir
decl_stmt|,
name|assoc
decl_stmt|,
name|seq
decl_stmt|,
name|first
decl_stmt|,
name|hpredir
decl_stmt|;
comment|/* Count present associations */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|!=
name|j
condition|)
continue|continue;
name|max
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|15
condition|)
comment|/* There could be many 1-pin assocs #15 */
break|break;
block|}
block|}
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|1
condition|)
return|return;
name|as
operator|=
operator|(
expr|struct
name|hdac_audio_as
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|as
argument_list|)
operator|*
name|max
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
condition|)
block|{
comment|/* Blekh! */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to allocate assocs!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|as
index|[
name|i
index|]
operator|.
name|hpredir
operator|=
operator|-
literal|1
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|chan
operator|=
operator|-
literal|1
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|digital
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Scan associations skipping as=0. */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|first
operator|=
literal|16
expr_stmt|;
name|hpredir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|assoc
operator|=
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|seq
operator|=
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|j
condition|)
block|{
continue|continue;
block|}
name|KASSERT
argument_list|(
name|cnt
operator|<
name|max
argument_list|,
operator|(
literal|"%s: Associations owerflow (%d of %d)"
operator|,
name|__func__
operator|,
name|cnt
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
comment|/* Get pin direction. */
if|if
condition|(
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_OUT
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_OUT
condition|)
name|dir
operator|=
name|HDA_CTL_OUT
expr_stmt|;
else|else
name|dir
operator|=
name|HDA_CTL_IN
expr_stmt|;
comment|/* If this is a first pin - create new association. */
if|if
condition|(
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|==
literal|0
condition|)
block|{
name|as
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|index
operator|=
name|j
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
block|}
if|if
condition|(
name|seq
operator|<
name|first
condition|)
name|first
operator|=
name|seq
expr_stmt|;
comment|/* Check association correctness. */
if|if
condition|(
name|as
index|[
name|cnt
index|]
operator|.
name|pins
index|[
name|seq
index|]
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Duplicate pin %d (%d) "
literal|"in association %d! Disabling association.\n"
argument_list|,
name|__func__
argument_list|,
name|seq
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
name|as
index|[
name|cnt
index|]
operator|.
name|dir
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: Pin %d has wrong "
literal|"direction for association %d! Disabling "
literal|"association.\n"
argument_list|,
name|__func__
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|as
index|[
name|cnt
index|]
operator|.
name|digital
operator|=
literal|0
expr_stmt|;
comment|/* Headphones with seq=15 may mean redirection. */
if|if
condition|(
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator|&&
name|seq
operator|==
literal|15
condition|)
name|hpredir
operator|=
literal|1
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|pins
index|[
name|seq
index|]
operator|=
name|w
operator|->
name|nid
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|++
expr_stmt|;
comment|/* Association 15 is a multiple unassociated pins. */
if|if
condition|(
name|j
operator|==
literal|15
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
literal|15
operator|&&
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hpredir
operator|&&
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|>
literal|1
condition|)
name|as
index|[
name|cnt
index|]
operator|.
name|hpredir
operator|=
name|first
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"%d associations found:\n"
argument|, max); 		for (i =
literal|0
argument|; i< max; i++) { 			device_printf(sc->dev,
literal|"Association %d (%d) %s%s:\n"
argument|, 			    i, as[i].index, (as[i].dir == HDA_CTL_IN)?
literal|"in"
argument|:
literal|"out"
argument|, 			    as[i].enable?
literal|""
argument|:
literal|" (disabled)"
argument|); 			for (j =
literal|0
argument|; j<
literal|16
argument|; j++) { 				if (as[i].pins[j] ==
literal|0
argument|) 					continue; 				device_printf(sc->dev,
literal|" Pin nid=%d seq=%d\n"
argument|, 				    as[i].pins[j], j); 			} 		}
argument_list|)
empty_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
operator|=
name|as
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|model
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|set
decl_stmt|,
name|unset
decl_stmt|;
block|}
name|hdac_quirks
index|[]
init|=
block|{
comment|/* 	 * XXX Force stereo quirk. Monoural recording / playback 	 *     on few codecs (especially ALC880) seems broken or 	 *     perhaps unsupported. 	 */
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_MATCH_ALL
block|,
name|HDA_QUIRK_FORCESTEREO
operator||
name|HDA_QUIRK_IVREF
block|,
literal|0
block|}
block|,
block|{
name|ACER_ALL_SUBVENDOR
block|,
name|HDA_MATCH_ALL
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_G2K_SUBVENDOR
block|,
name|HDA_CODEC_ALC660
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_M5200_SUBVENDOR
block|,
name|HDA_CODEC_ALC880
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_A7M_SUBVENDOR
block|,
name|HDA_CODEC_ALC880
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_A7T_SUBVENDOR
block|,
name|HDA_CODEC_ALC882
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_W2J_SUBVENDOR
block|,
name|HDA_CODEC_ALC882
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|ASUS_U5F_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|ASUS_A8X_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|ASUS_F3JC_SUBVENDOR
block|,
name|HDA_CODEC_ALC861
block|,
name|HDA_QUIRK_OVREF
block|,
literal|0
block|}
block|,
block|{
name|UNIWILL_9075_SUBVENDOR
block|,
name|HDA_CODEC_ALC861
block|,
name|HDA_QUIRK_OVREF
block|,
literal|0
block|}
block|,
comment|/*{ ASUS_M2N_SUBVENDOR, HDA_CODEC_AD1988, 	    HDA_QUIRK_IVREF80, HDA_QUIRK_IVREF50 | HDA_QUIRK_IVREF100 },*/
block|{
name|MEDION_MD95257_SUBVENDOR
block|,
name|HDA_CODEC_ALC880
block|,
name|HDA_QUIRK_GPIO1
block|,
literal|0
block|}
block|,
block|{
name|LENOVO_3KN100_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
operator||
name|HDA_QUIRK_SENSEINV
block|,
literal|0
block|}
block|,
block|{
name|SAMSUNG_Q1_SUBVENDOR
block|,
name|HDA_CODEC_AD1986A
block|,
name|HDA_QUIRK_EAPDINV
block|,
literal|0
block|}
block|,
block|{
name|APPLE_MB3_SUBVENDOR
block|,
name|HDA_CODEC_ALC885
block|,
name|HDA_QUIRK_GPIO0
operator||
name|HDA_QUIRK_OVREF50
block|,
literal|0
block|}
block|,
block|{
name|APPLE_INTEL_MAC
block|,
name|HDA_CODEC_STAC9221
block|,
name|HDA_QUIRK_GPIO0
operator||
name|HDA_QUIRK_GPIO1
block|,
literal|0
block|}
block|,
block|{
name|DELL_D630_SUBVENDOR
block|,
name|HDA_CODEC_STAC9205X
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|DELL_V1400_SUBVENDOR
block|,
name|HDA_CODEC_STAC9228X
block|,
name|HDA_QUIRK_GPIO2
block|,
literal|0
block|}
block|,
block|{
name|DELL_V1500_SUBVENDOR
block|,
name|HDA_CODEC_STAC9205X
block|,
name|HDA_QUIRK_GPIO0
block|,
literal|0
block|}
block|,
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_CODEC_AD1988
block|,
name|HDA_QUIRK_IVREF80
block|,
name|HDA_QUIRK_IVREF50
operator||
name|HDA_QUIRK_IVREF100
block|}
block|,
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_CODEC_AD1988B
block|,
name|HDA_QUIRK_IVREF80
block|,
name|HDA_QUIRK_IVREF50
operator||
name|HDA_QUIRK_IVREF100
block|}
block|,
block|{
name|HDA_MATCH_ALL
block|,
name|HDA_CODEC_CX20549
block|,
literal|0
block|,
name|HDA_QUIRK_FORCESTEREO
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAC_QUIRKS_LEN
value|(sizeof(hdac_quirks) / sizeof(hdac_quirks[0]))
end_define

begin_function
specifier|static
name|void
name|hdac_vendor_patch_parse
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|id
decl_stmt|,
name|subvendor
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id
operator|=
name|hdac_codec_id
argument_list|(
name|devinfo
operator|->
name|codec
argument_list|)
expr_stmt|;
name|subvendor
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|pci_subvendor
expr_stmt|;
comment|/* 	 * Quirks 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_QUIRKS_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|HDA_DEV_MATCH
argument_list|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|model
argument_list|,
name|subvendor
argument_list|)
operator|&&
name|HDA_DEV_MATCH
argument_list|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|id
argument_list|,
name|id
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|set
operator|!=
literal|0
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator||=
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|set
expr_stmt|;
if|if
condition|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|unset
operator|!=
literal|0
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&=
operator|~
operator|(
name|hdac_quirks
index|[
name|i
index|]
operator|.
name|unset
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|HDA_CODEC_ALC883
case|:
comment|/* 		 * nid: 24/25 = External (jack) or Internal (fixed) Mic. 		 *              Clear vref cap for jack connectivity. 		 */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|enable
operator|!=
literal|0
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
operator|&=
operator|~
operator|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100_MASK
operator||
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80_MASK
operator||
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50_MASK
operator|)
expr_stmt|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|25
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|enable
operator|!=
literal|0
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
operator|&=
operator|~
operator|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100_MASK
operator||
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80_MASK
operator||
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50_MASK
operator|)
expr_stmt|;
comment|/* 		 * nid: 26 = Line-in, leave it alone. 		 */
break|break;
case|case
name|HDA_CODEC_AD1986A
case|:
comment|/* 		 * This codec has overcomplicated input mixing. 		 * Make some cleaning there. 		 */
comment|/* Disable input mono mixer. Not needed and not supported. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|43
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
comment|/* Disable any with any input mixing mesh. Use separately. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|39
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|41
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|42
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
comment|/* Disable duplicate mixer node connector. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|connsenable
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|subvendor
operator|==
name|ASUS_A8X_SUBVENDOR
condition|)
block|{
comment|/* 			 * This is just plain ridiculous.. There 			 * are several A8 series that share the same 			 * pci id but works differently (EAPD). 			 */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|26
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|!=
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
condition|)
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&=
operator|~
name|HDA_QUIRK_EAPDINV
expr_stmt|;
block|}
break|break;
case|case
name|HDA_CODEC_AD1981HD
case|:
comment|/* 		 * This codec has very unusual design with several 		 * points inappropriate for the present parser. 		 */
comment|/* Disable recording from mono playback mix. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|21
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|connsenable
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Disable rear to front mic mixer, use separately. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
comment|/* Disable playback mixer, use direct bypass. */
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Trace path from DAC to pin.  */
end_comment

begin_function
specifier|static
name|nid_t
name|hdac_audio_trace_dac
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|dupseq
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|only
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|im
init|=
operator|-
literal|1
decl_stmt|;
name|nid_t
name|m
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 			device_printf(devinfo->codec->sc->dev,
literal|" %*stracing via nid %d\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid); 		}
argument_list|)
empty_stmt|;
comment|/* Use only unused widgets */
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|as
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 				device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d busy by association %d\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas); 			}
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dupseq
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|bindseqmask
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 					device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d busy by seqmask %x\n"
argument|, 						depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindseqmask); 				}
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* If this is headphones - allow duplicate first pin. */
if|if
condition|(
name|w
operator|->
name|bindseqmask
operator|!=
literal|0
operator|&&
operator|(
name|w
operator|->
name|bindseqmask
operator|&
operator|(
literal|1
operator|<<
name|dupseq
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d busy by seqmask %x\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindseqmask);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
comment|/* Do not traverse input. AD1988 has digital monitor 		for which we are not ready. */
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
comment|/* If we are tracing HP take only dac of first pin. */
if|if
condition|(
operator|(
name|only
operator|==
literal|0
operator|||
name|only
operator|==
name|w
operator|->
name|nid
operator|)
operator|&&
operator|(
name|w
operator|->
name|nid
operator|>=
name|min
operator|)
operator|&&
operator|(
name|dupseq
operator|<
literal|0
operator|||
name|w
operator|->
name|nid
operator|==
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
index|[
name|as
index|]
operator|.
name|dacs
index|[
name|dupseq
index|]
operator|)
condition|)
name|m
operator|=
name|w
operator|->
name|nid
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
break|break;
comment|/* Fall */
default|default:
comment|/* Find reachable DACs with smallest nid respecting constraints. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|selconn
operator|!=
operator|-
literal|1
operator|&&
name|w
operator|->
name|selconn
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|hdac_audio_trace_dac
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|seq
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|dupseq
argument_list|,
name|min
argument_list|,
name|only
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
operator|||
name|ret
operator|<
name|m
condition|)
block|{
name|m
operator|=
name|ret
expr_stmt|;
name|im
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|only
operator|||
name|dupseq
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|m
operator|&&
name|only
operator|&&
operator|(
operator|(
name|w
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|)
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|)
condition|)
name|w
operator|->
name|selconn
operator|=
name|im
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|&&
name|only
condition|)
block|{
name|w
operator|->
name|bindas
operator|=
name|as
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator||=
operator|(
literal|1
operator|<<
name|seq
operator|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 			device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d returned %d\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid, m); 		}
argument_list|)
empty_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trace path from widget to ADC.  */
end_comment

begin_function
specifier|static
name|nid_t
name|hdac_audio_trace_adc
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|only
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|nid_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*stracing via nid %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid);
argument_list|)
empty_stmt|;
comment|/* Use only unused widgets */
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|as
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d busy by association %d\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
comment|/* If we are tracing HP take only dac of first pin. */
if|if
condition|(
name|only
operator|==
name|w
operator|->
name|nid
condition|)
name|res
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
break|break;
comment|/* Fall */
default|default:
comment|/* Try to find reachable ADCs with specified nid. */
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|wc
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wc
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|wc
operator|->
name|conns
index|[
name|i
index|]
operator|!=
name|nid
condition|)
continue|continue;
if|if
condition|(
name|hdac_audio_trace_adc
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|seq
argument_list|,
name|j
argument_list|,
name|only
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|wc
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|wc
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|)
operator|||
name|wc
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|)
operator|&&
name|wc
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|wc
operator|->
name|selconn
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
if|if
condition|(
name|res
condition|)
block|{
name|w
operator|->
name|bindas
operator|=
name|as
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator||=
operator|(
literal|1
operator|<<
name|seq
operator|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d returned %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid, res);
argument_list|)
empty_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Erase trace path of the specified association.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_audio_undo_trace
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
name|as
condition|)
block|{
if|if
condition|(
name|seq
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|bindseqmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|seq
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|bindseqmask
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Trace association path from DAC to output  */
end_comment

begin_function
specifier|static
name|int
name|hdac_audio_trace_as_out
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hpredir
decl_stmt|;
name|nid_t
name|min
decl_stmt|,
name|res
decl_stmt|;
comment|/* Find next pin */
for|for
control|(
name|i
operator|=
name|seq
init|;
name|i
operator|<
literal|16
operator|&&
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Check if there is no any left. If so - we succeded. */
if|if
condition|(
name|i
operator|==
literal|16
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hpredir
operator|=
operator|(
name|i
operator|==
literal|15
operator|&&
name|ases
index|[
name|as
index|]
operator|.
name|fakeredir
operator|==
literal|0
operator|)
condition|?
name|ases
index|[
name|as
index|]
operator|.
name|hpredir
else|:
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Tracing pin %d with min nid %d"
argument|, 			    ases[as].pins[i], min); 			if (hpredir>=
literal|0
argument|) 				printf(
literal|" and hpredir %d"
argument|, hpredir); 			printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* Trace this pin taking min nid into account. */
name|res
operator|=
name|hdac_audio_trace_dac
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
name|hpredir
argument_list|,
name|min
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
comment|/* If we failed - return to previous and redo it. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Unable to trace pin %d seq %d with min "
literal|"nid %d"
argument|, 				    ases[as].pins[i], i, min); 				if (hpredir>=
literal|0
argument|) 					printf(
literal|" and hpredir %d"
argument|, hpredir); 				printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Pin %d traced to DAC %d"
argument|, 			    ases[as].pins[i], res); 			if (hpredir>=
literal|0
argument|) 				printf(
literal|" and hpredir %d"
argument|, hpredir); 			if (ases[as].fakeredir) 				printf(
literal|" with fake redirection"
argument|); 			printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* Trace again to mark the path */
name|hdac_audio_trace_dac
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
name|hpredir
argument_list|,
name|min
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
operator|=
name|res
expr_stmt|;
comment|/* We succeded, so call next. */
if|if
condition|(
name|hdac_audio_trace_as_out
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If next failed, we should retry with next min */
name|hdac_audio_undo_trace
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|min
operator|=
name|res
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Trace association path from input to ADC  */
end_comment

begin_function
specifier|static
name|int
name|hdac_audio_trace_as_in
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|as
condition|)
continue|continue;
comment|/* Find next pin */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Tracing pin %d to ADC %d\n"
argument|, 				    ases[as].pins[i], j);
argument_list|)
empty_stmt|;
comment|/* Trace this pin taking goal into account. */
if|if
condition|(
name|hdac_audio_trace_adc
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If we failed - return to previous and redo it. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Unable to trace pin %d to ADC %d, undo traces\n"
argument|, 					    ases[as].pins[i], j);
argument_list|)
empty_stmt|;
name|hdac_audio_undo_trace
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|16
condition|;
name|k
operator|++
control|)
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Pin %d traced to ADC %d\n"
argument|, 				    ases[as].pins[i], j);
argument_list|)
empty_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|16
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trace input monitor path from mixer to output association.  */
end_comment

begin_function
specifier|static
name|int
name|hdac_audio_trace_to_out
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|nid_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*stracing via nid %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid);
argument_list|)
empty_stmt|;
comment|/* Use only unused widgets */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|ases
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_OUT
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d found output association %d\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d busy by input association %d\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
comment|/* Do not traverse input. AD1988 has digital monitor 		for which we are not ready. */
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
break|break;
comment|/* Fall */
default|default:
comment|/* Try to find reachable ADCs with specified nid. */
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|wc
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wc
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|wc
operator|->
name|conns
index|[
name|i
index|]
operator|!=
name|nid
condition|)
continue|continue;
if|if
condition|(
name|hdac_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wc
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
name|wc
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|wc
operator|->
name|selconn
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
if|if
condition|(
name|res
condition|)
name|w
operator|->
name|bindas
operator|=
operator|-
literal|2
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" %*snid %d returned %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid, res);
argument_list|)
empty_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trace extra associations (beeper, monitor)  */
end_comment

begin_function
specifier|static
name|void
name|hdac_audio_trace_as_extra
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Input monitor */
comment|/* Find mixer associated with input, but supplying signal 	   for output associations. Hope it will be input monitor. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"Tracing input monitor\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|!=
name|HDA_CTL_IN
condition|)
continue|continue;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Tracing nid %d to out\n"
argument|, 			    j);
argument_list|)
empty_stmt|;
if|if
condition|(
name|hdac_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" nid %d is input monitor\n"
argument|, 					w->nid);
argument_list|)
empty_stmt|;
name|w
operator|->
name|pflags
operator||=
name|HDA_ADC_MONITOR
expr_stmt|;
name|w
operator|->
name|ossdev
operator|=
name|SOUND_MIXER_IMIX
expr_stmt|;
block|}
block|}
comment|/* Beeper */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"Tracing beeper\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
condition|)
continue|continue;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Tracing nid %d to out\n"
argument|, 			    j);
argument_list|)
empty_stmt|;
if|if
condition|(
name|hdac_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" nid %d traced to out\n"
argument|, 				    j);
argument_list|)
empty_stmt|;
block|}
name|w
operator|->
name|bindas
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Bind assotiations to PCM channels  */
end_comment

begin_function
specifier|static
name|void
name|hdac_audio_bind_as
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|int
name|j
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|,
name|free
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|num_chans
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|chans
operator|=
operator|(
expr|struct
name|hdac_chan
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_chan
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chans
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"Channels memory allocation failed!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|chans
operator|=
operator|(
expr|struct
name|hdac_chan
operator|*
operator|)
name|realloc
argument_list|(
name|sc
operator|->
name|chans
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_chan
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|num_chans
operator|+
name|cnt
operator|)
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chans
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|num_chans
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"Channels memory allocation failed!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|free
operator|=
name|sc
operator|->
name|num_chans
expr_stmt|;
name|sc
operator|->
name|num_chans
operator|+=
name|cnt
expr_stmt|;
for|for
control|(
name|j
operator|=
name|free
init|;
name|j
operator|<
name|free
operator|+
name|cnt
condition|;
name|j
operator|++
control|)
block|{
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|chans
index|[
name|j
index|]
operator|.
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|chans
index|[
name|j
index|]
operator|.
name|as
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Assign associations in order of their numbers, */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|as
index|[
name|j
index|]
operator|.
name|chan
operator|=
name|free
expr_stmt|;
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|chans
index|[
name|free
index|]
operator|.
name|as
operator|=
name|j
expr_stmt|;
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|chans
index|[
name|free
index|]
operator|.
name|dir
operator|=
operator|(
name|as
index|[
name|j
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
operator|)
condition|?
name|PCMDIR_REC
else|:
name|PCMDIR_PLAY
expr_stmt|;
name|hdac_pcmchannel_setup
argument_list|(
operator|&
name|devinfo
operator|->
name|codec
operator|->
name|sc
operator|->
name|chans
index|[
name|free
index|]
argument_list|)
expr_stmt|;
name|free
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_disable_nonaudio
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable power and volume widgets. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_POWER_WIDGET
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VOLUME_WIDGET
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling nid %d due to it's"
literal|" non-audio type.\n"
argument|, 				    w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_disable_useless
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|done
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Disable useless pins. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling pin nid %d due"
literal|" to None connectivity.\n"
argument|, 					    w->nid);
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling unassociated"
literal|" pin nid %d.\n"
argument|, 					    w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
do|do
block|{
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Disable and mute controls for disabled widgets. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|enable
operator|==
literal|0
operator|||
operator|(
name|ctl
operator|->
name|childwidget
operator|!=
name|NULL
operator|&&
name|ctl
operator|->
name|childwidget
operator|->
name|enable
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|ndir
operator|==
name|HDA_CTL_IN
condition|)
name|ctl
operator|->
name|widget
operator|->
name|connsenable
index|[
name|ctl
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling ctl %d nid %d cnid %d due"
literal|" to disabled widget.\n"
argument|, i, 					    ctl->widget->nid, 					    (ctl->childwidget != NULL)? 					    ctl->childwidget->nid:-
literal|1
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Disable useless widgets. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
comment|/* Disable inputs with disabled child widgets. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling nid %d connection %d due"
literal|" to disabled child widget.\n"
argument|, 							    i, j);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
comment|/* Disable mixers and selectors without inputs. */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling nid %d due to all it's"
literal|" inputs disabled.\n"
argument|, w->nid);
argument_list|)
empty_stmt|;
block|}
comment|/* Disable nodes without consumers. */
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|k
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|k
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cw
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cw
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|cw
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling nid %d due to all it's"
literal|" consumers disabled.\n"
argument|, w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_disable_unas
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Disable unassosiated widgets. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling unassociated nid %d.\n"
argument|, 				    w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Disable input connections on input pin and 	 * output on output. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling connection to input pin "
literal|"nid %d conn %d.\n"
argument|, 					    i, j);
argument_list|)
empty_stmt|;
block|}
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_IN
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
name|ctl
operator|->
name|enable
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
name|ctl
operator|->
name|enable
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|k
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|k
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cw
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cw
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|cw
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|cw
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling connection from output pin "
literal|"nid %d conn %d cnid %d.\n"
argument|, 							    k, j, i);
argument_list|)
empty_stmt|;
if|if
condition|(
name|cw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|cw
operator|->
name|nconns
operator|>
literal|1
condition|)
continue|continue;
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|k
argument_list|,
name|HDA_CTL_IN
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
name|ctl
operator|->
name|enable
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_disable_notselected
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* On playback path we can safely disable all unseleted inputs. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nconns
operator|<=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|selconn
operator|<
literal|0
operator|||
name|w
operator|->
name|selconn
operator|==
name|j
condition|)
continue|continue;
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling unselected connection "
literal|"nid %d conn %d.\n"
argument|, 				    i, j);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_disable_crossas
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Disable crossassociatement connections. */
comment|/* ... using selectors */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nconns
operator|<=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|2
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
name|cw
operator|->
name|bindas
operator|||
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|2
condition|)
continue|continue;
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling crossassociatement connection "
literal|"nid %d conn %d cnid %d.\n"
argument|, 				    i, j, cw->nid);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* ... using controls */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|childwidget
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|||
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
operator|==
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|!=
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|ndir
operator|==
name|HDA_CTL_IN
condition|)
name|ctl
operator|->
name|widget
operator|->
name|connsenable
index|[
name|ctl
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|" Disabling crossassociatement connection "
literal|"ctl %d nid %d cnid %d.\n"
argument|, i, 				    ctl->widget->nid, 				    ctl->childwidget->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|HDA_CTL_GIVE
parameter_list|(
name|ctl
parameter_list|)
value|((ctl)->step?1:0)
end_define

begin_comment
comment|/*  * Find controls to control amplification for source.  */
end_comment

begin_function
specifier|static
name|int
name|hdac_audio_ctl_source_amp
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|int
name|ctlable
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|need
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|conns
init|=
literal|0
decl_stmt|,
name|rneed
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
name|need
operator|)
return|;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
name|need
operator|)
return|;
comment|/* Count number of active inputs. */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
name|conns
operator|++
expr_stmt|;
block|}
block|}
comment|/* If this is not a first step - use input mixer. 	   Pins have common input ctl so care must be taken. */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|ctlable
operator|&&
operator|(
name|conns
operator|==
literal|1
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
condition|)
block|{
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_IN
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
if|if
condition|(
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
operator|&
name|need
condition|)
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
else|else
name|ctl
operator|->
name|possmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|need
operator|&=
operator|~
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If widget has own ossdev - not traverse it. 	   It will be traversed on it's own. */
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return
operator|(
name|need
operator|)
return|;
comment|/* We must not traverse pin */
if|if
condition|(
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return
operator|(
name|need
operator|)
return|;
comment|/* record that this widget exports such signal, */
name|w
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
comment|/* If signals mixed, we can't assign controls farther. 	 * Ignore this on depth zero. Caller must knows why. 	 * Ignore this for static selectors if this input selected. 	 */
if|if
condition|(
name|conns
operator|>
literal|1
condition|)
name|ctlable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlable
condition|)
block|{
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
if|if
condition|(
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
operator|&
name|need
condition|)
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
else|else
name|ctl
operator|->
name|possmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|need
operator|&=
operator|~
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
name|rneed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wc
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|wc
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|nid
condition|)
block|{
name|rneed
operator||=
name|hdac_audio_ctl_source_amp
argument_list|(
name|devinfo
argument_list|,
name|wc
operator|->
name|nid
argument_list|,
name|j
argument_list|,
name|ossdev
argument_list|,
name|ctlable
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rneed
operator|&=
name|need
expr_stmt|;
return|return
operator|(
name|rneed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find controls to control amplification for destination.  */
end_comment

begin_function
specifier|static
name|void
name|hdac_audio_ctl_dest_amp
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|need
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|consumers
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
comment|/* If this node produce output for several consumers, 		   we can't touch it. */
name|consumers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wc
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|wc
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|nid
condition|)
name|consumers
operator|++
expr_stmt|;
block|}
block|}
comment|/* The only exception is if real HP redirection is configured 		   and this is a duplication point. 		   XXX: Actually exception is not completely correct. 		   XXX: Duplication point check is not perfect. */
if|if
condition|(
operator|(
name|consumers
operator|==
literal|2
operator|&&
operator|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|hpredir
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|fakeredir
operator|||
operator|(
name|w
operator|->
name|bindseqmask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
name|consumers
operator|>
literal|2
condition|)
return|return;
comment|/* Else use it's output mixer. */
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
if|if
condition|(
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
operator|&
name|need
condition|)
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
else|else
name|ctl
operator|->
name|possmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|need
operator|&=
operator|~
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We must not traverse pin */
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tneed
init|=
name|need
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|ctl
operator|=
name|hdac_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CTL_IN
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
if|if
condition|(
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
operator|&
name|tneed
condition|)
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
else|else
name|ctl
operator|->
name|possmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|tneed
operator|&=
operator|~
name|HDA_CTL_GIVE
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
name|hdac_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|ossdev
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|tneed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Assign OSS names to sound sources  */
end_comment

begin_function
specifier|static
name|void
name|hdac_audio_assign_names
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|,
name|use
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|types
index|[
literal|7
index|]
index|[
literal|13
index|]
init|=
block|{
block|{
name|SOUND_MIXER_LINE
block|,
name|SOUND_MIXER_LINE1
block|,
name|SOUND_MIXER_LINE2
block|,
name|SOUND_MIXER_LINE3
block|,
operator|-
literal|1
block|}
block|,
comment|/* line */
block|{
name|SOUND_MIXER_MONITOR
block|,
name|SOUND_MIXER_MIC
block|,
operator|-
literal|1
block|}
block|,
comment|/* int mic */
block|{
name|SOUND_MIXER_MIC
block|,
name|SOUND_MIXER_MONITOR
block|,
operator|-
literal|1
block|}
block|,
comment|/* ext mic */
block|{
name|SOUND_MIXER_CD
block|,
operator|-
literal|1
block|}
block|,
comment|/* cd */
block|{
name|SOUND_MIXER_SPEAKER
block|,
operator|-
literal|1
block|}
block|,
comment|/* speaker */
block|{
name|SOUND_MIXER_DIGITAL1
block|,
name|SOUND_MIXER_DIGITAL2
block|,
name|SOUND_MIXER_DIGITAL3
block|,
operator|-
literal|1
block|}
block|,
comment|/* digital */
block|{
name|SOUND_MIXER_LINE
block|,
name|SOUND_MIXER_LINE1
block|,
name|SOUND_MIXER_LINE2
block|,
name|SOUND_MIXER_LINE3
block|,
name|SOUND_MIXER_PHONEIN
block|,
name|SOUND_MIXER_PHONEOUT
block|,
name|SOUND_MIXER_VIDEO
block|,
name|SOUND_MIXER_RADIO
block|,
name|SOUND_MIXER_DIGITAL1
block|,
name|SOUND_MIXER_DIGITAL2
block|,
name|SOUND_MIXER_DIGITAL3
block|,
name|SOUND_MIXER_MONITOR
block|,
operator|-
literal|1
block|}
comment|/* others */
block|}
decl_stmt|;
comment|/* Surely known names */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|use
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_OUT
condition|)
break|break;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
case|:
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
condition|)
break|break;
name|type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
case|:
name|type
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
case|:
name|type
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_IN
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_IN
case|:
name|type
operator|=
literal|5
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
break|break;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
operator|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|use
operator|=
name|types
index|[
name|type
index|]
index|[
name|j
index|]
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
name|use
operator|=
name|SOUND_MIXER_PCM
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
case|:
name|use
operator|=
name|SOUND_MIXER_SPEAKER
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|use
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|ossdev
operator|=
name|use
expr_stmt|;
name|used
operator||=
operator|(
literal|1
operator|<<
name|use
operator|)
expr_stmt|;
block|}
block|}
comment|/* Semi-known names */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_OUT
condition|)
continue|continue;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_AUX
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
case|:
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_OUT
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_OUT
case|:
name|type
operator|=
literal|5
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
break|break;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
operator|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|ossdev
operator|=
name|types
index|[
name|type
index|]
index|[
name|j
index|]
expr_stmt|;
name|used
operator||=
operator|(
literal|1
operator|<<
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* Others */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_OUT
condition|)
continue|continue;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
operator|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|ossdev
operator|=
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
expr_stmt|;
name|used
operator||=
operator|(
literal|1
operator|<<
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_build_tree
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|int
name|j
decl_stmt|,
name|res
decl_stmt|;
comment|/* Trace all associations in order of their numbers, */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"Tracing association %d (%d)\n"
argument|, j, as[j].index);
argument_list|)
empty_stmt|;
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_OUT
condition|)
block|{
name|retry
label|:
name|res
operator|=
name|hdac_audio_trace_as_out
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
operator|&&
name|as
index|[
name|j
index|]
operator|.
name|hpredir
operator|>=
literal|0
operator|&&
name|as
index|[
name|j
index|]
operator|.
name|fakeredir
operator|==
literal|0
condition|)
block|{
comment|/* If codec can't do analog HP redirection 				   try to make it using one more DAC. */
name|as
index|[
name|j
index|]
operator|.
name|fakeredir
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
else|else
block|{
name|res
operator|=
name|hdac_audio_trace_as_in
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"Association %d (%d) trace succeded\n"
argument|, 				    j, as[j].index);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->codec->sc->dev,
literal|"Association %d (%d) trace failed\n"
argument|, 				    j, as[j].index);
argument_list|)
empty_stmt|;
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Trace mixer and beeper pseudo associations. */
name|hdac_audio_trace_as_extra
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_assign_mixers
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Assign mixers to the tree. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
operator|||
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|ossdev
operator|<
literal|0
condition|)
continue|continue;
name|hdac_audio_ctl_source_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_MONITOR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|ossdev
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|hdac_audio_ctl_source_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If we are unable to control input monitor 				   as source - try to control it as destination. */
name|hdac_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|hdac_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|SOUND_MIXER_RECLEV
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_OUT
condition|)
block|{
name|hdac_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Treat unrequired as possible. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|ossmask
operator|==
literal|0
condition|)
name|ctl
operator|->
name|ossmask
operator|=
name|ctl
operator|->
name|possmask
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_prepare_pin_ctrl
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|pincap
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|nodecnt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
operator|&
name|devinfo
operator|->
name|widget
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
comment|/* Disable everything. */
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
operator|(
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
comment|/* Pin is unused so left it disabled. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
condition|)
block|{
comment|/* Input pin, configure for input. */
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_IVREF100
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_IVREF80
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_80
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_IVREF50
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_50
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output pin, configure for output. */
if|if
condition|(
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
operator|&&
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_OVREF100
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_OVREF80
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_80
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_OVREF50
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_50
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_commit
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|uint32_t
name|gdata
decl_stmt|,
name|gmask
decl_stmt|,
name|gdir
decl_stmt|;
name|int
name|commitgpio
decl_stmt|,
name|numgpio
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cad
operator|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pci_subvendor
operator|==
name|APPLE_INTEL_MAC
condition|)
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_12BIT
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
literal|0x7e7
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|gdata
operator|=
literal|0
expr_stmt|;
name|gmask
operator|=
literal|0
expr_stmt|;
name|gdir
operator|=
literal|0
expr_stmt|;
name|commitgpio
operator|=
literal|0
expr_stmt|;
name|numgpio
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_GPIOFLUSH
condition|)
name|commitgpio
operator|=
operator|(
name|numgpio
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpio
operator|&&
name|i
operator|<
name|HDA_GPIO_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|commitgpio
operator|==
literal|0
condition|)
block|{
name|commitgpio
operator|=
literal|1
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|gdata = hdac_command(sc, 					    HDA_CMD_GET_GPIO_DATA(cad, 					    devinfo->nid), cad); 					gmask = hdac_command(sc, 					    HDA_CMD_GET_GPIO_ENABLE_MASK(cad, 					    devinfo->nid), cad); 					gdir = hdac_command(sc, 					    HDA_CMD_GET_GPIO_DIRECTION(cad, 					    devinfo->nid), cad); 					device_printf(sc->dev,
literal|"GPIO init: data=0x%08x "
literal|"mask=0x%08x dir=0x%08x\n"
argument|, 					    gdata, gmask, gdir); 					gdata =
literal|0
argument|; 					gmask =
literal|0
argument|; 					gdir =
literal|0
argument|;
argument_list|)
empty_stmt|;
block|}
name|gdata
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|gmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|gdir
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|commitgpio
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"GPIO commit: data=0x%08x mask=0x%08x "
literal|"dir=0x%08x\n"
argument|, 			    gdata, gmask, gdir);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_GPIO_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gmask
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_GPIO_DIRECTION
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdir
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_GPIO_DATA
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdata
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|nodecnt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
operator|&
name|devinfo
operator|->
name|widget
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|selconn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|0
condition|)
name|hdac_widget_connection_select
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|selconn
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDAC_INVALID
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_EAPDINV
condition|)
name|val
operator|^=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_EAPD_BTL_ENABLE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|val
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_audio_ctl_commit
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
block|{
comment|/* Mute disabled controls. */
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_ALL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Init controls to 0dB amplification. */
name|z
operator|=
name|ctl
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|z
operator|>
name|ctl
operator|->
name|step
condition|)
name|z
operator|=
name|ctl
operator|->
name|step
expr_stmt|;
name|hdac_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDA_AMP_MUTE_NONE
argument_list|,
name|z
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_powerup
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|nid_t
name|cad
init|=
name|devinfo
operator|->
name|codec
operator|->
name|cad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|cad
argument_list|,
name|i
argument_list|,
name|HDA_CMD_POWER_STATE_D0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_pcmchannel_setup
parameter_list|(
name|struct
name|hdac_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|cap
decl_stmt|,
name|fmtcap
decl_stmt|,
name|pcmcap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|,
name|max
decl_stmt|;
name|ch
operator|->
name|caps
operator|=
name|hdac_caps
expr_stmt|;
name|ch
operator|->
name|caps
operator|.
name|fmtlist
operator|=
name|ch
operator|->
name|fmtlist
expr_stmt|;
name|ch
operator|->
name|bit16
operator|=
literal|1
expr_stmt|;
name|ch
operator|->
name|bit32
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|fmtcap
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
expr_stmt|;
name|pcmcap
operator|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
expr_stmt|;
name|max
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|io
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|io
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
operator|&&
name|ret
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check as is correct */
if|if
condition|(
name|ch
operator|->
name|as
operator|<
literal|0
condition|)
break|break;
comment|/* Cound only present DACs */
if|if
condition|(
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
comment|/* Ignore duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ret
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|io
index|[
name|j
index|]
operator|==
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|ret
condition|)
continue|continue;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|HDA_PARAM_AUDIO_WIDGET_CAP_STEREO
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
continue|continue;
name|cap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
expr_stmt|;
comment|/*if (HDA_PARAM_SUPP_STREAM_FORMATS_FLOAT32(cap)) { 		}*/
if|if
condition|(
operator|!
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|cap
argument_list|)
operator|&&
operator|!
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|cap
argument_list|)
condition|)
continue|continue;
comment|/* Many codec does not declare AC3 support on SPDIF. 		   I don't beleave that they doesn't support it! */
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|cap
operator||=
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3_MASK
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|fmtcap
operator|=
name|cap
expr_stmt|;
name|pcmcap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
else|else
block|{
name|fmtcap
operator|&=
name|cap
expr_stmt|;
name|pcmcap
operator|&=
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
name|ch
operator|->
name|io
index|[
name|ret
operator|++
index|]
operator|=
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|i
index|]
expr_stmt|;
block|}
name|ch
operator|->
name|io
index|[
name|ret
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|->
name|supp_stream_formats
operator|=
name|fmtcap
expr_stmt|;
name|ch
operator|->
name|supp_pcm_size_rate
operator|=
name|pcmcap
expr_stmt|;
comment|/* 	 *  8bit = 0 	 * 16bit = 1 	 * 20bit = 2 	 * 24bit = 3 	 * 32bit = 4 	 */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|fmtcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit16
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_FORCESTEREO
operator|)
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S16_LE
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_FORCESTEREO
operator|)
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S32_LE
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_S32_LE
operator||
name|AFMT_STEREO
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|fmtcap
argument_list|)
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|AFMT_AC3
expr_stmt|;
block|}
name|ch
operator|->
name|fmtlist
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|8000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_11KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|11025
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|16000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_22KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|22050
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|32000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_44KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|44100
expr_stmt|;
comment|/* if (HDA_PARAM_SUPP_PCM_SIZE_RATE_48KHZ(pcmcap)) */
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|48000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_88KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|88200
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_96KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|96000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_176KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|176400
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_192KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|192000
expr_stmt|;
comment|/* if (HDA_PARAM_SUPP_PCM_SIZE_RATE_384KHZ(pcmcap)) */
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ch
operator|->
name|caps
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
expr_stmt|;
name|ch
operator|->
name|caps
operator|.
name|maxspeed
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_create_pcms
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|apdev
init|=
literal|0
decl_stmt|,
name|ardev
init|=
literal|0
decl_stmt|,
name|dpdev
init|=
literal|0
decl_stmt|,
name|drdev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
condition|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|digital
condition|)
name|drdev
operator|++
expr_stmt|;
else|else
name|ardev
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|digital
condition|)
name|dpdev
operator|++
expr_stmt|;
else|else
name|apdev
operator|++
expr_stmt|;
block|}
block|}
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|num_devs
operator|=
name|max
argument_list|(
name|ardev
argument_list|,
name|apdev
argument_list|)
operator|+
name|max
argument_list|(
name|drdev
argument_list|,
name|dpdev
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
operator|=
operator|(
expr|struct
name|hdac_pcm_devinfo
operator|*
operator|)
name|malloc
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|num_devs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_pcm_devinfo
argument_list|)
argument_list|,
name|M_HDAC
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to allocate memory for devices\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|num_devs
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
operator|.
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
operator|.
name|play
operator|=
operator|-
literal|1
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
operator|.
name|rec
operator|=
operator|-
literal|1
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
operator|.
name|digital
operator|=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|num_devs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|digital
operator|!=
literal|2
operator|&&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|digital
operator|!=
name|as
index|[
name|i
index|]
operator|.
name|digital
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|dir
operator|==
name|HDA_CTL_IN
condition|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|rec
operator|>=
literal|0
condition|)
continue|continue;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|rec
operator|=
name|as
index|[
name|i
index|]
operator|.
name|chan
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|play
operator|>=
literal|0
condition|)
continue|continue;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|play
operator|=
name|as
index|[
name|i
index|]
operator|.
name|chan
expr_stmt|;
block|}
name|sc
operator|->
name|chans
index|[
name|as
index|[
name|i
index|]
operator|.
name|chan
index|]
operator|.
name|pdevinfo
operator|=
operator|&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|j
index|]
operator|.
name|digital
operator|=
name|as
index|[
name|i
index|]
operator|.
name|digital
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|num_devs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
decl_stmt|;
name|pdevinfo
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pdevinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_ctls
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|banner
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|printed
decl_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
operator|~
operator|(
name|SOUND_MASK_VOLUME
operator||
name|SOUND_MASK_PCM
operator||
name|SOUND_MASK_CD
operator||
name|SOUND_MASK_LINE
operator||
name|SOUND_MASK_RECLEV
operator||
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_SPEAKER
operator||
name|SOUND_MASK_OGAIN
operator||
name|SOUND_MASK_IMIX
operator||
name|SOUND_MASK_MONITOR
operator|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|i
operator|=
literal|0
expr_stmt|;
name|printed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdac_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|play
index|]
operator|.
name|as
operator|)
operator|||
operator|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
operator|.
name|as
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|pdevinfo
operator|->
name|index
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|banner
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%s"
argument_list|,
name|banner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Unknown Ctl"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (OSS: %s)\n"
argument_list|,
name|hdac_audio_ctl_ossmixer_mask2allname
argument_list|(
literal|1
operator|<<
name|j
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"   |\n"
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"   +- ctl %2d (nid %3d %s"
argument_list|,
name|i
argument_list|,
name|ctl
operator|->
name|widget
operator|->
name|nid
argument_list|,
operator|(
name|ctl
operator|->
name|ndir
operator|==
name|HDA_CTL_IN
operator|)
condition|?
literal|"in "
else|:
literal|"out"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|ndir
operator|==
name|HDA_CTL_IN
operator|&&
name|ctl
operator|->
name|ndir
operator|==
name|ctl
operator|->
name|dir
condition|)
name|printf
argument_list|(
literal|" %2d): "
argument_list|,
name|ctl
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"):    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|step
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%+d/%+ddB (%d steps)%s\n"
argument_list|,
operator|(
literal|0
operator|-
name|ctl
operator|->
name|offset
operator|)
operator|*
operator|(
name|ctl
operator|->
name|size
operator|+
literal|1
operator|)
operator|/
literal|4
argument_list|,
operator|(
name|ctl
operator|->
name|step
operator|-
name|ctl
operator|->
name|offset
operator|)
operator|*
operator|(
name|ctl
operator|->
name|size
operator|+
literal|1
operator|)
operator|/
literal|4
argument_list|,
name|ctl
operator|->
name|step
operator|+
literal|1
argument_list|,
name|ctl
operator|->
name|mute
condition|?
literal|" + mute"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ctl
operator|->
name|mute
condition|?
literal|"mute"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_audio_formats
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|fcap
parameter_list|,
name|uint32_t
name|pcmcap
parameter_list|)
block|{
name|uint32_t
name|cap
decl_stmt|;
name|cap
operator|=
name|fcap
expr_stmt|;
if|if
condition|(
name|cap
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"     Stream cap: 0x%08x\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AC3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_FLOAT32
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" FLOAT32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PCM"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cap
operator|=
name|pcmcap
expr_stmt|;
if|if
condition|(
name|cap
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"        PCM cap: 0x%08x\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 20"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 24"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 32"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bits,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_11KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 11"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_22KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 22"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_44KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 44"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 48"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_88KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_96KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 96"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_176KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 176"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_192KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 192"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" KHz\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_pin
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|)
block|{
name|uint32_t
name|pincap
decl_stmt|;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"        Pin cap: 0x%08x\n"
argument_list|,
name|pincap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_IMP_SENSE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" ISC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_TRIGGER_REQD
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" TRQD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PDC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_BALANCED_IO_PINS
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" BAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" VREF["
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 50"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 80"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 100"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_GROUND
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" GROUND"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_HIZ
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HIZ"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" EAPD"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     Pin config: 0x%08x\n"
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    Pin control: 0x%08x"
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
condition|)
name|printf
argument_list|(
literal|" HP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
condition|)
name|printf
argument_list|(
literal|" IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
condition|)
name|printf
argument_list|(
literal|" OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
condition|)
name|printf
argument_list|(
literal|" VREFs"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_pin_config
parameter_list|(
name|struct
name|hdac_widget
modifier|*
name|w
parameter_list|,
name|uint32_t
name|conf
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|w
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|" nid %d 0x%08x as %2d seq %2d %13s %5s "
literal|"jack %2d loc %2d color %7s misc %d%s\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|conf
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_DEVS
index|[
name|HDA_CONFIG_DEFAULTCONF_DEVICE
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONNS
index|[
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_LOCATION
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_COLORS
index|[
name|HDA_CONFIG_DEFAULTCONF_COLOR
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|conf
argument_list|)
argument_list|,
operator|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|)
condition|?
literal|" [DISABLED]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_pin_configs
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|hdac_dump_pin_config
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_amp
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cap
parameter_list|,
name|char
modifier|*
name|banner
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     %s amp: 0x%08x\n"
argument_list|,
name|banner
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                 "
literal|"mute=%d step=%d size=%d offset=%d\n"
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|cap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_nodes
parameter_list|(
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
specifier|static
name|char
modifier|*
name|ossname
index|[]
init|=
name|SOUND_DEVICE_NAMES
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Default Parameter\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"-----------------\n"
argument_list|)
expr_stmt|;
name|hdac_dump_audio_formats
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_stream_formats
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"         IN amp: 0x%08x\n"
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|inamp_cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"        OUT amp: 0x%08x\n"
argument_list|,
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|outamp_cap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Ghost widget nid=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"            nid: %d%s\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|)
condition|?
literal|" [DISABLED]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"           Name: %s\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"     Widget cap: 0x%08x\n"
argument_list|,
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|widget_cap
operator|&
literal|0x0ee1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_LR_SWAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" LRSWAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_POWER_CTRL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PWR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DIGITAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_UNSOL_CAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" UNSOL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_PROC_WIDGET
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PROC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_STRIPE
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STRIPE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_STEREO
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STEREO"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    Association: %d (0x%08x)\n"
argument_list|,
name|w
operator|->
name|bindas
argument_list|,
name|w
operator|->
name|bindseqmask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|ossmask
operator|!=
literal|0
operator|||
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"            OSS: %s"
argument_list|,
name|hdac_audio_ctl_ossmixer_mask2allname
argument_list|(
name|w
operator|->
name|ossmask
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|ossname
index|[
name|w
operator|->
name|ossdev
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|hdac_dump_audio_formats
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
argument_list|,
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|hdac_dump_pin
argument_list|(
name|sc
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDAC_INVALID
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"           EAPD: 0x%08x\n"
argument_list|,
name|w
operator|->
name|param
operator|.
name|eapdbtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_OUT_AMP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|!=
literal|0
condition|)
name|hdac_dump_amp
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|param
operator|.
name|outamp_cap
argument_list|,
literal|"Output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_IN_AMP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|!=
literal|0
condition|)
name|hdac_dump_amp
argument_list|(
name|sc
argument_list|,
name|w
operator|->
name|param
operator|.
name|inamp_cap
argument_list|,
literal|" Input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"    connections: %d\n"
argument_list|,
name|w
operator|->
name|nconns
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"          |\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"          + %s<- nid=%d [%s]"
argument_list|,
operator|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
operator|)
condition|?
literal|"[DISABLED] "
else|:
literal|""
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|,
operator|(
name|cw
operator|==
name|NULL
operator|)
condition|?
literal|"GHOST!"
else|:
name|cw
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|" [UNKNOWN]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" [DISABLED]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|w
operator|->
name|selconn
operator|==
name|j
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
name|printf
argument_list|(
literal|" (selected)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_dst_nid
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return;
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%*s"
argument_list|,
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%*s  +<- "
argument_list|,
literal|4
operator|+
operator|(
name|depth
operator|-
literal|1
operator|)
operator|*
literal|7
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nid=%d [%s]"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|ossmask
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" [src: %s]"
argument_list|,
name|hdac_audio_ctl_ossmixer_mask2allname
argument_list|(
name|w
operator|->
name|ossmask
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
operator|||
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%*s  |\n"
argument_list|,
literal|4
operator|+
operator|(
name|depth
operator|)
operator|*
literal|7
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
name|hdac_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_dac
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|play
operator|<
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|play
index|]
operator|.
name|as
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Playback:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdac_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_adc
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|rec
operator|<
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
name|sc
operator|->
name|chans
index|[
name|pdevinfo
operator|->
name|rec
index|]
operator|.
name|as
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Record:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdac_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_mix
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|index
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDA_ADC_MONITOR
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Input Mix:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdac_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_dump_pcmchannels
parameter_list|(
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|pdevinfo
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|nid_t
modifier|*
name|nids
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|pdevinfo
operator|->
name|play
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Playback:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdac_dump_audio_formats
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|supp_stream_formats
argument_list|,
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"            DAC:"
argument_list|)
expr_stmt|;
for|for
control|(
name|nids
operator|=
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|io
init|;
operator|*
name|nids
operator|!=
operator|-
literal|1
condition|;
name|nids
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|nids
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|pdevinfo
operator|->
name|rec
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Record:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdac_dump_audio_formats
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|supp_stream_formats
argument_list|,
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"            ADC:"
argument_list|)
expr_stmt|;
for|for
control|(
name|nids
operator|=
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|io
init|;
operator|*
name|nids
operator|!=
operator|-
literal|1
condition|;
name|nids
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|nids
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdac_release_resources
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|poll_ival
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|hdac_irq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAC_CODEC_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|num_fgs
condition|;
name|j
operator|++
control|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|fgs
index|[
name|j
index|]
operator|.
name|widget
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|fgs
index|[
name|j
index|]
operator|.
name|node_type
operator|==
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|fgs
index|[
name|j
index|]
operator|.
name|function
operator|.
name|audio
operator|.
name|ctl
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|fgs
index|[
name|j
index|]
operator|.
name|function
operator|.
name|audio
operator|.
name|as
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|fgs
index|[
name|j
index|]
operator|.
name|function
operator|.
name|audio
operator|.
name|devs
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|->
name|fgs
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|codecs
index|[
name|i
index|]
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|codecs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pos_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rirb_dma
argument_list|)
expr_stmt|;
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|corb_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|blkcnt
operator|>
literal|0
condition|)
name|hdac_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|bdl_dma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|chans
argument_list|,
name|M_HDAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chan_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|chan_dmat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chan_dmat
operator|=
name|NULL
expr_stmt|;
block|}
name|hdac_mem_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function surely going to make its way into upper level someday. */
end_comment

begin_function
specifier|static
name|void
name|hdac_config_fetch
parameter_list|(
name|struct
name|hdac_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|on
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|,
name|inv
decl_stmt|;
if|if
condition|(
name|on
operator|!=
name|NULL
condition|)
operator|*
name|on
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"config"
argument_list|,
operator|&
name|res
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|res
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|res
argument_list|)
operator|>
literal|0
operator|)
condition|)
return|return;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA Config:"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|res
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|res
index|[
name|i
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|res
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|res
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
return|return;
block|}
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|res
index|[
name|j
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|res
index|[
name|j
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|res
index|[
name|j
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|j
operator|++
expr_stmt|;
name|len
operator|=
name|j
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|res
operator|+
name|i
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|inv
operator|=
literal|2
expr_stmt|;
else|else
name|inv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|len
operator|>
name|inv
operator|&&
name|k
operator|<
name|HDAC_QUIRKS_TAB_LEN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
operator|+
name|i
operator|+
name|inv
argument_list|,
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|,
name|len
operator|-
name|inv
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|len
operator|-
name|inv
operator|!=
name|strlen
argument_list|(
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|)
condition|)
break|break;
name|HDA_BOOTVERBOSE
argument_list|(
argument|printf(
literal|" %s%s"
argument|, (inv !=
literal|0
argument|) ?
literal|"no"
argument|:
literal|""
argument|, 				    hdac_quirks_tab[k].key);
argument_list|)
empty_stmt|;
if|if
condition|(
name|inv
operator|==
literal|0
operator|&&
name|on
operator|!=
name|NULL
condition|)
operator|*
name|on
operator||=
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|inv
operator|!=
literal|0
operator|&&
name|off
operator|!=
name|NULL
condition|)
operator|*
name|off
operator||=
name|hdac_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_hdac_polling
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|sc
operator|->
name|polling
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|sc
operator|->
name|polling
condition|)
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator||=
name|HDAC_INTCTL_GIE
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctl
operator|=
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|)
expr_stmt|;
name|ctl
operator|&=
operator|~
name|HDAC_INTCTL_GIE
expr_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|polling
operator|=
literal|1
expr_stmt|;
name|hdac_poll_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
literal|1
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hdac_polling_interval
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|sc
operator|->
name|poll_ival
operator|*
literal|1000
operator|)
operator|/
name|hz
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|1
condition|)
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|5000
condition|)
name|val
operator|=
literal|5000
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|val
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|1
condition|)
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|>
operator|(
name|hz
operator|*
literal|5
operator|)
condition|)
name|val
operator|=
name|hz
operator|*
literal|5
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|poll_ival
operator|=
name|val
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hdac_pindump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|struct
name|hdac_widget
modifier|*
name|w
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|res
decl_stmt|,
name|pincap
decl_stmt|,
name|delay
decl_stmt|;
name|int
name|codec_index
decl_stmt|,
name|fg_index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|val
decl_stmt|;
name|nid_t
name|cad
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* XXX: Temporary. For debugging. */
if|if
condition|(
name|val
operator|==
literal|100
condition|)
block|{
name|hdac_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|101
condition|)
block|{
name|hdac_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|codec_index
operator|=
literal|0
init|;
name|codec_index
operator|<
name|HDAC_CODEC_MAX
condition|;
name|codec_index
operator|++
control|)
block|{
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|codec_index
index|]
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
continue|continue;
name|cad
operator|=
name|codec
operator|->
name|cad
expr_stmt|;
for|for
control|(
name|fg_index
operator|=
literal|0
init|;
name|fg_index
operator|<
name|codec
operator|->
name|num_fgs
condition|;
name|fg_index
operator|++
control|)
block|{
name|devinfo
operator|=
operator|&
name|codec
operator|->
name|fgs
index|[
name|fg_index
index|]
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|node_type
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
continue|continue;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Dumping AFG cad=%d nid=%d pins:\n"
argument_list|,
name|codec_index
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdac_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|hdac_dump_pin_config
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"       Caps: %2s %3s %2s %4s %4s"
argument_list|,
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"IN"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"OUT"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"HP"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"EAPD"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_VREF_CTRL
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"VREF"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_IMP_SENSE_CAP
argument_list|(
name|pincap
argument_list|)
operator|||
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_PIN_CAP_TRIGGER_REQD
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
name|delay
operator|=
literal|0
expr_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_PIN_SENSE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
do|do
block|{
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0x7fffffff
operator|&&
name|res
operator|!=
literal|0xffffffff
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|delay
operator|<
literal|10000
condition|)
do|;
block|}
else|else
block|{
name|delay
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
name|cad
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" Sense: 0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" delay %dus"
argument_list|,
name|delay
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"NumGPIO=%d NumGPO=%d NumGPI=%d GPIWake=%d GPIUnsol=%d\n"
argument_list|,
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_NUM_GPI
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_GPI_WAKE
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_GPI_UNSOL
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_GPIO_COUNT_NUM_GPI
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" GPI:"
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPI_DATA
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" data=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPI_WAKE_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" wake=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPI_UNSOLICITED_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" unsol=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPI_STICKY_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" sticky=0x%08x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" GPO:"
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPO_DATA
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" data=0x%08x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|gpio
argument_list|)
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"GPIO:"
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_DATA
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" data=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" enable=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_DIRECTION
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" direction=0x%08x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_WAKE_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"      wake=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_UNSOLICITED_ENABLE_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  unsol=0x%08x"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_GET_GPIO_STICKY_MASK
argument_list|(
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|,
name|cad
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    sticky=0x%08x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|hdac_attach2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|quirks_on
decl_stmt|,
name|quirks_off
decl_stmt|;
name|int
name|codec_index
decl_stmt|,
name|fg_index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dmaalloc
init|=
literal|0
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|hdac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|hdac_config_fetch
argument_list|(
name|sc
argument_list|,
operator|&
name|quirks_on
argument_list|,
operator|&
name|quirks_off
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HDA Config: on=0x%08x off=0x%08x\n"
argument|, 		    quirks_on, quirks_off);
argument_list|)
empty_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Remove ourselves from the config hooks */
if|if
condition|(
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|!=
name|NULL
condition|)
block|{
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|intrhook
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhook
operator|.
name|ich_func
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Start the corb and rirb engines */
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Starting CORB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_corb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Starting RIRB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_rirb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Enabling controller interrupt...\n"
argument|);
argument_list|)
empty_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
operator||
name|HDAC_GCTL_UNSOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|HDAC_INTCTL_CIE
operator||
name|HDAC_INTCTL_GIE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
literal|1
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Scanning HDA codecs ...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_scan_codecs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|codec_index
operator|=
literal|0
init|;
name|codec_index
operator|<
name|HDAC_CODEC_MAX
condition|;
name|codec_index
operator|++
control|)
block|{
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|codec_index
index|]
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|fg_index
operator|=
literal|0
init|;
name|fg_index
operator|<
name|codec
operator|->
name|num_fgs
condition|;
name|fg_index
operator|++
control|)
block|{
name|devinfo
operator|=
operator|&
name|codec
operator|->
name|fgs
index|[
name|fg_index
index|]
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"\n"
argument|); 				device_printf(sc->dev,
literal|"Processing %s FG cad=%d nid=%d...\n"
argument|, 				    (devinfo->node_type == HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO) ?
literal|"audio"
argument|: 				    (devinfo->node_type == HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_MODEM) ?
literal|"modem"
argument|:
literal|"unknown"
argument|, 				    devinfo->codec->cad, devinfo->nid);
argument_list|)
empty_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|node_type
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Powering down...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|codec
operator|->
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D3
argument_list|)
argument_list|,
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Powering up...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_powerup
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Parsing audio FG...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Parsing Ctls...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_ctl_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Parsing vendor patch...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_vendor_patch_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator||=
name|quirks_on
expr_stmt|;
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&=
operator|~
name|quirks_off
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling nonaudio...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_nonaudio
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling useless...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_useless
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Patched pins configuration:\n"
argument|); 				hdac_dump_pin_configs(devinfo);
argument_list|)
empty_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Parsing pin associations...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_as_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Building AFG tree...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_build_tree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling unassociated "
literal|"widgets...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_unas
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling nonselected "
literal|"inputs...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_notselected
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling useless...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_useless
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling "
literal|"crossassociatement connections...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_crossas
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Disabling useless...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_disable_useless
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Binding associations to channels...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_bind_as
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Assigning names to signal sources...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_assign_names
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Assigning mixers to the tree...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_assign_mixers
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Preparing pin controls...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_prepare_pin_ctrl
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"AFG commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Ctls commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_ctl_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"HP switch init...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_hp_switch_init
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|quirks
operator|&
name|HDA_QUIRK_DMAPOS
operator|)
operator|&&
name|dmaalloc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hdac_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|pos_dma
argument_list|,
operator|(
name|sc
operator|->
name|num_iss
operator|+
name|sc
operator|->
name|num_oss
operator|+
name|sc
operator|->
name|num_bss
operator|)
operator|*
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Failed to "
literal|"allocate DMA pos buffer "
literal|"(non-fatal)\n"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
name|dmaalloc
operator|=
literal|1
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"Creating PCM devices...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_create_pcms
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (devinfo->function.audio.quirks !=
literal|0
argument|) { 					device_printf(sc->dev,
literal|"FG config/quirks:"
argument|); 					for (i =
literal|0
argument|; i< HDAC_QUIRKS_TAB_LEN; i++) { 						if ((devinfo->function.audio.quirks& 						    hdac_quirks_tab[i].value) == 						    hdac_quirks_tab[i].value) 							printf(
literal|" %s"
argument|, hdac_quirks_tab[i].key); 					} 					printf(
literal|"\n"
argument|); 				}  				device_printf(sc->dev,
literal|"\n"
argument|); 				device_printf(sc->dev,
literal|"+-------------------+\n"
argument|); 				device_printf(sc->dev,
literal|"| DUMPING HDA NODES |\n"
argument|); 				device_printf(sc->dev,
literal|"+-------------------+\n"
argument|); 				hdac_dump_nodes(devinfo);
argument_list|)
empty_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"\n"
argument|); 				device_printf(sc->dev,
literal|"+------------------------+\n"
argument|); 				device_printf(sc->dev,
literal|"| DUMPING HDA AMPLIFIERS |\n"
argument|); 				device_printf(sc->dev,
literal|"+------------------------+\n"
argument|); 				device_printf(sc->dev,
literal|"\n"
argument|); 				i =
literal|0
argument|; 				while ((ctl = hdac_audio_ctl_each(devinfo,&i)) != NULL) { 					device_printf(sc->dev,
literal|"%3d: nid %3d %s (%s) index %d"
argument|, i, 					    (ctl->widget != NULL) ? ctl->widget->nid : -
literal|1
argument|, 					    (ctl->ndir == HDA_CTL_IN)?
literal|"in "
argument|:
literal|"out"
argument|, 					    (ctl->dir == HDA_CTL_IN)?
literal|"in "
argument|:
literal|"out"
argument|, 					    ctl->index); 					if (ctl->childwidget != NULL) 						printf(
literal|" cnid %3d"
argument|, ctl->childwidget->nid); 					else 						printf(
literal|"         "
argument|); 					printf(
literal|" ossmask=0x%08x\n"
argument|, 					    ctl->ossmask); 					device_printf(sc->dev,
literal|"       mute: %d step: %3d size: %3d off: %3d%s\n"
argument|, 					    ctl->mute, ctl->step, ctl->size, ctl->offset, 					    (ctl->enable ==
literal|0
argument|) ?
literal|" [DISABLED]"
argument|:  					    ((ctl->ossmask ==
literal|0
argument|) ?
literal|" [UNUSED]"
argument|:
literal|""
argument|)); 				}
argument_list|)
empty_stmt|;
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(sc->dev,
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SND_DYNSYSCTL
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"polling"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sysctl_hdac_polling
argument_list|,
literal|"I"
argument_list|,
literal|"Enable polling mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"polling_interval"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sysctl_hdac_polling_interval
argument_list|,
literal|"I"
argument_list|,
literal|"Controller/Jack Sense polling interval (1-1000 ms)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pindump"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|sysctl_hdac_pindump
argument_list|,
literal|"I"
argument_list|,
literal|"Dump pin states/data"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_suspend(device_t)  *  * Suspend and power down HDA bus and codecs.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|int
name|codec_index
decl_stmt|,
name|fg_index
decl_stmt|,
name|i
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Suspend...\n"
argument|);
argument_list|)
empty_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Stop streams...\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|HDAC_CHN_RUNNING
condition|)
block|{
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|HDAC_CHN_SUSPEND
expr_stmt|;
name|hdac_channel_stop
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|chans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|codec_index
operator|=
literal|0
init|;
name|codec_index
operator|<
name|HDAC_CODEC_MAX
condition|;
name|codec_index
operator|++
control|)
block|{
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|codec_index
index|]
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|fg_index
operator|=
literal|0
init|;
name|fg_index
operator|<
name|codec
operator|->
name|num_fgs
condition|;
name|fg_index
operator|++
control|)
block|{
name|devinfo
operator|=
operator|&
name|codec
operator|->
name|fgs
index|[
name|fg_index
index|]
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Power down FG"
literal|" cad=%d nid=%d to the D3 state...\n"
argument|, 				    codec->cad, devinfo->nid);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|codec
operator|->
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D3
argument_list|)
argument_list|,
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reset controller...\n"
argument|);
argument_list|)
empty_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|sc
operator|->
name|unsolq_task
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_hda
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Suspend done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_resume(device_t)  *  * Powerup and restore HDA bus and codecs state.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hdac_codec
modifier|*
name|codec
decl_stmt|;
name|struct
name|hdac_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|int
name|codec_index
decl_stmt|,
name|fg_index
decl_stmt|,
name|i
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Resume...\n"
argument|);
argument_list|)
empty_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Quiesce everything */
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reset controller...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the CORB and RIRB */
name|hdac_corb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hdac_rirb_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Start the corb and rirb engines */
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Starting CORB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_corb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Starting RIRB Engine...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_rirb_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Enabling controller interrupt...\n"
argument|);
argument_list|)
empty_stmt|;
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|,
name|HDAC_READ_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_GCTL
argument_list|)
operator||
name|HDAC_GCTL_UNSOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|polling
operator|==
literal|0
condition|)
block|{
name|HDAC_WRITE_4
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|HDAC_INTCTL
argument_list|,
name|HDAC_INTCTL_CIE
operator||
name|HDAC_INTCTL_GIE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|poll_hdac
argument_list|,
literal|1
argument_list|,
name|hdac_poll_callback
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|codec_index
operator|=
literal|0
init|;
name|codec_index
operator|<
name|HDAC_CODEC_MAX
condition|;
name|codec_index
operator|++
control|)
block|{
name|codec
operator|=
name|sc
operator|->
name|codecs
index|[
name|codec_index
index|]
expr_stmt|;
if|if
condition|(
name|codec
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|fg_index
operator|=
literal|0
init|;
name|fg_index
operator|<
name|codec
operator|->
name|num_fgs
condition|;
name|fg_index
operator|++
control|)
block|{
name|devinfo
operator|=
operator|&
name|codec
operator|->
name|fgs
index|[
name|fg_index
index|]
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|node_type
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Power down unsupported non-audio FG"
literal|" cad=%d nid=%d to the D3 state...\n"
argument|, 					    codec->cad, devinfo->nid);
argument_list|)
empty_stmt|;
name|hdac_command
argument_list|(
name|sc
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
name|codec
operator|->
name|cad
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D3
argument_list|)
argument_list|,
name|codec
operator|->
name|cad
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Power up audio FG cad=%d nid=%d...\n"
argument|, 				    devinfo->codec->cad, devinfo->nid);
argument_list|)
empty_stmt|;
name|hdac_powerup
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"AFG commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Ctls commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_audio_ctl_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"HP switch init...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdac_hp_switch_init
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|num_devs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|&
name|devinfo
operator|->
name|function
operator|.
name|audio
operator|.
name|devs
index|[
name|i
index|]
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"OSS mixer reinitialization...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|mixer_reinit
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
block|}
name|hdac_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Start streams...\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|HDAC_CHN_SUSPEND
condition|)
block|{
name|sc
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|HDAC_CHN_SUSPEND
expr_stmt|;
name|hdac_channel_start
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|chans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|hdac_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Resume done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * int hdac_detach(device_t)  *  * Detach and free up resources utilized by the hdac device.  ****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|hdac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|int
name|i
decl_stmt|,
name|devcount
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|devlist
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdac_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdac_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at cad %d nid %d"
argument_list|,
name|pdevinfo
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|,
name|pdevinfo
operator|->
name|devinfo
operator|->
name|nid
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdac_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdac_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdac_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdac_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|hdac_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|hdac_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|hdac_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdac_driver
init|=
block|{
literal|"hdac"
block|,
name|hdac_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdac_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hdac_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hda
argument_list|,
name|pci
argument_list|,
name|hdac_driver
argument_list|,
name|hdac_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_hda
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_hda
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|hdac_pcm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdac_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"HDA %s PCM #%d %s"
argument_list|,
name|hdac_codec_name
argument_list|(
name|pdevinfo
operator|->
name|devinfo
operator|->
name|codec
argument_list|)
argument_list|,
name|pdevinfo
operator|->
name|index
argument_list|,
name|pdevinfo
operator|->
name|digital
condition|?
literal|"Digital"
else|:
literal|"Analog"
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_pcm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdac_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdac_softc
modifier|*
name|sc
init|=
name|pdevinfo
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|sc
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pdevinfo
operator|->
name|chan_size
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
name|HDA_BUFSZ_MIN
argument_list|,
name|HDA_BUFSZ_DEFAULT
argument_list|,
name|HDA_BUFSZ_MAX
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"+--------------------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING PCM Playback/Record Channels |\n"
argument|); 		device_printf(dev,
literal|"+--------------------------------------+\n"
argument|); 		hdac_dump_pcmchannels(pdevinfo); 		device_printf(dev,
literal|"\n"
argument|); 		device_printf(dev,
literal|"+--------------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING Playback/Record Pathes |\n"
argument|); 		device_printf(dev,
literal|"+--------------------------------+\n"
argument|); 		hdac_dump_dac(pdevinfo); 		hdac_dump_adc(pdevinfo); 		hdac_dump_mix(pdevinfo); 		device_printf(dev,
literal|"\n"
argument|); 		device_printf(dev,
literal|"+-------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING Volume Controls |\n"
argument|); 		device_printf(dev,
literal|"+-------------------------+\n"
argument|); 		hdac_dump_ctls(pdevinfo,
literal|"Master Volume"
argument|, SOUND_MASK_VOLUME); 		hdac_dump_ctls(pdevinfo,
literal|"PCM Volume"
argument|, SOUND_MASK_PCM); 		hdac_dump_ctls(pdevinfo,
literal|"CD Volume"
argument|, SOUND_MASK_CD); 		hdac_dump_ctls(pdevinfo,
literal|"Microphone Volume"
argument|, SOUND_MASK_MIC); 		hdac_dump_ctls(pdevinfo,
literal|"Microphone2 Volume"
argument|, SOUND_MASK_MONITOR); 		hdac_dump_ctls(pdevinfo,
literal|"Line-in Volume"
argument|, SOUND_MASK_LINE); 		hdac_dump_ctls(pdevinfo,
literal|"Speaker/Beep Volume"
argument|, SOUND_MASK_SPEAKER); 		hdac_dump_ctls(pdevinfo,
literal|"Recording Level"
argument|, SOUND_MASK_RECLEV); 		hdac_dump_ctls(pdevinfo,
literal|"Input Mix Level"
argument|, SOUND_MASK_IMIX); 		hdac_dump_ctls(pdevinfo, NULL,
literal|0
argument|); 		device_printf(dev,
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"blocksize"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|&=
name|HDA_BLK_ALIGN
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|HDA_BLK_MIN
condition|)
name|i
operator|=
name|HDA_BLK_MIN
expr_stmt|;
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|pdevinfo
operator|->
name|chan_size
operator|/
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pdevinfo
operator|->
name|chan_blkcnt
operator|>>
name|i
condition|)
name|i
operator|++
expr_stmt|;
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|chan_blkcnt
operator|<
name|HDA_BDL_MIN
condition|)
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_MIN
expr_stmt|;
elseif|else
if|if
condition|(
name|pdevinfo
operator|->
name|chan_blkcnt
operator|>
name|HDA_BDL_MAX
condition|)
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_MAX
expr_stmt|;
block|}
else|else
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_DEFAULT
expr_stmt|;
comment|/*  	 * We don't register interrupt handler with snd_setup_intr 	 * in pcm device. Mark pcm device as MPSAFE manually. 	 */
name|pcm_setflags
argument_list|(
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|dev
argument_list|)
operator||
name|SD_F_MPSAFE
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"OSS mixer initialization...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|hdac_audio_ctl_ossmixer_class
argument_list|,
name|pdevinfo
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't register mixer\n"
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Registering PCM channels...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|pdevinfo
argument_list|,
operator|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't register PCM\n"
argument_list|)
expr_stmt|;
name|pdevinfo
operator|->
name|registered
operator|++
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|play
operator|>=
literal|0
condition|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|hdac_channel_class
argument_list|,
name|pdevinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|rec
operator|>=
literal|0
condition|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|hdac_channel_class
argument_list|,
name|pdevinfo
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at cad %d nid %d on %s %s"
argument_list|,
name|pdevinfo
operator|->
name|devinfo
operator|->
name|codec
operator|->
name|cad
argument_list|,
name|pdevinfo
operator|->
name|devinfo
operator|->
name|nid
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_hda
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdac_pcm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdac_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdac_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|registered
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdac_pcm_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdac_pcm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdac_pcm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdac_pcm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdac_pcm_driver
init|=
block|{
literal|"pcm"
block|,
name|hdac_pcm_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hda_pcm
argument_list|,
name|hdac
argument_list|,
name|hdac_pcm_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

