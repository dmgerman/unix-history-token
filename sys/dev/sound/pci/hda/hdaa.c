begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Stephane E. Potvin<sepotvin@videotron.ca>  * Copyright (c) 2006 Ariff Abdullah<ariff@FreeBSD.org>  * Copyright (c) 2008-2012 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Intel High Definition Audio (Audio function) driver for FreeBSD.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdac.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hdaa.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hda/hda_reg.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|hdaa_lock
parameter_list|(
name|devinfo
parameter_list|)
value|snd_mtxlock((devinfo)->lock)
end_define

begin_define
define|#
directive|define
name|hdaa_unlock
parameter_list|(
name|devinfo
parameter_list|)
value|snd_mtxunlock((devinfo)->lock)
end_define

begin_define
define|#
directive|define
name|hdaa_lockassert
parameter_list|(
name|devinfo
parameter_list|)
value|snd_mtxassert((devinfo)->lock)
end_define

begin_define
define|#
directive|define
name|hdaa_lockowned
parameter_list|(
name|devinfo
parameter_list|)
value|mtx_owned((devinfo)->lock)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|hdaa_quirks_tab
index|[]
init|=
block|{
block|{
literal|"softpcmvol"
block|,
name|HDAA_QUIRK_SOFTPCMVOL
block|}
block|,
block|{
literal|"fixedrate"
block|,
name|HDAA_QUIRK_FIXEDRATE
block|}
block|,
block|{
literal|"forcestereo"
block|,
name|HDAA_QUIRK_FORCESTEREO
block|}
block|,
block|{
literal|"eapdinv"
block|,
name|HDAA_QUIRK_EAPDINV
block|}
block|,
block|{
literal|"senseinv"
block|,
name|HDAA_QUIRK_SENSEINV
block|}
block|,
block|{
literal|"ivref50"
block|,
name|HDAA_QUIRK_IVREF50
block|}
block|,
block|{
literal|"ivref80"
block|,
name|HDAA_QUIRK_IVREF80
block|}
block|,
block|{
literal|"ivref100"
block|,
name|HDAA_QUIRK_IVREF100
block|}
block|,
block|{
literal|"ovref50"
block|,
name|HDAA_QUIRK_OVREF50
block|}
block|,
block|{
literal|"ovref80"
block|,
name|HDAA_QUIRK_OVREF80
block|}
block|,
block|{
literal|"ovref100"
block|,
name|HDAA_QUIRK_OVREF100
block|}
block|,
block|{
literal|"ivref"
block|,
name|HDAA_QUIRK_IVREF
block|}
block|,
block|{
literal|"ovref"
block|,
name|HDAA_QUIRK_OVREF
block|}
block|,
block|{
literal|"vref"
block|,
name|HDAA_QUIRK_VREF
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|HDAA_QUIRKS_TAB_LEN
define|\
value|(sizeof(hdaa_quirks_tab) / sizeof(hdaa_quirks_tab[0]))
end_define

begin_define
define|#
directive|define
name|HDA_PARSE_MAXDEPTH
value|10
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HDAA
argument_list|,
literal|"hdaa"
argument_list|,
literal|"HDA Audio"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_COLORS
index|[
literal|16
index|]
init|=
block|{
literal|"Unknown"
block|,
literal|"Black"
block|,
literal|"Grey"
block|,
literal|"Blue"
block|,
literal|"Green"
block|,
literal|"Red"
block|,
literal|"Orange"
block|,
literal|"Yellow"
block|,
literal|"Purple"
block|,
literal|"Pink"
block|,
literal|"Res.A"
block|,
literal|"Res.B"
block|,
literal|"Res.C"
block|,
literal|"Res.D"
block|,
literal|"White"
block|,
literal|"Other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_DEVS
index|[
literal|16
index|]
init|=
block|{
literal|"Line-out"
block|,
literal|"Speaker"
block|,
literal|"Headphones"
block|,
literal|"CD"
block|,
literal|"SPDIF-out"
block|,
literal|"Digital-out"
block|,
literal|"Modem-line"
block|,
literal|"Modem-handset"
block|,
literal|"Line-in"
block|,
literal|"AUX"
block|,
literal|"Mic"
block|,
literal|"Telephony"
block|,
literal|"SPDIF-in"
block|,
literal|"Digital-in"
block|,
literal|"Res.E"
block|,
literal|"Other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_CONNS
index|[
literal|4
index|]
init|=
block|{
literal|"Jack"
block|,
literal|"None"
block|,
literal|"Fixed"
block|,
literal|"Both"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_CONNECTORS
index|[
literal|16
index|]
init|=
block|{
literal|"Unknown"
block|,
literal|"1/8"
block|,
literal|"1/4"
block|,
literal|"ATAPI"
block|,
literal|"RCA"
block|,
literal|"Optical"
block|,
literal|"Digital"
block|,
literal|"Analog"
block|,
literal|"DIN"
block|,
literal|"XLR"
block|,
literal|"RJ-11"
block|,
literal|"Combo"
block|,
literal|"0xc"
block|,
literal|"0xd"
block|,
literal|"0xe"
block|,
literal|"Other"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_LOCS
index|[
literal|64
index|]
init|=
block|{
literal|"0x00"
block|,
literal|"Rear"
block|,
literal|"Front"
block|,
literal|"Left"
block|,
literal|"Right"
block|,
literal|"Top"
block|,
literal|"Bottom"
block|,
literal|"Rear-panel"
block|,
literal|"Drive-bay"
block|,
literal|"0x09"
block|,
literal|"0x0a"
block|,
literal|"0x0b"
block|,
literal|"0x0c"
block|,
literal|"0x0d"
block|,
literal|"0x0e"
block|,
literal|"0x0f"
block|,
literal|"Internal"
block|,
literal|"0x11"
block|,
literal|"0x12"
block|,
literal|"0x13"
block|,
literal|"0x14"
block|,
literal|"0x15"
block|,
literal|"0x16"
block|,
literal|"Riser"
block|,
literal|"0x18"
block|,
literal|"Onboard"
block|,
literal|"0x1a"
block|,
literal|"0x1b"
block|,
literal|"0x1c"
block|,
literal|"0x1d"
block|,
literal|"0x1e"
block|,
literal|"0x1f"
block|,
literal|"External"
block|,
literal|"Ext-Rear"
block|,
literal|"Ext-Front"
block|,
literal|"Ext-Left"
block|,
literal|"Ext-Right"
block|,
literal|"Ext-Top"
block|,
literal|"Ext-Bottom"
block|,
literal|"0x07"
block|,
literal|"0x28"
block|,
literal|"0x29"
block|,
literal|"0x2a"
block|,
literal|"0x2b"
block|,
literal|"0x2c"
block|,
literal|"0x2d"
block|,
literal|"0x2e"
block|,
literal|"0x2f"
block|,
literal|"Other"
block|,
literal|"0x31"
block|,
literal|"0x32"
block|,
literal|"0x33"
block|,
literal|"0x34"
block|,
literal|"0x35"
block|,
literal|"Other-Bott"
block|,
literal|"Lid-In"
block|,
literal|"Lid-Out"
block|,
literal|"0x39"
block|,
literal|"0x3a"
block|,
literal|"0x3b"
block|,
literal|"0x3c"
block|,
literal|"0x3d"
block|,
literal|"0x3e"
block|,
literal|"0x3f"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_GPIO_ACTIONS
index|[
literal|8
index|]
init|=
block|{
literal|"keep"
block|,
literal|"set"
block|,
literal|"clear"
block|,
literal|"disable"
block|,
literal|"input"
block|,
literal|"0x05"
block|,
literal|"0x06"
block|,
literal|"0x07"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|HDA_HDMI_CODING_TYPES
index|[
literal|18
index|]
init|=
block|{
literal|"undefined"
block|,
literal|"LPCM"
block|,
literal|"AC-3"
block|,
literal|"MPEG1"
block|,
literal|"MP3"
block|,
literal|"MPEG2"
block|,
literal|"AAC-LC"
block|,
literal|"DTS"
block|,
literal|"ATRAC"
block|,
literal|"DSD"
block|,
literal|"E-AC-3"
block|,
literal|"DTS-HD"
block|,
literal|"MLP"
block|,
literal|"DST"
block|,
literal|"WMAPro"
block|,
literal|"HE-AAC"
block|,
literal|"HE-AACv2"
block|,
literal|"MPEG-Surround"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|hdaa_fmt
index|[]
init|=
block|{
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|hdaa_caps
init|=
block|{
literal|48000
block|,
literal|48000
block|,
name|hdaa_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|rate
decl_stmt|;
name|int
name|valid
decl_stmt|;
name|uint16_t
name|base
decl_stmt|;
name|uint16_t
name|mul
decl_stmt|;
name|uint16_t
name|div
decl_stmt|;
block|}
name|hda_rate_tab
index|[]
init|=
block|{
block|{
literal|8000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0500
block|}
block|,
comment|/* (48000 * 1) / 6 */
block|{
literal|9600
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 1) / 5 */
block|{
literal|12000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
comment|/* (48000 * 1) / 4 */
block|{
literal|16000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 1) / 3 */
block|{
literal|18000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0700
block|}
block|,
comment|/* (48000 * 3) / 8 */
block|{
literal|19200
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 2) / 5 */
block|{
literal|24000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0100
block|}
block|,
comment|/* (48000 * 1) / 2 */
block|{
literal|28800
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 3) / 5 */
block|{
literal|32000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 2) / 3 */
block|{
literal|36000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0300
block|}
block|,
comment|/* (48000 * 3) / 4 */
block|{
literal|38400
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0400
block|}
block|,
comment|/* (48000 * 4) / 5 */
block|{
literal|48000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 1) / 1 */
block|{
literal|64000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0200
block|}
block|,
comment|/* (48000 * 4) / 3 */
block|{
literal|72000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0100
block|}
block|,
comment|/* (48000 * 3) / 2 */
block|{
literal|96000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x0800
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 2) / 1 */
block|{
literal|144000
block|,
literal|0
block|,
literal|0x0000
block|,
literal|0x1000
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 3) / 1 */
block|{
literal|192000
block|,
literal|1
block|,
literal|0x0000
block|,
literal|0x1800
block|,
literal|0x0000
block|}
block|,
comment|/* (48000 * 4) / 1 */
block|{
literal|8820
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 1) / 5 */
block|{
literal|11025
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
comment|/* (44100 * 1) / 4 */
block|{
literal|12600
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 2) / 7 */
block|{
literal|14700
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 1) / 3 */
block|{
literal|17640
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 2) / 5 */
block|{
literal|18900
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 3) / 7 */
block|{
literal|22050
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0100
block|}
block|,
comment|/* (44100 * 1) / 2 */
block|{
literal|25200
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0600
block|}
block|,
comment|/* (44100 * 4) / 7 */
block|{
literal|26460
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 3) / 5 */
block|{
literal|29400
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 2) / 3 */
block|{
literal|33075
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0300
block|}
block|,
comment|/* (44100 * 3) / 4 */
block|{
literal|35280
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0400
block|}
block|,
comment|/* (44100 * 4) / 5 */
block|{
literal|44100
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 1) / 1 */
block|{
literal|58800
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0200
block|}
block|,
comment|/* (44100 * 4) / 3 */
block|{
literal|66150
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0100
block|}
block|,
comment|/* (44100 * 3) / 2 */
block|{
literal|88200
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x0800
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 2) / 1 */
block|{
literal|132300
block|,
literal|0
block|,
literal|0x4000
block|,
literal|0x1000
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 3) / 1 */
block|{
literal|176400
block|,
literal|1
block|,
literal|0x4000
block|,
literal|0x1800
block|,
literal|0x0000
block|}
block|,
comment|/* (44100 * 4) / 1 */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HDA_RATE_TAB_LEN
value|(sizeof(hda_rate_tab) / sizeof(hda_rate_tab[0]))
end_define

begin_decl_stmt
specifier|const
specifier|static
name|char
modifier|*
name|ossnames
index|[]
init|=
name|SOUND_DEVICE_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  * Function prototypes  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|hdaa_pcmchannel_setup
parameter_list|(
name|struct
name|hdaa_chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdaa_widget_connection_select
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdaa_audio_ctl_amp_set
parameter_list|(
name|struct
name|hdaa_audio_ctl
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hdaa_audio_ctl
modifier|*
name|hdaa_audio_ctl_amp_get
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdaa_audio_ctl_amp_set_internal
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
parameter_list|,
name|nid_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hdaa_dump_pin_config
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|,
name|uint32_t
name|conf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|hdaa_audio_ctl_ossmixer_mask2allname
parameter_list|(
name|uint32_t
name|mask
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|buf
argument_list|,
name|ossnames
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdaa_audio_ctl
modifier|*
name|hdaa_audio_ctl_each
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|index
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|ctl
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|ctlcnt
operator|<
literal|1
operator|||
operator|*
name|index
operator|<
literal|0
operator|||
operator|*
name|index
operator|>=
name|devinfo
operator|->
name|ctlcnt
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|devinfo
operator|->
name|ctl
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hdaa_audio_ctl
modifier|*
name|hdaa_audio_ctl_amp_get
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|ctl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdaa_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|nid
operator|!=
name|nid
condition|)
continue|continue;
if|if
condition|(
name|dir
operator|&&
name|ctl
operator|->
name|ndir
operator|!=
name|dir
condition|)
continue|continue;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|ndir
operator|==
name|HDAA_CTL_IN
operator|&&
name|ctl
operator|->
name|dir
operator|==
name|ctl
operator|->
name|ndir
operator|&&
name|ctl
operator|->
name|index
operator|!=
name|index
condition|)
continue|continue;
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|cnt
operator|||
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|ctl
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Headphones redirection change handler.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_hpredir_handler
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|w
operator|->
name|bindas
index|]
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w1
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|j
decl_stmt|,
name|connected
init|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|connected
decl_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf((as->pdevinfo&& as->pdevinfo->dev) ? 		    as->pdevinfo->dev : devinfo->dev,
literal|"Redirect output to: %s\n"
argument|, 		    connected ?
literal|"headphones"
argument|:
literal|"main"
argument|);
argument_list|)
empty_stmt|;
comment|/* (Un)Mute headphone pin. */
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
operator|&&
name|ctl
operator|->
name|mute
condition|)
block|{
comment|/* If pin has muter - use it. */
name|val
operator|=
name|connected
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|ctl
operator|->
name|forcemute
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
name|val
expr_stmt|;
name|hdaa_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDAA_AMP_MUTE_DEFAULT
argument_list|,
name|HDAA_AMP_VOL_DEFAULT
argument_list|,
name|HDAA_AMP_VOL_DEFAULT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If there is no muter - disable pin output. */
if|if
condition|(
name|connected
condition|)
name|val
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
else|else
name|val
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|val
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* (Un)Mute other pins. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|15
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|j
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|as
operator|->
name|pins
index|[
name|j
index|]
argument_list|,
name|HDAA_CTL_IN
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|NULL
operator|&&
name|ctl
operator|->
name|mute
condition|)
block|{
comment|/* If pin has muter - use it. */
name|val
operator|=
name|connected
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|ctl
operator|->
name|forcemute
condition|)
continue|continue;
name|ctl
operator|->
name|forcemute
operator|=
name|val
expr_stmt|;
name|hdaa_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDAA_AMP_MUTE_DEFAULT
argument_list|,
name|HDAA_AMP_VOL_DEFAULT
argument_list|,
name|HDAA_AMP_VOL_DEFAULT
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If there is no muter - disable pin output. */
name|w1
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
operator|->
name|pins
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|connected
condition|)
name|val
operator|=
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
else|else
name|val
operator|=
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
condition|)
block|{
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|val
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
literal|0
argument_list|,
name|w1
operator|->
name|nid
argument_list|,
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Recording source change handler.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_autorecsrc_handler
parameter_list|(
name|struct
name|hdaa_audio_as
modifier|*
name|as
parameter_list|,
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|as
operator|->
name|pdevinfo
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|,
name|fullmask
decl_stmt|,
name|prio
decl_stmt|,
name|bestprio
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|as
operator|->
name|mixed
operator|||
name|pdevinfo
operator|==
name|NULL
operator|||
name|pdevinfo
operator|->
name|mixer
operator|==
name|NULL
condition|)
return|return;
comment|/* Don't touch anything if we asked not to. */
if|if
condition|(
name|pdevinfo
operator|->
name|autorecsrc
operator|==
literal|0
operator|||
operator|(
name|pdevinfo
operator|->
name|autorecsrc
operator|==
literal|1
operator|&&
name|w
operator|!=
name|NULL
operator|)
condition|)
return|return;
comment|/* Don't touch anything if "mix" or "speaker" selected. */
if|if
condition|(
name|pdevinfo
operator|->
name|recsrc
operator|&
operator|(
name|SOUND_MASK_IMIX
operator||
name|SOUND_MASK_SPEAKER
operator|)
condition|)
return|return;
comment|/* Don't touch anything if several selected. */
if|if
condition|(
name|ffs
argument_list|(
name|pdevinfo
operator|->
name|recsrc
argument_list|)
operator|!=
name|fls
argument_list|(
name|pdevinfo
operator|->
name|recsrc
argument_list|)
condition|)
return|return;
name|devinfo
operator|=
name|pdevinfo
operator|->
name|devinfo
expr_stmt|;
name|mask
operator|=
name|fullmask
operator|=
literal|0
expr_stmt|;
name|bestprio
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|w1
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w1
operator|==
name|NULL
operator|||
name|w1
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|connected
operator|==
literal|0
condition|)
continue|continue;
name|prio
operator|=
operator|(
name|w1
operator|->
name|wclass
operator|.
name|pin
operator|.
name|connected
operator|==
literal|1
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|prio
operator|<
name|bestprio
condition|)
continue|continue;
if|if
condition|(
name|prio
operator|>
name|bestprio
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
name|bestprio
operator|=
name|prio
expr_stmt|;
block|}
name|mask
operator||=
operator|(
literal|1
operator|<<
name|w1
operator|->
name|ossdev
operator|)
expr_stmt|;
name|fullmask
operator||=
operator|(
literal|1
operator|<<
name|w1
operator|->
name|ossdev
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return;
comment|/* Prefer newly connected input. */
if|if
condition|(
name|w
operator|!=
name|NULL
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|w
operator|->
name|ossdev
operator|)
operator|)
condition|)
name|mask
operator|=
operator|(
literal|1
operator|<<
name|w
operator|->
name|ossdev
operator|)
expr_stmt|;
comment|/* Prefer previously selected input */
if|if
condition|(
name|mask
operator|&
name|pdevinfo
operator|->
name|recsrc
condition|)
name|mask
operator|&=
name|pdevinfo
operator|->
name|recsrc
expr_stmt|;
comment|/* Prefer mic. */
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_MIC
condition|)
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
comment|/* Prefer monitor (2nd mic). */
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_MONITOR
condition|)
name|mask
operator|=
name|SOUND_MASK_MONITOR
expr_stmt|;
comment|/* Just take first one. */
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|mask
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|hdaa_audio_ctl_ossmixer_mask2allname(mask, buf, sizeof(buf)); 		device_printf(pdevinfo->dev,
literal|"Automatically set rec source to: %s\n"
argument|, buf);
argument_list|)
empty_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|mix_setrecsrc
argument_list|(
name|pdevinfo
operator|->
name|mixer
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jack presence detection event handler.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_presence_handler
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|connected
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
return|return;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
return|return;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|connected
operator|=
operator|(
name|res
operator|&
name|HDA_CMD_GET_PIN_SENSE_PRESENCE_DETECT
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_SENSEINV
condition|)
name|connected
operator|=
operator|!
name|connected
expr_stmt|;
if|if
condition|(
name|connected
operator|==
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|connected
condition|)
return|return;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|connected
operator|=
name|connected
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Pin sense: nid=%d sence=0x%08x (%sconnected)\n"
argument|, 		    w->nid, res, !w->wclass.pin.connected ?
literal|"dis"
argument|:
literal|""
argument|);
argument_list|)
empty_stmt|;
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|w
operator|->
name|bindas
index|]
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|hpredir
operator|>=
literal|0
operator|&&
name|as
operator|->
name|pins
index|[
literal|15
index|]
operator|==
name|w
operator|->
name|nid
condition|)
name|hdaa_hpredir_handler
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
name|hdaa_autorecsrc_handler
argument_list|(
name|as
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback for poll based presence detection.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_jack_poll_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|arg
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|poll_ival
operator|==
literal|0
condition|)
block|{
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|as
index|[
name|i
index|]
operator|.
name|hpredir
operator|<
literal|0
condition|)
continue|continue;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|devinfo
operator|->
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|hdaa_presence_handler
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|,
name|devinfo
operator|->
name|poll_ival
argument_list|,
name|hdaa_jack_poll_callback
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_eld_dump
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w
operator|->
name|devinfo
decl_stmt|;
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|uint8_t
modifier|*
name|sad
decl_stmt|;
name|int
name|len
decl_stmt|,
name|mnl
decl_stmt|,
name|i
decl_stmt|,
name|sadc
decl_stmt|,
name|fmt
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|eld
operator|==
name|NULL
operator|||
name|w
operator|->
name|eld_len
operator|<
literal|4
condition|)
return|return;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: ELD_Ver=%u Baseline_ELD_Len=%u\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|0
index|]
operator|>>
literal|3
argument_list|,
name|w
operator|->
name|eld
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|eld
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|!=
literal|0x02
condition|)
return|return;
name|len
operator|=
name|min
argument_list|(
name|w
operator|->
name|eld_len
argument_list|,
operator|(
name|u_int
operator|)
name|w
operator|->
name|eld
index|[
literal|2
index|]
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mnl
operator|=
name|w
operator|->
name|eld
index|[
literal|4
index|]
operator|&
literal|0x1f
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: CEA_EDID_Ver=%u MNL=%u\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|4
index|]
operator|>>
literal|5
argument_list|,
name|mnl
argument_list|)
expr_stmt|;
name|sadc
operator|=
name|w
operator|->
name|eld
index|[
literal|5
index|]
operator|>>
literal|4
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: SAD_Count=%u Conn_Type=%u S_AI=%u HDCP=%u\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|sadc
argument_list|,
operator|(
name|w
operator|->
name|eld
index|[
literal|5
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x3
argument_list|,
operator|(
name|w
operator|->
name|eld
index|[
literal|5
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x1
argument_list|,
name|w
operator|->
name|eld
index|[
literal|5
index|]
operator|&
literal|0x1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: Aud_Synch_Delay=%ums\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|6
index|]
operator|*
literal|2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: Channels=0x%b\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|7
index|]
argument_list|,
literal|"\020\07RLRC\06FLRC\05RC\04RLR\03FC\02LFE\01FLR"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: Port_ID=0x%02x%02x%02x%02x%02x%02x%02x%02x\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|8
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|9
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|10
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|11
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|12
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|13
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|14
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: Manufacturer_Name=0x%02x%02x\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|16
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: Product_Code=0x%02x%02x\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|eld
index|[
literal|18
index|]
argument_list|,
name|w
operator|->
name|eld
index|[
literal|19
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: Monitor_Name_String='%.*s'\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|mnl
argument_list|,
operator|&
name|w
operator|->
name|eld
index|[
literal|20
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sadc
condition|;
name|i
operator|++
control|)
block|{
name|sad
operator|=
operator|&
name|w
operator|->
name|eld
index|[
literal|20
operator|+
name|mnl
operator|+
name|i
operator|*
literal|3
index|]
expr_stmt|;
name|fmt
operator|=
operator|(
name|sad
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|HDA_HDMI_CODING_TYPE_REF_CTX
condition|)
block|{
name|fmt
operator|=
operator|(
name|sad
index|[
literal|2
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|fmt
operator|<
literal|1
operator|||
name|fmt
operator|>
literal|3
condition|)
name|fmt
operator|=
literal|0
expr_stmt|;
else|else
name|fmt
operator|+=
literal|14
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ELD nid=%d: %s %dch freqs=0x%b"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_HDMI_CODING_TYPES
index|[
name|fmt
index|]
argument_list|,
operator|(
name|sad
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|+
literal|1
argument_list|,
name|sad
index|[
literal|1
index|]
argument_list|,
literal|"\020\007192\006176\00596\00488\00348\00244\00132"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|HDA_HDMI_CODING_TYPE_LPCM
case|:
name|printf
argument_list|(
literal|" sizes=0x%b"
argument_list|,
name|sad
index|[
literal|2
index|]
operator|&
literal|0x07
argument_list|,
literal|"\020\00324\00220\00116"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDA_HDMI_CODING_TYPE_AC3
case|:
case|case
name|HDA_HDMI_CODING_TYPE_MPEG1
case|:
case|case
name|HDA_HDMI_CODING_TYPE_MP3
case|:
case|case
name|HDA_HDMI_CODING_TYPE_MPEG2
case|:
case|case
name|HDA_HDMI_CODING_TYPE_AACLC
case|:
case|case
name|HDA_HDMI_CODING_TYPE_DTS
case|:
case|case
name|HDA_HDMI_CODING_TYPE_ATRAC
case|:
name|printf
argument_list|(
literal|" max_bitrate=%d"
argument_list|,
name|sad
index|[
literal|2
index|]
operator|*
literal|8000
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDA_HDMI_CODING_TYPE_WMAPRO
case|:
name|printf
argument_list|(
literal|" profile=%d"
argument_list|,
name|sad
index|[
literal|2
index|]
operator|&
literal|0x07
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_eld_handler
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w
operator|->
name|devinfo
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
return|return;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
return|return;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|->
name|eld
operator|!=
literal|0
operator|)
operator|==
operator|(
operator|(
name|res
operator|&
name|HDA_CMD_GET_PIN_SENSE_ELD_VALID
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|w
operator|->
name|eld
operator|!=
name|NULL
condition|)
block|{
name|w
operator|->
name|eld_len
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|eld
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
name|w
operator|->
name|eld
operator|=
name|NULL
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Pin sense: nid=%d sence=0x%08x "
literal|"(%sconnected, ELD %svalid)\n"
argument|, 		    w->nid, res, 		    (res& HDA_CMD_GET_PIN_SENSE_PRESENCE_DETECT) ?
literal|""
argument|:
literal|"dis"
argument|, 		    (res& HDA_CMD_GET_PIN_SENSE_ELD_VALID) ?
literal|""
argument|:
literal|"in"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|res
operator|&
name|HDA_CMD_GET_PIN_SENSE_ELD_VALID
operator|)
operator|==
literal|0
condition|)
return|return;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_HDMI_DIP_SIZE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0x08
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|HDA_INVALID
condition|)
return|return;
name|w
operator|->
name|eld_len
operator|=
name|res
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|eld_len
operator|!=
literal|0
condition|)
name|w
operator|->
name|eld
operator|=
name|malloc
argument_list|(
name|w
operator|->
name|eld_len
argument_list|,
name|M_HDAA
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|eld
operator|==
name|NULL
condition|)
block|{
name|w
operator|->
name|eld_len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|eld_len
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_HDMI_ELDD
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|&
literal|0x80000000
condition|)
name|w
operator|->
name|eld
index|[
name|i
index|]
operator|=
name|res
operator|&
literal|0xff
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|hdaa_eld_dump(w);
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pin sense initializer.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_sense_init
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|poll
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_UNSOL_CAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|unsol
operator|<
literal|0
condition|)
name|w
operator|->
name|unsol
operator|=
name|HDAC_UNSOL_ALLOC
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|w
operator|->
name|nid
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE_ENABLE
operator||
name|w
operator|->
name|unsol
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|w
operator|->
name|bindas
index|]
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|hpredir
operator|>=
literal|0
operator|&&
name|as
operator|->
name|pins
index|[
literal|15
index|]
operator|==
name|w
operator|->
name|nid
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"No presence detection support at nid %d\n"
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|w
operator|->
name|unsol
operator|<
literal|0
condition|)
name|poll
operator|=
literal|1
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Headphones redirection for "
literal|"association %d nid=%d using %s.\n"
argument|, 					    w->bindas, w->nid, 					    (poll !=
literal|0
argument|) ?
literal|"polling"
argument|:
literal|"unsolicited responses"
argument|);
argument_list|)
empty_stmt|;
block|}
empty_stmt|;
block|}
name|hdaa_presence_handler
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HDA_PARAM_PIN_CAP_DP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|&&
operator|!
name|HDA_PARAM_PIN_CAP_HDMI
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
continue|continue;
name|hdaa_eld_handler
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|poll
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|,
literal|1
argument_list|,
name|hdaa_jack_poll_callback
argument_list|,
name|devinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_sense_deinit
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|unsol
operator|<
literal|0
condition|)
continue|continue;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_UNSOLICITED_RESPONSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|HDAC_UNSOL_FREE
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|w
operator|->
name|unsol
argument_list|)
expr_stmt|;
name|w
operator|->
name|unsol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint32_t
name|hdaa_widget_pin_patch
parameter_list|(
name|uint32_t
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|rest
decl_stmt|,
modifier|*
name|bad
decl_stmt|;
name|int
name|ival
decl_stmt|,
name|i
decl_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|strsep
argument_list|(
operator|&
name|rest
argument_list|,
literal|"="
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|strsep
argument_list|(
operator|&
name|rest
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
break|break;
name|ival
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
operator|&
name|bad
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"seq"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"as"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"misc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_MISC_MASK
expr_stmt|;
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_MISC_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_MISC_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"color"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_COLOR_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_COLOR_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_COLOR_MASK
operator|)
expr_stmt|;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_COLORS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_COLOR_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"ctype"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_MASK
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_CONNECTORS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"device"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_DEVS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"loc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_LOCATION_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_LOCATION_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_LOCATION_MASK
operator|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_LOCS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_LOCATION_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"conn"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|&=
operator|~
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
expr_stmt|;
if|if
condition|(
name|bad
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
operator|(
name|ival
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_SHIFT
operator|)
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_CONNS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator||=
operator|(
name|i
operator|<<
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_SHIFT
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|hdaa_gpio_patch
parameter_list|(
name|uint32_t
name|gpio
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|rest
decl_stmt|;
name|int
name|ikey
decl_stmt|,
name|i
decl_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|strsep
argument_list|(
operator|&
name|rest
argument_list|,
literal|"="
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|strsep
argument_list|(
operator|&
name|rest
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
break|break;
name|ikey
operator|=
name|strtol
argument_list|(
name|key
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ikey
operator|<
literal|0
operator|||
name|ikey
operator|>
literal|7
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|HDA_GPIO_ACTIONS
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gpio
operator|&=
operator|~
name|HDAA_GPIO_MASK
argument_list|(
name|ikey
argument_list|)
expr_stmt|;
name|gpio
operator||=
name|i
operator|<<
name|HDAA_GPIO_SHIFT
argument_list|(
name|ikey
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|gpio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_local_patch_pin
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|w
operator|->
name|devinfo
operator|->
name|dev
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|config
decl_stmt|,
name|orig
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|config
operator|=
name|orig
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cad%u.nid%u.config"
argument_list|,
name|hda_get_codec_id
argument_list|(
name|dev
argument_list|)
argument_list|,
name|w
operator|->
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|=
name|strtol
argument_list|(
name|res
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|hdaa_widget_pin_patch
argument_list|(
name|config
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"nid%u.config"
argument_list|,
name|w
operator|->
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|=
name|strtol
argument_list|(
name|res
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|=
name|hdaa_widget_pin_patch
argument_list|(
name|config
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (config != orig) 			device_printf(w->devinfo->dev,
literal|"Patching pin config nid=%u 0x%08x -> 0x%08x\n"
argument|, 			    w->nid, orig, config);
argument_list|)
empty_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|newconf
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|=
name|config
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|conf
decl_stmt|;
name|conf
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"0x%08x as=%d seq=%d "
literal|"device=%s conn=%s ctype=%s loc=%s color=%s misc=%d"
argument_list|,
name|conf
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_DEVS
index|[
name|HDA_CONFIG_DEFAULTCONF_DEVICE
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONNS
index|[
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONNECTORS
index|[
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_LOCS
index|[
name|HDA_CONFIG_DEFAULTCONF_LOCATION
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_COLORS
index|[
name|HDA_CONFIG_DEFAULTCONF_COLOR
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|conf
operator|=
name|strtol
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|conf
operator|=
name|hdaa_widget_pin_patch
argument_list|(
name|conf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|conf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_config_fetch
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint32_t
modifier|*
name|on
parameter_list|,
name|uint32_t
modifier|*
name|off
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|,
name|inv
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|str
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|str
index|[
name|i
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|str
index|[
name|j
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|str
index|[
name|j
index|]
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|str
index|[
name|j
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|j
operator|++
expr_stmt|;
name|len
operator|=
name|j
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|strncmp
argument_list|(
name|str
operator|+
name|i
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|inv
operator|=
literal|2
expr_stmt|;
else|else
name|inv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|len
operator|>
name|inv
operator|&&
name|k
operator|<
name|HDAA_QUIRKS_TAB_LEN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|str
operator|+
name|i
operator|+
name|inv
argument_list|,
name|hdaa_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|,
name|len
operator|-
name|inv
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|len
operator|-
name|inv
operator|!=
name|strlen
argument_list|(
name|hdaa_quirks_tab
index|[
name|k
index|]
operator|.
name|key
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inv
operator|==
literal|0
condition|)
block|{
operator|*
name|on
operator||=
name|hdaa_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|off
operator|&=
operator|~
name|hdaa_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|off
operator||=
name|hdaa_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|on
operator|&=
operator|~
name|hdaa_quirks_tab
index|[
name|k
index|]
operator|.
name|value
expr_stmt|;
block|}
break|break;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_quirks
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|quirks
decl_stmt|,
name|quirks_off
decl_stmt|;
name|quirks
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDAA_QUIRKS_TAB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|quirks
operator|&
name|hdaa_quirks_tab
index|[
name|i
index|]
operator|.
name|value
operator|)
operator|!=
literal|0
condition|)
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s%s"
argument_list|,
name|n
operator|!=
literal|0
condition|?
literal|","
else|:
literal|""
argument_list|,
name|hdaa_quirks_tab
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|quirks
operator|=
name|strtol
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
name|quirks
operator|=
literal|0
expr_stmt|;
name|hdaa_config_fetch
argument_list|(
name|buf
argument_list|,
operator|&
name|quirks
argument_list|,
operator|&
name|quirks_off
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|=
name|quirks
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_local_patch
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|quirks_on
init|=
literal|0
decl_stmt|,
name|quirks_off
init|=
literal|0
decl_stmt|,
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|hdaa_local_patch_pin
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
literal|"config"
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|res
argument_list|)
operator|>
literal|0
condition|)
name|hdaa_config_fetch
argument_list|(
name|res
argument_list|,
operator|&
name|quirks_on
argument_list|,
operator|&
name|quirks_off
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|quirks
operator||=
name|quirks_on
expr_stmt|;
name|devinfo
operator|->
name|quirks
operator|&=
operator|~
name|quirks_off
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|->
name|newquirks
operator|==
operator|-
literal|1
condition|)
name|devinfo
operator|->
name|newquirks
operator|=
name|devinfo
operator|->
name|quirks
expr_stmt|;
else|else
name|devinfo
operator|->
name|quirks
operator|=
name|devinfo
operator|->
name|newquirks
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Config options: 0x%08x\n"
argument|, devinfo->quirks);
argument_list|)
empty_stmt|;
if|if
condition|(
name|resource_string_value
argument_list|(
name|device_get_name
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
literal|"gpio_config"
argument_list|,
operator|&
name|res
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|res
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|devinfo
operator|->
name|gpio
operator|=
name|strtol
argument_list|(
name|res
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|devinfo
operator|->
name|gpio
operator|=
name|hdaa_gpio_patch
argument_list|(
name|devinfo
operator|->
name|gpio
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|devinfo
operator|->
name|newgpio
operator|==
operator|-
literal|1
condition|)
name|devinfo
operator|->
name|newgpio
operator|=
name|devinfo
operator|->
name|gpio
expr_stmt|;
else|else
name|devinfo
operator|->
name|gpio
operator|=
name|devinfo
operator|->
name|newgpio
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|newgpo
operator|==
operator|-
literal|1
condition|)
name|devinfo
operator|->
name|newgpo
operator|=
name|devinfo
operator|->
name|gpo
expr_stmt|;
else|else
name|devinfo
operator|->
name|gpo
operator|=
name|devinfo
operator|->
name|newgpo
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"GPIO config options:"
argument|); 		for (i =
literal|0
argument|; i<
literal|7
argument|; i++) { 			x = (devinfo->gpio& HDAA_GPIO_MASK(i))>> HDAA_GPIO_SHIFT(i); 			if (x !=
literal|0
argument|) 				printf(
literal|" %d=%s"
argument|, i, HDA_GPIO_ACTIONS[x]); 		} 		printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_widget_connection_parse
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max
decl_stmt|,
name|ents
decl_stmt|,
name|entnum
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|nid_t
name|cnid
decl_stmt|,
name|addcnid
decl_stmt|,
name|prevcnid
decl_stmt|;
name|w
operator|->
name|nconns
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_CONN_LIST_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
name|ents
operator|=
name|HDA_PARAM_CONN_LIST_LENGTH_LIST_LENGTH
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ents
operator|<
literal|1
condition|)
return|return;
name|entnum
operator|=
name|HDA_PARAM_CONN_LIST_LENGTH_LONG_FORM
argument_list|(
name|res
argument_list|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
name|max
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|w
operator|->
name|conns
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|w
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|prevcnid
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CONN_RMASK
parameter_list|(
name|e
parameter_list|)
value|(1<< ((32 / (e)) - 1))
define|#
directive|define
name|CONN_NMASK
parameter_list|(
name|e
parameter_list|)
value|(CONN_RMASK(e) - 1)
define|#
directive|define
name|CONN_RESVAL
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|,
name|n
parameter_list|)
value|((r)>> ((32 / (e)) * (n)))
define|#
directive|define
name|CONN_RANGE
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|,
name|n
parameter_list|)
value|(CONN_RESVAL(r, e, n)& CONN_RMASK(e))
define|#
directive|define
name|CONN_CNID
parameter_list|(
name|r
parameter_list|,
name|e
parameter_list|,
name|n
parameter_list|)
value|(CONN_RESVAL(r, e, n)& CONN_NMASK(e))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ents
condition|;
name|i
operator|+=
name|entnum
control|)
block|{
name|res
operator|=
name|hda_command
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_CONN_LIST_ENTRY
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|entnum
condition|;
name|j
operator|++
control|)
block|{
name|cnid
operator|=
name|CONN_CNID
argument_list|(
name|res
argument_list|,
name|entnum
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|nconns
operator|<
name|ents
condition|)
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"WARNING: nid=%d has zero cnid "
literal|"entnum=%d j=%d index=%d "
literal|"entries=%d found=%d res=0x%08x\n"
argument_list|,
name|nid
argument_list|,
name|entnum
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|ents
argument_list|,
name|w
operator|->
name|nconns
argument_list|,
name|res
argument_list|)
expr_stmt|;
else|else
goto|goto
name|getconns_out
goto|;
block|}
if|if
condition|(
name|cnid
operator|<
name|w
operator|->
name|devinfo
operator|->
name|startnode
operator|||
name|cnid
operator|>=
name|w
operator|->
name|devinfo
operator|->
name|endnode
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(w->devinfo->dev,
literal|"WARNING: nid=%d has cnid outside "
literal|"of the AFG range j=%d "
literal|"entnum=%d index=%d res=0x%08x\n"
argument|, 					    nid, j, entnum, i, res);
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|CONN_RANGE
argument_list|(
name|res
argument_list|,
name|entnum
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
name|addcnid
operator|=
name|cnid
expr_stmt|;
elseif|else
if|if
condition|(
name|prevcnid
operator|==
literal|0
operator|||
name|prevcnid
operator|>=
name|cnid
condition|)
block|{
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"WARNING: Invalid child range "
literal|"nid=%d index=%d j=%d entnum=%d "
literal|"prevcnid=%d cnid=%d res=0x%08x\n"
argument_list|,
name|nid
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|entnum
argument_list|,
name|prevcnid
argument_list|,
name|cnid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|addcnid
operator|=
name|cnid
expr_stmt|;
block|}
else|else
name|addcnid
operator|=
name|prevcnid
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|addcnid
operator|<=
name|cnid
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Adding %d (nid=%d): "
literal|"Max connection reached! max=%d\n"
argument_list|,
name|addcnid
argument_list|,
name|nid
argument_list|,
name|max
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|getconns_out
goto|;
block|}
name|w
operator|->
name|connsenable
index|[
name|w
operator|->
name|nconns
index|]
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|conns
index|[
name|w
operator|->
name|nconns
operator|++
index|]
operator|=
name|addcnid
operator|++
expr_stmt|;
block|}
name|prevcnid
operator|=
name|cnid
expr_stmt|;
block|}
block|}
name|getconns_out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_widget_parse
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|w
operator|->
name|devinfo
operator|->
name|dev
decl_stmt|;
name|uint32_t
name|wcap
decl_stmt|,
name|cap
decl_stmt|;
name|nid_t
name|nid
init|=
name|w
operator|->
name|nid
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|w
operator|->
name|param
operator|.
name|widget_cap
operator|=
name|wcap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_AUDIO_WIDGET_CAP
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE
argument_list|(
name|wcap
argument_list|)
expr_stmt|;
name|hdaa_widget_connection_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_OUT_AMP
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_AMP_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
name|w
operator|->
name|devinfo
operator|->
name|outamp_cap
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_IN_AMP
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_AMP_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_INPUT_AMP_CAP
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
name|w
operator|->
name|devinfo
operator|->
name|inamp_cap
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_FORMAT_OVR
argument_list|(
name|wcap
argument_list|)
condition|)
block|{
name|cap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_STREAM_FORMATS
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
operator|(
name|cap
operator|!=
literal|0
operator|)
condition|?
name|cap
else|:
name|w
operator|->
name|devinfo
operator|->
name|supp_stream_formats
expr_stmt|;
name|cap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_PCM_SIZE_RATE
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
operator|(
name|cap
operator|!=
literal|0
operator|)
condition|?
name|cap
else|:
name|w
operator|->
name|devinfo
operator|->
name|supp_pcm_size_rate
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
name|w
operator|->
name|devinfo
operator|->
name|supp_stream_formats
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
name|w
operator|->
name|devinfo
operator|->
name|supp_pcm_size_rate
expr_stmt|;
block|}
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_STRIPE
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|conv
operator|.
name|stripecap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_STRIPE_CONTROL
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|)
operator|>>
literal|20
expr_stmt|;
block|}
else|else
name|w
operator|->
name|wclass
operator|.
name|conv
operator|.
name|stripecap
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|original
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|newconf
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_CONFIGURATION_DEFAULT
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDA_PARAM_PIN_CAP
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PIN_WIDGET_CTRL
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
block|{
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_EAPD_BTL_ENABLE
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&=
literal|0x7
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator||=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
block|}
else|else
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|HDA_INVALID
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|w
operator|->
name|devinfo
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"nid%d_config"
argument_list|,
name|w
operator|->
name|nid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|buf
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|newconf
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|newconf
argument_list|)
argument_list|,
name|hdaa_sysctl_config
argument_list|,
literal|"A"
argument_list|,
literal|"Current pin configuration"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"nid%d_original"
argument_list|,
name|w
operator|->
name|nid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|buf
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|original
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|original
argument_list|)
argument_list|,
name|hdaa_sysctl_config
argument_list|,
literal|"A"
argument_list|,
literal|"Original pin configuration"
argument_list|)
expr_stmt|;
name|hdaa_lock
argument_list|(
name|w
operator|->
name|devinfo
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|unsol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_widget_postprocess
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|char
modifier|*
name|typestr
decl_stmt|;
name|w
operator|->
name|type
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
name|typestr
operator|=
literal|"audio output"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
name|typestr
operator|=
literal|"audio input"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
name|typestr
operator|=
literal|"audio mixer"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
name|typestr
operator|=
literal|"audio selector"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
name|typestr
operator|=
literal|"pin"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_POWER_WIDGET
case|:
name|typestr
operator|=
literal|"power widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VOLUME_WIDGET
case|:
name|typestr
operator|=
literal|"volume widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
case|:
name|typestr
operator|=
literal|"beep widget"
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VENDOR_WIDGET
case|:
name|typestr
operator|=
literal|"vendor widget"
expr_stmt|;
break|break;
default|default:
name|typestr
operator|=
literal|"unknown type"
expr_stmt|;
break|break;
block|}
name|strlcpy
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|typestr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
name|uint32_t
name|config
decl_stmt|;
specifier|const
name|char
modifier|*
name|devstr
decl_stmt|;
name|int
name|conn
decl_stmt|,
name|color
decl_stmt|;
name|config
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
expr_stmt|;
name|devstr
operator|=
name|HDA_DEVS
index|[
operator|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
operator|>>
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SHIFT
index|]
expr_stmt|;
name|conn
operator|=
operator|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|>>
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_SHIFT
expr_stmt|;
name|color
operator|=
operator|(
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_COLOR_MASK
operator|)
operator|>>
name|HDA_CONFIG_DEFAULTCONF_COLOR_SHIFT
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|": "
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|devstr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|" ("
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|==
literal|0
operator|&&
name|color
operator|!=
literal|0
operator|&&
name|color
operator|!=
literal|15
condition|)
block|{
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|HDA_COLORS
index|[
name|color
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|" "
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
name|HDA_CONNS
index|[
name|conn
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|w
operator|->
name|name
argument_list|,
literal|")"
argument_list|,
sizeof|sizeof
argument_list|(
name|w
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|connected
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|hdaa_widget
modifier|*
name|hdaa_widget_get
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|)
block|{
if|if
condition|(
name|devinfo
operator|==
name|NULL
operator|||
name|devinfo
operator|->
name|widget
operator|==
name|NULL
operator|||
name|nid
operator|<
name|devinfo
operator|->
name|startnode
operator|||
name|nid
operator|>=
name|devinfo
operator|->
name|endnode
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|devinfo
operator|->
name|widget
index|[
name|nid
operator|-
name|devinfo
operator|->
name|startnode
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_amp_set_internal
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|lmute
parameter_list|,
name|int
name|rmute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|uint16_t
name|v
init|=
literal|0
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Setting amplifier nid=%d index=%d %s mute=%d/%d vol=%d/%d\n"
argument|, 		    nid,index,dir ?
literal|"in"
argument|:
literal|"out"
argument|,lmute,rmute,left,right);
argument_list|)
empty_stmt|;
if|if
condition|(
name|left
operator|!=
name|right
operator|||
name|lmute
operator|!=
name|rmute
condition|)
block|{
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|lmute
operator|<<
literal|7
operator|)
operator||
name|left
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_AMP_GAIN_MUTE
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|rmute
operator|<<
literal|7
operator|)
operator||
name|right
expr_stmt|;
block|}
else|else
name|v
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|dir
operator|)
operator|)
operator||
operator|(
literal|3
operator|<<
literal|12
operator|)
operator||
operator|(
name|index
operator|<<
literal|8
operator|)
operator||
operator|(
name|lmute
operator|<<
literal|7
operator|)
operator||
name|left
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_AMP_GAIN_MUTE
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_amp_set
parameter_list|(
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
parameter_list|,
name|uint32_t
name|mute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|)
block|{
name|nid_t
name|nid
decl_stmt|;
name|int
name|lmute
decl_stmt|,
name|rmute
decl_stmt|;
name|nid
operator|=
name|ctl
operator|->
name|widget
operator|->
name|nid
expr_stmt|;
comment|/* Save new values if valid. */
if|if
condition|(
name|mute
operator|!=
name|HDAA_AMP_MUTE_DEFAULT
condition|)
name|ctl
operator|->
name|muted
operator|=
name|mute
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|HDAA_AMP_VOL_DEFAULT
condition|)
name|ctl
operator|->
name|left
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|right
operator|!=
name|HDAA_AMP_VOL_DEFAULT
condition|)
name|ctl
operator|->
name|right
operator|=
name|right
expr_stmt|;
comment|/* Prepare effective values */
if|if
condition|(
name|ctl
operator|->
name|forcemute
condition|)
block|{
name|lmute
operator|=
literal|1
expr_stmt|;
name|rmute
operator|=
literal|1
expr_stmt|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lmute
operator|=
name|HDAA_AMP_LEFT_MUTED
argument_list|(
name|ctl
operator|->
name|muted
argument_list|)
expr_stmt|;
name|rmute
operator|=
name|HDAA_AMP_RIGHT_MUTED
argument_list|(
name|ctl
operator|->
name|muted
argument_list|)
expr_stmt|;
name|left
operator|=
name|ctl
operator|->
name|left
expr_stmt|;
name|right
operator|=
name|ctl
operator|->
name|right
expr_stmt|;
block|}
comment|/* Apply effective values */
if|if
condition|(
name|ctl
operator|->
name|dir
operator|&
name|HDAA_CTL_OUT
condition|)
name|hdaa_audio_ctl_amp_set_internal
argument_list|(
name|ctl
operator|->
name|widget
operator|->
name|devinfo
argument_list|,
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|,
name|lmute
argument_list|,
name|rmute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|dir
operator|&
name|HDAA_CTL_IN
condition|)
name|hdaa_audio_ctl_amp_set_internal
argument_list|(
name|ctl
operator|->
name|widget
operator|->
name|devinfo
argument_list|,
name|nid
argument_list|,
name|ctl
operator|->
name|index
argument_list|,
name|lmute
argument_list|,
name|rmute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_widget_connection_select
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|nconns
operator|<
literal|1
operator|||
name|index
operator|>
operator|(
name|w
operator|->
name|nconns
operator|-
literal|1
operator|)
condition|)
return|return;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(w->devinfo->dev,
literal|"Setting selector nid=%d index=%d\n"
argument|, w->nid, index);
argument_list|)
empty_stmt|;
name|hda_command
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_CONNECTION_SELECT_CONTROL
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  * Device Methods  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|hdaa_channel_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|ch
operator|->
name|pdevinfo
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_FIXEDRATE
condition|)
block|{
name|ch
operator|->
name|caps
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|caps
operator|.
name|maxspeed
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|ch
operator|->
name|b
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|pdevinfo
operator|->
name|chan_size
operator|/
name|pdevinfo
operator|->
name|chan_blkcnt
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|pdevinfo
operator|->
name|chan_blkcnt
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|b
argument_list|,
name|bus_get_dma_tag
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|hda_get_dma_nocache
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
condition|?
name|BUS_DMA_NOCACHE
else|:
literal|0
argument_list|,
name|pdevinfo
operator|->
name|chan_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_channel_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|caps
operator|.
name|fmtlist
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|format
operator|==
name|ch
operator|->
name|caps
operator|.
name|fmtlist
index|[
name|i
index|]
condition|)
block|{
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdaa_channel_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|uint32_t
name|spd
init|=
literal|0
decl_stmt|,
name|threshold
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First look for equal or multiple frequency. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|spd
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|speed
operator|!=
literal|0
operator|&&
name|spd
operator|/
name|speed
operator|*
name|speed
operator|==
name|spd
condition|)
block|{
name|ch
operator|->
name|spd
operator|=
name|spd
expr_stmt|;
return|return
operator|(
name|spd
operator|)
return|;
block|}
block|}
comment|/* If no match, just find nearest. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|spd
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
expr_stmt|;
name|threshold
operator|=
name|spd
operator|+
operator|(
operator|(
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|spd
operator|)
operator|>>
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<
name|threshold
condition|)
break|break;
block|}
name|ch
operator|->
name|spd
operator|=
name|spd
expr_stmt|;
return|return
operator|(
name|spd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|hdaa_stream_format
parameter_list|(
name|struct
name|hdaa_chan
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|fmt
decl_stmt|;
name|fmt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S16_LE
condition|)
name|fmt
operator||=
name|ch
operator|->
name|bit16
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_S32_LE
condition|)
name|fmt
operator||=
name|ch
operator|->
name|bit32
operator|<<
literal|4
expr_stmt|;
else|else
name|fmt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_RATE_TAB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|valid
operator|&&
name|ch
operator|->
name|spd
operator|==
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|rate
condition|)
block|{
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|mul
expr_stmt|;
name|fmt
operator||=
name|hda_rate_tab
index|[
name|i
index|]
operator|.
name|div
expr_stmt|;
break|break;
block|}
block|}
name|fmt
operator||=
operator|(
name|AFMT_CHANNEL
argument_list|(
name|ch
operator|->
name|fmt
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|fmt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_allowed_stripes
parameter_list|(
name|uint16_t
name|fmt
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|bits
index|[
literal|8
index|]
init|=
block|{
literal|8
block|,
literal|16
block|,
literal|20
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|}
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|bits
index|[
operator|(
name|fmt
operator|>>
literal|4
operator|)
operator|&
literal|0x03
index|]
expr_stmt|;
name|size
operator|*=
operator|(
name|fmt
operator|&
literal|0x0f
operator|)
operator|+
literal|1
expr_stmt|;
name|size
operator|*=
operator|(
operator|(
name|fmt
operator|>>
literal|11
operator|)
operator|&
literal|0x07
operator|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0xffffffffU
operator|>>
operator|(
literal|32
operator|-
name|fls
argument_list|(
name|size
operator|/
literal|8
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_setup
parameter_list|(
name|struct
name|hdaa_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
operator|&
name|ch
operator|->
name|devinfo
operator|->
name|as
index|[
name|ch
operator|->
name|as
index|]
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|chn
decl_stmt|,
name|cchn
decl_stmt|,
name|totalchn
decl_stmt|,
name|totalextchn
decl_stmt|,
name|c
decl_stmt|;
name|uint16_t
name|fmt
decl_stmt|,
name|dfmt
decl_stmt|;
comment|/* Mapping channel pairs to codec pins/converters. */
specifier|const
specifier|static
name|uint16_t
name|convmap
index|[
literal|2
index|]
index|[
literal|5
index|]
init|=
block|{
block|{
literal|0x0010
block|,
literal|0x0001
block|,
literal|0x0201
block|,
literal|0x0231
block|,
literal|0x0231
block|}
block|,
comment|/* 5.1 */
block|{
literal|0x0010
block|,
literal|0x0001
block|,
literal|0x2001
block|,
literal|0x2031
block|,
literal|0x2431
block|}
block|}
decl_stmt|;
comment|/* 7.1 */
comment|/* Mapping formats to HDMI channel allocations. */
specifier|const
specifier|static
name|uint8_t
name|hdmica
index|[
literal|2
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
literal|0x02
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x0a
block|,
literal|0x0e
block|,
literal|0x12
block|,
literal|0x12
block|}
block|,
comment|/* x.0 */
block|{
literal|0x01
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x09
block|,
literal|0x0b
block|,
literal|0x0f
block|,
literal|0x13
block|}
block|}
decl_stmt|;
comment|/* x.1 */
comment|/* Mapping formats to HDMI channels order. */
specifier|const
specifier|static
name|uint32_t
name|hdmich
index|[
literal|2
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
literal|0xFFFF0F00
block|,
literal|0xFFFFFF10
block|,
literal|0xFFF2FF10
block|,
literal|0xFF32FF10
block|,
literal|0xFF324F10
block|,
literal|0xF5324F10
block|,
literal|0x54326F10
block|,
literal|0x54326F10
block|}
block|,
comment|/* x.0 */
block|{
literal|0xFFFFF000
block|,
literal|0xFFFF0100
block|,
literal|0xFFFFF210
block|,
literal|0xFFFF2310
block|,
literal|0xFF32F410
block|,
literal|0xFF324510
block|,
literal|0xF6324510
block|,
literal|0x76325410
block|}
block|}
decl_stmt|;
comment|/* x.1 */
name|int
name|convmapid
init|=
operator|-
literal|1
decl_stmt|;
name|nid_t
name|nid
decl_stmt|;
name|uint8_t
name|csum
decl_stmt|;
name|totalchn
operator|=
name|AFMT_CHANNEL
argument_list|(
name|ch
operator|->
name|fmt
argument_list|)
expr_stmt|;
name|totalextchn
operator|=
name|AFMT_EXTCHANNEL
argument_list|(
name|ch
operator|->
name|fmt
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(ch->pdevinfo->dev,
literal|"PCMDIR_%s: Stream setup fmt=%08x (%d.%d) speed=%d\n"
argument|, 		    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, 		    ch->fmt, totalchn - totalextchn, totalextchn, ch->spd);
argument_list|)
empty_stmt|;
name|fmt
operator|=
name|hdaa_stream_format
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Set channels to I/O converters mapping for known speaker setups. */
if|if
condition|(
operator|(
name|as
operator|->
name|pinset
operator|==
literal|0x0007
operator|||
name|as
operator|->
name|pinset
operator|==
literal|0x0013
operator|)
condition|)
comment|/* Standard 5.1 */
name|convmapid
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|as
operator|->
name|pinset
operator|==
literal|0x0017
condition|)
comment|/* Standard 7.1 */
name|convmapid
operator|=
literal|1
expr_stmt|;
name|dfmt
operator|=
name|HDA_CMD_SET_DIGITAL_CONV_FMT1_DIGEN
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_AC3
condition|)
name|dfmt
operator||=
name|HDA_CMD_SET_DIGITAL_CONV_FMT1_NAUDIO
expr_stmt|;
name|chn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If HP redirection is enabled, but failed to use same 		   DAC, make last DAC to duplicate first one. */
if|if
condition|(
name|as
operator|->
name|fakeredir
operator|&&
name|i
operator|==
operator|(
name|as
operator|->
name|pincnt
operator|-
literal|1
operator|)
condition|)
block|{
name|c
operator|=
operator|(
name|ch
operator|->
name|sid
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Map channels to I/O converters, if set. */
if|if
condition|(
name|convmapid
operator|>=
literal|0
condition|)
name|chn
operator|=
operator|(
operator|(
operator|(
name|convmap
index|[
name|convmapid
index|]
index|[
name|totalchn
operator|/
literal|2
index|]
operator|>>
name|i
operator|*
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|chn
operator|<
literal|0
operator|||
name|chn
operator|>=
name|totalchn
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|(
name|ch
operator|->
name|sid
operator|<<
literal|4
operator|)
operator||
name|chn
expr_stmt|;
block|}
block|}
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_CONV_FMT
argument_list|(
literal|0
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_DIGITAL_CONV_FMT1
argument_list|(
literal|0
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|dfmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_CONV_STREAM_CHAN
argument_list|(
literal|0
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_STRIPE
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_STRIPE_CONTROL
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|ch
operator|->
name|stripectl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cchn
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_CC
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cchn
operator|>
literal|1
operator|&&
name|chn
operator|<
name|totalchn
condition|)
block|{
name|cchn
operator|=
name|min
argument_list|(
name|cchn
argument_list|,
name|totalchn
operator|-
name|chn
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_CONV_CHAN_COUNT
argument_list|(
literal|0
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
name|cchn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(ch->pdevinfo->dev,
literal|"PCMDIR_%s: Stream setup nid=%d: "
literal|"fmt=0x%04x, dfmt=0x%04x, chan=0x%04x, "
literal|"chan_count=0x%02x, stripe=%d\n"
argument|, 			    (ch->dir == PCMDIR_PLAY) ?
literal|"PLAY"
argument|:
literal|"REC"
argument|, 			    ch->io[i], fmt, dfmt, c, cchn, ch->stripectl);
argument_list|)
empty_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|dacs
index|[
name|ch
operator|->
name|asindex
index|]
index|[
name|j
index|]
operator|!=
name|ch
operator|->
name|io
index|[
name|i
index|]
condition|)
continue|continue;
name|nid
operator|=
name|as
operator|->
name|pins
index|[
name|j
index|]
expr_stmt|;
name|wp
operator|=
name|hdaa_widget_get
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|HDA_PARAM_PIN_CAP_DP
argument_list|(
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|&&
operator|!
name|HDA_PARAM_PIN_CAP_HDMI
argument_list|(
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
continue|continue;
comment|/* Set channel mapping. */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
block|{
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_CHAN_SLOT
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
operator|(
operator|(
operator|(
name|hdmich
index|[
name|totalextchn
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
index|]
index|[
name|totalchn
operator|-
literal|1
index|]
operator|>>
operator|(
name|k
operator|*
literal|4
operator|)
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Enable High Bit Rate (HBR) Encoded Packet Type 			 * (EPT), if supported and needed (8ch data). 			 */
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HDMI
argument_list|(
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|&&
name|HDA_PARAM_PIN_CAP_HBR
argument_list|(
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
block|{
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|fmt
operator|&
name|AFMT_AC3
operator|)
operator|&&
operator|(
name|cchn
operator|==
literal|7
operator|)
condition|)
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
literal|0x03
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|wp
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Stop audio infoframe transmission. */
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_INDEX
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_XMIT
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear audio infoframe buffer. */
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_INDEX
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|32
condition|;
name|k
operator|++
control|)
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write HDMI/DisplayPort audio infoframe. */
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_INDEX
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|eld
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|eld_len
operator|>=
literal|6
operator|&&
operator|(
operator|(
name|w
operator|->
name|eld
index|[
literal|5
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x3
operator|)
operator|==
literal|1
condition|)
block|{
comment|/* DisplayPort */
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x84
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x1b
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x44
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* HDMI */
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x84
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x01
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x0a
argument_list|)
argument_list|)
expr_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|csum
operator|-=
literal|0x84
operator|+
literal|0x01
operator|+
literal|0x0a
operator|+
operator|(
name|totalchn
operator|-
literal|1
operator|)
operator|+
name|hdmica
index|[
name|totalextchn
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
index|]
index|[
name|totalchn
operator|-
literal|1
index|]
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|csum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|totalchn
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_DATA
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|hdmica
index|[
name|totalextchn
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
index|]
index|[
name|totalchn
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start audio infoframe transmission. */
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_INDEX
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_HDMI_DIP_XMIT
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
literal|0xc0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chn
operator|+=
name|cchn
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Greatest Common Divisor.  */
end_comment

begin_function
specifier|static
name|unsigned
name|gcd
parameter_list|(
name|unsigned
name|a
parameter_list|,
name|unsigned
name|b
parameter_list|)
block|{
name|u_int
name|c
decl_stmt|;
while|while
condition|(
name|b
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
name|c
operator|%
name|b
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Least Common Multiple.  */
end_comment

begin_function
specifier|static
name|unsigned
name|lcm
parameter_list|(
name|unsigned
name|a
parameter_list|,
name|unsigned
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
name|a
operator|*
name|b
operator|)
operator|/
name|gcd
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_channel_setfragments
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blksz
parameter_list|,
name|uint32_t
name|blkcnt
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|blksz
operator|-=
name|blksz
operator|%
name|lcm
argument_list|(
name|HDA_DMA_ALIGNMENT
argument_list|,
name|sndbuf_getalign
argument_list|(
name|ch
operator|->
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
operator|(
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|/
name|HDA_BDL_MIN
operator|)
condition|)
name|blksz
operator|=
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|/
name|HDA_BDL_MIN
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
name|HDA_BLK_MIN
condition|)
name|blksz
operator|=
name|HDA_BLK_MIN
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|>
name|HDA_BDL_MAX
condition|)
name|blkcnt
operator|=
name|HDA_BDL_MAX
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|<
name|HDA_BDL_MIN
condition|)
name|blkcnt
operator|=
name|HDA_BDL_MIN
expr_stmt|;
while|while
condition|(
operator|(
name|blksz
operator|*
name|blkcnt
operator|)
operator|>
name|sndbuf_getmaxsize
argument_list|(
name|ch
operator|->
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|blkcnt
operator|>>
literal|1
operator|)
operator|>=
name|HDA_BDL_MIN
condition|)
name|blkcnt
operator|>>=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|blksz
operator|>>
literal|1
operator|)
operator|>=
name|HDA_BLK_MIN
condition|)
name|blksz
operator|>>=
literal|1
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|(
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|!=
name|blksz
operator|||
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|b
argument_list|)
operator|!=
name|blkcnt
operator|)
operator|&&
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|b
argument_list|,
name|blkcnt
argument_list|,
name|blksz
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%s: failed blksz=%u blkcnt=%u\n"
argument_list|,
name|__func__
argument_list|,
name|blksz
argument_list|,
name|blkcnt
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blkcnt
operator|=
name|sndbuf_getblkcnt
argument_list|(
name|ch
operator|->
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdaa_channel_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blksz
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|hdaa_channel_setfragments
argument_list|(
name|obj
argument_list|,
name|data
argument_list|,
name|blksz
argument_list|,
name|ch
operator|->
name|pdevinfo
operator|->
name|chan_blkcnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|->
name|blksz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_channel_stop
parameter_list|(
name|struct
name|hdaa_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|flags
operator|&
name|HDAA_CHN_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ch
operator|->
name|flags
operator|&=
operator|~
name|HDAA_CHN_RUNNING
expr_stmt|;
name|HDAC_STREAM_STOP
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ch
operator|->
name|sid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_DIGITAL_CONV_FMT1
argument_list|(
literal|0
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_CONV_STREAM_CHAN
argument_list|(
literal|0
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HDAC_STREAM_FREE
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ch
operator|->
name|sid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_channel_start
parameter_list|(
name|struct
name|hdaa_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|uint32_t
name|fmt
decl_stmt|;
name|fmt
operator|=
name|hdaa_stream_format
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|->
name|stripectl
operator|=
name|fls
argument_list|(
name|ch
operator|->
name|stripecap
operator|&
name|hdaa_allowed_stripes
argument_list|(
name|fmt
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ch
operator|->
name|sid
operator|=
name|HDAC_STREAM_ALLOC
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|1
else|:
literal|0
argument_list|,
name|fmt
argument_list|,
name|ch
operator|->
name|stripectl
argument_list|,
operator|&
name|ch
operator|->
name|dmapos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sid
operator|<=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|hdaa_audio_setup
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|HDAC_STREAM_RESET
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ch
operator|->
name|sid
argument_list|)
expr_stmt|;
name|HDAC_STREAM_START
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ch
operator|->
name|sid
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|b
argument_list|)
argument_list|,
name|ch
operator|->
name|blksz
argument_list|,
name|ch
operator|->
name|blkcnt
argument_list|)
expr_stmt|;
name|ch
operator|->
name|flags
operator||=
name|HDAA_CHN_RUNNING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_channel_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|PCMTRIG_COMMON
argument_list|(
name|go
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hdaa_lock
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
name|error
operator|=
name|hdaa_channel_start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|hdaa_channel_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|hdaa_unlock
argument_list|(
name|ch
operator|->
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdaa_channel_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|hdaa_chan
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|uint32_t
name|ptr
decl_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dmapos
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
operator|*
operator|(
name|ch
operator|->
name|dmapos
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|HDAC_STREAM_GETPTR
argument_list|(
name|device_get_parent
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|devinfo
operator|->
name|dev
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ch
operator|->
name|sid
argument_list|)
expr_stmt|;
block|}
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
comment|/* 	 * Round to available space and force 128 bytes aligment. 	 */
name|ptr
operator|%=
name|ch
operator|->
name|blksz
operator|*
name|ch
operator|->
name|blkcnt
expr_stmt|;
name|ptr
operator|&=
name|HDA_BLK_ALIGN
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|hdaa_channel_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|&
operator|(
operator|(
expr|struct
name|hdaa_chan
operator|*
operator|)
name|data
operator|)
operator|->
name|caps
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdaa_channel_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|hdaa_channel_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|hdaa_channel_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|hdaa_channel_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|hdaa_channel_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setfragments
argument_list|,
name|hdaa_channel_setfragments
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|hdaa_channel_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|hdaa_channel_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|hdaa_channel_getcaps
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|hdaa_channel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|hdaa_audio_ctl_ossmixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|recmask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|pdevinfo
operator|->
name|mixer
operator|=
name|m
expr_stmt|;
comment|/* Make sure that in case of soft volume it won't stay muted. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
name|pdevinfo
operator|->
name|left
index|[
name|i
index|]
operator|=
literal|100
expr_stmt|;
name|pdevinfo
operator|->
name|right
index|[
name|i
index|]
operator|=
literal|100
expr_stmt|;
block|}
comment|/* Declare volume controls assigned to this association. */
name|mask
operator|=
name|pdevinfo
operator|->
name|ossmask
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
comment|/* Declate EAPD as ogain control. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|==
name|HDA_INVALID
operator|||
name|w
operator|->
name|bindas
operator|!=
name|pdevinfo
operator|->
name|playas
condition|)
continue|continue;
name|mask
operator||=
name|SOUND_MASK_OGAIN
expr_stmt|;
break|break;
block|}
comment|/* Declare soft PCM volume if needed. */
if|if
condition|(
operator|(
name|mask
operator|&
name|SOUND_MASK_PCM
operator|)
operator|==
literal|0
operator|||
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_SOFTPCMVOL
operator|)
operator|||
name|pdevinfo
operator|->
name|minamp
index|[
name|SOUND_MIXER_PCM
index|]
operator|==
name|pdevinfo
operator|->
name|maxamp
index|[
name|SOUND_MIXER_PCM
index|]
condition|)
block|{
name|mask
operator||=
name|SOUND_MASK_PCM
expr_stmt|;
name|pcm_setflags
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|)
operator||
name|SD_F_SOFTPCMVOL
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Forcing Soft PCM volume\n"
argument|);
argument_list|)
empty_stmt|;
block|}
comment|/* Declare master volume if needed. */
if|if
condition|(
operator|(
name|mask
operator|&
name|SOUND_MASK_VOLUME
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
name|mix_setparentchild
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MASK_PCM
argument_list|)
expr_stmt|;
name|mix_setrealdev
argument_list|(
name|m
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|SOUND_MIXER_NONE
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Forcing master volume with PCM\n"
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Declare record sources available to this association. */
name|recmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|<
literal|0
condition|)
continue|continue;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|bindas
operator|!=
name|pdevinfo
operator|->
name|recas
operator|&&
name|cw
operator|->
name|bindas
operator|!=
operator|-
literal|2
condition|)
continue|continue;
name|recmask
operator||=
name|cw
operator|->
name|ossmask
expr_stmt|;
block|}
block|}
block|}
name|recmask
operator|&=
operator|(
literal|1
operator|<<
name|SOUND_MIXER_NRDEVICES
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|(
literal|1
operator|<<
name|SOUND_MIXER_NRDEVICES
operator|)
operator|-
literal|1
expr_stmt|;
name|pdevinfo
operator|->
name|ossmask
operator|=
name|mask
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|recmask
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update amplification per pdevinfo per ossdev, calculate summary coefficient  * and write it to codec, update *left and *right to reflect remaining error.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_dev_set
parameter_list|(
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|int
name|mute
parameter_list|,
name|int
modifier|*
name|left
parameter_list|,
name|int
modifier|*
name|right
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|zleft
decl_stmt|,
name|zright
decl_stmt|,
name|sleft
decl_stmt|,
name|sright
decl_stmt|,
name|smute
decl_stmt|,
name|lval
decl_stmt|,
name|rval
decl_stmt|;
name|ctl
operator|->
name|devleft
index|[
name|ossdev
index|]
operator|=
operator|*
name|left
expr_stmt|;
name|ctl
operator|->
name|devright
index|[
name|ossdev
index|]
operator|=
operator|*
name|right
expr_stmt|;
name|ctl
operator|->
name|devmute
index|[
name|ossdev
index|]
operator|=
name|mute
expr_stmt|;
name|smute
operator|=
name|sleft
operator|=
name|sright
operator|=
name|zleft
operator|=
name|zright
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
name|sleft
operator|+=
name|ctl
operator|->
name|devleft
index|[
name|i
index|]
expr_stmt|;
name|sright
operator|+=
name|ctl
operator|->
name|devright
index|[
name|i
index|]
expr_stmt|;
name|smute
operator||=
name|ctl
operator|->
name|devmute
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ossdev
condition|)
continue|continue;
name|zleft
operator|+=
name|ctl
operator|->
name|devleft
index|[
name|i
index|]
expr_stmt|;
name|zright
operator|+=
name|ctl
operator|->
name|devright
index|[
name|i
index|]
expr_stmt|;
block|}
name|lval
operator|=
name|QDB2VAL
argument_list|(
name|ctl
argument_list|,
name|sleft
argument_list|)
expr_stmt|;
name|rval
operator|=
name|QDB2VAL
argument_list|(
name|ctl
argument_list|,
name|sright
argument_list|)
expr_stmt|;
name|hdaa_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|smute
argument_list|,
name|lval
argument_list|,
name|rval
argument_list|)
expr_stmt|;
operator|*
name|left
operator|-=
name|VAL2QDB
argument_list|(
name|ctl
argument_list|,
name|lval
argument_list|)
operator|-
name|VAL2QDB
argument_list|(
name|ctl
argument_list|,
name|QDB2VAL
argument_list|(
name|ctl
argument_list|,
name|zleft
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|right
operator|-=
name|VAL2QDB
argument_list|(
name|ctl
argument_list|,
name|rval
argument_list|)
operator|-
name|VAL2QDB
argument_list|(
name|ctl
argument_list|,
name|QDB2VAL
argument_list|(
name|ctl
argument_list|,
name|zright
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trace signal from source, setting volumes on the way.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_source_volume
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|mute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|conns
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return;
comment|/* Count number of active inputs. */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
continue|continue;
name|conns
operator|++
expr_stmt|;
block|}
block|}
comment|/* If this is not a first step - use input mixer. 	   Pins have common input ctl so care must be taken. */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
operator|(
name|conns
operator|==
literal|1
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
condition|)
block|{
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
name|hdaa_audio_ctl_dev_set
argument_list|(
name|ctl
argument_list|,
name|ossdev
argument_list|,
name|mute
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
block|}
comment|/* If widget has own ossdev - not traverse it. 	   It will be traversed on it's own. */
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return;
comment|/* We must not traverse pin */
if|if
condition|(
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return;
comment|/* 	 * If signals mixed, we can't assign controls farther. 	 * Ignore this on depth zero. Caller must knows why. 	 */
if|if
condition|(
name|conns
operator|>
literal|1
operator|&&
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|||
name|w
operator|->
name|selconn
operator|!=
name|index
operator|)
condition|)
return|return;
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
name|hdaa_audio_ctl_dev_set
argument_list|(
name|ctl
argument_list|,
name|ossdev
argument_list|,
name|mute
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wc
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|wc
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|nid
condition|)
block|{
name|hdaa_audio_ctl_source_volume
argument_list|(
name|pdevinfo
argument_list|,
name|ossdev
argument_list|,
name|wc
operator|->
name|nid
argument_list|,
name|j
argument_list|,
name|mute
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Trace signal from destination, setting volumes on the way.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_dest_volume
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|mute
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|consumers
decl_stmt|,
name|cleft
decl_stmt|,
name|cright
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
comment|/* If this node produce output for several consumers, 		   we can't touch it. */
name|consumers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wc
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|wc
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|nid
condition|)
name|consumers
operator|++
expr_stmt|;
block|}
block|}
comment|/* The only exception is if real HP redirection is configured 		   and this is a duplication point. 		   XXX: Actually exception is not completely correct. 		   XXX: Duplication point check is not perfect. */
if|if
condition|(
operator|(
name|consumers
operator|==
literal|2
operator|&&
operator|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|hpredir
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|fakeredir
operator|||
operator|(
name|w
operator|->
name|bindseqmask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
name|consumers
operator|>
literal|2
condition|)
return|return;
comment|/* Else use it's output mixer. */
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
name|hdaa_audio_ctl_dev_set
argument_list|(
name|ctl
argument_list|,
name|ossdev
argument_list|,
name|mute
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|)
expr_stmt|;
block|}
comment|/* We must not traverse pin */
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|i
operator|!=
name|index
condition|)
continue|continue;
name|cleft
operator|=
name|left
expr_stmt|;
name|cright
operator|=
name|right
expr_stmt|;
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
name|hdaa_audio_ctl_dev_set
argument_list|(
name|ctl
argument_list|,
name|ossdev
argument_list|,
name|mute
argument_list|,
operator|&
name|cleft
argument_list|,
operator|&
name|cright
argument_list|)
expr_stmt|;
name|hdaa_audio_ctl_dest_volume
argument_list|(
name|pdevinfo
argument_list|,
name|ossdev
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|mute
argument_list|,
name|cleft
argument_list|,
name|cright
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set volumes for the specified pdevinfo and ossdev.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_dev_volume
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|unsigned
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|uint32_t
name|mute
decl_stmt|;
name|int
name|lvol
decl_stmt|,
name|rvol
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mute
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|left
index|[
name|dev
index|]
operator|==
literal|0
condition|)
block|{
name|mute
operator||=
name|HDAA_AMP_MUTE_LEFT
expr_stmt|;
name|lvol
operator|=
operator|-
literal|4000
expr_stmt|;
block|}
else|else
name|lvol
operator|=
operator|(
operator|(
name|pdevinfo
operator|->
name|maxamp
index|[
name|dev
index|]
operator|-
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
operator|)
operator|*
name|pdevinfo
operator|->
name|left
index|[
name|dev
index|]
operator|+
literal|50
operator|)
operator|/
literal|100
operator|+
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|right
index|[
name|dev
index|]
operator|==
literal|0
condition|)
block|{
name|mute
operator||=
name|HDAA_AMP_MUTE_RIGHT
expr_stmt|;
name|rvol
operator|=
operator|-
literal|4000
expr_stmt|;
block|}
else|else
name|rvol
operator|=
operator|(
operator|(
name|pdevinfo
operator|->
name|maxamp
index|[
name|dev
index|]
operator|-
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
operator|)
operator|*
name|pdevinfo
operator|->
name|right
index|[
name|dev
index|]
operator|+
literal|50
operator|)
operator|/
literal|100
operator|+
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|&&
name|pdevinfo
operator|->
name|index
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
name|pdevinfo
operator|->
name|playas
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|pdevinfo
operator|->
name|recas
condition|)
continue|continue;
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_RECLEV
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|hdaa_audio_ctl_dest_volume
argument_list|(
name|pdevinfo
argument_list|,
name|dev
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_VOLUME
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|devinfo
operator|->
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
block|{
name|hdaa_audio_ctl_dest_volume
argument_list|(
name|pdevinfo
argument_list|,
name|dev
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_IGAIN
operator|&&
name|w
operator|->
name|pflags
operator|&
name|HDAA_ADC_MONITOR
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
continue|continue;
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|devinfo
operator|->
name|as
index|[
name|cw
operator|->
name|bindas
index|]
operator|.
name|dir
operator|!=
name|HDAA_CTL_IN
condition|)
continue|continue;
name|hdaa_audio_ctl_dest_volume
argument_list|(
name|pdevinfo
argument_list|,
name|dev
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|j
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|w
operator|->
name|ossdev
operator|!=
name|dev
condition|)
continue|continue;
name|hdaa_audio_ctl_source_volume
argument_list|(
name|pdevinfo
argument_list|,
name|dev
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_IMIX
operator|&&
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDAA_IMIX_AS_DST
operator|)
condition|)
name|hdaa_audio_ctl_dest_volume
argument_list|(
name|pdevinfo
argument_list|,
name|dev
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|mute
argument_list|,
name|lvol
argument_list|,
name|rvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * OSS Mixer set method.  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_ctl_ossmixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
comment|/* Save new values. */
name|pdevinfo
operator|->
name|left
index|[
name|dev
index|]
operator|=
name|left
expr_stmt|;
name|pdevinfo
operator|->
name|right
index|[
name|dev
index|]
operator|=
name|right
expr_stmt|;
comment|/* 'ogain' is the special case implemented with EAPD. */
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_OGAIN
condition|)
block|{
name|uint32_t
name|orig
decl_stmt|;
name|w
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|==
name|HDA_INVALID
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|devinfo
operator|->
name|endnode
condition|)
block|{
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|orig
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|&=
operator|~
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
else|else
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator||=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
if|if
condition|(
name|orig
operator|!=
name|w
operator|->
name|param
operator|.
name|eapdbtl
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_EAPDINV
condition|)
name|val
operator|^=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_EAPD_BTL_ENABLE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|left
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
comment|/* Recalculate all controls related to this OSS device. */
name|hdaa_audio_ctl_dev_volume
argument_list|(
name|pdevinfo
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set mixer settings to our own default values:  * +20dB for mics, -10dB for analog vol, mute for igain, 0dB for others.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_set_defaults
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|int
name|amp
decl_stmt|,
name|vol
decl_stmt|,
name|dev
decl_stmt|;
for|for
control|(
name|dev
operator|=
literal|0
init|;
name|dev
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|dev
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pdevinfo
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If the value was overriden, leave it as is. */
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|)
argument_list|,
name|ossnames
index|[
name|dev
index|]
argument_list|,
operator|&
name|vol
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|vol
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_OGAIN
condition|)
name|vol
operator|=
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_IGAIN
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_MIC
operator|||
name|dev
operator|==
name|SOUND_MIXER_MONITOR
condition|)
name|amp
operator|=
literal|20
operator|*
literal|4
expr_stmt|;
comment|/* +20dB */
elseif|else
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_VOLUME
operator|&&
operator|!
name|pdevinfo
operator|->
name|digital
condition|)
name|amp
operator|=
operator|-
literal|10
operator|*
literal|4
expr_stmt|;
comment|/* -10dB */
else|else
name|amp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
operator|&&
operator|(
name|pdevinfo
operator|->
name|maxamp
index|[
name|dev
index|]
operator|-
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
operator|)
operator|<=
literal|0
condition|)
block|{
name|vol
operator|=
literal|100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
block|{
name|vol
operator|=
operator|(
operator|(
name|amp
operator|-
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
operator|)
operator|*
literal|100
operator|+
operator|(
name|pdevinfo
operator|->
name|maxamp
index|[
name|dev
index|]
operator|-
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
operator|)
operator|/
literal|2
operator|)
operator|/
operator|(
name|pdevinfo
operator|->
name|maxamp
index|[
name|dev
index|]
operator|-
name|pdevinfo
operator|->
name|minamp
index|[
name|dev
index|]
operator|)
expr_stmt|;
name|vol
operator|=
name|imin
argument_list|(
name|imax
argument_list|(
name|vol
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
block|}
name|mix_set
argument_list|(
name|pdevinfo
operator|->
name|mixer
argument_list|,
name|dev
argument_list|,
name|vol
argument_list|,
name|vol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Recursively commutate specified record source.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|hdaa_audio_ctl_recsel_comm
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|uint32_t
name|src
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|muted
decl_stmt|;
name|uint32_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
operator|||
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Call recursively to trace signal to it's source if needed. */
if|if
condition|(
operator|(
name|src
operator|&
name|cw
operator|->
name|ossmask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cw
operator|->
name|ossdev
operator|<
literal|0
condition|)
block|{
name|res
operator||=
name|hdaa_audio_ctl_recsel_comm
argument_list|(
name|pdevinfo
argument_list|,
name|src
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator||=
name|cw
operator|->
name|ossmask
expr_stmt|;
block|}
block|}
comment|/* We have two special cases: mixers and others (selectors). */
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
block|{
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If we have input control on this node mute them 			 * according to requested sources. */
name|muted
operator|=
operator|(
name|src
operator|&
name|cw
operator|->
name|ossmask
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|muted
operator|!=
name|ctl
operator|->
name|forcemute
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
name|muted
expr_stmt|;
name|hdaa_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDAA_AMP_MUTE_DEFAULT
argument_list|,
name|HDAA_AMP_VOL_DEFAULT
argument_list|,
name|HDAA_AMP_VOL_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Recsel (%s): nid %d source %d %s\n"
argument|, 				    hdaa_audio_ctl_ossmixer_mask2allname( 				    src, buf, sizeof(buf)), 				    nid, i, muted?
literal|"mute"
argument|:
literal|"unmute"
argument|);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|w
operator|->
name|nconns
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|src
operator|&
name|cw
operator|->
name|ossmask
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If we found requested source - select it and exit. */
name|hdaa_widget_connection_select
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"Recsel (%s): nid %d source %d select\n"
argument|, 				    hdaa_audio_ctl_ossmixer_mask2allname( 				    src, buf, sizeof(buf)), 				    nid, i);
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdaa_audio_ctl_ossmixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|uint32_t
name|src
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|struct
name|hdaa_chan
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
name|ret
init|=
literal|0xffffffff
decl_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|<
literal|0
condition|)
block|{
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
expr_stmt|;
comment|/* For non-mixed associations we always recording everything. */
if|if
condition|(
operator|!
name|as
operator|->
name|mixed
condition|)
block|{
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|mix_getrecdevs
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
comment|/* Commutate requested recsrc for each ADC. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|as
operator|->
name|num_chans
condition|;
name|j
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|devinfo
operator|->
name|chans
index|[
name|as
operator|->
name|chans
index|[
name|j
index|]
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ch
operator|->
name|io
index|[
name|i
index|]
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator|&=
name|hdaa_audio_ctl_recsel_comm
argument_list|(
name|pdevinfo
argument_list|,
name|src
argument_list|,
name|ch
operator|->
name|io
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|0xffffffff
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Some controls could be shared. Reset volumes for controls 	 * related to previously chosen devices, as they may no longer 	 * affect the signal. 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdaa_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
operator|!
operator|(
name|ctl
operator|->
name|ossmask
operator|&
name|pdevinfo
operator|->
name|recsrc
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|pdevinfo
operator|->
name|playas
operator|)
operator|||
operator|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|pdevinfo
operator|->
name|recas
operator|)
operator|||
operator|(
name|pdevinfo
operator|->
name|index
operator|==
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pdevinfo
operator|->
name|recsrc
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|ctl
operator|->
name|devleft
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|devright
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|devmute
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Some controls could be shared. Set volumes for controls 	 * related to devices selected both previously and now. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator||
name|pdevinfo
operator|->
name|recsrc
operator|)
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|hdaa_audio_ctl_dev_volume
argument_list|(
name|pdevinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|pdevinfo
operator|->
name|recsrc
operator|=
name|ret
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdaa_audio_ctl_ossmixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|hdaa_audio_ctl_ossmixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|hdaa_audio_ctl_ossmixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|hdaa_audio_ctl_ossmixer_setrecsrc
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|hdaa_audio_ctl_ossmixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|hdaa_dump_gpi
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|data
decl_stmt|,
name|wake
decl_stmt|,
name|unsol
decl_stmt|,
name|sticky
decl_stmt|;
if|if
condition|(
name|HDA_PARAM_GPIO_COUNT_NUM_GPI
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPI_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|wake
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPI_WAKE_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|unsol
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPI_UNSOLICITED_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|sticky
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPI_STICKY_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_PARAM_GPIO_COUNT_NUM_GPI
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" GPI%d:%s%s%s state=%d"
argument_list|,
name|i
argument_list|,
operator|(
name|sticky
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|" sticky"
else|:
literal|""
argument_list|,
operator|(
name|unsol
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|" unsol"
else|:
literal|""
argument_list|,
operator|(
name|wake
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|" wake"
else|:
literal|""
argument_list|,
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_gpio
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|data
decl_stmt|,
name|dir
decl_stmt|,
name|enable
decl_stmt|,
name|wake
decl_stmt|,
name|unsol
decl_stmt|,
name|sticky
decl_stmt|;
if|if
condition|(
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|enable
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_DIRECTION
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|wake
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_WAKE_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|unsol
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_UNSOLICITED_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|sticky
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_STICKY_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" GPIO%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enable
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"disabled\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|dir
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"input%s%s%s"
argument_list|,
operator|(
name|sticky
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|" sticky"
else|:
literal|""
argument_list|,
operator|(
name|unsol
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|" unsol"
else|:
literal|""
argument_list|,
operator|(
name|wake
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|?
literal|" wake"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"output"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" state=%d\n"
argument_list|,
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_gpo
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
if|if
condition|(
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" GPO%d: state=%d"
argument_list|,
name|i
argument_list|,
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_parse
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|nid_t
name|nid
decl_stmt|;
name|nid
operator|=
name|devinfo
operator|->
name|nid
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_GPIO_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|gpio_cap
operator|=
name|res
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"NumGPIO=%d NumGPO=%d "
literal|"NumGPI=%d GPIWake=%d GPIUnsol=%d\n"
argument|, 		    HDA_PARAM_GPIO_COUNT_NUM_GPIO(devinfo->gpio_cap), 		    HDA_PARAM_GPIO_COUNT_NUM_GPO(devinfo->gpio_cap), 		    HDA_PARAM_GPIO_COUNT_NUM_GPI(devinfo->gpio_cap), 		    HDA_PARAM_GPIO_COUNT_GPI_WAKE(devinfo->gpio_cap), 		    HDA_PARAM_GPIO_COUNT_GPI_UNSOL(devinfo->gpio_cap)); 		hdaa_dump_gpi(devinfo); 		hdaa_dump_gpio(devinfo); 		hdaa_dump_gpo(devinfo);
argument_list|)
empty_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_STREAM_FORMATS
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|supp_stream_formats
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUPP_PCM_SIZE_RATE
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|supp_pcm_size_rate
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|outamp_cap
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_INPUT_AMP_CAP
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|inamp_cap
operator|=
name|res
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Ghost widget! nid=%d!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|->
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|w
operator|->
name|nid
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|enable
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|pflags
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|ossdev
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|=
name|HDA_INVALID
expr_stmt|;
name|hdaa_widget_parse
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_postprocess
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
name|hdaa_widget_postprocess
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_parse
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctls
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|,
name|max
decl_stmt|,
name|ocap
decl_stmt|,
name|icap
decl_stmt|;
name|int
name|mute
decl_stmt|,
name|offset
decl_stmt|,
name|step
decl_stmt|,
name|size
decl_stmt|;
comment|/* XXX This is redundant */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|!=
literal|0
condition|)
name|max
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|max
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|max
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|devinfo
operator|->
name|ctlcnt
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|1
condition|)
return|return;
name|ctls
operator|=
operator|(
expr|struct
name|hdaa_audio_ctl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctls
argument_list|)
operator|*
name|max
argument_list|,
name|M_HDAA
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctls
operator|==
name|NULL
condition|)
block|{
comment|/* Blekh! */
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"unable to allocate ctls!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|ctlcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|cnt
operator|<
name|max
operator|&&
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ocap
operator|=
name|w
operator|->
name|param
operator|.
name|outamp_cap
expr_stmt|;
name|icap
operator|=
name|w
operator|->
name|param
operator|.
name|inamp_cap
expr_stmt|;
if|if
condition|(
name|ocap
operator|!=
literal|0
condition|)
block|{
name|mute
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|step
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|size
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|ocap
argument_list|)
expr_stmt|;
comment|/*if (offset> step) { 				HDA_BOOTVERBOSE( 					device_printf(devinfo->dev, 					    "BUGGY outamp: nid=%d " 					    "[offset=%d> step=%d]\n", 					    w->nid, offset, step); 				); 				offset = step; 			}*/
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|waspin
condition|)
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDAA_CTL_IN
expr_stmt|;
else|else
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDAA_CTL_OUT
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDAA_CTL_OUT
expr_stmt|;
block|}
if|if
condition|(
name|icap
operator|!=
literal|0
condition|)
block|{
name|mute
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|step
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|size
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|icap
argument_list|)
expr_stmt|;
name|offset
operator|=
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|icap
argument_list|)
expr_stmt|;
comment|/*if (offset> step) { 				HDA_BOOTVERBOSE( 					device_printf(devinfo->dev, 					    "BUGGY inamp: nid=%d " 					    "[offset=%d> step=%d]\n", 					    w->nid, offset, step); 				); 				offset = step; 			}*/
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
case|:
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|childwidget
operator|=
name|cw
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|index
operator|=
name|j
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDAA_CTL_IN
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDAA_CTL_IN
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|cnt
operator|>=
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%s: Ctl overflow!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctls
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|widget
operator|=
name|w
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|mute
operator|=
name|mute
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|step
operator|=
name|step
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|left
operator|=
name|offset
expr_stmt|;
name|ctls
index|[
name|cnt
index|]
operator|.
name|right
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDAA_CTL_OUT
expr_stmt|;
else|else
name|ctls
index|[
name|cnt
index|]
operator|.
name|ndir
operator|=
name|HDAA_CTL_IN
expr_stmt|;
name|ctls
index|[
name|cnt
operator|++
index|]
operator|.
name|dir
operator|=
name|HDAA_CTL_IN
expr_stmt|;
break|break;
block|}
block|}
block|}
name|devinfo
operator|->
name|ctl
operator|=
name|ctls
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_as_parse
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|,
name|max
decl_stmt|,
name|type
decl_stmt|,
name|dir
decl_stmt|,
name|assoc
decl_stmt|,
name|seq
decl_stmt|,
name|first
decl_stmt|,
name|hpredir
decl_stmt|;
comment|/* Count present associations */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
operator|!=
name|j
condition|)
continue|continue;
name|max
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|15
condition|)
comment|/* There could be many 1-pin assocs #15 */
break|break;
block|}
block|}
name|devinfo
operator|->
name|ascnt
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|1
condition|)
return|return;
name|as
operator|=
operator|(
expr|struct
name|hdaa_audio_as
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|as
argument_list|)
operator|*
name|max
argument_list|,
name|M_HDAA
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
condition|)
block|{
comment|/* Blekh! */
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"unable to allocate assocs!\n"
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|ascnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|as
index|[
name|i
index|]
operator|.
name|hpredir
operator|=
operator|-
literal|1
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|digital
operator|=
literal|0
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|num_chans
operator|=
literal|1
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|location
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Scan associations skipping as=0. */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|first
operator|=
literal|16
expr_stmt|;
name|hpredir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|assoc
operator|=
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|seq
operator|=
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|j
condition|)
block|{
continue|continue;
block|}
name|KASSERT
argument_list|(
name|cnt
operator|<
name|max
argument_list|,
operator|(
literal|"%s: Associations owerflow (%d of %d)"
operator|,
name|__func__
operator|,
name|cnt
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
expr_stmt|;
comment|/* Get pin direction. */
if|if
condition|(
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_OUT
operator|||
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_OUT
condition|)
name|dir
operator|=
name|HDAA_CTL_OUT
expr_stmt|;
else|else
name|dir
operator|=
name|HDAA_CTL_IN
expr_stmt|;
comment|/* If this is a first pin - create new association. */
if|if
condition|(
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|==
literal|0
condition|)
block|{
name|as
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|index
operator|=
name|j
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
block|}
if|if
condition|(
name|seq
operator|<
name|first
condition|)
name|first
operator|=
name|seq
expr_stmt|;
comment|/* Check association correctness. */
if|if
condition|(
name|as
index|[
name|cnt
index|]
operator|.
name|pins
index|[
name|seq
index|]
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%s: Duplicate pin %d (%d) "
literal|"in association %d! Disabling association.\n"
argument_list|,
name|__func__
argument_list|,
name|seq
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|!=
name|as
index|[
name|cnt
index|]
operator|.
name|dir
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%s: Pin %d has wrong "
literal|"direction for association %d! Disabling "
literal|"association.\n"
argument_list|,
name|__func__
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
name|as
index|[
name|cnt
index|]
operator|.
name|digital
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HDMI
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
name|as
index|[
name|cnt
index|]
operator|.
name|digital
operator||=
literal|0x2
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_DP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
name|as
index|[
name|cnt
index|]
operator|.
name|digital
operator||=
literal|0x4
expr_stmt|;
block|}
if|if
condition|(
name|as
index|[
name|cnt
index|]
operator|.
name|location
operator|==
operator|-
literal|1
condition|)
block|{
name|as
index|[
name|cnt
index|]
operator|.
name|location
operator|=
name|HDA_CONFIG_DEFAULTCONF_LOCATION
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|as
index|[
name|cnt
index|]
operator|.
name|location
operator|!=
name|HDA_CONFIG_DEFAULTCONF_LOCATION
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
condition|)
block|{
name|as
index|[
name|cnt
index|]
operator|.
name|location
operator|=
operator|-
literal|2
expr_stmt|;
block|}
comment|/* Headphones with seq=15 may mean redirection. */
if|if
condition|(
name|type
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
operator|&&
name|seq
operator|==
literal|15
condition|)
name|hpredir
operator|=
literal|1
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|pins
index|[
name|seq
index|]
operator|=
name|w
operator|->
name|nid
expr_stmt|;
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|++
expr_stmt|;
comment|/* Association 15 is a multiple unassociated pins. */
if|if
condition|(
name|j
operator|==
literal|15
condition|)
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
literal|15
operator|&&
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hpredir
operator|&&
name|as
index|[
name|cnt
index|]
operator|.
name|pincnt
operator|>
literal|1
condition|)
name|as
index|[
name|cnt
index|]
operator|.
name|hpredir
operator|=
name|first
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
operator|&&
operator|(
name|as
index|[
name|i
index|]
operator|.
name|pincnt
operator|==
literal|1
operator|||
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|14
index|]
operator|>
literal|0
operator|||
name|as
index|[
name|i
index|]
operator|.
name|pins
index|[
literal|15
index|]
operator|>
literal|0
operator|)
condition|)
name|as
index|[
name|i
index|]
operator|.
name|mixed
operator|=
literal|1
expr_stmt|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"%d associations found:\n"
argument|, max); 		for (i =
literal|0
argument|; i< max; i++) { 			device_printf(devinfo->dev,
literal|"Association %d (%d) %s%s:\n"
argument|, 			    i, as[i].index, (as[i].dir == HDAA_CTL_IN)?
literal|"in"
argument|:
literal|"out"
argument|, 			    as[i].enable?
literal|""
argument|:
literal|" (disabled)"
argument|); 			for (j =
literal|0
argument|; j<
literal|16
argument|; j++) { 				if (as[i].pins[j] ==
literal|0
argument|) 					continue; 				device_printf(devinfo->dev,
literal|" Pin nid=%d seq=%d\n"
argument|, 				    as[i].pins[j], j); 			} 		}
argument_list|)
empty_stmt|;
name|devinfo
operator|->
name|as
operator|=
name|as
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trace path from DAC to pin.  */
end_comment

begin_function
specifier|static
name|nid_t
name|hdaa_audio_trace_dac
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|dupseq
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|only
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|im
init|=
operator|-
literal|1
decl_stmt|;
name|nid_t
name|m
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 			device_printf(devinfo->dev,
literal|" %*stracing via nid %d\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid); 		}
argument_list|)
empty_stmt|;
comment|/* Use only unused widgets */
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|as
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 				device_printf(devinfo->dev,
literal|" %*snid %d busy by association %d\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas); 			}
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dupseq
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|bindseqmask
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 					device_printf(devinfo->dev,
literal|" %*snid %d busy by seqmask %x\n"
argument|, 						depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindseqmask); 				}
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* If this is headphones - allow duplicate first pin. */
if|if
condition|(
name|w
operator|->
name|bindseqmask
operator|!=
literal|0
operator|&&
operator|(
name|w
operator|->
name|bindseqmask
operator|&
operator|(
literal|1
operator|<<
name|dupseq
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d busy by seqmask %x\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindseqmask);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
comment|/* Do not traverse input. AD1988 has digital monitor 		for which we are not ready. */
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
comment|/* If we are tracing HP take only dac of first pin. */
if|if
condition|(
operator|(
name|only
operator|==
literal|0
operator|||
name|only
operator|==
name|w
operator|->
name|nid
operator|)
operator|&&
operator|(
name|w
operator|->
name|nid
operator|>=
name|min
operator|)
operator|&&
operator|(
name|dupseq
operator|<
literal|0
operator|||
name|w
operator|->
name|nid
operator|==
name|devinfo
operator|->
name|as
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|dupseq
index|]
operator|)
condition|)
name|m
operator|=
name|w
operator|->
name|nid
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
break|break;
comment|/* Fall */
default|default:
comment|/* Find reachable DACs with smallest nid respecting constraints. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|selconn
operator|!=
operator|-
literal|1
operator|&&
name|w
operator|->
name|selconn
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|hdaa_audio_trace_dac
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|seq
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|dupseq
argument_list|,
name|min
argument_list|,
name|only
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
operator|||
name|ret
operator|<
name|m
condition|)
block|{
name|m
operator|=
name|ret
expr_stmt|;
name|im
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|only
operator|||
name|dupseq
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|im
operator|>=
literal|0
operator|&&
name|only
operator|&&
operator|(
operator|(
name|w
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|)
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|)
condition|)
name|w
operator|->
name|selconn
operator|=
name|im
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|&&
name|only
condition|)
block|{
name|w
operator|->
name|bindas
operator|=
name|as
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator||=
operator|(
literal|1
operator|<<
name|seq
operator|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|if (!only) { 			device_printf(devinfo->dev,
literal|" %*snid %d returned %d\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid, m); 		}
argument_list|)
empty_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trace path from widget to ADC.  */
end_comment

begin_function
specifier|static
name|nid_t
name|hdaa_audio_trace_adc
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|mixed
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|only
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
modifier|*
name|length
parameter_list|,
name|int
name|onlylength
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|im
decl_stmt|,
name|lm
init|=
name|HDA_PARSE_MAXDEPTH
decl_stmt|;
name|nid_t
name|m
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*stracing via nid %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid);
argument_list|)
empty_stmt|;
comment|/* Use only unused widgets */
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|as
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d busy by association %d\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|mixed
operator|&&
name|w
operator|->
name|bindseqmask
operator|!=
literal|0
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d busy by seqmask %x\n"
argument|, 				depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindseqmask);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
if|if
condition|(
operator|(
name|only
operator|==
literal|0
operator|||
name|only
operator|==
name|w
operator|->
name|nid
operator|)
operator|&&
operator|(
name|w
operator|->
name|nid
operator|>=
name|min
operator|)
operator|&&
operator|(
name|onlylength
operator|==
literal|0
operator|||
name|onlylength
operator|==
name|depth
operator|)
condition|)
block|{
name|m
operator|=
name|w
operator|->
name|nid
expr_stmt|;
operator|*
name|length
operator|=
name|depth
expr_stmt|;
block|}
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
break|break;
comment|/* Fall */
default|default:
comment|/* Try to find reachable ADCs with specified nid. */
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|wc
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|im
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wc
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|wc
operator|->
name|conns
index|[
name|i
index|]
operator|!=
name|nid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret
operator|=
name|hdaa_audio_trace_adc
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|seq
argument_list|,
name|j
argument_list|,
name|mixed
argument_list|,
name|min
argument_list|,
name|only
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|length
argument_list|,
name|onlylength
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
operator|||
name|ret
operator|<
name|m
operator|||
operator|(
name|ret
operator|==
name|m
operator|&&
operator|*
name|length
operator|<
name|lm
operator|)
condition|)
block|{
name|m
operator|=
name|ret
expr_stmt|;
name|im
operator|=
name|i
expr_stmt|;
name|lm
operator|=
operator|*
name|length
expr_stmt|;
block|}
else|else
operator|*
name|length
operator|=
name|lm
expr_stmt|;
if|if
condition|(
name|only
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|im
operator|>=
literal|0
operator|&&
name|only
operator|&&
operator|(
operator|(
name|wc
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|wc
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
operator|)
operator|||
name|wc
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|)
condition|)
name|wc
operator|->
name|selconn
operator|=
name|im
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|m
operator|&&
name|only
condition|)
block|{
name|w
operator|->
name|bindas
operator|=
name|as
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator||=
operator|(
literal|1
operator|<<
name|seq
operator|)
expr_stmt|;
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d returned %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid, m);
argument_list|)
empty_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Erase trace path of the specified association.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_undo_trace
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
name|as
condition|)
block|{
if|if
condition|(
name|seq
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|bindseqmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|seq
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|bindseqmask
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Trace association path from DAC to output  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_trace_as_out
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hpredir
decl_stmt|;
name|nid_t
name|min
decl_stmt|,
name|res
decl_stmt|;
comment|/* Find next pin */
for|for
control|(
name|i
operator|=
name|seq
init|;
name|i
operator|<
literal|16
operator|&&
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Check if there is no any left. If so - we succeeded. */
if|if
condition|(
name|i
operator|==
literal|16
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hpredir
operator|=
operator|(
name|i
operator|==
literal|15
operator|&&
name|ases
index|[
name|as
index|]
operator|.
name|fakeredir
operator|==
literal|0
operator|)
condition|?
name|ases
index|[
name|as
index|]
operator|.
name|hpredir
else|:
operator|-
literal|1
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Tracing pin %d with min nid %d"
argument|, 			    ases[as].pins[i], min); 			if (hpredir>=
literal|0
argument|) 				printf(
literal|" and hpredir %d"
argument|, hpredir); 			printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* Trace this pin taking min nid into account. */
name|res
operator|=
name|hdaa_audio_trace_dac
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
name|hpredir
argument_list|,
name|min
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
comment|/* If we failed - return to previous and redo it. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Unable to trace pin %d seq %d with min "
literal|"nid %d"
argument|, 				    ases[as].pins[i], i, min); 				if (hpredir>=
literal|0
argument|) 					printf(
literal|" and hpredir %d"
argument|, hpredir); 				printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Pin %d traced to DAC %d"
argument|, 			    ases[as].pins[i], res); 			if (hpredir>=
literal|0
argument|) 				printf(
literal|" and hpredir %d"
argument|, hpredir); 			if (ases[as].fakeredir) 				printf(
literal|" with fake redirection"
argument|); 			printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* Trace again to mark the path */
name|hdaa_audio_trace_dac
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
name|hpredir
argument_list|,
name|min
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|res
expr_stmt|;
comment|/* We succeeded, so call next. */
if|if
condition|(
name|hdaa_audio_trace_as_out
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If next failed, we should retry with next min */
name|hdaa_audio_undo_trace
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|min
operator|=
name|res
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Check equivalency of two DACs.  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_dacs_equal
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w1
parameter_list|,
name|struct
name|hdaa_widget
modifier|*
name|w2
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w1
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w3
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|w1
operator|->
name|param
argument_list|,
operator|&
name|w2
operator|->
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|w1
operator|->
name|param
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w3
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w3
operator|==
name|NULL
operator|||
name|w3
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w3
operator|->
name|bindas
operator|!=
name|w1
operator|->
name|bindas
condition|)
continue|continue;
if|if
condition|(
name|w3
operator|->
name|nconns
operator|==
literal|0
condition|)
continue|continue;
name|c1
operator|=
name|c2
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w3
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w3
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w3
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|w1
operator|->
name|nid
condition|)
name|c1
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|w3
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|w2
operator|->
name|nid
condition|)
name|c2
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|c2
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w3
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check equivalency of two ADCs.  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_adcs_equal
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w1
parameter_list|,
name|struct
name|hdaa_widget
modifier|*
name|w2
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w1
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w3
decl_stmt|,
modifier|*
name|w4
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|w1
operator|->
name|param
argument_list|,
operator|&
name|w2
operator|->
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|w1
operator|->
name|param
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w1
operator|->
name|nconns
operator|!=
literal|1
operator|||
name|w2
operator|->
name|nconns
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w1
operator|->
name|conns
index|[
literal|0
index|]
operator|==
name|w2
operator|->
name|conns
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|w3
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w1
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w3
operator|==
name|NULL
operator|||
name|w3
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w4
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w2
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w4
operator|==
name|NULL
operator|||
name|w4
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w3
operator|->
name|bindas
operator|==
name|w4
operator|->
name|bindas
operator|&&
name|w3
operator|->
name|bindseqmask
operator|==
name|w4
operator|->
name|bindseqmask
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|w4
operator|->
name|bindas
operator|>=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w3
operator|->
name|type
operator|!=
name|w4
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|w3
operator|->
name|param
argument_list|,
operator|&
name|w4
operator|->
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|w3
operator|->
name|param
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|w3
operator|->
name|nconns
operator|!=
name|w4
operator|->
name|nconns
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w3
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w3
operator|->
name|conns
index|[
name|i
index|]
operator|!=
name|w4
operator|->
name|conns
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for equivalent DAC/ADC to implement second channel.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_adddac
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|asid
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|asid
index|]
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w1
decl_stmt|,
modifier|*
name|w2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pos
decl_stmt|;
name|nid_t
name|nid1
decl_stmt|,
name|nid2
decl_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Looking for additional %sC "
literal|"for association %d (%d)\n"
argument|, 		    (as->dir == HDAA_CTL_OUT) ?
literal|"DA"
argument|:
literal|"AD"
argument|, 		    asid, as->index);
argument_list|)
empty_stmt|;
comment|/* Find the exisitng DAC position and return if found more the one. */
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pos
operator|>=
literal|0
operator|&&
name|as
operator|->
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|!=
name|as
operator|->
name|dacs
index|[
literal|0
index|]
index|[
name|pos
index|]
condition|)
return|return;
name|pos
operator|=
name|i
expr_stmt|;
block|}
name|nid1
operator|=
name|as
operator|->
name|dacs
index|[
literal|0
index|]
index|[
name|pos
index|]
expr_stmt|;
name|w1
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid1
argument_list|)
expr_stmt|;
name|w2
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|nid2
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|nid2
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|nid2
operator|++
control|)
block|{
name|w2
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid2
argument_list|)
expr_stmt|;
if|if
condition|(
name|w2
operator|==
name|NULL
operator|||
name|w2
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w2
operator|->
name|bindas
operator|>=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w1
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
condition|)
block|{
if|if
condition|(
name|w2
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
condition|)
continue|continue;
if|if
condition|(
name|hdaa_audio_dacs_equal
argument_list|(
name|w1
argument_list|,
name|w2
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|w2
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
if|if
condition|(
name|hdaa_audio_adcs_equal
argument_list|(
name|w1
argument_list|,
name|w2
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|nid2
operator|>=
name|devinfo
operator|->
name|endnode
condition|)
return|return;
name|w2
operator|->
name|bindas
operator|=
name|w1
operator|->
name|bindas
expr_stmt|;
name|w2
operator|->
name|bindseqmask
operator|=
name|w1
operator|->
name|bindseqmask
expr_stmt|;
if|if
condition|(
name|w1
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" ADC %d considered equal to ADC %d\n"
argument|, nid2, nid1);
argument_list|)
empty_stmt|;
name|w1
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w1
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|w2
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w2
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|w2
operator|->
name|bindas
operator|=
name|w1
operator|->
name|bindas
expr_stmt|;
name|w2
operator|->
name|bindseqmask
operator|=
name|w1
operator|->
name|bindseqmask
expr_stmt|;
block|}
else|else
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" DAC %d considered equal to DAC %d\n"
argument|, nid2, nid1);
argument_list|)
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|as
operator|->
name|dacs
index|[
name|as
operator|->
name|num_chans
index|]
index|[
name|i
index|]
operator|=
name|nid2
expr_stmt|;
block|}
name|as
operator|->
name|num_chans
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trace association path from input to ADC  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_trace_as_in
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|length
decl_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
name|as
condition|)
continue|continue;
comment|/* Find next pin */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Tracing pin %d to ADC %d\n"
argument|, 				    ases[as].pins[i], j);
argument_list|)
empty_stmt|;
comment|/* Trace this pin taking goal into account. */
if|if
condition|(
name|hdaa_audio_trace_adc
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
literal|0
argument_list|,
operator|&
name|length
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If we failed - return to previous and redo it. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Unable to trace pin %d to ADC %d, undo traces\n"
argument|, 					    ases[as].pins[i], j);
argument_list|)
empty_stmt|;
name|hdaa_audio_undo_trace
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|16
condition|;
name|k
operator|++
control|)
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Pin %d traced to ADC %d\n"
argument|, 				    ases[as].pins[i], j);
argument_list|)
empty_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|16
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trace association path from input to multiple ADCs  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_trace_as_in_mch
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|as
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|nid_t
name|min
decl_stmt|,
name|res
decl_stmt|;
comment|/* Find next pin */
for|for
control|(
name|i
operator|=
name|seq
init|;
name|i
operator|<
literal|16
operator|&&
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Check if there is no any left. If so - we succeeded. */
if|if
condition|(
name|i
operator|==
literal|16
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|min
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Tracing pin %d with min nid %d"
argument|, 			    ases[as].pins[i], min); 			printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
comment|/* Trace this pin taking min nid into account. */
name|res
operator|=
name|hdaa_audio_trace_adc
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|min
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
comment|/* If we failed - return to previous and redo it. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Unable to trace pin %d seq %d with min "
literal|"nid %d"
argument|, 				    ases[as].pins[i], i, min); 				printf(
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Pin %d traced to ADC %d\n"
argument|, 			    ases[as].pins[i], res);
argument_list|)
empty_stmt|;
comment|/* Trace again to mark the path */
name|hdaa_audio_trace_adc
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|,
name|ases
index|[
name|as
index|]
operator|.
name|pins
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|min
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
operator|&
name|length
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|res
expr_stmt|;
comment|/* We succeeded, so call next. */
if|if
condition|(
name|hdaa_audio_trace_as_in_mch
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If next failed, we should retry with next min */
name|hdaa_audio_undo_trace
argument_list|(
name|devinfo
argument_list|,
name|as
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ases
index|[
name|as
index|]
operator|.
name|dacs
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|min
operator|=
name|res
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Trace input monitor path from mixer to output association.  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_trace_to_out
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|nid_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*stracing via nid %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid);
argument_list|)
empty_stmt|;
comment|/* Use only unused widgets */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|w
operator|->
name|bindas
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|ases
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d found output association %d\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas);
argument_list|)
empty_stmt|;
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
condition|)
name|w
operator|->
name|pflags
operator||=
name|HDAA_ADC_MONITOR
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d busy by input association %d\n"
argument|, 					depth +
literal|1
argument|,
literal|""
argument|, w->nid, w->bindas);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
case|:
comment|/* Do not traverse input. AD1988 has digital monitor 		for which we are not ready. */
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
break|break;
comment|/* Fall */
default|default:
comment|/* Try to find reachable ADCs with specified nid. */
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|wc
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wc
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|wc
operator|->
name|conns
index|[
name|i
index|]
operator|!=
name|nid
condition|)
continue|continue;
if|if
condition|(
name|hdaa_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wc
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
name|wc
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|wc
operator|->
name|selconn
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
if|if
condition|(
name|res
operator|&&
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|bindas
operator|=
operator|-
literal|2
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" %*snid %d returned %d\n"
argument|, 			depth +
literal|1
argument|,
literal|""
argument|, w->nid, res);
argument_list|)
empty_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trace extra associations (beeper, monitor)  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_trace_as_extra
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Input monitor */
comment|/* Find mixer associated with input, but supplying signal 	   for output associations. Hope it will be input monitor. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Tracing input monitor\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|!=
name|HDAA_CTL_IN
condition|)
continue|continue;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Tracing nid %d to out\n"
argument|, 			    j);
argument_list|)
empty_stmt|;
if|if
condition|(
name|hdaa_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" nid %d is input monitor\n"
argument|, 					w->nid);
argument_list|)
empty_stmt|;
name|w
operator|->
name|ossdev
operator|=
name|SOUND_MIXER_IMIX
expr_stmt|;
block|}
block|}
comment|/* Other inputs monitor */
comment|/* Find input pins supplying signal for output associations. 	   Hope it will be input monitoring. */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Tracing other input monitors\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|!=
name|HDAA_CTL_IN
condition|)
continue|continue;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Tracing nid %d to out\n"
argument|, 			    j);
argument_list|)
empty_stmt|;
if|if
condition|(
name|hdaa_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" nid %d is input monitor\n"
argument|, 					w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Beeper */
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Tracing beeper\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|j
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
condition|)
continue|continue;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Tracing nid %d to out\n"
argument|, 			    j);
argument_list|)
empty_stmt|;
if|if
condition|(
name|hdaa_audio_trace_to_out
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" nid %d traced to out\n"
argument|, 				    j);
argument_list|)
empty_stmt|;
block|}
name|w
operator|->
name|bindas
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Bind assotiations to PCM channels  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_bind_as
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|,
name|free
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
condition|)
name|cnt
operator|+=
name|as
index|[
name|j
index|]
operator|.
name|num_chans
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|->
name|num_chans
operator|==
literal|0
condition|)
block|{
name|devinfo
operator|->
name|chans
operator|=
operator|(
expr|struct
name|hdaa_chan
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hdaa_chan
argument_list|)
operator|*
name|cnt
argument_list|,
name|M_HDAA
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|chans
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Channels memory allocation failed!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|devinfo
operator|->
name|chans
operator|=
operator|(
expr|struct
name|hdaa_chan
operator|*
operator|)
name|realloc
argument_list|(
name|devinfo
operator|->
name|chans
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdaa_chan
argument_list|)
operator|*
operator|(
name|devinfo
operator|->
name|num_chans
operator|+
name|cnt
operator|)
argument_list|,
name|M_HDAA
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|chans
operator|==
name|NULL
condition|)
block|{
name|devinfo
operator|->
name|num_chans
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Channels memory allocation failed!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fixup relative pointers after realloc */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|num_chans
condition|;
name|j
operator|++
control|)
name|devinfo
operator|->
name|chans
index|[
name|j
index|]
operator|.
name|caps
operator|.
name|fmtlist
operator|=
name|devinfo
operator|->
name|chans
index|[
name|j
index|]
operator|.
name|fmtlist
expr_stmt|;
block|}
name|free
operator|=
name|devinfo
operator|->
name|num_chans
expr_stmt|;
name|devinfo
operator|->
name|num_chans
operator|+=
name|cnt
expr_stmt|;
for|for
control|(
name|j
operator|=
name|free
init|;
name|j
operator|<
name|free
operator|+
name|cnt
condition|;
name|j
operator|++
control|)
block|{
name|devinfo
operator|->
name|chans
index|[
name|j
index|]
operator|.
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|devinfo
operator|->
name|chans
index|[
name|j
index|]
operator|.
name|as
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Assign associations in order of their numbers, */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|as
index|[
name|j
index|]
operator|.
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|->
name|chans
index|[
name|free
index|]
operator|.
name|as
operator|=
name|j
expr_stmt|;
name|devinfo
operator|->
name|chans
index|[
name|free
index|]
operator|.
name|asindex
operator|=
name|i
expr_stmt|;
name|devinfo
operator|->
name|chans
index|[
name|free
index|]
operator|.
name|dir
operator|=
operator|(
name|as
index|[
name|j
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
operator|)
condition|?
name|PCMDIR_REC
else|:
name|PCMDIR_PLAY
expr_stmt|;
name|hdaa_pcmchannel_setup
argument_list|(
operator|&
name|devinfo
operator|->
name|chans
index|[
name|free
index|]
argument_list|)
expr_stmt|;
name|as
index|[
name|j
index|]
operator|.
name|chans
index|[
name|i
index|]
operator|=
name|free
expr_stmt|;
name|free
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_disable_nonaudio
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable power and volume widgets. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_POWER_WIDGET
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_VOLUME_WIDGET
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling nid %d due to it's"
literal|" non-audio type.\n"
argument|, 				    w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_disable_useless
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|done
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Disable useless pins. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_NONE
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling pin nid %d due"
literal|" to None connectivity.\n"
argument|, 					    w->nid);
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling unassociated"
literal|" pin nid %d.\n"
argument|, 					    w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
do|do
block|{
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Disable and mute controls for disabled widgets. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdaa_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|enable
operator|==
literal|0
operator|||
operator|(
name|ctl
operator|->
name|childwidget
operator|!=
name|NULL
operator|&&
name|ctl
operator|->
name|childwidget
operator|->
name|enable
operator|==
literal|0
operator|)
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDAA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|ndir
operator|==
name|HDAA_CTL_IN
condition|)
name|ctl
operator|->
name|widget
operator|->
name|connsenable
index|[
name|ctl
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling ctl %d nid %d cnid %d due"
literal|" to disabled widget.\n"
argument|, i, 					    ctl->widget->nid, 					    (ctl->childwidget != NULL)? 					    ctl->childwidget->nid:-
literal|1
argument|);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Disable useless widgets. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
comment|/* Disable inputs with disabled child widgets. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
block|{
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling nid %d connection %d due"
literal|" to disabled child widget.\n"
argument|, 							    i, j);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
comment|/* Disable mixers and selectors without inputs. */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling nid %d due to all it's"
literal|" inputs disabled.\n"
argument|, w->nid);
argument_list|)
empty_stmt|;
block|}
comment|/* Disable nodes without consumers. */
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_SELECTOR
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|k
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|k
operator|++
control|)
block|{
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cw
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cw
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|cw
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling nid %d due to all it's"
literal|" consumers disabled.\n"
argument|, w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_disable_unas
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Disable unassosiated widgets. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
block|{
name|w
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling unassociated nid %d.\n"
argument|, 				    w->nid);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* Disable input connections on input pin and 	 * output on output. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling connection to input pin "
literal|"nid %d conn %d.\n"
argument|, 					    i, j);
argument_list|)
empty_stmt|;
block|}
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
name|ctl
operator|->
name|enable
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDAA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
name|ctl
operator|->
name|enable
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDAA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|k
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|k
operator|++
control|)
block|{
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cw
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cw
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|cw
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|cw
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling connection from output pin "
literal|"nid %d conn %d cnid %d.\n"
argument|, 							    k, j, i);
argument_list|)
empty_stmt|;
if|if
condition|(
name|cw
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|cw
operator|->
name|nconns
operator|>
literal|1
condition|)
continue|continue;
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|k
argument_list|,
name|HDAA_CTL_IN
argument_list|,
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
name|ctl
operator|->
name|enable
condition|)
block|{
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDAA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_disable_notselected
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* On playback path we can safely disable all unseleted inputs. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nconns
operator|<=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|selconn
operator|<
literal|0
operator|||
name|w
operator|->
name|selconn
operator|==
name|j
condition|)
continue|continue;
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling unselected connection "
literal|"nid %d conn %d.\n"
argument|, 				    i, j);
argument_list|)
empty_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_disable_crossas
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|ases
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Disable crossassociatement and unwanted crosschannel connections. */
comment|/* ... using selectors */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|nconns
operator|<=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
continue|continue;
comment|/* Allow any -> mix */
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|2
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allow mix -> out. */
if|if
condition|(
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|ases
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
continue|continue;
comment|/* Allow mix -> mixed-in. */
if|if
condition|(
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|w
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|ases
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|mixed
condition|)
continue|continue;
comment|/* Allow in -> mix. */
if|if
condition|(
operator|(
name|w
operator|->
name|pflags
operator|&
name|HDAA_ADC_MONITOR
operator|)
operator|&&
name|cw
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|ases
index|[
name|cw
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
continue|continue;
comment|/* Allow if have common as/seqs. */
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
name|cw
operator|->
name|bindas
operator|&&
operator|(
name|w
operator|->
name|bindseqmask
operator|&
name|cw
operator|->
name|bindseqmask
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling crossassociatement connection "
literal|"nid %d conn %d cnid %d.\n"
argument|, 				    i, j, cw->nid);
argument_list|)
empty_stmt|;
block|}
block|}
comment|/* ... using controls */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdaa_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|childwidget
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Allow any -> mix */
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
condition|)
continue|continue;
comment|/* Allow mix -> out. */
if|if
condition|(
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|ases
index|[
name|ctl
operator|->
name|widget
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
continue|continue;
comment|/* Allow mix -> mixed-in. */
if|if
condition|(
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|ases
index|[
name|ctl
operator|->
name|widget
operator|->
name|bindas
index|]
operator|.
name|mixed
condition|)
continue|continue;
comment|/* Allow in -> mix. */
if|if
condition|(
operator|(
name|ctl
operator|->
name|widget
operator|->
name|pflags
operator|&
name|HDAA_ADC_MONITOR
operator|)
operator|&&
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|ases
index|[
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
continue|continue;
comment|/* Allow if have common as/seqs. */
if|if
condition|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|ctl
operator|->
name|childwidget
operator|->
name|bindas
operator|&&
operator|(
name|ctl
operator|->
name|widget
operator|->
name|bindseqmask
operator|&
name|ctl
operator|->
name|childwidget
operator|->
name|bindseqmask
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|ctl
operator|->
name|forcemute
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|muted
operator|=
name|HDAA_AMP_MUTE_ALL
expr_stmt|;
name|ctl
operator|->
name|left
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|ctl
operator|->
name|enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|ndir
operator|==
name|HDAA_CTL_IN
condition|)
name|ctl
operator|->
name|widget
operator|->
name|connsenable
index|[
name|ctl
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|" Disabling crossassociatement connection "
literal|"ctl %d nid %d cnid %d.\n"
argument|, i, 			    ctl->widget->nid, 			    ctl->childwidget->nid);
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find controls to control amplification for source and calculate possible  * amplification range.  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_ctl_source_amp
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|int
name|ctlable
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
modifier|*
name|minamp
parameter_list|,
name|int
modifier|*
name|maxamp
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|conns
init|=
literal|0
decl_stmt|,
name|tminamp
decl_stmt|,
name|tmaxamp
decl_stmt|,
name|cminamp
decl_stmt|,
name|cmaxamp
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
name|found
operator|)
return|;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
name|found
operator|)
return|;
comment|/* Count number of active inputs. */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
continue|continue;
name|conns
operator|++
expr_stmt|;
block|}
block|}
comment|/* If this is not a first step - use input mixer. 	   Pins have common input ctl so care must be taken. */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|ctlable
operator|&&
operator|(
name|conns
operator|==
literal|1
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
condition|)
block|{
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|minamp
operator|==
operator|*
name|maxamp
condition|)
block|{
operator|*
name|minamp
operator|+=
name|MINQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
operator|*
name|maxamp
operator|+=
name|MAXQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If widget has own ossdev - not traverse it. 	   It will be traversed on it's own. */
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return
operator|(
name|found
operator|)
return|;
comment|/* We must not traverse pin */
if|if
condition|(
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|)
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return
operator|(
name|found
operator|)
return|;
comment|/* record that this widget exports such signal, */
name|w
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
comment|/* 	 * If signals mixed, we can't assign controls farther. 	 * Ignore this on depth zero. Caller must knows why. 	 */
if|if
condition|(
name|conns
operator|>
literal|1
operator|&&
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
name|ctlable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlable
condition|)
block|{
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|minamp
operator|==
operator|*
name|maxamp
condition|)
block|{
operator|*
name|minamp
operator|+=
name|MINQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
operator|*
name|maxamp
operator|+=
name|MAXQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cminamp
operator|=
name|cmaxamp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wc
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|wc
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|nid
condition|)
block|{
name|tminamp
operator|=
name|tmaxamp
operator|=
literal|0
expr_stmt|;
name|found
operator|+=
name|hdaa_audio_ctl_source_amp
argument_list|(
name|devinfo
argument_list|,
name|wc
operator|->
name|nid
argument_list|,
name|j
argument_list|,
name|ossdev
argument_list|,
name|ctlable
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
operator|&
name|tminamp
argument_list|,
operator|&
name|tmaxamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cminamp
operator|==
literal|0
operator|&&
name|cmaxamp
operator|==
literal|0
condition|)
block|{
name|cminamp
operator|=
name|tminamp
expr_stmt|;
name|cmaxamp
operator|=
name|tmaxamp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tminamp
operator|!=
name|tmaxamp
condition|)
block|{
name|cminamp
operator|=
name|imax
argument_list|(
name|cminamp
argument_list|,
name|tminamp
argument_list|)
expr_stmt|;
name|cmaxamp
operator|=
name|imin
argument_list|(
name|cmaxamp
argument_list|,
name|tmaxamp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|*
name|minamp
operator|==
operator|*
name|maxamp
operator|&&
name|cminamp
operator|<
name|cmaxamp
condition|)
block|{
operator|*
name|minamp
operator|+=
name|cminamp
expr_stmt|;
operator|*
name|maxamp
operator|+=
name|cmaxamp
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find controls to control amplification for destination and calculate  * possible amplification range.  */
end_comment

begin_function
specifier|static
name|int
name|hdaa_audio_ctl_dest_amp
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
modifier|*
name|minamp
parameter_list|,
name|int
modifier|*
name|maxamp
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|wc
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|consumers
decl_stmt|,
name|tminamp
decl_stmt|,
name|tmaxamp
decl_stmt|,
name|cminamp
decl_stmt|,
name|cmaxamp
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return
operator|(
name|found
operator|)
return|;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return
operator|(
name|found
operator|)
return|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
comment|/* If this node produce output for several consumers, 		   we can't touch it. */
name|consumers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|NULL
operator|||
name|wc
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wc
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|->
name|connsenable
index|[
name|j
index|]
operator|&&
name|wc
operator|->
name|conns
index|[
name|j
index|]
operator|==
name|nid
condition|)
name|consumers
operator|++
expr_stmt|;
block|}
block|}
comment|/* The only exception is if real HP redirection is configured 		   and this is a duplication point. 		   XXX: Actually exception is not completely correct. 		   XXX: Duplication point check is not perfect. */
if|if
condition|(
operator|(
name|consumers
operator|==
literal|2
operator|&&
operator|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|hpredir
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|fakeredir
operator|||
operator|(
name|w
operator|->
name|bindseqmask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
name|consumers
operator|>
literal|2
condition|)
return|return
operator|(
name|found
operator|)
return|;
comment|/* Else use it's output mixer. */
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_OUT
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|minamp
operator|==
operator|*
name|maxamp
condition|)
block|{
operator|*
name|minamp
operator|+=
name|MINQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
operator|*
name|maxamp
operator|+=
name|MAXQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We must not traverse pin */
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|depth
operator|>
literal|0
condition|)
return|return
operator|(
name|found
operator|)
return|;
name|cminamp
operator|=
name|cmaxamp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|i
operator|!=
name|index
condition|)
continue|continue;
name|tminamp
operator|=
name|tmaxamp
operator|=
literal|0
expr_stmt|;
name|ctl
operator|=
name|hdaa_audio_ctl_amp_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|HDAA_CTL_IN
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
condition|)
block|{
name|ctl
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|minamp
operator|==
operator|*
name|maxamp
condition|)
block|{
name|tminamp
operator|+=
name|MINQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|tmaxamp
operator|+=
name|MAXQDB
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
name|found
operator|+=
name|hdaa_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|ossdev
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
operator|&
name|tminamp
argument_list|,
operator|&
name|tmaxamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cminamp
operator|==
literal|0
operator|&&
name|cmaxamp
operator|==
literal|0
condition|)
block|{
name|cminamp
operator|=
name|tminamp
expr_stmt|;
name|cmaxamp
operator|=
name|tmaxamp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tminamp
operator|!=
name|tmaxamp
condition|)
block|{
name|cminamp
operator|=
name|imax
argument_list|(
name|cminamp
argument_list|,
name|tminamp
argument_list|)
expr_stmt|;
name|cmaxamp
operator|=
name|imin
argument_list|(
name|cmaxamp
argument_list|,
name|tmaxamp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|minamp
operator|==
operator|*
name|maxamp
operator|&&
name|cminamp
operator|<
name|cmaxamp
condition|)
block|{
operator|*
name|minamp
operator|+=
name|cminamp
expr_stmt|;
operator|*
name|maxamp
operator|+=
name|cmaxamp
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assign OSS names to sound sources  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_assign_names
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|,
name|use
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|int
name|types
index|[
literal|7
index|]
index|[
literal|13
index|]
init|=
block|{
block|{
name|SOUND_MIXER_LINE
block|,
name|SOUND_MIXER_LINE1
block|,
name|SOUND_MIXER_LINE2
block|,
name|SOUND_MIXER_LINE3
block|,
operator|-
literal|1
block|}
block|,
comment|/* line */
block|{
name|SOUND_MIXER_MONITOR
block|,
name|SOUND_MIXER_MIC
block|,
operator|-
literal|1
block|}
block|,
comment|/* int mic */
block|{
name|SOUND_MIXER_MIC
block|,
name|SOUND_MIXER_MONITOR
block|,
operator|-
literal|1
block|}
block|,
comment|/* ext mic */
block|{
name|SOUND_MIXER_CD
block|,
operator|-
literal|1
block|}
block|,
comment|/* cd */
block|{
name|SOUND_MIXER_SPEAKER
block|,
operator|-
literal|1
block|}
block|,
comment|/* speaker */
block|{
name|SOUND_MIXER_DIGITAL1
block|,
name|SOUND_MIXER_DIGITAL2
block|,
name|SOUND_MIXER_DIGITAL3
block|,
operator|-
literal|1
block|}
block|,
comment|/* digital */
block|{
name|SOUND_MIXER_LINE
block|,
name|SOUND_MIXER_LINE1
block|,
name|SOUND_MIXER_LINE2
block|,
name|SOUND_MIXER_LINE3
block|,
name|SOUND_MIXER_PHONEIN
block|,
name|SOUND_MIXER_PHONEOUT
block|,
name|SOUND_MIXER_VIDEO
block|,
name|SOUND_MIXER_RADIO
block|,
name|SOUND_MIXER_DIGITAL1
block|,
name|SOUND_MIXER_DIGITAL2
block|,
name|SOUND_MIXER_DIGITAL3
block|,
name|SOUND_MIXER_MONITOR
block|,
operator|-
literal|1
block|}
comment|/* others */
block|}
decl_stmt|;
comment|/* Surely known names */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|use
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|type
condition|)
block|{
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
case|:
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
break|break;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_IN
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
case|:
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY_JACK
condition|)
break|break;
name|type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_CD
case|:
name|type
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
case|:
name|type
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_IN
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_IN
case|:
name|type
operator|=
literal|5
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
break|break;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
operator|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|use
operator|=
name|types
index|[
name|type
index|]
index|[
name|j
index|]
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
case|:
name|use
operator|=
name|SOUND_MIXER_PCM
expr_stmt|;
break|break;
case|case
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
case|:
name|use
operator|=
name|SOUND_MIXER_SPEAKER
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|use
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|ossdev
operator|=
name|use
expr_stmt|;
name|used
operator||=
operator|(
literal|1
operator|<<
name|use
operator|)
expr_stmt|;
block|}
block|}
comment|/* Semi-known names */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
continue|continue;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
condition|)
block|{
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_LINE_OUT
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPEAKER
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_AUX
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MIC_IN
case|:
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_SPDIF_OUT
case|:
case|case
name|HDA_CONFIG_DEFAULTCONF_DEVICE_DIGITAL_OTHER_OUT
case|:
name|type
operator|=
literal|5
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
break|break;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
operator|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|ossdev
operator|=
name|types
index|[
name|type
index|]
index|[
name|j
index|]
expr_stmt|;
name|used
operator||=
operator|(
literal|1
operator|<<
name|types
index|[
name|type
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* Others */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
continue|continue;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
operator|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|>=
literal|0
condition|)
block|{
name|w
operator|->
name|ossdev
operator|=
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
expr_stmt|;
name|used
operator||=
operator|(
literal|1
operator|<<
name|types
index|[
literal|6
index|]
index|[
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_build_tree
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|int
name|j
decl_stmt|,
name|res
decl_stmt|;
comment|/* Trace all associations in order of their numbers. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Tracing association %d (%d)\n"
argument|, j, as[j].index);
argument_list|)
empty_stmt|;
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
block|{
name|retry
label|:
name|res
operator|=
name|hdaa_audio_trace_as_out
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
operator|&&
name|as
index|[
name|j
index|]
operator|.
name|hpredir
operator|>=
literal|0
operator|&&
name|as
index|[
name|j
index|]
operator|.
name|fakeredir
operator|==
literal|0
condition|)
block|{
comment|/* If CODEC can't do analog HP redirection 				   try to make it using one more DAC. */
name|as
index|[
name|j
index|]
operator|.
name|fakeredir
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|mixed
condition|)
name|res
operator|=
name|hdaa_audio_trace_as_in
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|hdaa_audio_trace_as_in_mch
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Association %d (%d) trace succeeded\n"
argument|, 				    j, as[j].index);
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"Association %d (%d) trace failed\n"
argument|, 				    j, as[j].index);
argument_list|)
empty_stmt|;
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Look for additional DACs/ADCs. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|j
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|hdaa_audio_adddac
argument_list|(
name|devinfo
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Trace mixer and beeper pseudo associations. */
name|hdaa_audio_trace_as_extra
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store in pdevinfo new data about whether and how we can control signal  * for OSS device to/from specified widget.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_adjust_amp
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|,
name|int
name|ossdev
parameter_list|,
name|int
name|found
parameter_list|,
name|int
name|minamp
parameter_list|,
name|int
name|maxamp
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|w
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|bindas
operator|>=
literal|0
condition|)
name|pdevinfo
operator|=
name|devinfo
operator|->
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|pdevinfo
expr_stmt|;
else|else
name|pdevinfo
operator|=
operator|&
name|devinfo
operator|->
name|devs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|pdevinfo
operator|->
name|ossmask
operator||=
operator|(
literal|1
operator|<<
name|ossdev
operator|)
expr_stmt|;
if|if
condition|(
name|minamp
operator|==
literal|0
operator|&&
name|maxamp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pdevinfo
operator|->
name|minamp
index|[
name|ossdev
index|]
operator|==
literal|0
operator|&&
name|pdevinfo
operator|->
name|maxamp
index|[
name|ossdev
index|]
operator|==
literal|0
condition|)
block|{
name|pdevinfo
operator|->
name|minamp
index|[
name|ossdev
index|]
operator|=
name|minamp
expr_stmt|;
name|pdevinfo
operator|->
name|maxamp
index|[
name|ossdev
index|]
operator|=
name|maxamp
expr_stmt|;
block|}
else|else
block|{
name|pdevinfo
operator|->
name|minamp
index|[
name|ossdev
index|]
operator|=
name|imax
argument_list|(
name|pdevinfo
operator|->
name|minamp
index|[
name|ossdev
index|]
argument_list|,
name|minamp
argument_list|)
expr_stmt|;
name|pdevinfo
operator|->
name|maxamp
index|[
name|ossdev
index|]
operator|=
name|imin
argument_list|(
name|pdevinfo
operator|->
name|maxamp
index|[
name|ossdev
index|]
argument_list|,
name|maxamp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Trace signals from/to all possible sources/destionstions to find possible  * recording sources, OSS device control ranges and to assign controls.  */
end_comment

begin_function
specifier|static
name|void
name|hdaa_audio_assign_mixers
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|minamp
decl_stmt|,
name|maxamp
decl_stmt|,
name|found
decl_stmt|;
comment|/* Assign mixers to the tree. */
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|minamp
operator|=
name|maxamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_BEEP_WIDGET
operator|||
operator|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|ossdev
operator|<
literal|0
condition|)
continue|continue;
name|found
operator|=
name|hdaa_audio_ctl_source_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|minamp
argument_list|,
operator|&
name|maxamp
argument_list|)
expr_stmt|;
name|hdaa_adjust_amp
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
name|found
argument_list|,
name|minamp
argument_list|,
name|maxamp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|found
operator|=
name|hdaa_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|SOUND_MIXER_RECLEV
argument_list|,
literal|0
argument_list|,
operator|&
name|minamp
argument_list|,
operator|&
name|maxamp
argument_list|)
expr_stmt|;
name|hdaa_adjust_amp
argument_list|(
name|w
argument_list|,
name|SOUND_MIXER_RECLEV
argument_list|,
name|found
argument_list|,
name|minamp
argument_list|,
name|maxamp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_OUT
condition|)
block|{
name|found
operator|=
name|hdaa_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
literal|0
argument_list|,
operator|&
name|minamp
argument_list|,
operator|&
name|maxamp
argument_list|)
expr_stmt|;
name|hdaa_adjust_amp
argument_list|(
name|w
argument_list|,
name|SOUND_MIXER_VOLUME
argument_list|,
name|found
argument_list|,
name|minamp
argument_list|,
name|maxamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|ossdev
operator|==
name|SOUND_MIXER_IMIX
condition|)
block|{
name|minamp
operator|=
name|maxamp
operator|=
literal|0
expr_stmt|;
name|found
operator|=
name|hdaa_audio_ctl_source_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|minamp
argument_list|,
operator|&
name|maxamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|minamp
operator|==
name|maxamp
condition|)
block|{
comment|/* If we are unable to control input monitor 				   as source - try to control it as destination. */
name|found
operator|+=
name|hdaa_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|-
literal|1
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
literal|0
argument_list|,
operator|&
name|minamp
argument_list|,
operator|&
name|maxamp
argument_list|)
expr_stmt|;
name|w
operator|->
name|pflags
operator||=
name|HDAA_IMIX_AS_DST
expr_stmt|;
block|}
name|hdaa_adjust_amp
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|ossdev
argument_list|,
name|found
argument_list|,
name|minamp
argument_list|,
name|maxamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|pflags
operator|&
name|HDAA_ADC_MONITOR
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|w
operator|->
name|connsenable
index|[
name|j
index|]
condition|)
continue|continue;
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cw
operator|->
name|bindas
operator|>=
literal|0
operator|&&
name|as
index|[
name|cw
operator|->
name|bindas
index|]
operator|.
name|dir
operator|!=
name|HDAA_CTL_IN
condition|)
continue|continue;
name|minamp
operator|=
name|maxamp
operator|=
literal|0
expr_stmt|;
name|found
operator|=
name|hdaa_audio_ctl_dest_amp
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|j
argument_list|,
name|SOUND_MIXER_IGAIN
argument_list|,
literal|0
argument_list|,
operator|&
name|minamp
argument_list|,
operator|&
name|maxamp
argument_list|)
expr_stmt|;
name|hdaa_adjust_amp
argument_list|(
name|w
argument_list|,
name|SOUND_MIXER_IGAIN
argument_list|,
name|found
argument_list|,
name|minamp
argument_list|,
name|maxamp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_prepare_pin_ctrl
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|pincap
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|nodecnt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
operator|&
name|devinfo
operator|->
name|widget
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|&&
name|w
operator|->
name|waspin
operator|==
literal|0
condition|)
continue|continue;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
comment|/* Disable everything. */
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&=
operator|~
operator|(
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
operator||
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
block|{
comment|/* Pin is unused so left it disabled. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|waspin
condition|)
block|{
comment|/* Enable input for beeper input. */
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|bindas
operator|<
literal|0
operator|||
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
comment|/* Pin is unused so left it disabled. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|as
index|[
name|w
operator|->
name|bindas
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
block|{
comment|/* Input pin, configure for input. */
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_IVREF100
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_IVREF80
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_80
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_IVREF50
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_50
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output pin, configure for output. */
if|if
condition|(
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
operator|&&
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|&
name|HDA_CONFIG_DEFAULTCONF_DEVICE_MASK
operator|)
operator|==
name|HDA_CONFIG_DEFAULTCONF_DEVICE_HP_OUT
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_OVREF100
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_OVREF80
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_80
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_OVREF50
operator|)
operator|&&
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50
argument_list|(
name|pincap
argument_list|)
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator||=
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE
argument_list|(
name|HDA_CMD_PIN_WIDGET_CTRL_VREF_ENABLE_50
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_ctl_commit
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdaa_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|ossmask
operator|!=
literal|0
condition|)
block|{
comment|/* Mute disabled and mixer controllable controls. 			 * Last will be initialized by mixer_init(). 			 * This expected to reduce click on startup. */
name|hdaa_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDAA_AMP_MUTE_ALL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Init fixed controls to 0dB amplification. */
name|z
operator|=
name|ctl
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|z
operator|>
name|ctl
operator|->
name|step
condition|)
name|z
operator|=
name|ctl
operator|->
name|step
expr_stmt|;
name|hdaa_audio_ctl_amp_set
argument_list|(
name|ctl
argument_list|,
name|HDAA_AMP_MUTE_NONE
argument_list|,
name|z
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_gpio_commit
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|uint32_t
name|gdata
decl_stmt|,
name|gmask
decl_stmt|,
name|gdir
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numgpio
decl_stmt|;
name|numgpio
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|gpio
operator|!=
literal|0
operator|&&
name|numgpio
operator|!=
literal|0
condition|)
block|{
name|gdata
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|gmask
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|gdir
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_DIRECTION
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpio
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|devinfo
operator|->
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|HDAA_GPIO_SET
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|gdata
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|gmask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|gdir
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|HDAA_GPIO_CLEAR
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|gdata
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|gmask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|gdir
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|HDAA_GPIO_DISABLE
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|gmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|HDAA_GPIO_INPUT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|gmask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|gdir
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"GPIO commit\n"
argument|);
argument_list|)
empty_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_GPIO_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gmask
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_GPIO_DIRECTION
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdir
argument_list|)
argument_list|)
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_GPIO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdata
argument_list|)
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|hdaa_dump_gpio(devinfo);
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_gpo_commit
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|uint32_t
name|gdata
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numgpo
decl_stmt|;
name|numgpo
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|gpo
operator|!=
literal|0
operator|&&
name|numgpo
operator|!=
literal|0
condition|)
block|{
name|gdata
operator|=
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_GET_GPO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpo
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|devinfo
operator|->
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|HDAA_GPIO_SET
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|gdata
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|devinfo
operator|->
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|HDAA_GPIO_CLEAR
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|gdata
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(devinfo->dev,
literal|"GPO commit\n"
argument|);
argument_list|)
empty_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_GPO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|gdata
argument_list|)
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|hdaa_dump_gpo(devinfo);
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_audio_commit
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Commit controls. */
name|hdaa_audio_ctl_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
comment|/* Commit selectors, pins and EAPD. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|nodecnt
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
operator|&
name|devinfo
operator|->
name|widget
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|selconn
operator|==
operator|-
literal|1
condition|)
name|w
operator|->
name|selconn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|0
condition|)
name|hdaa_widget_connection_select
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|selconn
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|waspin
condition|)
block|{
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_PIN_WIDGET_CTRL
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDA_INVALID
condition|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|w
operator|->
name|param
operator|.
name|eapdbtl
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_EAPDINV
condition|)
name|val
operator|^=
name|HDA_CMD_SET_EAPD_BTL_ENABLE_EAPD
expr_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_EAPD_BTL_ENABLE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|hdaa_gpio_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_gpo_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_powerup
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D0
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
name|HDA_CMD_POWER_STATE_D0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_pcmchannel_setup
parameter_list|(
name|struct
name|hdaa_chan
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|ch
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|cap
decl_stmt|,
name|fmtcap
decl_stmt|,
name|pcmcap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|,
name|channels
decl_stmt|,
name|onlystereo
decl_stmt|;
name|uint16_t
name|pinset
decl_stmt|;
name|ch
operator|->
name|caps
operator|=
name|hdaa_caps
expr_stmt|;
name|ch
operator|->
name|caps
operator|.
name|fmtlist
operator|=
name|ch
operator|->
name|fmtlist
expr_stmt|;
name|ch
operator|->
name|bit16
operator|=
literal|1
expr_stmt|;
name|ch
operator|->
name|bit32
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
operator|=
literal|48000
expr_stmt|;
name|ch
operator|->
name|pcmrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|stripecap
operator|=
literal|0xff
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|channels
operator|=
literal|0
expr_stmt|;
name|onlystereo
operator|=
literal|1
expr_stmt|;
name|pinset
operator|=
literal|0
expr_stmt|;
name|fmtcap
operator|=
name|devinfo
operator|->
name|supp_stream_formats
expr_stmt|;
name|pcmcap
operator|=
name|devinfo
operator|->
name|supp_pcm_size_rate
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check as is correct */
if|if
condition|(
name|ch
operator|->
name|as
operator|<
literal|0
condition|)
break|break;
comment|/* Cound only present DACs */
if|if
condition|(
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|ch
operator|->
name|asindex
index|]
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
comment|/* Ignore duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ret
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|io
index|[
name|j
index|]
operator|==
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|ch
operator|->
name|asindex
index|]
index|[
name|i
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|ret
condition|)
continue|continue;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|ch
operator|->
name|asindex
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
name|cap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
expr_stmt|;
if|if
condition|(
operator|!
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|cap
argument_list|)
operator|&&
operator|!
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|cap
argument_list|)
condition|)
continue|continue;
comment|/* Many CODECs does not declare AC3 support on SPDIF. 		   I don't beleave that they doesn't support it! */
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|cap
operator||=
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3_MASK
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|fmtcap
operator|=
name|cap
expr_stmt|;
name|pcmcap
operator|=
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
else|else
block|{
name|fmtcap
operator|&=
name|cap
expr_stmt|;
name|pcmcap
operator|&=
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
expr_stmt|;
block|}
name|ch
operator|->
name|io
index|[
name|ret
operator|++
index|]
operator|=
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|dacs
index|[
name|ch
operator|->
name|asindex
index|]
index|[
name|i
index|]
expr_stmt|;
name|ch
operator|->
name|stripecap
operator|&=
name|w
operator|->
name|wclass
operator|.
name|conv
operator|.
name|stripecap
expr_stmt|;
comment|/* Do not count redirection pin/dac channels. */
if|if
condition|(
name|i
operator|==
literal|15
operator|&&
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|hpredir
operator|>=
literal|0
condition|)
continue|continue;
name|channels
operator|+=
name|HDA_PARAM_AUDIO_WIDGET_CAP_CC
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_CC
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|!=
literal|1
condition|)
name|onlystereo
operator|=
literal|0
expr_stmt|;
name|pinset
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|ch
operator|->
name|io
index|[
name|ret
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|->
name|channels
operator|=
name|channels
expr_stmt|;
if|if
condition|(
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|fakeredir
condition|)
name|ret
operator|--
expr_stmt|;
comment|/* Standard speaks only about stereo pins and playback, ... */
if|if
condition|(
operator|(
operator|!
name|onlystereo
operator|)
operator|||
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|mixed
condition|)
name|pinset
operator|=
literal|0
expr_stmt|;
comment|/* ..., but there it gives us info about speakers layout. */
name|as
index|[
name|ch
operator|->
name|as
index|]
operator|.
name|pinset
operator|=
name|pinset
expr_stmt|;
name|ch
operator|->
name|supp_stream_formats
operator|=
name|fmtcap
expr_stmt|;
name|ch
operator|->
name|supp_pcm_size_rate
operator|=
name|pcmcap
expr_stmt|;
comment|/* 	 *  8bit = 0 	 * 16bit = 1 	 * 20bit = 2 	 * 24bit = 3 	 * 32bit = 4 	 */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|fmtcap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit16
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit16
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|devinfo
operator|->
name|quirks
operator|&
name|HDAA_QUIRK_FORCESTEREO
operator|)
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channels
operator|>=
literal|2
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channels
operator|>=
literal|3
operator|&&
operator|!
name|onlystereo
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channels
operator|>=
literal|4
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onlystereo
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|channels
operator|>=
literal|5
operator|&&
operator|!
name|onlystereo
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channels
operator|>=
literal|6
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onlystereo
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|channels
operator|>=
literal|7
operator|&&
operator|!
name|onlystereo
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|channels
operator|>=
literal|8
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|bit32
condition|)
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|fmtcap
argument_list|)
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_AC3
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
operator|>=
literal|8
condition|)
block|{
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_AC3
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmtlist
index|[
name|i
operator|++
index|]
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_AC3
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ch
operator|->
name|fmtlist
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|8000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_11KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|11025
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|16000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_22KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|22050
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|32000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_44KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|44100
expr_stmt|;
comment|/* if (HDA_PARAM_SUPP_PCM_SIZE_RATE_48KHZ(pcmcap)) */
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|48000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_88KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|88200
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_96KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|96000
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_176KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|176400
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_192KHZ
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|++
index|]
operator|=
literal|192000
expr_stmt|;
comment|/* if (HDA_PARAM_SUPP_PCM_SIZE_RATE_384KHZ(pcmcap)) */
name|ch
operator|->
name|pcmrates
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ch
operator|->
name|caps
operator|.
name|minspeed
operator|=
name|ch
operator|->
name|pcmrates
index|[
literal|0
index|]
expr_stmt|;
name|ch
operator|->
name|caps
operator|.
name|maxspeed
operator|=
name|ch
operator|->
name|pcmrates
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_prepare_pcms
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
name|devinfo
operator|->
name|as
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|apdev
init|=
literal|0
decl_stmt|,
name|ardev
init|=
literal|0
decl_stmt|,
name|dpdev
init|=
literal|0
decl_stmt|,
name|drdev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|digital
condition|)
name|drdev
operator|++
expr_stmt|;
else|else
name|ardev
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|digital
condition|)
name|dpdev
operator|++
expr_stmt|;
else|else
name|apdev
operator|++
expr_stmt|;
block|}
block|}
name|devinfo
operator|->
name|num_devs
operator|=
name|max
argument_list|(
name|ardev
argument_list|,
name|apdev
argument_list|)
operator|+
name|max
argument_list|(
name|drdev
argument_list|,
name|dpdev
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|devs
operator|=
operator|(
expr|struct
name|hdaa_pcm_devinfo
operator|*
operator|)
name|malloc
argument_list|(
name|devinfo
operator|->
name|num_devs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hdaa_pcm_devinfo
argument_list|)
argument_list|,
name|M_HDAA
argument_list|,
name|M_ZERO
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|devs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Unable to allocate memory for devices\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|num_devs
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
operator|.
name|devinfo
operator|=
name|devinfo
expr_stmt|;
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
operator|.
name|playas
operator|=
operator|-
literal|1
expr_stmt|;
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
operator|.
name|recas
operator|=
operator|-
literal|1
expr_stmt|;
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
operator|.
name|digital
operator|=
literal|255
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|ascnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|devinfo
operator|->
name|num_devs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|digital
operator|!=
literal|255
operator|&&
operator|(
operator|!
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|digital
operator|)
operator|!=
operator|(
operator|!
name|as
index|[
name|i
index|]
operator|.
name|digital
operator|)
condition|)
continue|continue;
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|dir
operator|==
name|HDAA_CTL_IN
condition|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|recas
operator|>=
literal|0
condition|)
continue|continue;
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|recas
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|playas
operator|>=
literal|0
condition|)
continue|continue;
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|playas
operator|=
name|i
expr_stmt|;
block|}
name|as
index|[
name|i
index|]
operator|.
name|pdevinfo
operator|=
operator|&
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|as
index|[
name|i
index|]
operator|.
name|num_chans
condition|;
name|k
operator|++
control|)
block|{
name|devinfo
operator|->
name|chans
index|[
name|as
index|[
name|i
index|]
operator|.
name|chans
index|[
name|k
index|]
index|]
operator|.
name|pdevinfo
operator|=
operator|&
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
expr_stmt|;
block|}
name|devinfo
operator|->
name|devs
index|[
name|j
index|]
operator|.
name|digital
operator|=
name|as
index|[
name|i
index|]
operator|.
name|digital
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_create_pcms
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|num_devs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|&
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
decl_stmt|;
name|pdevinfo
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pdevinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_ctls
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|banner
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|printed
decl_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
operator|~
operator|(
name|SOUND_MASK_VOLUME
operator||
name|SOUND_MASK_PCM
operator||
name|SOUND_MASK_CD
operator||
name|SOUND_MASK_LINE
operator||
name|SOUND_MASK_RECLEV
operator||
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_SPEAKER
operator||
name|SOUND_MASK_IGAIN
operator||
name|SOUND_MASK_OGAIN
operator||
name|SOUND_MASK_IMIX
operator||
name|SOUND_MASK_MONITOR
operator|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|i
operator|=
literal|0
expr_stmt|;
name|printed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ctl
operator|=
name|hdaa_audio_ctl_each
argument_list|(
name|devinfo
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ctl
operator|->
name|enable
operator|==
literal|0
operator|||
name|ctl
operator|->
name|widget
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
operator|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|pdevinfo
operator|->
name|playas
operator|)
operator|||
operator|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
operator|&&
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
name|pdevinfo
operator|->
name|recas
operator|)
operator|||
operator|(
name|ctl
operator|->
name|widget
operator|->
name|bindas
operator|==
operator|-
literal|2
operator|&&
name|pdevinfo
operator|->
name|index
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ctl
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|banner
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%s"
argument_list|,
name|banner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Unknown Ctl"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (OSS: %s)"
argument_list|,
name|hdaa_audio_ctl_ossmixer_mask2allname
argument_list|(
literal|1
operator|<<
name|j
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|ossmask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": %+d/%+ddB\n"
argument_list|,
name|pdevinfo
operator|->
name|minamp
index|[
name|j
index|]
operator|/
literal|4
argument_list|,
name|pdevinfo
operator|->
name|maxamp
index|[
name|j
index|]
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"   |\n"
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"   +- ctl %2d (nid %3d %s"
argument_list|,
name|i
argument_list|,
name|ctl
operator|->
name|widget
operator|->
name|nid
argument_list|,
operator|(
name|ctl
operator|->
name|ndir
operator|==
name|HDAA_CTL_IN
operator|)
condition|?
literal|"in "
else|:
literal|"out"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|ndir
operator|==
name|HDAA_CTL_IN
operator|&&
name|ctl
operator|->
name|ndir
operator|==
name|ctl
operator|->
name|dir
condition|)
name|printf
argument_list|(
literal|" %2d): "
argument_list|,
name|ctl
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"):    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|step
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%+d/%+ddB (%d steps)%s\n"
argument_list|,
name|MINQDB
argument_list|(
name|ctl
argument_list|)
operator|/
literal|4
argument_list|,
name|MAXQDB
argument_list|(
name|ctl
argument_list|)
operator|/
literal|4
argument_list|,
name|ctl
operator|->
name|step
operator|+
literal|1
argument_list|,
name|ctl
operator|->
name|mute
condition|?
literal|" + mute"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ctl
operator|->
name|mute
condition|?
literal|"mute"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_audio_formats
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|fcap
parameter_list|,
name|uint32_t
name|pcmcap
parameter_list|)
block|{
name|uint32_t
name|cap
decl_stmt|;
name|cap
operator|=
name|fcap
expr_stmt|;
if|if
condition|(
name|cap
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"     Stream cap: 0x%08x\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_AC3
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AC3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_FLOAT32
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" FLOAT32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_STREAM_FORMATS_PCM
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PCM"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cap
operator|=
name|pcmcap
expr_stmt|;
if|if
condition|(
name|cap
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"        PCM cap: 0x%08x\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 20"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 24"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 32"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bits,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_8KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_11KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 11"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_16KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_22KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 22"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_44KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 44"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 48"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_88KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 88"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_96KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 96"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_176KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 176"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_192KHZ
argument_list|(
name|cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 192"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" KHz\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_pin
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|)
block|{
name|uint32_t
name|pincap
decl_stmt|;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"        Pin cap: 0x%08x\n"
argument_list|,
name|pincap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_IMP_SENSE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" ISC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_TRIGGER_REQD
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" TRQD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PDC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_BALANCED_IO_PINS
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" BAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HDMI
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HDMI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" VREF["
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_50
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 50"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_80
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 80"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_100
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" 100"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_GROUND
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" GROUND"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_VREF_CTRL_HIZ
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HIZ"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" EAPD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_DP
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_HBR
argument_list|(
name|pincap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" HBR"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"     Pin config: 0x%08x\n"
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"    Pin control: 0x%08x"
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_HPHN_ENABLE
condition|)
name|printf
argument_list|(
literal|" HP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_IN_ENABLE
condition|)
name|printf
argument_list|(
literal|" IN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_OUT_ENABLE
condition|)
name|printf
argument_list|(
literal|" OUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
operator|)
operator|==
literal|0x03
condition|)
name|printf
argument_list|(
literal|" HBR"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" EPTs"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|ctrl
operator|&
name|HDA_CMD_SET_PIN_WIDGET_CTRL_VREF_ENABLE_MASK
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" VREFs"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_pin_config
parameter_list|(
name|struct
name|hdaa_widget
modifier|*
name|w
parameter_list|,
name|uint32_t
name|conf
parameter_list|)
block|{
name|device_printf
argument_list|(
name|w
operator|->
name|devinfo
operator|->
name|dev
argument_list|,
literal|"%2d %08x %-2d %-2d "
literal|"%-13s %-5s %-7s %-10s %-7s %d%s\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|conf
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_ASSOCIATION
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_SEQUENCE
argument_list|(
name|conf
argument_list|)
argument_list|,
name|HDA_DEVS
index|[
name|HDA_CONFIG_DEFAULTCONF_DEVICE
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONNS
index|[
name|HDA_CONFIG_DEFAULTCONF_CONNECTIVITY
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONNECTORS
index|[
name|HDA_CONFIG_DEFAULTCONF_CONNECTION_TYPE
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_LOCS
index|[
name|HDA_CONFIG_DEFAULTCONF_LOCATION
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_COLORS
index|[
name|HDA_CONFIG_DEFAULTCONF_COLOR
argument_list|(
name|conf
argument_list|)
index|]
argument_list|,
name|HDA_CONFIG_DEFAULTCONF_MISC
argument_list|(
name|conf
argument_list|)
argument_list|,
operator|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|)
condition|?
literal|" DISA"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_pin_configs
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"nid   0x    as seq "
literal|"device       conn  jack    loc        color   misc\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|hdaa_dump_pin_config
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_amp
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|cap
parameter_list|,
name|char
modifier|*
name|banner
parameter_list|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"     %s amp: 0x%08x\n"
argument_list|,
name|banner
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"                 "
literal|"mute=%d step=%d size=%d offset=%d\n"
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_MUTE_CAP
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_NUMSTEPS
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_STEPSIZE
argument_list|(
name|cap
argument_list|)
argument_list|,
name|HDA_PARAM_OUTPUT_AMP_CAP_OFFSET
argument_list|(
name|cap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_nodes
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|)
block|{
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Default Parameter\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"-----------------\n"
argument_list|)
expr_stmt|;
name|hdaa_dump_audio_formats
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|devinfo
operator|->
name|supp_stream_formats
argument_list|,
name|devinfo
operator|->
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"         IN amp: 0x%08x\n"
argument_list|,
name|devinfo
operator|->
name|inamp_cap
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"        OUT amp: 0x%08x\n"
argument_list|,
name|devinfo
operator|->
name|outamp_cap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"Ghost widget nid=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"            nid: %d%s\n"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
operator|(
name|w
operator|->
name|enable
operator|==
literal|0
operator|)
condition|?
literal|" [DISABLED]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"           Name: %s\n"
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"     Widget cap: 0x%08x\n"
argument_list|,
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|widget_cap
operator|&
literal|0x0ee1
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"                "
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_LR_SWAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" LRSWAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_POWER_CTRL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PWR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DIGITAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_UNSOL_CAP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" UNSOL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_PROC_WIDGET
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PROC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_STRIPE
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STRIPE(x%d)"
argument_list|,
literal|1
operator|<<
operator|(
name|fls
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|conv
operator|.
name|stripecap
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|j
operator|=
name|HDA_PARAM_AUDIO_WIDGET_CAP_CC
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|" STEREO"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|" %dCH"
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"    Association: %d (0x%08x)\n"
argument_list|,
name|w
operator|->
name|bindas
argument_list|,
name|w
operator|->
name|bindseqmask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|ossmask
operator|!=
literal|0
operator|||
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"            OSS: %s"
argument_list|,
name|hdaa_audio_ctl_ossmixer_mask2allname
argument_list|(
name|w
operator|->
name|ossmask
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|ossnames
index|[
name|w
operator|->
name|ossdev
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_OUTPUT
operator|||
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
block|{
name|hdaa_dump_audio_formats
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|w
operator|->
name|param
operator|.
name|supp_stream_formats
argument_list|,
name|w
operator|->
name|param
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
operator|||
name|w
operator|->
name|waspin
condition|)
name|hdaa_dump_pin
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|param
operator|.
name|eapdbtl
operator|!=
name|HDA_INVALID
condition|)
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"           EAPD: 0x%08x\n"
argument_list|,
name|w
operator|->
name|param
operator|.
name|eapdbtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_OUT_AMP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
name|w
operator|->
name|param
operator|.
name|outamp_cap
operator|!=
literal|0
condition|)
name|hdaa_dump_amp
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|w
operator|->
name|param
operator|.
name|outamp_cap
argument_list|,
literal|"Output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_IN_AMP
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
name|w
operator|->
name|param
operator|.
name|inamp_cap
operator|!=
literal|0
condition|)
name|hdaa_dump_amp
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|w
operator|->
name|param
operator|.
name|inamp_cap
argument_list|,
literal|" Input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"    connections: %d\n"
argument_list|,
name|w
operator|->
name|nconns
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"          |\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
block|{
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
literal|"          + %s<- nid=%d [%s]"
argument_list|,
operator|(
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|==
literal|0
operator|)
condition|?
literal|"[DISABLED] "
else|:
literal|""
argument_list|,
name|w
operator|->
name|conns
index|[
name|j
index|]
argument_list|,
operator|(
name|cw
operator|==
name|NULL
operator|)
condition|?
literal|"GHOST!"
else|:
name|cw
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|" [UNKNOWN]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cw
operator|->
name|enable
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" [DISABLED]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|nconns
operator|>
literal|1
operator|&&
name|w
operator|->
name|selconn
operator|==
name|j
operator|&&
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_MIXER
condition|)
name|printf
argument_list|(
literal|" (selected)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_dst_nid
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|,
name|nid_t
name|nid
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|,
modifier|*
name|cw
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|HDA_PARSE_MAXDEPTH
condition|)
return|return;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%*s"
argument_list|,
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%*s  +<- "
argument_list|,
literal|4
operator|+
operator|(
name|depth
operator|-
literal|1
operator|)
operator|*
literal|7
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nid=%d [%s]"
argument_list|,
name|w
operator|->
name|nid
argument_list|,
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|ossmask
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" [src: %s]"
argument_list|,
name|hdaa_audio_ctl_ossmixer_mask2allname
argument_list|(
name|w
operator|->
name|ossmask
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w
operator|->
name|nconns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|->
name|connsenable
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cw
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|cw
operator|->
name|enable
operator|==
literal|0
operator|||
name|cw
operator|->
name|bindas
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"%*s  |\n"
argument_list|,
literal|4
operator|+
operator|(
name|depth
operator|)
operator|*
literal|7
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printed
operator|=
literal|1
expr_stmt|;
block|}
name|hdaa_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|w
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_dac
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|<
literal|0
condition|)
return|return;
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Playback:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdaa_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_adc
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|<
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_AUDIO_INPUT
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
name|pdevinfo
operator|->
name|recas
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Record:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdaa_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_mix
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|ossdev
operator|!=
name|SOUND_MIXER_IMIX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|bindas
operator|!=
name|pdevinfo
operator|->
name|recas
condition|)
continue|continue;
if|if
condition|(
name|printed
operator|==
literal|0
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Input Mix:\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdaa_dump_dst_nid
argument_list|(
name|pdevinfo
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_dump_pcmchannels
parameter_list|(
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|nid_t
modifier|*
name|nids
decl_stmt|;
name|int
name|chid
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Playback:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|chid
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
operator|.
name|chans
index|[
literal|0
index|]
expr_stmt|;
name|hdaa_dump_audio_formats
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
name|devinfo
operator|->
name|chans
index|[
name|chid
index|]
operator|.
name|supp_stream_formats
argument_list|,
name|devinfo
operator|->
name|chans
index|[
name|chid
index|]
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
operator|.
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
name|chid
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
operator|.
name|chans
index|[
name|i
index|]
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"            DAC:"
argument_list|)
expr_stmt|;
for|for
control|(
name|nids
operator|=
name|devinfo
operator|->
name|chans
index|[
name|chid
index|]
operator|.
name|io
init|;
operator|*
name|nids
operator|!=
operator|-
literal|1
condition|;
name|nids
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|nids
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"Record:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|chid
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|chans
index|[
literal|0
index|]
expr_stmt|;
name|hdaa_dump_audio_formats
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
name|devinfo
operator|->
name|chans
index|[
name|chid
index|]
operator|.
name|supp_stream_formats
argument_list|,
name|devinfo
operator|->
name|chans
index|[
name|chid
index|]
operator|.
name|supp_pcm_size_rate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
name|chid
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|chans
index|[
name|i
index|]
expr_stmt|;
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"            DAC:"
argument_list|)
expr_stmt|;
for|for
control|(
name|nids
operator|=
name|devinfo
operator|->
name|chans
index|[
name|chid
index|]
operator|.
name|io
init|;
operator|*
name|nids
operator|!=
operator|-
literal|1
condition|;
name|nids
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
operator|*
name|nids
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_pindump
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|res
decl_stmt|,
name|pincap
decl_stmt|,
name|delay
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Dumping AFG pins:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"nid   0x    as seq "
literal|"device       conn  jack    loc        color   misc\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|hdaa_dump_pin_config
argument_list|(
name|w
argument_list|,
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
name|pincap
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"    Caps: %2s %3s %2s %4s %4s"
argument_list|,
name|HDA_PARAM_PIN_CAP_INPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"IN"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_OUTPUT_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"OUT"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_HEADPHONE_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"HP"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_EAPD_CAP
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"EAPD"
else|:
literal|""
argument_list|,
name|HDA_PARAM_PIN_CAP_VREF_CTRL
argument_list|(
name|pincap
argument_list|)
condition|?
literal|"VREF"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_IMP_SENSE_CAP
argument_list|(
name|pincap
argument_list|)
operator|||
name|HDA_PARAM_PIN_CAP_PRESENCE_DETECT_CAP
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
if|if
condition|(
name|HDA_PARAM_PIN_CAP_TRIGGER_REQD
argument_list|(
name|pincap
argument_list|)
condition|)
block|{
name|delay
operator|=
literal|0
expr_stmt|;
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_SET_PIN_SENSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|res
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0x7fffffff
operator|&&
name|res
operator|!=
literal|0xffffffff
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|delay
operator|<
literal|10000
condition|)
do|;
block|}
else|else
block|{
name|delay
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PIN_SENSE
argument_list|(
literal|0
argument_list|,
name|w
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" Sense: 0x%08x (%sconnected%s)"
argument_list|,
name|res
argument_list|,
operator|(
name|res
operator|&
name|HDA_CMD_GET_PIN_SENSE_PRESENCE_DETECT
operator|)
condition|?
literal|""
else|:
literal|"dis"
argument_list|,
operator|(
name|HDA_PARAM_AUDIO_WIDGET_CAP_DIGITAL
argument_list|(
name|w
operator|->
name|param
operator|.
name|widget_cap
argument_list|)
operator|&&
operator|(
name|res
operator|&
name|HDA_CMD_GET_PIN_SENSE_ELD_VALID
operator|)
operator|)
condition|?
literal|", ELD valid"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" delay %dus"
argument_list|,
name|delay
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"NumGPIO=%d NumGPO=%d NumGPI=%d GPIWake=%d GPIUnsol=%d\n"
argument_list|,
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_NUM_GPI
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_GPI_WAKE
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
argument_list|,
name|HDA_PARAM_GPIO_COUNT_GPI_UNSOL
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
argument_list|)
expr_stmt|;
name|hdaa_dump_gpi
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_dump_gpio
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_dump_gpo
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_configure
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_audio_ctl
modifier|*
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Applying built-in patches...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_patch
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Applying local patches...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_local_patch
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_audio_postprocess
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Parsing Ctls...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_ctl_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling nonaudio...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_nonaudio
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling useless...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_useless
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Patched pins configuration:\n"
argument|); 		hdaa_dump_pin_configs(devinfo);
argument_list|)
empty_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Parsing pin associations...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_as_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Building AFG tree...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_build_tree
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling unassociated "
literal|"widgets...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_unas
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling nonselected "
literal|"inputs...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_notselected
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling useless...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_useless
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling "
literal|"crossassociatement connections...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_crossas
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Disabling useless...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_disable_useless
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Binding associations to channels...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_bind_as
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Assigning names to signal sources...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_assign_names
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Preparing PCM devices...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_prepare_pcms
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Assigning mixers to the tree...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_assign_mixers
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Preparing pin controls...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_prepare_pin_ctrl
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"AFG commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Applying direct built-in patches...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_patch_direct
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Pin sense init...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_sense_init
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Creating PCM devices...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_create_pcms
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|if (devinfo->quirks !=
literal|0
argument|) { 			device_printf(dev,
literal|"FG config/quirks:"
argument|); 			for (i =
literal|0
argument|; i< HDAA_QUIRKS_TAB_LEN; i++) { 				if ((devinfo->quirks& 				    hdaa_quirks_tab[i].value) == 				    hdaa_quirks_tab[i].value) 					printf(
literal|" %s"
argument|, hdaa_quirks_tab[i].key); 			} 			printf(
literal|"\n"
argument|); 		}  		device_printf(dev,
literal|"\n"
argument|); 		device_printf(dev,
literal|"+-------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING HDA NODES |\n"
argument|); 		device_printf(dev,
literal|"+-------------------+\n"
argument|); 		hdaa_dump_nodes(devinfo);
argument_list|)
empty_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"\n"
argument|); 		device_printf(dev,
literal|"+------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING HDA AMPLIFIERS |\n"
argument|); 		device_printf(dev,
literal|"+------------------------+\n"
argument|); 		device_printf(dev,
literal|"\n"
argument|); 		i =
literal|0
argument|; 		while ((ctl = hdaa_audio_ctl_each(devinfo,&i)) != NULL) { 			device_printf(dev,
literal|"%3d: nid %3d %s (%s) index %d"
argument|, i, 			    (ctl->widget != NULL) ? ctl->widget->nid : -
literal|1
argument|, 			    (ctl->ndir == HDAA_CTL_IN)?
literal|"in "
argument|:
literal|"out"
argument|, 			    (ctl->dir == HDAA_CTL_IN)?
literal|"in "
argument|:
literal|"out"
argument|, 			    ctl->index); 			if (ctl->childwidget != NULL) 				printf(
literal|" cnid %3d"
argument|, ctl->childwidget->nid); 			else 				printf(
literal|"         "
argument|); 			printf(
literal|" ossmask=0x%08x\n"
argument|, 			    ctl->ossmask); 			device_printf(dev,
literal|"       mute: %d step: %3d size: %3d off: %3d%s\n"
argument|, 			    ctl->mute, ctl->step, ctl->size, ctl->offset, 			    (ctl->enable ==
literal|0
argument|) ?
literal|" [DISABLED]"
argument|:  			    ((ctl->ossmask ==
literal|0
argument|) ?
literal|" [UNUSED]"
argument|:
literal|""
argument|)); 		}
argument_list|)
empty_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_unconfigure
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Pin sense deinit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_sense_deinit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devinfo
operator|->
name|ctl
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|ctl
operator|=
name|NULL
expr_stmt|;
name|devinfo
operator|->
name|ctlcnt
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|devinfo
operator|->
name|as
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|as
operator|=
name|NULL
expr_stmt|;
name|devinfo
operator|->
name|ascnt
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|devinfo
operator|->
name|devs
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|devs
operator|=
name|NULL
expr_stmt|;
name|devinfo
operator|->
name|num_devs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|devinfo
operator|->
name|chans
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|chans
operator|=
name|NULL
expr_stmt|;
name|devinfo
operator|->
name|num_chans
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
continue|continue;
name|w
operator|->
name|enable
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|selconn
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|pflags
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|bindas
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|bindseqmask
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|ossdev
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|ossmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w
operator|->
name|nconns
condition|;
name|j
operator|++
control|)
name|w
operator|->
name|connsenable
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|type
operator|==
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
operator|=
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|newconf
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|eld
operator|!=
name|NULL
condition|)
block|{
name|w
operator|->
name|eld_len
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|eld
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
name|w
operator|->
name|eld
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_gpi_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|oidp
operator|->
name|oid_arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|numgpi
decl_stmt|;
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|numgpi
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPI
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|numgpi
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPI_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpi
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s%d=%d"
argument_list|,
name|n
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_gpio_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|oidp
operator|->
name|oid_arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|numgpio
decl_stmt|;
name|uint32_t
name|data
init|=
literal|0
decl_stmt|,
name|enable
init|=
literal|0
decl_stmt|,
name|dir
init|=
literal|0
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|numgpio
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|numgpio
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|enable
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_ENABLE_MASK
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPIO_DIRECTION
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpio
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s%d="
argument_list|,
name|n
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enable
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"disabled"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%sput(%d)"
argument_list|,
operator|(
operator|(
name|dir
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
condition|?
literal|"out"
else|:
literal|"in"
argument_list|,
operator|(
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_gpio_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|oidp
operator|->
name|oid_arg1
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|numgpio
decl_stmt|;
name|uint32_t
name|gpio
decl_stmt|,
name|x
decl_stmt|;
name|gpio
operator|=
name|devinfo
operator|->
name|newgpio
expr_stmt|;
name|numgpio
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPIO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpio
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|gpio
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|>>
name|HDAA_GPIO_SHIFT
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s%d=%s"
argument_list|,
name|n
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|i
argument_list|,
name|HDA_GPIO_ACTIONS
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|gpio
operator|=
name|strtol
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|gpio
operator|=
name|hdaa_gpio_patch
argument_list|(
name|gpio
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|newgpio
operator|=
name|devinfo
operator|->
name|gpio
operator|=
name|gpio
expr_stmt|;
name|hdaa_gpio_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_gpo_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|oidp
operator|->
name|oid_arg1
decl_stmt|;
name|device_t
name|dev
init|=
name|devinfo
operator|->
name|dev
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|numgpo
decl_stmt|;
name|uint32_t
name|data
init|=
literal|0
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|numgpo
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|numgpo
operator|>
literal|0
condition|)
block|{
name|data
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_GPO_DATA
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpo
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s%d=%d"
argument_list|,
name|n
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|data
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_gpo_config
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|oidp
operator|->
name|oid_arg1
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|numgpo
decl_stmt|;
name|uint32_t
name|gpo
decl_stmt|,
name|x
decl_stmt|;
name|gpo
operator|=
name|devinfo
operator|->
name|newgpo
expr_stmt|;
name|numgpo
operator|=
name|HDA_PARAM_GPIO_COUNT_NUM_GPO
argument_list|(
name|devinfo
operator|->
name|gpio_cap
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numgpo
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|gpo
operator|&
name|HDAA_GPIO_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|>>
name|HDAA_GPIO_SHIFT
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s%d=%s"
argument_list|,
name|n
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|i
argument_list|,
name|HDA_GPIO_ACTIONS
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|gpo
operator|=
name|strtol
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|gpo
operator|=
name|hdaa_gpio_patch
argument_list|(
name|gpo
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|newgpo
operator|=
name|devinfo
operator|->
name|gpo
operator|=
name|gpo
expr_stmt|;
name|hdaa_gpo_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_reconfig
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
decl_stmt|;
name|int
name|error
decl_stmt|,
name|val
decl_stmt|;
name|dev
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|devinfo
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|||
name|val
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reconfiguration...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_delete_children
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_unconfigure
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdaa_configure
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Reconfiguration done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Suspend...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Stop streams...\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|HDAA_CHN_RUNNING
condition|)
block|{
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|HDAA_CHN_SUSPEND
expr_stmt|;
name|hdaa_channel_stop
argument_list|(
operator|&
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Power down FG"
literal|" nid=%d to the D3 state...\n"
argument|, 		    devinfo->nid);
argument_list|)
empty_stmt|;
name|hda_command
argument_list|(
name|devinfo
operator|->
name|dev
argument_list|,
name|HDA_CMD_SET_POWER_STATE
argument_list|(
literal|0
argument_list|,
name|devinfo
operator|->
name|nid
argument_list|,
name|HDA_CMD_POWER_STATE_D3
argument_list|)
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Suspend done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Resume...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Power up audio FG nid=%d...\n"
argument|, 		    devinfo->nid);
argument_list|)
empty_stmt|;
name|hdaa_powerup
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"AFG commit...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_commit
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Applying direct built-in patches...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_patch_direct
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Pin sense init...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_sense_init
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|num_devs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|&
name|devinfo
operator|->
name|devs
index|[
name|i
index|]
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(pdevinfo->dev,
literal|"OSS mixer reinitialization...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|mixer_reinit
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|device_printf
argument_list|(
name|pdevinfo
operator|->
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
block|}
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Start streams...\n"
argument|);
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|HDAA_CHN_SUSPEND
condition|)
block|{
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|HDAA_CHN_SUSPEND
expr_stmt|;
name|hdaa_channel_start
argument_list|(
operator|&
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Resume done\n"
argument|);
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pdesc
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|hda_get_node_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|HDA_PARAM_FCT_GRP_TYPE_NODE_TYPE_AUDIO
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pdesc
operator|=
name|device_get_desc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%.*s Audio Function Group"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|pdesc
argument_list|)
operator|-
literal|10
argument_list|)
argument_list|,
name|pdesc
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|res
decl_stmt|;
name|nid_t
name|nid
init|=
name|hda_get_node_id
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|devinfo
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|devinfo
operator|->
name|lock
operator|=
name|HDAC_GET_MTX
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|nid
operator|=
name|nid
expr_stmt|;
name|devinfo
operator|->
name|newquirks
operator|=
operator|-
literal|1
expr_stmt|;
name|devinfo
operator|->
name|newgpio
operator|=
operator|-
literal|1
expr_stmt|;
name|devinfo
operator|->
name|newgpo
operator|=
operator|-
literal|1
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|poll_ival
operator|=
name|hz
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|res
operator|=
name|hda_command
argument_list|(
name|dev
argument_list|,
name|HDA_CMD_GET_PARAMETER
argument_list|(
literal|0
argument_list|,
name|nid
argument_list|,
name|HDA_PARAM_SUB_NODE_COUNT
argument_list|)
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|nodecnt
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_TOTAL
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|startnode
operator|=
name|HDA_PARAM_SUB_NODE_COUNT_START
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|endnode
operator|=
name|devinfo
operator|->
name|startnode
operator|+
name|devinfo
operator|->
name|nodecnt
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Audio Function Group at nid=%d: %d subnodes %d-%d\n"
argument|, 		    nid, devinfo->nodecnt, 		    devinfo->startnode, devinfo->endnode -
literal|1
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|devinfo
operator|->
name|nodecnt
operator|>
literal|0
condition|)
name|devinfo
operator|->
name|widget
operator|=
operator|(
expr|struct
name|hdaa_widget
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|devinfo
operator|->
name|widget
operator|)
argument_list|)
operator|*
name|devinfo
operator|->
name|nodecnt
argument_list|,
name|M_HDAA
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|else
name|devinfo
operator|->
name|widget
operator|=
name|NULL
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Powering up...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_powerup
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Parsing audio FG...\n"
argument|);
argument_list|)
empty_stmt|;
name|hdaa_audio_parse
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Original pins configuration:\n"
argument|); 		hdaa_dump_pin_configs(devinfo);
argument_list|)
empty_stmt|;
name|hdaa_configure
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
operator|&
name|devinfo
operator|->
name|newquirks
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|devinfo
operator|->
name|newquirks
argument_list|)
argument_list|,
name|hdaa_sysctl_quirks
argument_list|,
literal|"A"
argument_list|,
literal|"Configuration options"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gpi_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|devinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
argument_list|,
name|hdaa_sysctl_gpi_state
argument_list|,
literal|"A"
argument_list|,
literal|"GPI state"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gpio_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|devinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
argument_list|,
name|hdaa_sysctl_gpio_state
argument_list|,
literal|"A"
argument_list|,
literal|"GPIO state"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gpio_config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|devinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
argument_list|,
name|hdaa_sysctl_gpio_config
argument_list|,
literal|"A"
argument_list|,
literal|"GPIO configuration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gpo_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|devinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
argument_list|,
name|hdaa_sysctl_gpo_state
argument_list|,
literal|"A"
argument_list|,
literal|"GPO state"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"gpo_config"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|devinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
argument_list|)
argument_list|,
name|hdaa_sysctl_gpo_config
argument_list|,
literal|"A"
argument_list|,
literal|"GPO configuration"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reconfig"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
argument_list|)
argument_list|,
name|hdaa_sysctl_reconfig
argument_list|,
literal|"I"
argument_list|,
literal|"Reprocess configuration"
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|device_delete_children
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_unconfigure
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|poll_ival
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|devinfo
operator|->
name|poll_jack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devinfo
operator|->
name|widget
argument_list|,
name|M_HDAA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdaa_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|retval
operator|=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at nid "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|retval
operator|+=
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|","
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
name|retval
operator|+=
name|printf
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
block|}
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|retval
operator|+=
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|","
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdaa_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"nid="
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"%s%d"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|","
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
operator|->
name|pins
index|[
name|i
index|]
operator|<=
literal|0
condition|)
continue|continue;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"%s%d"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|","
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_stream_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|stream
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_chan
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|devinfo
operator|->
name|chans
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|flags
operator|&
name|HDAA_CHN_RUNNING
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
operator|(
operator|(
name|dir
operator|==
literal|1
operator|)
condition|?
name|PCMDIR_PLAY
else|:
name|PCMDIR_REC
operator|)
operator|&&
name|ch
operator|->
name|sid
operator|==
name|stream
condition|)
block|{
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|c
argument_list|)
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hdaa_unsol_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
name|resp
parameter_list|)
block|{
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tag
decl_stmt|,
name|flags
decl_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Unsolicited response %08x\n"
argument|, resp);
argument_list|)
empty_stmt|;
name|tag
operator|=
name|resp
operator|>>
literal|26
expr_stmt|;
for|for
control|(
name|i
operator|=
name|devinfo
operator|->
name|startnode
init|;
name|i
operator|<
name|devinfo
operator|->
name|endnode
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
if|if
condition|(
name|w
operator|->
name|unsol
operator|!=
name|tag
condition|)
continue|continue;
if|if
condition|(
name|HDA_PARAM_PIN_CAP_DP
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
operator|||
name|HDA_PARAM_PIN_CAP_HDMI
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|cap
argument_list|)
condition|)
name|flags
operator|=
name|resp
operator|&
literal|0x03
expr_stmt|;
else|else
name|flags
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x01
condition|)
name|hdaa_presence_handler
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x02
condition|)
name|hdaa_eld_handler
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdaa_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdaa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdaa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdaa_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|hdaa_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|hdaa_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|hdaa_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|hdaa_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_stream_intr
argument_list|,
name|hdaa_stream_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_unsol_intr
argument_list|,
name|hdaa_unsol_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|hdac_pindump
argument_list|,
name|hdaa_pindump
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdaa_driver
init|=
block|{
literal|"hdaa"
block|,
name|hdaa_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|hdaa_devinfo
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hdaa_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hda
argument_list|,
name|hdacc
argument_list|,
name|hdaa_driver
argument_list|,
name|hdaa_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|hdaa_chan_formula
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|asid
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|int
name|c
decl_stmt|;
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|asid
index|]
expr_stmt|;
name|c
operator|=
name|devinfo
operator|->
name|chans
index|[
name|as
operator|->
name|chans
index|[
literal|0
index|]
index|]
operator|.
name|channels
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"mono"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|as
operator|->
name|hpredir
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"2.0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|as
operator|->
name|pinset
operator|==
literal|0x0003
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"3.1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|as
operator|->
name|pinset
operator|==
literal|0x0005
operator|||
name|as
operator|->
name|pinset
operator|==
literal|0x0011
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"4.0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|as
operator|->
name|pinset
operator|==
literal|0x0007
operator|||
name|as
operator|->
name|pinset
operator|==
literal|0x0013
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"5.1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|as
operator|->
name|pinset
operator|==
literal|0x0017
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"7.1"
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"%dch"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|hpredir
operator|>=
literal|0
condition|)
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"+HP"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_chan_type
parameter_list|(
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
parameter_list|,
name|int
name|asid
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|hdaa_widget
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
init|=
operator|-
literal|1
decl_stmt|,
name|t1
decl_stmt|;
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|asid
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|hdaa_widget_get
argument_list|(
name|devinfo
argument_list|,
name|as
operator|->
name|pins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
operator|||
name|w
operator|->
name|enable
operator|==
literal|0
operator|||
name|w
operator|->
name|type
operator|!=
name|HDA_PARAM_AUDIO_WIDGET_CAP_TYPE_PIN_COMPLEX
condition|)
continue|continue;
name|t1
operator|=
name|HDA_CONFIG_DEFAULTCONF_DEVICE
argument_list|(
name|w
operator|->
name|wclass
operator|.
name|pin
operator|.
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|-
literal|1
condition|)
name|t
operator|=
name|t1
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|!=
name|t1
condition|)
block|{
name|t
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_sysctl_32bit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hdaa_audio_as
modifier|*
name|as
init|=
operator|(
expr|struct
name|hdaa_audio_as
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
decl_stmt|;
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
name|as
operator|->
name|pdevinfo
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_chan
modifier|*
name|ch
decl_stmt|;
name|int
name|error
decl_stmt|,
name|val
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|pcmcap
decl_stmt|;
name|ch
operator|=
operator|&
name|devinfo
operator|->
name|chans
index|[
name|as
operator|->
name|chans
index|[
literal|0
index|]
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|ch
operator|->
name|bit32
operator|==
literal|4
operator|)
condition|?
literal|32
else|:
operator|(
operator|(
name|ch
operator|->
name|bit32
operator|==
literal|3
operator|)
condition|?
literal|24
else|:
operator|(
operator|(
name|ch
operator|->
name|bit32
operator|==
literal|2
operator|)
condition|?
literal|20
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pcmcap
operator|=
name|ch
operator|->
name|supp_pcm_size_rate
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|32
operator|&&
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_32BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|24
operator|&&
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_24BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|20
operator|&&
name|HDA_PARAM_SUPP_PCM_SIZE_RATE_20BIT
argument_list|(
name|pcmcap
argument_list|)
condition|)
name|ch
operator|->
name|bit32
operator|=
literal|2
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|as
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
name|devinfo
operator|->
name|chans
index|[
name|as
operator|->
name|chans
index|[
name|i
index|]
index|]
operator|.
name|bit32
operator|=
name|ch
operator|->
name|bit32
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_pcm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdaa_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|pdesc
decl_stmt|;
name|char
name|chans1
index|[
literal|8
index|]
decl_stmt|,
name|chans2
index|[
literal|8
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|loc1
decl_stmt|,
name|loc2
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
name|loc1
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
operator|.
name|location
expr_stmt|;
else|else
name|loc1
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|location
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
name|loc2
operator|=
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
operator|.
name|location
expr_stmt|;
else|else
name|loc2
operator|=
name|loc1
expr_stmt|;
if|if
condition|(
name|loc1
operator|!=
name|loc2
condition|)
name|loc1
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|loc1
operator|>=
literal|0
operator|&&
name|HDA_LOCS
index|[
name|loc1
index|]
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|loc1
operator|=
operator|-
literal|2
expr_stmt|;
name|chans1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|chans2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|t1
operator|=
name|t2
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
name|hdaa_chan_formula
argument_list|(
name|devinfo
argument_list|,
name|pdevinfo
operator|->
name|playas
argument_list|,
name|chans1
argument_list|,
sizeof|sizeof
argument_list|(
name|chans1
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|hdaa_chan_type
argument_list|(
name|devinfo
argument_list|,
name|pdevinfo
operator|->
name|playas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
name|hdaa_chan_formula
argument_list|(
name|devinfo
argument_list|,
name|pdevinfo
operator|->
name|recas
argument_list|,
name|chans2
argument_list|,
sizeof|sizeof
argument_list|(
name|chans2
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|hdaa_chan_type
argument_list|(
name|devinfo
argument_list|,
name|pdevinfo
operator|->
name|recas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chans1
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|chans2
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chans1
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|chans1
argument_list|,
sizeof|sizeof
argument_list|(
name|chans1
argument_list|)
argument_list|,
literal|"2.0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chans2
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|chans2
argument_list|,
sizeof|sizeof
argument_list|(
name|chans2
argument_list|)
argument_list|,
literal|"2.0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|chans1
argument_list|,
name|chans2
argument_list|)
operator|==
literal|0
condition|)
name|chans2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|==
operator|-
literal|1
condition|)
name|t1
operator|=
name|t2
expr_stmt|;
elseif|else
if|if
condition|(
name|t2
operator|==
operator|-
literal|1
condition|)
name|t2
operator|=
name|t1
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
condition|)
name|t1
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|digital
condition|)
name|t1
operator|=
operator|-
literal|2
expr_stmt|;
name|pdesc
operator|=
name|device_get_desc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%.*s (%s%s%s%s%s%s%s%s%s)"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|pdesc
argument_list|)
operator|-
literal|21
argument_list|)
argument_list|,
name|pdesc
argument_list|,
name|loc1
operator|>=
literal|0
condition|?
name|HDA_LOCS
index|[
name|loc1
index|]
else|:
literal|""
argument_list|,
name|loc1
operator|>=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
operator|(
name|pdevinfo
operator|->
name|digital
operator|==
literal|0x7
operator|)
condition|?
literal|"HDMI/DP"
else|:
operator|(
operator|(
name|pdevinfo
operator|->
name|digital
operator|==
literal|0x5
operator|)
condition|?
literal|"DisplayPort"
else|:
operator|(
operator|(
name|pdevinfo
operator|->
name|digital
operator|==
literal|0x3
operator|)
condition|?
literal|"HDMI"
else|:
operator|(
operator|(
name|pdevinfo
operator|->
name|digital
operator|)
condition|?
literal|"Digital"
else|:
literal|"Analog"
operator|)
operator|)
operator|)
argument_list|,
name|chans1
index|[
literal|0
index|]
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|chans1
argument_list|,
name|chans2
index|[
literal|0
index|]
condition|?
literal|"/"
else|:
literal|""
argument_list|,
name|chans2
argument_list|,
name|t1
operator|>=
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|t1
operator|>=
literal|0
condition|?
name|HDA_DEVS
index|[
name|t1
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_SPECIFIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_pcm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdaa_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hdaa_devinfo
modifier|*
name|devinfo
init|=
name|pdevinfo
operator|->
name|devinfo
decl_stmt|;
name|struct
name|hdaa_audio_as
modifier|*
name|as
decl_stmt|;
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pdevinfo
operator|->
name|chan_size
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
name|HDA_BUFSZ_MIN
argument_list|,
name|HDA_BUFSZ_DEFAULT
argument_list|,
name|HDA_BUFSZ_MAX
argument_list|)
expr_stmt|;
name|HDA_BOOTVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"+--------------------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING PCM Playback/Record Channels |\n"
argument|); 		device_printf(dev,
literal|"+--------------------------------------+\n"
argument|); 		hdaa_dump_pcmchannels(pdevinfo); 		device_printf(dev,
literal|"\n"
argument|); 		device_printf(dev,
literal|"+-------------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING Playback/Record Paths |\n"
argument|); 		device_printf(dev,
literal|"+-------------------------------+\n"
argument|); 		hdaa_dump_dac(pdevinfo); 		hdaa_dump_adc(pdevinfo); 		hdaa_dump_mix(pdevinfo); 		device_printf(dev,
literal|"\n"
argument|); 		device_printf(dev,
literal|"+-------------------------+\n"
argument|); 		device_printf(dev,
literal|"| DUMPING Volume Controls |\n"
argument|); 		device_printf(dev,
literal|"+-------------------------+\n"
argument|); 		hdaa_dump_ctls(pdevinfo,
literal|"Master Volume"
argument|, SOUND_MASK_VOLUME); 		hdaa_dump_ctls(pdevinfo,
literal|"PCM Volume"
argument|, SOUND_MASK_PCM); 		hdaa_dump_ctls(pdevinfo,
literal|"CD Volume"
argument|, SOUND_MASK_CD); 		hdaa_dump_ctls(pdevinfo,
literal|"Microphone Volume"
argument|, SOUND_MASK_MIC); 		hdaa_dump_ctls(pdevinfo,
literal|"Microphone2 Volume"
argument|, SOUND_MASK_MONITOR); 		hdaa_dump_ctls(pdevinfo,
literal|"Line-in Volume"
argument|, SOUND_MASK_LINE); 		hdaa_dump_ctls(pdevinfo,
literal|"Speaker/Beep Volume"
argument|, SOUND_MASK_SPEAKER); 		hdaa_dump_ctls(pdevinfo,
literal|"Recording Level"
argument|, SOUND_MASK_RECLEV); 		hdaa_dump_ctls(pdevinfo,
literal|"Input Mix Level"
argument|, SOUND_MASK_IMIX); 		hdaa_dump_ctls(pdevinfo,
literal|"Input Monitoring Level"
argument|, SOUND_MASK_IGAIN); 		hdaa_dump_ctls(pdevinfo, NULL,
literal|0
argument|); 		device_printf(dev,
literal|"\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"blocksize"
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|&=
name|HDA_BLK_ALIGN
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|HDA_BLK_MIN
condition|)
name|i
operator|=
name|HDA_BLK_MIN
expr_stmt|;
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|pdevinfo
operator|->
name|chan_size
operator|/
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pdevinfo
operator|->
name|chan_blkcnt
operator|>>
name|i
condition|)
name|i
operator|++
expr_stmt|;
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|chan_blkcnt
operator|<
name|HDA_BDL_MIN
condition|)
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_MIN
expr_stmt|;
elseif|else
if|if
condition|(
name|pdevinfo
operator|->
name|chan_blkcnt
operator|>
name|HDA_BDL_MAX
condition|)
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_MAX
expr_stmt|;
block|}
else|else
name|pdevinfo
operator|->
name|chan_blkcnt
operator|=
name|HDA_BDL_DEFAULT
expr_stmt|;
comment|/*  	 * We don't register interrupt handler with snd_setup_intr 	 * in pcm device. Mark pcm device as MPSAFE manually. 	 */
name|pcm_setflags
argument_list|(
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|dev
argument_list|)
operator||
name|SD_F_MPSAFE
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"OSS mixer initialization...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|hdaa_audio_ctl_ossmixer_class
argument_list|,
name|pdevinfo
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't register mixer\n"
argument_list|)
expr_stmt|;
name|HDA_BOOTHVERBOSE
argument_list|(
argument|device_printf(dev,
literal|"Registering PCM channels...\n"
argument|);
argument_list|)
empty_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|pdevinfo
argument_list|,
operator|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't register PCM\n"
argument_list|)
expr_stmt|;
name|pdevinfo
operator|->
name|registered
operator|++
expr_stmt|;
name|d
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|playas
operator|>=
literal|0
condition|)
block|{
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|playas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|as
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|hdaa_channel_class
argument_list|,
operator|&
name|devinfo
operator|->
name|chans
index|[
name|as
operator|->
name|chans
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|d
operator|->
name|play_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|d
operator|->
name|play_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"32bit"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|as
argument_list|,
sizeof|sizeof
argument_list|(
name|as
argument_list|)
argument_list|,
name|hdaa_sysctl_32bit
argument_list|,
literal|"I"
argument_list|,
literal|"Resolution of 32bit samples (20/24/32bit)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|as
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|hdaa_channel_class
argument_list|,
operator|&
name|devinfo
operator|->
name|chans
index|[
name|as
operator|->
name|chans
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|d
operator|->
name|rec_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|d
operator|->
name|rec_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"32bit"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|as
argument_list|,
sizeof|sizeof
argument_list|(
name|as
argument_list|)
argument_list|,
name|hdaa_sysctl_32bit
argument_list|,
literal|"I"
argument_list|,
literal|"Resolution of 32bit samples (20/24/32bit)"
argument_list|)
expr_stmt|;
name|pdevinfo
operator|->
name|autorecsrc
operator|=
literal|2
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"rec.autosrc"
argument_list|,
operator|&
name|pdevinfo
operator|->
name|autorecsrc
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|d
operator|->
name|rec_sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|d
operator|->
name|rec_sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"autosrc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|pdevinfo
operator|->
name|autorecsrc
argument_list|,
literal|0
argument_list|,
literal|"Automatic recording source selection"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdevinfo
operator|->
name|mixer
operator|!=
name|NULL
condition|)
block|{
name|hdaa_audio_ctl_set_defaults
argument_list|(
name|pdevinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|recas
operator|>=
literal|0
condition|)
block|{
name|as
operator|=
operator|&
name|devinfo
operator|->
name|as
index|[
name|pdevinfo
operator|->
name|recas
index|]
expr_stmt|;
name|hdaa_lock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
name|hdaa_autorecsrc_handler
argument_list|(
name|as
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hdaa_unlock
argument_list|(
name|devinfo
argument_list|)
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"on %s %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_hda
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdaa_pcm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hdaa_pcm_devinfo
modifier|*
name|pdevinfo
init|=
operator|(
expr|struct
name|hdaa_pcm_devinfo
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|pdevinfo
operator|->
name|registered
operator|>
literal|0
condition|)
block|{
name|err
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdaa_pcm_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdaa_pcm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdaa_pcm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdaa_pcm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdaa_pcm_driver
init|=
block|{
literal|"pcm"
block|,
name|hdaa_pcm_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hda_pcm
argument_list|,
name|hdaa
argument_list|,
name|hdaa_pcm_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_hda
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_hda
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

