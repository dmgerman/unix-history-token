begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Orion Hodson<O.Hodson@cs.ucl.ac.uk>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This card has the annoying habit of "clicking" when attached and  * detached, haven't been able to remedy this with any combination of  * muting.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/vibes.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Constants */
end_comment

begin_define
define|#
directive|define
name|SV_PCI_ID
value|0xca005333
end_define

begin_define
define|#
directive|define
name|SV_DEFAULT_BUFSZ
value|16384
end_define

begin_define
define|#
directive|define
name|SV_MIN_BLKSZ
value|128
end_define

begin_define
define|#
directive|define
name|SV_INTR_PER_BUFFER
value|2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEB
end_ifndef

begin_define
define|#
directive|define
name|DEB
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* (x) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Structures */
end_comment

begin_struct_decl
struct_decl|struct
name|sc_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|sc_chinfo
block|{
name|struct
name|sc_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|dma_active
decl_stmt|,
name|dma_was_active
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sc_info
block|{
name|device_t
name|dev
decl_stmt|;
comment|/* DMA buffer allocator */
name|bus_dma_tag_t
name|parent_dmat
decl_stmt|;
comment|/* Enhanced register resources */
name|struct
name|resource
modifier|*
name|enh_reg
decl_stmt|;
name|bus_space_tag_t
name|enh_st
decl_stmt|;
name|bus_space_handle_t
name|enh_sh
decl_stmt|;
name|int
name|enh_type
decl_stmt|;
name|int
name|enh_rid
decl_stmt|;
comment|/* DMA configuration */
name|struct
name|resource
modifier|*
name|dmaa_reg
decl_stmt|,
modifier|*
name|dmac_reg
decl_stmt|;
name|bus_space_tag_t
name|dmaa_st
decl_stmt|,
name|dmac_st
decl_stmt|;
name|bus_space_handle_t
name|dmaa_sh
decl_stmt|,
name|dmac_sh
decl_stmt|;
name|int
name|dmaa_type
decl_stmt|,
name|dmac_type
decl_stmt|;
name|int
name|dmaa_rid
decl_stmt|,
name|dmac_rid
decl_stmt|;
comment|/* Interrupt resources */
name|struct
name|resource
modifier|*
name|irq
decl_stmt|;
name|int
name|irqid
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
comment|/* User configurable buffer size */
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|struct
name|sc_chinfo
name|rch
decl_stmt|,
name|pch
decl_stmt|;
name|u_int8_t
name|rev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_int32_t
name|sc_fmt
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_U8
operator||
name|AFMT_STEREO
block|,
name|AFMT_S16_LE
block|,
name|AFMT_S16_LE
operator||
name|AFMT_STEREO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|sc_caps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|sc_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Register Manipulations */
end_comment

begin_define
define|#
directive|define
name|sv_direct_set
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|_sv_direct_set(x, y, z, __LINE__)
end_define

begin_function
specifier|static
name|u_int8_t
name|sv_direct_get
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|reg
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|enh_st
argument_list|,
name|sc
operator|->
name|enh_sh
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_sv_direct_set
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|reg
parameter_list|,
name|u_int8_t
name|val
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|u_int8_t
name|n
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|enh_st
argument_list|,
name|sc
operator|->
name|enh_sh
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|n
operator|=
name|sv_direct_get
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|val
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"sv_direct_set register 0x%02x %d != %d from line %d\n"
argument_list|,
name|reg
argument_list|,
name|n
argument_list|,
name|val
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|sv_indirect_get
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|==
name|SV_REG_FORMAT
operator|||
name|reg
operator|==
name|SV_REG_ANALOG_PWR
condition|)
name|reg
operator||=
name|SV_CM_INDEX_MCE
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|enh_st
argument_list|,
name|sc
operator|->
name|enh_sh
argument_list|,
name|SV_CM_INDEX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|enh_st
argument_list|,
name|sc
operator|->
name|enh_sh
argument_list|,
name|SV_CM_DATA
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|sv_indirect_set
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|_sv_indirect_set(x, y, z, __LINE__)
end_define

begin_function
specifier|static
name|void
name|_sv_indirect_set
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|reg
parameter_list|,
name|u_int8_t
name|val
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|==
name|SV_REG_FORMAT
operator|||
name|reg
operator|==
name|SV_REG_ANALOG_PWR
condition|)
name|reg
operator||=
name|SV_CM_INDEX_MCE
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|enh_st
argument_list|,
name|sc
operator|->
name|enh_sh
argument_list|,
name|SV_CM_INDEX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|enh_st
argument_list|,
name|sc
operator|->
name|enh_sh
argument_list|,
name|SV_CM_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|SV_CM_INDEX_MCE
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|SV_REG_ADC_PLLM
condition|)
block|{
name|u_int8_t
name|n
decl_stmt|;
name|n
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|val
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"sv_indirect_set register 0x%02x %d != %d line %d\n"
argument_list|,
name|reg
argument_list|,
name|n
argument_list|,
name|val
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sv_dma_set_config
parameter_list|(
name|bus_space_tag_t
name|st
parameter_list|,
name|bus_space_handle_t
name|sh
parameter_list|,
name|u_int32_t
name|base
parameter_list|,
name|u_int32_t
name|count
parameter_list|,
name|u_int8_t
name|mode
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|st
argument_list|,
name|sh
argument_list|,
name|SV_DMA_ADDR
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|st
argument_list|,
name|sh
argument_list|,
name|SV_DMA_COUNT
argument_list|,
name|count
operator|&
literal|0xffffff
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|st
argument_list|,
name|sh
argument_list|,
name|SV_DMA_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"base 0x%08x count %5d mode 0x%02x\n"
argument_list|,
name|base
argument_list|,
name|count
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|sv_dma_get_count
parameter_list|(
name|bus_space_tag_t
name|st
parameter_list|,
name|bus_space_handle_t
name|sh
parameter_list|)
block|{
return|return
name|bus_space_read_4
argument_list|(
name|st
argument_list|,
name|sh
argument_list|,
name|SV_DMA_COUNT
argument_list|)
operator|&
literal|0xffffff
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Play / Record Common Interface */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|svchan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|pch
else|:
operator|&
name|sc
operator|->
name|rch
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|b
argument_list|,
name|sc
operator|->
name|parent_dmat
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"svchan_init failed\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
name|ch
operator|->
name|dma_was_active
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|svchan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|&
name|sc_caps
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
comment|/* user has requested interrupts every blocksize bytes */
name|RANGE
argument_list|(
name|blocksize
argument_list|,
name|SV_MIN_BLKSZ
argument_list|,
name|sc
operator|->
name|bufsz
operator|/
name|SV_INTR_PER_BUFFER
argument_list|)
expr_stmt|;
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|SV_INTR_PER_BUFFER
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"svchan_setblocksize: %d\n"
argument_list|,
name|blocksize
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|blocksize
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svchan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
comment|/* NB Just note format here as setting format register 	 * generates noise if dma channel is inactive. */
name|ch
operator|->
name|fmt
operator|=
operator|(
name|format
operator|&
name|AFMT_STEREO
operator|)
condition|?
name|SV_AFMT_STEREO
else|:
name|SV_AFMT_MONO
expr_stmt|;
name|ch
operator|->
name|fmt
operator||=
operator|(
name|format
operator|&
name|AFMT_16BIT
operator|)
condition|?
name|SV_AFMT_S16
else|:
name|SV_AFMT_U8
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svchan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|8000
argument_list|,
literal|48000
argument_list|)
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Recording interface */
end_comment

begin_function
specifier|static
name|int
name|sv_set_recspeed
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
name|u_int32_t
name|f_out
decl_stmt|,
name|f_actual
decl_stmt|;
name|u_int32_t
name|rs
decl_stmt|,
name|re
decl_stmt|,
name|r
decl_stmt|,
name|best_r
init|=
literal|0
decl_stmt|,
name|r2
decl_stmt|,
name|t
decl_stmt|,
name|n
decl_stmt|,
name|best_n
init|=
literal|0
decl_stmt|;
name|int32_t
name|m
decl_stmt|,
name|best_m
init|=
literal|0
decl_stmt|,
name|ms
decl_stmt|,
name|me
decl_stmt|,
name|err
decl_stmt|,
name|min_err
decl_stmt|;
comment|/* This algorithm is a variant described in sonicvibes.pdf 	 * appendix A.  This search is marginally more extensive and 	 * results in (nominally) better sample rate matching. */
name|f_out
operator|=
name|SV_F_SCALE
operator|*
name|speed
expr_stmt|;
name|min_err
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/* Find bounds of r to examine, rs<= r<= re */
name|t
operator|=
literal|80000000
operator|/
name|f_out
expr_stmt|;
for|for
control|(
name|rs
operator|=
literal|1
init|;
operator|(
literal|1
operator|<<
name|rs
operator|)
operator|<
name|t
condition|;
name|rs
operator|++
control|)
empty_stmt|;
name|t
operator|=
literal|150000000
operator|/
name|f_out
expr_stmt|;
for|for
control|(
name|re
operator|=
literal|1
init|;
operator|(
literal|2
operator|<<
name|re
operator|)
operator|<
name|t
condition|;
name|re
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|re
operator|>
literal|7
condition|)
name|re
operator|=
literal|7
expr_stmt|;
comment|/* Search over r, n, m */
for|for
control|(
name|r
operator|=
name|rs
init|;
name|r
operator|<=
name|re
condition|;
name|r
operator|++
control|)
block|{
name|r2
operator|=
operator|(
literal|1
operator|<<
name|r
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|3
init|;
name|n
operator|<
literal|34
condition|;
name|n
operator|++
control|)
block|{
name|m
operator|=
name|f_out
operator|*
name|n
operator|/
operator|(
name|SV_F_REF
operator|/
name|r2
operator|)
expr_stmt|;
name|ms
operator|=
operator|(
name|m
operator|>
literal|3
operator|)
condition|?
operator|(
name|m
operator|-
literal|1
operator|)
else|:
literal|3
expr_stmt|;
name|me
operator|=
operator|(
name|m
operator|<
literal|129
operator|)
condition|?
operator|(
name|m
operator|+
literal|1
operator|)
else|:
literal|129
expr_stmt|;
for|for
control|(
name|m
operator|=
name|ms
init|;
name|m
operator|<=
name|me
condition|;
name|m
operator|++
control|)
block|{
name|f_actual
operator|=
name|m
operator|*
name|SV_F_REF
operator|/
operator|(
name|n
operator|*
name|r2
operator|)
expr_stmt|;
if|if
condition|(
name|f_actual
operator|>
name|f_out
condition|)
block|{
name|err
operator|=
name|f_actual
operator|-
name|f_out
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|f_out
operator|-
name|f_actual
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|<
name|min_err
condition|)
block|{
name|best_r
operator|=
name|r
expr_stmt|;
name|best_m
operator|=
name|m
operator|-
literal|2
expr_stmt|;
name|best_n
operator|=
name|n
operator|-
literal|2
expr_stmt|;
name|min_err
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ADC_PLLM
argument_list|,
name|best_m
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ADC_PLLN
argument_list|,
name|SV_ADC_PLLN
argument_list|(
name|best_n
argument_list|)
operator||
name|SV_ADC_PLLR
argument_list|(
name|best_r
argument_list|)
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"svrchan_setspeed: %d -> PLLM 0x%02x PLLNR 0x%08x\n"
argument_list|,
name|speed
argument_list|,
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ADC_PLLM
argument_list|)
argument_list|,
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ADC_PLLN
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svrchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|,
name|enable
decl_stmt|;
name|u_int8_t
name|v
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
comment|/* Set speed */
name|sv_set_recspeed
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|spd
argument_list|)
expr_stmt|;
comment|/* Set format */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_FORMAT
argument_list|)
operator|&
operator|~
name|SV_AFMT_DMAC_MSK
expr_stmt|;
name|v
operator||=
name|SV_AFMT_DMAC
argument_list|(
name|ch
operator|->
name|fmt
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_FORMAT
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Program DMA */
name|count
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
literal|2
expr_stmt|;
comment|/* DMAC uses words */
name|sv_dma_set_config
argument_list|(
name|sc
operator|->
name|dmac_st
argument_list|,
name|sc
operator|->
name|dmac_sh
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|SV_DMA_MODE_AUTO
operator||
name|SV_DMA_MODE_RD
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|/
name|SV_INTR_PER_BUFFER
operator|-
literal|1
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_DMAC_COUNT_HI
argument_list|,
name|count
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_DMAC_COUNT_LO
argument_list|,
name|count
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable DMA */
name|enable
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|)
operator||
name|SV_RECORD_ENABLE
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|enable
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|)
operator|&
operator|~
name|SV_RECORD_ENABLE
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svrchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|sz
decl_stmt|,
name|remain
decl_stmt|;
name|sz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* DMAC uses words */
name|remain
operator|=
operator|(
name|sv_dma_get_count
argument_list|(
name|sc
operator|->
name|dmac_st
argument_list|,
name|sc
operator|->
name|dmac_sh
argument_list|)
operator|+
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
return|return
name|sz
operator|-
name|remain
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|svrchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|svchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|svchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|svchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|svchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|svrchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|svrchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|svchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|svrchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Playback interface */
end_comment

begin_function
specifier|static
name|int
name|svpchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|,
name|enable
decl_stmt|,
name|speed
decl_stmt|;
name|u_int8_t
name|v
decl_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
comment|/* Set speed */
name|speed
operator|=
operator|(
name|ch
operator|->
name|spd
operator|*
literal|65536
operator|)
operator|/
literal|48000
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|65535
condition|)
name|speed
operator|=
literal|65535
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_PCM_SAMPLING_HI
argument_list|,
name|speed
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_PCM_SAMPLING_LO
argument_list|,
name|speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set format */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_FORMAT
argument_list|)
operator|&
operator|~
name|SV_AFMT_DMAA_MSK
expr_stmt|;
name|v
operator||=
name|SV_AFMT_DMAA
argument_list|(
name|ch
operator|->
name|fmt
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_FORMAT
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Program DMA */
name|count
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|sv_dma_set_config
argument_list|(
name|sc
operator|->
name|dmaa_st
argument_list|,
name|sc
operator|->
name|dmaa_sh
argument_list|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|SV_DMA_MODE_AUTO
operator||
name|SV_DMA_MODE_WR
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|/
name|SV_INTR_PER_BUFFER
operator|-
literal|1
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_DMAA_COUNT_HI
argument_list|,
name|count
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_DMAA_COUNT_LO
argument_list|,
name|count
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable DMA */
name|enable
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|)
expr_stmt|;
name|enable
operator|=
operator|(
name|enable
operator||
name|SV_PLAY_ENABLE
operator|)
operator|&
operator|~
name|SV_PLAYBACK_PAUSE
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
name|enable
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|)
operator|&
operator|~
name|SV_PLAY_ENABLE
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ENABLE
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma_active
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svpchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|u_int32_t
name|sz
decl_stmt|,
name|remain
decl_stmt|;
name|sz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* DMAA uses bytes */
name|remain
operator|=
name|sv_dma_get_count
argument_list|(
name|sc
operator|->
name|dmaa_st
argument_list|,
name|sc
operator|->
name|dmaa_sh
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|sz
operator|-
name|remain
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|svpchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|svchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|svchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|svchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|svchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|svpchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|svpchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|svchan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|svpchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Mixer support */
end_comment

begin_struct
struct|struct
name|sv_mix_props
block|{
name|u_int8_t
name|reg
decl_stmt|;
comment|/* Register */
name|u_int8_t
name|stereo
range|:
literal|1
decl_stmt|;
comment|/* Supports 2 channels */
name|u_int8_t
name|mute
range|:
literal|1
decl_stmt|;
comment|/* Supports muting */
name|u_int8_t
name|neg
range|:
literal|1
decl_stmt|;
comment|/* Negative gain */
name|u_int8_t
name|max
decl_stmt|;
comment|/* Max gain */
name|u_int8_t
name|iselect
decl_stmt|;
comment|/* Input selector */
block|}
decl|static const
name|mt
index|[
name|SOUND_MIXER_NRDEVICES
index|]
init|=
block|{
index|[
name|SOUND_MIXER_LINE1
index|]
operator|=
block|{
name|SV_REG_AUX1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|SV_DEFAULT_MAX
block|,
name|SV_INPUT_AUX1
block|}
block|,
index|[
name|SOUND_MIXER_CD
index|]
operator|=
block|{
name|SV_REG_CD
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|SV_DEFAULT_MAX
block|,
name|SV_INPUT_CD
block|}
block|,
index|[
name|SOUND_MIXER_LINE
index|]
operator|=
block|{
name|SV_REG_LINE
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|SV_DEFAULT_MAX
block|,
name|SV_INPUT_LINE
block|}
block|,
index|[
name|SOUND_MIXER_MIC
index|]
operator|=
block|{
name|SV_REG_MIC
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|SV_MIC_MAX
block|,
name|SV_INPUT_MIC
block|}
block|,
index|[
name|SOUND_MIXER_SYNTH
index|]
operator|=
block|{
name|SV_REG_SYNTH
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|SV_DEFAULT_MAX
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_LINE2
index|]
operator|=
block|{
name|SV_REG_AUX2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|SV_DEFAULT_MAX
block|,
name|SV_INPUT_AUX2
block|}
block|,
index|[
name|SOUND_MIXER_VOLUME
index|]
operator|=
block|{
name|SV_REG_MIX
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|SV_DEFAULT_MAX
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_PCM
index|]
operator|=
block|{
name|SV_REG_PCM
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|SV_PCM_MAX
block|,
literal|0
block|}
block|,
index|[
name|SOUND_MIXER_RECLEV
index|]
operator|=
block|{
name|SV_REG_ADC_INPUT
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|SV_ADC_MAX
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|sv_channel_gain
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|dev
parameter_list|,
name|u_int32_t
name|gain
parameter_list|,
name|u_int32_t
name|channel
parameter_list|)
block|{
name|u_int8_t
name|v
decl_stmt|;
name|int32_t
name|g
decl_stmt|;
name|g
operator|=
name|mt
index|[
name|dev
index|]
operator|.
name|max
operator|*
name|gain
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|mt
index|[
name|dev
index|]
operator|.
name|neg
condition|)
name|g
operator|=
name|mt
index|[
name|dev
index|]
operator|.
name|max
operator|-
name|g
expr_stmt|;
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|mt
index|[
name|dev
index|]
operator|.
name|reg
operator|+
name|channel
argument_list|)
operator|&
operator|~
name|mt
index|[
name|dev
index|]
operator|.
name|max
expr_stmt|;
name|v
operator||=
name|g
expr_stmt|;
if|if
condition|(
name|mt
index|[
name|dev
index|]
operator|.
name|mute
condition|)
block|{
if|if
condition|(
name|gain
operator|==
literal|0
condition|)
block|{
name|v
operator||=
name|SV_MUTE
expr_stmt|;
block|}
else|else
block|{
name|v
operator|&=
operator|~
name|SV_MUTE
expr_stmt|;
block|}
block|}
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|mt
index|[
name|dev
index|]
operator|.
name|reg
operator|+
name|channel
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_gain
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|dev
parameter_list|,
name|u_int32_t
name|left
parameter_list|,
name|u_int32_t
name|right
parameter_list|)
block|{
name|sv_channel_gain
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|,
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
index|[
name|dev
index|]
operator|.
name|stereo
condition|)
name|sv_channel_gain
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|,
name|right
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sv_mix_mute_all
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mt
index|[
name|i
index|]
operator|.
name|reg
condition|)
name|sv_gain
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sv_mix_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|u_int32_t
name|i
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mt
index|[
name|i
index|]
operator|.
name|max
condition|)
name|v
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mt
index|[
name|i
index|]
operator|.
name|iselect
condition|)
name|v
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_mix_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|dev
parameter_list|,
name|u_int32_t
name|left
parameter_list|,
name|u_int32_t
name|right
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
return|return
name|sv_gain
argument_list|(
name|sc
argument_list|,
name|dev
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_mix_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|mask
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|,
name|v
decl_stmt|;
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ADC_INPUT
argument_list|)
operator|&
name|SV_INPUT_GAIN_MASK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|mask
condition|)
block|{
name|v
operator||=
name|mt
index|[
name|i
index|]
operator|.
name|iselect
expr_stmt|;
block|}
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sv_mix_setrecsrc: mask 0x%08x adc_input 0x%02x\n"
argument_list|,
name|mask
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ADC_INPUT
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|sv_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|sv_mix_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|sv_mix_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|sv_mix_setrecsrc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|sv_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Power management and reset */
end_comment

begin_function
specifier|static
name|void
name|sv_power
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|u_int8_t
name|v
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* power on */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ANALOG_PWR
argument_list|)
operator|&
operator|~
name|SV_ANALOG_OFF
expr_stmt|;
name|v
operator||=
name|SV_ANALOG_OFF_SRS
operator||
name|SV_ANALOG_OFF_SPLL
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ANALOG_PWR
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_DIGITAL_PWR
argument_list|)
operator|&
operator|~
name|SV_DIGITAL_OFF
expr_stmt|;
name|v
operator||=
name|SV_DIGITAL_OFF_SYN
operator||
name|SV_DIGITAL_OFF_MU
operator||
name|SV_DIGITAL_OFF_GP
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_DIGITAL_PWR
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* power off */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_ANALOG_PWR
argument_list|)
operator||
name|SV_ANALOG_OFF
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_ANALOG_PWR
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_DIGITAL_PWR
argument_list|)
operator||
name|SV_DIGITAL_OFF
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_DIGITAL_PWR
argument_list|,
name|SV_DIGITAL_OFF
argument_list|)
expr_stmt|;
break|break;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Power state %d\n"
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_init
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|v
decl_stmt|;
comment|/* Effect reset */
name|v
operator|=
name|sv_direct_get
argument_list|(
name|sc
argument_list|,
name|SV_CM_CONTROL
argument_list|)
operator|&
operator|~
name|SV_CM_CONTROL_ENHANCED
expr_stmt|;
name|v
operator||=
name|SV_CM_CONTROL_RESET
expr_stmt|;
name|sv_direct_set
argument_list|(
name|sc
argument_list|,
name|SV_CM_CONTROL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|v
operator|=
name|sv_direct_get
argument_list|(
name|sc
argument_list|,
name|SV_CM_CONTROL
argument_list|)
operator|&
operator|~
name|SV_CM_CONTROL_RESET
expr_stmt|;
name|sv_direct_set
argument_list|(
name|sc
argument_list|,
name|SV_CM_CONTROL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Set in enhanced mode */
name|v
operator|=
name|sv_direct_get
argument_list|(
name|sc
argument_list|,
name|SV_CM_CONTROL
argument_list|)
expr_stmt|;
name|v
operator||=
name|SV_CM_CONTROL_ENHANCED
expr_stmt|;
name|sv_direct_set
argument_list|(
name|sc
argument_list|,
name|SV_CM_CONTROL
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Enable interrupts (UDM and MIDM are superfluous) */
name|v
operator|=
name|sv_direct_get
argument_list|(
name|sc
argument_list|,
name|SV_CM_IMR
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|SV_CM_IMR_AMSK
operator||
name|SV_CM_IMR_CMSK
operator||
name|SV_CM_IMR_SMSK
operator|)
expr_stmt|;
name|sv_direct_set
argument_list|(
name|sc
argument_list|,
name|SV_CM_IMR
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Select ADC PLL for ADC clock */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_CLOCK_SOURCE
argument_list|)
operator|&
operator|~
name|SV_CLOCK_ALTERNATE
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_CLOCK_SOURCE
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Disable loopback - binds ADC and DAC rates */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_LOOPBACK
argument_list|)
operator|&
operator|~
name|SV_LOOPBACK_ENABLE
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_LOOPBACK
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Disable SRS */
name|v
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_SRS_SPACE
argument_list|)
operator||
name|SV_SRS_DISABLED
expr_stmt|;
name|sv_indirect_set
argument_list|(
name|sc
argument_list|,
name|SV_REG_SRS_SPACE
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Get revision */
name|sc
operator|->
name|rev
operator|=
name|sv_indirect_get
argument_list|(
name|sc
argument_list|,
name|SV_REG_REVISION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|rch
operator|.
name|dma_was_active
operator|=
name|sc
operator|->
name|rch
operator|.
name|dma_active
expr_stmt|;
name|svrchan_trigger
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rch
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pch
operator|.
name|dma_was_active
operator|=
name|sc
operator|->
name|pch
operator|.
name|dma_active
expr_stmt|;
name|svrchan_trigger
argument_list|(
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|pch
argument_list|,
name|PCMTRIG_ABORT
argument_list|)
expr_stmt|;
name|sv_mix_mute_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sv_power
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sv_mix_mute_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sv_power
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv_init
argument_list|(
name|sc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the card\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mixer_reinit
argument_list|(
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|rch
operator|.
name|dma_was_active
condition|)
block|{
name|svrchan_trigger
argument_list|(
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rch
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|pch
operator|.
name|dma_was_active
condition|)
block|{
name|svpchan_trigger
argument_list|(
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|pch
argument_list|,
name|PCMTRIG_START
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Resource related */
end_comment

begin_function
specifier|static
name|void
name|sv_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|status
operator|=
name|sv_direct_get
argument_list|(
name|sc
argument_list|,
name|SV_CM_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SV_CM_STATUS_AINT
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SV_CM_STATUS_CINT
condition|)
name|chn_intr
argument_list|(
name|sc
operator|->
name|rch
operator|.
name|channel
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
operator|(
name|SV_CM_STATUS_AINT
operator||
name|SV_CM_STATUS_CINT
operator|)
expr_stmt|;
name|DEB
argument_list|(
argument|if (status) printf(
literal|"intr 0x%02x ?\n"
argument|, status)
argument_list|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|SV_PCI_ID
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"S3 Sonicvibes"
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
default|default:
return|return
name|ENXIO
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sv_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|u_long
name|midi_start
decl_stmt|,
name|games_start
decl_stmt|,
name|count
decl_stmt|,
name|sdmaa
decl_stmt|,
name|sdmac
decl_stmt|,
name|ml
decl_stmt|,
name|mu
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sc_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|500000
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"chip is in D%d power mode "
literal|"-- setting to D0\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|enh_rid
operator|=
name|SV_PCI_ENHANCED
expr_stmt|;
name|sc
operator|->
name|enh_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|enh_reg
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|enh_type
argument_list|,
operator|&
name|sc
operator|->
name|enh_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|SV_PCI_ENHANCED_SIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|enh_reg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: cannot allocate enh\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|enh_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|enh_reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enh_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|enh_reg
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sv_attach: initial dmaa 0x%08x\n"
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAC
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sv_attach: initial dmac 0x%08x\n"
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize DMA_A and DMA_C */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAA
argument_list|,
name|SV_PCI_DMA_EXTENDED
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAC
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Register IRQ handler */
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
operator|||
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
literal|0
argument_list|,
name|sv_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: Unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|,
name|SV_DEFAULT_BUFSZ
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/*alignment*/
literal|2
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|sc
operator|->
name|bufsz
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegz*/
literal|0x3ffff
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: Unable to create dma tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Power up and initialize */
name|sv_mix_mute_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sv_power
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|sv_mixer_class
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: Mixer failed to initialize\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* XXX This is a hack, and it's ugly.  Okay, the deal is this 	 * card has two more io regions that available for automatic 	 * configuration by the pci code.  These need to be allocated 	 * to used as control registers for the DMA engines. 	 * Unfortunately FBSD has no bus_space_foo() functions so we 	 * have to grab port space in region of existing resources.  Go 	 * for space between midi and game ports. 	 */
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|SV_PCI_MIDI
argument_list|,
operator|&
name|midi_start
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|SV_PCI_GAMES
argument_list|,
operator|&
name|games_start
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|games_start
operator|<
name|midi_start
condition|)
block|{
name|ml
operator|=
name|games_start
expr_stmt|;
name|mu
operator|=
name|midi_start
expr_stmt|;
block|}
else|else
block|{
name|ml
operator|=
name|midi_start
expr_stmt|;
name|mu
operator|=
name|games_start
expr_stmt|;
block|}
comment|/* Check assumptions about space availability and            alignment. How driver loaded can determine whether            games_start> midi_start or vice versa */
if|if
condition|(
operator|(
name|mu
operator|-
name|ml
operator|>=
literal|0x800
operator|)
operator|||
operator|(
operator|(
name|mu
operator|-
name|ml
operator|)
operator|%
literal|0x200
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: resource assumptions not met "
literal|"(midi 0x%08lx, games 0x%08lx)\n"
argument_list|,
name|midi_start
argument_list|,
name|games_start
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sdmaa
operator|=
name|ml
operator|+
literal|0x40
expr_stmt|;
name|sdmac
operator|=
name|sdmaa
operator|+
literal|0x40
expr_stmt|;
comment|/* Add resources to list of pci resources for this device - from here on 	 * they look like normal pci resources. */
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|SV_PCI_DMAA
argument_list|,
name|sdmaa
argument_list|,
name|SV_PCI_DMAA_SIZE
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|SV_PCI_DMAC
argument_list|,
name|sdmac
argument_list|,
name|SV_PCI_DMAC_SIZE
argument_list|)
expr_stmt|;
comment|/* Cache resource short-cuts for dma_a */
name|sc
operator|->
name|dmaa_rid
operator|=
name|SV_PCI_DMAA
expr_stmt|;
name|sc
operator|->
name|dmaa_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|dmaa_reg
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dmaa_type
argument_list|,
operator|&
name|sc
operator|->
name|dmaa_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|SV_PCI_ENHANCED_SIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmaa_reg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: cannot allocate dmaa\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|dmaa_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|dmaa_reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmaa_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|dmaa_reg
argument_list|)
expr_stmt|;
comment|/* Poke port into dma_a configuration, nb bit flags to enable dma */
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAA
argument_list|,
literal|4
argument_list|)
operator||
name|SV_PCI_DMA_ENABLE
operator||
name|SV_PCI_DMA_EXTENDED
expr_stmt|;
name|data
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|sdmaa
operator|&
literal|0xfffffff0
operator|)
operator||
operator|(
name|data
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAA
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dmaa: 0x%x 0x%x\n"
argument_list|,
name|data
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAA
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cache resource short-cuts for dma_c */
name|sc
operator|->
name|dmac_rid
operator|=
name|SV_PCI_DMAC
expr_stmt|;
name|sc
operator|->
name|dmac_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|dmac_reg
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dmac_type
argument_list|,
operator|&
name|sc
operator|->
name|dmac_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|SV_PCI_ENHANCED_SIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmac_reg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: cannot allocate dmac\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|dmac_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|dmac_reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmac_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|dmac_reg
argument_list|)
expr_stmt|;
comment|/* Poke port into dma_c configuration, nb bit flags to enable dma */
name|data
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAC
argument_list|,
literal|4
argument_list|)
operator||
name|SV_PCI_DMA_ENABLE
operator||
name|SV_PCI_DMA_EXTENDED
expr_stmt|;
name|data
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|sdmac
operator|&
literal|0xfffffff0
operator|)
operator||
operator|(
name|data
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAC
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dmac: 0x%x 0x%x\n"
argument_list|,
name|data
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|SV_PCI_DMAC
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Sonicvibes: revision %d.\n"
argument_list|,
name|sc
operator|->
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sv_attach: pcm_register fail\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|svpchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|svrchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx irq %ld %s"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|enh_reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_vibes
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sv_attach: succeeded\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|sc
operator|->
name|parent_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|enh_reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|enh_type
argument_list|,
name|sc
operator|->
name|enh_rid
argument_list|,
name|sc
operator|->
name|enh_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmaa_reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dmaa_type
argument_list|,
name|sc
operator|->
name|dmaa_rid
argument_list|,
name|sc
operator|->
name|dmaa_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmac_reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dmac_type
argument_list|,
name|sc
operator|->
name|dmac_rid
argument_list|,
name|sc
operator|->
name|dmac_reg
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sv_mix_mute_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sv_power
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|enh_type
argument_list|,
name|sc
operator|->
name|enh_rid
argument_list|,
name|sc
operator|->
name|enh_reg
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dmaa_type
argument_list|,
name|sc
operator|->
name|dmaa_rid
argument_list|,
name|sc
operator|->
name|dmaa_reg
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dmac_type
argument_list|,
name|sc
operator|->
name|dmac_rid
argument_list|,
name|sc
operator|->
name|dmac_reg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|sc_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sv_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sv_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|sv_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|sv_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|sv_suspend
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|sonicvibes_driver
init|=
block|{
literal|"pcm"
block|,
name|sc_methods
block|,
name|PCM_SOFTC_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_vibes
argument_list|,
name|pci
argument_list|,
name|sonicvibes_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_vibes
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_vibes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

