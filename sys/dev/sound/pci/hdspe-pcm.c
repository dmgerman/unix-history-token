begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Ruslan Bukin<br@bsdpad.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * RME HDSPe driver for FreeBSD (pcm-part).  * Supported cards: AIO, RayDAT.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/hdspe.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<mixer_if.h>
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|hdspe_latency
block|{
name|uint32_t
name|n
decl_stmt|;
name|uint32_t
name|period
decl_stmt|;
name|float
name|ms
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|hdspe_latency
name|latency_map
index|[]
init|=
block|{
block|{
literal|7
block|,
literal|32
block|,
literal|0.7
block|}
block|,
block|{
literal|0
block|,
literal|64
block|,
literal|1.5
block|}
block|,
block|{
literal|1
block|,
literal|128
block|,
literal|3
block|}
block|,
block|{
literal|2
block|,
literal|256
block|,
literal|6
block|}
block|,
block|{
literal|3
block|,
literal|512
block|,
literal|12
block|}
block|,
block|{
literal|4
block|,
literal|1024
block|,
literal|23
block|}
block|,
block|{
literal|5
block|,
literal|2048
block|,
literal|46
block|}
block|,
block|{
literal|6
block|,
literal|4096
block|,
literal|93
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|hdspe_rate
block|{
name|uint32_t
name|speed
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|hdspe_rate
name|rate_map
index|[]
init|=
block|{
block|{
literal|32000
block|,
operator|(
name|HDSPE_FREQ_32000
operator|)
block|}
block|,
block|{
literal|44100
block|,
operator|(
name|HDSPE_FREQ_44100
operator|)
block|}
block|,
block|{
literal|48000
block|,
operator|(
name|HDSPE_FREQ_48000
operator|)
block|}
block|,
block|{
literal|64000
block|,
operator|(
name|HDSPE_FREQ_32000
operator||
name|HDSPE_FREQ_DOUBLE
operator|)
block|}
block|,
block|{
literal|88200
block|,
operator|(
name|HDSPE_FREQ_44100
operator||
name|HDSPE_FREQ_DOUBLE
operator|)
block|}
block|,
block|{
literal|96000
block|,
operator|(
name|HDSPE_FREQ_48000
operator||
name|HDSPE_FREQ_DOUBLE
operator|)
block|}
block|,
block|{
literal|128000
block|,
operator|(
name|HDSPE_FREQ_32000
operator||
name|HDSPE_FREQ_QUAD
operator|)
block|}
block|,
block|{
literal|176400
block|,
operator|(
name|HDSPE_FREQ_44100
operator||
name|HDSPE_FREQ_QUAD
operator|)
block|}
block|,
block|{
literal|192000
block|,
operator|(
name|HDSPE_FREQ_48000
operator||
name|HDSPE_FREQ_QUAD
operator|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hdspe_hw_mixer
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|,
name|unsigned
name|int
name|dst
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|short
name|data
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|int
name|offs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|offs
operator|=
literal|64
expr_stmt|;
name|hdspe_write_4
argument_list|(
name|sc
argument_list|,
name|HDSPE_MIXER_BASE
operator|+
operator|(
operator|(
name|offs
operator|+
name|src
operator|+
literal|128
operator|*
name|dst
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
name|data
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|int
name|hdspechan_setgain
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|hdspe_hw_mixer
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|lslot
argument_list|,
name|ch
operator|->
name|lslot
argument_list|,
name|ch
operator|->
name|lvol
operator|*
name|HDSPE_MAX_GAIN
operator|/
literal|100
argument_list|)
expr_stmt|;
name|hdspe_hw_mixer
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|rslot
argument_list|,
name|ch
operator|->
name|rslot
argument_list|,
name|ch
operator|->
name|rvol
operator|*
name|HDSPE_MAX_GAIN
operator|/
literal|100
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspemixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|mask
operator|=
name|SOUND_MASK_PCM
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|hc
operator|->
name|play
condition|)
name|mask
operator||=
name|SOUND_MASK_VOLUME
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|hc
operator|->
name|rec
condition|)
name|mask
operator||=
name|SOUND_MASK_RECLEV
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pcm_setflags
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
operator||
name|SD_F_SOFTPCMVOL
argument_list|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspemixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|device_printf(scp->dev, "hdspemixer_set() %d %d\n", 	    left,right);
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|chnum
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|scp
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|==
name|SOUND_MIXER_VOLUME
operator|&&
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
operator|||
operator|(
name|dev
operator|==
name|SOUND_MIXER_RECLEV
operator|&&
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_REC
operator|)
condition|)
block|{
name|ch
operator|->
name|lvol
operator|=
name|left
expr_stmt|;
name|ch
operator|->
name|rvol
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|run
condition|)
name|hdspechan_setgain
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdspemixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|hdspemixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|hdspemixer_set
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|hdspemixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|hdspechan_enable
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|reg
operator|=
name|HDSPE_OUT_ENABLE_BASE
expr_stmt|;
else|else
name|reg
operator|=
name|HDSPE_IN_ENABLE_BASE
expr_stmt|;
name|ch
operator|->
name|run
operator|=
name|value
expr_stmt|;
name|hdspe_write_1
argument_list|(
name|sc
argument_list|,
name|reg
operator|+
operator|(
literal|4
operator|*
name|ch
operator|->
name|lslot
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|hdspe_write_1
argument_list|(
name|sc
argument_list|,
name|reg
operator|+
operator|(
literal|4
operator|*
name|ch
operator|->
name|rslot
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspe_running
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|devcount
decl_stmt|,
name|err
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|device_get_children
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|devcount
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|=
name|device_get_ivars
argument_list|(
name|devlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|scp
operator|->
name|chnum
condition|;
name|j
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|scp
operator|->
name|chan
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|run
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|#
directive|if
literal|0
block|device_printf(sc->dev,"hdspe is running\n");
endif|#
directive|endif
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdspe_start_audio
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|ctrl_register
operator||=
operator|(
name|HDSPE_AUDIO_INT_ENABLE
operator||
name|HDSPE_ENABLE
operator|)
expr_stmt|;
name|hdspe_write_4
argument_list|(
name|sc
argument_list|,
name|HDSPE_CONTROL_REG
argument_list|,
name|sc
operator|->
name|ctrl_register
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdspe_stop_audio
parameter_list|(
name|struct
name|sc_info
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|hdspe_running
argument_list|(
name|sc
argument_list|)
operator|==
literal|1
condition|)
return|return;
name|sc
operator|->
name|ctrl_register
operator|&=
operator|~
operator|(
name|HDSPE_AUDIO_INT_ENABLE
operator||
name|HDSPE_ENABLE
operator|)
expr_stmt|;
name|hdspe_write_4
argument_list|(
name|sc
argument_list|,
name|HDSPE_CONTROL_REG
argument_list|,
name|sc
operator|->
name|ctrl_register
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiplex / demultiplex: 2.0<-> 2 x 1.0. */
end_comment

begin_function
specifier|static
name|void
name|buffer_copy
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|int
name|length
decl_stmt|,
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|ssize
decl_stmt|,
name|dsize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|length
operator|=
name|sndbuf_getready
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
operator|(
literal|4
comment|/* Bytes per sample. */
operator|*
literal|2
comment|/* channels */
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|src
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|sndbuf_getfreeptr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|src
operator|/=
literal|4
expr_stmt|;
comment|/* Bytes per sample. */
name|dst
operator|=
name|src
operator|/
literal|2
expr_stmt|;
comment|/* Destination buffer twice smaller. */
name|ssize
operator|=
name|ch
operator|->
name|size
operator|/
literal|4
expr_stmt|;
name|dsize
operator|=
name|ch
operator|->
name|size
operator|/
literal|8
expr_stmt|;
comment|/* 	 * Use two fragment buffer to avoid sound clipping. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|period
operator|*
literal|2
comment|/* fragments */
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|sc
operator|->
name|pbuf
index|[
name|dst
operator|+
name|HDSPE_CHANBUF_SAMPLES
operator|*
name|ch
operator|->
name|lslot
index|]
operator|=
name|ch
operator|->
name|data
index|[
name|src
index|]
expr_stmt|;
name|sc
operator|->
name|pbuf
index|[
name|dst
operator|+
name|HDSPE_CHANBUF_SAMPLES
operator|*
name|ch
operator|->
name|rslot
index|]
operator|=
name|ch
operator|->
name|data
index|[
name|src
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|data
index|[
name|src
index|]
operator|=
name|sc
operator|->
name|rbuf
index|[
name|dst
operator|+
name|HDSPE_CHANBUF_SAMPLES
operator|*
name|ch
operator|->
name|lslot
index|]
expr_stmt|;
name|ch
operator|->
name|data
index|[
name|src
operator|+
literal|1
index|]
operator|=
name|sc
operator|->
name|rbuf
index|[
name|dst
operator|+
name|HDSPE_CHANBUF_SAMPLES
operator|*
name|ch
operator|->
name|rslot
index|]
expr_stmt|;
block|}
name|dst
operator|+=
literal|1
expr_stmt|;
name|dst
operator|%=
name|dsize
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|src
operator|%=
name|ssize
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|clean
parameter_list|(
name|struct
name|sc_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|uint32_t
modifier|*
name|buf
init|=
name|sc
operator|->
name|rbuf
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|pbuf
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buf
operator|+
name|HDSPE_CHANBUF_SAMPLES
operator|*
name|ch
operator|->
name|lslot
argument_list|,
name|HDSPE_CHANBUF_SIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
operator|+
name|HDSPE_CHANBUF_SAMPLES
operator|*
name|ch
operator|->
name|rslot
argument_list|,
name|HDSPE_CHANBUF_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Channel interface. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|hdspechan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|devinfo
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|int
name|num
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|num
operator|=
name|scp
operator|->
name|chnum
expr_stmt|;
name|ch
operator|=
operator|&
name|scp
operator|->
name|chan
index|[
name|num
index|]
expr_stmt|;
name|ch
operator|->
name|lslot
operator|=
name|scp
operator|->
name|hc
operator|->
name|left
expr_stmt|;
name|ch
operator|->
name|rslot
operator|=
name|scp
operator|->
name|hc
operator|->
name|right
expr_stmt|;
name|ch
operator|->
name|run
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|lvol
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|rvol
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|size
operator|=
name|HDSPE_CHANBUF_SIZE
operator|*
literal|2
comment|/* slots */
expr_stmt|;
name|ch
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|ch
operator|->
name|size
argument_list|,
name|M_HDSPE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|scp
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_setup
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|ch
operator|->
name|data
argument_list|,
name|ch
operator|->
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|scp
operator|->
name|dev
argument_list|,
literal|"Can't setup sndbuf.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspechan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
if|#
directive|if
literal|0
block|device_printf(scp->dev, "hdspechan_trigger(): start\n");
endif|#
directive|endif
name|hdspechan_enable
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdspechan_setgain
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdspe_start_audio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
if|#
directive|if
literal|0
block|device_printf(scp->dev, "hdspechan_trigger(): stop or abort\n");
endif|#
directive|endif
name|clean
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|hdspechan_enable
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdspe_stop_audio
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_EMLDMAWR
case|:
case|case
name|PCMTRIG_EMLDMARD
case|:
if|if
condition|(
name|ch
operator|->
name|run
condition|)
name|buffer_copy
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdspechan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|ret
decl_stmt|,
name|pos
decl_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|hdspe_read_2
argument_list|(
name|sc
argument_list|,
name|HDSPE_STATUS_REG
argument_list|)
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pos
operator|=
name|ret
operator|&
name|HDSPE_BUF_POSITION_MASK
expr_stmt|;
name|pos
operator|*=
literal|2
expr_stmt|;
comment|/* Hardbuf twice bigger. */
return|return
name|pos
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspechan_free
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
if|#
directive|if
literal|0
block|device_printf(scp->dev, "hdspechan_free()\n");
endif|#
directive|endif
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ch
operator|->
name|data
argument_list|,
name|M_HDSPE
argument_list|)
expr_stmt|;
name|ch
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspechan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|#
directive|if
literal|0
block|struct sc_pcminfo *scp = ch->parent; 	device_printf(scp->dev, "hdspechan_setformat(%d)\n", format);
endif|#
directive|endif
name|ch
operator|->
name|format
operator|=
name|format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdspechan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|struct
name|hdspe_rate
modifier|*
name|hr
init|=
name|NULL
decl_stmt|;
name|long
name|long
name|period
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|device_printf(scp->dev, "hdspechan_setspeed(%d)\n", speed);
endif|#
directive|endif
if|if
condition|(
name|hdspe_running
argument_list|(
name|sc
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|end
goto|;
comment|/* First look for equal frequency. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rate_map
index|[
name|i
index|]
operator|.
name|speed
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rate_map
index|[
name|i
index|]
operator|.
name|speed
operator|==
name|speed
condition|)
name|hr
operator|=
operator|&
name|rate_map
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If no match, just find nearest. */
if|if
condition|(
name|hr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rate_map
index|[
name|i
index|]
operator|.
name|speed
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|hr
operator|=
operator|&
name|rate_map
index|[
name|i
index|]
expr_stmt|;
name|threshold
operator|=
name|hr
operator|->
name|speed
operator|+
operator|(
operator|(
name|rate_map
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|speed
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|rate_map
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|speed
operator|-
name|hr
operator|->
name|speed
operator|)
operator|>>
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<
name|threshold
condition|)
break|break;
block|}
block|}
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|RAYDAT
case|:
case|case
name|AIO
case|:
name|period
operator|=
name|HDSPE_FREQ_AIO
expr_stmt|;
break|break;
default|default:
comment|/* Unsupported card. */
goto|goto
name|end
goto|;
block|}
comment|/* Write frequency on the device. */
name|sc
operator|->
name|ctrl_register
operator|&=
operator|~
name|HDSPE_FREQ_MASK
expr_stmt|;
name|sc
operator|->
name|ctrl_register
operator||=
name|hr
operator|->
name|reg
expr_stmt|;
name|hdspe_write_4
argument_list|(
name|sc
argument_list|,
name|HDSPE_CONTROL_REG
argument_list|,
name|sc
operator|->
name|ctrl_register
argument_list|)
expr_stmt|;
name|speed
operator|=
name|hr
operator|->
name|speed
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|96000
condition|)
name|speed
operator|/=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|>
literal|48000
condition|)
name|speed
operator|/=
literal|2
expr_stmt|;
comment|/* Set DDS value. */
name|period
operator|/=
name|speed
expr_stmt|;
name|hdspe_write_4
argument_list|(
name|sc
argument_list|,
name|HDSPE_FREQ_REG
argument_list|,
name|period
argument_list|)
expr_stmt|;
name|sc
operator|->
name|speed
operator|=
name|hr
operator|->
name|speed
expr_stmt|;
name|end
label|:
return|return
name|sc
operator|->
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdspechan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|sc_pcminfo
modifier|*
name|scp
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|struct
name|hdspe_latency
modifier|*
name|hl
init|=
name|NULL
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|device_printf(scp->dev, "hdspechan_setblocksize(%d)\n", blocksize);
endif|#
directive|endif
if|if
condition|(
name|hdspe_running
argument_list|(
name|sc
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|blocksize
operator|>
name|HDSPE_LAT_BYTES_MAX
condition|)
name|blocksize
operator|=
name|HDSPE_LAT_BYTES_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|blocksize
operator|<
name|HDSPE_LAT_BYTES_MIN
condition|)
name|blocksize
operator|=
name|HDSPE_LAT_BYTES_MIN
expr_stmt|;
name|blocksize
operator|/=
literal|4
comment|/* samples */
expr_stmt|;
comment|/* First look for equal latency. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|latency_map
index|[
name|i
index|]
operator|.
name|period
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|latency_map
index|[
name|i
index|]
operator|.
name|period
operator|==
name|blocksize
condition|)
block|{
name|hl
operator|=
operator|&
name|latency_map
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* If no match, just find nearest. */
if|if
condition|(
name|hl
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|latency_map
index|[
name|i
index|]
operator|.
name|period
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|hl
operator|=
operator|&
name|latency_map
index|[
name|i
index|]
expr_stmt|;
name|threshold
operator|=
name|hl
operator|->
name|period
operator|+
operator|(
operator|(
name|latency_map
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|period
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|latency_map
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|period
operator|-
name|hl
operator|->
name|period
operator|)
operator|>>
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|<
name|threshold
condition|)
break|break;
block|}
block|}
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ctrl_register
operator|&=
operator|~
name|HDSPE_LAT_MASK
expr_stmt|;
name|sc
operator|->
name|ctrl_register
operator||=
name|hdspe_encode_latency
argument_list|(
name|hl
operator|->
name|n
argument_list|)
expr_stmt|;
name|hdspe_write_4
argument_list|(
name|sc
argument_list|,
name|HDSPE_CONTROL_REG
argument_list|,
name|sc
operator|->
name|ctrl_register
argument_list|)
expr_stmt|;
name|sc
operator|->
name|period
operator|=
name|hl
operator|->
name|period
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|device_printf(scp->dev, "New period=%d\n", sc->period);
endif|#
directive|endif
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
operator|(
name|HDSPE_CHANBUF_SIZE
operator|*
literal|2
operator|)
operator|/
operator|(
name|sc
operator|->
name|period
operator|*
literal|4
operator|)
argument_list|,
operator|(
name|sc
operator|->
name|period
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|end
label|:
return|return
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint32_t
name|hdspe_rfmt
index|[]
init|=
block|{
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|hdspe_rcaps
init|=
block|{
literal|32000
block|,
literal|192000
block|,
name|hdspe_rfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|hdspe_pfmt
index|[]
init|=
block|{
name|SND_FORMAT
argument_list|(
name|AFMT_S32_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|hdspe_pcaps
init|=
block|{
literal|32000
block|,
literal|192000
block|,
name|hdspe_pfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|hdspechan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
if|#
directive|if
literal|0
block|struct sc_pcminfo *scl = ch->parent; 	device_printf(scp->dev, "hdspechan_getcaps()\n");
endif|#
directive|endif
return|return
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|hdspe_pcaps
else|:
operator|&
name|hdspe_rcaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|hdspechan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|hdspechan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|hdspechan_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|hdspechan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|hdspechan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|hdspechan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|hdspechan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|hdspechan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|hdspechan_getcaps
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|hdspechan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|hdspe_pcm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|#
directive|if
literal|0
block|device_printf(dev,"hdspe_pcm_probe()\n");
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|hdspe_pcm_intr
parameter_list|(
name|struct
name|sc_pcminfo
modifier|*
name|scp
parameter_list|)
block|{
name|struct
name|sc_chinfo
modifier|*
name|ch
decl_stmt|;
name|struct
name|sc_info
modifier|*
name|sc
init|=
name|scp
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|chnum
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|scp
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
name|snd_mtxunlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|chn_intr
argument_list|(
name|ch
operator|->
name|channel
argument_list|)
expr_stmt|;
name|snd_mtxlock
argument_list|(
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspe_pcm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sc_pcminfo
modifier|*
name|scp
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|char
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|scp
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ih
operator|=
operator|&
name|hdspe_pcm_intr
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
literal|"HDSPe AIO [%s]"
argument_list|,
name|scp
operator|->
name|hc
operator|->
name|descr
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
comment|/* 	 * We don't register interrupt handler with snd_setup_intr 	 * in pcm device. Mark pcm device as MPSAFE manually. 	 */
name|pcm_setflags
argument_list|(
name|dev
argument_list|,
name|pcm_getflags
argument_list|(
name|dev
argument_list|)
operator||
name|SD_F_MPSAFE
argument_list|)
expr_stmt|;
name|err
operator|=
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|hc
operator|->
name|play
argument_list|,
name|scp
operator|->
name|hc
operator|->
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't register pcm.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|scp
operator|->
name|chnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|hc
operator|->
name|play
condition|;
name|i
operator|++
control|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|hdspechan_class
argument_list|,
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|chnum
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|hc
operator|->
name|rec
condition|;
name|i
operator|++
control|)
block|{
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|hdspechan_class
argument_list|,
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|chnum
operator|++
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx irq %ld %s"
argument_list|,
name|rman_get_start
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|cs
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|scp
operator|->
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_hdspe
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mixer_init
argument_list|(
name|dev
argument_list|,
operator|&
name|hdspemixer_class
argument_list|,
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hdspe_pcm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't unregister device.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|hdspe_pcm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hdspe_pcm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hdspe_pcm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hdspe_pcm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hdspe_pcm_driver
init|=
block|{
literal|"pcm"
block|,
name|hdspe_pcm_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_hdspe_pcm
argument_list|,
name|hdspe
argument_list|,
name|hdspe_pcm_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_hdspe
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_hdspe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

