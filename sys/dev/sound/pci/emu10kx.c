begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Cameron Grant<cg@freebsd.org>  * Copyright (c) 2003-2007 Yuriy Tsibizov<yuriy.tsibizov@gfk.ru>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHERIN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/emuxkireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/emu10kx.h>
end_include

begin_comment
comment|/* hw flags */
end_comment

begin_define
define|#
directive|define
name|HAS_51
value|0x0001
end_define

begin_define
define|#
directive|define
name|HAS_71
value|0x0002
end_define

begin_define
define|#
directive|define
name|HAS_AC97
value|0x0004
end_define

begin_define
define|#
directive|define
name|IS_EMU10K1
value|0x0008
end_define

begin_define
define|#
directive|define
name|IS_EMU10K2
value|0x0010
end_define

begin_define
define|#
directive|define
name|IS_CA0102
value|0x0020
end_define

begin_define
define|#
directive|define
name|IS_CA0108
value|0x0040
end_define

begin_define
define|#
directive|define
name|IS_UNKNOWN
value|0x0080
end_define

begin_define
define|#
directive|define
name|BROKEN_DIGITAL
value|0x0100
end_define

begin_define
define|#
directive|define
name|DIGITAL_ONLY
value|0x0200
end_define

begin_define
define|#
directive|define
name|IS_CARDBUS
value|0x0400
end_define

begin_define
define|#
directive|define
name|MODE_ANALOG
value|1
end_define

begin_define
define|#
directive|define
name|MODE_DIGITAL
value|2
end_define

begin_define
define|#
directive|define
name|SPDIF_MODE_PCM
value|1
end_define

begin_define
define|#
directive|define
name|SPDIF_MODE_AC3
value|2
end_define

begin_define
define|#
directive|define
name|MACS
value|0x0
end_define

begin_define
define|#
directive|define
name|MACS1
value|0x1
end_define

begin_define
define|#
directive|define
name|MACW
value|0x2
end_define

begin_define
define|#
directive|define
name|MACW1
value|0x3
end_define

begin_define
define|#
directive|define
name|MACINTS
value|0x4
end_define

begin_define
define|#
directive|define
name|MACINTW
value|0x5
end_define

begin_define
define|#
directive|define
name|ACC3
value|0x6
end_define

begin_define
define|#
directive|define
name|MACMV
value|0x7
end_define

begin_define
define|#
directive|define
name|ANDXOR
value|0x8
end_define

begin_define
define|#
directive|define
name|TSTNEG
value|0x9
end_define

begin_define
define|#
directive|define
name|LIMIT
value|0xA
end_define

begin_define
define|#
directive|define
name|LIMIT1
value|0xB
end_define

begin_define
define|#
directive|define
name|LOG
value|0xC
end_define

begin_define
define|#
directive|define
name|EXP
value|0xD
end_define

begin_define
define|#
directive|define
name|INTERP
value|0xE
end_define

begin_define
define|#
directive|define
name|SKIP
value|0xF
end_define

begin_define
define|#
directive|define
name|GPR
parameter_list|(
name|i
parameter_list|)
value|(sc->gpr_base+(i))
end_define

begin_define
define|#
directive|define
name|INP
parameter_list|(
name|i
parameter_list|)
value|(sc->input_base+(i))
end_define

begin_define
define|#
directive|define
name|OUTP
parameter_list|(
name|i
parameter_list|)
value|(sc->output_base+(i))
end_define

begin_define
define|#
directive|define
name|FX
parameter_list|(
name|i
parameter_list|)
value|(i)
end_define

begin_define
define|#
directive|define
name|FX2
parameter_list|(
name|i
parameter_list|)
value|(sc->efxc_base+(i))
end_define

begin_define
define|#
directive|define
name|DSP_CONST
parameter_list|(
name|i
parameter_list|)
value|(sc->dsp_zero+(i))
end_define

begin_define
define|#
directive|define
name|COND_NORMALIZED
value|DSP_CONST(0x1)
end_define

begin_define
define|#
directive|define
name|COND_BORROW
value|DSP_CONST(0x2)
end_define

begin_define
define|#
directive|define
name|COND_MINUS
value|DSP_CONST(0x3)
end_define

begin_define
define|#
directive|define
name|COND_LESS_ZERO
value|DSP_CONST(0x4)
end_define

begin_define
define|#
directive|define
name|COND_EQ_ZERO
value|DSP_CONST(0x5)
end_define

begin_define
define|#
directive|define
name|COND_SATURATION
value|DSP_CONST(0x6)
end_define

begin_define
define|#
directive|define
name|COND_NEQ_ZERO
value|DSP_CONST(0x8)
end_define

begin_define
define|#
directive|define
name|DSP_ACCUM
value|DSP_CONST(0x16)
end_define

begin_define
define|#
directive|define
name|DSP_CCR
value|DSP_CONST(0x17)
end_define

begin_comment
comment|/* Live! Inputs */
end_comment

begin_define
define|#
directive|define
name|IN_AC97_L
value|0x00
end_define

begin_define
define|#
directive|define
name|IN_AC97_R
value|0x01
end_define

begin_define
define|#
directive|define
name|IN_AC97
value|IN_AC97_L
end_define

begin_define
define|#
directive|define
name|IN_SPDIF_CD_L
value|0x02
end_define

begin_define
define|#
directive|define
name|IN_SPDIF_CD_R
value|0x03
end_define

begin_define
define|#
directive|define
name|IN_SPDIF_CD
value|IN_SPDIF_CD_L
end_define

begin_define
define|#
directive|define
name|IN_ZOOM_L
value|0x04
end_define

begin_define
define|#
directive|define
name|IN_ZOOM_R
value|0x05
end_define

begin_define
define|#
directive|define
name|IN_ZOOM
value|IN_ZOOM_L
end_define

begin_define
define|#
directive|define
name|IN_TOSLINK_L
value|0x06
end_define

begin_define
define|#
directive|define
name|IN_TOSLINK_R
value|0x07
end_define

begin_define
define|#
directive|define
name|IN_TOSLINK
value|IN_TOSLINK_L
end_define

begin_define
define|#
directive|define
name|IN_LINE1_L
value|0x08
end_define

begin_define
define|#
directive|define
name|IN_LINE1_R
value|0x09
end_define

begin_define
define|#
directive|define
name|IN_LINE1
value|IN_LINE1_L
end_define

begin_define
define|#
directive|define
name|IN_COAX_SPDIF_L
value|0x0a
end_define

begin_define
define|#
directive|define
name|IN_COAX_SPDIF_R
value|0x0b
end_define

begin_define
define|#
directive|define
name|IN_COAX_SPDIF
value|IN_COAX_SPDIF_L
end_define

begin_define
define|#
directive|define
name|IN_LINE2_L
value|0x0c
end_define

begin_define
define|#
directive|define
name|IN_LINE2_R
value|0x0d
end_define

begin_define
define|#
directive|define
name|IN_LINE2
value|IN_LINE2_L
end_define

begin_define
define|#
directive|define
name|IN_0E
value|0x0e
end_define

begin_define
define|#
directive|define
name|IN_0F
value|0x0f
end_define

begin_comment
comment|/* Outputs */
end_comment

begin_define
define|#
directive|define
name|OUT_AC97_L
value|0x00
end_define

begin_define
define|#
directive|define
name|OUT_AC97_R
value|0x01
end_define

begin_define
define|#
directive|define
name|OUT_AC97
value|OUT_AC97_L
end_define

begin_define
define|#
directive|define
name|OUT_A_FRONT
value|OUT_AC97
end_define

begin_define
define|#
directive|define
name|OUT_TOSLINK_L
value|0x02
end_define

begin_define
define|#
directive|define
name|OUT_TOSLINK_R
value|0x03
end_define

begin_define
define|#
directive|define
name|OUT_TOSLINK
value|OUT_TOSLINK_L
end_define

begin_define
define|#
directive|define
name|OUT_D_CENTER
value|0x04
end_define

begin_define
define|#
directive|define
name|OUT_D_SUB
value|0x05
end_define

begin_define
define|#
directive|define
name|OUT_HEADPHONE_L
value|0x06
end_define

begin_define
define|#
directive|define
name|OUT_HEADPHONE_R
value|0x07
end_define

begin_define
define|#
directive|define
name|OUT_HEADPHONE
value|OUT_HEADPHONE_L
end_define

begin_define
define|#
directive|define
name|OUT_REAR_L
value|0x08
end_define

begin_define
define|#
directive|define
name|OUT_REAR_R
value|0x09
end_define

begin_define
define|#
directive|define
name|OUT_REAR
value|OUT_REAR_L
end_define

begin_define
define|#
directive|define
name|OUT_ADC_REC_L
value|0x0a
end_define

begin_define
define|#
directive|define
name|OUT_ADC_REC_R
value|0x0b
end_define

begin_define
define|#
directive|define
name|OUT_ADC_REC
value|OUT_ADC_REC_L
end_define

begin_define
define|#
directive|define
name|OUT_MIC_CAP
value|0x0c
end_define

begin_comment
comment|/* Live! 5.1 Digital, non-standard 5.1 (center& sub) outputs */
end_comment

begin_define
define|#
directive|define
name|OUT_A_CENTER
value|0x11
end_define

begin_define
define|#
directive|define
name|OUT_A_SUB
value|0x12
end_define

begin_comment
comment|/* Audigy Inputs */
end_comment

begin_define
define|#
directive|define
name|A_IN_AC97_L
value|0x00
end_define

begin_define
define|#
directive|define
name|A_IN_AC97_R
value|0x01
end_define

begin_define
define|#
directive|define
name|A_IN_AC97
value|A_IN_AC97_L
end_define

begin_define
define|#
directive|define
name|A_IN_SPDIF_CD_L
value|0x02
end_define

begin_define
define|#
directive|define
name|A_IN_SPDIF_CD_R
value|0x03
end_define

begin_define
define|#
directive|define
name|A_IN_SPDIF_CD
value|A_IN_SPDIF_CD_L
end_define

begin_define
define|#
directive|define
name|A_IN_O_SPDIF_L
value|0x04
end_define

begin_define
define|#
directive|define
name|A_IN_O_SPDIF_R
value|0x05
end_define

begin_define
define|#
directive|define
name|A_IN_O_SPDIF
value|A_IN_O_SPDIF_L
end_define

begin_define
define|#
directive|define
name|A_IN_LINE2_L
value|0x08
end_define

begin_define
define|#
directive|define
name|A_IN_LINE2_R
value|0x09
end_define

begin_define
define|#
directive|define
name|A_IN_LINE2
value|A_IN_LINE2_L
end_define

begin_define
define|#
directive|define
name|A_IN_R_SPDIF_L
value|0x0a
end_define

begin_define
define|#
directive|define
name|A_IN_R_SPDIF_R
value|0x0b
end_define

begin_define
define|#
directive|define
name|A_IN_R_SPDIF
value|A_IN_R_SPDIF_L
end_define

begin_define
define|#
directive|define
name|A_IN_AUX2_L
value|0x0c
end_define

begin_define
define|#
directive|define
name|A_IN_AUX2_R
value|0x0d
end_define

begin_define
define|#
directive|define
name|A_IN_AUX2
value|A_IN_AUX2_L
end_define

begin_comment
comment|/* Audigy Outputs */
end_comment

begin_define
define|#
directive|define
name|A_OUT_D_FRONT_L
value|0x00
end_define

begin_define
define|#
directive|define
name|A_OUT_D_FRONT_R
value|0x01
end_define

begin_define
define|#
directive|define
name|A_OUT_D_FRONT
value|A_OUT_D_FRONT_L
end_define

begin_define
define|#
directive|define
name|A_OUT_D_CENTER
value|0x02
end_define

begin_define
define|#
directive|define
name|A_OUT_D_SUB
value|0x03
end_define

begin_define
define|#
directive|define
name|A_OUT_D_SIDE_L
value|0x04
end_define

begin_define
define|#
directive|define
name|A_OUT_D_SIDE_R
value|0x05
end_define

begin_define
define|#
directive|define
name|A_OUT_D_SIDE
value|A_OUT_D_SIDE_L
end_define

begin_define
define|#
directive|define
name|A_OUT_D_REAR_L
value|0x06
end_define

begin_define
define|#
directive|define
name|A_OUT_D_REAR_R
value|0x07
end_define

begin_define
define|#
directive|define
name|A_OUT_D_REAR
value|A_OUT_D_REAR_L
end_define

begin_comment
comment|/* on Audigy Platinum only */
end_comment

begin_define
define|#
directive|define
name|A_OUT_HPHONE_L
value|0x04
end_define

begin_define
define|#
directive|define
name|A_OUT_HPHONE_R
value|0x05
end_define

begin_define
define|#
directive|define
name|A_OUT_HPHONE
value|A_OUT_HPHONE_L
end_define

begin_define
define|#
directive|define
name|A_OUT_A_FRONT_L
value|0x08
end_define

begin_define
define|#
directive|define
name|A_OUT_A_FRONT_R
value|0x09
end_define

begin_define
define|#
directive|define
name|A_OUT_A_FRONT
value|A_OUT_A_FRONT_L
end_define

begin_define
define|#
directive|define
name|A_OUT_A_CENTER
value|0x0a
end_define

begin_define
define|#
directive|define
name|A_OUT_A_SUB
value|0x0b
end_define

begin_define
define|#
directive|define
name|A_OUT_A_SIDE_L
value|0x0c
end_define

begin_define
define|#
directive|define
name|A_OUT_A_SIDE_R
value|0x0d
end_define

begin_define
define|#
directive|define
name|A_OUT_A_SIDE
value|A_OUT_A_SIDE_L
end_define

begin_define
define|#
directive|define
name|A_OUT_A_REAR_L
value|0x0e
end_define

begin_define
define|#
directive|define
name|A_OUT_A_REAR_R
value|0x0f
end_define

begin_define
define|#
directive|define
name|A_OUT_A_REAR
value|A_OUT_A_REAR_L
end_define

begin_define
define|#
directive|define
name|A_OUT_AC97_L
value|0x10
end_define

begin_define
define|#
directive|define
name|A_OUT_AC97_R
value|0x11
end_define

begin_define
define|#
directive|define
name|A_OUT_AC97
value|A_OUT_AC97_L
end_define

begin_define
define|#
directive|define
name|A_OUT_ADC_REC_L
value|0x16
end_define

begin_define
define|#
directive|define
name|A_OUT_ADC_REC_R
value|0x17
end_define

begin_define
define|#
directive|define
name|A_OUT_ADC_REC
value|A_OUT_ADC_REC_L
end_define

begin_define
define|#
directive|define
name|EMU_DATA2
value|0x24
end_define

begin_define
define|#
directive|define
name|EMU_IPR2
value|0x28
end_define

begin_define
define|#
directive|define
name|EMU_INTE2
value|0x2c
end_define

begin_define
define|#
directive|define
name|EMU_IPR3
value|0x38
end_define

begin_define
define|#
directive|define
name|EMU_INTE3
value|0x3c
end_define

begin_define
define|#
directive|define
name|EMU_A2_SRCSel
value|0x60
end_define

begin_define
define|#
directive|define
name|EMU_A2_SRCMULTI_ENABLE
value|0x6e
end_define

begin_define
define|#
directive|define
name|EMU_A_I2S_CAPTURE_96000
value|0x00000400
end_define

begin_define
define|#
directive|define
name|EMU_A2_MIXER_I2S_ENABLE
value|0x7B
end_define

begin_define
define|#
directive|define
name|EMU_A2_MIXER_SPDIF_ENABLE
value|0x7A
end_define

begin_define
define|#
directive|define
name|C_FRONT_L
value|0
end_define

begin_define
define|#
directive|define
name|C_FRONT_R
value|1
end_define

begin_define
define|#
directive|define
name|C_REC_L
value|2
end_define

begin_define
define|#
directive|define
name|C_REC_R
value|3
end_define

begin_define
define|#
directive|define
name|C_REAR_L
value|4
end_define

begin_define
define|#
directive|define
name|C_REAR_R
value|5
end_define

begin_define
define|#
directive|define
name|C_CENTER
value|6
end_define

begin_define
define|#
directive|define
name|C_SUB
value|7
end_define

begin_define
define|#
directive|define
name|C_SIDE_L
value|8
end_define

begin_define
define|#
directive|define
name|C_SIDE_R
value|9
end_define

begin_define
define|#
directive|define
name|NUM_CACHES
value|10
end_define

begin_define
define|#
directive|define
name|CDSPDIFMUTE
value|0
end_define

begin_define
define|#
directive|define
name|ANALOGMUTE
value|1
end_define

begin_define
define|#
directive|define
name|NUM_MUTE
value|2
end_define

begin_define
define|#
directive|define
name|EMU_MAX_GPR
value|512
end_define

begin_define
define|#
directive|define
name|EMU_MAX_IRQ_CONSUMERS
value|32
end_define

begin_struct
struct|struct
name|emu_voice
block|{
name|int
name|vnum
decl_stmt|;
name|unsigned
name|int
name|b16
range|:
literal|1
decl_stmt|,
name|stereo
range|:
literal|1
decl_stmt|,
name|busy
range|:
literal|1
decl_stmt|,
name|running
range|:
literal|1
decl_stmt|,
name|ismaster
range|:
literal|1
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|;
name|void
modifier|*
name|vbuf
decl_stmt|;
name|struct
name|emu_voice
modifier|*
name|slave
decl_stmt|;
name|uint32_t
name|sa
decl_stmt|;
name|uint32_t
name|ea
decl_stmt|;
name|uint32_t
name|routing
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|amounts
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_memblk
block|{
name|SLIST_ENTRY
argument_list|(
argument|emu_memblk
argument_list|)
name|link
expr_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|char
name|owner
index|[
literal|16
index|]
decl_stmt|;
name|bus_addr_t
name|buf_addr
decl_stmt|;
name|uint32_t
name|pte_start
decl_stmt|,
name|pte_size
decl_stmt|;
name|bus_dmamap_t
name|buf_map
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_mem
block|{
name|uint8_t
name|bmap
index|[
name|EMU_MAXPAGES
operator|/
literal|8
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|ptb_pages
decl_stmt|;
name|void
modifier|*
name|silent_page
decl_stmt|;
name|bus_addr_t
name|ptb_pages_addr
decl_stmt|;
name|bus_addr_t
name|silent_page_addr
decl_stmt|;
name|bus_dmamap_t
name|ptb_map
decl_stmt|;
name|bus_dmamap_t
name|silent_map
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|struct
name|emu_sc_info
modifier|*
name|card
decl_stmt|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|emu_memblk
argument_list|)
name|blocks
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* rm */
end_comment

begin_struct
struct|struct
name|emu_rm
block|{
name|struct
name|emu_sc_info
modifier|*
name|card
decl_stmt|;
name|struct
name|mtx
name|gpr_lock
decl_stmt|;
name|signed
name|int
name|allocmap
index|[
name|EMU_MAX_GPR
index|]
decl_stmt|;
name|int
name|num_gprs
decl_stmt|;
name|int
name|last_free_gpr
decl_stmt|;
name|int
name|num_used
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_intr_handler
block|{
name|void
modifier|*
name|softc
decl_stmt|;
name|uint32_t
name|intr_mask
decl_stmt|;
name|uint32_t
name|inte_mask
decl_stmt|;
name|uint32_t
function_decl|(
modifier|*
name|irq_func
function_decl|)
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
name|uint32_t
name|irq
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|emu_sc_info
block|{
name|struct
name|mtx
name|lock
decl_stmt|;
name|struct
name|mtx
name|rw
decl_stmt|;
comment|/* Hardware exclusive access lock */
comment|/* Hardware and subdevices */
name|device_t
name|dev
decl_stmt|;
name|device_t
name|pcm
index|[
name|RT_COUNT
index|]
decl_stmt|;
name|device_t
name|midi
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|uint32_t
name|rev
decl_stmt|;
name|bus_space_tag_t
name|st
decl_stmt|;
name|bus_space_handle_t
name|sh
decl_stmt|;
name|struct
name|cdev
modifier|*
name|cdev
decl_stmt|;
comment|/* /dev/emu10k character device */
name|struct
name|mtx
name|emu10kx_lock
decl_stmt|;
name|int
name|emu10kx_isopen
decl_stmt|;
name|struct
name|sbuf
name|emu10kx_sbuf
decl_stmt|;
name|int
name|emu10kx_bufptr
decl_stmt|;
comment|/* Resources */
name|struct
name|resource
modifier|*
name|reg
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
comment|/* IRQ handlers */
name|struct
name|emu_intr_handler
name|ihandler
index|[
name|EMU_MAX_IRQ_CONSUMERS
index|]
decl_stmt|;
comment|/* Card HW configuration */
name|unsigned
name|int
name|mode
decl_stmt|;
comment|/* analog / digital */
name|unsigned
name|int
name|mchannel_fx
decl_stmt|;
name|unsigned
name|int
name|dsp_zero
decl_stmt|;
name|unsigned
name|int
name|code_base
decl_stmt|;
name|unsigned
name|int
name|code_size
decl_stmt|;
name|unsigned
name|int
name|gpr_base
decl_stmt|;
name|unsigned
name|int
name|num_gprs
decl_stmt|;
name|unsigned
name|int
name|input_base
decl_stmt|;
name|unsigned
name|int
name|output_base
decl_stmt|;
name|unsigned
name|int
name|efxc_base
decl_stmt|;
name|unsigned
name|int
name|opcode_shift
decl_stmt|;
name|unsigned
name|int
name|high_operand_shift
decl_stmt|;
name|unsigned
name|int
name|address_mask
decl_stmt|;
name|uint32_t
name|is_emu10k1
range|:
literal|1
decl_stmt|,
name|is_emu10k2
decl_stmt|,
name|is_ca0102
decl_stmt|,
name|is_ca0108
range|:
literal|1
decl_stmt|,
name|has_ac97
range|:
literal|1
decl_stmt|,
name|has_51
range|:
literal|1
decl_stmt|,
name|has_71
range|:
literal|1
decl_stmt|,
name|enable_ir
range|:
literal|1
decl_stmt|,
name|broken_digital
range|:
literal|1
decl_stmt|,
name|is_cardbus
range|:
literal|1
decl_stmt|;
name|signed
name|int
name|mch_disabled
decl_stmt|,
name|mch_rec
decl_stmt|,
name|dbg_level
decl_stmt|;
name|signed
name|int
name|num_inputs
decl_stmt|;
name|unsigned
name|int
name|num_outputs
decl_stmt|;
name|unsigned
name|int
name|num_fxbuses
decl_stmt|;
name|unsigned
name|int
name|routing_code_start
decl_stmt|;
name|unsigned
name|int
name|routing_code_end
decl_stmt|;
comment|/* HW resources */
name|struct
name|emu_voice
name|voice
index|[
name|NUM_G
index|]
decl_stmt|;
comment|/* Hardware voices */
name|uint32_t
name|irq_mask
index|[
name|EMU_MAX_IRQ_CONSUMERS
index|]
decl_stmt|;
comment|/* IRQ manager data */
name|int
name|timer
index|[
name|EMU_MAX_IRQ_CONSUMERS
index|]
decl_stmt|;
comment|/* timer */
name|int
name|timerinterval
decl_stmt|;
name|struct
name|emu_rm
modifier|*
name|rm
decl_stmt|;
name|struct
name|emu_mem
name|mem
decl_stmt|;
comment|/* memory */
comment|/* Mixer */
name|int
name|mixer_gpr
index|[
name|NUM_MIXERS
index|]
decl_stmt|;
name|int
name|mixer_volcache
index|[
name|NUM_MIXERS
index|]
decl_stmt|;
name|int
name|cache_gpr
index|[
name|NUM_CACHES
index|]
decl_stmt|;
name|int
name|dummy_gpr
decl_stmt|;
name|int
name|mute_gpr
index|[
name|NUM_MUTE
index|]
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|emu_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|emu_malloc
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|uint32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_free
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|dmabuf
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|emu_memalloc
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|uint32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_memfree
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|membuf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_memstart
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|membuf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* /dev */
end_comment

begin_function_decl
specifier|static
name|int
name|emu10kx_dev_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu10kx_dev_uninit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu10kx_prepare
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sbuf
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emumix_set_mode
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emumix_set_spdif_mode
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emumix_set_fxvol
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|gpr
parameter_list|,
name|int32_t
name|vol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emumix_set_gpr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|gpr
parameter_list|,
name|int32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_emu_mixer_control
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_rm_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_rm_uninit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_rm_gpr_alloc
parameter_list|(
name|struct
name|emu_rm
modifier|*
name|rm
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|emu_getcard
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|emu_rd_nolock
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_wr_nolock
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_wr_cbptr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_vstop
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_wrefx
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|pc
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_addefxop
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|,
name|unsigned
name|int
name|z
parameter_list|,
name|unsigned
name|int
name|w
parameter_list|,
name|unsigned
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|y
parameter_list|,
name|uint32_t
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emu_initefx
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_cardbus_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_uninit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_read_ivar
parameter_list|(
name|device_t
name|bus
name|__unused
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|ivar_index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_write_ivar
parameter_list|(
name|device_t
name|bus
name|__unused
parameter_list|,
name|device_t
name|dev
name|__unused
parameter_list|,
name|int
name|ivar_index
parameter_list|,
name|uintptr_t
name|value
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|emu_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SND_EMU10KX_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|EMU_MTX_DEBUG
parameter_list|()
value|do { 						\ 		if (mtx_owned(&sc->rw)) {				\ 		printf("RW owned in %s line %d for %s\n", __func__,	\ 			__LINE__ , device_get_nameunit(sc->dev));	\ 		printf("rw lock owned: %d\n", mtx_owned(&sc->rw));	\ 		printf("rw lock: value %x thread %x\n",			\ 			((&sc->rw)->mtx_lock& ~MTX_FLAGMASK), 		\ 			(uintptr_t)curthread);				\ 		printf("rw lock: recursed %d\n", mtx_recursed(&sc->rw));\ 		db_show_mtx(&sc->rw);					\ 		}							\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EMU_MTX_DEBUG
parameter_list|()
value|do { 						\ 	} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EMU_RWLOCK
parameter_list|()
value|do {		\ 	EMU_MTX_DEBUG();		\ 	mtx_lock(&(sc->rw));		\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|EMU_RWUNLOCK
parameter_list|()
value|do {		\ 	mtx_unlock(&(sc->rw));		\ 	EMU_MTX_DEBUG();		\ 	} while (0)
end_define

begin_comment
comment|/* Supported cards */
end_comment

begin_struct
struct|struct
name|emu_hwinfo
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|subvendor
decl_stmt|;
name|uint16_t
name|subdevice
decl_stmt|;
name|char
name|SBcode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|desc
index|[
literal|32
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|emu_hwinfo
name|emu_cards
index|[]
init|=
block|{
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|"BADCRD"
block|,
literal|"Not a compatible card"
block|,
literal|0
block|}
block|,
comment|/* 0x0020..0x002f 4.0 EMU10K1 cards */
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x0020
block|,
literal|"CT4850"
block|,
literal|"SBLive! Value"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x0021
block|,
literal|"CT4620"
block|,
literal|"SBLive!"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x002f
block|,
literal|"CT????"
block|,
literal|"SBLive! mainboard implementation"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
comment|/* (range unknown) 5.1 EMU10K1 cards */
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x100a
block|,
literal|"CT????"
block|,
literal|"SBLive! 5.1"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
comment|/* 0x80??..0x805? 4.0 EMU10K1 cards */
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8022
block|,
literal|"CT4780"
block|,
literal|"SBLive! Value"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8023
block|,
literal|"CT4790"
block|,
literal|"SB PCI512"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8024
block|,
literal|"CT4760"
block|,
literal|"SBLive!"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8025
block|,
literal|"CT????"
block|,
literal|"SBLive! Mainboard Implementation"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8026
block|,
literal|"CT4830"
block|,
literal|"SBLive! Value"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8027
block|,
literal|"CT4832"
block|,
literal|"SBLive! Value"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8028
block|,
literal|"CT4760"
block|,
literal|"SBLive! OEM version"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8031
block|,
literal|"CT4831"
block|,
literal|"SBLive! Value"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8040
block|,
literal|"CT4760"
block|,
literal|"SBLive!"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8051
block|,
literal|"CT4850"
block|,
literal|"SBLive! Value"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
comment|/* 0x8061..0x???? 5.1 EMU10K1  cards */
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8061
block|,
literal|"SB????"
block|,
literal|"SBLive! Player 5.1"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8062
block|,
literal|"CT4830"
block|,
literal|"SBLive! 1024"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8064
block|,
literal|"SB????"
block|,
literal|"SBLive! 5.1"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8065
block|,
literal|"SB0220"
block|,
literal|"SBLive! 5.1 Digital"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8066
block|,
literal|"CT4780"
block|,
literal|"SBLive! 5.1 Digital"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x8067
block|,
literal|"SB????"
block|,
literal|"SBLive!"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K1
block|}
block|,
comment|/* Generic SB Live! */
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x0000
block|,
literal|"SB????"
block|,
literal|"SBLive! (Unknown model)"
block|,
name|HAS_AC97
operator||
name|IS_EMU10K1
block|}
block|,
comment|/* 0x0041..0x0043 EMU10K2 (some kind of Audigy) cards */
comment|/* 0x0051..0x0051 5.1 CA0100-IAF cards */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x0051
block|,
literal|"SB0090"
block|,
literal|"Audigy"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K2
block|}
block|,
comment|/* ES is CA0100-IDF chip that don't work in digital mode */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x0052
block|,
literal|"SB0160"
block|,
literal|"Audigy ES"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_EMU10K2
operator||
name|BROKEN_DIGITAL
block|}
block|,
comment|/* 0x0053..0x005C 5.1 CA0101-NAF cards */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x0053
block|,
literal|"SB0090"
block|,
literal|"Audigy Player/OEM"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K2
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x0058
block|,
literal|"SB0090"
block|,
literal|"Audigy Player/OEM"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K2
block|}
block|,
comment|/* 0x1002..0x1009 5.1 CA0102-IAT cards */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x1002
block|,
literal|"SB????"
block|,
literal|"Audigy 2 Platinum"
block|,
name|HAS_51
operator||
name|IS_CA0102
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x1005
block|,
literal|"SB????"
block|,
literal|"Audigy 2 Platinum EX"
block|,
name|HAS_51
operator||
name|IS_CA0102
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x1007
block|,
literal|"SB0240"
block|,
literal|"Audigy 2"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_CA0102
block|}
block|,
comment|/* 0x2001..0x2003 7.1 CA0102-ICT cards */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x2001
block|,
literal|"SB0350"
block|,
literal|"Audigy 2 ZS"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0102
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x2002
block|,
literal|"SB0350"
block|,
literal|"Audigy 2 ZS"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0102
block|}
block|,
comment|/* XXX No reports about 0x2003& 0x2004 cards */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x2003
block|,
literal|"SB0350"
block|,
literal|"Audigy 2 ZS"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0102
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x2004
block|,
literal|"SB0350"
block|,
literal|"Audigy 2 ZS"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0102
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x2005
block|,
literal|"SB0350"
block|,
literal|"Audigy 2 ZS"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0102
block|}
block|,
comment|/* (range unknown) 7.1 CA0102-xxx Audigy 4 cards */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x2007
block|,
literal|"SB0380"
block|,
literal|"Audigy 4 Pro"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0102
block|}
block|,
comment|/* Generic Audigy or Audigy 2 */
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x0000
block|,
literal|"SB????"
block|,
literal|"Audigy (Unknown model)"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_EMU10K2
block|}
block|,
comment|/* We don't support CA0103-DAT (Audigy LS) cards */
comment|/* There is NO CA0104-xxx cards */
comment|/* There is NO CA0105-xxx cards */
comment|/* We don't support CA0106-DAT (SB Live! 24 bit) cards */
comment|/* There is NO CA0107-xxx cards */
comment|/* 0x1000..0x1001 7.1 CA0108-IAT cards */
block|{
literal|0x1102
block|,
literal|0x0008
block|,
literal|0x1102
block|,
literal|0x1000
block|,
literal|"SB????"
block|,
literal|"Audigy 2 LS"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_CA0108
operator||
name|DIGITAL_ONLY
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0008
block|,
literal|0x1102
block|,
literal|0x1001
block|,
literal|"SB0400"
block|,
literal|"Audigy 2 Value"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0108
operator||
name|DIGITAL_ONLY
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0008
block|,
literal|0x1102
block|,
literal|0x1021
block|,
literal|"SB0610"
block|,
literal|"Audigy 4"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0108
operator||
name|DIGITAL_ONLY
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0008
block|,
literal|0x1102
block|,
literal|0x2001
block|,
literal|"SB0530"
block|,
literal|"Audigy 2 ZS CardBus"
block|,
name|HAS_AC97
operator||
name|HAS_71
operator||
name|IS_CA0108
operator||
name|IS_CARDBUS
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0008
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|"SB????"
block|,
literal|"Audigy 2 Value (Unknown model)"
block|,
name|HAS_AC97
operator||
name|HAS_51
operator||
name|IS_CA0108
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unsupported cards */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|emu_hwinfo
name|emu_bad_cards
index|[]
init|=
block|{
comment|/* APS cards should be possible to support */
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x4001
block|,
literal|"EMUAPS"
block|,
literal|"E-mu APS"
block|,
literal|0
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0002
block|,
literal|0x1102
block|,
literal|0x4002
block|,
literal|"EMUAPS"
block|,
literal|"E-mu APS"
block|,
literal|0
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0004
block|,
literal|0x1102
block|,
literal|0x4001
block|,
literal|"EMU???"
block|,
literal|"E-mu 1212m [4001]"
block|,
literal|0
block|}
block|,
comment|/* Similar-named ("Live!" or "Audigy") cards on different chipsets */
block|{
literal|0x1102
block|,
literal|0x8064
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|"SB0100"
block|,
literal|"SBLive! 5.1 OEM"
block|,
literal|0
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0006
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|"SB0200"
block|,
literal|"DELL OEM SBLive! Value"
block|,
literal|0
block|}
block|,
block|{
literal|0x1102
block|,
literal|0x0007
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|"SB0310"
block|,
literal|"Audigy LS"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get best known information about device.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|emu_getcard
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|subdevice
decl_stmt|;
name|int
name|n_cards
decl_stmt|;
name|unsigned
name|int
name|thiscard
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_DEVICE
argument_list|,
comment|/* bytes */
literal|2
argument_list|)
expr_stmt|;
name|subdevice
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
comment|/* bytes */
literal|2
argument_list|)
expr_stmt|;
name|n_cards
operator|=
sizeof|sizeof
argument_list|(
name|emu_cards
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|emu_hwinfo
argument_list|)
expr_stmt|;
name|thiscard
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_cards
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device
operator|==
name|emu_cards
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
if|if
condition|(
name|subdevice
operator|==
name|emu_cards
index|[
name|i
index|]
operator|.
name|subdevice
condition|)
block|{
name|thiscard
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|0x0000
operator|==
name|emu_cards
index|[
name|i
index|]
operator|.
name|subdevice
condition|)
block|{
name|thiscard
operator|=
name|i
expr_stmt|;
comment|/* 				 * don't break, we can get more specific card 				 * later in the list. 				 */
block|}
block|}
block|}
name|n_cards
operator|=
sizeof|sizeof
argument_list|(
name|emu_bad_cards
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|emu_hwinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_cards
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device
operator|==
name|emu_bad_cards
index|[
name|i
index|]
operator|.
name|device
condition|)
block|{
if|if
condition|(
name|subdevice
operator|==
name|emu_bad_cards
index|[
name|i
index|]
operator|.
name|subdevice
condition|)
block|{
name|thiscard
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|0x0000
operator|==
name|emu_bad_cards
index|[
name|i
index|]
operator|.
name|subdevice
condition|)
block|{
name|thiscard
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* we avoid all this cards */
block|}
block|}
block|}
return|return
operator|(
name|thiscard
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Base hardware interface are 32 (Audigy) or 64 (Audigy2) registers.  * Some of them are used directly, some of them provide pointer / data pairs.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|emu_rd_nolock
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"emu_rd: NULL sc"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0xffffffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_wr_nolock
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"emu_rd: NULL sc"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|st
argument_list|,
name|sc
operator|->
name|sh
argument_list|,
name|regno
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * EMU_PTR / EMU_DATA interface. Access to EMU10Kx is made  * via (channel, register) pair. Some registers are channel-specific,  * some not.  */
end_comment

begin_function
name|uint32_t
name|emu_rdptr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|chn
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|)
block|{
name|uint32_t
name|ptr
decl_stmt|,
name|val
decl_stmt|,
name|mask
decl_stmt|,
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|ptr
operator|=
operator|(
operator|(
name|reg
operator|<<
literal|16
operator|)
operator|&
name|sc
operator|->
name|address_mask
operator|)
operator||
operator|(
name|chn
operator|&
name|EMU_PTR_CHNO_MASK
operator|)
expr_stmt|;
name|EMU_RWLOCK
argument_list|()
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_PTR
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_DATA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|EMU_RWUNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * XXX Some register numbers has data size and offset encoded in 	 * it to get only part of 32bit register. This use is not described 	 * in register name, be careful! 	 */
if|if
condition|(
name|reg
operator|&
literal|0xff000000
condition|)
block|{
name|size
operator|=
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|offset
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|offset
expr_stmt|;
name|val
operator|&=
name|mask
expr_stmt|;
name|val
operator|>>=
name|offset
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|emu_wrptr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|chn
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|ptr
decl_stmt|,
name|mask
decl_stmt|,
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|ptr
operator|=
operator|(
operator|(
name|reg
operator|<<
literal|16
operator|)
operator|&
name|sc
operator|->
name|address_mask
operator|)
operator||
operator|(
name|chn
operator|&
name|EMU_PTR_CHNO_MASK
operator|)
expr_stmt|;
name|EMU_RWLOCK
argument_list|()
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_PTR
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Another kind of magic encoding in register number. This can 	 * give you side effect - it will read previous data from register 	 * and change only required bits. 	 */
if|if
condition|(
name|reg
operator|&
literal|0xff000000
condition|)
block|{
name|size
operator|=
operator|(
name|reg
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|offset
operator|=
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|offset
expr_stmt|;
name|data
operator|<<=
name|offset
expr_stmt|;
name|data
operator|&=
name|mask
expr_stmt|;
name|data
operator||=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_DATA
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
block|}
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_DATA
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|EMU_RWUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * EMU_A2_PTR / EMU_DATA2 interface. Access to P16v is made  * via (channel, register) pair. Some registers are channel-specific,  * some not. This interface is supported by CA0102 and CA0108 chips only.  */
end_comment

begin_function
name|uint32_t
name|emu_rd_p16vptr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|chn
parameter_list|,
name|uint16_t
name|reg
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* XXX separate lock? */
name|EMU_RWLOCK
argument_list|()
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A2_PTR
argument_list|,
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
name|chn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_DATA2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|EMU_RWUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|emu_wr_p16vptr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|chn
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|EMU_RWLOCK
argument_list|()
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A2_PTR
argument_list|,
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
name|chn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_DATA2
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|EMU_RWUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX CardBus interface. Not tested on any real hardware.  */
end_comment

begin_function
specifier|static
name|void
name|emu_wr_cbptr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* 	 * 0x38 is IPE3 (CD S/PDIF interrupt pending register) on CA0102. Seems 	 * to be some reg/value accessible kind of config register on CardBus 	 * CA0108, with value(?) in top 16 bit, address(?) in low 16 	 */
name|val
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
literal|0x38
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
literal|0x38
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
literal|0x38
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Direct hardware register access  * Assume that it is never used to access EMU_PTR-based registers and can run unlocked.  */
end_comment

begin_function
name|void
name|emu_wr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|regno
operator|!=
name|EMU_PTR
argument_list|,
operator|(
literal|"emu_wr: attempt to write to EMU_PTR"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|regno
operator|!=
name|EMU_A2_PTR
argument_list|,
operator|(
literal|"emu_wr: attempt to write to EMU_A2_PTR"
operator|)
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|emu_rd
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|uint32_t
name|rd
decl_stmt|;
name|KASSERT
argument_list|(
name|regno
operator|!=
name|EMU_DATA
argument_list|,
operator|(
literal|"emu_rd: attempt to read DATA"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|regno
operator|!=
name|EMU_DATA2
argument_list|,
operator|(
literal|"emu_rd: attempt to read DATA2"
operator|)
argument_list|)
expr_stmt|;
name|rd
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
name|regno
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|rd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enabling IR MIDI messages is another kind of black magic. It just  * has to be made this way. It really do it.  */
end_comment

begin_function
name|void
name|emu_enable_ir
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|iocfg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k2
operator|||
name|sc
operator|->
name|is_ca0102
condition|)
block|{
name|iocfg
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
name|iocfg
operator||
name|EMU_A_IOCFG_GPOUT2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
name|iocfg
operator||
name|EMU_A_IOCFG_GPOUT1
operator||
name|EMU_A_IOCFG_GPOUT2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
name|iocfg
operator||
name|EMU_A_IOCFG_GPOUT1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
name|iocfg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Audigy IR MIDI events enabled.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enable_ir
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|iocfg
operator|=
name|emu_rd_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
name|iocfg
operator||
name|EMU_HCFG_GPOUT2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
name|iocfg
operator||
name|EMU_HCFG_GPOUT1
operator||
name|EMU_HCFG_GPOUT2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|emu_wr_nolock
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
name|iocfg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"SB Live! IR MIDI events enabled.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enable_ir
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * emu_timer_ - HW timer management  */
end_comment

begin_function
name|int
name|emu_timer_create
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|timer
decl_stmt|;
name|timer
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|timer
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|timer
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* disable it */
name|timer
operator|=
name|i
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|timer
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emu_timer_set
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|timer
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|timer
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|RANGE
argument_list|(
name|delay
argument_list|,
literal|16
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
name|timer
argument_list|,
literal|0
argument_list|,
name|EMU_MAX_IRQ_CONSUMERS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|=
name|delay
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|timerinterval
operator|>
name|sc
operator|->
name|timer
index|[
name|i
index|]
condition|)
name|sc
operator|->
name|timerinterval
operator|=
name|sc
operator|->
name|timer
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_TIMER
argument_list|,
name|sc
operator|->
name|timerinterval
operator|&
literal|0x03ff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|timer
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emu_timer_enable
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|timer
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
name|int
name|ena_int
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|timer
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|RANGE
argument_list|(
name|timer
argument_list|,
literal|0
argument_list|,
name|EMU_MAX_IRQ_CONSUMERS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|go
operator|==
literal|1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|<
literal|0
operator|)
condition|)
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|=
operator|-
name|sc
operator|->
name|timer
index|[
name|timer
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|go
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|>
literal|0
operator|)
condition|)
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|=
operator|-
name|sc
operator|->
name|timer
index|[
name|timer
index|]
expr_stmt|;
name|ena_int
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|timerinterval
operator|>
name|sc
operator|->
name|timer
index|[
name|i
index|]
condition|)
name|sc
operator|->
name|timerinterval
operator|=
name|sc
operator|->
name|timer
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|timer
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|ena_int
operator|=
literal|1
expr_stmt|;
block|}
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_TIMER
argument_list|,
name|sc
operator|->
name|timerinterval
operator|&
literal|0x03ff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ena_int
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator||=
name|EMU_INTE_INTERTIMERENB
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|EMU_INTE_INTERTIMERENB
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emu_timer_clear
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|timer
parameter_list|)
block|{
if|if
condition|(
name|timer
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|RANGE
argument_list|(
name|timer
argument_list|,
literal|0
argument_list|,
name|EMU_MAX_IRQ_CONSUMERS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emu_timer_enable
argument_list|(
name|sc
argument_list|,
name|timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|!=
literal|0
condition|)
name|sc
operator|->
name|timer
index|[
name|timer
index|]
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|timer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * emu_intr_ - HW interrupt handler management  */
end_comment

begin_function
name|int
name|emu_intr_register
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|inte_mask
parameter_list|,
name|uint32_t
name|intr_mask
parameter_list|,
name|uint32_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
name|uint32_t
name|irq
parameter_list|)
parameter_list|,
name|void
modifier|*
name|isc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|inte_mask
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|inte_mask
operator|=
name|inte_mask
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|intr_mask
operator|=
name|intr_mask
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|softc
operator|=
name|isc
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|irq_func
operator|=
name|func
expr_stmt|;
name|x
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator||=
name|inte_mask
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ihandle %d registered\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ihandle not registered\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emu_intr_unregister
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|hnumber
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ihandler
index|[
name|hnumber
index|]
operator|.
name|inte_mask
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|x
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
name|sc
operator|->
name|ihandler
index|[
name|hnumber
index|]
operator|.
name|inte_mask
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|hnumber
index|]
operator|.
name|inte_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|hnumber
index|]
operator|.
name|intr_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|hnumber
index|]
operator|.
name|softc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|ihandler
index|[
name|hnumber
index|]
operator|.
name|irq_func
operator|=
name|NULL
expr_stmt|;
comment|/* other interrupt handlers may use this EMU_INTE value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|inte_mask
operator|!=
literal|0
condition|)
name|x
operator||=
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|inte_mask
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
name|x
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|hnumber
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|emu_sc_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|emu_sc_info
operator|*
operator|)
name|p
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|,
name|ack
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|stat
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_IPR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_IPR
argument_list|,
name|stat
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|intr_mask
operator|)
operator|&
name|stat
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|irq_func
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ack
operator||=
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|irq_func
argument_list|(
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|softc
argument_list|,
operator|(
name|sc
operator|->
name|ihandler
index|[
name|i
index|]
operator|.
name|intr_mask
operator|)
operator|&
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
if|if
condition|(
name|stat
operator|&
operator|(
operator|~
name|ack
operator|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unhandled interrupt: %08x\n"
argument_list|,
name|stat
operator|&
operator|(
operator|~
name|ack
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|stat
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_IPR2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_IPR2
argument_list|,
name|stat
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"EMU_IPR2: %08x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
comment|/* to avoid infinite loop. should be removed 				 * after completion of P16V interface. */
block|}
if|if
condition|(
name|sc
operator|->
name|is_ca0102
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|stat
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_IPR3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
break|break;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_IPR3
argument_list|,
name|stat
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"EMU_IPR3: %08x\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
break|break;
comment|/* to avoid infinite loop. should be removed 				 * after completion of S/PDIF interface */
block|}
block|}
end_function

begin_comment
comment|/*  * Get data from private emu10kx structure for PCM buffer allocation.  * Used by PCM code only.  */
end_comment

begin_function
name|bus_dma_tag_t
name|emu_gettag
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|mem
operator|.
name|dmat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_setmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|phys
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|*
name|phys
operator|=
name|error
condition|?
literal|0
else|:
operator|(
name|bus_addr_t
operator|)
name|segs
operator|->
name|ds_addr
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"emu10kx: setmap (%lx, %lx), nseg=%d, error=%d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segs
operator|->
name|ds_len
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|emu_malloc
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|uint32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|)
block|{
name|void
modifier|*
name|dmabuf
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
operator|&
name|dmabuf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|map
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|card
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|mem
operator|->
name|card
operator|->
name|dev
argument_list|,
literal|"emu_malloc: failed to alloc DMA map: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
operator|*
name|map
argument_list|,
name|dmabuf
argument_list|,
name|sz
argument_list|,
name|emu_setmap
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|!
operator|*
name|addr
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|card
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|mem
operator|->
name|card
operator|->
name|dev
argument_list|,
literal|"emu_malloc: failed to load DMA memory: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|dmabuf
argument_list|,
operator|*
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dmabuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_free
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|dmabuf
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mem
operator|->
name|dmat
argument_list|,
name|dmabuf
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|emu_memalloc
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|uint32_t
name|sz
parameter_list|,
name|bus_addr_t
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|)
block|{
name|uint32_t
name|blksz
decl_stmt|,
name|start
decl_stmt|,
name|idx
decl_stmt|,
name|ofs
decl_stmt|,
name|tmp
decl_stmt|,
name|found
decl_stmt|;
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|;
name|void
modifier|*
name|membuf
decl_stmt|;
name|blksz
operator|=
name|sz
operator|/
name|EMUPAGESIZE
expr_stmt|;
if|if
condition|(
name|sz
operator|>
operator|(
name|blksz
operator|*
name|EMUPAGESIZE
operator|)
condition|)
name|blksz
operator|++
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
name|EMU_MAX_BUFSZ
operator|/
name|EMUPAGESIZE
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|card
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|mem
operator|->
name|card
operator|->
name|dev
argument_list|,
literal|"emu_memalloc: memory request tool large\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* find a free block in the bitmap */
name|found
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|found
operator|&&
name|start
operator|+
name|blksz
operator|<
name|EMU_MAXPAGES
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<
name|start
operator|+
name|blksz
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|mem
operator|->
name|bmap
index|[
name|idx
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
condition|)
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|card
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|mem
operator|->
name|card
operator|->
name|dev
argument_list|,
literal|"emu_memalloc: no free space in bitmap\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|blk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|blk
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|card
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|mem
operator|->
name|card
operator|->
name|dev
argument_list|,
literal|"emu_memalloc: buffer allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|blk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|blk
argument_list|)
argument_list|)
expr_stmt|;
name|membuf
operator|=
name|emu_malloc
argument_list|(
name|mem
argument_list|,
name|sz
argument_list|,
operator|&
name|blk
operator|->
name|buf_addr
argument_list|,
operator|&
name|blk
operator|->
name|buf_map
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|blk
operator|->
name|buf_addr
expr_stmt|;
if|if
condition|(
name|membuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|card
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|mem
operator|->
name|card
operator|->
name|dev
argument_list|,
literal|"emu_memalloc: can't setup HW memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|blk
operator|->
name|buf
operator|=
name|membuf
expr_stmt|;
name|blk
operator|->
name|pte_start
operator|=
name|start
expr_stmt|;
name|blk
operator|->
name|pte_size
operator|=
name|blksz
expr_stmt|;
name|strncpy
argument_list|(
name|blk
operator|->
name|owner
argument_list|,
name|owner
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|blk
operator|->
name|owner
index|[
literal|15
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<
name|start
operator|+
name|blksz
condition|;
name|idx
operator|++
control|)
block|{
name|mem
operator|->
name|bmap
index|[
name|idx
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|idx
operator|&
literal|7
operator|)
expr_stmt|;
name|tmp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|blk
operator|->
name|buf_addr
operator|+
name|ofs
argument_list|)
expr_stmt|;
name|mem
operator|->
name|ptb_pages
index|[
name|idx
index|]
operator|=
operator|(
name|tmp
operator|<<
literal|1
operator|)
operator||
name|idx
expr_stmt|;
name|ofs
operator|+=
name|EMUPAGESIZE
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mem
operator|->
name|blocks
argument_list|,
name|blk
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|membuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_memfree
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|membuf
parameter_list|)
block|{
name|uint32_t
name|idx
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|blk
operator|=
name|NULL
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|i
argument_list|,
argument|&mem->blocks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|i
operator|->
name|buf
operator|==
name|membuf
condition|)
name|blk
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|mem
operator|->
name|blocks
argument_list|,
name|blk
argument_list|,
name|emu_memblk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|emu_free
argument_list|(
name|mem
argument_list|,
name|membuf
argument_list|,
name|blk
operator|->
name|buf_map
argument_list|)
expr_stmt|;
name|tmp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|mem
operator|->
name|silent_page_addr
argument_list|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|blk
operator|->
name|pte_start
init|;
name|idx
operator|<
name|blk
operator|->
name|pte_start
operator|+
name|blk
operator|->
name|pte_size
condition|;
name|idx
operator|++
control|)
block|{
name|mem
operator|->
name|bmap
index|[
name|idx
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|mem
operator|->
name|ptb_pages
index|[
name|idx
index|]
operator|=
name|tmp
operator||
name|idx
expr_stmt|;
block|}
name|free
argument_list|(
name|blk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_memstart
parameter_list|(
name|struct
name|emu_mem
modifier|*
name|mem
parameter_list|,
name|void
modifier|*
name|membuf
parameter_list|)
block|{
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|,
modifier|*
name|i
decl_stmt|;
name|blk
operator|=
name|NULL
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|i
argument_list|,
argument|&mem->blocks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|i
operator|->
name|buf
operator|==
name|membuf
condition|)
name|blk
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|blk
operator|->
name|pte_start
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|emu_rate_to_pitch
parameter_list|(
name|uint32_t
name|rate
parameter_list|)
block|{
specifier|static
name|uint32_t
name|logMagTable
index|[
literal|128
index|]
init|=
block|{
literal|0x00000
block|,
literal|0x02dfc
block|,
literal|0x05b9e
block|,
literal|0x088e6
block|,
literal|0x0b5d6
block|,
literal|0x0e26f
block|,
literal|0x10eb3
block|,
literal|0x13aa2
block|,
literal|0x1663f
block|,
literal|0x1918a
block|,
literal|0x1bc84
block|,
literal|0x1e72e
block|,
literal|0x2118b
block|,
literal|0x23b9a
block|,
literal|0x2655d
block|,
literal|0x28ed5
block|,
literal|0x2b803
block|,
literal|0x2e0e8
block|,
literal|0x30985
block|,
literal|0x331db
block|,
literal|0x359eb
block|,
literal|0x381b6
block|,
literal|0x3a93d
block|,
literal|0x3d081
block|,
literal|0x3f782
block|,
literal|0x41e42
block|,
literal|0x444c1
block|,
literal|0x46b01
block|,
literal|0x49101
block|,
literal|0x4b6c4
block|,
literal|0x4dc49
block|,
literal|0x50191
block|,
literal|0x5269e
block|,
literal|0x54b6f
block|,
literal|0x57006
block|,
literal|0x59463
block|,
literal|0x5b888
block|,
literal|0x5dc74
block|,
literal|0x60029
block|,
literal|0x623a7
block|,
literal|0x646ee
block|,
literal|0x66a00
block|,
literal|0x68cdd
block|,
literal|0x6af86
block|,
literal|0x6d1fa
block|,
literal|0x6f43c
block|,
literal|0x7164b
block|,
literal|0x73829
block|,
literal|0x759d4
block|,
literal|0x77b4f
block|,
literal|0x79c9a
block|,
literal|0x7bdb5
block|,
literal|0x7dea1
block|,
literal|0x7ff5e
block|,
literal|0x81fed
block|,
literal|0x8404e
block|,
literal|0x86082
block|,
literal|0x88089
block|,
literal|0x8a064
block|,
literal|0x8c014
block|,
literal|0x8df98
block|,
literal|0x8fef1
block|,
literal|0x91e20
block|,
literal|0x93d26
block|,
literal|0x95c01
block|,
literal|0x97ab4
block|,
literal|0x9993e
block|,
literal|0x9b79f
block|,
literal|0x9d5d9
block|,
literal|0x9f3ec
block|,
literal|0xa11d8
block|,
literal|0xa2f9d
block|,
literal|0xa4d3c
block|,
literal|0xa6ab5
block|,
literal|0xa8808
block|,
literal|0xaa537
block|,
literal|0xac241
block|,
literal|0xadf26
block|,
literal|0xafbe7
block|,
literal|0xb1885
block|,
literal|0xb3500
block|,
literal|0xb5157
block|,
literal|0xb6d8c
block|,
literal|0xb899f
block|,
literal|0xba58f
block|,
literal|0xbc15e
block|,
literal|0xbdd0c
block|,
literal|0xbf899
block|,
literal|0xc1404
block|,
literal|0xc2f50
block|,
literal|0xc4a7b
block|,
literal|0xc6587
block|,
literal|0xc8073
block|,
literal|0xc9b3f
block|,
literal|0xcb5ed
block|,
literal|0xcd07c
block|,
literal|0xceaec
block|,
literal|0xd053f
block|,
literal|0xd1f73
block|,
literal|0xd398a
block|,
literal|0xd5384
block|,
literal|0xd6d60
block|,
literal|0xd8720
block|,
literal|0xda0c3
block|,
literal|0xdba4a
block|,
literal|0xdd3b4
block|,
literal|0xded03
block|,
literal|0xe0636
block|,
literal|0xe1f4e
block|,
literal|0xe384a
block|,
literal|0xe512c
block|,
literal|0xe69f3
block|,
literal|0xe829f
block|,
literal|0xe9b31
block|,
literal|0xeb3a9
block|,
literal|0xecc08
block|,
literal|0xee44c
block|,
literal|0xefc78
block|,
literal|0xf148a
block|,
literal|0xf2c83
block|,
literal|0xf4463
block|,
literal|0xf5c2a
block|,
literal|0xf73da
block|,
literal|0xf8b71
block|,
literal|0xfa2f0
block|,
literal|0xfba57
block|,
literal|0xfd1a7
block|,
literal|0xfe8df
block|}
decl_stmt|;
specifier|static
name|char
name|logSlopeTable
index|[
literal|128
index|]
init|=
block|{
literal|0x5c
block|,
literal|0x5c
block|,
literal|0x5b
block|,
literal|0x5a
block|,
literal|0x5a
block|,
literal|0x59
block|,
literal|0x58
block|,
literal|0x58
block|,
literal|0x57
block|,
literal|0x56
block|,
literal|0x56
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0x54
block|,
literal|0x53
block|,
literal|0x53
block|,
literal|0x52
block|,
literal|0x52
block|,
literal|0x51
block|,
literal|0x51
block|,
literal|0x50
block|,
literal|0x50
block|,
literal|0x4f
block|,
literal|0x4f
block|,
literal|0x4e
block|,
literal|0x4d
block|,
literal|0x4d
block|,
literal|0x4d
block|,
literal|0x4c
block|,
literal|0x4c
block|,
literal|0x4b
block|,
literal|0x4b
block|,
literal|0x4a
block|,
literal|0x4a
block|,
literal|0x49
block|,
literal|0x49
block|,
literal|0x48
block|,
literal|0x48
block|,
literal|0x47
block|,
literal|0x47
block|,
literal|0x47
block|,
literal|0x46
block|,
literal|0x46
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x44
block|,
literal|0x44
block|,
literal|0x43
block|,
literal|0x43
block|,
literal|0x43
block|,
literal|0x42
block|,
literal|0x42
block|,
literal|0x42
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x3f
block|,
literal|0x3f
block|,
literal|0x3f
block|,
literal|0x3e
block|,
literal|0x3e
block|,
literal|0x3e
block|,
literal|0x3d
block|,
literal|0x3d
block|,
literal|0x3d
block|,
literal|0x3c
block|,
literal|0x3c
block|,
literal|0x3c
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3a
block|,
literal|0x3a
block|,
literal|0x3a
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x2f
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rate
operator|*=
literal|11185
expr_stmt|;
comment|/* Scale 48000 to 0x20002380 */
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|rate
operator|&
literal|0x80000000
condition|)
block|{
comment|/* Detect leading "1" */
return|return
operator|(
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|i
operator|-
literal|15
argument_list|)
operator|<<
literal|20
operator|)
operator|+
name|logMagTable
index|[
literal|0x7f
operator|&
operator|(
name|rate
operator|>>
literal|24
operator|)
index|]
operator|+
operator|(
literal|0x7f
operator|&
operator|(
name|rate
operator|>>
literal|17
operator|)
operator|)
operator|*
name|logSlopeTable
index|[
literal|0x7f
operator|&
operator|(
name|rate
operator|>>
literal|24
operator|)
index|]
operator|)
return|;
block|}
name|rate
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|emu_rate_to_linearpitch
parameter_list|(
name|uint32_t
name|rate
parameter_list|)
block|{
name|rate
operator|=
operator|(
name|rate
operator|<<
literal|8
operator|)
operator|/
literal|375
expr_stmt|;
return|return
operator|(
operator|(
name|rate
operator|>>
literal|1
operator|)
operator|+
operator|(
name|rate
operator|&
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|emu_voice
modifier|*
name|emu_valloc
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|emu_voice
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_G
operator|&&
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|busy
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|NUM_G
condition|)
block|{
name|v
operator|=
operator|&
name|sc
operator|->
name|voice
index|[
name|i
index|]
expr_stmt|;
name|v
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|void
name|emu_vfree
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_G
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|==
operator|&
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|&&
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|busy
condition|)
block|{
name|v
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
comment|/* 			 * XXX What we should do with mono channels? 			 * See -pcm.c emupchan_init for other side of 			 * this problem 			 */
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
name|r
operator|=
name|emu_memfree
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|v
operator|->
name|vbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|emu_vinit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|m
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|s
parameter_list|,
name|uint32_t
name|sz
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
name|void
modifier|*
name|vbuf
decl_stmt|;
name|bus_addr_t
name|tmp_addr
decl_stmt|;
name|vbuf
operator|=
name|emu_memalloc
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|sz
argument_list|,
operator|&
name|tmp_addr
argument_list|,
literal|"vinit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"emu_memalloc returns NULL in enu_vinit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
name|sndbuf_setup
argument_list|(
name|b
argument_list|,
name|vbuf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|m
operator|->
name|start
operator|=
name|emu_memstart
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|vbuf
argument_list|)
operator|*
name|EMUPAGESIZE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|start
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|2
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"emu_memstart returns (-1) in enu_vinit\n"
argument_list|)
expr_stmt|;
name|emu_memfree
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|vbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|->
name|end
operator|=
name|m
operator|->
name|start
operator|+
name|sz
expr_stmt|;
name|m
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|b16
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|stereo
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|ismaster
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|vol
operator|=
literal|0xff
expr_stmt|;
name|m
operator|->
name|buf
operator|=
name|tmp_addr
expr_stmt|;
name|m
operator|->
name|vbuf
operator|=
name|vbuf
expr_stmt|;
name|m
operator|->
name|slave
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|start
operator|=
name|m
operator|->
name|start
expr_stmt|;
name|s
operator|->
name|end
operator|=
name|m
operator|->
name|end
expr_stmt|;
name|s
operator|->
name|speed
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|b16
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stereo
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ismaster
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|vol
operator|=
name|m
operator|->
name|vol
expr_stmt|;
name|s
operator|->
name|buf
operator|=
name|m
operator|->
name|buf
expr_stmt|;
name|s
operator|->
name|vbuf
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|slave
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|emu_vsetup
parameter_list|(
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|,
name|int
name|fmt
parameter_list|,
name|int
name|spd
parameter_list|)
block|{
if|if
condition|(
name|fmt
condition|)
block|{
name|v
operator|->
name|b16
operator|=
operator|(
name|fmt
operator|&
name|AFMT_16BIT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|v
operator|->
name|stereo
operator|=
operator|(
name|AFMT_CHANNEL
argument_list|(
name|fmt
argument_list|)
operator|>
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
block|{
name|v
operator|->
name|slave
operator|->
name|b16
operator|=
name|v
operator|->
name|b16
expr_stmt|;
name|v
operator|->
name|slave
operator|->
name|stereo
operator|=
name|v
operator|->
name|stereo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spd
condition|)
block|{
name|v
operator|->
name|speed
operator|=
name|spd
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|slave
operator|!=
name|NULL
condition|)
name|v
operator|->
name|slave
operator|->
name|speed
operator|=
name|v
operator|->
name|speed
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|emu_vroute
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_route
modifier|*
name|rt
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|->
name|routing
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|routing_left
index|[
name|i
index|]
expr_stmt|;
name|v
operator|->
name|amounts
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|amounts_left
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v
operator|->
name|stereo
operator|)
operator|&&
operator|(
name|v
operator|->
name|ismaster
operator|==
literal|0
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|->
name|routing
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|routing_right
index|[
name|i
index|]
expr_stmt|;
name|v
operator|->
name|amounts
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|amounts_right
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v
operator|->
name|stereo
operator|)
operator|&&
operator|(
name|v
operator|->
name|slave
operator|!=
name|NULL
operator|)
condition|)
name|emu_vroute
argument_list|(
name|sc
argument_list|,
name|rt
argument_list|,
name|v
operator|->
name|slave
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emu_vwrite
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|uint32_t
name|start
decl_stmt|,
name|val
decl_stmt|,
name|silent_page
decl_stmt|;
name|s
operator|=
operator|(
name|v
operator|->
name|stereo
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|v
operator|->
name|sa
operator|=
name|v
operator|->
name|start
operator|>>
name|s
expr_stmt|;
name|v
operator|->
name|ea
operator|=
name|v
operator|->
name|end
operator|>>
name|s
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|stereo
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CPF
argument_list|,
name|EMU_CHAN_CPF_STEREO_MASK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CPF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|v
operator|->
name|stereo
condition|?
literal|28
else|:
literal|30
expr_stmt|;
name|val
operator|*=
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|start
operator|=
name|v
operator|->
name|sa
operator|+
name|val
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_FXRT
argument_list|,
operator|(
operator|(
name|v
operator|->
name|routing
index|[
literal|3
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|1
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|0
index|]
operator|<<
literal|0
operator|)
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_A_CHAN_FXRT1
argument_list|,
operator|(
name|v
operator|->
name|routing
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|0
index|]
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_A_CHAN_FXRT2
argument_list|,
operator|(
name|v
operator|->
name|routing
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|v
operator|->
name|routing
index|[
literal|4
index|]
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_A_CHAN_SENDAMOUNTS
argument_list|,
operator|(
name|v
operator|->
name|amounts
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|v
operator|->
name|amounts
index|[
literal|6
index|]
operator|<<
literal|26
operator|)
operator||
operator|(
name|v
operator|->
name|amounts
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|v
operator|->
name|amounts
index|[
literal|4
index|]
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_PTRX
argument_list|,
operator|(
name|v
operator|->
name|amounts
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|v
operator|->
name|amounts
index|[
literal|1
index|]
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_DSL
argument_list|,
name|v
operator|->
name|ea
operator||
operator|(
name|v
operator|->
name|amounts
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_PSST
argument_list|,
name|v
operator|->
name|sa
operator||
operator|(
name|v
operator|->
name|amounts
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CCCA
argument_list|,
name|start
operator||
operator|(
name|v
operator|->
name|b16
condition|?
literal|0
else|:
name|EMU_CHAN_CCCA_8BITSELECT
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_Z1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_Z2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|silent_page
operator|=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|)
operator|<<
literal|1
operator|)
operator||
name|EMU_CHAN_MAP_PTI_MASK
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_MAPA
argument_list|,
name|silent_page
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_MAPB
argument_list|,
name|silent_page
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CVCF
argument_list|,
name|EMU_CHAN_CVCF_CURRFILTER_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_VTFT
argument_list|,
name|EMU_CHAN_VTFT_FILTERTARGET_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_ATKHLDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_DCYSUSM
argument_list|,
name|EMU_CHAN_DCYSUSM_DECAYTIME_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_LFOVAL1
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_LFOVAL2
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_FMMOD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_TREMFRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_FM2FRQ2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_ENVVAL
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_ATKHLDV
argument_list|,
name|EMU_CHAN_ATKHLDV_HOLDTIME_MASK
operator||
name|EMU_CHAN_ATKHLDV_ATTACKTIME_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_ENVVOL
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_PEFE_FILTERAMOUNT
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_PEFE_PITCHAMOUNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|stereo
operator|)
operator|&&
operator|(
name|v
operator|->
name|slave
operator|!=
name|NULL
operator|)
condition|)
name|emu_vwrite
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|slave
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_vstop
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|char
name|channel
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
name|channel
operator|&
literal|0x20
operator|)
condition|?
name|EMU_SOLEH
else|:
name|EMU_SOLEL
expr_stmt|;
name|channel
operator|&=
literal|0x1f
expr_stmt|;
name|reg
operator||=
literal|1
operator|<<
literal|24
expr_stmt|;
name|reg
operator||=
name|channel
operator|<<
literal|16
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emu_vtrigger
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|uint32_t
name|pitch_target
decl_stmt|,
name|initial_pitch
decl_stmt|;
name|uint32_t
name|cra
decl_stmt|,
name|cs
decl_stmt|,
name|ccis
decl_stmt|;
name|uint32_t
name|sample
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|go
condition|)
block|{
name|cra
operator|=
literal|64
expr_stmt|;
name|cs
operator|=
name|v
operator|->
name|stereo
condition|?
literal|4
else|:
literal|2
expr_stmt|;
name|ccis
operator|=
name|v
operator|->
name|stereo
condition|?
literal|28
else|:
literal|30
expr_stmt|;
name|ccis
operator|*=
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|sample
operator|=
name|v
operator|->
name|b16
condition|?
literal|0x00000000
else|:
literal|0x80808080
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cs
condition|;
name|i
operator|++
control|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CD0
operator|+
name|i
argument_list|,
name|sample
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CCR_CACHEINVALIDSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CCR_READADDRESS
argument_list|,
name|cra
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CCR_CACHEINVALIDSIZE
argument_list|,
name|ccis
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_IFATN
argument_list|,
literal|0xff00
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_VTFT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CVCF
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_DCYSUSV
argument_list|,
literal|0x00007f7f
argument_list|)
expr_stmt|;
name|emu_vstop
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pitch_target
operator|=
name|emu_rate_to_linearpitch
argument_list|(
name|v
operator|->
name|speed
argument_list|)
expr_stmt|;
name|initial_pitch
operator|=
name|emu_rate_to_pitch
argument_list|(
name|v
operator|->
name|speed
argument_list|)
operator|>>
literal|8
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_PTRX_PITCHTARGET
argument_list|,
name|pitch_target
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CPF_PITCH
argument_list|,
name|pitch_target
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_IP
argument_list|,
name|initial_pitch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_PTRX_PITCHTARGET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CPF_PITCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_IFATN
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_VTFT
argument_list|,
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CVCF
argument_list|,
literal|0x0000ffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_IP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_vstop
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v
operator|->
name|stereo
operator|)
operator|&&
operator|(
name|v
operator|->
name|slave
operator|!=
name|NULL
operator|)
condition|)
name|emu_vtrigger
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|slave
argument_list|,
name|go
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|emu_vpos
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|emu_voice
modifier|*
name|v
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|ptr
decl_stmt|;
name|s
operator|=
operator|(
name|v
operator|->
name|b16
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|v
operator|->
name|stereo
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
name|v
operator|->
name|vnum
argument_list|,
name|EMU_CHAN_CCCA_CURRADDR
argument_list|)
operator|-
operator|(
name|v
operator|->
name|start
operator|>>
name|s
operator|)
operator|)
operator|<<
name|s
expr_stmt|;
return|return
operator|(
name|ptr
operator|&
operator|~
literal|0x0000001f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fx */
end_comment

begin_function
specifier|static
name|void
name|emu_wrefx
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|pc
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|code_base
operator|+
name|pc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_addefxop
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|op
parameter_list|,
name|unsigned
name|int
name|z
parameter_list|,
name|unsigned
name|int
name|w
parameter_list|,
name|unsigned
name|int
name|x
parameter_list|,
name|unsigned
name|int
name|y
parameter_list|,
name|uint32_t
modifier|*
name|pc
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|pc
operator|)
operator|+
literal|1
operator|>
name|sc
operator|->
name|code_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"DSP CODE OVERRUN: attept to write past code_size (pc=%d)\n"
argument_list|,
operator|(
operator|*
name|pc
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
operator|(
operator|*
name|pc
operator|)
operator|*
literal|2
argument_list|,
operator|(
name|x
operator|<<
name|sc
operator|->
name|high_operand_shift
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|emu_wrefx
argument_list|(
name|sc
argument_list|,
operator|(
operator|*
name|pc
operator|)
operator|*
literal|2
operator|+
literal|1
argument_list|,
operator|(
name|op
operator|<<
name|sc
operator|->
name|opcode_shift
operator|)
operator||
operator|(
name|z
operator|<<
name|sc
operator|->
name|high_operand_shift
operator|)
operator||
name|w
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_emu_mixer_control
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|mixer_id
decl_stmt|;
name|int
name|new_vol
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|mixer_id
operator|=
name|arg2
expr_stmt|;
name|new_vol
operator|=
name|emumix_get_volume
argument_list|(
name|sc
argument_list|,
name|mixer_id
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_vol
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|new_vol
operator|<
literal|0
operator|||
name|new_vol
operator|>
literal|100
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|emumix_set_volume
argument_list|(
name|sc
argument_list|,
name|mixer_id
argument_list|,
name|new_vol
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_addefxmixer
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|mix_name
parameter_list|,
specifier|const
name|int
name|mix_id
parameter_list|,
name|uint32_t
name|defvolume
parameter_list|)
block|{
name|int
name|volgpr
decl_stmt|;
name|char
name|sysctl_name
index|[
literal|32
index|]
decl_stmt|;
name|volgpr
operator|=
name|emu_rm_gpr_alloc
argument_list|(
name|sc
operator|->
name|rm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emumix_set_fxvol
argument_list|(
name|sc
argument_list|,
name|volgpr
argument_list|,
name|defvolume
argument_list|)
expr_stmt|;
comment|/* 	 * Mixer controls with NULL mix_name are handled 	 * by AC97 emulation code or PCM mixer. 	 */
if|if
condition|(
name|mix_name
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Temporary sysctls should start with underscore, 		 * see freebsd-current mailing list, emu10kx driver 		 * discussion around 2006-05-24. 		 */
name|snprintf
argument_list|(
name|sysctl_name
argument_list|,
literal|32
argument_list|,
literal|"_%s"
argument_list|,
name|mix_name
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|root
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|sysctl_name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
name|mix_id
argument_list|,
name|sysctl_emu_mixer_control
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|volgpr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_emu_digitalswitch_control
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|int
name|new_val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|new_val
operator|=
operator|(
name|sc
operator|->
name|mode
operator|==
name|MODE_DIGITAL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|new_val
operator|<
literal|0
operator|||
name|new_val
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|new_val
condition|)
block|{
case|case
literal|0
case|:
name|emumix_set_mode
argument_list|(
name|sc
argument_list|,
name|MODE_ANALOG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|emumix_set_mode
argument_list|(
name|sc
argument_list|,
name|MODE_DIGITAL
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|emu_digitalswitch
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX temporary? */
name|SYSCTL_ADD_PROC
argument_list|(
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|root
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"_digital"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_emu_digitalswitch_control
argument_list|,
literal|"I"
argument_list|,
literal|"Enable digital output"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Allocate cache GPRs that will hold mixed output channels  * and clear it on every DSP run.  */
end_comment

begin_define
define|#
directive|define
name|EFX_CACHE
parameter_list|(
name|CACHE_IDX
parameter_list|)
value|do {				\ 	sc->cache_gpr[CACHE_IDX] = emu_rm_gpr_alloc(sc->rm, 1); \ 	emu_addefxop(sc, ACC3, 					\ 		GPR(sc->cache_gpr[CACHE_IDX]), 			\ 		DSP_CONST(0), 					\ 		DSP_CONST(0), 					\ 		DSP_CONST(0), 					\&pc);						\ } while (0)
end_define

begin_comment
comment|/* Allocate GPR for volume control and route sound: OUT = OUT + IN * VOL */
end_comment

begin_define
define|#
directive|define
name|EFX_ROUTE
parameter_list|(
name|TITLE
parameter_list|,
name|INP_NR
parameter_list|,
name|IN_GPR_IDX
parameter_list|,
name|OUT_CACHE_IDX
parameter_list|,
name|DEF
parameter_list|)
value|do { 	\ 	sc->mixer_gpr[IN_GPR_IDX] = emu_addefxmixer(sc, TITLE, IN_GPR_IDX,  DEF); \ 	sc->mixer_volcache[IN_GPR_IDX] = DEF; 			\ 	emu_addefxop(sc, MACS, 					\ 		GPR(sc->cache_gpr[OUT_CACHE_IDX]), 		\ 		GPR(sc->cache_gpr[OUT_CACHE_IDX]),		\ 		INP_NR,						\ 		GPR(sc->mixer_gpr[IN_GPR_IDX]),			\&pc);						\ } while (0)
end_define

begin_comment
comment|/* allocate GPR, OUT = IN * VOL */
end_comment

begin_define
define|#
directive|define
name|EFX_OUTPUT
parameter_list|(
name|TITLE
parameter_list|,
name|OUT_CACHE_IDX
parameter_list|,
name|OUT_GPR_IDX
parameter_list|,
name|OUTP_NR
parameter_list|,
name|DEF
parameter_list|)
value|do {	\ 	sc->mixer_gpr[OUT_GPR_IDX] = emu_addefxmixer(sc, TITLE, OUT_GPR_IDX, DEF); \ 	sc->mixer_volcache[OUT_GPR_IDX] = DEF;			\ 	emu_addefxop(sc, MACS,					\ 		OUTP(OUTP_NR),					\ 		DSP_CONST(0),					\ 		GPR(sc->cache_gpr[OUT_CACHE_IDX]),		\ 		GPR(sc->mixer_gpr[OUT_GPR_IDX]),		\&pc);						\ } while (0)
end_define

begin_comment
comment|/* like EFX_OUTPUT, but don't allocate mixer gpr */
end_comment

begin_define
define|#
directive|define
name|EFX_OUTPUTD
parameter_list|(
name|OUT_CACHE_IDX
parameter_list|,
name|OUT_GPR_IDX
parameter_list|,
name|OUTP_NR
parameter_list|)
value|do {	\ 	emu_addefxop(sc, MACS,					\ 		OUTP(OUTP_NR),					\ 		DSP_CONST(0),					\ 		GPR(sc->cache_gpr[OUT_CACHE_IDX]),		\ 		GPR(sc->mixer_gpr[OUT_GPR_IDX]),		\&pc);						\ } while (0)
end_define

begin_comment
comment|/* skip next OPCOUNT instructions if FLAG != 0 */
end_comment

begin_define
define|#
directive|define
name|EFX_SKIP
parameter_list|(
name|OPCOUNT
parameter_list|,
name|FLAG_GPR
parameter_list|)
value|do {			\ 	emu_addefxop(sc, MACS,					\ 		DSP_CONST(0),					\ 		GPR(sc->mute_gpr[FLAG_GPR]),					\ 		DSP_CONST(0),					\ 		DSP_CONST(0),					\&pc);						\ 	emu_addefxop(sc, SKIP,					\ 		DSP_CCR,					\ 		DSP_CCR,					\ 		COND_NEQ_ZERO,					\ 		OPCOUNT,					\&pc);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|EFX_COPY
parameter_list|(
name|TO
parameter_list|,
name|FROM
parameter_list|)
value|do {					\ 	emu_addefxop(sc, ACC3,					\ 		TO,						\ 		DSP_CONST(0),					\ 		DSP_CONST(0),					\ 		FROM,						\&pc);						\ } while (0)
end_define

begin_function
specifier|static
name|void
name|emu_initefx
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|uint32_t
name|pc
decl_stmt|;
comment|/* stop DSP */
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_DBG
argument_list|,
name|EMU_DBG_SINGLE_STEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A_DBG
argument_list|,
name|EMU_A_DBG_SINGLE_STEP
argument_list|)
expr_stmt|;
block|}
comment|/* code size is in instructions */
name|pc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|code_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|ACC3
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|SKIP
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0xf
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0x0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* allocate GPRs for mute switches (EFX_SKIP). Mute by default */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MUTE
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|mute_gpr
index|[
name|i
index|]
operator|=
name|emu_rm_gpr_alloc
argument_list|(
name|sc
operator|->
name|rm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emumix_set_gpr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mute_gpr
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|emu_digitalswitch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * DSP code below is not good, because: 	 * 1. It can be written smaller, if it can use DSP accumulator register 	 * instead of cache_gpr[]. 	 * 2. It can be more careful when volume is 100%, because in DSP 	 * x*0x7fffffff may not be equal to x ! 	 */
comment|/* clean outputs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|ACC3
argument_list|,
name|OUTP
argument_list|(
name|i
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|EFX_CACHE
argument_list|(
name|C_FRONT_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_FRONT_R
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_REC_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_REC_R
argument_list|)
expr_stmt|;
comment|/* fx0 to front/record, 100%/muted by default */
name|EFX_ROUTE
argument_list|(
literal|"pcm_front_l"
argument_list|,
name|FX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|M_FX0_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"pcm_front_r"
argument_list|,
name|FX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_FX1_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|M_FX0_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_FX1_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in0, from AC97 codec output */
name|EFX_ROUTE
argument_list|(
literal|"ac97_front_l"
argument_list|,
name|INP
argument_list|(
name|IN_AC97_L
argument_list|)
argument_list|,
name|M_IN0_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"ac97_front_r"
argument_list|,
name|INP
argument_list|(
name|IN_AC97_R
argument_list|)
argument_list|,
name|M_IN0_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"ac97_rec_l"
argument_list|,
name|INP
argument_list|(
name|IN_AC97_L
argument_list|)
argument_list|,
name|M_IN0_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"ac97_rec_r"
argument_list|,
name|INP
argument_list|(
name|IN_AC97_R
argument_list|)
argument_list|,
name|M_IN0_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in1, from CD S/PDIF */
comment|/* XXX EFX_SKIP 4 assumes that each EFX_ROUTE is one DSP op */
name|EFX_SKIP
argument_list|(
literal|4
argument_list|,
name|CDSPDIFMUTE
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_SPDIF_CD_L
argument_list|)
argument_list|,
name|M_IN1_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_SPDIF_CD_R
argument_list|)
argument_list|,
name|M_IN1_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_SPDIF_CD_L
argument_list|)
argument_list|,
name|M_IN1_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_SPDIF_CD_R
argument_list|)
argument_list|,
name|M_IN1_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|0
condition|)
block|{
comment|/* in2, ZoomVide (???) */
name|EFX_ROUTE
argument_list|(
literal|"zoom_front_l"
argument_list|,
name|INP
argument_list|(
name|IN_ZOOM_L
argument_list|)
argument_list|,
name|M_IN2_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"zoom_front_r"
argument_list|,
name|INP
argument_list|(
name|IN_ZOOM_R
argument_list|)
argument_list|,
name|M_IN2_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"zoom_rec_l"
argument_list|,
name|INP
argument_list|(
name|IN_ZOOM_L
argument_list|)
argument_list|,
name|M_IN2_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"zoom_rec_r"
argument_list|,
name|INP
argument_list|(
name|IN_ZOOM_R
argument_list|)
argument_list|,
name|M_IN2_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* in3, TOSLink  */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_TOSLINK_L
argument_list|)
argument_list|,
name|M_IN3_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_TOSLINK_R
argument_list|)
argument_list|,
name|M_IN3_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_TOSLINK_L
argument_list|)
argument_list|,
name|M_IN3_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_TOSLINK_R
argument_list|)
argument_list|,
name|M_IN3_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in4, LineIn  */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE1_L
argument_list|)
argument_list|,
name|M_IN4_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE1_R
argument_list|)
argument_list|,
name|M_IN4_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE1_L
argument_list|)
argument_list|,
name|M_IN4_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE1_R
argument_list|)
argument_list|,
name|M_IN4_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in5, on-card S/PDIF */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_COAX_SPDIF_L
argument_list|)
argument_list|,
name|M_IN5_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_COAX_SPDIF_R
argument_list|)
argument_list|,
name|M_IN5_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_COAX_SPDIF_L
argument_list|)
argument_list|,
name|M_IN5_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_COAX_SPDIF_R
argument_list|)
argument_list|,
name|M_IN5_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in6, Line2 on Live!Drive */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE2_L
argument_list|)
argument_list|,
name|M_IN6_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE2_R
argument_list|)
argument_list|,
name|M_IN6_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE2_L
argument_list|)
argument_list|,
name|M_IN6_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|IN_LINE2_R
argument_list|)
argument_list|,
name|M_IN6_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|0
condition|)
block|{
comment|/* in7, unknown */
name|EFX_ROUTE
argument_list|(
literal|"in7_front_l"
argument_list|,
name|INP
argument_list|(
literal|0xE
argument_list|)
argument_list|,
name|M_IN7_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in7_front_r"
argument_list|,
name|INP
argument_list|(
literal|0xF
argument_list|)
argument_list|,
name|M_IN7_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in7_rec_l"
argument_list|,
name|INP
argument_list|(
literal|0xE
argument_list|)
argument_list|,
name|M_IN7_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in7_rec_r"
argument_list|,
name|INP
argument_list|(
literal|0xF
argument_list|)
argument_list|,
name|M_IN7_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* analog and digital */
name|EFX_OUTPUT
argument_list|(
literal|"master_front_l"
argument_list|,
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|OUT_AC97_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
literal|"master_front_r"
argument_list|,
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|OUT_AC97_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* S/PDIF */
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|OUT_TOSLINK_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|OUT_TOSLINK_R
argument_list|)
expr_stmt|;
comment|/* Headphones */
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|OUT_HEADPHONE_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|OUT_HEADPHONE_R
argument_list|)
expr_stmt|;
comment|/* rec output to "ADC" */
name|EFX_OUTPUT
argument_list|(
literal|"master_rec_l"
argument_list|,
name|C_REC_L
argument_list|,
name|M_MASTER_REC_L
argument_list|,
name|OUT_ADC_REC_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
literal|"master_rec_r"
argument_list|,
name|C_REC_R
argument_list|,
name|M_MASTER_REC_R
argument_list|,
name|OUT_ADC_REC_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|mch_disabled
operator|)
condition|)
block|{
comment|/* 			 * Additional channel volume is controlled by mixer in 			 * emu_dspmixer_set() in -pcm.c 			 */
comment|/* fx2/3 (pcm1) to rear */
name|EFX_CACHE
argument_list|(
name|C_REAR_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_REAR_R
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|2
argument_list|)
argument_list|,
name|M_FX2_REAR_L
argument_list|,
name|C_REAR_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|3
argument_list|)
argument_list|,
name|M_FX3_REAR_R
argument_list|,
name|C_REAR_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_REAR_L
argument_list|,
name|M_MASTER_REAR_L
argument_list|,
name|OUT_REAR_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_REAR_R
argument_list|,
name|M_MASTER_REAR_R
argument_list|,
name|OUT_REAR_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|has_51
condition|)
block|{
comment|/* fx4 (pcm2) to center */
name|EFX_CACHE
argument_list|(
name|C_CENTER
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|4
argument_list|)
argument_list|,
name|M_FX4_CENTER
argument_list|,
name|C_CENTER
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_CENTER
argument_list|,
name|M_MASTER_CENTER
argument_list|,
name|OUT_D_CENTER
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX in digital mode (default) this should be muted because 				this output is shared with digital out */
name|EFX_SKIP
argument_list|(
literal|1
argument_list|,
name|ANALOGMUTE
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_CENTER
argument_list|,
name|M_MASTER_CENTER
argument_list|,
name|OUT_A_CENTER
argument_list|)
expr_stmt|;
comment|/* fx5 (pcm3) to sub */
name|EFX_CACHE
argument_list|(
name|C_SUB
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|5
argument_list|)
argument_list|,
name|M_FX5_SUBWOOFER
argument_list|,
name|C_SUB
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_SUB
argument_list|,
name|M_MASTER_SUBWOOFER
argument_list|,
name|OUT_D_SUB
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX in digital mode (default) this should be muted because 				this output is shared with digital out */
name|EFX_SKIP
argument_list|(
literal|1
argument_list|,
name|ANALOGMUTE
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_SUB
argument_list|,
name|M_MASTER_SUBWOOFER
argument_list|,
name|OUT_A_SUB
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* SND_EMU10KX_MULTICHANNEL_DISABLED */
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_FRONT_L
argument_list|,
name|M_MASTER_REAR_L
argument_list|,
name|OUT_REAR_L
argument_list|,
literal|57
argument_list|)
expr_stmt|;
comment|/* 75%*75% */
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_FRONT_R
argument_list|,
name|M_MASTER_REAR_R
argument_list|,
name|OUT_REAR_R
argument_list|,
literal|57
argument_list|)
expr_stmt|;
comment|/* 75%*75% */
if|#
directive|if
literal|0
comment|/* XXX 5.1 does not work */
block|if (sc->has_51) {
comment|/* (fx0+fx1)/2 to center */
block|EFX_CACHE(C_CENTER); 				emu_addefxop(sc, MACS, 					GPR(sc->cache_gpr[C_CENTER]), 					GPR(sc->cache_gpr[C_CENTER]), 					DSP_CONST(0xd),
comment|/* = 1/2 */
block|GPR(sc->cache_gpr[C_FRONT_L]),&pc); 				emu_addefxop(sc, MACS, 					GPR(sc->cache_gpr[C_CENTER]), 					GPR(sc->cache_gpr[C_CENTER]), 					DSP_CONST(0xd),
comment|/* = 1/2 */
block|GPR(sc->cache_gpr[C_FRONT_R]),&pc); 				EFX_OUTPUT(NULL, C_CENTER, M_MASTER_CENTER, OUT_D_CENTER, 100);
comment|/* XXX in digital mode (default) this should be muted because 				this output is shared with digital out */
block|EFX_SKIP(1, ANALOGMUTE); 				EFX_OUTPUTD(C_CENTER, M_MASTER_CENTER, OUT_A_CENTER);
comment|/* (fx0+fx1)/2  to sub */
block|EFX_CACHE(C_SUB); 				emu_addefxop(sc, MACS, 					GPR(sc->cache_gpr[C_CENTER]), 					GPR(sc->cache_gpr[C_CENTER]), 					DSP_CONST(0xd),
comment|/* = 1/2 */
block|GPR(sc->cache_gpr[C_FRONT_L]),&pc); 				emu_addefxop(sc, MACS, 					GPR(sc->cache_gpr[C_CENTER]), 					GPR(sc->cache_gpr[C_CENTER]), 					DSP_CONST(0xd),
comment|/* = 1/2 */
block|GPR(sc->cache_gpr[C_FRONT_R]),&pc);
comment|/* XXX add lowpass filter here */
block|EFX_OUTPUT(NULL, C_SUB, M_MASTER_SUBWOOFER, OUT_D_SUB, 100);
comment|/* XXX in digital mode (default) this should be muted because 				this output is shared with digital out */
block|EFX_SKIP(1, ANALOGMUTE); 				EFX_OUTPUTD(C_SUB, M_MASTER_SUBWOOFER, OUT_A_SUB); 			}
endif|#
directive|endif
block|}
comment|/* !mch_disabled */
if|if
condition|(
name|sc
operator|->
name|mch_rec
condition|)
block|{
comment|/* 			 * MCH RECORDING , hight 16 slots. On 5.1 cards first 4 slots 			 * are used as outputs and already filled with data 			 */
comment|/* 			 * XXX On Live! cards stream does not begin at zero offset. 			 * It can be HW, driver or sound buffering problem. 			 * Use sync substream (offset 0x3E) to let userland find 			 * correct data. 			 */
comment|/* 			 * Substream map (in byte offsets, each substream is 2 bytes): 			 *	0x00..0x1E - outputs 			 *	0x20..0x3E - FX, inputs and sync stream 			 */
comment|/* First 2 channels (offset 0x20,0x22) are empty */
for|for
control|(
name|i
operator|=
operator|(
name|sc
operator|->
name|has_51
condition|?
literal|2
else|:
literal|0
operator|)
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|EFX_COPY
argument_list|(
name|FX2
argument_list|(
name|i
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PCM Playback monitoring, offset 0x24..0x2A */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|EFX_COPY
argument_list|(
name|FX2
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|,
name|FX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy of some inputs, offset 0x2C..0x3C */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|EFX_COPY
argument_list|(
name|FX2
argument_list|(
name|i
operator|+
literal|8
argument_list|)
argument_list|,
name|INP
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sync data (0xc0de, offset 0x3E) */
name|sc
operator|->
name|dummy_gpr
operator|=
name|emu_rm_gpr_alloc
argument_list|(
name|sc
operator|->
name|rm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emumix_set_gpr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dummy_gpr
argument_list|,
literal|0xc0de0000
argument_list|)
expr_stmt|;
name|EFX_COPY
argument_list|(
name|FX2
argument_list|(
literal|15
argument_list|)
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|dummy_gpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* mch_rec */
block|}
else|else
comment|/* emu10k2 and later */
block|{
name|EFX_CACHE
argument_list|(
name|C_FRONT_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_FRONT_R
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_REC_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_REC_R
argument_list|)
expr_stmt|;
comment|/* fx0 to front/record, 100%/muted by default */
comment|/* 		 * FRONT_[L|R] is controlled by AC97 emulation in 		 * emu_ac97_[read|write]_emulation in -pcm.c 		 */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|M_FX0_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_FX1_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|M_FX0_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_FX1_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in0, from AC97 codec output */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AC97_L
argument_list|)
argument_list|,
name|M_IN0_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AC97_R
argument_list|)
argument_list|,
name|M_IN0_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AC97_L
argument_list|)
argument_list|,
name|M_IN0_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AC97_R
argument_list|)
argument_list|,
name|M_IN0_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in1, from CD S/PDIF */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_SPDIF_CD_L
argument_list|)
argument_list|,
name|M_IN1_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_SPDIF_CD_R
argument_list|)
argument_list|,
name|M_IN1_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_SPDIF_CD_L
argument_list|)
argument_list|,
name|M_IN1_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_SPDIF_CD_R
argument_list|)
argument_list|,
name|M_IN1_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in2, optical& coax S/PDIF on AudigyDrive*/
comment|/* XXX Should be muted when GPRSCS valid stream == 0 */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_O_SPDIF_L
argument_list|)
argument_list|,
name|M_IN2_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_O_SPDIF_R
argument_list|)
argument_list|,
name|M_IN2_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_O_SPDIF_L
argument_list|)
argument_list|,
name|M_IN2_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_O_SPDIF_R
argument_list|)
argument_list|,
name|M_IN2_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|0
condition|)
block|{
comment|/* in3, unknown */
name|EFX_ROUTE
argument_list|(
literal|"in3_front_l"
argument_list|,
name|INP
argument_list|(
literal|0x6
argument_list|)
argument_list|,
name|M_IN3_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in3_front_r"
argument_list|,
name|INP
argument_list|(
literal|0x7
argument_list|)
argument_list|,
name|M_IN3_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in3_rec_l"
argument_list|,
name|INP
argument_list|(
literal|0x6
argument_list|)
argument_list|,
name|M_IN3_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in3_rec_r"
argument_list|,
name|INP
argument_list|(
literal|0x7
argument_list|)
argument_list|,
name|M_IN3_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* in4, LineIn 2 on AudigyDrive */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_LINE2_L
argument_list|)
argument_list|,
name|M_IN4_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_LINE2_R
argument_list|)
argument_list|,
name|M_IN4_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_LINE2_L
argument_list|)
argument_list|,
name|M_IN4_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_LINE2_R
argument_list|)
argument_list|,
name|M_IN4_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in5, on-card S/PDIF */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_R_SPDIF_L
argument_list|)
argument_list|,
name|M_IN5_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_R_SPDIF_R
argument_list|)
argument_list|,
name|M_IN5_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_R_SPDIF_L
argument_list|)
argument_list|,
name|M_IN5_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_R_SPDIF_R
argument_list|)
argument_list|,
name|M_IN5_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in6, AUX2 on AudigyDrive */
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AUX2_L
argument_list|)
argument_list|,
name|M_IN6_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AUX2_R
argument_list|)
argument_list|,
name|M_IN6_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AUX2_L
argument_list|)
argument_list|,
name|M_IN6_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|INP
argument_list|(
name|A_IN_AUX2_R
argument_list|)
argument_list|,
name|M_IN6_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|0
condition|)
block|{
comment|/* in7, unknown */
name|EFX_ROUTE
argument_list|(
literal|"in7_front_l"
argument_list|,
name|INP
argument_list|(
literal|0xE
argument_list|)
argument_list|,
name|M_IN7_FRONT_L
argument_list|,
name|C_FRONT_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in7_front_r"
argument_list|,
name|INP
argument_list|(
literal|0xF
argument_list|)
argument_list|,
name|M_IN7_FRONT_R
argument_list|,
name|C_FRONT_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in7_rec_l"
argument_list|,
name|INP
argument_list|(
literal|0xE
argument_list|)
argument_list|,
name|M_IN7_REC_L
argument_list|,
name|C_REC_L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
literal|"in7_rec_r"
argument_list|,
name|INP
argument_list|(
literal|0xF
argument_list|)
argument_list|,
name|M_IN7_REC_R
argument_list|,
name|C_REC_R
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* front output to headphones and  alog and digital *front */
comment|/* volume controlled by AC97 emulation */
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|A_OUT_A_FRONT_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|A_OUT_A_FRONT_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|A_OUT_D_FRONT_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|A_OUT_D_FRONT_R
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|A_OUT_HPHONE_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|A_OUT_HPHONE_R
argument_list|)
expr_stmt|;
comment|/* rec output to "ADC" */
comment|/* volume controlled by AC97 emulation */
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_REC_L
argument_list|,
name|M_MASTER_REC_L
argument_list|,
name|A_OUT_ADC_REC_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_REC_R
argument_list|,
name|M_MASTER_REC_R
argument_list|,
name|A_OUT_ADC_REC_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|mch_disabled
operator|)
condition|)
block|{
comment|/* 			 * Additional channel volume is controlled by mixer in 			 * emu_dspmixer_set() in -pcm.c 			 */
comment|/* fx2/3 (pcm1) to rear */
name|EFX_CACHE
argument_list|(
name|C_REAR_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_REAR_R
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|2
argument_list|)
argument_list|,
name|M_FX2_REAR_L
argument_list|,
name|C_REAR_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|3
argument_list|)
argument_list|,
name|M_FX3_REAR_R
argument_list|,
name|C_REAR_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_REAR_L
argument_list|,
name|M_MASTER_REAR_L
argument_list|,
name|A_OUT_A_REAR_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_REAR_R
argument_list|,
name|M_MASTER_REAR_R
argument_list|,
name|A_OUT_A_REAR_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_REAR_L
argument_list|,
name|M_MASTER_REAR_L
argument_list|,
name|A_OUT_D_REAR_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_REAR_R
argument_list|,
name|M_MASTER_REAR_R
argument_list|,
name|A_OUT_D_REAR_R
argument_list|)
expr_stmt|;
comment|/* fx4 (pcm2) to center */
name|EFX_CACHE
argument_list|(
name|C_CENTER
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|4
argument_list|)
argument_list|,
name|M_FX4_CENTER
argument_list|,
name|C_CENTER
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_CENTER
argument_list|,
name|M_MASTER_CENTER
argument_list|,
name|A_OUT_D_CENTER
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * XXX in digital mode (default) this should be muted 			 * because this output is shared with digital out 			 */
block|EFX_OUTPUTD(C_CENTER, M_MASTER_CENTER, A_OUT_A_CENTER);
endif|#
directive|endif
comment|/* fx5 (pcm3) to sub */
name|EFX_CACHE
argument_list|(
name|C_SUB
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|5
argument_list|)
argument_list|,
name|M_FX5_SUBWOOFER
argument_list|,
name|C_SUB
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_SUB
argument_list|,
name|M_MASTER_SUBWOOFER
argument_list|,
name|A_OUT_D_SUB
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * XXX in digital mode (default) this should be muted 			 * because this output is shared with digital out 			 */
block|EFX_OUTPUTD(C_SUB, M_MASTER_SUBWOOFER, A_OUT_A_SUB);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|has_71
condition|)
block|{
comment|/* XXX this will broke headphones on AudigyDrive */
comment|/* fx6/7 (pcm4) to side */
name|EFX_CACHE
argument_list|(
name|C_SIDE_L
argument_list|)
expr_stmt|;
name|EFX_CACHE
argument_list|(
name|C_SIDE_R
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|6
argument_list|)
argument_list|,
name|M_FX6_SIDE_L
argument_list|,
name|C_SIDE_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_ROUTE
argument_list|(
name|NULL
argument_list|,
name|FX
argument_list|(
literal|7
argument_list|)
argument_list|,
name|M_FX7_SIDE_R
argument_list|,
name|C_SIDE_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_SIDE_L
argument_list|,
name|M_MASTER_SIDE_L
argument_list|,
name|A_OUT_A_SIDE_L
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_SIDE_R
argument_list|,
name|M_MASTER_SIDE_R
argument_list|,
name|A_OUT_A_SIDE_R
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_SIDE_L
argument_list|,
name|M_MASTER_SIDE_L
argument_list|,
name|A_OUT_D_SIDE_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_SIDE_R
argument_list|,
name|M_MASTER_SIDE_R
argument_list|,
name|A_OUT_D_SIDE_R
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mch_disabled */
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|A_OUT_A_REAR_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|A_OUT_A_REAR_R
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_L
argument_list|,
name|M_MASTER_FRONT_L
argument_list|,
name|A_OUT_D_REAR_L
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_FRONT_R
argument_list|,
name|M_MASTER_FRONT_R
argument_list|,
name|A_OUT_D_REAR_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|has_51
condition|)
block|{
comment|/* (fx0+fx1)/2 to center */
name|EFX_CACHE
argument_list|(
name|C_CENTER
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|MACS
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_CENTER
index|]
argument_list|)
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_CENTER
index|]
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0xd
argument_list|)
argument_list|,
comment|/* = 1/2 */
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_FRONT_L
index|]
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|MACS
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_CENTER
index|]
argument_list|)
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_CENTER
index|]
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0xd
argument_list|)
argument_list|,
comment|/* = 1/2 */
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_FRONT_R
index|]
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_CENTER
argument_list|,
name|M_MASTER_CENTER
argument_list|,
name|A_OUT_D_CENTER
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX in digital mode (default) this should be muted because 				this output is shared with digital out */
name|EFX_SKIP
argument_list|(
literal|1
argument_list|,
name|ANALOGMUTE
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_CENTER
argument_list|,
name|M_MASTER_CENTER
argument_list|,
name|A_OUT_A_CENTER
argument_list|)
expr_stmt|;
comment|/* (fx0+fx1)/2  to sub */
name|EFX_CACHE
argument_list|(
name|C_SUB
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|MACS
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_SUB
index|]
argument_list|)
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_SUB
index|]
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0xd
argument_list|)
argument_list|,
comment|/* = 1/2 */
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_FRONT_L
index|]
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|emu_addefxop
argument_list|(
name|sc
argument_list|,
name|MACS
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_SUB
index|]
argument_list|)
argument_list|,
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_SUB
index|]
argument_list|)
argument_list|,
name|DSP_CONST
argument_list|(
literal|0xd
argument_list|)
argument_list|,
comment|/* = 1/2 */
name|GPR
argument_list|(
name|sc
operator|->
name|cache_gpr
index|[
name|C_FRONT_R
index|]
argument_list|)
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
comment|/* XXX add lowpass filter here */
name|EFX_OUTPUT
argument_list|(
name|NULL
argument_list|,
name|C_SUB
argument_list|,
name|M_MASTER_SUBWOOFER
argument_list|,
name|A_OUT_D_SUB
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX in digital mode (default) this should be muted because 				this output is shared with digital out */
name|EFX_SKIP
argument_list|(
literal|1
argument_list|,
name|ANALOGMUTE
argument_list|)
expr_stmt|;
name|EFX_OUTPUTD
argument_list|(
name|C_SUB
argument_list|,
name|M_MASTER_SUBWOOFER
argument_list|,
name|A_OUT_A_SUB
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mch_disabled */
if|if
condition|(
name|sc
operator|->
name|mch_rec
condition|)
block|{
comment|/* MCH RECORDING, high 32 slots */
comment|/* 			 * Stream map (in byte offsets): 			 *	0x00..0x3E - outputs 			 *	0x40..0x7E - FX, inputs 			 *	each substream is 2 bytes. 			 */
comment|/* 			 * XXX Audigy 2 Value cards (and, possibly, 			 * Audigy 4) write some unknown data in place of 			 * some outputs (offsets 0x20..0x3F) and one 			 * input (offset 0x7E). 			 */
comment|/* PCM Playback monitoring, offsets 0x40..0x5E */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|EFX_COPY
argument_list|(
name|FX2
argument_list|(
name|i
argument_list|)
argument_list|,
name|FX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy of all inputs, offsets 0x60..0x7E */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|EFX_COPY
argument_list|(
name|FX2
argument_list|(
name|i
operator|+
literal|16
argument_list|)
argument_list|,
name|INP
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Audigy seems to work correct and does not need this */
comment|/* sync data (0xc0de), offset 0x7E */
block|sc->dummy_gpr = emu_rm_gpr_alloc(sc->rm, 1); 			emumix_set_gpr(sc, sc->dummy_gpr, 0xc0de0000); 			EFX_COPY(FX2(31), GPR(sc->dummy_gpr));
endif|#
directive|endif
block|}
comment|/* mch_rec */
block|}
name|sc
operator|->
name|routing_code_end
operator|=
name|pc
expr_stmt|;
comment|/* start DSP */
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* /dev/em10kx */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|emu10kx_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|emu10kx_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|emu10kx_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|emu10kx_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|emu10kx_open
block|,
operator|.
name|d_close
operator|=
name|emu10kx_close
block|,
operator|.
name|d_read
operator|=
name|emu10kx_read
block|,
operator|.
name|d_name
operator|=
literal|"emu10kx"
block|,
operator|.
name|d_version
operator|=
name|D_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|emu10kx_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|,
name|int
name|mode
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|emu10kx_isopen
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sc
operator|->
name|emu10kx_isopen
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_sbuf
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|emu10kx_bufptr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|(
name|emu10kx_prepare
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|emu10kx_sbuf
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
name|ENOMEM
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|emu10kx_isopen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu10kx_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|,
name|int
name|mode
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|emu10kx_isopen
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|sbuf_delete
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_sbuf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|emu10kx_isopen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu10kx_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
name|__unused
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|i_dev
operator|->
name|si_drv1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|emu10kx_isopen
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|buf
operator|->
name|uio_resid
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_sbuf
argument_list|)
operator|-
name|sc
operator|->
name|emu10kx_bufptr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
name|l
operator|>
literal|0
operator|)
condition|?
name|uiomove
argument_list|(
name|sbuf_data
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_sbuf
argument_list|)
operator|+
name|sc
operator|->
name|emu10kx_bufptr
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|emu10kx_bufptr
operator|+=
name|l
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu10kx_prepare
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|struct
name|sbuf
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"FreeBSD EMU10Kx Audio Driver\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\nHardware resource usage:\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"DSP General Purpose Registers: %d used, %d total\n"
argument_list|,
name|sc
operator|->
name|rm
operator|->
name|num_used
argument_list|,
name|sc
operator|->
name|rm
operator|->
name|num_gprs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"DSP Instruction Registers: %d used, %d total\n"
argument_list|,
name|sc
operator|->
name|routing_code_end
argument_list|,
name|sc
operator|->
name|code_size
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Card supports"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|has_ac97
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" AC97 codec"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" NO AC97 codec"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|has_51
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|has_71
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" and 7.1 output"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|" and 5.1 output"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", SBLive! DSP code"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k2
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", Audigy DSP code"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_ca0102
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", Audigy DSP code with Audigy2 hacks"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_ca0108
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|", Audigy DSP code with Audigy2Value hacks"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|broken_digital
condition|)
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Digital mode unsupported\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\nInstalled devices:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RT_COUNT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s on %s\n"
argument_list|,
name|device_get_desc
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"EMU10Kx MIDI Interface\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\tOn-card connector on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|midi
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\tOn-Drive connector on %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|device_is_attached
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\tIR receiver MIDI events %s\n"
argument_list|,
name|sc
operator|->
name|enable_ir
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Card is in %s mode\n"
argument_list|,
operator|(
name|sc
operator|->
name|mode
operator|==
name|MODE_ANALOG
operator|)
condition|?
literal|"analog"
else|:
literal|"digital"
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_len
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* INIT& UNINIT */
end_comment

begin_function
specifier|static
name|int
name|emu10kx_dev_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"kxdevlock"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|emu10kx_cdevsw
argument_list|,
name|PCMMINOR
argument_list|(
name|unit
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0640
argument_list|,
literal|"emu10kx%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cdev
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu10kx_dev_uninit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|emu10kx_isopen
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|cdev
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|cdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cdev
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|emu10kx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* resource manager */
end_comment

begin_function
name|int
name|emu_rm_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|maxcount
decl_stmt|;
name|struct
name|emu_rm
modifier|*
name|rm
decl_stmt|;
name|rm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_rm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|rm
operator|=
name|rm
expr_stmt|;
name|rm
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|maxcount
operator|=
name|sc
operator|->
name|num_gprs
expr_stmt|;
name|rm
operator|->
name|num_used
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
operator|(
name|rm
operator|->
name|gpr_lock
operator|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"gpr alloc"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rm
operator|->
name|num_gprs
operator|=
operator|(
name|maxcount
operator|<
name|EMU_MAX_GPR
condition|?
name|maxcount
else|:
name|EMU_MAX_GPR
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rm
operator|->
name|num_gprs
condition|;
name|i
operator|++
control|)
name|rm
operator|->
name|allocmap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* pre-allocate gpr[0] */
name|rm
operator|->
name|allocmap
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|rm
operator|->
name|last_free_gpr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emu_rm_uninit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|rm
operator|->
name|gpr_lock
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|rm
operator|->
name|last_free_gpr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|rm
operator|->
name|allocmap
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"rm: gpr %d not free before uninit\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|rm
operator|->
name|gpr_lock
operator|)
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|rm
operator|->
name|gpr_lock
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|rm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_rm_gpr_alloc
parameter_list|(
name|struct
name|emu_rm
modifier|*
name|rm
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|allocated_gpr
decl_stmt|;
name|allocated_gpr
operator|=
name|rm
operator|->
name|num_gprs
expr_stmt|;
comment|/* try fast way first */
name|mtx_lock
argument_list|(
operator|&
operator|(
name|rm
operator|->
name|gpr_lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|last_free_gpr
operator|+
name|count
operator|<=
name|rm
operator|->
name|num_gprs
condition|)
block|{
name|allocated_gpr
operator|=
name|rm
operator|->
name|last_free_gpr
expr_stmt|;
name|rm
operator|->
name|last_free_gpr
operator|+=
name|count
expr_stmt|;
name|rm
operator|->
name|allocmap
index|[
name|allocated_gpr
index|]
operator|=
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|rm
operator|->
name|allocmap
index|[
name|allocated_gpr
operator|+
name|i
index|]
operator|=
operator|-
operator|(
name|count
operator|-
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* longer */
name|i
operator|=
literal|0
expr_stmt|;
name|allocated_gpr
operator|=
name|rm
operator|->
name|num_gprs
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|rm
operator|->
name|last_free_gpr
operator|-
name|count
condition|)
block|{
if|if
condition|(
name|rm
operator|->
name|allocmap
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|i
operator|+=
name|rm
operator|->
name|allocmap
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|allocated_gpr
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rm
operator|->
name|allocmap
index|[
name|i
operator|+
name|j
index|]
operator|!=
literal|0
condition|)
name|allocated_gpr
operator|=
name|rm
operator|->
name|num_gprs
expr_stmt|;
block|}
if|if
condition|(
name|allocated_gpr
operator|==
name|i
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|allocated_gpr
operator|+
name|count
operator|<
name|rm
operator|->
name|last_free_gpr
condition|)
block|{
name|rm
operator|->
name|allocmap
index|[
name|allocated_gpr
index|]
operator|=
name|count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|rm
operator|->
name|allocmap
index|[
name|allocated_gpr
operator|+
name|i
index|]
operator|=
operator|-
operator|(
name|count
operator|-
name|i
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allocated_gpr
operator|==
name|rm
operator|->
name|num_gprs
condition|)
name|allocated_gpr
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|allocated_gpr
operator|>=
literal|0
condition|)
name|rm
operator|->
name|num_used
operator|+=
name|count
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
operator|(
name|rm
operator|->
name|gpr_lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|allocated_gpr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mixer */
end_comment

begin_function
name|void
name|emumix_set_mode
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint32_t
name|a_iocfg
decl_stmt|;
name|uint32_t
name|hcfg
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_DIGITAL
case|:
comment|/* FALLTHROUGH */
case|case
name|MODE_ANALOG
case|:
break|break;
default|default:
return|return;
block|}
name|hcfg
operator|=
name|EMU_HCFG_AUDIOENABLE
operator||
name|EMU_HCFG_AUTOMUTE
expr_stmt|;
name|a_iocfg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rev
operator|>=
literal|6
condition|)
name|hcfg
operator||=
name|EMU_HCFG_JOYENABLE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
name|hcfg
operator||=
name|EMU_HCFG_LOCKTANKCACHE_MASK
expr_stmt|;
else|else
name|hcfg
operator||=
name|EMU_HCFG_CODECFMT_I2S
operator||
name|EMU_HCFG_JOYENABLE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_DIGITAL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|broken_digital
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Digital mode is reported as broken on this card.\n"
argument_list|)
expr_stmt|;
block|}
name|a_iocfg
operator||=
name|EMU_A_IOCFG_GPOUT1
expr_stmt|;
name|hcfg
operator||=
name|EMU_HCFG_GPOUT0
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|MODE_ANALOG
condition|)
name|emumix_set_spdif_mode
argument_list|(
name|sc
argument_list|,
name|SPDIF_MODE_PCM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k2
condition|)
name|a_iocfg
operator||=
literal|0x80
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
comment|/* 		 * Setting EMU_A_IOCFG_DISABLE_ANALOG will do opposite things 		 * on diffrerent cards. 		 * "don't disable analog outs" on Audigy 2 (ca0102/ca0108) 		 * "disable analog outs" on Audigy (emu10k2) 		 */
name|a_iocfg
operator||=
name|EMU_A_IOCFG_DISABLE_ANALOG
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_ca0108
condition|)
name|a_iocfg
operator||=
literal|0x20
expr_stmt|;
comment|/* XXX */
comment|/* Mute analog center& subwoofer before mode change */
if|if
condition|(
name|mode
operator|==
name|MODE_DIGITAL
condition|)
name|emumix_set_gpr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mute_gpr
index|[
name|ANALOGMUTE
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
name|hcfg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
block|{
name|tmp
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|a_iocfg
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
name|tmp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Unmute if we have changed mode to analog. */
if|if
condition|(
name|mode
operator|==
name|MODE_ANALOG
condition|)
name|emumix_set_gpr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mute_gpr
index|[
name|ANALOGMUTE
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emumix_set_spdif_mode
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint32_t
name|spcs
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SPDIF_MODE_PCM
case|:
break|break;
case|case
name|SPDIF_MODE_AC3
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"AC3 mode does not work and disabled\n"
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
name|spcs
operator|=
name|EMU_SPCS_CLKACCY_1000PPM
operator||
name|EMU_SPCS_SAMPLERATE_48
operator||
name|EMU_SPCS_CHANNELNUM_LEFT
operator||
name|EMU_SPCS_SOURCENUM_UNSPEC
operator||
name|EMU_SPCS_GENERATIONSTATUS
operator||
literal|0x00001200
operator||
literal|0x00000000
operator||
name|EMU_SPCS_EMPHASIS_NONE
operator||
name|EMU_SPCS_COPYRIGHT
expr_stmt|;
name|mode
operator|=
name|SPDIF_MODE_PCM
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SPCS0
argument_list|,
name|spcs
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SPCS1
argument_list|,
name|spcs
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SPCS2
argument_list|,
name|spcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|L2L_POINTS
value|10
end_define

begin_decl_stmt
specifier|static
name|int
name|l2l_df
index|[
name|L2L_POINTS
index|]
init|=
block|{
literal|0x572C5CA
block|,
comment|/* 100..90 */
literal|0x3211625
block|,
comment|/* 90..80 */
literal|0x1CC1A76
block|,
comment|/* 80..70 */
literal|0x108428F
block|,
comment|/* 70..60 */
literal|0x097C70A
block|,
comment|/* 60..50 */
literal|0x0572C5C
block|,
comment|/* 50..40 */
literal|0x0321162
block|,
comment|/* 40..30 */
literal|0x01CC1A7
block|,
comment|/* 30..20 */
literal|0x0108428
block|,
comment|/* 20..10 */
literal|0x016493D
comment|/* 10..0 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|l2l_f
index|[
name|L2L_POINTS
index|]
init|=
block|{
literal|0x4984461A
block|,
comment|/* 90 */
literal|0x2A3968A7
block|,
comment|/* 80 */
literal|0x18406003
block|,
comment|/* 70 */
literal|0x0DEDC66D
block|,
comment|/* 60 */
literal|0x07FFFFFF
block|,
comment|/* 50 */
literal|0x04984461
block|,
comment|/* 40 */
literal|0x02A3968A
block|,
comment|/* 30 */
literal|0x01840600
block|,
comment|/* 20 */
literal|0x00DEDC66
block|,
comment|/* 10 */
literal|0x00000000
comment|/* 0 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|log2lin
parameter_list|(
name|int
name|log_t
parameter_list|)
block|{
name|int
name|lin_t
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|lin
decl_stmt|;
if|if
condition|(
name|log_t
operator|<=
literal|0
condition|)
block|{
name|lin_t
operator|=
literal|0x00000000
expr_stmt|;
return|return
operator|(
name|lin_t
operator|)
return|;
block|}
if|if
condition|(
name|log_t
operator|>=
literal|100
condition|)
block|{
name|lin_t
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
operator|(
name|lin_t
operator|)
return|;
block|}
name|idx
operator|=
operator|(
name|L2L_POINTS
operator|-
literal|1
operator|)
operator|-
name|log_t
operator|/
operator|(
name|L2L_POINTS
operator|)
expr_stmt|;
name|lin
operator|=
name|log_t
operator|%
operator|(
name|L2L_POINTS
operator|)
expr_stmt|;
name|lin_t
operator|=
name|l2l_df
index|[
name|idx
index|]
operator|*
name|lin
operator|+
name|l2l_f
index|[
name|idx
index|]
expr_stmt|;
return|return
operator|(
name|lin_t
operator|)
return|;
block|}
end_function

begin_function
name|void
name|emumix_set_fxvol
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|gpr
parameter_list|,
name|int32_t
name|vol
parameter_list|)
block|{
name|vol
operator|=
name|log2lin
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|emumix_set_gpr
argument_list|(
name|sc
argument_list|,
name|gpr
argument_list|,
name|vol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emumix_set_gpr
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|unsigned
name|gpr
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|dbg_level
operator|>
literal|1
condition|)
if|if
condition|(
name|gpr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Zero gpr write access\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_backtrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|GPR
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emumix_set_volume
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|mixer_idx
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|RANGE
argument_list|(
name|volume
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_idx
operator|<
name|NUM_MIXERS
condition|)
block|{
name|sc
operator|->
name|mixer_volcache
index|[
name|mixer_idx
index|]
operator|=
name|volume
expr_stmt|;
name|emumix_set_fxvol
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mixer_gpr
index|[
name|mixer_idx
index|]
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|emumix_get_volume
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|,
name|int
name|mixer_idx
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mixer_idx
operator|<
name|NUM_MIXERS
operator|)
operator|&&
operator|(
name|mixer_idx
operator|>=
literal|0
operator|)
condition|)
return|return
operator|(
name|sc
operator|->
name|mixer_volcache
index|[
name|mixer_idx
index|]
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Init CardBus part */
end_comment

begin_function
specifier|static
name|int
name|emu_cardbus_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * XXX May not need this if we have EMU_IPR3 handler. 	 * Is it a real init calls, or EMU_IPR3 interrupt acknowledgments? 	 * Looks much like "(data<< 16) | register". 	 */
name|emu_wr_cbptr
argument_list|(
name|sc
argument_list|,
operator|(
literal|0x00d0
operator|<<
literal|16
operator|)
operator||
literal|0x0000
argument_list|)
expr_stmt|;
name|emu_wr_cbptr
argument_list|(
name|sc
argument_list|,
operator|(
literal|0x00d0
operator|<<
literal|16
operator|)
operator||
literal|0x0001
argument_list|)
expr_stmt|;
name|emu_wr_cbptr
argument_list|(
name|sc
argument_list|,
operator|(
literal|0x00d0
operator|<<
literal|16
operator|)
operator||
literal|0x005f
argument_list|)
expr_stmt|;
name|emu_wr_cbptr
argument_list|(
name|sc
argument_list|,
operator|(
literal|0x00d0
operator|<<
literal|16
operator|)
operator||
literal|0x007f
argument_list|)
expr_stmt|;
name|emu_wr_cbptr
argument_list|(
name|sc
argument_list|,
operator|(
literal|0x0090
operator|<<
literal|16
operator|)
operator||
literal|0x007f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Probe and attach the card */
end_comment

begin_function
specifier|static
name|int
name|emu_init
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ch
decl_stmt|,
name|tmp
decl_stmt|;
name|uint32_t
name|spdif_sr
decl_stmt|;
name|uint32_t
name|ac97slot
decl_stmt|;
name|int
name|def_mode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* disable audio and lock cache */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
name|EMU_HCFG_LOCKSOUNDCACHE
operator||
name|EMU_HCFG_LOCKTANKCACHE_MASK
operator||
name|EMU_HCFG_MUTEBUTTONENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* reset recording buffers */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_MICBS
argument_list|,
name|EMU_RECBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_MICBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_FXBS
argument_list|,
name|EMU_RECBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_FXBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_ADCBS
argument_list|,
name|EMU_RECBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_ADCBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable channel interrupt */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
name|EMU_INTE_INTERTIMERENB
operator||
name|EMU_INTE_SAMPLERATER
operator||
name|EMU_INTE_PCIERRENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_CLIEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_CLIEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SOLEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SOLEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable P16V and S/PDIF interrupts */
if|if
condition|(
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE2
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_ca0102
condition|)
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE3
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* init phys inputs and outputs */
name|ac97slot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|has_51
condition|)
name|ac97slot
operator|=
name|EMU_AC97SLOT_CENTER
operator||
name|EMU_AC97SLOT_LFE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|has_71
condition|)
name|ac97slot
operator|=
name|EMU_AC97SLOT_CENTER
operator||
name|EMU_AC97SLOT_LFE
operator||
name|EMU_AC97SLOT_REAR_LEFT
operator||
name|EMU_AC97SLOT_REAR_RIGHT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k2
condition|)
name|ac97slot
operator||=
literal|0x40
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_AC97SLOT
argument_list|,
name|ac97slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_emu10k2
condition|)
comment|/* XXX for later cards? */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SPBYPASS
argument_list|,
literal|0xf00
argument_list|)
expr_stmt|;
comment|/* What will happen if 							 * we write 1 here? */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent */
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* alignment */
literal|2
argument_list|,
comment|/* boundary */
literal|0
argument_list|,
comment|/* lowaddr */
operator|(
literal|1U
operator|<<
literal|31
operator|)
operator|-
literal|1
argument_list|,
comment|/* can only access 0-2gb */
comment|/* highaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter */
name|NULL
argument_list|,
comment|/* filterarg */
name|NULL
argument_list|,
comment|/* maxsize */
name|EMU_MAX_BUFSZ
argument_list|,
comment|/* nsegments */
literal|1
argument_list|,
comment|/* maxsegz */
literal|0x3ffff
argument_list|,
comment|/* flags */
literal|0
argument_list|,
comment|/* lockfunc */
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg */
operator|&
name|Giant
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mem
operator|.
name|dmat
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to create dma tag\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|dmat
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|mem
operator|.
name|card
operator|=
name|sc
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mem
operator|.
name|blocks
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
operator|=
name|emu_malloc
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|EMU_MAXPAGES
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|ptb_pages_addr
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|ptb_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|mem
operator|.
name|silent_page
operator|=
name|emu_malloc
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|EMUPAGESIZE
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|,
operator|&
name|sc
operator|->
name|mem
operator|.
name|silent_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|.
name|silent_page
operator|==
name|NULL
condition|)
block|{
name|emu_free
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|ptb_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Clear page with silence& setup all pointers to this page */
name|bzero
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page
argument_list|,
name|EMUPAGESIZE
argument_list|)
expr_stmt|;
name|tmp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|silent_page_addr
argument_list|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAXPAGES
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
index|[
name|i
index|]
operator|=
name|tmp
operator||
name|i
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_MAPA
argument_list|,
name|tmp
operator||
name|EMU_CHAN_MAP_PTI_MASK
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_MAPB
argument_list|,
name|tmp
operator||
name|EMU_CHAN_MAP_PTI_MASK
argument_list|)
expr_stmt|;
block|}
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_PTB
argument_list|,
operator|(
name|sc
operator|->
name|mem
operator|.
name|ptb_pages_addr
operator|)
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_TCB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* taken from original driver */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_TCBS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* taken from original driver */
comment|/* init envelope engine */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_DCYSUSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_IP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_VTFT
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_CVCF
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_PTRX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_CPF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_CCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_PSST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_DSL
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_CCCA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_Z1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_Z2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_FXRT
argument_list|,
literal|0xd01c0000
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_ATKHLDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_DCYSUSM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_IFATN
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_PEFE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_FMMOD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_TREMFRQ
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* 1 Hz */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_FM2FRQ2
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* 1 Hz */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_TEMPENV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*** these are last so OFF prevents writing ***/
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_LFOVAL2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_LFOVAL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_ATKHLDV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_ENVVOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_ENVVAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4c
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4d
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4e
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
literal|0x4f
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_A_CHAN_FXRT1
argument_list|,
literal|0x3f3f3f3f
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_A_CHAN_FXRT2
argument_list|,
literal|0x3f3f3f3f
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_A_CHAN_SENDAMOUNTS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
name|emumix_set_spdif_mode
argument_list|(
name|sc
argument_list|,
name|SPDIF_MODE_PCM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A_SPDIF_SAMPLERATE
argument_list|,
name|EMU_A_SPDIF_48000
argument_list|)
expr_stmt|;
comment|/* 	 * CAxxxx cards needs additional setup: 	 * 1. Set I2S capture sample rate to 96000 	 * 2. Disable P16v / P17v proceesing 	 * 3. Allow EMU10K DSP inputs 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
block|{
name|spdif_sr
operator|=
name|emu_rdptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A_SPDIF_SAMPLERATE
argument_list|)
expr_stmt|;
name|spdif_sr
operator|&=
literal|0xfffff1ff
expr_stmt|;
name|spdif_sr
operator||=
name|EMU_A_I2S_CAPTURE_96000
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A_SPDIF_SAMPLERATE
argument_list|,
name|spdif_sr
argument_list|)
expr_stmt|;
comment|/* Disable P16v processing */
name|emu_wr_p16vptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A2_SRCSel
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
comment|/* Setup P16v/P17v sound routing */
if|if
condition|(
name|sc
operator|->
name|is_ca0102
condition|)
name|emu_wr_p16vptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A2_SRCMULTI_ENABLE
argument_list|,
literal|0xFF00FF00
argument_list|)
expr_stmt|;
else|else
block|{
name|emu_wr_p16vptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A2_MIXER_I2S_ENABLE
argument_list|,
literal|0xFF000000
argument_list|)
expr_stmt|;
name|emu_wr_p16vptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_A2_MIXER_SPDIF_ENABLE
argument_list|,
literal|0xFF000000
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
name|tmp
operator|&
operator|~
literal|0x8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|emu_initefx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|def_mode
operator|=
name|MODE_ANALOG
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
name|def_mode
operator|=
name|MODE_DIGITAL
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
operator|)
operator|&&
operator|(
name|sc
operator|->
name|broken_digital
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Audigy card initialized in analog mode.\n"
argument_list|)
expr_stmt|;
name|def_mode
operator|=
name|MODE_ANALOG
expr_stmt|;
block|}
name|emumix_set_mode
argument_list|(
name|sc
argument_list|,
name|def_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|tmp
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Card Configuration (   0x%08x )\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Card Configuration (& 0xff000000 ) : %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|tmp
operator|&
literal|0x80000000
condition|?
literal|"[Legacy MPIC] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x40000000
condition|?
literal|"[0x40] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x20000000
condition|?
literal|"[0x20] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x10000000
condition|?
literal|"[0x10] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x08000000
condition|?
literal|"[0x08] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x04000000
condition|?
literal|"[0x04] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x02000000
condition|?
literal|"[0x02] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x01000000
condition|?
literal|"[0x01]"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Card Configuration (& 0x00ff0000 ) : %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00800000
condition|?
literal|"[0x80] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00400000
condition|?
literal|"[0x40] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00200000
condition|?
literal|"[Legacy INT] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00100000
condition|?
literal|"[0x10] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00080000
condition|?
literal|"[0x08] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00040000
condition|?
literal|"[Codec4] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00020000
condition|?
literal|"[Codec2] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00010000
condition|?
literal|"[I2S Codec]"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Card Configuration (& 0x0000ff00 ) : %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00008000
condition|?
literal|"[0x80] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00004000
condition|?
literal|"[GPINPUT0] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00002000
condition|?
literal|"[GPINPUT1] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00001000
condition|?
literal|"[GPOUT0] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000800
condition|?
literal|"[GPOUT1] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000400
condition|?
literal|"[GPOUT2] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000200
condition|?
literal|"[Joystick] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000100
condition|?
literal|"[0x01]"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Card Configuration (& 0x000000ff ) : %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000080
condition|?
literal|"[0x80] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000040
condition|?
literal|"[0x40] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000020
condition|?
literal|"[0x20] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000010
condition|?
literal|"[AUTOMUTE] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000008
condition|?
literal|"[LOCKSOUNDCACHE] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000004
condition|?
literal|"[LOCKTANKCACHE] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000002
condition|?
literal|"[MUTEBUTTONENABLE] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x00000001
condition|?
literal|"[AUDIOENABLE]"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
block|{
name|tmp
operator|=
name|emu_rd
argument_list|(
name|sc
argument_list|,
name|EMU_A_IOCFG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Audigy Card Configuration (    0x%04x )\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Audigy Card Configuration (& 0xff00 )"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" : %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|tmp
operator|&
literal|0x8000
condition|?
literal|"[Rear Speakers] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x4000
condition|?
literal|"[Front Speakers] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x2000
condition|?
literal|"[0x20] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x1000
condition|?
literal|"[0x10] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0800
condition|?
literal|"[0x08] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0400
condition|?
literal|"[0x04] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0200
condition|?
literal|"[0x02] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0100
condition|?
literal|"[AudigyDrive Phones]"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Audigy Card Configuration (& 0x00ff )"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" : %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0080
condition|?
literal|"[0x80] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0040
condition|?
literal|"[Mute AnalogOut] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0020
condition|?
literal|"[0x20] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0010
condition|?
literal|"[0x10] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0008
condition|?
literal|"[0x08] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0004
condition|?
literal|"[GPOUT0] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0002
condition|?
literal|"[GPOUT1] "
else|:
literal|""
operator|)
argument_list|,
operator|(
name|tmp
operator|&
literal|0x0001
condition|?
literal|"[GPOUT2]"
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* is_emu10k2 or ca* */
block|}
comment|/* bootverbose */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_uninit
parameter_list|(
name|struct
name|emu_sc_info
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ch
decl_stmt|;
name|struct
name|emu_memblk
modifier|*
name|blk
decl_stmt|;
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_INTE
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_DCYSUSV
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|NUM_G
condition|;
name|ch
operator|++
control|)
block|{
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_VTFT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_CVCF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_PTRX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|,
name|EMU_CHAN_CPF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* disable audio and lock cache */
name|emu_wr
argument_list|(
name|sc
argument_list|,
name|EMU_HCFG
argument_list|,
name|EMU_HCFG_LOCKSOUNDCACHE
operator||
name|EMU_HCFG_LOCKTANKCACHE_MASK
operator||
name|EMU_HCFG_MUTEBUTTONENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_PTB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset recording buffers */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_MICBS
argument_list|,
name|EMU_RECBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_MICBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_FXBS
argument_list|,
name|EMU_RECBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_FXBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_FXWC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_ADCBS
argument_list|,
name|EMU_RECBS_BUFSIZE_NONE
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_ADCBA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_TCB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_TCBS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable channel interrupt */
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_CLIEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_CLIEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SOLEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emu_wrptr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|EMU_SOLEH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|mem
operator|.
name|blocks
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"warning: memblock list not empty\n"
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|blk
argument_list|,
argument|&sc->mem.blocks
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|blk
operator|!=
name|NULL
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"lost %d for %s\n"
argument_list|,
name|blk
operator|->
name|pte_size
argument_list|,
name|blk
operator|->
name|owner
argument_list|)
expr_stmt|;
name|emu_free
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|ptb_pages
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|ptb_map
argument_list|)
expr_stmt|;
name|emu_free
argument_list|(
operator|&
name|sc
operator|->
name|mem
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|silent_page
argument_list|,
name|sc
operator|->
name|mem
operator|.
name|silent_map
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_read_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|ivar_index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|sndcard_func
modifier|*
name|func
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|emu_sc_info
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|ivar_index
condition|)
block|{
case|case
name|EMU_VAR_FUNC
case|:
operator|*
name|result
operator|=
name|func
operator|->
name|func
expr_stmt|;
break|break;
case|case
name|EMU_VAR_ROUTE
case|:
if|if
condition|(
name|func
operator|->
name|varinfo
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|result
operator|=
operator|(
operator|(
expr|struct
name|emu_pcminfo
operator|*
operator|)
name|func
operator|->
name|varinfo
operator|)
operator|->
name|route
expr_stmt|;
break|break;
case|case
name|EMU_VAR_ISEMU10K1
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|is_emu10k1
expr_stmt|;
break|break;
case|case
name|EMU_VAR_MCH_DISABLED
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|mch_disabled
expr_stmt|;
break|break;
case|case
name|EMU_VAR_MCH_REC
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|mch_rec
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_write_ivar
parameter_list|(
name|device_t
name|bus
name|__unused
parameter_list|,
name|device_t
name|dev
name|__unused
parameter_list|,
name|int
name|ivar_index
parameter_list|,
name|uintptr_t
name|value
name|__unused
parameter_list|)
block|{
switch|switch
condition|(
name|ivar_index
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|thiscard
init|=
literal|0
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|vendor
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
comment|/* bytes */
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|!=
literal|0x1102
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Not Creative */
name|thiscard
operator|=
name|emu_getcard
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|thiscard
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Creative %s [%s]"
argument_list|,
name|emu_cards
index|[
name|thiscard
index|]
operator|.
name|desc
argument_list|,
name|emu_cards
index|[
name|thiscard
index|]
operator|.
name|SBcode
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|sbuf_data
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|struct
name|emu_pcminfo
modifier|*
name|pcminfo
decl_stmt|;
if|#
directive|if
literal|0
block|struct emu_midiinfo *midiinfo;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|int
name|device_flags
decl_stmt|;
name|char
name|status
index|[
literal|255
index|]
decl_stmt|;
name|int
name|error
init|=
name|ENXIO
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Get configuration */
name|sc
operator|->
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|sc
operator|->
name|root
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|root
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"emu10kx"
argument_list|,
name|unit
argument_list|,
literal|"multichannel_disabled"
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mch_disabled
operator|)
argument_list|)
condition|)
name|RANGE
argument_list|(
name|sc
operator|->
name|mch_disabled
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"multichannel_disabled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mch_disabled
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Multichannel playback setting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"emu10kx"
argument_list|,
name|unit
argument_list|,
literal|"multichannel_recording"
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mch_rec
operator|)
argument_list|)
condition|)
name|RANGE
argument_list|(
name|sc
operator|->
name|mch_rec
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"multichannel_recording"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mch_rec
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Multichannel recording setting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"emu10kx"
argument_list|,
name|unit
argument_list|,
literal|"debug"
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|dbg_level
operator|)
argument_list|)
condition|)
name|RANGE
argument_list|(
name|sc
operator|->
name|mch_rec
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|dbg_level
operator|)
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
comment|/* Fill in the softc. */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"bridge conf"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|rw
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"exclusive io"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enable_ir
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|has_ac97
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|has_51
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|has_71
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|broken_digital
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|is_emu10k1
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|is_emu10k2
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|is_ca0102
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|is_ca0108
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|is_cardbus
operator|=
literal|0
expr_stmt|;
name|device_flags
operator|=
name|emu_cards
index|[
name|emu_getcard
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|device_flags
operator|&
name|HAS_51
condition|)
name|sc
operator|->
name|has_51
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|device_flags
operator|&
name|HAS_71
condition|)
block|{
name|sc
operator|->
name|has_51
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|has_71
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|device_flags
operator|&
name|IS_EMU10K1
condition|)
name|sc
operator|->
name|is_emu10k1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|device_flags
operator|&
name|IS_EMU10K2
condition|)
name|sc
operator|->
name|is_emu10k2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|device_flags
operator|&
name|IS_CA0102
condition|)
name|sc
operator|->
name|is_ca0102
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|device_flags
operator|&
name|IS_CA0108
condition|)
name|sc
operator|->
name|is_ca0108
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|&&
operator|(
name|sc
operator|->
name|rev
operator|==
literal|4
operator|)
condition|)
block|{
name|sc
operator|->
name|is_emu10k2
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|is_ca0102
operator|=
literal|1
expr_stmt|;
comment|/* for unknown Audigy 2 cards */
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|is_ca0102
operator|==
literal|1
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|==
literal|1
operator|)
condition|)
if|if
condition|(
name|device_flags
operator|&
name|IS_CARDBUS
condition|)
name|sc
operator|->
name|is_cardbus
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k1
operator|+
name|sc
operator|->
name|is_emu10k2
operator|+
name|sc
operator|->
name|is_ca0102
operator|+
name|sc
operator|->
name|is_ca0108
operator|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to detect HW chipset\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|device_flags
operator|&
name|BROKEN_DIGITAL
condition|)
name|sc
operator|->
name|broken_digital
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|device_flags
operator|&
name|HAS_AC97
condition|)
name|sc
operator|->
name|has_ac97
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|opcode_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|is_emu10k2
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0102
operator|)
operator|||
operator|(
name|sc
operator|->
name|is_ca0108
operator|)
condition|)
block|{
name|sc
operator|->
name|opcode_shift
operator|=
literal|24
expr_stmt|;
name|sc
operator|->
name|high_operand_shift
operator|=
literal|12
expr_stmt|;
comment|/*	DSP map				*/
comment|/*	sc->fx_base = 0x0		*/
name|sc
operator|->
name|input_base
operator|=
literal|0x40
expr_stmt|;
comment|/*	sc->p16vinput_base = 0x50;	*/
name|sc
operator|->
name|output_base
operator|=
literal|0x60
expr_stmt|;
name|sc
operator|->
name|efxc_base
operator|=
literal|0x80
expr_stmt|;
comment|/*	sc->output32h_base = 0xa0;	*/
comment|/*	sc->output32l_base = 0xb0;	*/
name|sc
operator|->
name|dsp_zero
operator|=
literal|0xc0
expr_stmt|;
comment|/*	0xe0...0x100 are unknown	*/
comment|/*	sc->tram_base = 0x200		*/
comment|/*	sc->tram_addr_base = 0x300	*/
name|sc
operator|->
name|gpr_base
operator|=
name|EMU_A_FXGPREGBASE
expr_stmt|;
name|sc
operator|->
name|num_gprs
operator|=
literal|0x200
expr_stmt|;
name|sc
operator|->
name|code_base
operator|=
name|EMU_A_MICROCODEBASE
expr_stmt|;
name|sc
operator|->
name|code_size
operator|=
literal|0x800
operator|/
literal|2
expr_stmt|;
comment|/* 0x600-0xdff,  2048 words, 						 * 1024 instructions */
name|sc
operator|->
name|mchannel_fx
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|num_fxbuses
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|num_inputs
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|num_outputs
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|address_mask
operator|=
name|EMU_A_PTR_ADDR_MASK
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|is_emu10k1
condition|)
block|{
name|sc
operator|->
name|has_51
operator|=
literal|0
expr_stmt|;
comment|/* We don't support 5.1 sound on SB Live! 5.1 */
name|sc
operator|->
name|opcode_shift
operator|=
literal|20
expr_stmt|;
name|sc
operator|->
name|high_operand_shift
operator|=
literal|10
expr_stmt|;
name|sc
operator|->
name|code_base
operator|=
name|EMU_MICROCODEBASE
expr_stmt|;
name|sc
operator|->
name|code_size
operator|=
literal|0x400
operator|/
literal|2
expr_stmt|;
comment|/* 0x400-0x7ff,  1024 words, 						 * 512 instructions */
name|sc
operator|->
name|gpr_base
operator|=
name|EMU_FXGPREGBASE
expr_stmt|;
name|sc
operator|->
name|num_gprs
operator|=
literal|0x100
expr_stmt|;
name|sc
operator|->
name|input_base
operator|=
literal|0x10
expr_stmt|;
name|sc
operator|->
name|output_base
operator|=
literal|0x20
expr_stmt|;
comment|/* 		 * XXX 5.1 Analog outputs are inside efxc address space! 		 * They use output+0x11/+0x12 (=efxc+1/+2). 		 * Don't use this efx registers for recording on SB Live! 5.1! 		 */
name|sc
operator|->
name|efxc_base
operator|=
literal|0x30
expr_stmt|;
name|sc
operator|->
name|dsp_zero
operator|=
literal|0x40
expr_stmt|;
name|sc
operator|->
name|mchannel_fx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_fxbuses
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|num_inputs
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|num_outputs
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|address_mask
operator|=
name|EMU_PTR_ADDR_MASK
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|opcode_shift
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|i
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map register space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMU_MAX_IRQ_CONSUMERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|timer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* disable it */
name|i
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|i
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|irq
operator|==
name|NULL
operator|)
operator|||
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_AV
argument_list|,
name|NULL
argument_list|,
name|emu_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|emu_rm_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create resource manager\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|is_cardbus
condition|)
if|if
condition|(
name|emu_cardbus_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize CardBus interface\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|emu_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to initialize the card\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|emu10kx_dev_init
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create control device\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|snprintf
argument_list|(
name|status
argument_list|,
literal|255
argument_list|,
literal|"rev %d at io 0x%jx irq %jd"
argument_list|,
name|sc
operator|->
name|rev
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Voices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_G
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|vnum
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|slave
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|ismaster
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|b16
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|stereo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|voice
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* PCM Audio */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RT_COUNT
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|pcm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* FRONT */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_pcminfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcminfo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|pcminfo
operator|->
name|route
operator|=
name|RT_FRONT
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|func
operator|->
name|varinfo
operator|=
name|pcminfo
expr_stmt|;
name|sc
operator|->
name|pcm
index|[
name|RT_FRONT
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|RT_FRONT
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|mch_disabled
operator|)
condition|)
block|{
comment|/* REAR */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_pcminfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcminfo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|pcminfo
operator|->
name|route
operator|=
name|RT_REAR
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|func
operator|->
name|varinfo
operator|=
name|pcminfo
expr_stmt|;
name|sc
operator|->
name|pcm
index|[
name|RT_REAR
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|RT_REAR
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|has_51
condition|)
block|{
comment|/* CENTER */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_pcminfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcminfo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|pcminfo
operator|->
name|route
operator|=
name|RT_CENTER
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|func
operator|->
name|varinfo
operator|=
name|pcminfo
expr_stmt|;
name|sc
operator|->
name|pcm
index|[
name|RT_CENTER
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|RT_CENTER
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* SUB */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_pcminfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcminfo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|pcminfo
operator|->
name|route
operator|=
name|RT_SUB
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|func
operator|->
name|varinfo
operator|=
name|pcminfo
expr_stmt|;
name|sc
operator|->
name|pcm
index|[
name|RT_SUB
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|RT_SUB
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|has_71
condition|)
block|{
comment|/* SIDE */
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_pcminfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcminfo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|pcminfo
operator|->
name|route
operator|=
name|RT_SIDE
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|func
operator|->
name|varinfo
operator|=
name|pcminfo
expr_stmt|;
name|sc
operator|->
name|pcm
index|[
name|RT_SIDE
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|RT_SIDE
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mch_disabled */
if|if
condition|(
name|sc
operator|->
name|mch_rec
condition|)
block|{
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sndcard_func
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|emu_pcminfo
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcminfo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pcminfo
operator|->
name|card
operator|=
name|sc
expr_stmt|;
name|pcminfo
operator|->
name|route
operator|=
name|RT_MCHRECORD
expr_stmt|;
name|func
operator|->
name|func
operator|=
name|SCF_PCM
expr_stmt|;
name|func
operator|->
name|varinfo
operator|=
name|pcminfo
expr_stmt|;
name|sc
operator|->
name|pcm
index|[
name|RT_MCHRECORD
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcm"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|RT_MCHRECORD
index|]
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
comment|/*mch_rec */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|midi
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* MIDI has some memory mangament and (possible) locking problems */
if|#
directive|if
literal|0
comment|/* Midi Interface 1: Live!, Audigy, Audigy 2 */
block|if ((sc->is_emu10k1) || (sc->is_emu10k2) || (sc->is_ca0102)) { 		func = malloc(sizeof(struct sndcard_func), M_DEVBUF, M_NOWAIT | M_ZERO); 		if (func == NULL) { 			error = ENOMEM; 			goto bad; 		} 		midiinfo = malloc(sizeof(struct emu_midiinfo), M_DEVBUF, M_NOWAIT | M_ZERO); 		if (midiinfo == NULL) { 			error = ENOMEM; 			goto bad; 		} 		midiinfo->card = sc; 		if (sc->is_emu10k2 || (sc->is_ca0102)) { 			midiinfo->port = EMU_A_MUDATA1; 			midiinfo->portnr = 1; 		} 		if (sc->is_emu10k1) { 			midiinfo->port = MUDATA; 			midiinfo->portnr = 1; 		} 		func->func = SCF_MIDI; 		func->varinfo = midiinfo; 		sc->midi[0] = device_add_child(dev, "midi", -1); 		device_set_ivars(sc->midi[0], func); 	}
comment|/* Midi Interface 2: Audigy, Audigy 2 (on AudigyDrive) */
block|if (sc->is_emu10k2 || (sc->is_ca0102)) { 		func = malloc(sizeof(struct sndcard_func), M_DEVBUF, M_NOWAIT | M_ZERO); 		if (func == NULL) { 			error = ENOMEM; 			goto bad; 		} 		midiinfo = malloc(sizeof(struct emu_midiinfo), M_DEVBUF, M_NOWAIT | M_ZERO); 		if (midiinfo == NULL) { 			error = ENOMEM; 			goto bad; 		} 		midiinfo->card = sc;  		midiinfo->port = EMU_A_MUDATA2; 		midiinfo->portnr = 2;  		func->func = SCF_MIDI; 		func->varinfo = midiinfo; 		sc->midi[1] = device_add_child(dev, "midi", -1); 		device_set_ivars(sc->midi[1], func); 	}
endif|#
directive|endif
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
name|bad
label|:
comment|/* XXX can we just call emu_pci_detach here? */
if|if
condition|(
name|sc
operator|->
name|cdev
condition|)
name|emu10kx_dev_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rm
operator|!=
name|NULL
condition|)
name|emu_rm_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|rw
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emu_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|emu_sc_info
modifier|*
name|sc
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
name|int
name|devcount
decl_stmt|,
name|i
decl_stmt|;
name|device_t
modifier|*
name|childlist
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RT_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|func
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
operator|&&
name|func
operator|->
name|func
operator|==
name|SCF_PCM
condition|)
block|{
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|pcm
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
operator|->
name|varinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|pcm
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|func
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
operator|&&
name|func
operator|->
name|func
operator|==
name|SCF_MIDI
condition|)
block|{
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
operator|->
name|varinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|midi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|midi
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|func
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
operator|&&
name|func
operator|->
name|func
operator|==
name|SCF_MIDI
condition|)
block|{
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|midi
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
operator|->
name|varinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|midi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|childlist
argument_list|,
operator|&
name|devcount
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"removing stale child %d (unit %d)\n"
argument_list|,
name|i
argument_list|,
name|device_get_unit
argument_list|(
name|childlist
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|func
operator|=
name|device_get_ivars
argument_list|(
name|childlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
operator|&&
operator|(
name|func
operator|->
name|func
operator|==
name|SCF_MIDI
operator|||
name|func
operator|->
name|func
operator|==
name|SCF_PCM
operator|)
condition|)
block|{
name|device_set_ivars
argument_list|(
name|childlist
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
operator|->
name|varinfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|func
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|childlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|childlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|r
operator|=
name|emu10kx_dev_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* shutdown chip */
name|emu_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|emu_rm_uninit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|.
name|dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mem
operator|.
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|reg
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|rw
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* add suspend, resume */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|emu_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|emu_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|emu_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|emu_pci_detach
argument_list|)
block|,
comment|/* Bus methods */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|emu_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|emu_write_ivar
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|emu_driver
init|=
block|{
literal|"emu10kx"
block|,
name|emu_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|emu_sc_info
argument_list|)
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|emu_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
break|break;
comment|/* Success */
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_SHUTDOWN
case|:
comment|/* XXX  Should we check state of pcm& midi subdevices here? */
break|break;
comment|/* Success */
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|emu_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_emu10kx
argument_list|,
name|pci
argument_list|,
name|emu_driver
argument_list|,
name|emu_devclass
argument_list|,
name|emu_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_emu10kx
argument_list|,
name|SND_EMU10KX_PREFVER
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

