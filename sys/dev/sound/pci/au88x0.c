begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Dag-Erling Coïdan Smørgrav  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pcm/ac97.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/pci/au88x0.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                          SUPPORTED CHIPSETS                             *  *                                                                         * \***************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|au88x0_chipset
name|au88x0_chipsets
index|[]
init|=
block|{
block|{
operator|.
name|auc_name
operator|=
literal|"Aureal Vortex (8820)"
block|,
operator|.
name|auc_pci_id
operator|=
literal|0x000112eb
block|,
operator|.
name|auc_control
operator|=
literal|0x1280c
block|,
operator|.
name|auc_irq_source
operator|=
literal|0x12800
block|,
operator|.
name|auc_irq_mask
operator|=
literal|0x12804
block|,
operator|.
name|auc_irq_control
operator|=
literal|0x12808
block|,
operator|.
name|auc_irq_status
operator|=
literal|0x1199c
block|,
operator|.
name|auc_dma_control
operator|=
literal|0x1060c
block|,
operator|.
name|auc_fifo_size
operator|=
literal|0x20
block|,
operator|.
name|auc_wt_fifos
operator|=
literal|32
block|,
operator|.
name|auc_wt_fifo_base
operator|=
literal|0x0e800
block|,
operator|.
name|auc_wt_fifo_ctl
operator|=
literal|0x0f800
block|,
operator|.
name|auc_wt_dma_ctl
operator|=
literal|0x10500
block|,
operator|.
name|auc_adb_fifos
operator|=
literal|16
block|,
operator|.
name|auc_adb_fifo_base
operator|=
literal|0x0e000
block|,
operator|.
name|auc_adb_fifo_ctl
operator|=
literal|0x0f840
block|,
operator|.
name|auc_adb_dma_ctl
operator|=
literal|0x10580
block|,
operator|.
name|auc_adb_route_base
operator|=
literal|0x10800
block|,
operator|.
name|auc_adb_route_bits
operator|=
literal|7
block|,
operator|.
name|auc_adb_codec_in
operator|=
literal|0x48
block|,
operator|.
name|auc_adb_codec_out
operator|=
literal|0x58
block|, 	}
block|,
block|{
operator|.
name|auc_name
operator|=
literal|"Aureal Vortex 2 (8830)"
block|,
operator|.
name|auc_pci_id
operator|=
literal|0x000212eb
block|,
operator|.
name|auc_control
operator|=
literal|0x2a00c
block|,
operator|.
name|auc_irq_source
operator|=
literal|0x2a000
block|,
operator|.
name|auc_irq_mask
operator|=
literal|0x2a004
block|,
operator|.
name|auc_irq_control
operator|=
literal|0x2a008
block|,
operator|.
name|auc_irq_status
operator|=
literal|0x2919c
block|,
operator|.
name|auc_dma_control
operator|=
literal|0x27ae8
block|,
operator|.
name|auc_fifo_size
operator|=
literal|0x40
block|,
operator|.
name|auc_wt_fifos
operator|=
literal|64
block|,
operator|.
name|auc_wt_fifo_base
operator|=
literal|0x10000
block|,
operator|.
name|auc_wt_fifo_ctl
operator|=
literal|0x16000
block|,
operator|.
name|auc_wt_dma_ctl
operator|=
literal|0x27900
block|,
operator|.
name|auc_adb_fifos
operator|=
literal|32
block|,
operator|.
name|auc_adb_fifo_base
operator|=
literal|0x14000
block|,
operator|.
name|auc_adb_fifo_ctl
operator|=
literal|0x16100
block|,
operator|.
name|auc_adb_dma_ctl
operator|=
literal|0x27a00
block|,
operator|.
name|auc_adb_route_base
operator|=
literal|0x28000
block|,
operator|.
name|auc_adb_route_bits
operator|=
literal|8
block|,
operator|.
name|auc_adb_codec_in
operator|=
literal|0x70
block|,
operator|.
name|auc_adb_codec_out
operator|=
literal|0x88
block|, 	}
block|,
block|{
operator|.
name|auc_name
operator|=
literal|"Aureal Vortex Advantage (8810)"
block|,
operator|.
name|auc_pci_id
operator|=
literal|0x000312eb
block|,
operator|.
name|auc_control
operator|=
literal|0x2a00c
block|,
operator|.
name|auc_irq_source
operator|=
literal|0x2a000
block|,
operator|.
name|auc_irq_mask
operator|=
literal|0x2a004
block|,
operator|.
name|auc_irq_control
operator|=
literal|0x2a008
block|,
operator|.
name|auc_irq_status
operator|=
literal|0x2919c
block|,
operator|.
name|auc_dma_control
operator|=
literal|0x27ae8
block|,
operator|.
name|auc_fifo_size
operator|=
literal|0x20
block|,
operator|.
name|auc_wt_fifos
operator|=
literal|32
block|,
operator|.
name|auc_wt_fifo_base
operator|=
literal|0x10000
block|,
operator|.
name|auc_wt_fifo_ctl
operator|=
literal|0x16000
block|,
operator|.
name|auc_wt_dma_ctl
operator|=
literal|0x27fd8
block|,
operator|.
name|auc_adb_fifos
operator|=
literal|16
block|,
operator|.
name|auc_adb_fifo_base
operator|=
literal|0x14000
block|,
operator|.
name|auc_adb_fifo_ctl
operator|=
literal|0x16100
block|,
operator|.
name|auc_adb_dma_ctl
operator|=
literal|0x27180
block|,
operator|.
name|auc_adb_route_base
operator|=
literal|0x28000
block|,
operator|.
name|auc_adb_route_bits
operator|=
literal|8
block|,
operator|.
name|auc_adb_codec_in
operator|=
literal|0x70
block|,
operator|.
name|auc_adb_codec_out
operator|=
literal|0x88
block|, 	}
block|,
block|{
operator|.
name|auc_pci_id
operator|=
literal|0
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                       FORMATS AND CAPABILITIES                          *  *                                                                         * \***************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|au88x0_formats
index|[]
init|=
block|{
name|AFMT_U8
block|,
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_STEREO
operator||
name|AFMT_S16_LE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|au88x0_capabilities
init|=
block|{
literal|4000
block|,
comment|/* minimum sample rate */
literal|48000
block|,
comment|/* maximum sample rate */
name|au88x0_formats
block|,
comment|/* supported formats */
literal|0
comment|/* no particular capabilities */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                           CODEC INTERFACE                               *  *                                                                         * \***************************************************************************/
end_comment

begin_comment
comment|/*  * Read from the au88x0 register space  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* all our writes are 32-bit */
end_comment

begin_define
define|#
directive|define
name|au88x0_read
parameter_list|(
name|aui
parameter_list|,
name|reg
parameter_list|,
name|n
parameter_list|)
define|\
value|bus_space_read_4((aui)->aui_spct, (aui)->aui_spch, (reg))
end_define

begin_define
define|#
directive|define
name|au88x0_write
parameter_list|(
name|aui
parameter_list|,
name|reg
parameter_list|,
name|data
parameter_list|,
name|n
parameter_list|)
define|\
value|bus_space_write_4((aui)->aui_spct, (aui)->aui_spch, (reg), (data))
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|uint32_t
name|au88x0_read
parameter_list|(
name|struct
name|au88x0_info
modifier|*
name|aui
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|data
operator|=
name|bus_space_read_1
argument_list|(
name|aui
operator|->
name|aui_spct
argument_list|,
name|aui
operator|->
name|aui_spch
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|data
operator|=
name|bus_space_read_2
argument_list|(
name|aui
operator|->
name|aui_spct
argument_list|,
name|aui
operator|->
name|aui_spch
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|data
operator|=
name|bus_space_read_4
argument_list|(
name|aui
operator|->
name|aui_spct
argument_list|,
name|aui
operator|->
name|aui_spch
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unsupported read size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to the au88x0 register space  */
end_comment

begin_function
specifier|static
name|void
name|au88x0_write
parameter_list|(
name|struct
name|au88x0_info
modifier|*
name|aui
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|aui
operator|->
name|aui_spct
argument_list|,
name|aui
operator|->
name|aui_spch
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|aui
operator|->
name|aui_spct
argument_list|,
name|aui
operator|->
name|aui_spch
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|aui
operator|->
name|aui_spct
argument_list|,
name|aui
operator|->
name|aui_spch
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unsupported write size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Reset and initialize the codec  */
end_comment

begin_function
specifier|static
name|void
name|au88x0_codec_init
parameter_list|(
name|struct
name|au88x0_info
modifier|*
name|aui
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* wave that chicken */
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_CONTROL
argument_list|,
literal|0x8068
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AU88X0_SETTLE_DELAY
argument_list|)
expr_stmt|;
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_CONTROL
argument_list|,
literal|0x00e8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_CHANNEL
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AU88X0_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_CONTROL
argument_list|,
literal|0x00e8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AU88X0_SETTLE_DELAY
argument_list|)
expr_stmt|;
comment|/* enable both codec channels */
name|data
operator|=
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_ENABLE
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|+
literal|0
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_ENABLE
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AU88X0_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for the codec to get ready to accept a register write  * Should be called at spltty  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_codec_wait
parameter_list|(
name|struct
name|au88x0_info
modifier|*
name|aui
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AU88X0_RETRY_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|data
operator|=
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_CONTROL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|AU88X0_CDCTL_WROK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
name|AU88X0_SETTLE_DELAY
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|aui
operator|->
name|aui_dev
argument_list|,
literal|"timeout while waiting for codec\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read from the ac97 codec  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_codec_read
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|au88x0_info
modifier|*
name|aui
init|=
name|arg
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|int
name|sl
decl_stmt|;
name|sl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|au88x0_codec_wait
argument_list|(
name|aui
argument_list|)
expr_stmt|;
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_IO
argument_list|,
name|AU88X0_CDIO_READ
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|data
operator|=
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_IO
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|data
operator|&=
name|AU88X0_CDIO_DATA_MASK
expr_stmt|;
name|data
operator|>>=
name|AU88X0_CDIO_DATA_SHIFT
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write to the ac97 codec  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_codec_write
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|au88x0_info
modifier|*
name|aui
init|=
name|arg
decl_stmt|;
name|int
name|sl
decl_stmt|;
name|sl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|au88x0_codec_wait
argument_list|(
name|aui
argument_list|)
expr_stmt|;
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|AU88X0_CODEC_IO
argument_list|,
name|AU88X0_CDIO_WRITE
argument_list|(
name|reg
argument_list|,
name|data
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|sl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Codec interface glue  */
end_comment

begin_decl_stmt
specifier|static
name|kobj_method_t
name|au88x0_ac97_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|ac97_read
argument_list|,
name|au88x0_codec_read
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|ac97_write
argument_list|,
name|au88x0_codec_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|AC97_DECLARE
argument_list|(
name|au88x0_ac97
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|au88x0_channel
parameter_list|(
name|aui
parameter_list|,
name|dir
parameter_list|)
define|\
value|&(aui)->aui_chan[((dir) == PCMDIR_PLAY) ? 0 : 1]
end_define

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                          CHANNEL INTERFACE                              *  *                                                                         * \***************************************************************************/
end_comment

begin_comment
comment|/*  * Initialize a PCM channel  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|au88x0_chan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|buf
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|chan
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|au88x0_info
modifier|*
name|aui
init|=
name|arg
decl_stmt|;
name|struct
name|au88x0_chan_info
modifier|*
name|auci
init|=
name|au88x0_channel
argument_list|(
name|aui
argument_list|,
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|buf
argument_list|,
name|aui
operator|->
name|aui_dmat
argument_list|,
literal|0
argument_list|,
name|aui
operator|->
name|aui_bufsize
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|auci
operator|->
name|auci_aui
operator|=
name|aui
expr_stmt|;
name|auci
operator|->
name|auci_pcmchan
operator|=
name|chan
expr_stmt|;
name|auci
operator|->
name|auci_buf
operator|=
name|buf
expr_stmt|;
name|auci
operator|->
name|auci_dir
operator|=
name|dir
expr_stmt|;
return|return
operator|(
name|auci
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the data format for a PCM channel  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_chan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
comment|/* XXX */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the sample rate for a PCM channel  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_chan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
comment|/* XXX */
return|return
operator|(
name|speed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the block size for a PCM channel  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_chan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
comment|/* XXX */
return|return
operator|(
name|blocksize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate a data transfer  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_chan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|trigger
parameter_list|)
block|{
name|struct
name|au88x0_chan_info
modifier|*
name|auci
init|=
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|auci
expr_stmt|;
switch|switch
condition|(
name|trigger
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_chan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the capabilities of a PCM channel  */
end_comment

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|au88x0_chan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
operator|&
name|au88x0_capabilities
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Channel interface glue  */
end_comment

begin_decl_stmt
specifier|static
name|kobj_method_t
name|au88x0_chan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|au88x0_chan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|au88x0_chan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|au88x0_chan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|au88x0_chan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|au88x0_chan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|au88x0_chan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|au88x0_chan_getcaps
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|au88x0_chan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                          INTERRUPT HANDLER                              *  *                                                                         * \***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|au88x0_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|au88x0_info
modifier|*
name|aui
init|=
name|arg
decl_stmt|;
name|struct
name|au88x0_chipset
modifier|*
name|auc
init|=
name|aui
operator|->
name|aui_chipset
decl_stmt|;
name|int
name|pending
decl_stmt|,
name|source
decl_stmt|;
name|pending
operator|=
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_control
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pending
operator|&
name|AU88X0_IRQ_PENDING_BIT
operator|)
operator|==
literal|0
condition|)
return|return;
name|source
operator|=
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_source
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|&
name|AU88X0_IRQ_FATAL_ERR
condition|)
name|device_printf
argument_list|(
name|aui
operator|->
name|aui_dev
argument_list|,
literal|"fatal error interrupt received\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|&
name|AU88X0_IRQ_PARITY_ERR
condition|)
name|device_printf
argument_list|(
name|aui
operator|->
name|aui_dev
argument_list|,
literal|"parity error interrupt received\n"
argument_list|)
expr_stmt|;
comment|/* XXX handle the others... */
comment|/* acknowledge the interrupts we just handled */
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_source
argument_list|,
name|source
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_source
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                            INITIALIZATION                               *  *                                                                         * \***************************************************************************/
end_comment

begin_comment
comment|/*  * Reset and initialize the ADB and WT FIFOs  *  *  - need to find out what the magic values 0x42000 and 0x2000 mean.  */
end_comment

begin_function
specifier|static
name|void
name|au88x0_fifo_init
parameter_list|(
name|struct
name|au88x0_info
modifier|*
name|aui
parameter_list|)
block|{
name|struct
name|au88x0_chipset
modifier|*
name|auc
init|=
name|aui
operator|->
name|aui_chipset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* reset, then clear the ADB FIFOs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|auc
operator|->
name|auc_adb_fifos
condition|;
operator|++
name|i
control|)
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_adb_fifo_ctl
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0x42000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|auc
operator|->
name|auc_adb_fifos
operator|*
name|auc
operator|->
name|auc_fifo_size
condition|;
operator|++
name|i
control|)
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_adb_fifo_base
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* reset, then clear the WT FIFOs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|auc
operator|->
name|auc_wt_fifos
condition|;
operator|++
name|i
control|)
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_wt_fifo_ctl
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0x42000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|auc
operator|->
name|auc_wt_fifos
operator|*
name|auc
operator|->
name|auc_fifo_size
condition|;
operator|++
name|i
control|)
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_wt_fifo_base
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hardware initialization  */
end_comment

begin_function
specifier|static
name|void
name|au88x0_init
parameter_list|(
name|struct
name|au88x0_info
modifier|*
name|aui
parameter_list|)
block|{
name|struct
name|au88x0_chipset
modifier|*
name|auc
init|=
name|aui
operator|->
name|aui_chipset
decl_stmt|;
comment|/* reset the chip */
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_control
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* clear all interrupts */
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_source
argument_list|,
literal|0xffffffff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_source
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|au88x0_read
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_irq_status
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* initialize the codec */
name|au88x0_codec_init
argument_list|(
name|aui
argument_list|)
expr_stmt|;
comment|/* initialize the fifos */
name|au88x0_fifo_init
argument_list|(
name|aui
argument_list|)
expr_stmt|;
comment|/* initialize the DMA engine */
comment|/* XXX chicken-waving! */
name|au88x0_write
argument_list|(
name|aui
argument_list|,
name|auc
operator|->
name|auc_dma_control
argument_list|,
literal|0x1380000
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct and set status string  */
end_comment

begin_function
specifier|static
name|void
name|au88x0_set_status
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|struct
name|au88x0_info
modifier|*
name|aui
decl_stmt|;
name|aui
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
sizeof|sizeof
name|status
argument_list|,
literal|"at %s 0x%lx irq %ld %s"
argument_list|,
operator|(
name|aui
operator|->
name|aui_regtype
operator|==
name|SYS_RES_IOPORT
operator|)
condition|?
literal|"io"
else|:
literal|"memory"
argument_list|,
name|rman_get_start
argument_list|(
name|aui
operator|->
name|aui_reg
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|aui
operator|->
name|aui_irq
argument_list|)
argument_list|,
name|PCM_KLDSTRING
argument_list|(
name|snd_au88x0
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***************************************************************************\  *                                                                         *  *                            PCI INTERFACE                                *  *                                                                         * \***************************************************************************/
end_comment

begin_comment
comment|/*  * Probe  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|au88x0_chipset
modifier|*
name|auc
decl_stmt|;
name|uint32_t
name|pci_id
decl_stmt|;
name|pci_id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|auc
operator|=
name|au88x0_chipsets
init|;
name|auc
operator|->
name|auc_pci_id
condition|;
operator|++
name|auc
control|)
block|{
if|if
condition|(
name|auc
operator|->
name|auc_pci_id
operator|==
name|pci_id
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|auc
operator|->
name|auc_name
argument_list|)
expr_stmt|;
return|return
name|BUS_PROBE_DEFAULT
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|au88x0_chipset
modifier|*
name|auc
decl_stmt|;
name|struct
name|au88x0_info
modifier|*
name|aui
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|config
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|aui
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|aui
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|aui
operator|->
name|aui_dev
operator|=
name|dev
expr_stmt|;
comment|/* Model-specific parameters */
name|aui
operator|->
name|aui_model
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|auc
operator|=
name|au88x0_chipsets
init|;
name|auc
operator|->
name|auc_pci_id
condition|;
operator|++
name|auc
control|)
if|if
condition|(
name|auc
operator|->
name|auc_pci_id
operator|==
name|aui
operator|->
name|aui_model
condition|)
name|aui
operator|->
name|aui_chipset
operator|=
name|auc
expr_stmt|;
if|if
condition|(
name|aui
operator|->
name|aui_chipset
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s() called for non-au88x0 device"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* enable pio, mmio, bus-mastering dma */
name|config
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|config
operator||=
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|config
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* register mapping */
name|config
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|&
name|PCIM_CMD_MEMEN
condition|)
block|{
comment|/* try memory-mapped I/O */
name|aui
operator|->
name|aui_regid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|aui
operator|->
name|aui_regtype
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|aui
operator|->
name|aui_reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_regtype
argument_list|,
operator|&
name|aui
operator|->
name|aui_regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aui
operator|->
name|aui_reg
operator|==
name|NULL
operator|&&
operator|(
name|config
operator|&
name|PCIM_CMD_PORTEN
operator|)
condition|)
block|{
comment|/* fall back on port I/O */
name|aui
operator|->
name|aui_regid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|aui
operator|->
name|aui_regtype
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|aui
operator|->
name|aui_reg
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_regtype
argument_list|,
operator|&
name|aui
operator|->
name|aui_regid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aui
operator|->
name|aui_reg
operator|==
name|NULL
condition|)
block|{
comment|/* both mmio and pio failed... */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to map registers\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|aui
operator|->
name|aui_spct
operator|=
name|rman_get_bustag
argument_list|(
name|aui
operator|->
name|aui_reg
argument_list|)
expr_stmt|;
name|aui
operator|->
name|aui_spch
operator|=
name|rman_get_bushandle
argument_list|(
name|aui
operator|->
name|aui_reg
argument_list|)
expr_stmt|;
comment|/* IRQ mapping */
name|aui
operator|->
name|aui_irqid
operator|=
literal|0
expr_stmt|;
name|aui
operator|->
name|aui_irqtype
operator|=
name|SYS_RES_IRQ
expr_stmt|;
name|aui
operator|->
name|aui_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_irqtype
argument_list|,
operator|&
name|aui
operator|->
name|aui_irqid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aui
operator|->
name|aui_irq
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to map IRQ\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* install interrupt handler */
name|error
operator|=
name|snd_setup_intr
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_irq
argument_list|,
literal|0
argument_list|,
name|au88x0_intr
argument_list|,
name|aui
argument_list|,
operator|&
name|aui
operator|->
name|aui_irqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to install interrupt handler\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* DMA mapping */
name|aui
operator|->
name|aui_bufsize
operator|=
name|pcm_getbuffersize
argument_list|(
name|dev
argument_list|,
name|AU88X0_BUFSIZE_MIN
argument_list|,
name|AU88X0_BUFSIZE_DFLT
argument_list|,
name|AU88X0_BUFSIZE_MAX
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
comment|/* 16-bit alignment, no boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restrict to 4GB */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* no filter */
name|aui
operator|->
name|aui_bufsize
argument_list|,
literal|1
argument_list|,
name|aui
operator|->
name|aui_bufsize
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|aui
operator|->
name|aui_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* initialize the hardware */
name|au88x0_init
argument_list|(
name|aui
argument_list|)
expr_stmt|;
comment|/* initialize the ac97 codec and mixer */
if|if
condition|(
operator|(
name|aui
operator|->
name|aui_ac97i
operator|=
name|AC97_CREATE
argument_list|(
name|dev
argument_list|,
name|aui
argument_list|,
name|au88x0_ac97
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize ac97 codec\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|mixer_init
argument_list|(
name|dev
argument_list|,
name|ac97_getmixerclass
argument_list|()
argument_list|,
name|aui
operator|->
name|aui_ac97i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize ac97 mixer\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* register with the pcm driver */
if|if
condition|(
name|pcm_register
argument_list|(
name|dev
argument_list|,
name|aui
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|pcm_addchan
argument_list|(
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|au88x0_chan_class
argument_list|,
name|aui
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|pcm_addchan(dev, PCMDIR_REC,&au88x0_chan_class, aui);
endif|#
directive|endif
name|au88x0_set_status
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|aui
operator|->
name|aui_ac97i
operator|!=
name|NULL
condition|)
name|ac97_destroy
argument_list|(
name|aui
operator|->
name|aui_ac97i
argument_list|)
expr_stmt|;
if|if
condition|(
name|aui
operator|->
name|aui_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|aui
operator|->
name|aui_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|aui
operator|->
name|aui_irqh
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_irq
argument_list|,
name|aui
operator|->
name|aui_irqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|aui
operator|->
name|aui_irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_irqtype
argument_list|,
name|aui
operator|->
name|aui_irqid
argument_list|,
name|aui
operator|->
name|aui_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|aui
operator|->
name|aui_reg
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_regtype
argument_list|,
name|aui
operator|->
name|aui_regid
argument_list|,
name|aui
operator|->
name|aui_reg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aui
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach  */
end_comment

begin_function
specifier|static
name|int
name|au88x0_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|au88x0_info
modifier|*
name|aui
decl_stmt|;
name|int
name|error
decl_stmt|;
name|aui
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* release resources in reverse order */
name|bus_dma_tag_destroy
argument_list|(
name|aui
operator|->
name|aui_dmat
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_irq
argument_list|,
name|aui
operator|->
name|aui_irqh
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_irqtype
argument_list|,
name|aui
operator|->
name|aui_irqid
argument_list|,
name|aui
operator|->
name|aui_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|aui
operator|->
name|aui_regtype
argument_list|,
name|aui
operator|->
name|aui_regid
argument_list|,
name|aui
operator|->
name|aui_reg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aui
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Driver glue  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|au88x0_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|au88x0_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|au88x0_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|au88x0_pci_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|au88x0_driver
init|=
block|{
literal|"pcm"
block|,
name|au88x0_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_au88x0
argument_list|,
name|pci
argument_list|,
name|au88x0_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_au88x0
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_au88x0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

