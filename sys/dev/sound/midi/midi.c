begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Mathew Kanner  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Lennart Augustsson (augustss@netbsd.org).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*   * Parts of this file started out as NetBSD: midi.c 1.31   * They are mostly gone.  Still the most obvious will be the state   * machine midi_in   */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_include
include|#
directive|include
file|"mpu_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/midiq.h>
end_include

begin_include
include|#
directive|include
file|"synth_if.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MIDI
argument_list|,
literal|"midi buffers"
argument_list|,
literal|"Midi data allocation area"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PCMMKMINOR
parameter_list|(
name|u
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|)
value|((((c)& 0xff)<< 16) | (((u)& 0x0f)<< 4) | ((d)& 0x0f))
end_define

begin_define
define|#
directive|define
name|MIDIMKMINOR
parameter_list|(
name|u
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|)
value|PCMMKMINOR(u, d, c)
end_define

begin_define
define|#
directive|define
name|MIDI_DEV_RAW
value|2
end_define

begin_define
define|#
directive|define
name|MIDI_DEV_MIDICTL
value|12
end_define

begin_enum
enum|enum
name|midi_states
block|{
name|MIDI_IN_START
block|,
name|MIDI_IN_SYSEX
block|,
name|MIDI_IN_DATA
block|}
enum|;
end_enum

begin_comment
comment|/*  * The MPU interface current has init() uninit() inqsize(( outqsize()  * callback() : fiddle with the tx|rx status.  */
end_comment

begin_include
include|#
directive|include
file|"mpu_if.h"
end_include

begin_comment
comment|/*  * /dev/rmidi	Structure definitions  */
end_comment

begin_define
define|#
directive|define
name|MIDI_NAMELEN
value|16
end_define

begin_struct
struct|struct
name|snd_midi
block|{
name|KOBJ_FIELDS
expr_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
comment|/* Protects all but queues */
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* Should only be used in midistat */
name|int
name|channel
decl_stmt|;
comment|/* Should only be used in midistat */
name|int
name|busy
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* File flags */
name|char
name|name
index|[
name|MIDI_NAMELEN
index|]
decl_stmt|;
name|struct
name|mtx
name|qlock
decl_stmt|;
comment|/* Protects inq, outq and flags */
name|MIDIQ_HEAD
argument_list|(
argument_list|,
argument|char
argument_list|)
name|inq
operator|,
name|outq
expr_stmt|;
name|int
name|rchan
decl_stmt|,
name|wchan
decl_stmt|;
name|struct
name|selinfo
name|rsel
decl_stmt|,
name|wsel
decl_stmt|;
name|int
name|hiwat
decl_stmt|;
comment|/* QLEN(outq)>High-water -> disable writes 		     * from userland */
name|enum
name|midi_states
name|inq_state
decl_stmt|;
name|int
name|inq_status
decl_stmt|,
name|inq_left
decl_stmt|;
comment|/* Variables for the state 			     * machine in Midi_in, this 			     * is to provide that signals 			     * only get issued only 			     * complete command packets. */
name|struct
name|proc
modifier|*
name|async
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|synth_midi
modifier|*
name|synth
decl_stmt|;
name|int
name|synth_flags
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|snd_midi
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|synth_midi
block|{
name|KOBJ_FIELDS
expr_stmt|;
name|struct
name|snd_midi
modifier|*
name|m
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|synth_open_t
name|midisynth_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_close_t
name|midisynth_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_writeraw_t
name|midisynth_writeraw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_killnote_t
name|midisynth_killnote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_startnote_t
name|midisynth_startnote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_setinstr_t
name|midisynth_setinstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_alloc_t
name|midisynth_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_controller_t
name|midisynth_controller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|synth_bender_t
name|midisynth_bender
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|midisynth_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|synth_open
argument_list|,
name|midisynth_open
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_close
argument_list|,
name|midisynth_close
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_writeraw
argument_list|,
name|midisynth_writeraw
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_setinstr
argument_list|,
name|midisynth_setinstr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_startnote
argument_list|,
name|midisynth_startnote
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_killnote
argument_list|,
name|midisynth_killnote
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_alloc
argument_list|,
name|midisynth_alloc
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_controller
argument_list|,
name|midisynth_controller
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|synth_bender
argument_list|,
name|midisynth_bender
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS
argument_list|(
name|midisynth
argument_list|,
name|midisynth_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Module Exports& Interface  *   * struct midi_chan *midi_init(MPU_CLASS cls, int unit, int chan) int  * midi_uninit(struct snd_midi *) 0 == no error EBUSY or other error int  * Midi_in(struct midi_chan *, char *buf, int count) int Midi_out(struct  * midi_chan *, char *buf, int count)  *   * midi_{in,out} return actual size transfered  *   */
end_comment

begin_comment
comment|/*  * midi_devs tailq, holder of all rmidi instances protected by midistat_lock  */
end_comment

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|snd_midi
argument_list|)
end_macro

begin_expr_stmt
name|midi_devs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * /dev/midistat variables and declarations, protected by midistat_lock  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|midistat_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midistat_isopen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbuf
name|midistat_sbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midistat_bufptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|midistat_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * /dev/midistat	dev_t declarations  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|midistat_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|midistat_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|midistat_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|midistat_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|midistat_open
block|,
operator|.
name|d_close
operator|=
name|midistat_close
block|,
operator|.
name|d_read
operator|=
name|midistat_read
block|,
operator|.
name|d_name
operator|=
literal|"midistat"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * /dev/rmidi dev_t declarations, struct variable access is protected by  * locks contained within the structure.  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|midi_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|midi_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|midi_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|midi_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|midi_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|midi_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|midi_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|midi_open
block|,
operator|.
name|d_close
operator|=
name|midi_close
block|,
operator|.
name|d_read
operator|=
name|midi_read
block|,
operator|.
name|d_write
operator|=
name|midi_write
block|,
operator|.
name|d_ioctl
operator|=
name|midi_ioctl
block|,
operator|.
name|d_poll
operator|=
name|midi_poll
block|,
operator|.
name|d_name
operator|=
literal|"rmidi"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes of library functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|midi_destroy
parameter_list|(
name|struct
name|snd_midi
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|midistat_prepare
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|midi_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|midi_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Misc declr.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|midi
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Midi driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_midi
argument_list|,
name|OID_AUTO
argument_list|,
name|stat
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Status device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|midi_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: should this be moved into debug.midi? */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_midi
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|midi_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|midi_dumpraw
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_midi
argument_list|,
name|OID_AUTO
argument_list|,
name|dumpraw
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|midi_dumpraw
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|midi_instroff
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_midi
argument_list|,
name|OID_AUTO
argument_list|,
name|instroff
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|midi_instroff
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|midistat_verbose
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_midi_stat
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|midistat_verbose
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MIDI_DEBUG
parameter_list|(
name|l
parameter_list|,
name|a
parameter_list|)
value|if(midi_debug>=l) a
end_define

begin_comment
comment|/*  * CODE START  */
end_comment

begin_comment
comment|/*  * Register a new rmidi device. cls midi_if interface unit == 0 means  * auto-assign new unit number unit != 0 already assigned a unit number, eg.  * not the first channel provided by this device. channel,	sub-unit  * cookie is passed back on MPU calls Typical device drivers will call with  * unit=0, channel=1..(number of channels) and cookie=soft_c and won't care  * what unit number is used.  *   * It is an error to call midi_init with an already used unit/channel combo.  *   * Returns NULL on error  *   */
end_comment

begin_function
name|struct
name|snd_midi
modifier|*
name|midi_init
parameter_list|(
name|kobj_class_t
name|cls
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|channel
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|inqsize
decl_stmt|,
name|outqsize
decl_stmt|;
name|MIDI_TYPE
modifier|*
name|buf
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midiinit: unit %d/%d.\n"
argument_list|,
name|unit
argument_list|,
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Protect against call with existing unit/channel or auto-allocate a 	 * new unit number. 	 */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&midi_devs
argument_list|,
argument|link
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|unit
operator|==
name|unit
operator|&&
name|m
operator|->
name|channel
operator|==
name|channel
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
block|}
else|else
block|{
comment|/* 	 * Find a better unit number 	 */
if|if
condition|(
name|m
operator|->
name|unit
operator|>
name|i
condition|)
name|i
operator|=
name|m
operator|->
name|unit
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|unit
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midiinit #2: unit %d/%d.\n"
argument_list|,
name|unit
argument_list|,
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|,
name|M_MIDI
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|err0
goto|;
name|m
operator|->
name|synth
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
operator|->
name|synth
argument_list|)
argument_list|,
name|M_MIDI
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|kobj_init
argument_list|(
operator|(
name|kobj_t
operator|)
name|m
operator|->
name|synth
argument_list|,
operator|&
name|midisynth_class
argument_list|)
expr_stmt|;
name|m
operator|->
name|synth
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|kobj_init
argument_list|(
operator|(
name|kobj_t
operator|)
name|m
argument_list|,
name|cls
argument_list|)
expr_stmt|;
name|inqsize
operator|=
name|MPU_INQSIZE
argument_list|(
name|m
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|outqsize
operator|=
name|MPU_OUTQSIZE
argument_list|(
name|m
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midiinit queues %d/%d.\n"
argument_list|,
name|inqsize
argument_list|,
name|outqsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inqsize
operator|&&
operator|!
name|outqsize
condition|)
goto|goto
name|err1
goto|;
name|mtx_init
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|,
literal|"raw midi"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|,
literal|"q raw midi"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|inqsize
condition|)
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MIDI_TYPE
argument_list|)
operator|*
name|inqsize
argument_list|,
name|M_MIDI
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|MIDIQ_INIT
argument_list|(
name|m
operator|->
name|inq
argument_list|,
name|buf
argument_list|,
name|inqsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|outqsize
condition|)
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MIDI_TYPE
argument_list|)
operator|*
name|outqsize
argument_list|,
name|M_MIDI
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|hiwat
operator|=
name|outqsize
operator|/
literal|2
expr_stmt|;
name|MIDIQ_INIT
argument_list|(
name|m
operator|->
name|outq
argument_list|,
name|buf
argument_list|,
name|outqsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inqsize
operator|&&
operator|!
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|inq
argument_list|)
operator|)
operator|||
operator|(
name|outqsize
operator|&&
operator|!
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|)
condition|)
goto|goto
name|err2
goto|;
name|m
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|m
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|m
operator|->
name|cookie
operator|=
name|cookie
expr_stmt|;
if|if
condition|(
name|MPU_INIT
argument_list|(
name|m
argument_list|,
name|cookie
argument_list|)
condition|)
goto|goto
name|err2
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|midi_devs
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|m
operator|->
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|midi_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
name|unit
argument_list|,
name|MIDI_DEV_RAW
argument_list|,
name|channel
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"midi%d.%d"
argument_list|,
name|unit
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|m
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|m
expr_stmt|;
return|return
name|m
return|;
name|err2
label|:
name|mtx_destroy
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|inq
argument_list|)
condition|)
name|free
argument_list|(
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|inq
argument_list|)
argument_list|,
name|M_MIDI
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|outq
argument_list|)
condition|)
name|free
argument_list|(
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|,
name|M_MIDI
argument_list|)
expr_stmt|;
name|err1
label|:
name|free
argument_list|(
name|m
argument_list|,
name|M_MIDI
argument_list|)
expr_stmt|;
name|err0
label|:
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midi_init ended in error\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * midi_uninit does not call MIDI_UNINIT, as since this is the implementors  * entry point. midi_unint if fact, does not send any methods. A call to  * midi_uninit is a defacto promise that you won't manipulate ch anymore  *   */
end_comment

begin_function
name|int
name|midi_uninit
parameter_list|(
name|struct
name|snd_midi
modifier|*
name|m
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|busy
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|rchan
operator|||
name|m
operator|->
name|wchan
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|m
operator|->
name|rchan
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|m
operator|->
name|rchan
argument_list|)
expr_stmt|;
name|m
operator|->
name|rchan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|wchan
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|m
operator|->
name|wchan
argument_list|)
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|err
operator|=
name|midi_destroy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
goto|goto
name|exit
goto|;
name|err
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|exit
label|:
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * midi_in: process all data until the queue is full, then discards the rest.  * Since midi_in is a state machine, data discards can cause it to get out of  * whack.  Process as much as possible.  It calls, wakeup, selnotify and  * psignal at most once.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|midi_lengths
index|[]
init|=
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/* Number of bytes in a MIDI command */
end_comment

begin_define
define|#
directive|define
name|MIDI_LENGTH
parameter_list|(
name|d
parameter_list|)
value|(midi_lengths[((d)>> 4)& 7])
end_define

begin_define
define|#
directive|define
name|MIDI_ACK
value|0xfe
end_define

begin_define
define|#
directive|define
name|MIDI_IS_STATUS
parameter_list|(
name|d
parameter_list|)
value|((d)>= 0x80)
end_define

begin_define
define|#
directive|define
name|MIDI_IS_COMMON
parameter_list|(
name|d
parameter_list|)
value|((d)>= 0xf0)
end_define

begin_define
define|#
directive|define
name|MIDI_SYSEX_START
value|0xF0
end_define

begin_define
define|#
directive|define
name|MIDI_SYSEX_END
value|0xF7
end_define

begin_function
name|int
name|midi_in
parameter_list|(
name|struct
name|snd_midi
modifier|*
name|m
parameter_list|,
name|MIDI_TYPE
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* int             i, sig, enq; */
name|int
name|used
decl_stmt|;
comment|/* MIDI_TYPE       data; */
name|MIDI_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"midi_in: m=%p size=%d\n"
argument_list|,
name|m
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * XXX: locking flub  */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_RX
operator|)
condition|)
return|return
name|size
return|;
name|used
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Don't bother queuing if not in read mode.  Discard everything and 	 * return size so the caller doesn't freak out. 	 */
block|if (!(m->flags& M_RX)) 	    return size;  	for (i = sig = 0; i< size; i++) {  	    data = buf[i]; 	    enq = 0; 	    if (data == MIDI_ACK) 		continue;  	    switch (m->inq_state) { 	    case MIDI_IN_START: 		if (MIDI_IS_STATUS(data)) { 		    switch (data) { 		    case 0xf0:
comment|/* Sysex */
block|m->inq_state = MIDI_IN_SYSEX; 			break; 		    case 0xf1:
comment|/* MTC quarter frame */
block|case 0xf3:
comment|/* Song select */
block|m->inq_state = MIDI_IN_DATA; 			enq = 1; 			m->inq_left = 1; 			break; 		    case 0xf2:
comment|/* Song position pointer */
block|m->inq_state = MIDI_IN_DATA; 			enq = 1; 			m->inq_left = 2; 			break; 		    default: 			if (MIDI_IS_COMMON(data)) { 			    enq = 1; 			    sig = 1; 			} else { 			    m->inq_state = MIDI_IN_DATA; 			    enq = 1; 			    m->inq_status = data; 			    m->inq_left = MIDI_LENGTH(data); 			} 			break; 		    } 		} else if (MIDI_IS_STATUS(m->inq_status)) { 		    m->inq_state = MIDI_IN_DATA; 		    if (!MIDIQ_FULL(m->inq)) { 			used++; 			MIDIQ_ENQ(m->inq,&m->inq_status, 1); 		    } 		    enq = 1; 		    m->inq_left = MIDI_LENGTH(m->inq_status) - 1; 		} 		break;
comment|/* 		 * End of case MIDI_IN_START: 		 */
block|case MIDI_IN_DATA: 		enq = 1; 		if (--m->inq_left<= 0) 		    sig = 1;
comment|/* deliver data */
block|break; 	    case MIDI_IN_SYSEX: 		if (data == MIDI_SYSEX_END) 		    m->inq_state = MIDI_IN_START; 		break; 	    }  	    if (enq) 		if (!MIDIQ_FULL(m->inq)) { 		    MIDIQ_ENQ(m->inq,&data, 1); 		    used++; 		}
comment|/* 	     * End of the state machines main "for loop" 	     */
block|} 	if (sig) {
endif|#
directive|endif
name|MIDI_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"midi_in: len %jd avail %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_LEN
argument_list|(
name|m
operator|->
name|inq
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|inq
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|inq
argument_list|)
operator|>
name|size
condition|)
block|{
name|used
operator|=
name|size
expr_stmt|;
name|MIDIQ_ENQ
argument_list|(
name|m
operator|->
name|inq
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MIDI_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"midi_in: Discarding data qu\n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|m
operator|->
name|rchan
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|m
operator|->
name|rchan
argument_list|)
expr_stmt|;
name|m
operator|->
name|rchan
operator|=
literal|0
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|m
operator|->
name|rsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|async
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|m
operator|->
name|async
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|m
operator|->
name|async
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|m
operator|->
name|async
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
return|return
name|used
return|;
block|}
end_function

begin_comment
comment|/*  * midi_out: The only clearer of the M_TXEN flag.  */
end_comment

begin_function
name|int
name|midi_out
parameter_list|(
name|struct
name|snd_midi
modifier|*
name|m
parameter_list|,
name|MIDI_TYPE
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|used
decl_stmt|;
comment|/*  * XXX: locking flub  */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TXEN
operator|)
condition|)
return|return
literal|0
return|;
name|MIDI_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"midi_out: %p\n"
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|used
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|MIDIQ_LEN
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"midi_out: used %d\n"
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
condition|)
name|MIDIQ_DEQ
argument_list|(
name|m
operator|->
name|outq
argument_list|,
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIDIQ_EMPTY
argument_list|(
name|m
operator|->
name|outq
argument_list|)
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|M_TXEN
expr_stmt|;
name|MPU_CALLBACKP
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|&&
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|>
name|m
operator|->
name|hiwat
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|wchan
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|m
operator|->
name|wchan
argument_list|)
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|0
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|m
operator|->
name|wsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|async
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|m
operator|->
name|async
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|m
operator|->
name|async
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|m
operator|->
name|async
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
return|return
name|used
return|;
block|}
end_function

begin_comment
comment|/*  * /dev/rmidi#.#	device access functions  */
end_comment

begin_function
name|int
name|midi_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midiopen %p %s %s\n"
argument_list|,
name|td
argument_list|,
name|flags
operator|&
name|FREAD
condition|?
literal|"M_RX"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|FWRITE
condition|?
literal|"M_TX"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
if|if
condition|(
name|MIDIQ_SIZE
argument_list|(
name|m
operator|->
name|inq
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|M_RX
condition|)
name|retval
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
if|if
condition|(
name|MIDIQ_SIZE
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|M_TX
condition|)
name|retval
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err
goto|;
block|}
name|m
operator|->
name|busy
operator|++
expr_stmt|;
name|m
operator|->
name|rchan
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|async
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|M_RX
operator||
name|M_RXEN
expr_stmt|;
comment|/* 	     * Only clear the inq, the outq might still have data to drain from 	     * a previous session 	     */
name|MIDIQ_CLEAR
argument_list|(
name|m
operator|->
name|inq
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
name|m
operator|->
name|flags
operator||=
name|M_TX
expr_stmt|;
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"midi_open: opened.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|err
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|midi_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|oldflags
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midi_close %p %s %s\n"
argument_list|,
name|td
argument_list|,
name|flags
operator|&
name|FREAD
condition|?
literal|"M_RX"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|FWRITE
condition|?
literal|"M_TX"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FREAD
operator|&&
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_RX
operator|)
operator|)
operator|||
operator|(
name|flags
operator|&
name|FWRITE
operator|&&
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TX
operator|)
operator|)
condition|)
block|{
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|m
operator|->
name|busy
operator|--
expr_stmt|;
name|oldflags
operator|=
name|m
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
name|m
operator|->
name|flags
operator|&=
operator|~
operator|(
name|M_RX
operator||
name|M_RXEN
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
name|m
operator|->
name|flags
operator|&=
operator|~
name|M_TX
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|M_TXEN
operator||
name|M_RXEN
operator|)
operator|)
operator|!=
operator|(
name|oldflags
operator|&
operator|(
name|M_RXEN
operator||
name|M_TXEN
operator|)
operator|)
condition|)
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midi_close: closed, busy = %d.\n"
argument_list|,
name|m
operator|->
name|busy
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|err
label|:
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: midi_read, per oss programmer's guide pg. 42 should return as soon as data is available.  */
end_comment

begin_function
name|int
name|midi_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
define|#
directive|define
name|MIDI_RSIZE
value|32
name|struct
name|snd_midi
modifier|*
name|m
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|used
decl_stmt|;
name|char
name|buf
index|[
name|MIDI_RSIZE
index|]
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"midiread: count=%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|err0
goto|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_RX
operator|)
condition|)
goto|goto
name|err1
goto|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|MIDIQ_EMPTY
argument_list|(
name|m
operator|->
name|inq
argument_list|)
condition|)
block|{
name|retval
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|ioflag
operator|&
name|O_NONBLOCK
condition|)
goto|goto
name|err1
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|m
operator|->
name|rchan
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|msleep
argument_list|(
operator|&
name|m
operator|->
name|rchan
argument_list|,
operator|&
name|m
operator|->
name|qlock
argument_list|,
name|PCATCH
operator||
name|PDROP
argument_list|,
literal|"midi RX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We slept, maybe things have changed since last 		 * dying check 		 */
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
goto|goto
name|err0
goto|;
if|if
condition|(
name|m
operator|!=
name|i_dev
operator|->
name|si_drv1
condition|)
name|retval
operator|=
name|ENXIO
expr_stmt|;
comment|/* if (retval&& retval != ERESTART) */
if|if
condition|(
name|retval
condition|)
goto|goto
name|err0
goto|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|m
operator|->
name|rchan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|busy
condition|)
goto|goto
name|err1
goto|;
block|}
name|MIDI_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"midi_read start\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * At this point, it is certain that m->inq has data 	     */
name|used
operator|=
name|MIN
argument_list|(
name|MIDIQ_LEN
argument_list|(
name|m
operator|->
name|inq
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|used
operator|=
name|MIN
argument_list|(
name|used
argument_list|,
name|MIDI_RSIZE
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"midiread: uiomove cc=%d\n"
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|MIDIQ_DEQ
argument_list|(
name|m
operator|->
name|inq
argument_list|,
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|retval
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|used
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err1
goto|;
block|}
comment|/* 	 * If we Made it here then transfer is good 	 */
name|retval
operator|=
literal|0
expr_stmt|;
name|err1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err0
label|:
name|MIDI_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"midi_read: ret %d\n"
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * midi_write: The only setter of M_TXEN  */
end_comment

begin_function
name|int
name|midi_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
define|#
directive|define
name|MIDI_WSIZE
value|32
name|struct
name|snd_midi
modifier|*
name|m
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|used
decl_stmt|;
name|char
name|buf
index|[
name|MIDI_WSIZE
index|]
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"midi_write\n"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|err0
goto|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TX
operator|)
condition|)
goto|goto
name|err1
goto|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|ioflag
operator|&
name|O_NONBLOCK
condition|)
goto|goto
name|err1
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|1
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"midi_write msleep\n"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|msleep
argument_list|(
operator|&
name|m
operator|->
name|wchan
argument_list|,
operator|&
name|m
operator|->
name|qlock
argument_list|,
name|PCATCH
operator||
name|PDROP
argument_list|,
literal|"midi TX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We slept, maybe things have changed since last 		 * dying check 		 */
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
goto|goto
name|err0
goto|;
if|if
condition|(
name|m
operator|!=
name|i_dev
operator|->
name|si_drv1
condition|)
name|retval
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err0
goto|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|busy
condition|)
goto|goto
name|err1
goto|;
block|}
comment|/* 	     * We are certain than data can be placed on the queue 	     */
name|used
operator|=
name|MIN
argument_list|(
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|used
operator|=
name|MIN
argument_list|(
name|used
argument_list|,
name|MIDI_WSIZE
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"midiout: resid %d len %jd avail %jd\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_LEN
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"midi_write: uiomove cc=%d\n"
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|used
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err1
goto|;
name|MIDIQ_ENQ
argument_list|(
name|m
operator|->
name|outq
argument_list|,
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* 	     * Inform the bottom half that data can be written 	     */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TXEN
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|M_TXEN
expr_stmt|;
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we Made it here then transfer is good 	 */
name|retval
operator|=
literal|0
expr_stmt|;
name|err1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err0
label|:
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|midi_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
name|int
name|midi_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|revents
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|revents
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
operator|!
name|MIDIQ_EMPTY
argument_list|(
name|m
operator|->
name|inq
argument_list|)
condition|)
name|events
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
if|if
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|<
name|m
operator|->
name|hiwat
condition|)
name|events
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|m
operator|->
name|rsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|m
operator|->
name|wsel
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * /dev/midistat device functions  *   */
end_comment

begin_function
specifier|static
name|int
name|midistat_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midistat_open\n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|midistat_isopen
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|midistat_isopen
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_new
argument_list|(
operator|&
name|midistat_sbuf
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
name|SBUF_AUTOEXTEND
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|midistat_bufptr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|(
name|midistat_prepare
argument_list|(
operator|&
name|midistat_sbuf
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
name|ENOMEM
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
name|midistat_isopen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midistat_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midistat_close\n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|midistat_isopen
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|EBADF
return|;
block|}
name|sbuf_delete
argument_list|(
operator|&
name|midistat_sbuf
argument_list|)
expr_stmt|;
name|midistat_isopen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midistat_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|l
decl_stmt|,
name|err
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"midistat_read\n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|midistat_isopen
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|EBADF
return|;
block|}
name|l
operator|=
name|min
argument_list|(
name|buf
operator|->
name|uio_resid
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|midistat_sbuf
argument_list|)
operator|-
name|midistat_bufptr
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
name|sbuf_data
argument_list|(
operator|&
name|midistat_sbuf
argument_list|)
operator|+
name|midistat_bufptr
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|l
operator|=
literal|0
expr_stmt|;
name|midistat_bufptr
operator|+=
name|l
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Module library functions  */
end_comment

begin_function
specifier|static
name|int
name|midistat_prepare
parameter_list|(
name|struct
name|sbuf
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|midistat_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"FreeBSD Midi Driver (midi2)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|midi_devs
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"No devices installed.\n"
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sbuf_len
argument_list|(
name|s
argument_list|)
return|;
block|}
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"Installed devices:\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&midi_devs
argument_list|,
argument|link
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s [%d/%d:%s]"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|unit
argument_list|,
name|m
operator|->
name|channel
argument_list|,
name|MPU_PROVIDER
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"%s"
argument_list|,
name|MPU_DESCR
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|midistat_verbose
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|s
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sbuf_len
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Convert IOCTL command to string for debugging  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|midi_cmdname
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|cmd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
modifier|*
name|tab
struct|,
name|cmdtab_midiioctl
index|[]
init|=
block|{
define|#
directive|define
name|A
parameter_list|(
name|x
parameter_list|)
value|{x, ## x}
comment|/* 	     * Once we have some real IOCTLs define, the following will 	     * be relavant. 	     *  	     * A(SNDCTL_MIDI_PRETIME), A(SNDCTL_MIDI_MPUMODE), 	     * A(SNDCTL_MIDI_MPUCMD), A(SNDCTL_SYNTH_INFO), 	     * A(SNDCTL_MIDI_INFO), A(SNDCTL_SYNTH_MEMAVL), 	     * A(SNDCTL_FM_LOAD_INSTR), A(SNDCTL_FM_4OP_ENABLE), 	     * A(MIOSPASSTHRU), A(MIOGPASSTHRU), A(AIONWRITE), 	     * A(AIOGSIZE), A(AIOSSIZE), A(AIOGFMT), A(AIOSFMT), 	     * A(AIOGMIX), A(AIOSMIX), A(AIOSTOP), A(AIOSYNC), 	     * A(AIOGCAP), 	     */
undef|#
directive|undef
name|A
block|{
operator|-
literal|1
block|,
literal|"unknown"
block|}
block|, 	}
struct|;
for|for
control|(
name|tab
operator|=
name|cmdtab_midiioctl
init|;
name|tab
operator|->
name|cmd
operator|!=
name|cmd
operator|&&
name|tab
operator|->
name|cmd
operator|!=
operator|-
literal|1
condition|;
name|tab
operator|++
control|)
empty_stmt|;
return|return
name|tab
operator|->
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notdef */
end_comment

begin_comment
comment|/*  * midisynth  */
end_comment

begin_function
name|int
name|midisynth_open
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
init|=
operator|(
operator|(
expr|struct
name|synth_midi
operator|*
operator|)
name|n
operator|)
operator|->
name|m
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midisynth_open %s %s\n"
argument_list|,
name|flags
operator|&
name|FREAD
condition|?
literal|"M_RX"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|FWRITE
condition|?
literal|"M_TX"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
if|if
condition|(
name|MIDIQ_SIZE
argument_list|(
name|m
operator|->
name|inq
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|M_RX
condition|)
name|retval
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
if|if
condition|(
name|MIDIQ_SIZE
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|ENXIO
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|M_TX
condition|)
name|retval
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err
goto|;
block|}
name|m
operator|->
name|busy
operator|++
expr_stmt|;
comment|/* 	 * TODO: Consider m->async = 0; 	 */
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|M_RX
operator||
name|M_RXEN
expr_stmt|;
comment|/* 	     * Only clear the inq, the outq might still have data to drain from 	     * a previous session 	     */
name|MIDIQ_CLEAR
argument_list|(
name|m
operator|->
name|inq
argument_list|)
expr_stmt|;
name|m
operator|->
name|rchan
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|M_TX
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|synth_flags
operator|=
name|flags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
expr_stmt|;
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
name|err
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"midisynth_open: return %d.\n"
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|midisynth_close
parameter_list|(
name|void
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
init|=
operator|(
operator|(
expr|struct
name|synth_midi
operator|*
operator|)
name|n
operator|)
operator|->
name|m
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|oldflags
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midisynth_close %s %s\n"
argument_list|,
name|m
operator|->
name|synth_flags
operator|&
name|FREAD
condition|?
literal|"M_RX"
else|:
literal|""
argument_list|,
name|m
operator|->
name|synth_flags
operator|&
name|FWRITE
condition|?
literal|"M_TX"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|synth_flags
operator|&
name|FREAD
operator|&&
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_RX
operator|)
operator|)
operator|||
operator|(
name|m
operator|->
name|synth_flags
operator|&
name|FWRITE
operator|&&
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TX
operator|)
operator|)
condition|)
block|{
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|m
operator|->
name|busy
operator|--
expr_stmt|;
name|oldflags
operator|=
name|m
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|synth_flags
operator|&
name|FREAD
condition|)
name|m
operator|->
name|flags
operator|&=
operator|~
operator|(
name|M_RX
operator||
name|M_RXEN
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|synth_flags
operator|&
name|FWRITE
condition|)
name|m
operator|->
name|flags
operator|&=
operator|~
name|M_TX
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|M_TXEN
operator||
name|M_RXEN
operator|)
operator|)
operator|!=
operator|(
name|oldflags
operator|&
operator|(
name|M_RXEN
operator||
name|M_TXEN
operator|)
operator|)
condition|)
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midi_close: closed, busy = %d.\n"
argument_list|,
name|m
operator|->
name|busy
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|err
label|:
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Always blocking.  */
end_comment

begin_function
name|int
name|midisynth_writeraw
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
init|=
operator|(
operator|(
expr|struct
name|synth_midi
operator|*
operator|)
name|n
operator|)
operator|->
name|m
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|used
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"midisynth_writeraw\n"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TX
operator|)
condition|)
goto|goto
name|err1
goto|;
if|if
condition|(
name|midi_dumpraw
condition|)
name|printf
argument_list|(
literal|"midi dump: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TXEN
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|M_TXEN
expr_stmt|;
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|1
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"midisynth_writeraw msleep\n"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|msleep
argument_list|(
operator|&
name|m
operator|->
name|wchan
argument_list|,
operator|&
name|m
operator|->
name|qlock
argument_list|,
name|PCATCH
operator||
name|PDROP
argument_list|,
literal|"midi TX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We slept, maybe things have changed since last 		 * dying check 		 */
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
goto|goto
name|err0
goto|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err0
goto|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|m
operator|->
name|wchan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|busy
condition|)
goto|goto
name|err1
goto|;
block|}
comment|/* 	     * We are certain than data can be placed on the queue 	     */
name|used
operator|=
name|MIN
argument_list|(
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|used
operator|=
name|MIN
argument_list|(
name|used
argument_list|,
name|MIDI_WSIZE
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"midi_synth: resid %zu len %jd avail %jd\n"
argument_list|,
name|len
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_LEN
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_AVAIL
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|midi_dumpraw
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|used
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|MIDIQ_ENQ
argument_list|(
name|m
operator|->
name|outq
argument_list|,
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|len
operator|-=
name|used
expr_stmt|;
comment|/* 	     * Inform the bottom half that data can be written 	     */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
name|M_TXEN
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|M_TXEN
expr_stmt|;
name|MPU_CALLBACK
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|,
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we Made it here then transfer is good 	 */
if|if
condition|(
name|midi_dumpraw
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|err1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|err0
label|:
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midisynth_killnote
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
name|chn
parameter_list|,
name|uint8_t
name|note
parameter_list|,
name|uint8_t
name|vel
parameter_list|)
block|{
name|u_char
name|c
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|note
operator|>
literal|127
operator|||
name|chn
operator|>
literal|15
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vel
operator|>
literal|127
condition|)
name|vel
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|vel
operator|==
literal|64
condition|)
block|{
name|c
index|[
literal|0
index|]
operator|=
literal|0x90
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Note on. */
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|note
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
index|[
literal|0
index|]
operator|=
literal|0x80
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Note off. */
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|note
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|u_char
operator|)
name|vel
expr_stmt|;
block|}
return|return
name|midisynth_writeraw
argument_list|(
name|n
argument_list|,
name|c
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midisynth_setinstr
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
name|chn
parameter_list|,
name|uint16_t
name|instr
parameter_list|)
block|{
name|u_char
name|c
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|instr
operator|>
literal|127
operator|||
name|chn
operator|>
literal|15
condition|)
return|return
name|EINVAL
return|;
name|c
index|[
literal|0
index|]
operator|=
literal|0xc0
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Progamme change. */
name|c
index|[
literal|1
index|]
operator|=
name|instr
operator|+
name|midi_instroff
expr_stmt|;
return|return
name|midisynth_writeraw
argument_list|(
name|n
argument_list|,
name|c
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midisynth_startnote
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
name|chn
parameter_list|,
name|uint8_t
name|note
parameter_list|,
name|uint8_t
name|vel
parameter_list|)
block|{
name|u_char
name|c
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|note
operator|>
literal|127
operator|||
name|chn
operator|>
literal|15
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vel
operator|>
literal|127
condition|)
name|vel
operator|=
literal|127
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
literal|0x90
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Note on. */
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|note
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|u_char
operator|)
name|vel
expr_stmt|;
return|return
name|midisynth_writeraw
argument_list|(
name|n
argument_list|,
name|c
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midisynth_alloc
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
name|chan
parameter_list|,
name|uint8_t
name|note
parameter_list|)
block|{
return|return
name|chan
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midisynth_controller
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
name|chn
parameter_list|,
name|uint8_t
name|ctrlnum
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|u_char
name|c
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|ctrlnum
operator|>
literal|127
operator|||
name|chn
operator|>
literal|15
condition|)
return|return
name|EINVAL
return|;
name|c
index|[
literal|0
index|]
operator|=
literal|0xb0
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Control Message. */
name|c
index|[
literal|1
index|]
operator|=
name|ctrlnum
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
name|val
expr_stmt|;
return|return
name|midisynth_writeraw
argument_list|(
name|n
argument_list|,
name|c
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midisynth_bender
parameter_list|(
name|void
modifier|*
name|n
parameter_list|,
name|uint8_t
name|chn
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|u_char
name|c
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|val
operator|>
literal|16383
operator|||
name|chn
operator|>
literal|15
condition|)
return|return
name|EINVAL
return|;
name|c
index|[
literal|0
index|]
operator|=
literal|0xe0
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* Pitch bend. */
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
name|val
operator|&
literal|0x7f
expr_stmt|;
name|c
index|[
literal|2
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|val
operator|>>
literal|7
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
return|return
name|midisynth_writeraw
argument_list|(
name|n
argument_list|,
name|c
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Single point of midi destructions.  */
end_comment

begin_function
specifier|static
name|int
name|midi_destroy
parameter_list|(
name|struct
name|snd_midi
modifier|*
name|m
parameter_list|,
name|int
name|midiuninit
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|midistat_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"midi_destroy\n"
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|destroy_dev
argument_list|(
name|m
operator|->
name|dev
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|midi_devs
argument_list|,
name|m
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|midiuninit
condition|)
name|MPU_UNINIT
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|cookie
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|inq
argument_list|)
argument_list|,
name|M_MIDI
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|MIDIQ_BUF
argument_list|(
name|m
operator|->
name|outq
argument_list|)
argument_list|,
name|M_MIDI
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|m
operator|->
name|qlock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|,
name|M_MIDI
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Load and unload functions, creates the /dev/midistat device  */
end_comment

begin_function
specifier|static
name|int
name|midi_load
parameter_list|()
block|{
name|mtx_init
argument_list|(
operator|&
name|midistat_lock
argument_list|,
literal|"midistat lock"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|midi_devs
argument_list|)
expr_stmt|;
comment|/* Initialize the queue. */
name|midistat_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|midistat_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
literal|0
argument_list|,
name|MIDI_DEV_MIDICTL
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"midistat"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midi_unload
parameter_list|()
block|{
name|struct
name|snd_midi
modifier|*
name|m
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"midi_unload()\n"
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EBUSY
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|midistat_isopen
condition|)
goto|goto
name|exit0
goto|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&midi_devs
argument_list|,
argument|link
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|busy
condition|)
name|retval
operator|=
name|EBUSY
expr_stmt|;
else|else
name|retval
operator|=
name|midi_destroy
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|exit1
goto|;
block|}
name|destroy_dev
argument_list|(
name|midistat_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Made it here then unload is complete 	 */
name|mtx_destroy
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|exit1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|m
operator|->
name|lock
argument_list|)
expr_stmt|;
name|exit0
label|:
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|MIDI_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"midi_unload: failed\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|seq_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|midi_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|retval
operator|=
name|midi_load
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
name|seq_modevent
argument_list|(
name|mod
argument_list|,
name|type
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|retval
operator|=
name|midi_unload
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|retval
operator|=
name|seq_modevent
argument_list|(
name|mod
argument_list|,
name|type
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|kobj_t
name|midimapper_addseq
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
name|unit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|kobj_t
operator|)
name|arg1
return|;
block|}
end_function

begin_function
name|int
name|midimapper_open
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|snd_midi
modifier|*
name|m
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&midi_devs
argument_list|,
argument|link
argument_list|)
block|{
name|retval
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|midimapper_close
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|kobj_t
name|midimapper_fetch_synth
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|snd_midi
modifier|*
name|m
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&midi_devs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|unit
operator|==
name|retval
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|kobj_t
operator|)
name|m
operator|->
name|synth
return|;
block|}
name|retval
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|midistat_lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|midi
argument_list|,
name|midi_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|midi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

