begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Main midi driver for FreeBSD. This file provides the main  * entry points for probe/attach and all i/o demultiplexing, including  * default routines for generic devices.  *   * (C) 1999 Seigo Tanimura  *   * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS  * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * For each card type a template "mididev_info" structure contains  * all the relevant parameters, both for configuration and runtime.  *  * In this file we build tables of pointers to the descriptors for  * the various supported cards. The generic probe routine scans  * the table(s) looking for a matching entry, then invokes the  * board-specific probe routine. If successful, a pointer to the  * correct mididev_info is stored in mididev_last_probed, for subsequent  * use in the attach routine. The generic attach routine copies  * the template to a permanent descriptor (midi_info[unit] and  * friends), initializes all generic parameters, and calls the  * board-specific attach routine.  *  * On device calls, the generic routines do the checks on unit and  * device parameters, then call the board-specific routines if  * available, or try to perform the task using the default code.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|midi_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|midiopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|midiclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|midiioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|midiread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|midiwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|midipoll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These functions are local. */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|midistat_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|midistat_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|midistat_read
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|midi_initstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|midi_readstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|MIDI_CDEV_MAJOR
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|midi_cdevsw
init|=
block|{
comment|/* open */
name|midiopen
block|,
comment|/* close */
name|midiclose
block|,
comment|/* read */
name|midiread
block|,
comment|/* write */
name|midiwrite
block|,
comment|/* ioctl */
name|midiioctl
block|,
comment|/* poll */
name|midipoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"midi"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * descriptors for active devices. also used as the public softc  * of a device.  */
end_comment

begin_decl_stmt
name|mididev_info
name|midi_info
index|[
name|NMIDI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|nmidi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of midi devices, filled in by the driver */
end_comment

begin_decl_stmt
name|u_long
name|nsynth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of synthesizers, filled in by the driver */
end_comment

begin_comment
comment|/* These make the buffer for /dev/midistat */
end_comment

begin_decl_stmt
specifier|static
name|int
name|midistatbusy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|midistatbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midistatptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the generic init routine  */
end_comment

begin_function
name|int
name|midiinit
parameter_list|(
name|mididev_info
modifier|*
name|d
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|midi_devclass
operator|==
name|NULL
condition|)
block|{
name|midi_devclass
operator|=
name|device_get_devclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|midi_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
literal|0
argument_list|,
name|MIDI_DEV_STATUS
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0444
argument_list|,
literal|"midistat"
argument_list|)
expr_stmt|;
block|}
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|midi_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
name|unit
argument_list|,
name|MIDI_DEV_MIDIN
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"midi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * initialize standard parameters for the device. This can be 	 * overridden by device-specific configurations but better do 	 * here the generic things. 	 */
name|d
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|->
name|softc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|d
operator|->
name|magic
operator|=
name|MAGIC
argument_list|(
name|d
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* debugging... */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a device number, returns  * a pointer to the associated mididev_info struct, and sets the unit  * number.  */
end_comment

begin_function
name|mididev_info
modifier|*
name|get_mididev_info
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|u
decl_stmt|;
name|mididev_info
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
operator|!=
name|MIDI_DEV_MIDIN
condition|)
return|return
name|NULL
return|;
name|u
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
condition|)
operator|*
name|unit
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|u
operator|>=
name|nmidi
operator|+
name|nsynth
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"get_mididev_info: unit %d is not configured.\n"
argument_list|,
name|u
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|d
operator|=
operator|&
name|midi_info
index|[
name|u
index|]
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * here are the switches for the main functions. The switches do  * all necessary checks on the device number to make sure  * that the device is configured. They also provide some default  * functionalities so that device-specific drivers have to deal  * only with special cases.  */
end_comment

begin_function
specifier|static
name|int
name|midiopen
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
return|return
name|midi_open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
case|case
name|MIDI_DEV_STATUS
case|:
return|return
name|midistat_open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiclose
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
return|return
name|midi_close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
case|case
name|MIDI_DEV_STATUS
case|:
return|return
name|midistat_close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiread
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
return|return
name|midi_read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
case|case
name|MIDI_DEV_STATUS
case|:
return|return
name|midistat_read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiwrite
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
return|return
name|midi_write
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
return|return
name|midi_ioctl
argument_list|(
name|i_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midipoll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
return|return
name|midi_poll
argument_list|(
name|i_dev
argument_list|,
name|events
argument_list|,
name|p
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Followings are the generic methods in midi drivers.  */
end_comment

begin_function
name|int
name|midi_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|s
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"open midi%d subdev %d flags 0x%08x mode 0x%08x\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
comment|/* Mark this device busy. */
name|device_busy
argument_list|(
name|d
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_BUSY
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"opl_open: unit %d is busy.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|d
operator|->
name|flags
operator||=
name|MIDI_F_BUSY
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MIDI_F_READING
operator||
name|MIDI_F_WRITING
operator|)
expr_stmt|;
name|d
operator|->
name|fflags
operator|=
name|flags
expr_stmt|;
comment|/* Init the queue. */
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|!=
literal|0
condition|)
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|open
operator|==
name|NULL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|d
operator|->
name|open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midi_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|s
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"close midi%d subdev %d\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
comment|/* Clear the queues. */
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|!=
literal|0
condition|)
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
block|}
comment|/* Stop playing and unmark this device busy. */
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_BUSY
expr_stmt|;
name|d
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|device_unbusy
argument_list|(
name|d
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|close
operator|==
name|NULL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|d
operator|->
name|close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midi_read
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|s
decl_stmt|,
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"read midi%d subdev %d flag 0x%08x\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|flag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
comment|/* Begin recording. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
comment|/* Have we got the data to read? */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
operator|==
literal|0
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
else|else
block|{
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|ret
operator|=
name|midibuf_uioread
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_in
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
name|ret
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|d
operator|->
name|read
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|d
operator|->
name|read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midi_write
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|s
decl_stmt|,
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"write midi%d subdev %d flag 0x%08x\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|flag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
comment|/* Begin playing. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
comment|/* Have we got the data to write? */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|==
literal|0
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
else|else
block|{
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
condition|)
name|len
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
expr_stmt|;
name|ret
operator|=
name|midibuf_uiowrite
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
name|ret
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Begin playing. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|d
operator|->
name|write
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|d
operator|->
name|write
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generic midi ioctl. Functions of the default driver can be  * overridden by the device-specific ioctl call.  * If a device-specific call returns ENOSYS (Function not implemented),  * the default driver is called. Otherwise, the returned value  * is passed up.  *  * The default handler, for many parameters, sets the value in the  * descriptor, sets MIDI_F_INIT, and calls the callback function with  * reason INIT. If successful, the callback returns 1 and the caller  * can update the parameter.  */
end_comment

begin_function
name|int
name|midi_ioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
init|=
name|ENOSYS
decl_stmt|,
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|snd_size
modifier|*
name|sndsize
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|d
operator|->
name|ioctl
condition|)
name|ret
operator|=
name|d
operator|->
name|ioctl
argument_list|(
name|i_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ENOSYS
condition|)
return|return
name|ret
return|;
comment|/* 	 * pass control to the default ioctl handler. Set ret to 0 now. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * all routines are called with int. blocked. Make sure that 	 * ints are re-enabled when calling slow or blocking functions! 	 */
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 		 * we start with the new ioctl interface. 		 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
expr_stmt|;
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
name|sndsize
operator|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sndsize
operator|->
name|play_size
operator|<=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|&&
name|sndsize
operator|->
name|rec_size
operator|<=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_HAS_SIZE
expr_stmt|;
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sndsize
operator|->
name|play_size
operator|>
name|d
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|/
literal|4
condition|)
name|sndsize
operator|->
name|play_size
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|sndsize
operator|->
name|rec_size
operator|>
name|d
operator|->
name|midi_dbuf_in
operator|.
name|bufsize
operator|/
literal|4
condition|)
name|sndsize
operator|->
name|rec_size
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|bufsize
operator|/
literal|4
expr_stmt|;
comment|/* Round up the size to the multiple of EV_SZ. */
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
operator|=
operator|(
operator|(
name|sndsize
operator|->
name|play_size
operator|+
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|-
literal|1
operator|)
operator|/
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|)
operator|*
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
operator|=
operator|(
operator|(
name|sndsize
operator|->
name|rec_size
operator|+
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|-
literal|1
operator|)
operator|/
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|)
operator|*
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|MIDI_F_HAS_SIZE
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
name|sndsize
operator|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_PLAY
condition|)
comment|/* play */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_STOP
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_CAPTURE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_STOP
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"AIOSTOP: bad channel 0x%x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
block|}
break|break ;
case|case
name|AIOSYNC
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"AIOSYNC chan 0x%03lx pos %lu unimplemented\n"
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * here follow the standard ioctls (filio.h etc.) 		 */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|DEB
argument_list|(
argument|printf(
literal|"FIOASYNC\n"
argument|) ;
argument_list|)
break|break;
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_NBIO
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator||=
name|MIDI_F_NBIO
expr_stmt|;
break|break ;
case|case
name|MIOSPASSTHRU
case|:
comment|/* set/clear passthru */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_PASSTHRU
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator||=
name|MIDI_F_PASSTHRU
expr_stmt|;
comment|/* Init the queue. */
name|midibuf_init
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MIOGPASSTHRU
case|:
comment|/* get passthru */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_PASSTHRU
operator|)
operator|!=
literal|0
condition|)
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|1
expr_stmt|;
else|else
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
break|break ;
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"default ioctl midi%d subdev %d fn 0x%08x fail\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break ;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|midi_poll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|dev
decl_stmt|,
name|ret
decl_stmt|,
name|s
decl_stmt|,
name|lim
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|d
operator|->
name|poll
condition|)
name|ret
operator|=
name|d
operator|->
name|poll
argument_list|(
name|i_dev
argument_list|,
name|events
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
comment|/* Look up the apropriate queue and select it. */
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start playing. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
comment|/* Find out the boundary. */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
else|else
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|<
name|lim
condition|)
comment|/* No enough space, record select. */
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|midi_dbuf_out
operator|.
name|sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start recording. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
comment|/* Find out the boundary. */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
else|else
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
operator|<
name|lim
condition|)
comment|/* No data ready, record select. */
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|midi_dbuf_in
operator|.
name|sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|midi_intr
parameter_list|(
name|mididev_info
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|intr
operator|!=
name|NULL
condition|)
name|d
operator|->
name|intr
argument_list|(
name|d
operator|->
name|intrarg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These handle the status message of the midi drivers.  */
end_comment

begin_function
name|int
name|midistat_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|midistatbusy
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bzero
argument_list|(
name|midistatbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|midistatbuf
argument_list|)
argument_list|)
expr_stmt|;
name|midistatptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|midi_initstatus
argument_list|(
name|midistatbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|midistatbuf
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|midistatbusy
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midistat_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|midistatbusy
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midistat_read
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
name|midi_readstatus
argument_list|(
name|midistatbuf
argument_list|,
operator|&
name|midistatptr
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * finally, some "libraries"  */
end_comment

begin_comment
comment|/* Inits the buffer for /dev/midistat. */
end_comment

begin_function
specifier|static
name|int
name|midi_initstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|"FreeBSD Midi Driver (newmidi) %s %s\nInstalled devices:\n"
argument_list|,
name|__DATE__
argument_list|,
name|__TIME__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMIDI_MAX
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|=
operator|&
name|midi_info
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MIDICONFED
argument_list|(
name|md
argument_list|)
condition|)
continue|continue;
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|midi_devclass
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|size
condition|)
name|p
operator|+=
name|snprintf
argument_list|(
operator|&
name|buf
index|[
name|p
index|]
argument_list|,
name|size
operator|-
name|p
argument_list|,
literal|"midi%d:<%s> %s\n"
argument_list|,
name|i
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
name|md
operator|->
name|midistat
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reads the status message. */
end_comment

begin_function
specifier|static
name|int
name|midi_readstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|s
operator|=
name|splmidi
argument_list|()
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|strlen
argument_list|(
operator|&
name|buf
index|[
operator|*
name|ptr
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|uiomove
argument_list|(
operator|&
name|buf
index|[
operator|*
name|ptr
index|]
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

