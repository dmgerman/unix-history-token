begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Main midi driver for FreeBSD. This file provides the main  * entry points for probe/attach and all i/o demultiplexing, including  * default routines for generic devices.  *   * (C) 1999 Seigo Tanimura  *   * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS  * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * For each card type a template "mididev_info" structure contains  * all the relevant parameters, both for configuration and runtime.  *  * In this file we build tables of pointers to the descriptors for  * the various supported cards. The generic probe routine scans  * the table(s) looking for a matching entry, then invokes the  * board-specific probe routine. If successful, a pointer to the  * correct mididev_info is stored in mididev_last_probed, for subsequent  * use in the attach routine. The generic attach routine copies  * the template to a permanent descriptor (midi_info and  * friends), initializes all generic parameters, and calls the  * board-specific attach routine.  *  * On device calls, the generic routines do the checks on unit and  * device parameters, then call the board-specific routines if  * available, or try to perform the task using the default code.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|midi_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|midiopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|midiclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|midiioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|midiread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|midiwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|midipoll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These functions are local. */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|midistat_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|midistat_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|midistat_read
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|midi_initstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|midi_readstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|MIDI_CDEV_MAJOR
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|midi_cdevsw
init|=
block|{
comment|/* open */
name|midiopen
block|,
comment|/* close */
name|midiclose
block|,
comment|/* read */
name|midiread
block|,
comment|/* write */
name|midiwrite
block|,
comment|/* ioctl */
name|midiioctl
block|,
comment|/* poll */
name|midipoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"midi"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * descriptors for active devices. also used as the public softc  * of a device.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|_mididev_info
argument_list|)
name|midi_info
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nmidi
decl_stmt|,
name|nsynth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mutex to protect midi_info, nmidi and nsynth. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|midiinfo_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midiinfo_mtx_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These make the buffer for /dev/midistat */
end_comment

begin_decl_stmt
specifier|static
name|int
name|midistatbusy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|midistatbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midistatptr
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|midi
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Midi driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|midi_debug
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_midi
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|midi_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|midi_cmdtab
name|cmdtab_midiioctl
index|[]
init|=
block|{
block|{
name|SNDCTL_MIDI_PRETIME
block|,
literal|"SNDCTL_MIDI_PRETIME"
block|}
block|,
block|{
name|SNDCTL_MIDI_MPUMODE
block|,
literal|"SNDCTL_MIDI_MPUMODE"
block|}
block|,
block|{
name|SNDCTL_MIDI_MPUCMD
block|,
literal|"SNDCTL_MIDI_MPUCMD"
block|}
block|,
block|{
name|SNDCTL_SYNTH_INFO
block|,
literal|"SNDCTL_SYNTH_INFO"
block|}
block|,
block|{
name|SNDCTL_MIDI_INFO
block|,
literal|"SNDCTL_MIDI_INFO"
block|}
block|,
block|{
name|SNDCTL_SYNTH_MEMAVL
block|,
literal|"SNDCTL_SYNTH_MEMAVL"
block|}
block|,
block|{
name|SNDCTL_FM_LOAD_INSTR
block|,
literal|"SNDCTL_FM_LOAD_INSTR"
block|}
block|,
block|{
name|SNDCTL_FM_4OP_ENABLE
block|,
literal|"SNDCTL_FM_4OP_ENABLE"
block|}
block|,
block|{
name|MIOSPASSTHRU
block|,
literal|"MIOSPASSTHRU"
block|}
block|,
block|{
name|MIOGPASSTHRU
block|,
literal|"MIOGPASSTHRU"
block|}
block|,
block|{
name|AIONWRITE
block|,
literal|"AIONWRITE"
block|}
block|,
block|{
name|AIOGSIZE
block|,
literal|"AIOGSIZE"
block|}
block|,
block|{
name|AIOSSIZE
block|,
literal|"AIOSSIZE"
block|}
block|,
block|{
name|AIOGFMT
block|,
literal|"AIOGFMT"
block|}
block|,
block|{
name|AIOSFMT
block|,
literal|"AIOSFMT"
block|}
block|,
block|{
name|AIOGMIX
block|,
literal|"AIOGMIX"
block|}
block|,
block|{
name|AIOSMIX
block|,
literal|"AIOSMIX"
block|}
block|,
block|{
name|AIOSTOP
block|,
literal|"AIOSTOP"
block|}
block|,
block|{
name|AIOSYNC
block|,
literal|"AIOSYNC"
block|}
block|,
block|{
name|AIOGCAP
block|,
literal|"AIOGCAP"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the generic init routine.  * Must be called after device-specific init.  */
end_comment

begin_function
name|int
name|midiinit
parameter_list|(
name|mididev_info
modifier|*
name|d
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
comment|/* 	 * initialize standard parameters for the device. This can be 	 * overridden by device-specific configurations but better do 	 * here the generic things. 	 */
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midiinit: unit %d.\n"
argument_list|,
name|d
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|=
name|d
operator|->
name|unit
expr_stmt|;
name|d
operator|->
name|softc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|d
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|d
operator|->
name|magic
operator|=
name|MAGIC
argument_list|(
name|d
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* debugging... */
name|d
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|midi_dbuf_passthru
operator|.
name|unit_size
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|midi_devclass
operator|==
name|NULL
condition|)
block|{
name|midi_devclass
operator|=
name|device_get_devclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|midi_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
literal|0
argument_list|,
name|MIDI_DEV_STATUS
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0444
argument_list|,
literal|"midistat"
argument_list|)
expr_stmt|;
block|}
name|make_dev
argument_list|(
operator|&
name|midi_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
name|unit
argument_list|,
name|MIDI_DEV_MIDIN
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"midi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a device number, returns  * a pointer to the associated mididev_info struct, and sets the unit  * number.  */
end_comment

begin_function
name|mididev_info
modifier|*
name|get_mididev_info
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|u
decl_stmt|;
if|if
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
operator|!=
name|MIDI_DEV_MIDIN
condition|)
return|return
name|NULL
return|;
name|u
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
condition|)
operator|*
name|unit
operator|=
name|u
expr_stmt|;
return|return
name|get_mididev_info_unit
argument_list|(
name|u
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a unit number, returns  * a pointer to the associated mididev_info struct.  */
end_comment

begin_function
name|mididev_info
modifier|*
name|get_mididev_info_unit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|mididev_info
modifier|*
name|md
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|midiinfo_mtx_init
condition|)
block|{
name|midiinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|,
literal|"midinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|midi_info
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&midi_info
argument_list|,
argument|md_link
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|unit
operator|==
name|unit
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|md
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a unit number, returns  * a pointer to the associated mididev_info struct with MDT_MIDI.  */
end_comment

begin_function
name|mididev_info
modifier|*
name|get_mididev_midi_unit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|mididev_info
modifier|*
name|md
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|midiinfo_mtx_init
condition|)
block|{
name|midiinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|,
literal|"midinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|midi_info
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&midi_info
argument_list|,
argument|md_link
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|midiunit
operator|==
name|unit
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|md
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a unit number, returns  * a pointer to the associated mididev_info struct with MDT_SYNTH.  */
end_comment

begin_function
name|mididev_info
modifier|*
name|get_mididev_synth_unit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|mididev_info
modifier|*
name|md
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|midiinfo_mtx_init
condition|)
block|{
name|midiinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|,
literal|"midinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|midi_info
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&midi_info
argument_list|,
argument|md_link
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|synthunit
operator|==
name|unit
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|md
return|;
block|}
end_function

begin_comment
comment|/* Create a new midi device info structure. */
end_comment

begin_comment
comment|/* TODO: lock md, then exit. */
end_comment

begin_function
name|mididev_info
modifier|*
name|create_mididev_info_unit
parameter_list|(
name|int
name|type
parameter_list|,
name|mididev_info
modifier|*
name|mdinf
parameter_list|,
name|synthdev_info
modifier|*
name|syninf
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|,
modifier|*
name|mdnew
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|midiinfo_mtx_init
condition|)
block|{
name|midiinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|,
literal|"midinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|midi_info
argument_list|)
expr_stmt|;
block|}
comment|/* As malloc(9) might block, allocate mididev_info now. */
name|mdnew
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mididev_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdnew
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
name|mdinf
argument_list|,
name|mdnew
argument_list|,
sizeof|sizeof
argument_list|(
name|mididev_info
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|syninf
argument_list|,
operator|&
name|mdnew
operator|->
name|synth
argument_list|,
sizeof|sizeof
argument_list|(
name|synthdev_info
argument_list|)
argument_list|)
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|mdnew
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|mdnew
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|mdnew
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|mdnew
operator|->
name|flagqueue_mtx
argument_list|,
literal|"midflq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|mdnew
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|,
literal|"synsvc"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|mdnew
operator|->
name|synth
operator|.
name|status_mtx
argument_list|,
literal|"synsst"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MDT_MIDI
case|:
name|mdnew
operator|->
name|midiunit
operator|=
name|nmidi
expr_stmt|;
name|mdnew
operator|->
name|synthunit
operator|=
name|nmidi
expr_stmt|;
name|nmidi
operator|++
expr_stmt|;
break|break;
case|case
name|MDT_SYNTH
case|:
name|mdnew
operator|->
name|midiunit
operator|=
operator|-
literal|1
expr_stmt|;
name|mdnew
operator|->
name|synthunit
operator|=
name|nsynth
expr_stmt|;
name|nsynth
operator|++
expr_stmt|;
break|break;
default|default:
name|mtx_unlock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
name|midibuf_destroy
argument_list|(
operator|&
name|mdnew
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
name|midibuf_destroy
argument_list|(
operator|&
name|mdnew
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|midibuf_destroy
argument_list|(
operator|&
name|mdnew
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|mdnew
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|mdnew
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|mdnew
operator|->
name|synth
operator|.
name|status_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mdnew
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unsupported device type"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mdnew
operator|->
name|mdtype
operator|=
name|type
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
condition|;
name|unit
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&midi_info
argument_list|,
argument|md_link
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|unit
operator|==
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
break|break;
block|}
name|mdnew
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mdnew
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|midi_info
argument_list|,
name|mdnew
argument_list|,
name|md_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|midiinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|mdnew
return|;
block|}
end_function

begin_comment
comment|/* Return the number of configured devices. */
end_comment

begin_function
name|int
name|mididev_info_number
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|nmidi
operator|+
name|nsynth
return|;
block|}
end_function

begin_comment
comment|/* Return the number of configured midi devices. */
end_comment

begin_function
name|int
name|mididev_midi_number
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|nmidi
return|;
block|}
end_function

begin_comment
comment|/* Return the number of configured synth devices. */
end_comment

begin_function
name|int
name|mididev_synth_number
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|nsynth
return|;
block|}
end_function

begin_comment
comment|/*  * here are the switches for the main functions. The switches do  * all necessary checks on the device number to make sure  * that the device is configured. They also provide some default  * functionalities so that device-specific drivers have to deal  * only with special cases.  */
end_comment

begin_function
specifier|static
name|int
name|midiopen
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
name|ret
operator|=
name|midi_open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_DEV_STATUS
case|:
name|ret
operator|=
name|midistat_open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiclose
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
name|ret
operator|=
name|midi_close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_DEV_STATUS
case|:
name|ret
operator|=
name|midistat_close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiread
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
name|ret
operator|=
name|midi_read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_DEV_STATUS
case|:
name|ret
operator|=
name|midistat_read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiwrite
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
name|ret
operator|=
name|midi_write
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midiioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|i_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|midipoll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_MIDIN
case|:
name|ret
operator|=
name|midi_poll
argument_list|(
name|i_dev
argument_list|,
name|events
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Followings are the generic methods in midi drivers.  */
end_comment

begin_function
name|int
name|midi_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_open: unit %d, flags 0x%x.\n"
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Mark this device busy. */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|device_busy
argument_list|(
name|d
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_BUSY
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"midi_open: unit %d is busy.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|d
operator|->
name|fflags
operator|=
name|flags
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|MIDI_F_BUSY
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MIDI_F_READING
operator||
name|MIDI_F_WRITING
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|O_NONBLOCK
operator|)
operator|!=
literal|0
condition|)
name|d
operator|->
name|flags
operator||=
name|MIDI_F_NBIO
expr_stmt|;
comment|/* Init the queue. */
if|if
condition|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|!=
literal|0
condition|)
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|open
operator|==
name|NULL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|d
operator|->
name|open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Begin recording if nonblocking. */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
operator|(
name|MIDI_F_READING
operator||
name|MIDI_F_NBIO
operator|)
operator|)
operator|==
name|MIDI_F_NBIO
operator|&&
operator|(
name|d
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|!=
literal|0
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_open: opened.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midi_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_close: unit %d.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Stop recording and playing. */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_READING
operator|)
operator|!=
literal|0
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_ABORT
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_WRITING
operator|)
operator|!=
literal|0
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_ABORT
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
comment|/* Clear the queues. */
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|!=
literal|0
condition|)
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
block|}
comment|/* Stop playing and unmark this device busy. */
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_BUSY
expr_stmt|;
name|d
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|device_unbusy
argument_list|(
name|d
operator|->
name|dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|close
operator|==
name|NULL
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|d
operator|->
name|close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_close: closed.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midi_read
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|len
decl_stmt|,
name|lenr
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|uiobuf
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_read: unit %d, resid %d.\n"
argument_list|,
name|unit
argument_list|,
name|buf
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|lenr
operator|=
literal|0
expr_stmt|;
name|uiobuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiobuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Begin recording. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
comment|/* Have we got the data to read? */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
operator|==
literal|0
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|len
operator|>
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
condition|)
name|len
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
expr_stmt|;
name|ret
operator|=
name|midibuf_seqread
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_in
argument_list|,
name|uiobuf
argument_list|,
name|len
argument_list|,
operator|&
name|lenr
argument_list|,
name|d
operator|->
name|callback
argument_list|,
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_RD
argument_list|,
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenr
operator|>
literal|0
condition|)
name|ret
operator|=
name|uiomove
argument_list|(
name|uiobuf
argument_list|,
name|lenr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uiobuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_read: ret %d, resid %d.\n"
argument_list|,
name|ret
argument_list|,
name|buf
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midi_write
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|len
decl_stmt|,
name|len2
decl_stmt|,
name|lenw
decl_stmt|,
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|uiobuf
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_write: unit %d.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|lenw
operator|=
literal|0
expr_stmt|;
name|uiobuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiobuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ret
operator|=
name|uiomove
argument_list|(
name|uiobuf
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|uiobuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Have we got the data to write? */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|==
literal|0
condition|)
block|{
comment|/* Begin playing. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
name|len2
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|len2
operator|>
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
condition|)
name|len2
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
expr_stmt|;
name|ret
operator|=
name|midibuf_seqwrite
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|,
name|uiobuf
argument_list|,
name|len2
argument_list|,
operator|&
name|lenw
argument_list|,
name|d
operator|->
name|callback
argument_list|,
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|,
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uiobuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|buf
operator|->
name|uio_resid
operator|=
name|len
operator|-
name|lenw
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generic midi ioctl. Functions of the default driver can be  * overridden by the device-specific ioctl call.  * If a device-specific call returns ENOSYS (Function not implemented),  * the default driver is called. Otherwise, the returned value  * is passed up.  *  * The default handler, for many parameters, sets the value in the  * descriptor, sets MIDI_F_INIT, and calls the callback function with  * reason INIT. If successful, the callback returns 1 and the caller  * can update the parameter.  */
end_comment

begin_function
name|int
name|midi_ioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
init|=
name|ENOSYS
decl_stmt|,
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|snd_size
modifier|*
name|sndsize
decl_stmt|;
name|snd_sync_parm
modifier|*
name|sp
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|d
operator|->
name|ioctl
condition|)
name|ret
operator|=
name|d
operator|->
name|ioctl
argument_list|(
name|i_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ENOSYS
condition|)
return|return
name|ret
return|;
comment|/* 	 * pass control to the default ioctl handler. Set ret to 0 now. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: unit %d, cmd %s.\n"
argument_list|,
name|unit
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_midiioctl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * all routines are called with int. blocked. Make sure that 	 * ints are re-enabled when calling slow or blocking functions! 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 		 * we start with the new ioctl interface. 		 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: fl %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
name|sndsize
operator|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: play %d, rec %d.\n"
argument_list|,
name|sndsize
operator|->
name|play_size
argument_list|,
name|sndsize
operator|->
name|rec_size
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndsize
operator|->
name|play_size
operator|<=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|&&
name|sndsize
operator|->
name|rec_size
operator|<=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
condition|)
block|{
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_HAS_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sndsize
operator|->
name|play_size
operator|>
name|d
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|/
literal|4
condition|)
name|sndsize
operator|->
name|play_size
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|sndsize
operator|->
name|rec_size
operator|>
name|d
operator|->
name|midi_dbuf_in
operator|.
name|bufsize
operator|/
literal|4
condition|)
name|sndsize
operator|->
name|rec_size
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|bufsize
operator|/
literal|4
expr_stmt|;
comment|/* Round up the size to the multiple of EV_SZ. */
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
operator|=
operator|(
operator|(
name|sndsize
operator|->
name|play_size
operator|+
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|-
literal|1
operator|)
operator|/
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|)
operator|*
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
operator|=
operator|(
operator|(
name|sndsize
operator|->
name|rec_size
operator|+
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|-
literal|1
operator|)
operator|/
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|)
operator|*
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|MIDI_F_HAS_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
name|sndsize
operator|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: play %d, rec %d.\n"
argument_list|,
name|sndsize
operator|->
name|play_size
argument_list|,
name|sndsize
operator|->
name|rec_size
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AIOSTOP
case|:
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_PLAY
condition|)
comment|/* play */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_STOP
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_CAPTURE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_STOP
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
else|else
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: bad channel 0x%x.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AIOSYNC
case|:
name|sp
operator|=
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: unimplemented, chan 0x%03lx pos %lu.\n"
argument_list|,
name|sp
operator|->
name|chan
argument_list|,
name|sp
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * here follow the standard ioctls (filio.h etc.) 		 */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: rl %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"FIOASYNC\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_NBIO
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator||=
name|MIDI_F_NBIO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: arg %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|MIOSPASSTHRU
case|:
comment|/* set/clear passthru */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_PASSTHRU
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator||=
name|MIDI_F_PASSTHRU
expr_stmt|;
comment|/* Init the queue. */
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_passthru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: passthru %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MIOGPASSTHRU
case|:
comment|/* get passthru */
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_PASSTHRU
operator|)
operator|!=
literal|0
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|1
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: passthru %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_ioctl: default ioctl midi%d subdev %d fn 0x%08lx fail\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break ;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|midi_poll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|dev
decl_stmt|,
name|ret
decl_stmt|,
name|lim
decl_stmt|;
name|mididev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_poll: unit %d.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Look up the apropriate queue and select it. */
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start playing. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
comment|/* Find out the boundary. */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
else|else
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|<
name|lim
condition|)
comment|/* No enough space, record select. */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|d
operator|->
name|midi_dbuf_out
operator|.
name|sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start recording. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_RD
argument_list|)
expr_stmt|;
comment|/* Find out the boundary. */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
else|else
name|lim
operator|=
name|d
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|midi_dbuf_in
operator|.
name|rl
operator|<
name|lim
condition|)
comment|/* No data ready, record select. */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|d
operator|->
name|midi_dbuf_in
operator|.
name|sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|midi_intr
parameter_list|(
name|mididev_info
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|intr
operator|!=
name|NULL
condition|)
name|d
operator|->
name|intr
argument_list|(
name|d
operator|->
name|intrarg
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the output queue. */
end_comment

begin_define
define|#
directive|define
name|MIDI_SYNC_TIMEOUT
value|1
end_define

begin_function
name|int
name|midi_sync
parameter_list|(
name|mididev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rl
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"midi_sync: unit %d.\n"
argument_list|,
name|d
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|midi_dbuf_out
operator|.
name|rl
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|MIDI_F_WRITING
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_START
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
name|rl
operator|=
name|d
operator|->
name|midi_dbuf_out
operator|.
name|rl
expr_stmt|;
name|i
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
operator|.
name|cv_out
argument_list|,
operator|&
name|d
operator|->
name|flagqueue_mtx
argument_list|,
operator|(
name|d
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|*
literal|10
operator|*
name|hz
operator|/
literal|38400
operator|)
operator|+
name|MIDI_SYNC_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EINTR
operator|||
name|i
operator|==
name|ERESTART
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|EINTR
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_STOP
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
name|EWOULDBLOCK
operator|&&
name|rl
operator|==
name|d
operator|->
name|midi_dbuf_out
operator|.
name|rl
condition|)
block|{
comment|/* A queue seems to be stuck up. Give up and clear the queue. */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|MIDI_CB_STOP
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|d
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * These handle the status message of the midi drivers.  */
end_comment

begin_function
name|int
name|midistat_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|midistatbusy
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bzero
argument_list|(
name|midistatbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|midistatbuf
argument_list|)
argument_list|)
expr_stmt|;
name|midistatptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|midi_initstatus
argument_list|(
name|midistatbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|midistatbuf
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|midistatbusy
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midistat_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|midistatbusy
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|midistat_read
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
name|midi_readstatus
argument_list|(
name|midistatbuf
argument_list|,
operator|&
name|midistatptr
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * finally, some "libraries"  */
end_comment

begin_comment
comment|/* Inits the buffer for /dev/midistat. */
end_comment

begin_function
specifier|static
name|int
name|midi_initstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|"FreeBSD Midi Driver (newmidi) %s %s\nInstalled devices:\n"
argument_list|,
name|__DATE__
argument_list|,
name|__TIME__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mididev_info_number
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|=
name|get_mididev_info_unit
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MIDICONFED
argument_list|(
name|md
argument_list|)
condition|)
continue|continue;
name|dev
operator|=
name|devclass_get_device
argument_list|(
name|midi_devclass
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|size
condition|)
name|p
operator|+=
name|snprintf
argument_list|(
operator|&
name|buf
index|[
name|p
index|]
argument_list|,
name|size
operator|-
name|p
argument_list|,
literal|"midi%d:<%s> %s\n"
argument_list|,
name|i
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
name|md
operator|->
name|midistat
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reads the status message. */
end_comment

begin_function
specifier|static
name|int
name|midi_readstatus
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|strlen
argument_list|(
operator|&
name|buf
index|[
operator|*
name|ptr
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|uiomove
argument_list|(
operator|&
name|buf
index|[
operator|*
name|ptr
index|]
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|midi_cmdname
parameter_list|(
name|int
name|cmd
parameter_list|,
name|midi_cmdtab
modifier|*
name|tab
parameter_list|)
block|{
while|while
condition|(
name|tab
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|tab
operator|->
name|cmd
condition|)
return|return
operator|(
name|tab
operator|->
name|name
operator|)
return|;
name|tab
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|"unknown"
operator|)
return|;
block|}
end_function

end_unit

