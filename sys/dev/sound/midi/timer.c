begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This is the timer engine of /dev/music for FreeBSD.  *   * (C) 2002 Seigo Tanimura  *   * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS  * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/sequencer.h>
end_include

begin_define
define|#
directive|define
name|TMR2TICKS
parameter_list|(
name|scp
parameter_list|,
name|tmr_val
parameter_list|)
define|\
value|((((tmr_val) * (scp)->tempo * (scp)->timebase) + (30 * hz)) / (60 * hz))
end_define

begin_define
define|#
directive|define
name|CURTICKS
parameter_list|(
name|scp
parameter_list|)
define|\
value|((scp)->ticks_offset + (scp)->ticks_cur - (scp)->ticks_base)
end_define

begin_struct
struct|struct
name|systmr_timer_softc
block|{
name|int
name|running
decl_stmt|;
name|u_long
name|ticks_offset
decl_stmt|;
name|u_long
name|ticks_base
decl_stmt|;
name|u_long
name|ticks_cur
decl_stmt|;
name|int
name|tempo
decl_stmt|;
name|int
name|timebase
decl_stmt|;
name|u_long
name|nexteventtime
decl_stmt|;
name|u_long
name|preveventtime
decl_stmt|;
name|struct
name|callout
name|timer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|timeout_t
name|systmr_timer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|systmr_reset
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|systmr_time
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|tmr_open_t
name|systmr_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tmr_close_t
name|systmr_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tmr_event_t
name|systmr_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tmr_gettime_t
name|systmr_gettime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tmr_ioctl_t
name|systmr_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tmr_armtimer_t
name|systmr_armtimer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timerdev_info
name|systmr_timerdev
init|=
block|{
literal|"System clock"
block|,
literal|0
block|,
literal|0
block|,
name|systmr_open
block|,
name|systmr_close
block|,
name|systmr_event
block|,
name|systmr_gettime
block|,
name|systmr_ioctl
block|,
name|systmr_armtimer
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|_timerdev_info
argument_list|)
name|timer_info
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|timerinfo_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timerinfo_mtx_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntimer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Install a system timer. */
end_comment

begin_function
name|int
name|timerdev_install
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|timerdev_info
modifier|*
name|tmd
decl_stmt|;
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"timerdev_install: install a new timer.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|tmd
operator|=
name|NULL
expr_stmt|;
name|scp
operator|=
name|NULL
expr_stmt|;
name|scp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|tmd
operator|=
name|create_timerdev_info_unit
argument_list|(
operator|&
name|systmr_timerdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|tmd
operator|->
name|softc
operator|=
name|scp
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|scp
operator|->
name|timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"timerdev_install: installed a new timer, unit %d.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|scp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|timer_info
argument_list|,
name|tmd
argument_list|,
name|tmd_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"timerdev_install: installation failed.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new timer device info structure. */
end_comment

begin_function
name|timerdev_info
modifier|*
name|create_timerdev_info_unit
parameter_list|(
name|timerdev_info
modifier|*
name|tmdinf
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|timerdev_info
modifier|*
name|tmd
decl_stmt|,
modifier|*
name|tmdnew
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|timerinfo_mtx_init
condition|)
block|{
name|timerinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|,
literal|"tmrinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|timer_info
argument_list|)
expr_stmt|;
block|}
comment|/* As malloc(9) might block, allocate timerdev_info now. */
name|tmdnew
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|timerdev_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmdnew
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
name|tmdinf
argument_list|,
name|tmdnew
argument_list|,
sizeof|sizeof
argument_list|(
name|timerdev_info
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|tmdnew
operator|->
name|mtx
argument_list|,
literal|"tmrmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|)
expr_stmt|;
name|ntimer
operator|++
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
condition|;
name|unit
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|tmd
argument_list|,
argument|&timer_info
argument_list|,
argument|tmd_link
argument_list|)
block|{
if|if
condition|(
name|tmd
operator|->
name|unit
operator|==
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|tmd
operator|==
name|NULL
condition|)
break|break;
block|}
name|tmdnew
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmdnew
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|tmd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|timer_info
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tmd
operator|->
name|prio
operator|<
name|tmdnew
operator|->
name|prio
condition|)
break|break;
name|tmd
operator|=
name|TAILQ_NEXT
argument_list|(
name|tmd
argument_list|,
name|tmd_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmd
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tmd
argument_list|,
name|tmdnew
argument_list|,
name|tmd_link
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|timer_info
argument_list|,
name|tmdnew
argument_list|,
name|tmd_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmdnew
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a unit number, returns  * a pointer to the associated timerdev_info struct.  */
end_comment

begin_function
name|timerdev_info
modifier|*
name|get_timerdev_info_unit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|timerdev_info
modifier|*
name|tmd
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|timerinfo_mtx_init
condition|)
block|{
name|timerinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|,
literal|"tmrinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|timer_info
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tmd
argument_list|,
argument|&timer_info
argument_list|,
argument|tmd_link
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|unit
operator|==
name|unit
operator|&&
name|tmd
operator|->
name|seq
operator|==
name|NULL
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|tmd
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which returns a pointer  * to the best preferred timerdev_info struct with  * no sequencer.  */
end_comment

begin_function
name|timerdev_info
modifier|*
name|get_timerdev_info
parameter_list|(
name|void
parameter_list|)
block|{
name|timerdev_info
modifier|*
name|tmd
decl_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|timerinfo_mtx_init
condition|)
block|{
name|timerinfo_mtx_init
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|,
literal|"tmrinf"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|timer_info
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tmd
argument_list|,
argument|&timer_info
argument_list|,
argument|tmd_link
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|seq
operator|==
name|NULL
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|timerinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|tmd
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|systmr_timer
parameter_list|(
name|void
modifier|*
name|d
parameter_list|)
block|{
name|timerdev_info
modifier|*
name|tmd
decl_stmt|;
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|void
modifier|*
name|seq
decl_stmt|;
name|tmd
operator|=
operator|(
name|timerdev_info
operator|*
operator|)
name|d
expr_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|seq
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|opened
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|scp
operator|->
name|timer
argument_list|,
literal|1
argument_list|,
name|systmr_timer
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|running
condition|)
block|{
name|scp
operator|->
name|ticks_cur
operator|=
name|TMR2TICKS
argument_list|(
name|scp
argument_list|,
name|systmr_time
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURTICKS
argument_list|(
name|scp
argument_list|)
operator|>=
name|scp
operator|->
name|nexteventtime
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_timer: CURTICKS %lu, call the sequencer.\n"
argument_list|,
name|CURTICKS
argument_list|(
name|scp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|nexteventtime
operator|=
name|ULONG_MAX
expr_stmt|;
name|seq
operator|=
name|tmd
operator|->
name|seq
expr_stmt|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|!=
name|NULL
condition|)
name|seq_timer
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|systmr_reset
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_reset: unit %d.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ticks_offset
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ticks_base
operator|=
name|scp
operator|->
name|ticks_cur
operator|=
name|TMR2TICKS
argument_list|(
name|scp
argument_list|,
name|systmr_time
argument_list|()
argument_list|)
expr_stmt|;
name|scp
operator|->
name|nexteventtime
operator|=
name|ULONG_MAX
expr_stmt|;
name|scp
operator|->
name|preveventtime
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|systmr_time
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timecopy
decl_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|timecopy
argument_list|)
expr_stmt|;
return|return
name|timecopy
operator|.
name|tv_usec
operator|/
operator|(
literal|1000000
operator|/
name|hz
operator|)
operator|+
operator|(
name|u_long
operator|)
name|timecopy
operator|.
name|tv_sec
operator|*
name|hz
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|systmr_open
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_open: unit %d.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|->
name|opened
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|systmr_reset
argument_list|(
name|tmd
argument_list|)
expr_stmt|;
name|scp
operator|->
name|tempo
operator|=
literal|60
expr_stmt|;
name|scp
operator|->
name|timebase
operator|=
name|hz
expr_stmt|;
name|tmd
operator|->
name|opened
operator|=
literal|1
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|scp
operator|->
name|timer
argument_list|,
literal|1
argument_list|,
name|systmr_timer
argument_list|,
name|tmd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|systmr_close
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_close: unit %d.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|tmd
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|scp
operator|->
name|timer
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|systmr_event
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|,
name|u_char
modifier|*
name|ev
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|u_char
name|cmd
decl_stmt|;
name|u_long
name|parm
decl_stmt|,
name|t
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|void
modifier|*
name|seq
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|cmd
operator|=
name|ev
index|[
literal|1
index|]
expr_stmt|;
name|parm
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|ev
index|[
literal|4
index|]
expr_stmt|;
name|ret
operator|=
name|MORE
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_event: unit %d, cmd %s, parm %lu.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_timer
argument_list|)
argument_list|,
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TMR_WAIT_REL
case|:
name|parm
operator|+=
name|scp
operator|->
name|preveventtime
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|TMR_WAIT_ABS
case|:
if|if
condition|(
name|parm
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|parm
operator|<=
name|CURTICKS
argument_list|(
name|scp
argument_list|)
condition|)
break|break;
name|t
operator|=
name|parm
expr_stmt|;
name|scp
operator|->
name|nexteventtime
operator|=
name|scp
operator|->
name|preveventtime
operator|=
name|t
expr_stmt|;
name|ret
operator|=
name|TIMERARMED
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TMR_START
case|:
name|systmr_reset
argument_list|(
name|tmd
argument_list|)
expr_stmt|;
name|scp
operator|->
name|running
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TMR_STOP
case|:
name|scp
operator|->
name|running
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMR_CONTINUE
case|:
name|scp
operator|->
name|running
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TMR_TEMPO
case|:
if|if
condition|(
name|parm
operator|>
literal|0
condition|)
block|{
name|RANGE
argument_list|(
name|parm
argument_list|,
literal|8
argument_list|,
literal|360
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ticks_offset
operator|+=
name|scp
operator|->
name|ticks_cur
operator|-
name|scp
operator|->
name|ticks_base
expr_stmt|;
name|scp
operator|->
name|ticks_base
operator|=
name|scp
operator|->
name|ticks_cur
expr_stmt|;
name|scp
operator|->
name|tempo
operator|=
name|parm
expr_stmt|;
block|}
break|break;
case|case
name|TMR_ECHO
case|:
name|seq
operator|=
name|tmd
operator|->
name|seq
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|seq_copytoinput
argument_list|(
name|seq
argument_list|,
name|ev
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_event: timer %s.\n"
argument_list|,
name|ret
operator|==
name|TIMERARMED
condition|?
literal|"armed"
else|:
literal|"not armed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|systmr_gettime
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|,
name|u_long
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_gettime: unit %d.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmd
operator|->
name|opened
operator|||
name|t
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
operator|*
name|t
operator|=
name|CURTICKS
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_gettime: ticks %lu.\n"
argument_list|,
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fail
label|:
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|systmr_ioctl
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|val
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_ioctl: unit %d, cmd %s.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_seqioctl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_TMR_SOURCE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TMR_INTERNAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_START
case|:
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|systmr_reset
argument_list|(
name|tmd
argument_list|)
expr_stmt|;
name|scp
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_STOP
case|:
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_CONTINUE
case|:
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_TIMEBASE
case|:
name|val
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
name|RANGE
argument_list|(
name|val
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|scp
operator|->
name|timebase
operator|=
name|val
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|timebase
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_ioctl: timebase %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_TEMPO
case|:
name|val
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
name|RANGE
argument_list|(
name|val
argument_list|,
literal|8
argument_list|,
literal|360
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ticks_offset
operator|+=
name|scp
operator|->
name|ticks_cur
operator|-
name|scp
operator|->
name|ticks_base
expr_stmt|;
name|scp
operator|->
name|ticks_base
operator|=
name|scp
operator|->
name|ticks_cur
expr_stmt|;
name|scp
operator|->
name|tempo
operator|=
name|val
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|tempo
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_ioctl: tempo %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
name|val
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
operator|(
name|scp
operator|->
name|tempo
operator|*
name|scp
operator|->
name|timebase
operator|)
operator|+
literal|30
operator|)
operator|/
literal|60
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_ioctl: ctrlrate %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNDCTL_TMR_METRONOME
case|:
comment|/* NOP. */
break|break;
case|case
name|SNDCTL_TMR_SELECT
case|:
comment|/* NOP. */
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|systmr_armtimer
parameter_list|(
name|timerdev_info
modifier|*
name|tmd
parameter_list|,
name|u_long
name|t
parameter_list|)
block|{
name|struct
name|systmr_timer_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
expr|struct
name|systmr_timer_softc
operator|*
operator|)
name|tmd
operator|->
name|softc
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"systmr_armtimer: unit %d, t %lu.\n"
argument_list|,
name|tmd
operator|->
name|unit
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|t
operator|=
name|CURTICKS
argument_list|(
name|scp
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|>
name|CURTICKS
argument_list|(
name|scp
argument_list|)
condition|)
name|scp
operator|->
name|nexteventtime
operator|=
name|scp
operator|->
name|preveventtime
operator|=
name|t
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tmd
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

