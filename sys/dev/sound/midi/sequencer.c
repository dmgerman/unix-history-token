begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The sequencer personality manager.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * This is the newmidi sequencer driver. This driver handles io against  * /dev/sequencer, midi input and output event queues and event transmittion  * to and from a midi device or synthesizer.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/sequencer.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DDB
end_ifndef

begin_define
define|#
directive|define
name|DDB
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_define
define|#
directive|define
name|SND_DEV_SEQ
value|1
end_define

begin_comment
comment|/* Sequencer output /dev/sequencer (FM 				   synthesizer and MIDI output) */
end_comment

begin_define
define|#
directive|define
name|SND_DEV_MIDIN
value|2
end_define

begin_comment
comment|/* Raw midi access */
end_comment

begin_define
define|#
directive|define
name|SND_DEV_SEQ2
value|8
end_define

begin_comment
comment|/* /dev/sequencer, level 2 interface */
end_comment

begin_define
define|#
directive|define
name|MIDIDEV_MODE
value|0x2000
end_define

begin_comment
comment|/* Length of a sequencer event. */
end_comment

begin_define
define|#
directive|define
name|EV_SZ
value|8
end_define

begin_define
define|#
directive|define
name|IEV_SZ
value|8
end_define

begin_comment
comment|/* Return value from seq_playevent and the helpers. */
end_comment

begin_enum
enum|enum
block|{
name|MORE
block|,
name|TIMERARMED
block|,
name|QUEUEFULL
block|}
enum|;
end_enum

begin_comment
comment|/* Lookup modes */
end_comment

begin_define
define|#
directive|define
name|LOOKUP_EXIST
value|(0)
end_define

begin_define
define|#
directive|define
name|LOOKUP_OPEN
value|(1)
end_define

begin_define
define|#
directive|define
name|LOOKUP_CLOSE
value|(2)
end_define

begin_comment
comment|/*  * These functions goes into seq_op_desc to get called  * from sound.c.  */
end_comment

begin_decl_stmt
specifier|static
name|midi_intr_t
name|seq_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|midi_callback_t
name|seq_callback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the entries to the sequencer driver. */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|seq_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|seq_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|seq_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|seq_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|seq_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|seq_poll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the device descriptor for the midi sequencer.  */
end_comment

begin_decl_stmt
name|seqdev_info
name|seq_op_desc
init|=
block|{
literal|"midi sequencer"
block|,
literal|0
block|,
name|seq_open
block|,
name|seq_close
block|,
name|seq_read
block|,
name|seq_write
block|,
name|seq_ioctl
block|,
name|seq_poll
block|,
name|seq_callback
block|,
name|SEQ_BUFFSIZE
block|,
comment|/* Queue Length */
literal|0
block|,
comment|/* XXX This is not an *audio* device! */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is the parameter structure per a device. */
end_comment

begin_struct
struct|struct
name|seq_softc
block|{
name|seqdev_info
modifier|*
name|devinfo
decl_stmt|;
comment|/* sequencer device information */
comment|/* Flags (protected by flag_mtx of mididev_info) */
name|int
name|fflags
decl_stmt|;
comment|/* Access mode */
name|int
name|queueout_pending
decl_stmt|;
comment|/* Pending for the output queue */
comment|/* Timer counters */
name|u_long
name|seq_time
decl_stmt|;
comment|/* The beggining time of this sequence */
name|u_long
name|prev_event_time
decl_stmt|;
comment|/* The time of the previous event output */
name|u_long
name|prev_input_time
decl_stmt|;
comment|/* The time of the previous event input */
name|u_long
name|prev_wakeup_time
decl_stmt|;
comment|/* The time of the previous wakeup */
name|struct
name|callout
name|timeout_ch
decl_stmt|;
comment|/* Timer callout handler */
name|long
name|timer_current
decl_stmt|;
comment|/* Current timer value */
name|int
name|timer_running
decl_stmt|;
comment|/* State of timer */
name|int
name|pending_timer
decl_stmt|;
comment|/* Timer change operation */
name|int
name|pre_event_timeout
decl_stmt|;
comment|/* Time to wait event input */
comment|/* Device list */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|_mididev_info
argument_list|)
name|midi_open
expr_stmt|;
comment|/* Midi devices opened by this sequencer. */
comment|/* 	 * XXX not sure to which category these belong. 	 * (and some might be no-op) 	 */
name|int
name|output_threshould
decl_stmt|;
comment|/* Sequence output threshould */
name|snd_sync_parm
name|sync_parm
decl_stmt|;
comment|/* AIOSYNC parameter set */
name|struct
name|thread
modifier|*
name|sync_thread
decl_stmt|;
comment|/* AIOSYNCing thread */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|seq_softc
modifier|*
name|sc_p
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|d_open_t
name|seqopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|seqclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|seqioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|seqread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|seqwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|seqpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|SEQ_CDEV_MAJOR
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|seq_cdevsw
init|=
block|{
comment|/* open */
name|seqopen
block|,
comment|/* close */
name|seqclose
block|,
comment|/* read */
name|seqread
block|,
comment|/* write */
name|seqwrite
block|,
comment|/* ioctl */
name|seqioctl
block|,
comment|/* poll */
name|seqpoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"midi"
block|,
comment|/* XXX */
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|_seqdev_info
argument_list|)
name|seq_info
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Mutex to protect seq_info and nseq. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|seqinfo_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|nseq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of sequencers */
end_comment

begin_decl_stmt
specifier|static
name|dev_t
name|seq_alias
init|=
name|NODEV
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The followings are the local function. */
end_comment

begin_function_decl
specifier|static
name|int
name|seq_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_initunit
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_queue
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|note
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_playevent
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|seq_gettime
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_requesttimer
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_stoptimer
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_midiinput
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_copytoinput
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_extended
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_chnvoice
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|seq_findvoice
argument_list|(
name|mididev_info
operator|*
name|md
argument_list|,
name|int
name|chn
argument_list|,
name|int
name|note
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|seq_allocvoice
argument_list|(
name|sc_p
name|scp
argument_list|,
name|mididev_info
operator|*
name|md
argument_list|,
name|int
name|chn
argument_list|,
name|int
name|note
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|seq_chncommon
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_timing
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_local
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sysex
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_reset
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_openmidi
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_closemidi
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_panic
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sync
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|seqdev_info
modifier|*
name|get_seqdev_info
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|seqdev_info
modifier|*
name|get_seqdev_info_unit
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|seqdev_info
modifier|*
name|create_seqdev_info_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|seqdev_info
modifier|*
name|seq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_mididev
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|mode
parameter_list|,
name|mididev_info
modifier|*
modifier|*
name|mdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|dev_t
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Here are the main functions to interact to the user process.  * These are called from snd* functions in sys/i386/isa/snd/sound.c.  */
end_comment

begin_function
specifier|static
name|int
name|seq_init
parameter_list|(
name|void
parameter_list|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq: initing.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|,
literal|"seqinf"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|seq_info
argument_list|)
expr_stmt|;
name|seq_initunit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|seq_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq: inited.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_initunit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|devinfo
decl_stmt|;
name|dev_t
name|seqdev
decl_stmt|;
comment|/* Allocate the softc. */
name|scp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
operator|(
name|sc_p
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"seq%d: softc allocation failed.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Fill the softc and the seq_info for this unit. */
name|scp
operator|->
name|seq_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_wakeup_time
operator|=
name|scp
operator|->
name|seq_time
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MIDI_OUTOFGIANT
argument_list|)
name|callout_init
argument_list|(
operator|&
name|scp
operator|->
name|timeout_ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|scp
operator|->
name|timeout_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MIDI_OUTOFGIANT */
name|scp
operator|->
name|timer_current
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|timer_running
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|queueout_pending
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|scp
operator|->
name|midi_open
argument_list|)
expr_stmt|;
name|scp
operator|->
name|devinfo
operator|=
name|devinfo
operator|=
name|create_seqdev_info_unit
argument_list|(
name|unit
argument_list|,
operator|&
name|seq_op_desc
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|=
name|devinfo
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|=
name|EV_SZ
expr_stmt|;
name|devinfo
operator|->
name|softc
operator|=
name|scp
expr_stmt|;
name|devinfo
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|seqdev
operator|=
name|make_dev
argument_list|(
operator|&
name|seq_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
name|unit
argument_list|,
name|SND_DEV_SEQ
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"sequencer%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_alias
operator|!=
name|NODEV
condition|)
block|{
name|destroy_dev
argument_list|(
name|seq_alias
argument_list|)
expr_stmt|;
name|seq_alias
operator|=
name|NODEV
expr_stmt|;
block|}
name|seq_alias
operator|=
name|make_dev_alias
argument_list|(
name|seqdev
argument_list|,
literal|"sequencer"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|seq_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq%d: opening.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NSEQ_MAX
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_open: unit %d does not exist.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sd
operator|=
name|get_seqdev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_open: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
comment|/* Mark this device busy. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_BUSY
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_open: unit %d is busy.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_BUSY
expr_stmt|;
name|sd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SEQ_F_READING
operator||
name|SEQ_F_WRITING
operator|)
expr_stmt|;
name|scp
operator|->
name|fflags
operator|=
name|flags
expr_stmt|;
comment|/* Init the queue. */
name|midibuf_clear
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
comment|/* Init timestamp. */
name|scp
operator|->
name|seq_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_wakeup_time
operator|=
name|scp
operator|->
name|seq_time
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq%d: opened.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|seq_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq%d: closing.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NSEQ_MAX
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_close: unit %d does not exist.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sd
operator|=
name|get_seqdev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_close: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sd
operator|->
name|flags
operator|&
name|MIDI_F_NBIO
operator|)
condition|)
name|seq_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Stop the timer. */
name|seq_stoptimer
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Reset the sequencer. */
name|seq_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|seq_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Clean up the midi device. */
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|md
operator|->
name|unit
argument_list|,
name|LOOKUP_CLOSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Stop playing and unmark this device busy. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|sd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SEQ_F_BUSY
operator||
name|SEQ_F_READING
operator||
name|SEQ_F_WRITING
operator||
name|SEQ_F_INSYNC
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq%d: closed.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|seq_read
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|ret
decl_stmt|,
name|len
decl_stmt|,
name|lenr
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|u_char
modifier|*
name|uiobuf
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
comment|/*DEB(printf("seq%d: reading.\n", unit));*/
if|if
condition|(
name|unit
operator|>=
name|NSEQ_MAX
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_read: unit %d does not exist.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sd
operator|=
name|get_seqdev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_read: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_read: unit %d is not for reading.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|len
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|lenr
operator|=
literal|0
expr_stmt|;
name|uiobuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiobuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Begin recording. */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_READING
operator|)
operator|==
literal|0
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_RD
argument_list|)
expr_stmt|;
comment|/* Have we got the data to read? */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|rl
operator|==
literal|0
condition|)
name|ret
operator|=
name|EAGAIN
expr_stmt|;
else|else
name|ret
operator|=
name|midibuf_seqread
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_in
argument_list|,
name|uiobuf
argument_list|,
name|len
argument_list|,
operator|&
name|lenr
argument_list|,
name|sd
operator|->
name|callback
argument_list|,
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_RD
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|lenr
operator|>
literal|0
condition|)
name|ret
operator|=
name|uiomove
argument_list|(
name|uiobuf
argument_list|,
name|lenr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uiobuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|seq_write
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u_char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|,
name|ev_code
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|count
decl_stmt|,
name|countorg
decl_stmt|,
name|midiunit
decl_stmt|,
name|ev_size
decl_stmt|,
name|p
decl_stmt|,
name|ret
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
comment|/*DEB(printf("seq%d: writing.\n", unit));*/
if|if
condition|(
name|unit
operator|>=
name|NSEQ_MAX
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_write: unit %d does not exist.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sd
operator|=
name|get_seqdev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_write: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_write: unit %d is not for writing.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|p
operator|=
literal|0
expr_stmt|;
name|countorg
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|count
operator|=
name|countorg
expr_stmt|;
comment|/* Pick up an event. */
while|while
condition|(
name|count
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|event
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"seq_write: user memory mangled?\n"
argument_list|)
expr_stmt|;
name|ev_code
operator|=
name|event
index|[
literal|0
index|]
expr_stmt|;
comment|/* Have a look at the event code. */
if|if
condition|(
name|ev_code
operator|==
name|SEQ_FULLSIZE
condition|)
block|{
comment|/* A long event, these are the patches/samples for a synthesizer. */
name|midiunit
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|event
index|[
literal|2
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_write: loading a patch to the unit %d.\n"
argument_list|,
name|midiunit
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|md
operator|->
name|synth
operator|.
name|loadpatch
argument_list|(
name|md
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|ev_code
operator|>=
literal|128
condition|)
block|{
comment|/* Some sort of an extended event. The size is eight bytes. */
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|ev_code
operator|==
name|SEQ_EXTENDED
condition|)
block|{
name|printf
argument_list|(
literal|"seq%d: invalid level two event %x.\n"
argument_list|,
name|unit
argument_list|,
name|ev_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* notyet */
name|ev_size
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|ev_size
condition|)
block|{
comment|/* No more data. Start playing now. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|event
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"seq_write: user memory mangled?\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not an extended event. The size is four bytes. */
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|printf
argument_list|(
literal|"seq%d: four byte event in level two mode.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* notyet */
name|ev_size
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|ev_code
operator|==
name|SEQ_MIDIPUTC
condition|)
block|{
comment|/* An event passed to the midi device itself. */
name|midiunit
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/*DEB(printf("seq_write: queueing event %d.\n", event[0]));*/
comment|/* Now we queue the event. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|seq_queue
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
condition|)
block|{
case|case
name|EAGAIN
case|:
comment|/* The queue is full. Start playing now. */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EINTR
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
case|case
name|ERESTART
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ev_size
expr_stmt|;
name|count
operator|-=
name|ev_size
expr_stmt|;
block|}
comment|/* We have written every single data. Start playing now. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|seq_ioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|midiunit
decl_stmt|,
name|ret
decl_stmt|,
name|tmp
decl_stmt|,
name|arg2
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|struct
name|synth_info
modifier|*
name|synthinfo
decl_stmt|;
name|struct
name|midi_info
modifier|*
name|midiinfo
decl_stmt|;
name|struct
name|patmgr_info
modifier|*
name|patinfo
decl_stmt|;
name|snd_sync_parm
modifier|*
name|syncparm
decl_stmt|;
name|struct
name|seq_event_rec
modifier|*
name|event
decl_stmt|;
name|struct
name|snd_size
modifier|*
name|sndsize
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq%d: ioctlling, cmd 0x%x.\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NSEQ_MAX
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_ioctl: unit %d does not exist.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sd
operator|=
name|get_seqdev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_ioctl: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 		 * we start with the new ioctl interface. 		 */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can be written ? */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|fl
expr_stmt|;
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
name|sndsize
operator|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndsize
operator|->
name|play_size
operator|<=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|&&
name|sndsize
operator|->
name|rec_size
operator|<=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
condition|)
block|{
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|sd
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_HAS_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sndsize
operator|->
name|play_size
operator|>
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|/
literal|4
condition|)
name|sndsize
operator|->
name|play_size
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|sndsize
operator|->
name|rec_size
operator|>
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|bufsize
operator|/
literal|4
condition|)
name|sndsize
operator|->
name|rec_size
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|bufsize
operator|/
literal|4
expr_stmt|;
comment|/* Round up the size to the multiple of EV_SZ. */
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
operator|=
operator|(
operator|(
name|sndsize
operator|->
name|play_size
operator|+
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|-
literal|1
operator|)
operator|/
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
operator|)
operator|*
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
operator|=
operator|(
operator|(
name|sndsize
operator|->
name|rec_size
operator|+
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|-
literal|1
operator|)
operator|/
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
operator|)
operator|*
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|sd
operator|->
name|flags
operator||=
name|MIDI_F_HAS_SIZE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
name|sndsize
operator|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|sndsize
operator|->
name|play_size
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
name|sndsize
operator|->
name|rec_size
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_PLAY
condition|)
block|{
comment|/* Stop writing. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_ABORT
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Pass the ioctl to the midi devices. */
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
if|if
condition|(
operator|(
name|md
operator|->
name|flags
operator|&
name|MIDI_F_WRITING
operator|)
operator|!=
literal|0
condition|)
block|{
name|arg2
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|md
operator|->
name|unit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arg2
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|rl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_CAPTURE
condition|)
block|{
comment|/* Stop reading. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_ABORT
operator||
name|SEQ_CB_RD
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Pass the ioctl to the midi devices. */
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
if|if
condition|(
operator|(
name|md
operator|->
name|flags
operator|&
name|MIDI_F_WRITING
operator|)
operator|!=
literal|0
condition|)
block|{
name|arg2
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|md
operator|->
name|unit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arg2
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|rl
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AIOSYNC
case|:
name|syncparm
operator|=
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
expr_stmt|;
name|scp
operator|->
name|sync_parm
operator|=
operator|*
name|syncparm
expr_stmt|;
comment|/* XXX Should select(2) against us watch the blocksize, or sync_parm? */
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_TIMEBASE
case|:
case|case
name|SNDCTL_TMR_TEMPO
case|:
case|case
name|SNDCTL_TMR_START
case|:
case|case
name|SNDCTL_TMR_STOP
case|:
case|case
name|SNDCTL_TMR_CONTINUE
case|:
case|case
name|SNDCTL_TMR_METRONOME
case|:
case|case
name|SNDCTL_TMR_SOURCE
case|:
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|!=
name|SEQ_2
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|tmr
operator|->
name|ioctl
argument_list|(
name|tmr_no
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
break|break;
case|case
name|SNDCTL_TMR_SELECT
case|:
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|!=
name|SEQ_2
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* notyet */
name|scp
operator|->
name|pending_timer
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|pending_timer
operator|<
literal|0
operator|||
name|scp
operator|->
name|pending_timer
operator|>=
comment|/*NTIMER*/
literal|1
condition|)
block|{
name|scp
operator|->
name|pending_timer
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|scp
operator|->
name|pending_timer
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_PANIC
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|seq_panic
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_SYNC
case|:
if|if
condition|(
name|mode
operator|==
name|O_RDONLY
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|seq_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_RESET
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|seq_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_TESTMIDI
case|:
name|midiunit
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_GETINCOUNT
case|:
if|if
condition|(
name|mode
operator|==
name|O_WRONLY
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|rl
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_GETOUTCOUNT
case|:
if|if
condition|(
name|mode
operator|==
name|O_RDONLY
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|fl
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|!=
name|SEQ_2
condition|)
block|{
name|ret
operator|=
name|tmr
operator|->
name|ioctl
argument_list|(
name|tmr_no
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* notyet */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|hz
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|midiunit
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_NRSYNTHS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|mididev_info_number
argument_list|()
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_NRMIDIS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|mididev_info_number
argument_list|()
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
name|midiunit
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
name|midiunit
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|synthinfo
operator|=
operator|(
expr|struct
name|synth_info
operator|*
operator|)
name|arg
expr_stmt|;
name|midiunit
operator|=
name|synthinfo
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_OUTOFBAND
case|:
name|event
operator|=
operator|(
expr|struct
name|seq_event_rec
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|seq_playevent
argument_list|(
name|scp
argument_list|,
name|event
operator|->
name|arr
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_MIDI_INFO
case|:
name|midiinfo
operator|=
operator|(
expr|struct
name|midi_info
operator|*
operator|)
name|arg
expr_stmt|;
name|midiunit
operator|=
name|midiinfo
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_PMGR_IFACE
case|:
name|patinfo
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|arg
expr_stmt|;
name|midiunit
operator|=
name|patinfo
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_PMGR_ACCESS
case|:
name|patinfo
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|arg
expr_stmt|;
name|midiunit
operator|=
name|patinfo
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_THRESHOLD
case|:
name|tmp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|RANGE
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|,
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|bufsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|scp
operator|->
name|output_threshould
operator|=
name|tmp
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_MIDI_PRETIME
case|:
name|tmp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
operator|(
name|hz
operator|*
name|tmp
operator|)
operator|/
literal|10
expr_stmt|;
name|scp
operator|->
name|pre_event_timeout
operator|=
name|tmp
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|scp
operator|->
name|fflags
operator|==
name|O_RDONLY
condition|)
block|{
name|ret
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|ret
operator|=
name|midi_ioctl
argument_list|(
name|MIDIMKDEV
argument_list|(
name|major
argument_list|(
name|i_dev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|seq_poll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|ret
decl_stmt|,
name|lim
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq%d: polling.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NSEQ_MAX
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_poll: unit %d does not exist.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sd
operator|=
name|get_seqdev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_poll: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Look up the apropriate queue and select it. */
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start playing. */
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
comment|/* Find out the boundary. */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
name|lim
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|blocksize
expr_stmt|;
else|else
name|lim
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|unit_size
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|<
name|lim
condition|)
comment|/* No enough space, record select. */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start recording. */
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_RD
argument_list|)
expr_stmt|;
comment|/* Find out the boundary. */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
name|lim
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|blocksize
expr_stmt|;
else|else
name|lim
operator|=
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|unit_size
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|rl
operator|<
name|lim
condition|)
comment|/* No data ready, record select. */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|sd
operator|->
name|midi_dbuf_in
operator|.
name|sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
operator|(
name|seqdev_info
operator|*
operator|)
name|p
expr_stmt|;
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Restart playing if we have the data to output. */
if|if
condition|(
name|scp
operator|->
name|queueout_pending
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
comment|/* Check the midi device if we are reading. */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_READING
operator|)
operator|!=
literal|0
condition|)
name|seq_midiinput
argument_list|(
name|scp
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_callback
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
operator|(
name|seqdev_info
operator|*
operator|)
name|d
expr_stmt|;
comment|/*DEB(printf("seq_callback: reason 0x%x.\n", reason));*/
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_callback: device not configured.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|sd
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
operator|&
name|SEQ_CB_REASON_MASK
condition|)
block|{
case|case
name|SEQ_CB_START
case|:
if|if
condition|(
operator|(
name|reason
operator|&
name|SEQ_CB_RD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_READING
operator|)
operator|==
literal|0
condition|)
comment|/* Begin recording. */
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_READING
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|&
name|SEQ_CB_WR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
condition|)
comment|/* Start playing. */
name|seq_startplay
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_CB_STOP
case|:
case|case
name|SEQ_CB_ABORT
case|:
if|if
condition|(
operator|(
name|reason
operator|&
name|SEQ_CB_RD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_READING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Stop recording. */
name|sd
operator|->
name|flags
operator|&=
operator|~
name|SEQ_F_READING
expr_stmt|;
name|scp
operator|->
name|seq_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reason
operator|&
name|SEQ_CB_WR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Stop Playing. */
name|sd
operator|->
name|flags
operator|&=
operator|~
name|SEQ_F_WRITING
expr_stmt|;
name|scp
operator|->
name|queueout_pending
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|seq_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
literal|0
expr_stmt|;
comment|/* Stop the timer. */
name|seq_stoptimer
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The functions below here are the libraries for the above ones.  */
end_comment

begin_function
specifier|static
name|int
name|seq_queue
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|note
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|err
decl_stmt|,
name|lenw
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/*DEB(printf("seq%d: queueing.\n", unit));*/
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_INSYNC
operator|)
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|sd
operator|->
name|insync_cv
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|<
name|EV_SZ
condition|)
block|{
comment|/* We have no space. Start playing if not yet. */
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_NBIO
operator|)
operator|!=
literal|0
operator|&&
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|fl
operator|<
name|EV_SZ
condition|)
comment|/* We would block. */
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Write to the queue. */
name|err
operator|=
name|midibuf_seqwrite
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|,
name|note
argument_list|,
name|EV_SZ
argument_list|,
operator|&
name|lenw
argument_list|,
name|sd
operator|->
name|callback
argument_list|,
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* Start playing if we have some data in the queue. */
if|if
condition|(
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|rl
operator|>=
name|EV_SZ
operator|&&
operator|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
operator|)
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|lenr
decl_stmt|;
name|u_char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_WRITING
expr_stmt|;
comment|/* Dequeue the events to play. */
while|while
condition|(
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|rl
operator|>=
name|EV_SZ
condition|)
block|{
name|midibuf_seqcopy
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|,
name|event
argument_list|,
name|EV_SZ
argument_list|,
operator|&
name|lenr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|seq_playevent
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
condition|)
block|{
case|case
name|TIMERARMED
case|:
name|midibuf_seqdelete
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|,
name|EV_SZ
argument_list|,
operator|&
name|lenr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return;
case|case
name|QUEUEFULL
case|:
comment|/* We cannot play any further. */
return|return;
case|case
name|MORE
case|:
name|midibuf_seqdelete
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|,
name|EV_SZ
argument_list|,
operator|&
name|lenr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Played every event in the queue. */
name|sd
operator|->
name|flags
operator|&=
operator|~
name|SEQ_F_WRITING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_playevent
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|ret
decl_stmt|,
name|lenw
decl_stmt|;
name|long
modifier|*
name|delay
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|MORE
operator|)
return|;
switch|switch
condition|(
name|event
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|killnote
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
literal|255
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
index|[
literal|4
index|]
operator|<
literal|128
operator|||
name|event
index|[
literal|4
index|]
operator|==
literal|255
operator|)
operator|&&
name|md
operator|->
name|synth
operator|.
name|startnote
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|event
index|[
literal|2
index|]
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_WAIT
case|:
comment|/* Extract the delay. */
name|delay
operator|=
operator|(
name|long
operator|*
operator|)
name|event
expr_stmt|;
operator|*
name|delay
operator|=
operator|(
operator|*
name|delay
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
operator|*
name|delay
operator|>
literal|0
condition|)
block|{
comment|/* Arm the timer. */
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_WRITING
expr_stmt|;
if|if
condition|(
name|seq_requesttimer
argument_list|(
name|scp
argument_list|,
operator|*
name|delay
argument_list|)
condition|)
block|{
name|ret
operator|=
name|TIMERARMED
expr_stmt|;
break|break;
block|}
block|}
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|setinstr
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|event
index|[
literal|2
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_SYNCTIMER
case|:
comment|/* Reset the timer. */
name|scp
operator|->
name|seq_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_wakeup_time
operator|=
name|scp
operator|->
name|seq_time
expr_stmt|;
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_MIDIPUTC
case|:
comment|/* Pass through to the midi device. */
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|event
index|[
literal|2
index|]
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|writeraw
argument_list|(
name|md
argument_list|,
operator|&
name|event
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|lenw
argument_list|,
literal|1
argument_list|)
operator|==
name|EAGAIN
condition|)
comment|/* The queue was full. Try again later. */
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
else|else
name|ret
operator|=
name|MORE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_ECHO
case|:
comment|/* Echo this event back. */
if|if
condition|(
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
name|event
argument_list|,
literal|4
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_PRIVATE
case|:
name|ret
operator|=
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|hwcontrol
argument_list|(
name|md
argument_list|,
name|event
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
case|case
name|SEQ_EXTENDED
case|:
name|ret
operator|=
name|seq_extended
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_VOICE
case|:
name|ret
operator|=
name|seq_chnvoice
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_COMMON
case|:
name|ret
operator|=
name|seq_chncommon
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_TIMING
case|:
name|ret
operator|=
name|seq_timing
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_SEQ_LOCAL
case|:
name|ret
operator|=
name|seq_local
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_SYSEX
case|:
name|ret
operator|=
name|seq_sysex
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|QUEUEFULL
case|:
comment|/*DEB(printf("seq_playevent: the queue is full.\n"));*/
comment|/* The queue was full. Try again on the interrupt by the midi device. */
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_WRITING
expr_stmt|;
name|scp
operator|->
name|queueout_pending
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TIMERARMED
case|:
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_WRITING
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MORE
case|:
name|scp
operator|->
name|queueout_pending
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|seq_gettime
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timecopy
decl_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|timecopy
argument_list|)
expr_stmt|;
return|return
name|timecopy
operator|.
name|tv_usec
operator|/
operator|(
literal|1000000
operator|/
name|hz
operator|)
operator|+
operator|(
name|u_long
operator|)
name|timecopy
operator|.
name|tv_sec
operator|*
name|hz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_requesttimer
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|u_long
name|cur_time
decl_stmt|,
name|rel_base
decl_stmt|;
comment|/*DEB(printf("seq%d: requested timer at delay of %d.\n", unit, delay));*/
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cur_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_event_time
operator|=
name|delay
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|0
condition|)
comment|/* Request a new timer. */
name|delay
operator|=
operator|-
name|delay
expr_stmt|;
else|else
block|{
name|rel_base
operator|=
name|cur_time
operator|-
name|scp
operator|->
name|seq_time
expr_stmt|;
if|if
condition|(
name|delay
operator|<=
name|rel_base
condition|)
block|{
name|seq_stoptimer
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delay
operator|-=
name|rel_base
expr_stmt|;
block|}
if|#
directive|if
name|notdef
comment|/* 	 * Compensate the delay of midi message transmission. 	 * XXX Do we have to consider the accumulation of errors 	 * less than 1/hz second? 	 */
name|delay
operator|-=
operator|(
name|cur_time
operator|-
name|scp
operator|->
name|prev_wakeup_time
operator|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"sequencer: prev = %lu, cur = %lu, delay = %d, skip sleeping.\n"
argument_list|,
name|scp
operator|->
name|prev_wakeup_time
argument_list|,
name|cur_time
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|seq_stoptimer
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* notdef */
name|callout_reset
argument_list|(
operator|&
name|scp
operator|->
name|timeout_ch
argument_list|,
name|delay
argument_list|,
name|seq_timer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|timer_running
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_stoptimer
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
comment|/*DEB(printf("seq%d: stopping timer.\n", unit));*/
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|timer_running
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|scp
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|scp
operator|->
name|timer_running
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|seq_midiinput
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|midiunit
decl_stmt|,
name|lenr
decl_stmt|;
name|u_long
name|tstamp
decl_stmt|;
name|u_char
name|event
index|[
literal|4
index|]
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
comment|/* Can this midi device interrupt for input? */
name|midiunit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
if|if
condition|(
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
name|LOOKUP_EXIST
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|md
operator|->
name|flags
operator|&
name|MIDI_F_READING
operator|)
operator|!=
literal|0
operator|&&
name|md
operator|->
name|intrarg
operator|==
name|sd
condition|)
block|{
comment|/* Read the input data. */
while|while
condition|(
name|md
operator|->
name|synth
operator|.
name|readraw
argument_list|(
name|md
argument_list|,
operator|&
name|event
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|lenr
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tstamp
operator|=
name|seq_gettime
argument_list|()
operator|-
name|scp
operator|->
name|seq_time
expr_stmt|;
if|if
condition|(
name|tstamp
operator|!=
name|scp
operator|->
name|prev_input_time
condition|)
block|{
comment|/* Insert a wait between events. */
name|tstamp
operator|=
operator|(
name|tstamp
operator|<<
literal|8
operator|)
operator||
name|SEQ_WAIT
expr_stmt|;
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tstamp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
name|tstamp
expr_stmt|;
block|}
name|event
index|[
literal|0
index|]
operator|=
name|SEQ_MIDIPUTC
expr_stmt|;
name|event
index|[
literal|2
index|]
operator|=
name|midiunit
expr_stmt|;
name|event
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
name|event
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|seq_copytoinput
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|leni
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ret
operator|=
name|midibuf_input_intr
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_in
argument_list|,
name|event
argument_list|,
name|len
argument_list|,
operator|&
name|leni
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_extended
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|event
index|[
literal|2
index|]
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MORE
operator|)
return|;
switch|switch
condition|(
name|event
index|[
literal|1
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|killnote
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|,
name|event
index|[
literal|4
index|]
argument_list|,
name|event
index|[
literal|5
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
index|[
literal|4
index|]
operator|<
literal|128
operator|||
name|event
index|[
literal|4
index|]
operator|==
literal|255
operator|)
operator|&&
name|md
operator|->
name|synth
operator|.
name|startnote
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|,
name|event
index|[
literal|4
index|]
argument_list|,
name|event
index|[
literal|5
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|setinstr
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|,
name|event
index|[
literal|4
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_AFTERTOUCH
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|aftertouch
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|,
name|event
index|[
literal|4
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_BALANCE
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|panning
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|,
operator|(
name|char
operator|)
name|event
index|[
literal|4
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_CONTROLLER
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|controller
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|,
name|event
index|[
literal|4
index|]
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|5
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_VOLMODE
case|:
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|volumemethod
operator|!=
name|NULL
operator|&&
name|md
operator|->
name|synth
operator|.
name|volumemethod
argument_list|(
name|md
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_chnvoice
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|u_char
name|dev
decl_stmt|,
name|cmd
decl_stmt|,
name|chn
decl_stmt|,
name|note
decl_stmt|,
name|parm
decl_stmt|;
name|voice
operator|=
operator|-
literal|1
expr_stmt|;
name|dev
operator|=
name|event
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|chn
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|note
operator|=
name|event
index|[
literal|4
index|]
expr_stmt|;
name|parm
operator|=
name|event
index|[
literal|5
index|]
expr_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MORE
operator|)
return|;
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|md
operator|->
name|synth
operator|.
name|allocvoice
operator|!=
name|NULL
condition|)
name|voice
operator|=
name|seq_allocvoice
argument_list|(
name|scp
argument_list|,
name|md
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_NOTEON
case|:
if|if
condition|(
name|note
operator|<
literal|128
operator|||
name|note
operator|==
literal|255
condition|)
block|{
if|#
directive|if
name|notyet
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
operator|&&
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|md
operator|->
name|synth
operator|.
name|allocvoice
condition|)
comment|/* This is an internal synthesizer. (FM, GUS, etc) */
if|if
condition|(
operator|(
name|voice
operator|=
name|seq_allocvoice
argument_list|(
name|scp
argument_list|,
name|md
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
operator|)
operator|==
name|EAGAIN
condition|)
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
endif|#
directive|endif
comment|/* notyet */
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|chn
operator|==
literal|9
condition|)
block|{
comment|/* This channel is a percussion. The note number is the patch number. */
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|setinstr
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
literal|128
operator|+
name|note
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|note
operator|=
literal|60
expr_stmt|;
comment|/* Middle C. */
block|}
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|setupvoice
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|chn
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* notyet */
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|startnote
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MIDI_NOTEOFF
case|:
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|killnote
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_KEY_PRESSURE
case|:
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|aftertouch
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|parm
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_findvoice
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
name|key
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
operator||
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|==
name|key
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_allocvoice
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|int
name|voice
decl_stmt|;
name|u_short
name|key
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
operator||
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|voice
operator|=
name|md
operator|->
name|synth
operator|.
name|allocvoice
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|note
argument_list|,
operator|&
name|md
operator|->
name|synth
operator|.
name|alloc
argument_list|)
operator|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|voice
index|]
operator|=
name|key
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|alloc_times
index|[
name|voice
index|]
operator|=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|timestamp
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|voice
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_chncommon
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|unit
comment|/*, i, val, key*/
decl_stmt|;
name|u_short
name|w14
decl_stmt|;
name|u_char
name|dev
decl_stmt|,
name|cmd
decl_stmt|,
name|chn
decl_stmt|,
name|p1
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|dev
operator|=
name|event
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|chn
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
name|event
index|[
literal|4
index|]
expr_stmt|;
name|w14
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MORE
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_PGM_CHANGE
case|:
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
operator|=
name|p1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|setinstr
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* notyet */
comment|/* For Mode 1. */
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|setinstr
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
block|}
endif|#
directive|endif
comment|/* notyet */
break|break;
case|case
name|MIDI_CTL_CHANGE
case|:
comment|/* mtx_lock(&md->giant); */
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
if|if
condition|(
name|chn
operator|<
literal|16
operator|&&
name|p1
operator|<
literal|128
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
index|]
operator|=
name|w14
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|p1
operator|<
literal|32
condition|)
comment|/* We have set the MSB, clear the LSB. */
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator|+
literal|32
index|]
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|w14
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|p1
operator|<
literal|64
condition|)
block|{
comment|/* Combine the MSB and the LSB. */
name|val
operator|=
operator|(
operator|(
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator|&
operator|~
literal|32
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator||
literal|32
index|]
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|32
expr_stmt|;
block|}
comment|/* Handle all of the notes playing on this channel. */
name|key
operator|=
operator|(
operator|(
name|int
operator|)
name|chn
operator|<<
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|==
name|key
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|controller
argument_list|(
name|md
argument_list|,
name|i
argument_list|,
name|p1
argument_list|,
name|val
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* notyet */
comment|/* For Mode 1. */
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|controller
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
block|}
endif|#
directive|endif
comment|/* notyet */
break|break;
case|case
name|MIDI_PITCH_BEND
case|:
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|bender_value
operator|=
name|w14
expr_stmt|;
comment|/* Handle all of the notes playing on this channel. */
name|key
operator|=
operator|(
operator|(
name|int
operator|)
name|chn
operator|<<
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|==
name|key
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|bender
argument_list|(
name|md
argument_list|,
name|i
argument_list|,
name|w14
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* notyet */
comment|/* For Mode 1. */
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|bender
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|w14
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
block|}
endif|#
directive|endif
comment|/* notyet */
break|break;
block|}
return|return
operator|(
name|MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_timing
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|unit
comment|/*, ret*/
decl_stmt|;
name|long
name|parm
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|parm
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
operator|&&
operator|(
name|ret
operator|=
name|tmr
operator|->
name|event
argument_list|(
name|tmr_no
argument_list|,
name|event
argument_list|)
operator|)
operator|==
name|TIMERARMED
condition|)
return|return
operator|(
name|ret
operator|)
return|;
endif|#
directive|endif
comment|/* notyet */
switch|switch
condition|(
name|event
index|[
literal|1
index|]
condition|)
block|{
case|case
name|TMR_WAIT_REL
case|:
name|parm
operator|+=
name|scp
operator|->
name|prev_event_time
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|TMR_WAIT_ABS
case|:
if|if
condition|(
name|parm
operator|>
literal|0
condition|)
block|{
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_WRITING
expr_stmt|;
if|if
condition|(
name|seq_requesttimer
argument_list|(
name|scp
argument_list|,
name|parm
argument_list|)
condition|)
return|return
operator|(
name|TIMERARMED
operator|)
return|;
block|}
break|break;
case|case
name|TMR_START
case|:
name|scp
operator|->
name|seq_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|scp
operator|->
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_wakeup_time
operator|=
name|scp
operator|->
name|seq_time
expr_stmt|;
break|break;
case|case
name|TMR_STOP
case|:
break|break;
case|case
name|TMR_CONTINUE
case|:
break|break;
case|case
name|TMR_TEMPO
case|:
break|break;
case|case
name|TMR_ECHO
case|:
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
name|event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
endif|#
directive|endif
comment|/* notyet */
name|parm
operator|=
operator|(
name|parm
operator|<<
literal|8
operator||
name|SEQ_ECHO
operator|)
expr_stmt|;
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|parm
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
block|}
endif|#
directive|endif
comment|/* notyet */
break|break;
block|}
return|return
operator|(
name|MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_local
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
index|[
literal|1
index|]
condition|)
block|{
case|case
name|LOCL_STARTAUDIO
case|:
if|#
directive|if
name|notyet
name|DMAbuf_start_devices
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
break|break;
block|}
return|return
operator|(
name|MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_sysex
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|LOOKUP_OPEN
argument_list|,
operator|&
name|md
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MORE
operator|)
return|;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
operator|&&
name|event
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0xff
condition|;
name|i
operator|++
control|)
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|sendsysex
argument_list|(
name|md
argument_list|,
operator|&
name|event
index|[
literal|2
index|]
argument_list|,
name|l
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|QUEUEFULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|scp
operator|=
name|arg
expr_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
comment|/*DEB(printf("seq_timer: timer fired.\n"));*/
comment|/* Record the current timestamp. */
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|timer_running
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|prev_wakeup_time
operator|=
name|seq_gettime
argument_list|()
expr_stmt|;
name|seq_startplay
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_openmidi
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|midiunit
decl_stmt|,
name|err
decl_stmt|,
name|insync
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|midiunit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_openmidi: opening midi unit %d.\n"
argument_list|,
name|midiunit
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|midi_open
argument_list|(
name|MIDIMKDEV
argument_list|(
name|MIDI_CDEV_MAJOR
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"seq_openmidi: failed to open midi device %d.\n"
argument_list|,
name|midiunit
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|status_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|intr
operator|=
name|seq_intr
expr_stmt|;
name|md
operator|->
name|intrarg
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|sysex_state
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|status_mtx
argument_list|)
expr_stmt|;
name|insync
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|devinfo
operator|->
name|flags
operator|&
name|SEQ_F_INSYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|insync
operator|=
literal|1
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|insync_cv
argument_list|,
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|scp
operator|->
name|midi_open
argument_list|,
name|md
argument_list|,
name|md_linkseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|insync
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|insync_cv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_closemidi
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|midiunit
decl_stmt|,
name|insync
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
operator|||
operator|!
name|MIDICONFED
argument_list|(
name|md
argument_list|)
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_closemidi: midi device does not exist.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|midiunit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"seq_closemidi: closing midi unit %d.\n"
argument_list|,
name|midiunit
argument_list|)
argument_list|)
expr_stmt|;
name|midi_close
argument_list|(
name|MIDIMKDEV
argument_list|(
name|MIDI_CDEV_MAJOR
argument_list|,
name|midiunit
argument_list|,
name|SND_DEV_MIDIN
argument_list|)
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|intr
operator|=
name|NULL
expr_stmt|;
name|md
operator|->
name|intrarg
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|insync
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|devinfo
operator|->
name|flags
operator|&
name|SEQ_F_INSYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|insync
operator|=
literal|1
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|insync_cv
argument_list|,
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|scp
operator|->
name|midi_open
argument_list|,
name|md
argument_list|,
name|md_linkseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|insync
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|insync_cv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_panic
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|seq_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_reset
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|chn
decl_stmt|,
name|lenw
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|u_char
name|c
index|[
literal|3
index|]
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|sd
operator|->
name|unit
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_INSYNC
operator|)
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|sd
operator|->
name|insync_cv
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
comment|/* Stop reading and writing. */
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_ABORT
operator||
name|SEQ_CB_RD
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
comment|/* Clear the queues. */
name|midibuf_clear
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
comment|/* Reset the synthesizers. */
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
name|md
operator|->
name|synth
operator|.
name|reset
argument_list|(
name|md
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
if|#
directive|if
name|notyet
if|if
condition|(
name|scp
operator|->
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|controller
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
literal|123
argument_list|,
literal|0
argument_list|)
operator|==
name|EAGAIN
comment|/* All notes off. */
operator|||
name|md
operator|->
name|synth
operator|.
name|controller
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
literal|121
argument_list|,
literal|0
argument_list|)
operator|==
name|EAGAIN
comment|/* Reset all controllers. */
operator|||
name|md
operator|->
name|synth
operator|.
name|bender
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
literal|1
operator|<<
literal|13
argument_list|)
operator|==
name|EAGAIN
condition|)
comment|/* Reset pitch bend. */
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* notyet */
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|c
index|[
literal|0
index|]
operator|=
literal|0xb0
operator||
operator|(
name|chn
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0x78
expr_stmt|;
comment|/* All sound off */
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|writeraw
argument_list|(
name|md
argument_list|,
name|c
argument_list|,
literal|3
argument_list|,
operator|&
name|lenw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0x7b
expr_stmt|;
comment|/* All note off */
name|md
operator|->
name|synth
operator|.
name|writeraw
argument_list|(
name|md
argument_list|,
name|c
argument_list|,
literal|3
argument_list|,
operator|&
name|lenw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0x79
expr_stmt|;
comment|/* Reset all controller */
name|md
operator|->
name|synth
operator|.
name|writeraw
argument_list|(
name|md
argument_list|,
name|c
argument_list|,
literal|3
argument_list|,
operator|&
name|lenw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|seq_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
name|lookup_mididev
argument_list|(
name|scp
argument_list|,
name|md
operator|->
name|unit
argument_list|,
name|LOOKUP_CLOSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
block|}
endif|#
directive|endif
comment|/* notyet */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SEQ_SYNC_TIMEOUT
value|8
end_define

begin_function
specifier|static
name|int
name|seq_sync
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rl
decl_stmt|;
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|sd
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sd
operator|->
name|flags
operator||=
name|SEQ_F_INSYNC
expr_stmt|;
while|while
condition|(
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|rl
operator|>=
name|EV_SZ
condition|)
block|{
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|SEQ_F_WRITING
operator|)
operator|==
literal|0
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_START
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|rl
operator|=
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|rl
expr_stmt|;
name|i
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|cv_out
argument_list|,
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|,
name|SEQ_SYNC_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EINTR
operator|||
name|i
operator|==
name|ERESTART
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|EINTR
condition|)
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_STOP
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|sd
operator|->
name|flags
operator|&=
operator|~
name|SEQ_F_INSYNC
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
name|EWOULDBLOCK
operator|&&
name|rl
operator|==
name|sd
operator|->
name|midi_dbuf_out
operator|.
name|rl
operator|&&
operator|!
name|scp
operator|->
name|timer_running
condition|)
block|{
comment|/* A queue seems to be stuck up. Give up and clear queues. */
name|sd
operator|->
name|callback
argument_list|(
name|sd
argument_list|,
name|SEQ_CB_STOP
operator||
name|SEQ_CB_WR
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|sd
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|callback
argument_list|(
name|md
argument_list|,
name|MIDI_CB_ABORT
operator||
name|MIDI_CB_WR
argument_list|)
expr_stmt|;
name|midibuf_clear
argument_list|(
operator|&
name|md
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 	 * Since syncing a midi device might block, unlock sd->flagqueue_mtx. 	 * Keep sd->midi_dbuf_out from writing by setting SEQ_F_INSYNC. 	 * sd->insync_cv is signalled when sync is finished. 	 */
name|mtx_unlock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|midi_sync
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sd
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|sd
operator|->
name|flags
operator|&=
operator|~
name|SEQ_F_INSYNC
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|sd
operator|->
name|insync_cv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a device number, returns  * a pointer to the associated seqdev_info struct, and sets the unit  * number.  */
end_comment

begin_function
specifier|static
name|seqdev_info
modifier|*
name|get_seqdev_info
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|u
decl_stmt|;
if|if
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
operator|!=
name|SND_DEV_SEQ
operator|&&
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
operator|!=
name|SND_DEV_SEQ2
condition|)
return|return
name|NULL
return|;
name|u
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
condition|)
operator|*
name|unit
operator|=
name|u
expr_stmt|;
return|return
name|get_seqdev_info_unit
argument_list|(
name|u
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a unit number, returns  * a pointer to the associated mididev_info struct.  */
end_comment

begin_function
name|seqdev_info
modifier|*
name|get_seqdev_info_unit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|seqdev_info
modifier|*
name|sd
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&seq_info
argument_list|,
argument|sd_link
argument_list|)
block|{
if|if
condition|(
name|sd
operator|->
name|unit
operator|==
name|unit
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/* Create a new sequencer device info structure. */
end_comment

begin_function
name|seqdev_info
modifier|*
name|create_seqdev_info_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|seqdev_info
modifier|*
name|seq
parameter_list|)
block|{
name|seqdev_info
modifier|*
name|sd
decl_stmt|,
modifier|*
name|sdnew
decl_stmt|;
comment|/* As malloc(9) might block, allocate seqdev_info now. */
name|sdnew
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|seqdev_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdnew
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
name|seq
argument_list|,
name|sdnew
argument_list|,
sizeof|sizeof
argument_list|(
name|seqdev_info
argument_list|)
argument_list|)
expr_stmt|;
name|sdnew
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|sdnew
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
name|midibuf_init
argument_list|(
operator|&
name|sdnew
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sdnew
operator|->
name|flagqueue_mtx
argument_list|,
literal|"seqflq"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sdnew
operator|->
name|insync_cv
argument_list|,
literal|"seqins"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&seq_info
argument_list|,
argument|sd_link
argument_list|)
block|{
if|if
condition|(
name|sd
operator|->
name|unit
operator|==
name|unit
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
name|midibuf_destroy
argument_list|(
operator|&
name|sdnew
operator|->
name|midi_dbuf_in
argument_list|)
expr_stmt|;
name|midibuf_destroy
argument_list|(
operator|&
name|sdnew
operator|->
name|midi_dbuf_out
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sdnew
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sdnew
operator|->
name|insync_cv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdnew
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|sdnew
operator|->
name|flagqueue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|seq_info
argument_list|,
name|sdnew
argument_list|,
name|sd_link
argument_list|)
expr_stmt|;
name|nseq
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
return|return
name|sdnew
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a midi device by its unit number opened by this sequencer.  * If the device is not opened and mode is LOOKUP_OPEN, open the device.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_mididev
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|mode
parameter_list|,
name|mididev_info
modifier|*
modifier|*
name|mdp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
if|if
condition|(
name|mdp
operator|==
name|NULL
condition|)
name|mdp
operator|=
operator|&
name|md
expr_stmt|;
operator|*
name|mdp
operator|=
name|NULL
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&scp->midi_open
argument_list|,
argument|md_linkseq
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|unit
operator|==
name|unit
condition|)
block|{
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|LOOKUP_CLOSE
condition|)
return|return
name|seq_closemidi
argument_list|(
name|scp
argument_list|,
name|md
argument_list|,
name|scp
operator|->
name|fflags
argument_list|,
name|MIDIDEV_MODE
argument_list|,
name|curthread
argument_list|)
return|;
return|return
operator|(
name|md
operator|!=
name|NULL
operator|&&
name|MIDICONFED
argument_list|(
name|md
argument_list|)
operator|)
condition|?
literal|0
else|:
name|ENXIO
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|LOOKUP_OPEN
condition|)
block|{
name|md
operator|=
name|get_mididev_info_unit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mdp
operator|=
name|md
expr_stmt|;
name|ret
operator|=
name|seq_openmidi
argument_list|(
name|scp
argument_list|,
name|md
argument_list|,
name|scp
operator|->
name|fflags
argument_list|,
name|MIDIDEV_MODE
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/* XXX These functions are actually redundant. */
end_comment

begin_function
specifier|static
name|int
name|seqopen
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_SEQ
case|:
return|return
name|seq_open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seqclose
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_SEQ
case|:
return|return
name|seq_close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seqread
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_SEQ
case|:
return|return
name|seq_read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seqwrite
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_SEQ
case|:
return|return
name|seq_write
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seqioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_SEQ
case|:
return|return
name|seq_ioctl
argument_list|(
name|i_dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|td
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seqpoll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
switch|switch
condition|(
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
condition|)
block|{
case|case
name|MIDI_DEV_SEQ
case|:
return|return
name|seq_poll
argument_list|(
name|i_dev
argument_list|,
name|events
argument_list|,
name|td
argument_list|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|seq_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|printf
argument_list|(
literal|"sequencer: unload not supported yet.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|seq
argument_list|,
name|seq_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|seq_clone
parameter_list|(
name|arg
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|dev
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|dev_t
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|u
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NODEV
condition|)
return|return;
if|if
condition|(
name|bcmp
argument_list|(
name|name
argument_list|,
literal|"sequencer"
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|name
index|[
literal|10
index|]
operator|!=
literal|'\0'
operator|&&
name|name
index|[
literal|11
index|]
operator|!=
literal|'\0'
condition|)
return|return;
name|u
operator|=
name|name
index|[
literal|9
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|10
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|u
operator|*=
literal|10
expr_stmt|;
name|u
operator|+=
name|name
index|[
literal|10
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
name|seq_initunit
argument_list|(
name|u
argument_list|)
expr_stmt|;
operator|*
name|dev
operator|=
name|MIDIMKDEV
argument_list|(
name|SEQ_CDEV_MAJOR
argument_list|,
name|u
argument_list|,
name|MIDI_DEV_SEQ
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

