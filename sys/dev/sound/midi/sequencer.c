begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Mathew Kanner  * Copyright (c) 1993 Hannu Savolainen  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * The sequencer personality manager.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* for DATA_SET */
end_comment

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* for DELAY */
end_comment

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/midiq.h>
end_include

begin_include
include|#
directive|include
file|"synth_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/sound/midi/sequencer.h>
end_include

begin_define
define|#
directive|define
name|TMR_TIMERBASE
value|13
end_define

begin_define
define|#
directive|define
name|SND_DEV_SEQ
value|1
end_define

begin_comment
comment|/* Sequencer output /dev/sequencer (FM 					 * synthesizer and MIDI output) */
end_comment

begin_define
define|#
directive|define
name|SND_DEV_MUSIC
value|8
end_define

begin_comment
comment|/* /dev/music, level 2 interface */
end_comment

begin_comment
comment|/* Length of a sequencer event. */
end_comment

begin_define
define|#
directive|define
name|EV_SZ
value|8
end_define

begin_define
define|#
directive|define
name|IEV_SZ
value|8
end_define

begin_comment
comment|/* Lookup modes */
end_comment

begin_define
define|#
directive|define
name|LOOKUP_EXIST
value|(0)
end_define

begin_define
define|#
directive|define
name|LOOKUP_OPEN
value|(1)
end_define

begin_define
define|#
directive|define
name|LOOKUP_CLOSE
value|(2)
end_define

begin_define
define|#
directive|define
name|PCMMKMINOR
parameter_list|(
name|u
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|)
define|\
value|((((c)& 0xff)<< 16) | (((u)& 0x0f)<< 4) | ((d)& 0x0f))
end_define

begin_define
define|#
directive|define
name|MIDIMKMINOR
parameter_list|(
name|u
parameter_list|,
name|d
parameter_list|,
name|c
parameter_list|)
value|PCMMKMINOR(u, d, c)
end_define

begin_define
define|#
directive|define
name|MIDIUNIT
parameter_list|(
name|y
parameter_list|)
value|((minor(y)>> 4)& 0x0f)
end_define

begin_define
define|#
directive|define
name|MIDIDEV
parameter_list|(
name|y
parameter_list|)
value|(minor(y)& 0x0f)
end_define

begin_comment
comment|/* These are the entries to the sequencer driver. */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|seq_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|seq_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|seq_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|seq_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|seq_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|seq_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|seq_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|seq_open
block|,
operator|.
name|d_close
operator|=
name|seq_close
block|,
operator|.
name|d_read
operator|=
name|seq_read
block|,
operator|.
name|d_write
operator|=
name|seq_write
block|,
operator|.
name|d_ioctl
operator|=
name|seq_ioctl
block|,
operator|.
name|d_poll
operator|=
name|seq_poll
block|,
operator|.
name|d_name
operator|=
literal|"sequencer"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|seq_softc
block|{
name|KOBJ_FIELDS
expr_stmt|;
name|struct
name|mtx
name|seq_lock
decl_stmt|,
name|q_lock
decl_stmt|;
name|struct
name|cv
name|empty_cv
decl_stmt|,
name|reset_cv
decl_stmt|,
name|in_cv
decl_stmt|,
name|out_cv
decl_stmt|,
name|state_cv
decl_stmt|,
name|th_cv
decl_stmt|;
name|MIDIQ_HEAD
argument_list|(
argument_list|,
argument|u_char
argument_list|)
name|in_q
operator|,
name|out_q
expr_stmt|;
name|u_long
name|flags
decl_stmt|;
comment|/* Flags (protected by flag_mtx of mididev_info) */
name|int
name|fflags
decl_stmt|;
comment|/* Access mode */
name|int
name|music
decl_stmt|;
name|int
name|out_water
decl_stmt|;
comment|/* Sequence output threshould */
name|snd_sync_parm
name|sync_parm
decl_stmt|;
comment|/* AIOSYNC parameter set */
name|struct
name|thread
modifier|*
name|sync_thread
decl_stmt|;
comment|/* AIOSYNCing thread */
name|struct
name|selinfo
name|in_sel
decl_stmt|,
name|out_sel
decl_stmt|;
name|int
name|midi_number
decl_stmt|;
name|struct
name|cdev
modifier|*
name|seqdev
decl_stmt|,
modifier|*
name|musicdev
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|maxunits
decl_stmt|;
name|kobj_t
modifier|*
name|midis
decl_stmt|;
name|int
modifier|*
name|midi_flags
decl_stmt|;
name|kobj_t
name|mapper
decl_stmt|;
name|void
modifier|*
name|mapper_cookie
decl_stmt|;
name|struct
name|timeval
name|timerstop
decl_stmt|,
name|timersub
decl_stmt|;
name|int
name|timerbase
decl_stmt|,
name|tempo
decl_stmt|;
name|int
name|timerrun
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|playing
decl_stmt|;
name|int
name|recording
decl_stmt|;
name|int
name|busy
decl_stmt|;
name|int
name|pre_event_timeout
decl_stmt|;
name|int
name|waiting
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Module specific stuff, including how many sequecers  * we currently own.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw_midi
argument_list|,
name|OID_AUTO
argument_list|,
name|seq
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Midi sequencer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|seq_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: should this be moved into debug.midi? */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_midi_seq
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seq_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|midi_cmdtab
name|cmdtab_seqevent
index|[]
init|=
block|{
block|{
name|SEQ_NOTEOFF
block|,
literal|"SEQ_NOTEOFF"
block|}
block|,
block|{
name|SEQ_NOTEON
block|,
literal|"SEQ_NOTEON"
block|}
block|,
block|{
name|SEQ_WAIT
block|,
literal|"SEQ_WAIT"
block|}
block|,
block|{
name|SEQ_PGMCHANGE
block|,
literal|"SEQ_PGMCHANGE"
block|}
block|,
block|{
name|SEQ_SYNCTIMER
block|,
literal|"SEQ_SYNCTIMER"
block|}
block|,
block|{
name|SEQ_MIDIPUTC
block|,
literal|"SEQ_MIDIPUTC"
block|}
block|,
block|{
name|SEQ_DRUMON
block|,
literal|"SEQ_DRUMON"
block|}
block|,
block|{
name|SEQ_DRUMOFF
block|,
literal|"SEQ_DRUMOFF"
block|}
block|,
block|{
name|SEQ_ECHO
block|,
literal|"SEQ_ECHO"
block|}
block|,
block|{
name|SEQ_AFTERTOUCH
block|,
literal|"SEQ_AFTERTOUCH"
block|}
block|,
block|{
name|SEQ_CONTROLLER
block|,
literal|"SEQ_CONTROLLER"
block|}
block|,
block|{
name|SEQ_BALANCE
block|,
literal|"SEQ_BALANCE"
block|}
block|,
block|{
name|SEQ_VOLMODE
block|,
literal|"SEQ_VOLMODE"
block|}
block|,
block|{
name|SEQ_FULLSIZE
block|,
literal|"SEQ_FULLSIZE"
block|}
block|,
block|{
name|SEQ_PRIVATE
block|,
literal|"SEQ_PRIVATE"
block|}
block|,
block|{
name|SEQ_EXTENDED
block|,
literal|"SEQ_EXTENDED"
block|}
block|,
block|{
name|EV_SEQ_LOCAL
block|,
literal|"EV_SEQ_LOCAL"
block|}
block|,
block|{
name|EV_TIMING
block|,
literal|"EV_TIMING"
block|}
block|,
block|{
name|EV_CHN_COMMON
block|,
literal|"EV_CHN_COMMON"
block|}
block|,
block|{
name|EV_CHN_VOICE
block|,
literal|"EV_CHN_VOICE"
block|}
block|,
block|{
name|EV_SYSEX
block|,
literal|"EV_SYSEX"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|midi_cmdtab
name|cmdtab_seqioctl
index|[]
init|=
block|{
block|{
name|SNDCTL_SEQ_RESET
block|,
literal|"SNDCTL_SEQ_RESET"
block|}
block|,
block|{
name|SNDCTL_SEQ_SYNC
block|,
literal|"SNDCTL_SEQ_SYNC"
block|}
block|,
block|{
name|SNDCTL_SYNTH_INFO
block|,
literal|"SNDCTL_SYNTH_INFO"
block|}
block|,
block|{
name|SNDCTL_SEQ_CTRLRATE
block|,
literal|"SNDCTL_SEQ_CTRLRATE"
block|}
block|,
block|{
name|SNDCTL_SEQ_GETOUTCOUNT
block|,
literal|"SNDCTL_SEQ_GETOUTCOUNT"
block|}
block|,
block|{
name|SNDCTL_SEQ_GETINCOUNT
block|,
literal|"SNDCTL_SEQ_GETINCOUNT"
block|}
block|,
block|{
name|SNDCTL_SEQ_PERCMODE
block|,
literal|"SNDCTL_SEQ_PERCMODE"
block|}
block|,
block|{
name|SNDCTL_FM_LOAD_INSTR
block|,
literal|"SNDCTL_FM_LOAD_INSTR"
block|}
block|,
block|{
name|SNDCTL_SEQ_TESTMIDI
block|,
literal|"SNDCTL_SEQ_TESTMIDI"
block|}
block|,
block|{
name|SNDCTL_SEQ_RESETSAMPLES
block|,
literal|"SNDCTL_SEQ_RESETSAMPLES"
block|}
block|,
block|{
name|SNDCTL_SEQ_NRSYNTHS
block|,
literal|"SNDCTL_SEQ_NRSYNTHS"
block|}
block|,
block|{
name|SNDCTL_SEQ_NRMIDIS
block|,
literal|"SNDCTL_SEQ_NRMIDIS"
block|}
block|,
block|{
name|SNDCTL_SEQ_GETTIME
block|,
literal|"SNDCTL_SEQ_GETTIME"
block|}
block|,
block|{
name|SNDCTL_MIDI_INFO
block|,
literal|"SNDCTL_MIDI_INFO"
block|}
block|,
block|{
name|SNDCTL_SEQ_THRESHOLD
block|,
literal|"SNDCTL_SEQ_THRESHOLD"
block|}
block|,
block|{
name|SNDCTL_SYNTH_MEMAVL
block|,
literal|"SNDCTL_SYNTH_MEMAVL"
block|}
block|,
block|{
name|SNDCTL_FM_4OP_ENABLE
block|,
literal|"SNDCTL_FM_4OP_ENABLE"
block|}
block|,
block|{
name|SNDCTL_PMGR_ACCESS
block|,
literal|"SNDCTL_PMGR_ACCESS"
block|}
block|,
block|{
name|SNDCTL_SEQ_PANIC
block|,
literal|"SNDCTL_SEQ_PANIC"
block|}
block|,
block|{
name|SNDCTL_SEQ_OUTOFBAND
block|,
literal|"SNDCTL_SEQ_OUTOFBAND"
block|}
block|,
block|{
name|SNDCTL_TMR_TIMEBASE
block|,
literal|"SNDCTL_TMR_TIMEBASE"
block|}
block|,
block|{
name|SNDCTL_TMR_START
block|,
literal|"SNDCTL_TMR_START"
block|}
block|,
block|{
name|SNDCTL_TMR_STOP
block|,
literal|"SNDCTL_TMR_STOP"
block|}
block|,
block|{
name|SNDCTL_TMR_CONTINUE
block|,
literal|"SNDCTL_TMR_CONTINUE"
block|}
block|,
block|{
name|SNDCTL_TMR_TEMPO
block|,
literal|"SNDCTL_TMR_TEMPO"
block|}
block|,
block|{
name|SNDCTL_TMR_SOURCE
block|,
literal|"SNDCTL_TMR_SOURCE"
block|}
block|,
block|{
name|SNDCTL_TMR_METRONOME
block|,
literal|"SNDCTL_TMR_METRONOME"
block|}
block|,
block|{
name|SNDCTL_TMR_SELECT
block|,
literal|"SNDCTL_TMR_SELECT"
block|}
block|,
block|{
name|SNDCTL_MIDI_PRETIME
block|,
literal|"SNDCTL_MIDI_PRETIME"
block|}
block|,
block|{
name|AIONWRITE
block|,
literal|"AIONWRITE"
block|}
block|,
block|{
name|AIOGSIZE
block|,
literal|"AIOGSIZE"
block|}
block|,
block|{
name|AIOSSIZE
block|,
literal|"AIOSSIZE"
block|}
block|,
block|{
name|AIOGFMT
block|,
literal|"AIOGFMT"
block|}
block|,
block|{
name|AIOSFMT
block|,
literal|"AIOSFMT"
block|}
block|,
block|{
name|AIOGMIX
block|,
literal|"AIOGMIX"
block|}
block|,
block|{
name|AIOSMIX
block|,
literal|"AIOSMIX"
block|}
block|,
block|{
name|AIOSTOP
block|,
literal|"AIOSTOP"
block|}
block|,
block|{
name|AIOSYNC
block|,
literal|"AIOSYNC"
block|}
block|,
block|{
name|AIOGCAP
block|,
literal|"AIOGCAP"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|midi_cmdtab
name|cmdtab_timer
index|[]
init|=
block|{
block|{
name|TMR_WAIT_REL
block|,
literal|"TMR_WAIT_REL"
block|}
block|,
block|{
name|TMR_WAIT_ABS
block|,
literal|"TMR_WAIT_ABS"
block|}
block|,
block|{
name|TMR_STOP
block|,
literal|"TMR_STOP"
block|}
block|,
block|{
name|TMR_START
block|,
literal|"TMR_START"
block|}
block|,
block|{
name|TMR_CONTINUE
block|,
literal|"TMR_CONTINUE"
block|}
block|,
block|{
name|TMR_TEMPO
block|,
literal|"TMR_TEMPO"
block|}
block|,
block|{
name|TMR_ECHO
block|,
literal|"TMR_ECHO"
block|}
block|,
block|{
name|TMR_CLOCK
block|,
literal|"TMR_CLOCK"
block|}
block|,
block|{
name|TMR_SPP
block|,
literal|"TMR_SPP"
block|}
block|,
block|{
name|TMR_TIMESIG
block|,
literal|"TMR_TIMESIG"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|midi_cmdtab
name|cmdtab_seqcv
index|[]
init|=
block|{
block|{
name|MIDI_NOTEOFF
block|,
literal|"MIDI_NOTEOFF"
block|}
block|,
block|{
name|MIDI_NOTEON
block|,
literal|"MIDI_NOTEON"
block|}
block|,
block|{
name|MIDI_KEY_PRESSURE
block|,
literal|"MIDI_KEY_PRESSURE"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|midi_cmdtab
name|cmdtab_seqccmn
index|[]
init|=
block|{
block|{
name|MIDI_CTL_CHANGE
block|,
literal|"MIDI_CTL_CHANGE"
block|}
block|,
block|{
name|MIDI_PGM_CHANGE
block|,
literal|"MIDI_PGM_CHANGE"
block|}
block|,
block|{
name|MIDI_CHN_PRESSURE
block|,
literal|"MIDI_CHN_PRESSURE"
block|}
block|,
block|{
name|MIDI_PITCH_BEND
block|,
literal|"MIDI_PITCH_BEND"
block|}
block|,
block|{
name|MIDI_SYSTEM_PREFIX
block|,
literal|"MIDI_SYSTEM_PREFIX"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * static const char *mpu401_mprovider(kobj_t obj, struct mpu401 *m);  */
end_comment

begin_decl_stmt
specifier|static
name|kobj_method_t
name|seq_methods
index|[]
init|=
block|{
comment|/* KOBJMETHOD(mpu_provider,mpu401_mprovider), */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS
argument_list|(
name|sequencer
argument_list|,
name|seq_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The followings are the local function. */
end_comment

begin_function_decl
specifier|static
name|int
name|seq_convertold
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|,
name|u_char
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * static void seq_midiinput(struct seq_softc * scp, void *md);  */
end_comment

begin_function_decl
specifier|static
name|void
name|seq_reset
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sync
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_processevent
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_timing
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_local
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_chnvoice
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|kobj_t
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_chncommon
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|kobj_t
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sysex
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|kobj_t
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_fetch_mid
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|int
name|unit
parameter_list|,
name|kobj_t
modifier|*
name|md
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|seq_copytoinput
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|seq_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|seq_softc
modifier|*
name|seqs
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|seqinfo_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|nseq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|timer_start
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timer_stop
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timer_setvals
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|,
name|int
name|tempo
parameter_list|,
name|int
name|timerbase
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timer_wait
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|,
name|int
name|ticks
parameter_list|,
name|int
name|wait_abs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|timer_now
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|timer_start
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|timerrun
operator|=
literal|1
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|t
operator|->
name|timersub
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_continue
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|timerrun
operator|==
literal|1
condition|)
return|return;
name|t
operator|->
name|timerrun
operator|=
literal|1
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|t
operator|->
name|timerstop
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|t
operator|->
name|timersub
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_stop
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|timerrun
operator|=
literal|0
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|t
operator|->
name|timerstop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_setvals
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|,
name|int
name|tempo
parameter_list|,
name|int
name|timerbase
parameter_list|)
block|{
name|t
operator|->
name|tempo
operator|=
name|tempo
expr_stmt|;
name|t
operator|->
name|timerbase
operator|=
name|timerbase
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|timer_wait
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|,
name|int
name|ticks
parameter_list|,
name|int
name|wait_abs
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|,
name|when
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|long
name|i
decl_stmt|;
while|while
condition|(
name|t
operator|->
name|timerrun
operator|==
literal|0
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"Timer wait when timer isn't running\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	         * The old sequencer used timeouts that only increased 	         * the timer when the timer was running. 	         * Hence the sequencer would stick (?) if the 	         * timer was disabled. 	         */
name|cv_wait
argument_list|(
operator|&
name|t
operator|->
name|reset_cv
argument_list|,
operator|&
name|t
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|playing
operator|==
literal|0
condition|)
return|return;
block|}
name|i
operator|=
name|ticks
operator|*
literal|60ull
operator|*
literal|1000000ull
operator|/
operator|(
name|t
operator|->
name|tempo
operator|*
name|t
operator|->
name|timerbase
operator|)
expr_stmt|;
name|when
operator|.
name|tv_sec
operator|=
name|i
operator|/
literal|1000000
expr_stmt|;
name|when
operator|.
name|tv_usec
operator|=
name|i
operator|%
literal|1000000
expr_stmt|;
if|#
directive|if
literal|0
block|printf("timer_wait tempo %d timerbase %d ticks %d abs %d u_sec %llu\n", 	    t->tempo, t->timerbase, ticks, wait_abs, i);
endif|#
directive|endif
if|if
condition|(
name|wait_abs
operator|!=
literal|0
condition|)
block|{
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|t
operator|->
name|timersub
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|when
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|when
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|when
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_timer error negative time %lds.%06lds\n"
argument_list|,
operator|(
name|long
operator|)
name|when
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|when
operator|.
name|tv_usec
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|when
operator|.
name|tv_sec
operator|*
literal|1000000ull
expr_stmt|;
name|i
operator|+=
name|when
operator|.
name|tv_usec
expr_stmt|;
name|i
operator|*=
name|hz
expr_stmt|;
name|i
operator|/=
literal|1000000ull
expr_stmt|;
if|#
directive|if
literal|0
block|printf("seq_timer usec %llu ticks %llu\n", 	    when.tv_sec * 1000000ull + when.tv_usec, i);
endif|#
directive|endif
name|t
operator|->
name|waiting
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|t
operator|->
name|reset_cv
argument_list|,
operator|&
name|t
operator|->
name|seq_lock
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|EWOULDBLOCK
condition|)
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_timer didn't timeout\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|timer_now
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|long
name|long
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|timerrun
operator|==
literal|0
condition|)
name|now
operator|=
name|t
operator|->
name|timerstop
expr_stmt|;
else|else
name|getmicrotime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|t
operator|->
name|timersub
argument_list|)
expr_stmt|;
name|i
operator|=
name|now
operator|.
name|tv_sec
operator|*
literal|1000000ull
expr_stmt|;
name|i
operator|+=
name|now
operator|.
name|tv_usec
expr_stmt|;
name|i
operator|*=
name|t
operator|->
name|timerbase
expr_stmt|;
comment|/*	i /= t->tempo; */
name|i
operator|/=
literal|1000000ull
expr_stmt|;
name|ret
operator|=
name|i
expr_stmt|;
comment|/* 	 * printf("timer_now: %llu %d\n", i, ret); 	 */
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_eventthread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|arg
decl_stmt|;
name|char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_eventthread started\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|scp
operator|->
name|done
operator|==
literal|0
condition|)
block|{
name|restart
label|:
while|while
condition|(
name|scp
operator|->
name|playing
operator|==
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|,
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|done
condition|)
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|MIDIQ_EMPTY
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|empty_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|,
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|playing
operator|==
literal|0
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|scp
operator|->
name|done
condition|)
goto|goto
name|done
goto|;
block|}
name|MIDIQ_DEQ
argument_list|(
name|scp
operator|->
name|out_q
argument_list|,
name|event
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
operator|<
name|scp
operator|->
name|out_water
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|scp
operator|->
name|out_sel
argument_list|)
expr_stmt|;
block|}
name|seq_processevent
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|th_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_eventthread finished\n"
argument_list|)
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * seq_processevent:  This maybe called by the event thread or the IOCTL  * handler for queued and out of band events respectively.  */
end_comment

begin_function
specifier|static
name|int
name|seq_processevent
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|kobj_t
name|m
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|==
name|EV_SEQ_LOCAL
condition|)
name|ret
operator|=
name|seq_local
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|==
name|EV_TIMING
condition|)
name|ret
operator|=
name|seq_timing
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|!=
name|EV_CHN_VOICE
operator|&&
name|event
index|[
literal|0
index|]
operator|!=
name|EV_CHN_COMMON
operator|&&
name|event
index|[
literal|0
index|]
operator|!=
name|EV_SYSEX
operator|&&
name|event
index|[
literal|0
index|]
operator|!=
name|SEQ_MIDIPUTC
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_processevent not known %d\n"
argument_list|,
name|event
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seq_fetch_mid
argument_list|(
name|scp
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
operator|&
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_processevent midi unit not found %d\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|event
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EV_CHN_VOICE
case|:
name|ret
operator|=
name|seq_chnvoice
argument_list|(
name|scp
argument_list|,
name|m
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_COMMON
case|:
name|ret
operator|=
name|seq_chncommon
argument_list|(
name|scp
argument_list|,
name|m
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_SYSEX
case|:
name|ret
operator|=
name|seq_sysex
argument_list|(
name|scp
argument_list|,
name|m
argument_list|,
name|event
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_MIDIPUTC
case|:
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|SYNTH_WRITERAW
argument_list|(
name|m
argument_list|,
operator|&
name|event
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_addunit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|seq_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
comment|/* Allocate the softc. */
name|ret
operator|=
name|ENOMEM
expr_stmt|;
name|scp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_addunit: softc allocation failed.\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|kobj_init
argument_list|(
operator|(
name|kobj_t
operator|)
name|scp
argument_list|,
operator|&
name|sequencer_class
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
operator|*
name|EV_SZ
operator|*
literal|1024
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|MIDIQ_INIT
argument_list|(
name|scp
operator|->
name|in_q
argument_list|,
name|buf
argument_list|,
name|EV_SZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
operator|*
name|EV_SZ
operator|*
literal|1024
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|MIDIQ_INIT
argument_list|(
name|scp
operator|->
name|out_q
argument_list|,
name|buf
argument_list|,
name|EV_SZ
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|scp
operator|->
name|midis
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|kobj_t
argument_list|)
operator|*
literal|32
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|scp
operator|->
name|midi_flags
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scp
operator|->
name|midi_flags
argument_list|)
operator|*
literal|32
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|midis
operator|==
name|NULL
operator|||
name|scp
operator|->
name|midi_flags
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|scp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
literal|"seqflq"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|,
literal|"seqstate"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scp
operator|->
name|empty_cv
argument_list|,
literal|"seqempty"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|,
literal|"seqtimer"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|,
literal|"seqqout"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scp
operator|->
name|in_cv
argument_list|,
literal|"seqqin"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scp
operator|->
name|th_cv
argument_list|,
literal|"seqstart"
argument_list|)
expr_stmt|;
comment|/* 	 * Init the damn timer 	 */
name|scp
operator|->
name|mapper
operator|=
name|midimapper_addseq
argument_list|(
name|scp
argument_list|,
operator|&
name|scp
operator|->
name|unit
argument_list|,
operator|&
name|scp
operator|->
name|mapper_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mapper
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|scp
operator|->
name|seqdev
operator|=
name|make_dev
argument_list|(
operator|&
name|seq_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
name|scp
operator|->
name|unit
argument_list|,
name|SND_DEV_SEQ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"sequencer%d"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
name|scp
operator|->
name|musicdev
operator|=
name|make_dev
argument_list|(
operator|&
name|seq_cdevsw
argument_list|,
name|MIDIMKMINOR
argument_list|(
name|scp
operator|->
name|unit
argument_list|,
name|SND_DEV_MUSIC
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"music%d"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|seqdev
operator|==
name|NULL
operator|||
name|scp
operator|->
name|musicdev
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * TODO: Add to list of sequencers this module provides 	 */
name|ret
operator|=
name|kthread_create
argument_list|(
name|seq_eventthread
argument_list|,
name|scp
argument_list|,
name|NULL
argument_list|,
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"sequencer %02d"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|scp
operator|->
name|seqdev
operator|->
name|si_drv1
operator|=
name|scp
operator|->
name|musicdev
operator|->
name|si_drv1
operator|=
name|scp
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"sequencer %d created scp %p\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|scp
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
name|seqs
index|[
name|nseq
operator|++
index|]
operator|=
name|scp
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
goto|goto
name|ok
goto|;
name|err
label|:
if|if
condition|(
name|scp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|seqdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|scp
operator|->
name|seqdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|musicdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|scp
operator|->
name|musicdev
argument_list|)
expr_stmt|;
comment|/* 	         * TODO: Destroy mutex and cv 	         */
if|if
condition|(
name|scp
operator|->
name|midis
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|midis
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|midi_flags
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|midi_flags
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|out_q
operator|.
name|b
condition|)
name|free
argument_list|(
name|scp
operator|->
name|out_q
operator|.
name|b
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|in_q
operator|.
name|b
condition|)
name|free
argument_list|(
name|scp
operator|->
name|in_q
operator|.
name|b
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|ok
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_delunit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|seqs
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|//SEQ_DEBUG(4, printf("seq_delunit: %d\n", unit));
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 1 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|scp
operator|->
name|playing
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 2 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|scp
operator|->
name|th_cv
argument_list|,
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 3.0 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 3.1 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 4 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scp
operator|->
name|empty_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 5 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 6 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 7 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scp
operator|->
name|in_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 8 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scp
operator|->
name|th_cv
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 10 \n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|seqdev
condition|)
name|destroy_dev
argument_list|(
name|scp
operator|->
name|seqdev
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 11 \n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|musicdev
condition|)
name|destroy_dev
argument_list|(
name|scp
operator|->
name|musicdev
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 12 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|seqdev
operator|=
name|scp
operator|->
name|musicdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|midis
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|midis
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 13 \n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|midi_flags
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|midi_flags
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 14 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
operator|->
name|out_q
operator|.
name|b
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 15 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
operator|->
name|in_q
operator|.
name|b
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 16 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_delunit: 17 \n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|unit
init|;
name|i
operator|<
operator|(
name|nseq
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|seqs
index|[
name|i
index|]
operator|=
name|seqs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|nseq
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|seq_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|r
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|,
literal|"seqmod"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|seq_addunit
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
while|while
condition|(
name|nseq
condition|)
block|{
name|r
operator|=
name|seq_delunit
argument_list|(
name|nseq
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|retval
operator|=
name|r
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nseq
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|seqinfo_mtx
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_fetch_mid
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|int
name|unit
parameter_list|,
name|kobj_t
modifier|*
name|md
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|>
name|scp
operator|->
name|midi_number
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
name|md
operator|=
name|scp
operator|->
name|midis
index|[
name|unit
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|seq_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_open: scp %p unit %d, flags 0x%x.\n"
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Mark this device busy. 	 */
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|busy
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_open: unit %d is busy.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|scp
operator|->
name|fflags
operator|=
name|flags
expr_stmt|;
comment|/* 	if ((scp->fflags& O_NONBLOCK) != 0) 		scp->flags |= SEQ_F_NBIO; 		*/
name|scp
operator|->
name|music
operator|=
name|MIDIDEV
argument_list|(
name|i_dev
argument_list|)
operator|==
name|SND_DEV_MUSIC
expr_stmt|;
comment|/* 	 * Enumerate the available midi devices 	 */
name|scp
operator|->
name|midi_number
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|maxunits
operator|=
name|midimapper_open
argument_list|(
name|scp
operator|->
name|mapper
argument_list|,
operator|&
name|scp
operator|->
name|mapper_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|maxunits
operator|==
literal|0
condition|)
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_open: no midi devices\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|maxunits
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|->
name|midis
index|[
name|scp
operator|->
name|midi_number
index|]
operator|=
name|midimapper_fetch_synth
argument_list|(
name|scp
operator|->
name|mapper
argument_list|,
name|scp
operator|->
name|mapper_cookie
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|midis
index|[
name|scp
operator|->
name|midi_number
index|]
condition|)
block|{
if|if
condition|(
name|SYNTH_OPEN
argument_list|(
name|scp
operator|->
name|midis
index|[
name|scp
operator|->
name|midi_number
index|]
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|fflags
argument_list|)
operator|!=
literal|0
condition|)
name|scp
operator|->
name|midis
index|[
name|scp
operator|->
name|midi_number
index|]
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|midi_flags
index|[
name|scp
operator|->
name|midi_number
index|]
operator|=
name|SYNTH_QUERY
argument_list|(
name|scp
operator|->
name|midis
index|[
name|scp
operator|->
name|midi_number
index|]
argument_list|)
expr_stmt|;
name|scp
operator|->
name|midi_number
operator|++
expr_stmt|;
block|}
block|}
block|}
name|timer_setvals
argument_list|(
name|scp
argument_list|,
literal|60
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|timer_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|timer_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* 	 * actually, if we're in rdonly mode, we should start the timer 	 */
comment|/* 	 * TODO: Handle recording now 	 */
name|scp
operator|->
name|out_water
operator|=
name|MIDIQ_SIZE
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_open: opened, mode %s.\n"
argument_list|,
name|scp
operator|->
name|music
condition|?
literal|"music"
else|:
literal|"sequencer"
argument_list|)
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"Sequencer %d %p opened maxunits %d midi_number %d:\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|scp
argument_list|,
name|scp
operator|->
name|maxunits
argument_list|,
name|scp
operator|->
name|midi_number
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|midi_number
condition|;
name|i
operator|++
control|)
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"  midi %d %p\n"
argument_list|,
name|i
argument_list|,
name|scp
operator|->
name|midis
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * seq_close  */
end_comment

begin_function
name|int
name|seq_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_close: unit %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|busy
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|seq_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|seq_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|midi_number
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|scp
operator|->
name|midis
index|[
name|i
index|]
condition|)
name|SYNTH_CLOSE
argument_list|(
name|scp
operator|->
name|midis
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|midimapper_close
argument_list|(
name|scp
operator|->
name|mapper
argument_list|,
name|scp
operator|->
name|mapper_cookie
argument_list|)
expr_stmt|;
name|timer_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|err
label|:
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_close: closed ret = %d.\n"
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|seq_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|used
decl_stmt|;
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
define|#
directive|define
name|SEQ_RSIZE
value|32
name|u_char
name|buf
index|[
name|SEQ_RSIZE
index|]
decl_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|SEQ_DEBUG
argument_list|(
literal|7
argument_list|,
name|printf
argument_list|(
literal|"seq_read: unit %d, resid %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_read: unit %d is not for reading.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* 	 * Begin recording. 	 */
comment|/* 	 * if ((scp->flags& SEQ_F_READING) == 0) 	 */
comment|/* 	 * TODO, start recording if not alread 	 */
comment|/* 	 * I think the semantics are to return as soon 	 * as possible. 	 * Second thought, it doens't seem like midimoutain 	 * expects that at all. 	 * TODO: Look up in some sort of spec 	 */
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|MIDIQ_EMPTY
argument_list|(
name|scp
operator|->
name|in_q
argument_list|)
condition|)
block|{
name|retval
operator|=
name|EWOULDBLOCK
expr_stmt|;
comment|/* 			 * I wish I knew which one to care about 			 */
if|if
condition|(
name|scp
operator|->
name|fflags
operator|&
name|O_NONBLOCK
condition|)
goto|goto
name|err1
goto|;
if|if
condition|(
name|ioflag
operator|&
name|O_NONBLOCK
condition|)
goto|goto
name|err1
goto|;
name|retval
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|scp
operator|->
name|in_cv
argument_list|,
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
goto|goto
name|err1
goto|;
block|}
name|used
operator|=
name|MIN
argument_list|(
name|MIDIQ_LEN
argument_list|(
name|scp
operator|->
name|in_q
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|used
operator|=
name|MIN
argument_list|(
name|used
argument_list|,
name|SEQ_RSIZE
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|8
argument_list|,
name|printf
argument_list|(
literal|"midiread: uiomove cc=%d\n"
argument_list|,
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|MIDIQ_DEQ
argument_list|(
name|scp
operator|->
name|in_q
argument_list|,
name|buf
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|retval
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|used
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err1
goto|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|err1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"seq_read: ret %d, resid %d.\n"
argument_list|,
name|retval
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|seq_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|u_char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|,
name|newevent
index|[
name|EV_SZ
index|]
decl_stmt|,
name|ev_code
decl_stmt|;
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|used
decl_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|7
argument_list|,
name|printf
argument_list|(
literal|"seq_write: unit %d, resid %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_write: unit %d is not for writing.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EIO
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|fflags
operator|&
name|O_NONBLOCK
condition|)
goto|goto
name|err0
goto|;
if|if
condition|(
name|ioflag
operator|&
name|O_NONBLOCK
condition|)
goto|goto
name|err0
goto|;
name|SEQ_DEBUG
argument_list|(
literal|8
argument_list|,
name|printf
argument_list|(
literal|"seq_write cvwait\n"
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|playing
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|retval
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|,
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
comment|/* 		         * We slept, maybe things have changed since last 		         * dying check 		         */
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
goto|goto
name|err0
goto|;
if|#
directive|if
literal|0
comment|/* 		         * Useless test 		         */
block|if (scp != i_dev->si_drv1) 				retval = ENXIO;
endif|#
directive|endif
block|}
name|used
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|8
argument_list|,
name|printf
argument_list|(
literal|"seqout: resid %d len %jd avail %jd\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_LEN
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|MIDIQ_AVAIL
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|!=
literal|4
condition|)
block|{
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
name|retval
operator|=
name|uiomove
argument_list|(
name|event
argument_list|,
name|used
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err0
goto|;
name|ev_code
operator|=
name|event
index|[
literal|0
index|]
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|8
argument_list|,
name|printf
argument_list|(
literal|"seq_write: unit %d, event %s.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|midi_cmdname
argument_list|(
name|ev_code
argument_list|,
name|cmdtab_seqevent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have a look at the event code. */
if|if
condition|(
name|ev_code
operator|==
name|SEQ_FULLSIZE
condition|)
block|{
comment|/* 			 * TODO: restore code for SEQ_FULLSIZE 			 */
if|#
directive|if
literal|0
comment|/* 			 * A long event, these are the patches/samples for a 			 * synthesizer. 			 */
block|midiunit = *(u_short *)&event[2]; 			mtx_lock(&sd->seq_lock); 			ret = lookup_mididev(scp, midiunit, LOOKUP_OPEN,&md); 			mtx_unlock(&sd->seq_lock); 			if (ret != 0) 				return (ret);  			SEQ_DEBUG(printf("seq_write: loading a patch to the unit %d.\n", midiunit));  			ret = md->synth.loadpatch(md, *(short *)&event[0], buf, 			    p + 4, count, 0); 			return (ret);
else|#
directive|else
comment|/* 			 * For now, just flush the darn buffer 			 */
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_write: SEQ_FULLSIZE flusing buffer.\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|retval
operator|=
name|uiomove
argument_list|(
name|event
argument_list|,
name|EV_SZ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
goto|goto
name|err0
goto|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|err0
goto|;
endif|#
directive|endif
block|}
name|retval
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|ev_code
operator|>=
literal|128
condition|)
block|{
comment|/* 			 * Some sort of an extended event. The size is eight 			 * bytes. scoop extra info. 			 */
if|if
condition|(
name|scp
operator|->
name|music
operator|&&
name|ev_code
operator|==
name|SEQ_EXTENDED
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_write: invalid level two event %x.\n"
argument_list|,
name|ev_code
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|event
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|uio
argument_list|)
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_write: user memory mangled?\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * Size four event. 			 */
if|if
condition|(
name|scp
operator|->
name|music
condition|)
block|{
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_write: four byte event in music mode.\n"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
block|}
if|if
condition|(
name|ev_code
operator|==
name|SEQ_MIDIPUTC
condition|)
block|{
comment|/* 			 * TODO: event[2] is unit number to receive char. 			 * Range check it. 			 */
block|}
if|if
condition|(
name|scp
operator|->
name|music
condition|)
block|{
ifdef|#
directive|ifdef
name|not_ever_ever
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|==
name|EV_TIMING
operator|&&
operator|(
name|event
index|[
literal|1
index|]
operator|==
name|TMR_START
operator|||
name|event
index|[
literal|1
index|]
operator|==
name|TMR_STOP
operator|)
condition|)
block|{
comment|/* 			         * For now, try to make midimoutain work by 			         * forcing these events to be processed 				 * immediatly. 			         */
name|seq_processevent
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
else|else
name|MIDIQ_ENQ
argument_list|(
name|scp
operator|->
name|out_q
argument_list|,
name|event
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|MIDIQ_ENQ
argument_list|(
name|scp
operator|->
name|out_q
argument_list|,
name|event
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|seq_convertold
argument_list|(
name|event
argument_list|,
name|newevent
argument_list|)
operator|>
literal|0
condition|)
name|MIDIQ_ENQ
argument_list|(
name|scp
operator|->
name|out_q
argument_list|,
name|newevent
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else 				goto err0;
endif|#
directive|endif
block|}
block|}
name|scp
operator|->
name|playing
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|err0
label|:
name|SEQ_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"seq_write done: leftover buffer length %d retval %d\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|seq_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|midiunit
decl_stmt|,
name|ret
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|synth_info
modifier|*
name|synthinfo
decl_stmt|;
name|struct
name|midi_info
modifier|*
name|midiinfo
decl_stmt|;
name|u_char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|;
name|u_char
name|newevent
index|[
name|EV_SZ
index|]
decl_stmt|;
name|kobj_t
name|md
decl_stmt|;
comment|/* 	 * struct snd_size *sndsize; 	 */
if|if
condition|(
name|scp
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|SEQ_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: unit %d, cmd %s.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_seqioctl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SEQ_GETTIME
case|:
comment|/* 		 * ioctl needed by libtse 		 */
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|timer_now
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|6
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: gettime %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_METRONOME
case|:
comment|/* fallthrough */
case|case
name|SNDCTL_TMR_SOURCE
case|:
comment|/* 		 * Not implemented 		 */
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_TEMPO
case|:
name|event
index|[
literal|1
index|]
operator|=
name|TMR_TEMPO
expr_stmt|;
name|event
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xFF
expr_stmt|;
name|event
index|[
literal|5
index|]
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|event
index|[
literal|6
index|]
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|event
index|[
literal|7
index|]
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
goto|goto
name|timerevent
goto|;
case|case
name|SNDCTL_TMR_TIMEBASE
case|:
name|event
index|[
literal|1
index|]
operator|=
name|TMR_TIMERBASE
expr_stmt|;
name|event
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xFF
expr_stmt|;
name|event
index|[
literal|5
index|]
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|event
index|[
literal|6
index|]
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|event
index|[
literal|7
index|]
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
goto|goto
name|timerevent
goto|;
case|case
name|SNDCTL_TMR_START
case|:
name|event
index|[
literal|1
index|]
operator|=
name|TMR_START
expr_stmt|;
goto|goto
name|timerevent
goto|;
case|case
name|SNDCTL_TMR_STOP
case|:
name|event
index|[
literal|1
index|]
operator|=
name|TMR_STOP
expr_stmt|;
goto|goto
name|timerevent
goto|;
case|case
name|SNDCTL_TMR_CONTINUE
case|:
name|event
index|[
literal|1
index|]
operator|=
name|TMR_CONTINUE
expr_stmt|;
name|timerevent
label|:
name|event
index|[
literal|0
index|]
operator|=
name|EV_TIMING
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
operator|->
name|music
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|seq_processevent
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_TMR_SELECT
case|:
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: SNDCTL_TMR_SELECT not supported\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_SYNC
case|:
if|if
condition|(
name|mode
operator|==
name|O_RDONLY
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|seq_sync
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_PANIC
case|:
comment|/* fallthrough */
case|case
name|SNDCTL_SEQ_RESET
case|:
comment|/* 		 * SNDCTL_SEQ_PANIC == SNDCTL_SEQ_RESET 		 */
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|seq_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_TESTMIDI
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
comment|/* 		 * TODO: SNDCTL_SEQ_TESTMIDI now means "can I write to the 		 * device?". 		 */
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case SNDCTL_SEQ_GETINCOUNT: 		if (mode == O_WRONLY) 			*(int *)arg = 0; 		else { 			mtx_lock(&scp->seq_lock); 			*(int *)arg = scp->in_q.rl; 			mtx_unlock(&scp->seq_lock); 			SEQ_DEBUG(printf("seq_ioctl: incount %d.\n", 			    *(int *)arg)); 		} 		ret = 0; 		break; 	case SNDCTL_SEQ_GETOUTCOUNT: 		if (mode == O_RDONLY) 			*(int *)arg = 0; 		else { 			mtx_lock(&scp->seq_lock); 			*(int *)arg = scp->out_q.fl; 			mtx_unlock(&scp->seq_lock); 			SEQ_DEBUG(printf("seq_ioctl: outcount %d.\n", 			    *(int *)arg)); 		} 		ret = 0; 		break;
endif|#
directive|endif
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|scp
operator|->
name|timerbase
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: ctrlrate %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * TODO: ioctl SNDCTL_SEQ_RESETSAMPLES 		 */
if|#
directive|if
literal|0
block|case SNDCTL_SEQ_RESETSAMPLES: 		mtx_lock(&scp->seq_lock); 		ret = lookup_mididev(scp, *(int *)arg, LOOKUP_OPEN,&md); 		mtx_unlock(&scp->seq_lock); 		if (ret != 0) 			break; 		ret = midi_ioctl(MIDIMKDEV(major(i_dev), *(int *)arg, 		    SND_DEV_MIDIN), cmd, arg, mode, td); 		break;
endif|#
directive|endif
case|case
name|SNDCTL_SEQ_NRSYNTHS
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|scp
operator|->
name|midi_number
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: synths %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_NRMIDIS
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|music
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 		         * TODO: count the numbder of devices that can WRITERAW 		         */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|scp
operator|->
name|midi_number
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: midis %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 		 * TODO: ioctl SNDCTL_SYNTH_MEMAVL 		 */
if|#
directive|if
literal|0
block|case SNDCTL_SYNTH_MEMAVL: 		mtx_lock(&scp->seq_lock); 		ret = lookup_mididev(scp, *(int *)arg, LOOKUP_OPEN,&md); 		mtx_unlock(&scp->seq_lock); 		if (ret != 0) 			break; 		ret = midi_ioctl(MIDIMKDEV(major(i_dev), *(int *)arg, 		    SND_DEV_MIDIN), cmd, arg, mode, td); 		break;
endif|#
directive|endif
case|case
name|SNDCTL_SEQ_OUTOFBAND
case|:
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|ret
operator|<
name|EV_SZ
condition|;
name|ret
operator|++
control|)
name|event
index|[
name|ret
index|]
operator|=
operator|(
name|u_char
operator|)
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|music
condition|)
name|ret
operator|=
name|seq_processevent
argument_list|(
name|scp
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|seq_convertold
argument_list|(
name|event
argument_list|,
name|newevent
argument_list|)
operator|>
literal|0
condition|)
name|ret
operator|=
name|seq_processevent
argument_list|(
name|scp
argument_list|,
name|newevent
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|synthinfo
operator|=
operator|(
expr|struct
name|synth_info
operator|*
operator|)
name|arg
expr_stmt|;
name|midiunit
operator|=
name|synthinfo
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_fetch_mid
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
operator|&
name|md
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|synthinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|synthinfo
argument_list|)
argument_list|)
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'f'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|2
index|]
operator|=
literal|'k'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|3
index|]
operator|=
literal|'e'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|4
index|]
operator|=
literal|'s'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|5
index|]
operator|=
literal|'y'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|6
index|]
operator|=
literal|'n'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|7
index|]
operator|=
literal|'t'
expr_stmt|;
name|synthinfo
operator|->
name|name
index|[
literal|8
index|]
operator|=
literal|'h'
expr_stmt|;
name|synthinfo
operator|->
name|device
operator|=
name|midiunit
expr_stmt|;
name|synthinfo
operator|->
name|synth_type
operator|=
name|SYNTH_TYPE_MIDI
expr_stmt|;
name|synthinfo
operator|->
name|capabilities
operator|=
name|scp
operator|->
name|midi_flags
index|[
name|midiunit
index|]
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_MIDI_INFO
case|:
name|midiinfo
operator|=
operator|(
expr|struct
name|midi_info
operator|*
operator|)
name|arg
expr_stmt|;
name|midiunit
operator|=
name|midiinfo
operator|->
name|device
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_fetch_mid
argument_list|(
name|scp
argument_list|,
name|midiunit
argument_list|,
operator|&
name|md
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|midiinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|midiinfo
argument_list|)
argument_list|)
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'f'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|2
index|]
operator|=
literal|'k'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|3
index|]
operator|=
literal|'e'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|4
index|]
operator|=
literal|'m'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|5
index|]
operator|=
literal|'i'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|6
index|]
operator|=
literal|'d'
expr_stmt|;
name|midiinfo
operator|->
name|name
index|[
literal|7
index|]
operator|=
literal|'i'
expr_stmt|;
name|midiinfo
operator|->
name|device
operator|=
name|midiunit
expr_stmt|;
name|midiinfo
operator|->
name|capabilities
operator|=
name|scp
operator|->
name|midi_flags
index|[
name|midiunit
index|]
expr_stmt|;
comment|/* 		         * TODO: What devtype? 		         */
name|midiinfo
operator|->
name|dev_type
operator|=
literal|0x01
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_THRESHOLD
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|RANGE
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|,
literal|1
argument_list|,
name|MIDIQ_SIZE
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|scp
operator|->
name|out_water
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: water %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_MIDI_PRETIME
case|:
name|tmp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|scp
operator|->
name|pre_event_timeout
operator|=
operator|(
name|hz
operator|*
name|tmp
operator|)
operator|/
literal|10
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|scp
operator|->
name|pre_event_timeout
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: pretime %d.\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
case|case
name|SNDCTL_PMGR_IFACE
case|:
case|case
name|SNDCTL_PMGR_ACCESS
case|:
comment|/* 		 * Patch manager and fm are ded, ded, ded. 		 */
comment|/* fallthrough */
default|default:
comment|/* 		 * TODO: Consider ioctl default case. 		 * Old code used to 		 * if ((scp->fflags& O_ACCMODE) == FREAD) { 		 *	ret = EIO; 		 *	break; 		 * } 		 * Then pass on the ioctl to device 0 		 */
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_ioctl: unsupported IOCTL %ld.\n"
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|seq_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|seq_softc
modifier|*
name|scp
init|=
name|i_dev
operator|->
name|si_drv1
decl_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|3
argument_list|,
name|printf
argument_list|(
literal|"seq_poll: unit %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_poll: unit %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* Look up the apropriate queue and select it. */
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Start playing. */
name|scp
operator|->
name|playing
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|lim
operator|=
name|scp
operator|->
name|out_water
expr_stmt|;
if|if
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
operator|<
name|lim
condition|)
comment|/* No enough space, record select. */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|scp
operator|->
name|out_sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can write now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* TODO: Start recording. */
comment|/* Find out the boundary. */
name|lim
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MIDIQ_LEN
argument_list|(
name|scp
operator|->
name|in_q
argument_list|)
operator|<
name|lim
condition|)
comment|/* No data ready, record select. */
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|scp
operator|->
name|in_sel
argument_list|)
expr_stmt|;
else|else
comment|/* We can read now. */
name|ret
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void sein_qtr(void *p, void
comment|/* mididev_info */
end_comment

begin_comment
unit|*md) { 	struct seq_softc *scp;  	scp = (struct seq_softc *)p;  	mtx_lock(&scp->seq_lock);
comment|/* Restart playing if we have the data to output. */
end_comment

begin_comment
unit|if (scp->queueout_pending) 		seq_callback(scp, SEQ_CB_START | SEQ_CB_WR);
comment|/* Check the midi device if we are reading. */
end_comment

begin_endif
unit|if ((scp->flags& SEQ_F_READING) != 0) 		seq_midiinput(scp, md);  	mtx_unlock(&scp->seq_lock); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * seq_convertold  * Was the old playevent.  Use this to convert and old  * style /dev/sequencer event to a /dev/music event  */
end_comment

begin_function
specifier|static
name|int
name|seq_convertold
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|,
name|u_char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|used
decl_stmt|;
name|u_char
name|dev
decl_stmt|,
name|chn
decl_stmt|,
name|note
decl_stmt|,
name|vel
decl_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|out
index|[
literal|1
index|]
operator|=
name|out
index|[
literal|2
index|]
operator|=
name|out
index|[
literal|3
index|]
operator|=
name|out
index|[
literal|4
index|]
operator|=
name|out
index|[
literal|5
index|]
operator|=
name|out
index|[
literal|6
index|]
operator|=
name|out
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
literal|0
expr_stmt|;
name|chn
operator|=
name|event
index|[
literal|1
index|]
expr_stmt|;
name|note
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|vel
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
name|restart
label|:
comment|/* 	 * TODO: Debug statement 	 */
switch|switch
condition|(
name|event
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EV_TIMING
case|:
case|case
name|EV_CHN_VOICE
case|:
case|case
name|EV_CHN_COMMON
case|:
case|case
name|EV_SYSEX
case|:
case|case
name|EV_SEQ_LOCAL
case|:
name|out
index|[
literal|0
index|]
operator|=
name|event
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|event
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|event
index|[
literal|4
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|event
index|[
literal|5
index|]
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
name|event
index|[
literal|6
index|]
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|=
name|event
index|[
literal|7
index|]
expr_stmt|;
name|used
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEOFF
case|:
name|out
index|[
literal|0
index|]
operator|=
name|EV_CHN_VOICE
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|dev
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|MIDI_NOTEOFF
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|chn
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|note
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
literal|255
expr_stmt|;
name|used
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
name|out
index|[
literal|0
index|]
operator|=
name|EV_CHN_VOICE
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|dev
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|MIDI_NOTEON
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|chn
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|note
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|vel
expr_stmt|;
name|used
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* 		 * wait delay = (event[2]<< 16) + (event[3]<< 8) + event[4] 		 */
case|case
name|SEQ_PGMCHANGE
case|:
name|out
index|[
literal|0
index|]
operator|=
name|EV_CHN_COMMON
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|dev
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|MIDI_PGM_CHANGE
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|chn
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|note
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|vel
expr_stmt|;
name|used
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* 		out[0] = EV_TIMING; 		out[1] = dev; 		out[2] = MIDI_PGM_CHANGE; 		out[3] = chn; 		out[4] = note; 		out[5] = vel; 		SEQ_DEBUG(4,printf("seq_playevent: synctimer\n")); 		break; */
case|case
name|SEQ_MIDIPUTC
case|:
name|SEQ_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"seq_playevent: put data 0x%02x, unit %d.\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|event
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Pass through to the midi device. 		 * device = event[2] 		 * data = event[1] 		 */
name|out
index|[
literal|0
index|]
operator|=
name|SEQ_MIDIPUTC
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|dev
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|chn
expr_stmt|;
name|used
operator|+=
literal|4
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|SEQ_ECHO
case|:
comment|/* 		 * This isn't handled here yet because I don't know if I can 		 * just use four bytes events.  There might be consequences 		 * in the _read routing 		 */
if|if
condition|(
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
name|event
argument_list|,
literal|4
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|ret
operator|=
name|QUEUEFULL
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|MORE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SEQ_EXTENDED
case|:
switch|switch
condition|(
name|event
index|[
literal|1
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
case|case
name|SEQ_NOTEON
case|:
case|case
name|SEQ_PGMCHANGE
case|:
name|event
operator|++
expr_stmt|;
name|used
operator|=
literal|4
expr_stmt|;
goto|goto
name|restart
goto|;
break|break;
case|case
name|SEQ_AFTERTOUCH
case|:
comment|/* 			 * SYNTH_AFTERTOUCH(md, event[3], event[4]) 			 */
case|case
name|SEQ_BALANCE
case|:
comment|/* 			 * SYNTH_PANNING(md, event[3], (char)event[4]) 			 */
case|case
name|SEQ_CONTROLLER
case|:
comment|/* 			 * SYNTH_CONTROLLER(md, event[3], event[4], *(short *)&event[5]) 			 */
case|case
name|SEQ_VOLMODE
case|:
comment|/* 			 * SYNTH_VOLUMEMETHOD(md, event[3]) 			 */
default|default:
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_convertold: SEQ_EXTENDED type %d"
literal|"not handled\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SEQ_WAIT
case|:
name|out
index|[
literal|0
index|]
operator|=
name|EV_TIMING
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|TMR_WAIT_REL
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
name|event
index|[
literal|4
index|]
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"SEQ_WAIT %d"
argument_list|,
name|event
index|[
literal|2
index|]
operator|+
operator|(
name|event
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|event
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|SEQ_ECHO
case|:
case|case
name|SEQ_SYNCTIMER
case|:
case|case
name|SEQ_PRIVATE
case|:
default|default:
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_convertold: event type %d not handled %d %d %d\n"
argument_list|,
name|event
index|[
literal|0
index|]
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|event
index|[
literal|2
index|]
argument_list|,
name|event
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|used
return|;
block|}
end_function

begin_comment
comment|/*  * Writting to the sequencer buffer never blocks and drops  * input which cannot be queued  */
end_comment

begin_function
name|void
name|seq_copytoinput
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIDIQ_AVAIL
argument_list|(
name|scp
operator|->
name|in_q
argument_list|)
operator|<
name|len
condition|)
block|{
comment|/* 	         * ENOROOM?  EINPUTDROPPED? ETOUGHLUCK? 	         */
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_copytoinput: queue full\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MIDIQ_ENQ
argument_list|(
name|scp
operator|->
name|in_q
argument_list|,
name|event
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|scp
operator|->
name|in_sel
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|in_cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|seq_chnvoice
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|kobj_t
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|voice
decl_stmt|;
name|u_char
name|cmd
decl_stmt|,
name|chn
decl_stmt|,
name|note
decl_stmt|,
name|parm
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|chn
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|note
operator|=
name|event
index|[
literal|4
index|]
expr_stmt|;
name|parm
operator|=
name|event
index|[
literal|5
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"seq_chnvoice: unit %d, dev %d, cmd %s,"
literal|" chn %d, note %d, parm %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_seqcv
argument_list|)
argument_list|,
name|chn
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|voice
operator|=
name|SYNTH_ALLOC
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_NOTEON
case|:
if|if
condition|(
name|note
operator|<
literal|128
operator|||
name|note
operator|==
literal|255
condition|)
block|{
if|#
directive|if
literal|0
block|if (scp->music&& chn == 9) {
comment|/* 				 * This channel is a percussion. The note 				 * number is the patch number. 				 */
comment|/* 				mtx_unlock(&scp->seq_lock); 				if (SYNTH_SETINSTR(md, voice, 128 + note) 				    == EAGAIN) { 					mtx_lock(&scp->seq_lock); 					return (QUEUEFULL); 				} 				mtx_lock(&scp->seq_lock); 				*/
block|note = 60;
comment|/* Middle C. */
block|}
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|music
condition|)
block|{
comment|/* 				mtx_unlock(&scp->seq_lock); 				if (SYNTH_SETUPVOICE(md, voice, chn) 				    == EAGAIN) { 					mtx_lock(&scp->seq_lock); 					return (QUEUEFULL); 				} 				mtx_lock(&scp->seq_lock); 				*/
block|}
name|SYNTH_STARTNOTE
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MIDI_NOTEOFF
case|:
name|SYNTH_KILLNOTE
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_KEY_PRESSURE
case|:
name|SYNTH_AFTERTOUCH
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|1
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_chnvoice event type %d not handled\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_chncommon
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|kobj_t
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u_short
name|w14
decl_stmt|;
name|u_char
name|cmd
decl_stmt|,
name|chn
decl_stmt|,
name|p1
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|chn
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
name|event
index|[
literal|4
index|]
expr_stmt|;
name|w14
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"seq_chncommon: unit %d, dev %d, cmd %s, chn %d,"
literal|" p1 %d, w14 %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_seqccmn
argument_list|)
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_PGM_CHANGE
case|:
name|SEQ_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"seq_chncommon pgmchn chn %d pg %d\n"
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|SYNTH_SETINSTR
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_CTL_CHANGE
case|:
name|SEQ_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"seq_chncommon ctlch chn %d pg %d %d\n"
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
argument_list|)
expr_stmt|;
name|SYNTH_CONTROLLER
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_PITCH_BEND
case|:
if|if
condition|(
name|scp
operator|->
name|music
condition|)
block|{
comment|/* 		         * TODO: MIDI_PITCH_BEND 		         */
if|#
directive|if
literal|0
block|mtx_lock(&md->synth.vc_mtx); 			md->synth.chn_info[chn].bender_value = w14; 			if (md->midiunit>= 0) {
comment|/* 				 * Handle all of the notes playing on this 				 * channel. 				 */
block|key = ((int)chn<< 8); 				for (i = 0; i< md->synth.alloc.max_voice; i++) 					if ((md->synth.alloc.map[i]& 0xff00) == key) { 						mtx_unlock(&md->synth.vc_mtx); 						mtx_unlock(&scp->seq_lock); 						if (md->synth.bender(md, i, w14) == EAGAIN) { 							mtx_lock(&scp->seq_lock); 							return (QUEUEFULL); 						} 						mtx_lock(&scp->seq_lock); 					} 			} else { 				mtx_unlock(&md->synth.vc_mtx); 				mtx_unlock(&scp->seq_lock); 				if (md->synth.bender(md, chn, w14) == EAGAIN) { 					mtx_lock(&scp->seq_lock); 					return (QUEUEFULL); 				} 				mtx_lock(&scp->seq_lock); 			}
endif|#
directive|endif
block|}
else|else
name|SYNTH_BENDER
argument_list|(
name|md
argument_list|,
name|chn
argument_list|,
name|w14
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|1
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_chncommon event type %d not handled.\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_timing
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|param
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|param
operator|=
name|event
index|[
literal|4
index|]
operator|+
operator|(
name|event
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|event
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|event
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"seq_timing: unit %d, cmd %d, param %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|,
name|param
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
index|[
literal|1
index|]
condition|)
block|{
case|case
name|TMR_WAIT_REL
case|:
name|timer_wait
argument_list|(
name|scp
argument_list|,
name|param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_WAIT_ABS
case|:
name|timer_wait
argument_list|(
name|scp
argument_list|,
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_START
case|:
name|timer_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_STOP
case|:
name|timer_stop
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* 		 * The following cv_broadcast isn't needed since we only 		 * wait for 0->1 transitions.  It probably won't hurt 		 */
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_CONTINUE
case|:
name|timer_continue
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_TEMPO
case|:
if|if
condition|(
name|param
operator|<
literal|8
condition|)
name|param
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|param
operator|>
literal|360
condition|)
name|param
operator|=
literal|360
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"Timer set tempo %d\n"
argument_list|,
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|timer_setvals
argument_list|(
name|scp
argument_list|,
name|param
argument_list|,
name|scp
operator|->
name|timerbase
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_TIMERBASE
case|:
if|if
condition|(
name|param
operator|<
literal|1
condition|)
name|param
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|param
operator|>
literal|1000
condition|)
name|param
operator|=
literal|1000
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"Timer set timerbase %d\n"
argument_list|,
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|timer_setvals
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|tempo
argument_list|,
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_ECHO
case|:
comment|/* 		 * TODO: Consider making 4-byte events for /dev/sequencer 		 * PRO: Maybe needed by legacy apps 		 * CON: soundcard.h has been warning for a while many years 		 * to expect 8 byte events. 		 */
if|#
directive|if
literal|0
block|if (scp->music) 			seq_copytoinput(scp, event, 8); 		else { 			param = (param<< 8 | SEQ_ECHO); 			seq_copytoinput(scp, (u_char *)&param, 4); 		}
else|#
directive|else
name|seq_copytoinput
argument_list|(
name|scp
argument_list|,
name|event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|SEQ_DEBUG
argument_list|(
literal|2
argument_list|,
name|printf
argument_list|(
literal|"seq_timing event type %d not handled.\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_local
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"seq_local: unit %d, cmd %d\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
index|[
literal|1
index|]
condition|)
block|{
default|default:
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_local event type %d not handled\n"
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_sysex
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|,
name|kobj_t
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"seq_sysex: unit %d device %d\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|,
name|event
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
operator|&&
name|event
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0xff
condition|;
name|i
operator|++
control|)
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYNTH_SENDSYSEX
argument_list|(
name|md
argument_list|,
operator|&
name|event
index|[
literal|2
index|]
argument_list|,
name|l
argument_list|)
operator|==
name|EAGAIN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reset no longer closes the raw devices nor seq_sync's  * Callers are IOCTL and seq_close  */
end_comment

begin_function
specifier|static
name|void
name|seq_reset
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|chn
decl_stmt|,
name|i
decl_stmt|;
name|kobj_t
name|m
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|5
argument_list|,
name|printf
argument_list|(
literal|"seq_reset: unit %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Stop reading and writing. 	 */
comment|/* scp->recording = 0; */
name|scp
operator|->
name|playing
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
comment|/* 	 * For now, don't reset the timers. 	 */
name|MIDIQ_CLEAR
argument_list|(
name|scp
operator|->
name|in_q
argument_list|)
expr_stmt|;
name|MIDIQ_CLEAR
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|midi_number
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|scp
operator|->
name|midis
index|[
name|i
index|]
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
name|SYNTH_RESET
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|SYNTH_CONTROLLER
argument_list|(
name|m
argument_list|,
name|chn
argument_list|,
literal|123
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYNTH_CONTROLLER
argument_list|(
name|m
argument_list|,
name|chn
argument_list|,
literal|121
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYNTH_BENDER
argument_list|(
name|m
argument_list|,
name|chn
argument_list|,
literal|1
operator|<<
literal|13
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * seq_sync  * *really* flush the output queue  * flush the event queue, then flush the synthsisers.  * Callers are IOCTL and close  */
end_comment

begin_define
define|#
directive|define
name|SEQ_SYNC_TIMEOUT
value|8
end_define

begin_function
specifier|static
name|int
name|seq_sync
parameter_list|(
name|struct
name|seq_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rl
decl_stmt|,
name|sync
index|[
literal|16
index|]
decl_stmt|,
name|done
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SEQ_DEBUG
argument_list|(
literal|4
argument_list|,
name|printf
argument_list|(
literal|"seq_sync: unit %d.\n"
argument_list|,
name|scp
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Wait until output queue is empty.  Check every so often to see if 	 * the queue is moving along.  If it isn't just abort. 	 */
while|while
condition|(
operator|!
name|MIDIQ_EMPTY
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|scp
operator|->
name|playing
condition|)
block|{
name|scp
operator|->
name|playing
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
block|}
name|rl
operator|=
name|MIDIQ_LEN
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
expr_stmt|;
name|i
operator|=
name|cv_timedwait_sig
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|,
operator|&
name|scp
operator|->
name|seq_lock
argument_list|,
name|SEQ_SYNC_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EINTR
operator|||
name|i
operator|==
name|ERESTART
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|EINTR
condition|)
block|{
comment|/* 			         * XXX: I don't know why we stop playing 			         */
name|scp
operator|->
name|playing
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
if|if
condition|(
name|i
operator|==
name|EWOULDBLOCK
operator|&&
name|rl
operator|==
name|MIDIQ_LEN
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
operator|&&
name|scp
operator|->
name|waiting
operator|==
literal|0
condition|)
block|{
comment|/* 			 * A queue seems to be stuck up. Give up and clear 			 * queues. 			 */
name|MIDIQ_CLEAR
argument_list|(
name|scp
operator|->
name|out_q
argument_list|)
expr_stmt|;
name|scp
operator|->
name|playing
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|state_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|out_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|scp
operator|->
name|reset_cv
argument_list|)
expr_stmt|;
comment|/* 			 * TODO: Consider if the raw devices need to be flushed 			 */
name|SEQ_DEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"seq_sync queue stuck, aborting\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
name|scp
operator|->
name|playing
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Since syncing a midi device might block, unlock scp->seq_lock. 	 */
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|midi_number
condition|;
name|i
operator|++
control|)
name|sync
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|midi_number
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sync
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|SYNTH_INSYNC
argument_list|(
name|scp
operator|->
name|midis
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|sync
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|done
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|seq_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|midi_cmdname
parameter_list|(
name|int
name|cmd
parameter_list|,
name|midi_cmdtab
modifier|*
name|tab
parameter_list|)
block|{
while|while
condition|(
name|tab
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|tab
operator|->
name|cmd
condition|)
return|return
operator|(
name|tab
operator|->
name|name
operator|)
return|;
name|tab
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|"unknown"
operator|)
return|;
block|}
end_function

end_unit

