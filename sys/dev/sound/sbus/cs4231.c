begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Jason L. Wright (jason@thought.net)  * Copyright (c) 2004 Pyun YongHyeon  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  *  *	from: OpenBSD: cs4231.c,v 1.21 2003/07/03 20:36:07 jason Exp  */
end_comment

begin_comment
comment|/*  * Driver for CS4231 based audio found in some sun4m systems (cs4231)  * based on ideas from the S/Linux project and the NetBSD project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/ofw_machdep.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/sbus/apcdmareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/sbus/cs4231.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/sbus/sbusvar.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/ebus/ebusreg.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_comment
comment|/*  * The driver supports CS4231A audio chips found on Sbus/Ebus based   * UltraSPARCs. Though, CS4231A says it supports full-duplex mode, I  * doubt it due to the lack of independent sampling frequency register  * for playback/capture.  * Since I couldn't find any documentation for APCDMA programming  * information, I guessed the usage of APCDMA from that of OpenBSD's  * driver. The EBDMA information of PCIO can be obtained from  *  http://solutions.sun.com/embedded/databook/web/microprocessors/pcio.html  * And CS4231A datasheet can also be obtained from  *  ftp://ftp.alsa-project.org/pub/manuals/cirrus/4231a.pdf  *  * Audio capture(recording) was not tested at all and may have bugs.  * Sorry, I don't have microphone. Don't try to use full-duplex mode.  * It wouldn't work.  */
end_comment

begin_define
define|#
directive|define
name|CS_TIMEOUT
value|90000
end_define

begin_define
define|#
directive|define
name|CS4231_MIN_BUF_SZ
value|(16*1024)
end_define

begin_define
define|#
directive|define
name|CS4231_DEFAULT_BUF_SZ
value|(32*1024)
end_define

begin_define
define|#
directive|define
name|CS4231_MAX_BUF_SZ
value|(64*1024)
end_define

begin_define
define|#
directive|define
name|CS4231_MAX_BLK_SZ
value|(8*1024)
end_define

begin_define
define|#
directive|define
name|CS4231_MAX_APC_DMA_SZ
value|(8*1024)
end_define

begin_undef
undef|#
directive|undef
name|CS4231_DEBUG
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|CS4231_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CS4231_AUTO_CALIBRATION
end_define

begin_struct_decl
struct_decl|struct
name|cs4231_softc
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|cs4231_channel
block|{
name|struct
name|cs4231_softc
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|u_int32_t
name|format
decl_stmt|;
name|u_int32_t
name|speed
decl_stmt|;
name|u_int32_t
name|nextaddr
decl_stmt|;
name|u_int32_t
name|togo
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|int
name|locked
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CS4231_RES_MEM_MAX
value|4
end_define

begin_define
define|#
directive|define
name|CS4231_RES_IRQ_MAX
value|2
end_define

begin_struct
struct|struct
name|cs4231_softc
block|{
name|struct
name|device
modifier|*
name|sc_dev
decl_stmt|;
name|int
name|sc_rid
index|[
name|CS4231_RES_MEM_MAX
index|]
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_res
index|[
name|CS4231_RES_MEM_MAX
index|]
decl_stmt|;
name|bus_space_handle_t
name|sc_regh
index|[
name|CS4231_RES_MEM_MAX
index|]
decl_stmt|;
name|bus_space_tag_t
name|sc_regt
index|[
name|CS4231_RES_MEM_MAX
index|]
decl_stmt|;
name|int
name|sc_irqrid
index|[
name|CS4231_RES_IRQ_MAX
index|]
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irqres
index|[
name|CS4231_RES_IRQ_MAX
index|]
decl_stmt|;
name|void
modifier|*
name|sc_ih
index|[
name|CS4231_RES_IRQ_MAX
index|]
decl_stmt|;
name|bus_dma_tag_t
name|sc_dmat
index|[
name|CS4231_RES_IRQ_MAX
index|]
decl_stmt|;
name|int
name|sc_burst
decl_stmt|;
name|u_int32_t
name|sc_bufsz
decl_stmt|;
name|struct
name|cs4231_channel
name|sc_pch
decl_stmt|;
name|struct
name|cs4231_channel
name|sc_rch
decl_stmt|;
name|int
name|sc_enabled
decl_stmt|;
name|int
name|sc_nmres
decl_stmt|;
name|int
name|sc_nires
decl_stmt|;
name|int
name|sc_codecv
decl_stmt|;
name|int
name|sc_chipvid
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
define|#
directive|define
name|CS4231_SBUS
value|0x01
define|#
directive|define
name|CS4231_EBUS
value|0x02
name|struct
name|mtx
modifier|*
name|sc_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mix_table
block|{
name|u_int32_t
name|reg
range|:
literal|8
decl_stmt|;
name|u_int32_t
name|bits
range|:
literal|8
decl_stmt|;
name|u_int32_t
name|mute
range|:
literal|8
decl_stmt|;
name|u_int32_t
name|shift
range|:
literal|4
decl_stmt|;
name|u_int32_t
name|neg
range|:
literal|1
decl_stmt|;
name|u_int32_t
name|avail
range|:
literal|1
decl_stmt|;
name|u_int32_t
name|recdev
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|cs4231_bus_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_sbus_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_ebus_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_attach_common
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_bus_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_bus_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_bus_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_getversion
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_free_resource
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_ebdma_reset
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_power_reset
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_enable
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_disable
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_write
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|cs4231_read
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_sbus_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_ebus_pintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_ebus_cintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_mixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_mixer_set_value
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|mix_table
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_mixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|cs4231_mixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|cs4231_chan_init
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
parameter_list|,
name|struct
name|pcm_channel
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_chan_setformat
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|cs4231_chan_setspeed
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_chan_fs
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|cs4231_chan_setblocksize
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cs4231_chan_trigger
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|cs4231_chan_getptr
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|cs4231_chan_getcaps
parameter_list|(
name|kobj_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_trigger
parameter_list|(
name|struct
name|cs4231_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_apcdma_trigger
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|struct
name|cs4231_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_ebdma_trigger
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
parameter_list|,
name|struct
name|cs4231_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cs4231_halt
parameter_list|(
name|struct
name|cs4231_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CS4231_LOCK
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxlock(sc->sc_lock)
end_define

begin_define
define|#
directive|define
name|CS4231_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxunlock(sc->sc_lock)
end_define

begin_define
define|#
directive|define
name|CS4231_LOCK_ASSERT
parameter_list|(
name|sc
parameter_list|)
value|snd_mtxassert(sc->sc_lock)
end_define

begin_define
define|#
directive|define
name|CS_WRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->sc_regt[0], (sc)->sc_regh[0], (r)<< 2, (v))
end_define

begin_define
define|#
directive|define
name|CS_READ
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_1((sc)->sc_regt[0], (sc)->sc_regh[0], (r)<< 2)
end_define

begin_define
define|#
directive|define
name|APC_WRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_4(sc->sc_regt[0], sc->sc_regh[0], r, v)
end_define

begin_define
define|#
directive|define
name|APC_READ
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_4(sc->sc_regt[0], sc->sc_regh[0], r)
end_define

begin_define
define|#
directive|define
name|EBDMA_P_WRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_4((sc)->sc_regt[1], (sc)->sc_regh[1], (r), (v))
end_define

begin_define
define|#
directive|define
name|EBDMA_P_READ
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_4((sc)->sc_regt[1], (sc)->sc_regh[1], (r))
end_define

begin_define
define|#
directive|define
name|EBDMA_C_WRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_4((sc)->sc_regt[2], (sc)->sc_regh[2], (r), (v))
end_define

begin_define
define|#
directive|define
name|EBDMA_C_READ
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_4((sc)->sc_regt[2], (sc)->sc_regh[2], (r))
end_define

begin_define
define|#
directive|define
name|AUXIO_CODEC
value|0x00
end_define

begin_define
define|#
directive|define
name|AUXIO_WRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_4((sc)->sc_regt[3], (sc)->sc_regh[3], (r), (v))
end_define

begin_define
define|#
directive|define
name|AUXIO_READ
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_4((sc)->sc_regt[3], (sc)->sc_regh[3], (r))
end_define

begin_define
define|#
directive|define
name|CODEC_WARM_RESET
value|0
end_define

begin_define
define|#
directive|define
name|CODEC_COLD_RESET
value|1
end_define

begin_comment
comment|/* SBus */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|cs4231_sbus_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cs4231_bus_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cs4231_sbus_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cs4231_bus_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|cs4231_bus_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|cs4231_bus_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cs4231_sbus_driver
init|=
block|{
literal|"pcm"
block|,
name|cs4231_sbus_methods
block|,
name|PCM_SOFTC_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_audiocs
argument_list|,
name|sbus
argument_list|,
name|cs4231_sbus_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* EBus */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|cs4231_ebus_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cs4231_bus_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cs4231_ebus_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cs4231_bus_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|cs4231_bus_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|cs4231_bus_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cs4231_ebus_driver
init|=
block|{
literal|"pcm"
block|,
name|cs4231_ebus_methods
block|,
name|PCM_SOFTC_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|snd_audiocs
argument_list|,
name|ebus
argument_list|,
name|cs4231_ebus_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|snd_audiocs
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|snd_audiocs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|cs4231_fmt
index|[]
init|=
block|{
name|SND_FORMAT
argument_list|(
name|AFMT_U8
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_U8
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_MU_LAW
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_MU_LAW
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_A_LAW
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_A_LAW
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_IMA_ADPCM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_IMA_ADPCM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S16_BE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S16_BE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|cs4231_caps
init|=
block|{
literal|5510
block|,
literal|48000
block|,
name|cs4231_fmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * sound(4) channel interface  */
end_comment

begin_decl_stmt
specifier|static
name|kobj_method_t
name|cs4231_chan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|cs4231_chan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|cs4231_chan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|cs4231_chan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|cs4231_chan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|cs4231_chan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|cs4231_chan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|cs4231_chan_getcaps
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|cs4231_chan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * sound(4) mixer interface  */
end_comment

begin_decl_stmt
specifier|static
name|kobj_method_t
name|cs4231_mixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|cs4231_mixer_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|cs4231_mixer_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_setrecsrc
argument_list|,
name|cs4231_mixer_setrecsrc
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|cs4231_mixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|cs4231_bus_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|compat
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|compat
operator|=
name|ofw_bus_get_compat
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|name
operator|=
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"SUNW,CS4231"
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|compat
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
literal|"SUNW,CS4231"
argument_list|,
name|compat
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Sun Audiocs"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_sbus_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|burst
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * XXX 	 * No public documentation exists on programming burst size of APCDMA. 	 */
name|burst
operator|=
name|sbus_get_burstsz
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|burst
operator|&
name|SBUS_BURST_64
operator|)
condition|)
name|sc
operator|->
name|sc_burst
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|burst
operator|&
name|SBUS_BURST_32
operator|)
condition|)
name|sc
operator|->
name|sc_burst
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|burst
operator|&
name|SBUS_BURST_16
operator|)
condition|)
name|sc
operator|->
name|sc_burst
operator|=
literal|16
expr_stmt|;
else|else
name|sc
operator|->
name|sc_burst
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|CS4231_SBUS
expr_stmt|;
name|sc
operator|->
name|sc_nmres
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_nires
operator|=
literal|1
expr_stmt|;
return|return
name|cs4231_attach_common
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_ebus_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cs4231_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate softc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_burst
operator|=
name|EBDCSR_BURST_1
expr_stmt|;
name|sc
operator|->
name|sc_nmres
operator|=
name|CS4231_RES_MEM_MAX
expr_stmt|;
name|sc
operator|->
name|sc_nires
operator|=
name|CS4231_RES_IRQ_MAX
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|CS4231_EBUS
expr_stmt|;
return|return
name|cs4231_attach_common
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_attach_common
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|driver_intr_t
modifier|*
name|ihandler
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_lock
operator|=
name|snd_mtxcreate
argument_list|(
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"snd_cs4231 softc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nmres
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_rid
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_res
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|sc_rid
index|[
name|i
index|]
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot map register %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_regt
index|[
name|i
index|]
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_regh
index|[
name|i
index|]
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nires
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_irqrid
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_irqres
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_irqrid
index|[
name|i
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate %s "
literal|"interrupt\n"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"capture"
else|:
literal|"playback"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|ihandler
operator|=
name|cs4231_sbus_intr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nires
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_EBUS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|ihandler
operator|=
name|cs4231_ebus_cintr
expr_stmt|;
else|else
name|ihandler
operator|=
name|cs4231_ebus_pintr
expr_stmt|;
block|}
if|if
condition|(
name|snd_setup_intr
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_irqres
index|[
name|i
index|]
argument_list|,
name|INTR_MPSAFE
argument_list|,
name|ihandler
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot set up interrupt\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot set up %s "
literal|" interrupt\n"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"capture"
else|:
literal|"playback"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|sc
operator|->
name|sc_bufsz
operator|=
name|pcm_getbuffersize
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|CS4231_MIN_BUF_SZ
argument_list|,
name|CS4231_DEFAULT_BUF_SZ
argument_list|,
name|CS4231_MAX_BUF_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nires
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|64
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|sc
operator|->
name|sc_bufsz
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|sc
operator|->
name|sc_bufsz
argument_list|,
comment|/* maxsegsz */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|sc_dmat
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate DMA tag\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate %s "
literal|"DMA tag\n"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|"capture"
else|:
literal|"playback"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|cs4231_enable
argument_list|(
name|sc
argument_list|,
name|CODEC_WARM_RESET
argument_list|)
expr_stmt|;
name|cs4231_getversion
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
operator|&
name|cs4231_mixer_class
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|pcm_register
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot register to pcm\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|pcm_addchan
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCMDIR_REC
argument_list|,
operator|&
name|cs4231_chan_class
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|chan_fail
goto|;
if|if
condition|(
name|pcm_addchan
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|cs4231_chan_class
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|chan_fail
goto|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at mem 0x%lx irq %ld bufsz %u"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_irqres
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bufsz
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at io 0x%lx 0x%lx 0x%lx 0x%lx "
literal|"irq %ld %ld bufsz %u"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_irqres
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_irqres
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_bufsz
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|chan_fail
label|:
name|pcm_unregister
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|fail
label|:
name|cs4231_free_resource
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_bus_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|pch
decl_stmt|,
modifier|*
name|rch
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pch
operator|=
operator|&
name|sc
operator|->
name|sc_pch
expr_stmt|;
name|rch
operator|=
operator|&
name|sc
operator|->
name|sc_pch
expr_stmt|;
if|if
condition|(
name|pch
operator|->
name|locked
operator|||
name|rch
operator|->
name|locked
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 	 * Since EBDMA requires valid DMA buffer to drain its FIFO, we need 	 * real DMA buffer for draining. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_EBUS
operator|)
operator|!=
literal|0
condition|)
name|cs4231_ebdma_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cs4231_free_resource
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_bus_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_bus_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_getversion
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|v
decl_stmt|;
name|v
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_MISC_INFO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_codecv
operator|=
name|v
operator|&
name|CS_CODEC_ID_MASK
expr_stmt|;
name|v
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_VERSION_ID
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|(
name|CS_VERSION_NUMBER
operator||
name|CS_VERSION_CHIPID
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_chipvid
operator|=
name|v
expr_stmt|;
switch|switch
condition|(
name|v
condition|)
block|{
case|case
literal|0x80
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"<CS4231 Codec Id. %d>\n"
argument_list|,
name|sc
operator|->
name|sc_codecv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa0
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"<CS4231A Codec Id. %d>\n"
argument_list|,
name|sc
operator|->
name|sc_codecv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"<CS4232 Codec Id. %d>\n"
argument_list|,
name|sc
operator|->
name|sc_codecv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"<Unknown 0x%x Codec Id. %d\n"
argument_list|,
name|v
argument_list|,
name|sc
operator|->
name|sc_codecv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_ebdma_reset
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* playback */
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
operator|~
operator|(
name|EBDCSR_INTEN
operator||
name|EBDCSR_NEXTEN
operator|)
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDCSR_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
name|EBDCSR_DRAIN
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for playback DMA reset\n"
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
expr_stmt|;
comment|/* capture */
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
operator|~
operator|(
name|EBDCSR_INTEN
operator||
name|EBDCSR_NEXTEN
operator|)
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDCSR_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
name|EBDCSR_DRAIN
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for capture DMA reset\n"
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_power_reset
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_CSR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator||
name|APC_CSR_CODEC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator|&
operator|(
operator|~
name|APC_CSR_CODEC_RESET
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|AUXIO_READ
argument_list|(
name|sc
argument_list|,
name|AUXIO_CODEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|CODEC_WARM_RESET
operator|&&
name|v
operator|!=
literal|0
condition|)
block|{
name|AUXIO_WRITE
argument_list|(
name|sc
argument_list|,
name|AUXIO_CODEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|how
operator|==
name|CODEC_COLD_RESET
condition|)
block|{
name|AUXIO_WRITE
argument_list|(
name|sc
argument_list|,
name|AUXIO_CODEC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|AUXIO_WRITE
argument_list|(
name|sc
argument_list|,
name|AUXIO_CODEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
name|cs4231_ebdma_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|)
operator|==
name|CS_IN_INIT
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for reset\n"
argument_list|)
expr_stmt|;
comment|/* turn on cs4231 mode */
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_MISC_INFO
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_MISC_INFO
argument_list|)
operator||
name|CS_MODE2
argument_list|)
expr_stmt|;
comment|/* enable interrupts& clear CSR */
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_PIN_CONTROL
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_PIN_CONTROL
argument_list|)
operator||
name|INTERRUPT_ENABLE
argument_list|)
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* enable DAC output */
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_LEFT_OUTPUT_CONTROL
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_LEFT_OUTPUT_CONTROL
argument_list|)
operator|&
operator|~
name|OUTPUT_MUTE
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_RIGHT_OUTPUT_CONTROL
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_RIGHT_OUTPUT_CONTROL
argument_list|)
operator|&
operator|~
name|OUTPUT_MUTE
argument_list|)
expr_stmt|;
comment|/* mute AUX1 since it generates noises */
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_LEFT_AUX1_CONTROL
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_LEFT_AUX1_CONTROL
argument_list|)
operator||
name|AUX_INPUT_MUTE
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_RIGHT_AUX1_CONTROL
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_RIGHT_AUX1_CONTROL
argument_list|)
operator||
name|AUX_INPUT_MUTE
argument_list|)
expr_stmt|;
comment|/* protect buffer underrun and set output level to 0dB */
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_ALT_FEATURE1
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_ALT_FEATURE1
argument_list|)
operator||
name|CS_DAC_ZERO
operator||
name|CS_OUTPUT_LVL
argument_list|)
expr_stmt|;
comment|/* enable high pass filter, dual xtal was disabled due to noises */
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_ALT_FEATURE2
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_ALT_FEATURE2
argument_list|)
operator||
name|CS_HPF_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_enable
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|cs4231_power_reset
argument_list|(
name|sc
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_disable
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|v
decl_stmt|;
name|CS4231_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_enabled
operator|==
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_enabled
operator|=
literal|0
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cs4231_halt
argument_list|(
operator|&
name|sc
operator|->
name|sc_pch
argument_list|)
expr_stmt|;
name|cs4231_halt
argument_list|(
operator|&
name|sc
operator|->
name|sc_rch
argument_list|)
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_PIN_CONTROL
argument_list|)
operator|&
operator|~
name|INTERRUPT_ENABLE
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_PIN_CONTROL
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_CSR_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
name|cs4231_ebdma_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_free_resource
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cs4231_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nires
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_irqres
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ih
index|[
name|i
index|]
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_irqres
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|sc_ih
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|sc_irqrid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|sc_irqres
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irqres
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nires
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_dmat
index|[
name|i
index|]
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nmres
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_res
index|[
name|i
index|]
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|sc_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|sc_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|snd_mtxfree
argument_list|(
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_write
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|r
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|cs4231_read
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|r
parameter_list|)
block|{
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_sbus_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|pch
decl_stmt|,
modifier|*
name|rch
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|=
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|APC_CSR_GI
operator|)
operator|==
literal|0
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|APC_CSR_EIE
operator|)
operator|&&
operator|(
name|csr
operator|&
name|APC_CSR_EI
operator|)
condition|)
block|{
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"apc error interrupt : stat = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|pch
operator|=
name|rch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|APC_CSR_PMIE
operator|)
operator|&&
operator|(
name|csr
operator|&
name|APC_CSR_PMI
operator|)
condition|)
block|{
name|u_long
name|nextaddr
decl_stmt|,
name|saddr
decl_stmt|;
name|u_int32_t
name|togo
decl_stmt|;
name|pch
operator|=
operator|&
name|sc
operator|->
name|sc_pch
expr_stmt|;
name|togo
operator|=
name|pch
operator|->
name|togo
expr_stmt|;
name|saddr
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|pch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|nextaddr
operator|=
name|pch
operator|->
name|nextaddr
operator|+
name|togo
expr_stmt|;
if|if
condition|(
name|nextaddr
operator|>=
name|saddr
operator|+
name|sndbuf_getsize
argument_list|(
name|pch
operator|->
name|buffer
argument_list|)
condition|)
name|nextaddr
operator|=
name|saddr
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_PNVA
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_PNC
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|pch
operator|->
name|nextaddr
operator|=
name|nextaddr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csr
operator|&
name|APC_CSR_CIE
operator|)
operator|&&
operator|(
name|csr
operator|&
name|APC_CSR_CI
operator|)
operator|&&
operator|(
name|csr
operator|&
name|APC_CSR_CD
operator|)
condition|)
block|{
name|u_long
name|nextaddr
decl_stmt|,
name|saddr
decl_stmt|;
name|u_int32_t
name|togo
decl_stmt|;
name|rch
operator|=
operator|&
name|sc
operator|->
name|sc_rch
expr_stmt|;
name|togo
operator|=
name|rch
operator|->
name|togo
expr_stmt|;
name|saddr
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|rch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|nextaddr
operator|=
name|rch
operator|->
name|nextaddr
operator|+
name|togo
expr_stmt|;
if|if
condition|(
name|nextaddr
operator|>=
name|saddr
operator|+
name|sndbuf_getsize
argument_list|(
name|rch
operator|->
name|buffer
argument_list|)
condition|)
name|nextaddr
operator|=
name|saddr
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CNVA
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CNC
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|rch
operator|->
name|nextaddr
operator|=
name|nextaddr
expr_stmt|;
block|}
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pch
condition|)
name|chn_intr
argument_list|(
name|pch
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|rch
condition|)
name|chn_intr
argument_list|(
name|rch
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* playback interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|cs4231_ebus_pintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|=
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|EBDCSR_INT
operator|)
operator|==
literal|0
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|csr
operator|&
name|EBDCSR_ERR
operator|)
condition|)
block|{
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"ebdma error interrupt : stat = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|csr
operator||
name|EBDCSR_TC
argument_list|)
expr_stmt|;
name|ch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|EBDCSR_TC
condition|)
block|{
name|u_long
name|nextaddr
decl_stmt|,
name|saddr
decl_stmt|;
name|u_int32_t
name|togo
decl_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_pch
expr_stmt|;
name|togo
operator|=
name|ch
operator|->
name|togo
expr_stmt|;
name|saddr
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|nextaddr
operator|=
name|ch
operator|->
name|nextaddr
operator|+
name|togo
expr_stmt|;
if|if
condition|(
name|nextaddr
operator|>=
name|saddr
operator|+
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
condition|)
name|nextaddr
operator|=
name|saddr
expr_stmt|;
comment|/* 		 * EBDMA_DCNT is loaded automatically 		 * EBDMA_P_WRITE(sc, EBDMA_DCNT, togo); 		 */
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|ch
operator|->
name|nextaddr
operator|=
name|nextaddr
expr_stmt|;
block|}
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
condition|)
name|chn_intr
argument_list|(
name|ch
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* capture interrupt handler */
end_comment

begin_function
specifier|static
name|void
name|cs4231_ebus_cintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|u_int32_t
name|csr
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|=
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|EBDCSR_INT
operator|)
operator|==
literal|0
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|csr
operator|&
name|EBDCSR_ERR
operator|)
condition|)
block|{
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"dma error interrupt : stat = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|csr
operator||
name|EBDCSR_TC
argument_list|)
expr_stmt|;
name|ch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|EBDCSR_TC
condition|)
block|{
name|u_long
name|nextaddr
decl_stmt|,
name|saddr
decl_stmt|;
name|u_int32_t
name|togo
decl_stmt|;
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_rch
expr_stmt|;
name|togo
operator|=
name|ch
operator|->
name|togo
expr_stmt|;
name|saddr
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|nextaddr
operator|=
name|ch
operator|->
name|nextaddr
operator|+
name|togo
expr_stmt|;
if|if
condition|(
name|nextaddr
operator|>=
name|saddr
operator|+
name|sndbuf_getblksz
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
condition|)
name|nextaddr
operator|=
name|saddr
expr_stmt|;
comment|/* 		 * EBDMA_DCNT is loaded automatically 		 * EBDMA_C_WRITE(sc, EBDMA_DCNT, togo); 		 */
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|ch
operator|->
name|nextaddr
operator|=
name|nextaddr
expr_stmt|;
block|}
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
condition|)
name|chn_intr
argument_list|(
name|ch
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mix_table
name|cs4231_mix_table
index|[
name|SOUND_MIXER_NRDEVICES
index|]
index|[
literal|2
index|]
init|=
block|{
index|[
name|SOUND_MIXER_PCM
index|]
operator|=
block|{
block|{
name|CS_LEFT_OUTPUT_CONTROL
block|,
literal|6
block|,
name|OUTPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|CS_RIGHT_OUTPUT_CONTROL
block|,
literal|6
block|,
name|OUTPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|}
block|,
index|[
name|SOUND_MIXER_SPEAKER
index|]
operator|=
block|{
block|{
name|CS_MONO_IO_CONTROL
block|,
literal|4
block|,
name|MONO_OUTPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|CS_REG_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|}
block|,
index|[
name|SOUND_MIXER_LINE
index|]
operator|=
block|{
block|{
name|CS_LEFT_LINE_CONTROL
block|,
literal|5
block|,
name|LINE_INPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CS_RIGHT_LINE_CONTROL
block|,
literal|5
block|,
name|LINE_INPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
comment|/* 	 * AUX1 : removed intentionally since it generates noises 	 * AUX2 : Ultra1/Ultra2 has no internal CD-ROM audio in 	 */
index|[
name|SOUND_MIXER_CD
index|]
operator|=
block|{
block|{
name|CS_LEFT_AUX2_CONTROL
block|,
literal|5
block|,
name|LINE_INPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CS_RIGHT_AUX2_CONTROL
block|,
literal|5
block|,
name|LINE_INPUT_MUTE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
index|[
name|SOUND_MIXER_MIC
index|]
operator|=
block|{
block|{
name|CS_LEFT_INPUT_CONTROL
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
name|CS_RIGHT_INPUT_CONTROL
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
index|[
name|SOUND_MIXER_IGAIN
index|]
operator|=
block|{
block|{
name|CS_LEFT_INPUT_CONTROL
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|CS_RIGHT_INPUT_CONTROL
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cs4231_mixer_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cs4231_mix_table
index|[
name|i
index|]
index|[
literal|0
index|]
operator|.
name|avail
operator|!=
literal|0
condition|)
name|v
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cs4231_mix_table
index|[
name|i
index|]
index|[
literal|0
index|]
operator|.
name|recdev
operator|!=
literal|0
condition|)
name|v
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|mix_setrecdevs
argument_list|(
name|m
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_mixer_set_value
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|mix_table
modifier|*
name|mt
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|u_int8_t
name|mask
decl_stmt|,
name|reg
decl_stmt|;
name|u_int8_t
name|old
decl_stmt|,
name|shift
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|mt
operator|->
name|avail
operator|==
literal|0
operator|||
name|mt
operator|->
name|reg
operator|==
name|CS_REG_NONE
condition|)
return|return;
name|reg
operator|=
name|mt
operator|->
name|reg
expr_stmt|;
if|if
condition|(
name|mt
operator|->
name|neg
operator|!=
literal|0
condition|)
name|val
operator|=
literal|100
operator|-
name|v
expr_stmt|;
else|else
name|val
operator|=
name|v
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|mt
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|*
name|mask
operator|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|shift
operator|=
name|mt
operator|->
name|shift
expr_stmt|;
name|val
operator|<<=
name|shift
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|val
operator||=
name|mt
operator|->
name|mute
expr_stmt|;
name|old
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|old
operator|&=
operator|~
operator|(
name|mt
operator|->
name|mute
operator||
operator|(
name|mask
operator|<<
name|shift
operator|)
operator|)
expr_stmt|;
name|val
operator||=
name|old
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|CS_LEFT_INPUT_CONTROL
operator|||
name|reg
operator|==
name|CS_RIGHT_INPUT_CONTROL
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|mask
operator|<<
name|shift
operator|)
operator|)
operator|!=
literal|0
condition|)
name|val
operator||=
name|ADC_INPUT_GAIN_ENABLE
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|ADC_INPUT_GAIN_ENABLE
expr_stmt|;
block|}
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_mixer_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|dev
parameter_list|,
name|u_int32_t
name|left
parameter_list|,
name|u_int32_t
name|right
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cs4231_mixer_set_value
argument_list|(
name|sc
argument_list|,
operator|&
name|cs4231_mix_table
index|[
name|dev
index|]
index|[
literal|0
index|]
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|cs4231_mixer_set_value
argument_list|(
name|sc
argument_list|,
operator|&
name|cs4231_mix_table
index|[
name|dev
index|]
index|[
literal|1
index|]
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|cs4231_mixer_setrecsrc
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|u_int32_t
name|src
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|v
decl_stmt|;
name|sc
operator|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src
condition|)
block|{
case|case
name|SOUND_MASK_LINE
case|:
name|v
operator|=
name|CS_IN_LINE
expr_stmt|;
break|break;
case|case
name|SOUND_MASK_CD
case|:
name|v
operator|=
name|CS_IN_DAC
expr_stmt|;
break|break;
case|case
name|SOUND_MASK_MIC
case|:
default|default:
name|v
operator|=
name|CS_IN_MIC
expr_stmt|;
name|src
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
break|break;
block|}
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_LEFT_INPUT_CONTROL
argument_list|,
operator|(
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_LEFT_INPUT_CONTROL
argument_list|)
operator|&
name|CS_IN_MASK
operator|)
operator||
name|v
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_RIGHT_INPUT_CONTROL
argument_list|,
operator|(
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_RIGHT_INPUT_CONTROL
argument_list|)
operator|&
name|CS_IN_MASK
operator|)
operator||
name|v
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|src
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|cs4231_chan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|dev
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|sc
operator|=
name|dev
expr_stmt|;
name|ch
operator|=
operator|(
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_pch
else|:
operator|&
name|sc
operator|->
name|sc_rch
expr_stmt|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|dmat
operator|=
name|sc
operator|->
name|sc_dmat
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
name|dmat
operator|=
name|sc
operator|->
name|sc_dmat
index|[
literal|1
index|]
expr_stmt|;
else|else
name|dmat
operator|=
name|sc
operator|->
name|sc_dmat
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sndbuf_alloc
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|dmat
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_bufsz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s channel addr: 0x%lx\n"
operator|,
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|"playback"
else|:
literal|"capture"
operator|,
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_chan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|format
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|u_int32_t
name|encoding
decl_stmt|;
name|u_int8_t
name|fs
decl_stmt|,
name|v
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
name|sc
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|format
operator|==
name|format
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|encoding
operator|=
name|AFMT_ENCODING
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|fs
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|AFMT_U8
case|:
name|fs
operator|=
name|CS_AFMT_U8
expr_stmt|;
break|break;
case|case
name|AFMT_MU_LAW
case|:
name|fs
operator|=
name|CS_AFMT_MU_LAW
expr_stmt|;
break|break;
case|case
name|AFMT_S16_LE
case|:
name|fs
operator|=
name|CS_AFMT_S16_LE
expr_stmt|;
break|break;
case|case
name|AFMT_A_LAW
case|:
name|fs
operator|=
name|CS_AFMT_A_LAW
expr_stmt|;
break|break;
case|case
name|AFMT_IMA_ADPCM
case|:
name|fs
operator|=
name|CS_AFMT_IMA_ADPCM
expr_stmt|;
break|break;
case|case
name|AFMT_S16_BE
case|:
name|fs
operator|=
name|CS_AFMT_S16_BE
expr_stmt|;
break|break;
default|default:
name|fs
operator|=
name|CS_AFMT_U8
expr_stmt|;
name|format
operator|=
name|AFMT_U8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|AFMT_CHANNEL
argument_list|(
name|format
argument_list|)
operator|>
literal|1
condition|)
name|fs
operator||=
name|CS_AFMT_STEREO
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"FORMAT: %s : 0x%x\n"
operator|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|"playback"
else|:
literal|"capture"
operator|,
name|format
operator|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_CLOCK_DATA_FORMAT
argument_list|)
expr_stmt|;
name|v
operator|&=
name|CS_CLOCK_DATA_FORMAT_MASK
expr_stmt|;
name|fs
operator||=
name|v
expr_stmt|;
name|cs4231_chan_fs
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|dir
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|ch
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|cs4231_chan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|speed
parameter_list|)
block|{
typedef|typedef
struct|struct
block|{
name|u_int32_t
name|speed
decl_stmt|;
name|u_int8_t
name|bits
decl_stmt|;
block|}
name|speed_struct
typedef|;
specifier|const
specifier|static
name|speed_struct
name|speed_table
index|[]
init|=
block|{
block|{
literal|5510
block|,
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|5510
block|,
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|6620
block|,
operator|(
literal|7
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|8000
block|,
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL1
block|}
block|,
block|{
literal|9600
block|,
operator|(
literal|7
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL1
block|}
block|,
block|{
literal|11025
block|,
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|16000
block|,
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL1
block|}
block|,
block|{
literal|18900
block|,
operator|(
literal|2
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|22050
block|,
operator|(
literal|3
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|27420
block|,
operator|(
literal|2
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL1
block|}
block|,
block|{
literal|32000
block|,
operator|(
literal|3
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL1
block|}
block|,
block|{
literal|33075
block|,
operator|(
literal|6
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|33075
block|,
operator|(
literal|4
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|44100
block|,
operator|(
literal|5
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL2
block|}
block|,
block|{
literal|48000
block|,
operator|(
literal|6
operator|<<
literal|1
operator|)
operator||
name|CLOCK_XTAL1
block|}
block|, 	}
decl_stmt|;
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|sel
decl_stmt|;
name|u_int8_t
name|fs
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
name|sc
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|speed
operator|==
name|speed
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|speed
operator|)
return|;
block|}
name|n
operator|=
sizeof|sizeof
argument_list|(
name|speed_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|speed_struct
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|sel
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|abs
argument_list|(
name|speed
operator|-
name|speed_table
index|[
name|i
index|]
operator|.
name|speed
argument_list|)
operator|<
name|abs
argument_list|(
name|speed
operator|-
name|speed_table
index|[
name|sel
index|]
operator|.
name|speed
argument_list|)
condition|)
name|sel
operator|=
name|i
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"SPEED: %s : %dHz -> %dHz\n"
operator|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|"playback"
else|:
literal|"capture"
operator|,
name|speed
operator|,
name|speed_table
index|[
name|sel
index|]
operator|.
name|speed
operator|)
argument_list|)
expr_stmt|;
name|speed
operator|=
name|speed_table
index|[
name|sel
index|]
operator|.
name|speed
expr_stmt|;
name|fs
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_CLOCK_DATA_FORMAT
argument_list|)
expr_stmt|;
name|fs
operator|&=
operator|~
name|CS_CLOCK_DATA_FORMAT_MASK
expr_stmt|;
name|fs
operator||=
name|speed_table
index|[
name|sel
index|]
operator|.
name|bits
expr_stmt|;
name|cs4231_chan_fs
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|dir
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|ch
operator|->
name|speed
operator|=
name|speed
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|speed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_chan_fs
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dir
parameter_list|,
name|u_int8_t
name|fs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|doreset
decl_stmt|;
ifdef|#
directive|ifdef
name|CS4231_AUTO_CALIBRATION
name|u_int8_t
name|v
decl_stmt|;
endif|#
directive|endif
name|CS4231_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set autocalibration */
name|doreset
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CS4231_AUTO_CALIBRATION
name|v
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator||
name|AUTO_CAL_ENABLE
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|MODE_CHANGE_ENABLE
argument_list|)
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|MODE_CHANGE_ENABLE
operator||
name|CS_INTERFACE_CONFIG
argument_list|)
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We always need to write CS_CLOCK_DATA_FORMAT register since 	 * the clock frequency is shared with playback/capture. 	 */
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|MODE_CHANGE_ENABLE
operator||
name|CS_CLOCK_DATA_FORMAT
argument_list|)
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|)
expr_stmt|;
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|)
operator|==
name|CS_IN_INIT
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout setting playback speed\n"
argument_list|)
expr_stmt|;
name|doreset
operator|++
expr_stmt|;
block|}
comment|/* 	 * capture channel 	 * cs4231 doesn't allow separate fs setup for playback/capture. 	 * I believe this will break full-duplex operation. 	 */
if|if
condition|(
name|dir
operator|==
name|PCMDIR_REC
condition|)
block|{
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|MODE_CHANGE_ENABLE
operator||
name|CS_REC_FORMAT
argument_list|)
expr_stmt|;
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|)
expr_stmt|;
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|)
operator|==
name|CS_IN_INIT
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout setting capture format\n"
argument_list|)
expr_stmt|;
name|doreset
operator|++
expr_stmt|;
block|}
block|}
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|)
operator|==
name|CS_IN_INIT
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for !MCE\n"
argument_list|)
expr_stmt|;
name|doreset
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CS4231_AUTO_CALIBRATION
name|CS_WRITE
argument_list|(
name|sc
argument_list|,
name|CS4231_IADDR
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
name|CS_READ
argument_list|(
name|sc
argument_list|,
name|CS4231_IDATA
argument_list|)
operator|&
name|AUTO_CAL_IN_PROG
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for autocalibration\n"
argument_list|)
expr_stmt|;
name|doreset
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|doreset
condition|)
block|{
comment|/* 		 * Maybe the last resort to avoid a dreadful message like 		 * "pcm0:play:0: play interrupt timeout, channel dead" would 		 * be hardware reset. 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"trying to hardware reset\n"
argument_list|)
expr_stmt|;
name|cs4231_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cs4231_enable
argument_list|(
name|sc
argument_list|,
name|CODEC_COLD_RESET
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|mixer_reinit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to reinitialize the mixer\n"
argument_list|)
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|cs4231_chan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|int
name|nblks
decl_stmt|,
name|error
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
name|sc
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|blocksize
operator|>
name|CS4231_MAX_BLK_SZ
condition|)
name|blocksize
operator|=
name|CS4231_MAX_BLK_SZ
expr_stmt|;
name|nblks
operator|=
name|sc
operator|->
name|sc_bufsz
operator|/
name|blocksize
expr_stmt|;
name|error
operator|=
name|sndbuf_resize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|nblks
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to block size, blksz = %d, error = %d\n"
argument_list|,
name|blocksize
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|blocksize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cs4231_chan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_EMLDMAWR
case|:
case|case
name|PCMTRIG_EMLDMARD
case|:
break|break;
case|case
name|PCMTRIG_START
case|:
name|cs4231_trigger
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_ABORT
case|:
case|case
name|PCMTRIG_STOP
case|:
name|cs4231_halt
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|cs4231_chan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cs4231_channel
modifier|*
name|ch
decl_stmt|;
name|u_int32_t
name|cur
decl_stmt|,
name|ptr
decl_stmt|,
name|sz
decl_stmt|;
name|ch
operator|=
name|data
expr_stmt|;
name|sc
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|cur
operator|=
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_PVA
argument_list|)
else|:
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CVA
argument_list|)
expr_stmt|;
else|else
name|cur
operator|=
operator|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
operator|)
condition|?
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|)
else|:
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|)
expr_stmt|;
name|sz
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|cur
operator|-
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|+
name|sz
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ptr
operator|%=
name|sz
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|cs4231_chan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|&
name|cs4231_caps
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_trigger
parameter_list|(
name|struct
name|cs4231_channel
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
name|cs4231_apcdma_trigger
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
name|cs4231_ebdma_trigger
argument_list|(
name|sc
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_apcdma_trigger
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cs4231_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|csr
decl_stmt|,
name|togo
decl_stmt|;
name|u_int32_t
name|nextaddr
decl_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|locked
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s channel already triggered\n"
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|"playback"
else|:
literal|"capture"
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|nextaddr
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|togo
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|togo
operator|>
name|CS4231_MAX_APC_DMA_SZ
condition|)
name|togo
operator|=
name|CS4231_MAX_APC_DMA_SZ
expr_stmt|;
name|ch
operator|->
name|togo
operator|=
name|togo
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"TRG: PNVA = 0x%x, togo = 0x%x\n"
operator|,
name|nextaddr
operator|,
name|togo
operator|)
argument_list|)
expr_stmt|;
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
comment|/* clear pending error */
name|csr
operator|=
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_PNVA
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_PNC
argument_list|,
name|togo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|APC_CSR_PDMA_GO
operator|)
operator|==
literal|0
operator|||
operator|(
name|csr
operator|&
name|APC_CSR_PPAUSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator|&
operator|~
operator|(
name|APC_CSR_PIE
operator||
name|APC_CSR_PPAUSE
operator|)
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator||
name|APC_CSR_GIE
operator||
name|APC_CSR_PIE
operator||
name|APC_CSR_EIE
operator||
name|APC_CSR_EI
operator||
name|APC_CSR_PMIE
operator||
name|APC_CSR_PDMA_GO
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator||
name|PLAYBACK_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* load next address */
if|if
condition|(
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator|&
name|APC_CSR_PD
condition|)
block|{
name|nextaddr
operator|+=
name|togo
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_PNVA
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_PNC
argument_list|,
name|togo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"TRG: CNVA = 0x%x, togo = 0x%x\n"
operator|,
name|nextaddr
operator|,
name|togo
operator|)
argument_list|)
expr_stmt|;
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
comment|/* clear pending error */
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CNVA
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CNC
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|csr
operator|=
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|csr
operator|&
name|APC_CSR_CDMA_GO
operator|)
operator|==
literal|0
operator|||
operator|(
name|csr
operator|&
name|APC_CSR_CPAUSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|csr
operator|&=
name|APC_CSR_CPAUSE
expr_stmt|;
name|csr
operator||=
name|APC_CSR_GIE
operator||
name|APC_CSR_CMIE
operator||
name|APC_CSR_CIE
operator||
name|APC_CSR_EI
operator||
name|APC_CSR_CDMA_GO
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator||
name|CAPTURE_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* load next address */
if|if
condition|(
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator|&
name|APC_CSR_CD
condition|)
block|{
name|nextaddr
operator|+=
name|togo
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CNVA
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CNC
argument_list|,
name|togo
argument_list|)
expr_stmt|;
block|}
block|}
name|ch
operator|->
name|nextaddr
operator|=
name|nextaddr
expr_stmt|;
name|ch
operator|->
name|locked
operator|=
literal|1
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_ebdma_trigger
parameter_list|(
name|struct
name|cs4231_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cs4231_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|csr
decl_stmt|,
name|togo
decl_stmt|;
name|u_int32_t
name|nextaddr
decl_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|locked
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s channel already triggered\n"
argument_list|,
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|?
literal|"playback"
else|:
literal|"capture"
argument_list|)
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|nextaddr
operator|=
name|sndbuf_getbufaddr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|togo
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|togo
operator|%
literal|64
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_burst
operator|=
name|EBDCSR_BURST_16
expr_stmt|;
elseif|else
if|if
condition|(
name|togo
operator|%
literal|32
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_burst
operator|=
name|EBDCSR_BURST_8
expr_stmt|;
elseif|else
if|if
condition|(
name|togo
operator|%
literal|16
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_burst
operator|=
name|EBDCSR_BURST_4
expr_stmt|;
else|else
name|sc
operator|->
name|sc_burst
operator|=
name|EBDCSR_BURST_1
expr_stmt|;
name|ch
operator|->
name|togo
operator|=
name|togo
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"TRG: DNAR = 0x%x, togo = 0x%x\n"
operator|,
name|nextaddr
operator|,
name|togo
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
comment|/* clear pending error */
name|csr
operator|=
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|EBDCSR_DMAEN
condition|)
block|{
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCNT
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDCSR_RESET
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCNT
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|sc
operator|->
name|sc_burst
operator||
name|EBDCSR_DMAEN
operator||
name|EBDCSR_INTEN
operator||
name|EBDCSR_CNTEN
operator||
name|EBDCSR_NEXTEN
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator||
name|PLAYBACK_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* load next address */
if|if
condition|(
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
name|EBDCSR_A_LOADED
condition|)
block|{
name|nextaddr
operator|+=
name|togo
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCNT
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
comment|/* clear pending error */
name|csr
operator|=
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|EBDCSR_DMAEN
condition|)
block|{
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCNT
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDCSR_RESET
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|sc
operator|->
name|sc_burst
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCNT
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|sc
operator|->
name|sc_burst
operator||
name|EBDCSR_WRITE
operator||
name|EBDCSR_DMAEN
operator||
name|EBDCSR_INTEN
operator||
name|EBDCSR_CNTEN
operator||
name|EBDCSR_NEXTEN
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator||
name|CAPTURE_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* load next address */
if|if
condition|(
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
name|EBDCSR_A_LOADED
condition|)
block|{
name|nextaddr
operator|+=
name|togo
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCNT
argument_list|,
name|togo
argument_list|)
expr_stmt|;
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DADDR
argument_list|,
name|nextaddr
argument_list|)
expr_stmt|;
block|}
block|}
name|ch
operator|->
name|nextaddr
operator|=
name|nextaddr
expr_stmt|;
name|ch
operator|->
name|locked
operator|=
literal|1
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cs4231_halt
parameter_list|(
name|struct
name|cs4231_channel
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|cs4231_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|ch
operator|->
name|parent
expr_stmt|;
name|CS4231_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|locked
operator|==
literal|0
condition|)
block|{
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ch
operator|->
name|dir
operator|==
name|PCMDIR_PLAY
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX Kills some capture bits */
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_READ
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|)
operator|&
operator|~
operator|(
name|APC_CSR_EI
operator||
name|APC_CSR_GIE
operator||
name|APC_CSR_PIE
operator||
name|APC_CSR_EIE
operator||
name|APC_CSR_PDMA_GO
operator||
name|APC_CSR_PMIE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EBDMA_P_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDMA_P_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
operator|~
name|EBDCSR_DMAEN
argument_list|)
expr_stmt|;
block|}
comment|/* Waiting for playback FIFO to empty */
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
operator|(
name|status
operator|&
name|PLAYBACK_UNDERRUN
operator|)
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for "
literal|"playback FIFO drain\n"
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator|&
operator|(
operator|~
name|PLAYBACK_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|CS4231_SBUS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX Kills some playback bits */
name|APC_WRITE
argument_list|(
name|sc
argument_list|,
name|APC_CSR
argument_list|,
name|APC_CSR_CAPTURE_PAUSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EBDMA_C_WRITE
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|,
name|EBDMA_C_READ
argument_list|(
name|sc
argument_list|,
name|EBDMA_DCSR
argument_list|)
operator|&
operator|~
name|EBDCSR_DMAEN
argument_list|)
expr_stmt|;
block|}
comment|/* Waiting for capture FIFO to empty */
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CS_TIMEOUT
init|;
name|i
operator|&&
operator|(
name|status
operator|&
name|CAPTURE_OVERRUN
operator|)
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|status
operator|=
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_TEST_AND_INIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout waiting for "
literal|"capture FIFO drain\n"
argument_list|)
expr_stmt|;
name|cs4231_write
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|,
name|cs4231_read
argument_list|(
name|sc
argument_list|,
name|CS_INTERFACE_CONFIG
argument_list|)
operator|&
operator|(
operator|~
name|CAPTURE_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|locked
operator|=
literal|0
expr_stmt|;
name|CS4231_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

