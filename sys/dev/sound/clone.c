begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Ariff Abdullah<ariff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SND_DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|SND_DEBUG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/clone.h>
end_include

begin_comment
comment|/*  * So here we go again, another clonedevs manager. Unlike default clonedevs,  * this clone manager is designed to withstand various abusive behavior  * (such as 'while : ; do ls /dev/whatever ; done', etc.), reusable object  * after reaching certain expiration threshold, aggressive garbage collector,  * transparent device allocator and concurrency handling across multiple  * thread/proc. Due to limited information given by dev_clone EVENTHANDLER,  * we don't have much clues whether the caller wants a real open() or simply  * making fun of us with things like stat(), mtime() etc. Assuming that:  * 1) Time window between dev_clone EH<-> real open() should be small  * enough and 2) mtime()/stat() etc. always looks like a half way / stalled  * operation, we can decide whether a new cdev must be created, old  * (expired) cdev can be reused or an existing cdev can be shared.  *  * Most of the operations and logics are generic enough and can be applied  * on other places (such as if_tap, snp, etc).  Perhaps this can be  * rearranged to complement clone_*(). However, due to this still being  * specific to the sound driver (and as a proof of concept on how it can be  * done), si_drv2 is used to keep the pointer of the clone list entry to  * avoid expensive lookup.  */
end_comment

begin_comment
comment|/* clone entry */
end_comment

begin_struct
struct|struct
name|snd_clone_entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|snd_clone_entry
argument_list|)
name|link
expr_stmt|;
name|struct
name|snd_clone
modifier|*
name|parent
decl_stmt|;
name|struct
name|cdev
modifier|*
name|devt
decl_stmt|;
name|struct
name|timespec
name|tsp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* clone manager */
end_comment

begin_struct
struct|struct
name|snd_clone
block|{
name|TAILQ_HEAD
argument_list|(
argument|link_head
argument_list|,
argument|snd_clone_entry
argument_list|)
name|head
expr_stmt|;
name|struct
name|timespec
name|tsp
decl_stmt|;
name|int
name|refcount
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|typemask
decl_stmt|;
name|int
name|maxunit
decl_stmt|;
name|int
name|deadline
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SND_DIAGNOSTIC
end_ifdef

begin_define
define|#
directive|define
name|SND_CLONE_ASSERT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do {			\ 	if (!(x))						\ 		panic y;					\ } while(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SND_CLONE_ASSERT
parameter_list|(
name|x
modifier|...
parameter_list|)
value|KASSERT(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Shamelessly ripped off from vfs_subr.c  * We need at least 1/HZ precision as default timestamping.  */
end_comment

begin_enum
enum|enum
block|{
name|SND_TSP_SEC
block|,
name|SND_TSP_HZ
block|,
name|SND_TSP_USEC
block|,
name|SND_TSP_NSEC
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|snd_timestamp_precision
init|=
name|SND_TSP_HZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.snd.timestamp_precision"
argument_list|,
operator|&
name|snd_timestamp_precision
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|snd_timestamp
parameter_list|(
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
switch|switch
condition|(
name|snd_timestamp_precision
condition|)
block|{
case|case
name|SND_TSP_SEC
case|:
name|tsp
operator|->
name|tv_sec
operator|=
name|time_second
expr_stmt|;
name|tsp
operator|->
name|tv_nsec
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SND_TSP_HZ
case|:
name|getnanouptime
argument_list|(
name|tsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SND_TSP_USEC
case|:
name|microuptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SND_TSP_NSEC
case|:
name|nanouptime
argument_list|(
name|tsp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|snd_timestamp_precision
operator|=
name|SND_TSP_HZ
expr_stmt|;
name|getnanouptime
argument_list|(
name|tsp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SND_DIAGNOSTIC
argument_list|)
operator|||
name|defined
argument_list|(
name|SND_DEBUG
argument_list|)
end_if

begin_function
specifier|static
name|int
name|sysctl_hw_snd_timestamp_precision
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|snd_timestamp_precision
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|SND_TSP_SEC
case|:
case|case
name|SND_TSP_HZ
case|:
case|case
name|SND_TSP_USEC
case|:
case|case
name|SND_TSP_NSEC
case|:
name|snd_timestamp_precision
operator|=
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|timestamp_precision
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_hw_snd_timestamp_precision
argument_list|,
literal|"I"
argument_list|,
literal|"timestamp precision (0=s 1=hz 2=us 3=ns)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * snd_clone_create() : Return opaque allocated clone manager.  */
end_comment

begin_function
name|struct
name|snd_clone
modifier|*
name|snd_clone_create
parameter_list|(
name|int
name|typemask
parameter_list|,
name|int
name|maxunit
parameter_list|,
name|int
name|deadline
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|snd_clone
modifier|*
name|c
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|!
operator|(
name|typemask
operator|&
operator|~
name|SND_CLONE_MAXUNIT
operator|)
argument_list|,
operator|(
literal|"invalid typemask: 0x%08x"
operator|,
name|typemask
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|maxunit
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
name|maxunit
operator|&
operator|~
operator|(
operator|~
name|typemask
operator|&
name|SND_CLONE_MAXUNIT
operator|)
operator|)
argument_list|,
operator|(
literal|"maxunit overflow: typemask=0x%08x maxunit=%d"
operator|,
name|typemask
operator|,
name|maxunit
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
operator|~
name|SND_CLONE_MASK
operator|)
argument_list|,
operator|(
literal|"invalid clone flags=0x%08x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|c
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|typemask
operator|=
name|typemask
expr_stmt|;
name|c
operator|->
name|maxunit
operator|=
operator|(
name|maxunit
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
operator|~
name|typemask
operator|&
name|SND_CLONE_MAXUNIT
operator|)
else|:
name|maxunit
expr_stmt|;
name|c
operator|->
name|deadline
operator|=
name|deadline
expr_stmt|;
name|c
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|snd_timestamp
argument_list|(
operator|&
name|c
operator|->
name|tsp
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|c
operator|->
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_busy
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|&c->head
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_BUSY
operator|)
operator|||
operator|(
name|ce
operator|->
name|devt
operator|!=
name|NULL
operator|&&
name|ce
operator|->
name|devt
operator|->
name|si_threadcount
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * snd_clone_enable()/disable() : Suspend/resume clone allocation through  * snd_clone_alloc(). Everything else will not be affected by this.  */
end_comment

begin_function
name|int
name|snd_clone_enable
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_ENABLE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|c
operator|->
name|flags
operator||=
name|SND_CLONE_ENABLE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_disable
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_ENABLE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|c
operator|->
name|flags
operator|&=
operator|~
name|SND_CLONE_ENABLE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Getters / Setters. Not worth explaining :)  */
end_comment

begin_function
name|int
name|snd_clone_getsize
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_getmaxunit
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|maxunit
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_setmaxunit
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|,
name|int
name|maxunit
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|maxunit
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
name|maxunit
operator|&
operator|~
operator|(
operator|~
name|c
operator|->
name|typemask
operator|&
name|SND_CLONE_MAXUNIT
operator|)
operator|)
argument_list|,
operator|(
literal|"maxunit overflow: typemask=0x%08x maxunit=%d"
operator|,
name|c
operator|->
name|typemask
operator|,
name|maxunit
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|maxunit
operator|=
operator|(
name|maxunit
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
operator|~
name|c
operator|->
name|typemask
operator|&
name|SND_CLONE_MAXUNIT
operator|)
else|:
name|maxunit
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|maxunit
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_getdeadline
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|deadline
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_setdeadline
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|,
name|int
name|deadline
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|deadline
operator|=
name|deadline
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|deadline
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_gettime
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|tsp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL timespec"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|tsp
operator|=
name|c
operator|->
name|tsp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|snd_clone_getflags
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|snd_clone_setflags
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
operator|~
name|SND_CLONE_MASK
operator|)
argument_list|,
operator|(
literal|"invalid clone flags=0x%08x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_getdevtime
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|tsp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL timespec"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|tsp
operator|=
name|ce
operator|->
name|tsp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|snd_clone_getdevflags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0xffffffff
operator|)
return|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ce
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|snd_clone_setdevflags
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
operator|~
name|SND_CLONE_DEVMASK
operator|)
argument_list|,
operator|(
literal|"invalid clone dev flags=0x%08x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0xffffffff
operator|)
return|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ce
operator|->
name|flags
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Elapsed time conversion to ms */
end_comment

begin_define
define|#
directive|define
name|SND_CLONE_ELAPSED
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|((((x)->tv_sec - (y)->tv_sec) * 1000) +				\ 	(((y)->tv_nsec> (x)->tv_nsec) ?				\ 	(((1000000000L + (x)->tv_nsec -					\ 	(y)->tv_nsec) / 1000000) - 1000) :				\ 	(((x)->tv_nsec - (y)->tv_nsec) / 1000000)))
end_define

begin_define
define|#
directive|define
name|SND_CLONE_EXPIRED
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
define|\
value|((x)->deadline< 1 ||						\ 	((y)->tv_sec - (z)->tv_sec)> ((x)->deadline / 1000) ||		\ 	SND_CLONE_ELAPSED(y, z)> (x)->deadline)
end_define

begin_comment
comment|/*  * snd_clone_gc() : Garbage collector for stalled, expired objects. Refer to  * clone.h for explanations on GC settings.  */
end_comment

begin_function
name|int
name|snd_clone_gc
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|,
modifier|*
name|tce
decl_stmt|;
name|struct
name|timespec
name|now
decl_stmt|;
name|int
name|pruned
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_GC_ENABLE
operator|)
operator|||
name|c
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|snd_timestamp
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Bail out if the last clone handler was invoked below the deadline 	 * threshold. 	 */
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_GC_EXPIRED
operator|)
operator|&&
operator|!
name|SND_CLONE_EXPIRED
argument_list|(
name|c
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|c
operator|->
name|tsp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pruned
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Visit each object in reverse order. If the object is still being 	 * referenced by a valid open(), skip it. Look for expired objects 	 * and either revoke its clone invocation status or mercilessly 	 * throw it away. 	 */
name|TAILQ_FOREACH_REVERSE_SAFE
argument_list|(
argument|ce
argument_list|,
argument|&c->head
argument_list|,
argument|link_head
argument_list|,
argument|link
argument_list|,
argument|tce
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_BUSY
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_INVOKE
operator|)
operator|||
name|SND_CLONE_EXPIRED
argument_list|(
name|c
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|ce
operator|->
name|tsp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_GC_REVOKE
operator|)
operator|||
name|ce
operator|->
name|devt
operator|->
name|si_threadcount
operator|!=
literal|0
condition|)
block|{
name|ce
operator|->
name|flags
operator|&=
operator|~
name|SND_CLONE_INVOKE
expr_stmt|;
name|ce
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|c
operator|->
name|head
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|ce
operator|->
name|devt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|c
operator|->
name|size
operator|--
expr_stmt|;
block|}
name|pruned
operator|++
expr_stmt|;
block|}
block|}
comment|/* return total pruned objects */
return|return
operator|(
name|pruned
operator|)
return|;
block|}
end_function

begin_function
name|void
name|snd_clone_destroy
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|c
operator|->
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|ce
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|TAILQ_NEXT
argument_list|(
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|devt
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|ce
operator|->
name|devt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ce
operator|=
name|tmp
expr_stmt|;
block|}
name|free
argument_list|(
name|c
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * snd_clone_acquire() : The vital part of concurrency management. Must be  * called somewhere at the beginning of open() handler. ENODEV is not really  * fatal since it just tell the caller that this is not cloned stuff.  * EBUSY is *real*, don't forget that!  */
end_comment

begin_function
name|int
name|snd_clone_acquire
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|->
name|flags
operator|&=
operator|~
name|SND_CLONE_INVOKE
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_BUSY
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ce
operator|->
name|flags
operator||=
name|SND_CLONE_BUSY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * snd_clone_release() : Release busy status. Must be called somewhere at  * the end of close() handler, or somewhere after fail open().  */
end_comment

begin_function
name|int
name|snd_clone_release
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|->
name|flags
operator|&=
operator|~
name|SND_CLONE_INVOKE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_BUSY
operator|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|ce
operator|->
name|flags
operator|&=
operator|~
name|SND_CLONE_BUSY
expr_stmt|;
name|ce
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * snd_clone_ref/unref() : Garbage collector reference counter. To make  * garbage collector run automatically, the sequence must be something like  * this (both in open() and close() handlers):  *  *  open() - 1) snd_clone_acquire()  *           2) .... check check ... if failed, snd_clone_release()  *           3) Success. Call snd_clone_ref()  *  * close() - 1) .... check check check ....  *           2) Success. snd_clone_release()  *           3) snd_clone_unref() . Garbage collector will run at this point  *              if this is the last referenced object.  */
end_comment

begin_function
name|int
name|snd_clone_ref
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|struct
name|snd_clone
modifier|*
name|c
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
name|ce
operator|->
name|parent
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|->
name|refcount
operator|>=
literal|0
argument_list|,
operator|(
literal|"refcount< 0"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|++
name|c
operator|->
name|refcount
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snd_clone_unref
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|;
name|struct
name|snd_clone
modifier|*
name|c
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|ce
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
name|ce
operator|->
name|parent
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|->
name|refcount
operator|>
literal|0
argument_list|,
operator|(
literal|"refcount<= 0"
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|refcount
operator|--
expr_stmt|;
comment|/*  	 * Run automatic garbage collector, if needed. 	 */
if|if
condition|(
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_GC_UNREF
operator|)
operator|&&
operator|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_GC_LASTREF
operator|)
operator|||
operator|(
name|c
operator|->
name|refcount
operator|==
literal|0
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_GC_LASTREF
operator|)
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|snd_clone_gc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|->
name|refcount
operator|)
return|;
block|}
end_function

begin_function
name|void
name|snd_clone_register
parameter_list|(
name|struct
name|snd_clone_entry
modifier|*
name|ce
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone_entry"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|->
name|si_drv2
operator|==
name|NULL
argument_list|,
operator|(
literal|"dev->si_drv2 not NULL"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_ALLOC
operator|)
operator|==
name|SND_CLONE_ALLOC
argument_list|,
operator|(
literal|"invalid clone alloc flags=0x%08x"
operator|,
name|ce
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|devt
operator|==
name|NULL
argument_list|,
operator|(
literal|"ce->devt not NULL"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|unit
operator|==
name|dev2unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
literal|"invalid unit ce->unit=0x%08x dev2unit=0x%08x"
operator|,
name|ce
operator|->
name|unit
operator|,
name|dev2unit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|ce
operator|->
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent"
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv2
operator|=
name|ce
expr_stmt|;
name|ce
operator|->
name|devt
operator|=
name|dev
expr_stmt|;
name|ce
operator|->
name|flags
operator|&=
operator|~
name|SND_CLONE_ALLOC
expr_stmt|;
name|ce
operator|->
name|flags
operator||=
name|SND_CLONE_INVOKE
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|snd_clone_entry
modifier|*
name|snd_clone_alloc
parameter_list|(
name|struct
name|snd_clone
modifier|*
name|c
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|dev
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|,
name|int
name|tmask
parameter_list|)
block|{
name|struct
name|snd_clone_entry
modifier|*
name|ce
decl_stmt|,
modifier|*
name|after
decl_stmt|,
modifier|*
name|bce
decl_stmt|,
modifier|*
name|cce
decl_stmt|,
modifier|*
name|nce
decl_stmt|,
modifier|*
name|tce
decl_stmt|;
name|struct
name|timespec
name|now
decl_stmt|;
name|int
name|cunit
decl_stmt|,
name|allocunit
decl_stmt|;
name|pid_t
name|curpid
decl_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL snd_clone"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL dev pointer"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|(
name|c
operator|->
name|typemask
operator|&
name|tmask
operator|)
operator|==
name|tmask
argument_list|,
operator|(
literal|"invalid tmask: typemask=0x%08x tmask=0x%08x"
operator|,
name|c
operator|->
name|typemask
operator|,
name|tmask
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
name|unit
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL unit pointer"
operator|)
argument_list|)
expr_stmt|;
name|SND_CLONE_ASSERT
argument_list|(
operator|*
name|unit
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
operator|*
name|unit
operator|&
operator|(
name|c
operator|->
name|typemask
operator||
name|tmask
operator|)
operator|)
argument_list|,
operator|(
literal|"typemask collision: typemask=0x%08x tmask=0x%08x *unit=%d"
operator|,
name|c
operator|->
name|typemask
operator|,
name|tmask
operator|,
operator|*
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_ENABLE
operator|)
operator|||
operator|(
operator|*
name|unit
operator|!=
operator|-
literal|1
operator|&&
operator|*
name|unit
operator|>
name|c
operator|->
name|maxunit
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ce
operator|=
name|NULL
expr_stmt|;
name|after
operator|=
name|NULL
expr_stmt|;
name|bce
operator|=
name|NULL
expr_stmt|;
comment|/* "b"usy candidate */
name|cce
operator|=
name|NULL
expr_stmt|;
comment|/* "c"urthread/proc candidate */
name|nce
operator|=
name|NULL
expr_stmt|;
comment|/* "n"ull, totally unbusy candidate */
name|tce
operator|=
name|NULL
expr_stmt|;
comment|/* Last "t"ry candidate */
name|cunit
operator|=
literal|0
expr_stmt|;
name|allocunit
operator|=
operator|(
operator|*
name|unit
operator|==
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
operator|*
name|unit
expr_stmt|;
name|curpid
operator|=
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|snd_timestamp
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|&c->head
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 		 * Sort incrementally according to device type. 		 */
if|if
condition|(
name|tmask
operator|>
operator|(
name|ce
operator|->
name|unit
operator|&
name|c
operator|->
name|typemask
operator|)
condition|)
block|{
if|if
condition|(
name|cunit
operator|==
literal|0
condition|)
name|after
operator|=
name|ce
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tmask
operator|<
operator|(
name|ce
operator|->
name|unit
operator|&
name|c
operator|->
name|typemask
operator|)
condition|)
break|break;
comment|/* 		 * Shoot.. this is where the grumpiness begin. Just 		 * return immediately. 		 */
if|if
condition|(
operator|*
name|unit
operator|!=
operator|-
literal|1
operator|&&
operator|*
name|unit
operator|==
operator|(
name|ce
operator|->
name|unit
operator|&
operator|~
name|tmask
operator|)
condition|)
goto|goto
name|snd_clone_alloc_out
goto|;
name|cunit
operator|++
expr_stmt|;
comment|/* 		 * Simmilar device type. Sort incrementally according 		 * to allocation unit. While here, look for free slot 		 * and possible collision for new / future allocation. 		 */
if|if
condition|(
operator|*
name|unit
operator|==
operator|-
literal|1
operator|&&
operator|(
name|ce
operator|->
name|unit
operator|&
operator|~
name|tmask
operator|)
operator|==
name|allocunit
condition|)
name|allocunit
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|unit
operator|&
operator|~
name|tmask
operator|)
operator|<
name|allocunit
condition|)
name|after
operator|=
name|ce
expr_stmt|;
comment|/* 		 * Clone logic: 		 *   1. Look for non busy, but keep track of the best 		 *      possible busy cdev. 		 *   2. Look for the best (oldest referenced) entry that is 		 *      in a same process / thread. 		 *   3. Look for the best (oldest referenced), absolute free 		 *      entry. 		 *   4. Lastly, look for the best (oldest referenced) 		 *      any entries that doesn't fit with anything above. 		 */
if|if
condition|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_BUSY
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|devt
operator|!=
name|NULL
operator|&&
operator|(
name|bce
operator|==
name|NULL
operator|||
name|timespeccmp
argument_list|(
operator|&
name|ce
operator|->
name|tsp
argument_list|,
operator|&
name|bce
operator|->
name|tsp
argument_list|,
operator|<
argument_list|)
operator|)
condition|)
name|bce
operator|=
name|ce
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ce
operator|->
name|pid
operator|==
name|curpid
operator|&&
operator|(
name|cce
operator|==
name|NULL
operator|||
name|timespeccmp
argument_list|(
operator|&
name|ce
operator|->
name|tsp
argument_list|,
operator|&
name|cce
operator|->
name|tsp
argument_list|,
operator|<
argument_list|)
operator|)
condition|)
name|cce
operator|=
name|ce
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_INVOKE
operator|)
operator|&&
operator|(
name|nce
operator|==
name|NULL
operator|||
name|timespeccmp
argument_list|(
operator|&
name|ce
operator|->
name|tsp
argument_list|,
operator|&
name|nce
operator|->
name|tsp
argument_list|,
operator|<
argument_list|)
operator|)
condition|)
name|nce
operator|=
name|ce
expr_stmt|;
elseif|else
if|if
condition|(
name|tce
operator|==
name|NULL
operator|||
name|timespeccmp
argument_list|(
operator|&
name|ce
operator|->
name|tsp
argument_list|,
operator|&
name|tce
operator|->
name|tsp
argument_list|,
operator|<
argument_list|)
condition|)
name|tce
operator|=
name|ce
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|unit
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|snd_clone_alloc_new
goto|;
elseif|else
if|if
condition|(
name|cce
operator|!=
name|NULL
condition|)
block|{
comment|/* Same proc entry found, go for it */
name|ce
operator|=
name|cce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
elseif|else
if|if
condition|(
name|nce
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Next, try absolute free entry. If the calculated 		 * allocunit is smaller, create new entry instead. 		 */
if|if
condition|(
name|allocunit
operator|<
operator|(
name|nce
operator|->
name|unit
operator|&
operator|~
name|tmask
operator|)
condition|)
goto|goto
name|snd_clone_alloc_new
goto|;
name|ce
operator|=
name|nce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
elseif|else
if|if
condition|(
name|allocunit
operator|>
name|c
operator|->
name|maxunit
condition|)
block|{
comment|/* 		 * Maximum allowable unit reached. Try returning any 		 * available cdev and hope for the best. If the lookup is 		 * done for things like stat(), mtime() etc. , things should 		 * be ok. Otherwise, open() handler should do further checks 		 * and decide whether to return correct error code or not. 		 */
if|if
condition|(
name|tce
operator|!=
name|NULL
condition|)
block|{
name|ce
operator|=
name|tce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
elseif|else
if|if
condition|(
name|bce
operator|!=
name|NULL
condition|)
block|{
name|ce
operator|=
name|bce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|snd_clone_alloc_new
label|:
comment|/* 	 * No free entries found, and we still haven't reached maximum 	 * allowable units. Allocate, setup a minimal unique entry with busy 	 * status so nobody will monkey on this new entry. Unit magic is set 	 * right here to avoid collision with other contesting handler. 	 * The caller must be carefull here to maintain its own 	 * synchronization, as long as it will not conflict with malloc(9) 	 * operations. 	 * 	 * That said, go figure. 	 */
name|ce
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ce
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
operator|(
name|c
operator|->
name|flags
operator|&
name|SND_CLONE_WAITOK
operator|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
operator|)
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|unit
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * We're being dense, ignorance is bliss, 		 * Super Regulatory Measure (TM).. TRY AGAIN! 		 */
if|if
condition|(
name|nce
operator|!=
name|NULL
condition|)
block|{
name|ce
operator|=
name|nce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
elseif|else
if|if
condition|(
name|tce
operator|!=
name|NULL
condition|)
block|{
name|ce
operator|=
name|tce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
elseif|else
if|if
condition|(
name|bce
operator|!=
name|NULL
condition|)
block|{
name|ce
operator|=
name|bce
expr_stmt|;
goto|goto
name|snd_clone_alloc_out
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Setup new entry */
name|ce
operator|->
name|parent
operator|=
name|c
expr_stmt|;
name|ce
operator|->
name|unit
operator|=
name|tmask
operator||
name|allocunit
expr_stmt|;
name|ce
operator|->
name|pid
operator|=
name|curpid
expr_stmt|;
name|ce
operator|->
name|tsp
operator|=
name|now
expr_stmt|;
name|ce
operator|->
name|flags
operator||=
name|SND_CLONE_ALLOC
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|c
operator|->
name|head
argument_list|,
name|after
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|c
operator|->
name|head
argument_list|,
name|ce
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|size
operator|++
expr_stmt|;
name|c
operator|->
name|tsp
operator|=
name|now
expr_stmt|;
comment|/* 	 * Save new allocation unit for caller which will be used 	 * by make_dev(). 	 */
operator|*
name|unit
operator|=
name|allocunit
expr_stmt|;
return|return
operator|(
name|ce
operator|)
return|;
name|snd_clone_alloc_out
label|:
comment|/* 	 * Set, mark, timestamp the entry if this is a truly free entry. 	 * Leave busy entry alone. 	 */
if|if
condition|(
operator|!
operator|(
name|ce
operator|->
name|flags
operator|&
name|SND_CLONE_BUSY
operator|)
condition|)
block|{
name|ce
operator|->
name|pid
operator|=
name|curpid
expr_stmt|;
name|ce
operator|->
name|tsp
operator|=
name|now
expr_stmt|;
name|ce
operator|->
name|flags
operator||=
name|SND_CLONE_INVOKE
expr_stmt|;
block|}
name|c
operator|->
name|tsp
operator|=
name|now
expr_stmt|;
operator|*
name|dev
operator|=
name|ce
operator|->
name|devt
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

