begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * A low level driver for Yamaha YM3812 and OPL-3 -chips  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_comment
comment|/*  * Major improvements to the FM handling 30AUG92 by Rob Hooft,  */
end_comment

begin_comment
comment|/*  * hooft@chem.ruu.nl  */
end_comment

begin_comment
comment|/*  *  * Ported to the new Audio Driver by Luigi Rizzo:  * (C) 1999 Seigo Tanimura  *  * This is the OPL2/3/4 chip driver for FreeBSD, based on the Luigi Sound Driver.  * This handles io against /dev/midi, the midi {in, out}put event queues  * and the event/message operation to the OPL chip.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<dev/sound/midi/midi.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|midi_devclass
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DDB
end_ifndef

begin_undef
undef|#
directive|undef
name|DDB
end_undef

begin_define
define|#
directive|define
name|DDB
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_comment
comment|/*  *	The OPL-3 mode is switched on by writing 0x01, to the offset 5  *	of the right side.  *  *	Another special register at the right side is at offset 4. It contains  *	a bit mask defining which voices are used as 4 OP voices.  *  *	The percussive mode is implemented in the left side only.  *  *	With the above exeptions the both sides can be operated independently.  *	  *	A 4 OP voice can be created by setting the corresponding  *	bit at offset 4 of the right side.  *  *	For example setting the rightmost bit (0x01) changes the  *	first voice on the right side to the 4 OP mode. The fourth  *	voice is made inaccessible.  *  *	If a voice is set to the 2 OP mode, it works like 2 OP modes  *	of the original YM3812 (AdLib). In addition the voice can   *	be connected the left, right or both stereo channels. It can  *	even be left unconnected. This works with 4 OP voices also.  *  *	The stereo connection bits are located in the FEEDBACK_CONNECTION  *	register of the voice (0xC0-0xC8). In 4 OP voices these bits are  *	in the second half of the voice.  */
end_comment

begin_comment
comment|/*  *	Register numbers for the global registers  */
end_comment

begin_define
define|#
directive|define
name|TEST_REGISTER
value|0x01
end_define

begin_define
define|#
directive|define
name|ENABLE_WAVE_SELECT
value|0x20
end_define

begin_define
define|#
directive|define
name|TIMER1_REGISTER
value|0x02
end_define

begin_define
define|#
directive|define
name|TIMER2_REGISTER
value|0x03
end_define

begin_define
define|#
directive|define
name|TIMER_CONTROL_REGISTER
value|0x04
end_define

begin_comment
comment|/* Left side */
end_comment

begin_define
define|#
directive|define
name|IRQ_RESET
value|0x80
end_define

begin_define
define|#
directive|define
name|TIMER1_MASK
value|0x40
end_define

begin_define
define|#
directive|define
name|TIMER2_MASK
value|0x20
end_define

begin_define
define|#
directive|define
name|TIMER1_START
value|0x01
end_define

begin_define
define|#
directive|define
name|TIMER2_START
value|0x02
end_define

begin_define
define|#
directive|define
name|CONNECTION_SELECT_REGISTER
value|0x04
end_define

begin_comment
comment|/* Right side */
end_comment

begin_define
define|#
directive|define
name|RIGHT_4OP_0
value|0x01
end_define

begin_define
define|#
directive|define
name|RIGHT_4OP_1
value|0x02
end_define

begin_define
define|#
directive|define
name|RIGHT_4OP_2
value|0x04
end_define

begin_define
define|#
directive|define
name|LEFT_4OP_0
value|0x08
end_define

begin_define
define|#
directive|define
name|LEFT_4OP_1
value|0x10
end_define

begin_define
define|#
directive|define
name|LEFT_4OP_2
value|0x20
end_define

begin_define
define|#
directive|define
name|OPL3_MODE_REGISTER
value|0x05
end_define

begin_comment
comment|/* Right side */
end_comment

begin_define
define|#
directive|define
name|OPL3_ENABLE
value|0x01
end_define

begin_define
define|#
directive|define
name|OPL4_ENABLE
value|0x02
end_define

begin_define
define|#
directive|define
name|KBD_SPLIT_REGISTER
value|0x08
end_define

begin_comment
comment|/* Left side */
end_comment

begin_define
define|#
directive|define
name|COMPOSITE_SINE_WAVE_MODE
value|0x80
end_define

begin_comment
comment|/* Don't use with OPL-3? */
end_comment

begin_define
define|#
directive|define
name|KEYBOARD_SPLIT
value|0x40
end_define

begin_define
define|#
directive|define
name|PERCUSSION_REGISTER
value|0xbd
end_define

begin_comment
comment|/* Left side only */
end_comment

begin_define
define|#
directive|define
name|TREMOLO_DEPTH
value|0x80
end_define

begin_define
define|#
directive|define
name|VIBRATO_DEPTH
value|0x40
end_define

begin_define
define|#
directive|define
name|PERCUSSION_ENABLE
value|0x20
end_define

begin_define
define|#
directive|define
name|BASSDRUM_ON
value|0x10
end_define

begin_define
define|#
directive|define
name|SNAREDRUM_ON
value|0x08
end_define

begin_define
define|#
directive|define
name|TOMTOM_ON
value|0x04
end_define

begin_define
define|#
directive|define
name|CYMBAL_ON
value|0x02
end_define

begin_define
define|#
directive|define
name|HIHAT_ON
value|0x01
end_define

begin_comment
comment|/*  *	Offsets to the register banks for operators. To get the  *	register number just add the operator offset to the bank offset  *  *	AM/VIB/EG/KSR/Multiple (0x20 to 0x35)  */
end_comment

begin_define
define|#
directive|define
name|AM_VIB
value|0x20
end_define

begin_define
define|#
directive|define
name|TREMOLO_ON
value|0x80
end_define

begin_define
define|#
directive|define
name|VIBRATO_ON
value|0x40
end_define

begin_define
define|#
directive|define
name|SUSTAIN_ON
value|0x20
end_define

begin_define
define|#
directive|define
name|KSR
value|0x10
end_define

begin_comment
comment|/* Key scaling rate */
end_comment

begin_define
define|#
directive|define
name|MULTIPLE_MASK
value|0x0f
end_define

begin_comment
comment|/* Frequency multiplier */
end_comment

begin_comment
comment|/*  *	KSL/Total level (0x40 to 0x55)  */
end_comment

begin_define
define|#
directive|define
name|KSL_LEVEL
value|0x40
end_define

begin_define
define|#
directive|define
name|KSL_MASK
value|0xc0
end_define

begin_comment
comment|/* Envelope scaling bits */
end_comment

begin_define
define|#
directive|define
name|TOTAL_LEVEL_MASK
value|0x3f
end_define

begin_comment
comment|/* Strength (volume) of OP */
end_comment

begin_comment
comment|/*  *	Attack / Decay rate (0x60 to 0x75)  */
end_comment

begin_define
define|#
directive|define
name|ATTACK_DECAY
value|0x60
end_define

begin_define
define|#
directive|define
name|ATTACK_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|DECAY_MASK
value|0x0f
end_define

begin_comment
comment|/*  * Sustain level / Release rate (0x80 to 0x95)  */
end_comment

begin_define
define|#
directive|define
name|SUSTAIN_RELEASE
value|0x80
end_define

begin_define
define|#
directive|define
name|SUSTAIN_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|RELEASE_MASK
value|0x0f
end_define

begin_comment
comment|/*  * Wave select (0xE0 to 0xF5)  */
end_comment

begin_define
define|#
directive|define
name|WAVE_SELECT
value|0xe0
end_define

begin_comment
comment|/*  *	Offsets to the register banks for voices. Just add to the  *	voice number to get the register number.  *  *	F-Number low bits (0xA0 to 0xA8).  */
end_comment

begin_define
define|#
directive|define
name|FNUM_LOW
value|0xa0
end_define

begin_comment
comment|/*  *	F-number high bits / Key on / Block (octave) (0xB0 to 0xB8)  */
end_comment

begin_define
define|#
directive|define
name|KEYON_BLOCK
value|0xb0
end_define

begin_define
define|#
directive|define
name|KEYON_BIT
value|0x20
end_define

begin_define
define|#
directive|define
name|BLOCKNUM_MASK
value|0x1c
end_define

begin_define
define|#
directive|define
name|FNUM_HIGH_MASK
value|0x03
end_define

begin_comment
comment|/*  *	Feedback / Connection (0xc0 to 0xc8)  *  *	These registers have two new bits when the OPL-3 mode  *	is selected. These bits controls connecting the voice  *	to the stereo channels. For 4 OP voices this bit is  *	defined in the second half of the voice (add 3 to the  *	register offset).  *  *	For 4 OP voices the connection bit is used in the  *	both halfs (gives 4 ways to connect the operators).  */
end_comment

begin_define
define|#
directive|define
name|FEEDBACK_CONNECTION
value|0xc0
end_define

begin_define
define|#
directive|define
name|FEEDBACK_MASK
value|0x0e
end_define

begin_comment
comment|/* Valid just for 1st OP of a voice */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_BIT
value|0x01
end_define

begin_comment
comment|/*  *	In the 4 OP mode there is four possible configurations how the  *	operators can be connected together (in 2 OP modes there is just  *	AM or FM). The 4 OP connection mode is defined by the rightmost  *	bit of the FEEDBACK_CONNECTION (0xC0-0xC8) on the both halfs.  *  *	First half	Second half	Mode  *  *					 +---+  *					 v   |  *	0		0>+-1-+--2--3--4-->  *  *  *					  *					 +---+  *					 |   |  *	0		1>+-1-+--2-+  *						  |->  *>--3----4-+  *					  *					 +---+  *					 |   |  *	1		0>+-1-+-----+  *						   |->  *>--2--3--4-+  *  *					 +---+  *					 |   |  *	1		1>+-1-+--+  *						|  *>--2--3-+->  *						|  *>--4----+  */
end_comment

begin_define
define|#
directive|define
name|STEREO_BITS
value|0x30
end_define

begin_comment
comment|/* OPL-3 only */
end_comment

begin_define
define|#
directive|define
name|VOICE_TO_LEFT
value|0x10
end_define

begin_define
define|#
directive|define
name|VOICE_TO_RIGHT
value|0x20
end_define

begin_comment
comment|/*  * 	Definition table for the physical voices  */
end_comment

begin_struct
struct|struct
name|physical_voice_info
block|{
name|unsigned
name|char
name|voice_num
decl_stmt|;
name|unsigned
name|char
name|voice_mode
decl_stmt|;
comment|/* 0=unavailable, 2=2 OP, 4=4 OP */
name|int
name|ch
decl_stmt|;
comment|/* channel (left=USE_LEFT, right=USE_RIGHT) */
name|unsigned
name|char
name|op
index|[
literal|4
index|]
decl_stmt|;
comment|/* Operator offsets */
block|}
struct|;
end_struct

begin_comment
comment|/*  *	There is 18 possible 2 OP voices  *	(9 in the left and 9 in the right).  *	The first OP is the modulator and 2nd is the carrier.  *  *	The first three voices in the both sides may be connected  *	with another voice to a 4 OP voice. For example voice 0  *	can be connected with voice 3. The operators of voice 3 are  *	used as operators 3 and 4 of the new 4 OP voice.  *	In this case the 2 OP voice number 0 is the 'first half' and  *	voice 3 is the second.  */
end_comment

begin_define
define|#
directive|define
name|USE_LEFT
value|0
end_define

begin_define
define|#
directive|define
name|USE_RIGHT
value|1
end_define

begin_decl_stmt
specifier|static
name|struct
name|physical_voice_info
name|pv_map
index|[
literal|18
index|]
init|=
block|{
comment|/*       No Mode Side		OP1	OP2	OP3   OP4	*/
comment|/*	---------------------------------------------------	*/
block|{
literal|0
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x00
block|,
literal|0x03
block|,
literal|0x08
block|,
literal|0x0b
block|}
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x01
block|,
literal|0x04
block|,
literal|0x09
block|,
literal|0x0c
block|}
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x02
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x0d
block|}
block|}
block|,
block|{
literal|3
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x08
block|,
literal|0x0b
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|4
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x09
block|,
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|5
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x0a
block|,
literal|0x0d
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|6
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x10
block|,
literal|0x13
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* Used by percussive voices */
block|{
literal|7
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x11
block|,
literal|0x14
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* if the percussive mode */
block|{
literal|8
block|,
literal|2
block|,
name|USE_LEFT
block|,
block|{
literal|0x12
block|,
literal|0x15
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|/* is selected */
block|{
literal|0
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x00
block|,
literal|0x03
block|,
literal|0x08
block|,
literal|0x0b
block|}
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x01
block|,
literal|0x04
block|,
literal|0x09
block|,
literal|0x0c
block|}
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x02
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x0d
block|}
block|}
block|,
block|{
literal|3
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x08
block|,
literal|0x0b
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|4
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x09
block|,
literal|0x0c
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|5
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x0a
block|,
literal|0x0d
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|6
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x10
block|,
literal|0x13
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|7
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x11
block|,
literal|0x14
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
literal|8
block|,
literal|2
block|,
name|USE_RIGHT
block|,
block|{
literal|0x12
block|,
literal|0x15
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the tuning parameters. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|semitone_tuning
index|[
literal|24
index|]
init|=
block|{
comment|/*   0 */
literal|10000
block|,
literal|10595
block|,
literal|11225
block|,
literal|11892
block|,
literal|12599
block|,
literal|13348
block|,
literal|14142
block|,
literal|14983
block|,
comment|/*   8 */
literal|15874
block|,
literal|16818
block|,
literal|17818
block|,
literal|18877
block|,
literal|20000
block|,
literal|21189
block|,
literal|22449
block|,
literal|23784
block|,
comment|/*  16 */
literal|25198
block|,
literal|26697
block|,
literal|28284
block|,
literal|29966
block|,
literal|31748
block|,
literal|33636
block|,
literal|35636
block|,
literal|37755
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|cent_tuning
index|[
literal|100
index|]
init|=
block|{
comment|/*   0 */
literal|10000
block|,
literal|10006
block|,
literal|10012
block|,
literal|10017
block|,
literal|10023
block|,
literal|10029
block|,
literal|10035
block|,
literal|10041
block|,
comment|/*   8 */
literal|10046
block|,
literal|10052
block|,
literal|10058
block|,
literal|10064
block|,
literal|10070
block|,
literal|10075
block|,
literal|10081
block|,
literal|10087
block|,
comment|/*  16 */
literal|10093
block|,
literal|10099
block|,
literal|10105
block|,
literal|10110
block|,
literal|10116
block|,
literal|10122
block|,
literal|10128
block|,
literal|10134
block|,
comment|/*  24 */
literal|10140
block|,
literal|10145
block|,
literal|10151
block|,
literal|10157
block|,
literal|10163
block|,
literal|10169
block|,
literal|10175
block|,
literal|10181
block|,
comment|/*  32 */
literal|10187
block|,
literal|10192
block|,
literal|10198
block|,
literal|10204
block|,
literal|10210
block|,
literal|10216
block|,
literal|10222
block|,
literal|10228
block|,
comment|/*  40 */
literal|10234
block|,
literal|10240
block|,
literal|10246
block|,
literal|10251
block|,
literal|10257
block|,
literal|10263
block|,
literal|10269
block|,
literal|10275
block|,
comment|/*  48 */
literal|10281
block|,
literal|10287
block|,
literal|10293
block|,
literal|10299
block|,
literal|10305
block|,
literal|10311
block|,
literal|10317
block|,
literal|10323
block|,
comment|/*  56 */
literal|10329
block|,
literal|10335
block|,
literal|10341
block|,
literal|10347
block|,
literal|10353
block|,
literal|10359
block|,
literal|10365
block|,
literal|10371
block|,
comment|/*  64 */
literal|10377
block|,
literal|10383
block|,
literal|10389
block|,
literal|10395
block|,
literal|10401
block|,
literal|10407
block|,
literal|10413
block|,
literal|10419
block|,
comment|/*  72 */
literal|10425
block|,
literal|10431
block|,
literal|10437
block|,
literal|10443
block|,
literal|10449
block|,
literal|10455
block|,
literal|10461
block|,
literal|10467
block|,
comment|/*  80 */
literal|10473
block|,
literal|10479
block|,
literal|10485
block|,
literal|10491
block|,
literal|10497
block|,
literal|10503
block|,
literal|10509
block|,
literal|10515
block|,
comment|/*  88 */
literal|10521
block|,
literal|10528
block|,
literal|10534
block|,
literal|10540
block|,
literal|10546
block|,
literal|10552
block|,
literal|10558
block|,
literal|10564
block|,
comment|/*  96 */
literal|10570
block|,
literal|10576
block|,
literal|10582
block|,
literal|10589
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The next table looks magical, but it certainly is not. Its values have  * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception  * for i=0. This log-table converts a linear volume-scaling (0..127) to a  * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume  * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative  * volume -8 it was implemented as a table because it is only 128 bytes and  * it saves a lot of log() calculations. (RH)  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|opl_volumetable
index|[
literal|128
index|]
init|=
block|{
operator|-
literal|64
block|,
operator|-
literal|48
block|,
operator|-
literal|40
block|,
operator|-
literal|35
block|,
operator|-
literal|32
block|,
operator|-
literal|29
block|,
operator|-
literal|27
block|,
operator|-
literal|26
block|,
operator|-
literal|24
block|,
operator|-
literal|23
block|,
operator|-
literal|21
block|,
operator|-
literal|20
block|,
operator|-
literal|19
block|,
operator|-
literal|18
block|,
operator|-
literal|18
block|,
operator|-
literal|17
block|,
operator|-
literal|16
block|,
operator|-
literal|15
block|,
operator|-
literal|15
block|,
operator|-
literal|14
block|,
operator|-
literal|13
block|,
operator|-
literal|13
block|,
operator|-
literal|12
block|,
operator|-
literal|12
block|,
operator|-
literal|11
block|,
operator|-
literal|11
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|8
block|,
operator|-
literal|8
block|,
operator|-
literal|8
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_VOICE
value|18
end_define

begin_define
define|#
directive|define
name|OFFS_4OP
value|11
end_define

begin_define
define|#
directive|define
name|SBFM_MAXINSTR
value|256
end_define

begin_comment
comment|/* These are the OPL Models. */
end_comment

begin_define
define|#
directive|define
name|MODEL_NONE
value|0
end_define

begin_define
define|#
directive|define
name|MODEL_OPL2
value|2
end_define

begin_define
define|#
directive|define
name|MODEL_OPL3
value|3
end_define

begin_define
define|#
directive|define
name|MODEL_OPL4
value|4
end_define

begin_comment
comment|/* These are the OPL Voice modes. */
end_comment

begin_define
define|#
directive|define
name|VOICE_NONE
value|0
end_define

begin_define
define|#
directive|define
name|VOICE_2OP
value|2
end_define

begin_define
define|#
directive|define
name|VOICE_4OP
value|4
end_define

begin_comment
comment|/* PnP IDs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|opl_ids
index|[]
init|=
block|{
block|{
literal|0x01200001
block|,
literal|"@H@2001 FM Synthesizer"
block|}
block|,
comment|/* @H@2001 */
block|{
literal|0x01100001
block|,
literal|"@H@1001 FM Synthesizer"
block|}
block|,
comment|/* @H@1001 */
if|#
directive|if
name|notdef
comment|/* TODO: write bridge drivers for these devices. */
block|{
literal|0x0000630e
block|,
literal|"CSC0000 FM Synthesizer"
block|}
block|,
comment|/* CSC0000 */
block|{
literal|0x68187316
block|,
literal|"ESS1868 FM Synthesizer"
block|}
block|,
comment|/* ESS1868 */
block|{
literal|0x79187316
block|,
literal|"ESS1879 FM Synthesizer"
block|}
block|,
comment|/* ESS1879 */
block|{
literal|0x2100a865
block|,
literal|"YMH0021 FM Synthesizer"
block|}
block|,
comment|/* YMH0021 */
block|{
literal|0x80719304
block|,
literal|"ADS7180 FM Synthesizer"
block|}
block|,
comment|/* ADS7180 */
block|{
literal|0x0300561e
block|,
literal|"GRV0003 FM Synthesizer"
block|}
block|,
comment|/* GRV0003 */
endif|#
directive|endif
comment|/* notdef */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the default io bases. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|opl_defaultiobase
index|[]
init|=
block|{
literal|0x388
block|,
literal|0x380
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the per-voice information. */
end_comment

begin_struct
struct|struct
name|voice_info
block|{
name|u_char
name|keyon_byte
decl_stmt|;
name|long
name|bender
decl_stmt|;
name|long
name|bender_range
decl_stmt|;
name|u_long
name|orig_freq
decl_stmt|;
name|u_long
name|current_freq
decl_stmt|;
name|int
name|volume
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* These are the synthesizer and the midi device information. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|opl_synthinfo
init|=
block|{
literal|"OPL FM Synthesizer"
block|,
literal|0
block|,
name|SYNTH_TYPE_FM
block|,
name|FM_TYPE_ADLIB
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|,
name|SBFM_MAXINSTR
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|midi_info
name|opl_midiinfo
init|=
block|{
literal|"OPL FM Synthesizer"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These functions goes into oplsynthdev_op_desc.  */
end_comment

begin_decl_stmt
specifier|static
name|mdsy_killnote_t
name|opl_killnote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_setinstr_t
name|opl_setinstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_startnote_t
name|opl_startnote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_reset_t
name|opl_reset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_hwcontrol_t
name|opl_hwcontrol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_loadpatch_t
name|opl_loadpatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_panning_t
name|opl_panning
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_aftertouch_t
name|opl_aftertouch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_controller_t
name|opl_controller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_patchmgr_t
name|opl_patchmgr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_bender_t
name|opl_bender
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_allocvoice_t
name|opl_allocvoice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_setupvoice_t
name|opl_setupvoice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_sendsysex_t
name|opl_sendsysex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_prefixcmd_t
name|opl_prefixcmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_volumemethod_t
name|opl_volumemethod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the synthdev_info for an OPL3 chip.  */
end_comment

begin_decl_stmt
specifier|static
name|synthdev_info
name|oplsynth_op_desc
init|=
block|{
name|opl_killnote
block|,
name|opl_setinstr
block|,
name|opl_startnote
block|,
name|opl_reset
block|,
name|opl_hwcontrol
block|,
name|opl_loadpatch
block|,
name|opl_panning
block|,
name|opl_aftertouch
block|,
name|opl_controller
block|,
name|opl_patchmgr
block|,
name|opl_bender
block|,
name|opl_allocvoice
block|,
name|opl_setupvoice
block|,
name|opl_sendsysex
block|,
name|opl_prefixcmd
block|,
name|opl_volumemethod
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is the parameter structure per a device. */
end_comment

begin_struct
struct|struct
name|opl_softc
block|{
name|device_t
name|dev
decl_stmt|;
comment|/* device information */
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
comment|/* midi device information */
name|struct
name|mtx
name|mtx
decl_stmt|;
comment|/* Mutex to protect the device. */
name|struct
name|resource
modifier|*
name|io
decl_stmt|;
comment|/* Base of io port */
name|int
name|io_rid
decl_stmt|;
comment|/* Io resource ID */
name|int
name|model
decl_stmt|;
comment|/* OPL model */
name|struct
name|synth_info
name|synthinfo
decl_stmt|;
comment|/* Synthesizer information */
name|struct
name|sbi_instrument
name|i_map
index|[
name|SBFM_MAXINSTR
index|]
decl_stmt|;
comment|/* Instrument map */
name|struct
name|sbi_instrument
modifier|*
name|act_i
index|[
name|SBFM_MAXINSTR
index|]
decl_stmt|;
comment|/* Active instruments */
name|struct
name|physical_voice_info
name|pv_map
index|[
name|MAX_VOICE
index|]
decl_stmt|;
comment|/* Physical voice map */
name|int
name|cmask
decl_stmt|;
comment|/* Connection mask */
name|int
name|lv_map
index|[
name|MAX_VOICE
index|]
decl_stmt|;
comment|/* Level map */
name|struct
name|voice_info
name|voc
index|[
name|MAX_VOICE
index|]
decl_stmt|;
comment|/* Voice information */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|opl_softc
modifier|*
name|sc_p
typedef|;
end_typedef

begin_comment
comment|/*  * These functions goes into opl_op_desc to get called  * from sound.c.  */
end_comment

begin_function_decl
specifier|static
name|int
name|opl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl_probe1
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oplsbc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oplsbc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|opl_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|opl_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|opl_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|midi_callback_t
name|opl_callback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These go to snddev_info. */
end_comment

begin_decl_stmt
specifier|static
name|mdsy_readraw_t
name|opl_readraw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mdsy_writeraw_t
name|opl_writeraw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These functions are local. */
end_comment

begin_function_decl
specifier|static
name|void
name|opl_command
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl_status
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl_enter4opmode
parameter_list|(
name|sc_p
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl_storeinstr
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|instr_no
parameter_list|,
name|struct
name|sbi_instrument
modifier|*
name|instr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl_calcvol
parameter_list|(
name|u_char
modifier|*
name|regbyte
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|main_vol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl_setvoicevolume
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|main_vol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl_freqtofnum
parameter_list|(
name|int
name|freq
parameter_list|,
name|int
modifier|*
name|block
parameter_list|,
name|int
modifier|*
name|fnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl_bendpitch
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl_notetofreq
parameter_list|(
name|int
name|note_num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|opl_computefinetune
parameter_list|(
name|u_long
name|base_freq
parameter_list|,
name|int
name|bend
parameter_list|,
name|int
name|range
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl_allocres
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl_releaseres
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is the device descriptor for the midi device.  */
end_comment

begin_decl_stmt
specifier|static
name|mididev_info
name|opl_op_desc
init|=
block|{
literal|"OPL FM Synthesizer"
block|,
name|SNDCARD_OPL
block|,
name|opl_open
block|,
name|opl_close
block|,
name|opl_ioctl
block|,
name|opl_callback
block|,
name|MIDI_BUFFSIZE
block|,
comment|/* Queue Length */
literal|0
block|,
comment|/* XXX This is not an *audio* device! */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Here are the main functions to interact to the user process.  */
end_comment

begin_function
specifier|static
name|int
name|opl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
comment|/* Check isapnp ids */
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|opl_ids
argument_list|)
operator|)
return|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|opl_op_desc
operator|.
name|name
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: probing.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|io_rid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|io
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|scp
operator|->
name|io_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opl_allocres
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|)
condition|)
block|{
comment|/* We try the defaults in opl_defaultiobase. */
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: port is omitted, trying the defaults.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|opl_defaultiobase
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|opl_defaultiobase
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|->
name|io_rid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|io
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|scp
operator|->
name|io_rid
argument_list|,
name|opl_defaultiobase
index|[
name|i
index|]
argument_list|,
name|opl_defaultiobase
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|io
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|opl_probe1
argument_list|(
name|scp
argument_list|)
condition|)
name|opl_releaseres
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|scp
operator|->
name|io
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|opl_probe1
argument_list|(
name|scp
argument_list|)
condition|)
block|{
name|opl_releaseres
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* We now have some kind of OPL. */
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: probed.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We do probe in this function. */
end_comment

begin_function
specifier|static
name|int
name|opl_probe1
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|u_char
name|stat1
decl_stmt|,
name|stat2
decl_stmt|;
comment|/* Reset the timers and the interrupt. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_MASK
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|IRQ_RESET
argument_list|)
expr_stmt|;
comment|/* Read the status. */
name|stat1
operator|=
name|opl_status
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat1
operator|&
literal|0xe0
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Try firing the timer1. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TIMER1_REGISTER
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set the timer value. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_START
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
comment|/* Start the timer. */
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* Wait for the timer. */
comment|/* Read the status. */
name|stat2
operator|=
name|opl_status
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* Reset the timers and the interrupt. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_MASK
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|IRQ_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat2
operator|&
literal|0xe0
operator|)
operator|!=
literal|0xc0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|oplsbc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|struct
name|sndcard_func
modifier|*
name|func
decl_stmt|;
comment|/* The parent device has already been probed. */
name|func
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|func
operator|->
name|func
operator|!=
name|SCF_SYNTH
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
literal|"SB OPL FM Synthesizer"
expr_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|io_rid
operator|=
literal|2
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
name|int
name|i
decl_stmt|,
name|opl4_io
decl_stmt|,
name|opl4_id
decl_stmt|;
name|struct
name|resource
modifier|*
name|opl4
decl_stmt|;
name|u_char
name|signature
decl_stmt|,
name|tmp
decl_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl: attaching.\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the softc for this unit. */
name|scp
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Allocate other resources. */
if|if
condition|(
name|opl_allocres
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|)
condition|)
block|{
name|opl_releaseres
argument_list|(
name|scp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Detect the OPL type. */
name|signature
operator|=
name|opl_status
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|==
literal|0x06
condition|)
name|scp
operator|->
name|model
operator|=
name|MODEL_OPL2
expr_stmt|;
else|else
block|{
comment|/* OPL3 or later, might be OPL4. */
comment|/* Enable OPL3 and OPL4. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
name|OPL3_ENABLE
operator||
name|OPL4_ENABLE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|opl_status
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0x02
condition|)
name|scp
operator|->
name|model
operator|=
name|MODEL_OPL3
expr_stmt|;
if|#
directive|if
name|notdef
else|else
block|{
endif|#
directive|endif
comment|/* notdef */
comment|/* Alloc OPL4 ID register. */
name|opl4_id
operator|=
literal|2
expr_stmt|;
name|opl4_io
operator|=
name|rman_get_start
argument_list|(
name|scp
operator|->
name|io
argument_list|)
operator|-
literal|8
expr_stmt|;
name|opl4
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|opl4_id
argument_list|,
name|opl4_io
argument_list|,
name|opl4_io
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opl4
operator|!=
name|NULL
condition|)
block|{
comment|/* Select OPL4 ID register. */
name|bus_space_write_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|opl4
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|opl4
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bus_space_read_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|opl4
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|opl4
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0x20
condition|)
name|scp
operator|->
name|model
operator|=
name|MODEL_OPL3
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|model
operator|=
name|MODEL_OPL4
expr_stmt|;
comment|/* Select back OPL4 FM mixer control. */
name|bus_space_write_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|opl4
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|opl4
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xf8
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|opl4
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|opl4
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0x1b
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|opl4_id
argument_list|,
name|opl4
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|notdef
block|}
endif|#
directive|endif
comment|/* notdef */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Kill any previous notes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|KEYON_BLOCK
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Select melodic mode. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|TEST_REGISTER
argument_list|,
name|ENABLE_WAVE_SELECT
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_LEFT
argument_list|,
name|PERCUSSION_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBFM_MAXINSTR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|i_map
index|[
name|i
index|]
operator|.
name|channel
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Fill the softc. */
name|bcopy
argument_list|(
operator|&
name|opl_synthinfo
argument_list|,
operator|&
name|scp
operator|->
name|synthinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|opl_synthinfo
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|scp
operator|->
name|synthinfo
operator|.
name|name
argument_list|,
literal|64
argument_list|,
literal|"Yamaha OPL%d FM"
argument_list|,
name|scp
operator|->
name|model
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|,
literal|"oplmid"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pv_map
argument_list|,
name|scp
operator|->
name|pv_map
argument_list|,
sizeof|sizeof
argument_list|(
name|pv_map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|model
operator|<
name|MODEL_OPL3
condition|)
block|{
comment|/* OPL2. */
name|scp
operator|->
name|synthinfo
operator|.
name|nr_voices
operator|=
literal|9
expr_stmt|;
name|scp
operator|->
name|synthinfo
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VOICE
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|ch
operator|=
name|USE_LEFT
expr_stmt|;
block|}
else|else
block|{
comment|/* OPL3 or later. */
name|scp
operator|->
name|synthinfo
operator|.
name|capabilities
operator||=
name|SYNTH_CAP_OPL3
expr_stmt|;
name|scp
operator|->
name|synthinfo
operator|.
name|nr_voices
operator|=
literal|18
expr_stmt|;
name|scp
operator|->
name|synthinfo
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|notdef
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VOICE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|ch
operator|==
name|USE_LEFT
condition|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|ch
operator|=
name|USE_LEFT
expr_stmt|;
else|else
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|ch
operator|=
name|USE_RIGHT
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* notdef */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
name|OPL3_ENABLE
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|devinfo
operator|=
name|devinfo
operator|=
name|create_mididev_info_unit
argument_list|(
name|MDT_SYNTH
argument_list|,
operator|&
name|opl_op_desc
argument_list|,
operator|&
name|oplsynth_op_desc
argument_list|)
expr_stmt|;
comment|/* Fill the midi info. */
name|devinfo
operator|->
name|synth
operator|.
name|readraw
operator|=
name|opl_readraw
expr_stmt|;
name|devinfo
operator|->
name|synth
operator|.
name|writeraw
operator|=
name|opl_writeraw
expr_stmt|;
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
name|scp
operator|->
name|synthinfo
operator|.
name|nr_voices
expr_stmt|;
name|strcpy
argument_list|(
name|devinfo
operator|->
name|name
argument_list|,
name|scp
operator|->
name|synthinfo
operator|.
name|name
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|devinfo
operator|->
name|midistat
argument_list|,
sizeof|sizeof
argument_list|(
name|devinfo
operator|->
name|midistat
argument_list|)
argument_list|,
literal|"at 0x%x"
argument_list|,
operator|(
name|u_int
operator|)
name|rman_get_start
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|midiinit
argument_list|(
name|devinfo
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl: attached.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl: the chip is OPL%d.\n"
argument_list|,
name|scp
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|oplsbc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|opl_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: opening.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_open: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|devinfo
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devinfo
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|model
operator|<
name|MODEL_OPL3
condition|)
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
literal|9
expr_stmt|;
else|else
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
literal|18
expr_stmt|;
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|timestamp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VOICE
condition|;
name|i
operator|++
control|)
block|{
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|alloc_times
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|devinfo
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cmask
operator|=
literal|0
expr_stmt|;
comment|/* We are in 2 OP mode initially. */
if|if
condition|(
name|scp
operator|->
name|model
operator|>=
name|MODEL_OPL3
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|scp
operator|->
name|cmask
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: opened.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: closing.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_close: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|devinfo
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devinfo
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|model
operator|<
name|MODEL_OPL3
condition|)
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
literal|9
expr_stmt|;
else|else
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
literal|18
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devinfo
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
comment|/* Stop the OPL. */
name|opl_reset
argument_list|(
name|scp
operator|->
name|devinfo
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: closed.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_ioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|synth_info
modifier|*
name|synthinfo
decl_stmt|;
name|struct
name|midi_info
modifier|*
name|midiinfo
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|ins
decl_stmt|;
name|unit
operator|=
name|MIDIUNIT
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_ioctl: unit %d, cmd %s.\n"
argument_list|,
name|unit
argument_list|,
name|midi_cmdname
argument_list|(
name|cmd
argument_list|,
name|cmdtab_midiioctl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|=
name|get_mididev_info
argument_list|(
name|i_dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_ioctl: unit %d is not configured.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|scp
operator|=
name|devinfo
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|synthinfo
operator|=
operator|(
expr|struct
name|synth_info
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|synthinfo
operator|->
name|device
operator|!=
name|unit
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|synthinfo
argument_list|,
name|synthinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|scp
operator|->
name|synthinfo
argument_list|)
argument_list|)
expr_stmt|;
name|synthinfo
operator|->
name|device
operator|=
name|unit
expr_stmt|;
name|synthinfo
operator|->
name|nr_voices
operator|=
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
expr_stmt|;
if|if
condition|(
name|synthinfo
operator|->
name|nr_voices
operator|==
literal|12
condition|)
name|synthinfo
operator|->
name|nr_voices
operator|=
literal|6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|SNDCTL_MIDI_INFO
case|:
name|midiinfo
operator|=
operator|(
expr|struct
name|midi_info
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|midiinfo
operator|->
name|device
operator|!=
name|unit
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|opl_midiinfo
argument_list|,
name|midiinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|opl_midiinfo
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|midiinfo
operator|->
name|name
argument_list|,
name|scp
operator|->
name|synthinfo
operator|.
name|name
argument_list|)
expr_stmt|;
name|midiinfo
operator|->
name|device
operator|=
name|unit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|SNDCTL_FM_LOAD_INSTR
case|:
name|ins
operator|=
operator|(
expr|struct
name|sbi_instrument
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|ins
operator|->
name|channel
operator|<
literal|0
operator|||
name|ins
operator|->
name|channel
operator|>=
name|SBFM_MAXINSTR
condition|)
block|{
name|printf
argument_list|(
literal|"opl_ioctl: Instrument number %d is not valid.\n"
argument_list|,
name|ins
operator|->
name|channel
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|#
directive|if
name|notyet
name|pmgr_inform
argument_list|(
name|scp
argument_list|,
name|PM_E_PATCH_LOADED
argument_list|,
name|inc
operator|->
name|channel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
name|opl_storeinstr
argument_list|(
name|scp
argument_list|,
name|ins
operator|->
name|channel
argument_list|,
name|ins
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
if|if
condition|(
name|scp
operator|->
name|model
operator|>=
name|MODEL_OPL3
condition|)
name|opl_enter4opmode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_callback
parameter_list|(
name|void
modifier|*
name|d
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
name|devinfo
operator|=
operator|(
name|mididev_info
operator|*
operator|)
name|d
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devinfo
operator|->
name|flagqueue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|==
name|NULL
condition|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_callback: device not configured.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|unit
operator|=
name|devinfo
operator|->
name|unit
expr_stmt|;
name|scp
operator|=
name|devinfo
operator|->
name|softc
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: callback, reason 0x%x.\n"
argument_list|,
name|unit
argument_list|,
name|reason
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
operator|&
name|MIDI_CB_REASON_MASK
condition|)
block|{
case|case
name|MIDI_CB_START
case|:
if|if
condition|(
operator|(
name|reason
operator|&
name|MIDI_CB_RD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|devinfo
operator|->
name|flags
operator|&
name|MIDI_F_READING
operator|)
operator|==
literal|0
condition|)
comment|/* Begin recording. */
name|devinfo
operator|->
name|flags
operator||=
name|MIDI_F_READING
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|&
name|MIDI_CB_WR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|devinfo
operator|->
name|flags
operator|&
name|MIDI_F_WRITING
operator|)
operator|==
literal|0
condition|)
comment|/* Start playing. */
name|devinfo
operator|->
name|flags
operator||=
name|MIDI_F_WRITING
expr_stmt|;
break|break;
case|case
name|MIDI_CB_STOP
case|:
case|case
name|MIDI_CB_ABORT
case|:
if|if
condition|(
operator|(
name|reason
operator|&
name|MIDI_CB_RD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|devinfo
operator|->
name|flags
operator|&
name|MIDI_F_READING
operator|)
operator|!=
literal|0
condition|)
comment|/* Stop recording. */
name|devinfo
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_READING
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|&
name|MIDI_CB_WR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|devinfo
operator|->
name|flags
operator|&
name|MIDI_F_WRITING
operator|)
operator|!=
literal|0
condition|)
comment|/* Stop Playing. */
name|devinfo
operator|->
name|flags
operator|&=
operator|~
name|MIDI_F_WRITING
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_readraw
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|lenr
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|lenr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|->
name|fflags
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_readraw: unit %d is not for reading.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* NOP. */
operator|*
name|lenr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_writeraw
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|lenw
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|lenw
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|->
name|fflags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl_writeraw: unit %d is not for writing.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* NOP. */
operator|*
name|lenw
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The functions below here are the synthesizer interfaces. */
end_comment

begin_function
specifier|static
name|int
name|opl_killnote
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|vel
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: killing a note, voice %d, note %d, vel %d.\n"
argument_list|,
name|unit
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|vel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|!=
name|VOICE_NONE
condition|)
block|{
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
operator|=
literal|64
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_setinstr
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: setting an instrument, voice %d, instr_no %d.\n"
argument_list|,
name|unit
argument_list|,
name|voice
argument_list|,
name|instr_no
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|||
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>=
name|SBFM_MAXINSTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|act_i
index|[
name|voice
index|]
operator|=
operator|&
name|scp
operator|->
name|i_map
index|[
name|instr_no
index|]
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_startnote
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|u_char
name|fpc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|block
decl_stmt|,
name|fnum
decl_stmt|,
name|freq
decl_stmt|,
name|voice_mode
decl_stmt|,
name|voice_shift
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: starting a note, voice %d, note %d, volume %d.\n"
argument_list|,
name|unit
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|volume
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
name|VOICE_NONE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|note
operator|==
literal|255
condition|)
block|{
comment|/* Change the volume. */
name|opl_setvoicevolume
argument_list|(
name|scp
argument_list|,
name|voice
argument_list|,
name|volume
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Kill the previous note. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Carrier volume */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Modulator volume */
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
name|VOICE_4OP
condition|)
block|{
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Carrier volume */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Modulator volume */
block|}
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note off. */
name|instr
operator|=
name|scp
operator|->
name|act_i
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|==
name|NULL
condition|)
name|instr
operator|=
operator|&
name|scp
operator|->
name|i_map
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opl_startnote: the instrument for voice %d is undefined.\n"
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
name|VOICE_2OP
operator|&&
name|instr
operator|->
name|key
operator|==
name|OPL3_PATCH
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opl_startnote: the voice mode %d mismatches the key 0x%x.\n"
argument_list|,
name|map
operator|->
name|voice_mode
argument_list|,
name|instr
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|voice_mode
operator|=
name|map
operator|->
name|voice_mode
expr_stmt|;
if|if
condition|(
name|voice_mode
operator|==
name|VOICE_4OP
condition|)
block|{
if|if
condition|(
name|map
operator|->
name|ch
operator|==
name|USE_LEFT
condition|)
name|voice_shift
operator|=
literal|0
expr_stmt|;
else|else
name|voice_shift
operator|=
literal|3
expr_stmt|;
name|voice_shift
operator|+=
name|map
operator|->
name|voice_num
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|key
operator|!=
name|OPL3_PATCH
condition|)
block|{
name|voice_mode
operator|=
name|VOICE_2OP
expr_stmt|;
name|scp
operator|->
name|cmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|voice_shift
operator|)
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|cmask
operator||=
literal|1
operator|<<
name|voice_shift
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|scp
operator|->
name|cmask
argument_list|)
expr_stmt|;
block|}
comment|/* Set the sound characteristics, attack, decay, sustain, release, wave select, feedback, connection. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Sound characteristics. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Attack and decay. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* Sustain and release. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* Wave select. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|fpc
operator|=
name|instr
operator|->
name|operators
index|[
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fpc
operator|&
literal|0x30
operator|)
operator|==
literal|0
condition|)
name|fpc
operator||=
literal|0x30
expr_stmt|;
comment|/* So that at least one channel is enabled. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|FEEDBACK_CONNECTION
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|fpc
argument_list|)
expr_stmt|;
comment|/* Feedback and connection. */
if|if
condition|(
name|voice_mode
operator|==
name|VOICE_4OP
condition|)
block|{
comment|/* Do not forget the operators 3 and 4. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Sound characteristics. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Attack and decay. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* Sustain and release. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* Wave select. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
name|fpc
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fpc
operator|&
literal|0x30
operator|)
operator|==
literal|0
condition|)
name|fpc
operator||=
literal|0x30
expr_stmt|;
comment|/* So that at least one channel is enabled. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|FEEDBACK_CONNECTION
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|fpc
argument_list|)
expr_stmt|;
comment|/* Feedback and connection. */
block|}
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|=
name|voice_mode
expr_stmt|;
name|opl_setvoicevolume
argument_list|(
name|scp
argument_list|,
name|voice
argument_list|,
name|volume
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
argument_list|)
expr_stmt|;
comment|/* Calcurate the frequency. */
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
name|opl_notetofreq
argument_list|(
name|note
argument_list|)
operator|/
literal|1000
expr_stmt|;
comment|/* Tune for the pitch bend. */
name|freq
operator|=
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|opl_computefinetune
argument_list|(
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|opl_freqtofnum
argument_list|(
name|freq
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|fnum
argument_list|)
expr_stmt|;
comment|/* Now we can play the note. */
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|FNUM_LOW
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|fnum
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
literal|0x20
operator||
operator|(
operator|(
name|block
operator|&
literal|0x07
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|fnum
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice_mode
operator|==
name|VOICE_4OP
condition|)
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_reset
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: resetting.\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VOICE
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
name|opl_command
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|voice_mode
operator|==
name|VOICE_4OP
condition|)
block|{
name|opl_command
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|2
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|3
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * opl_killnote(md, i, 0, 64) inline-expanded to avoid 		 * unlocking and relocking mutex unnecessarily. 		 */
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|map
operator|=
operator|&
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|!=
name|VOICE_NONE
condition|)
block|{
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|keyon_byte
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|keyon_byte
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|volume
operator|=
literal|64
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|orig_freq
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|current_freq
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|i
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scp
operator|->
name|model
operator|>=
name|MODEL_OPL3
condition|)
block|{
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
literal|18
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_VOICE
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
name|VOICE_2OP
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_hwcontrol
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
comment|/* NOP. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_loadpatch
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|format
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|sbi_instrument
name|ins
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"opl_loadpatch: The patch record is too short.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|uiomove
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ins
operator|)
index|[
name|offs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
operator|-
name|offs
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"opl_loadpatch: User memory mangled?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|channel
operator|<
literal|0
operator|||
name|ins
operator|.
name|channel
operator|>=
name|SBFM_MAXINSTR
condition|)
block|{
name|printf
argument_list|(
literal|"opl_loadpatch: Instrument number %d is not valid.\n"
argument_list|,
name|ins
operator|.
name|channel
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ins
operator|.
name|key
operator|=
name|format
expr_stmt|;
name|opl_storeinstr
argument_list|(
name|scp
argument_list|,
name|ins
operator|.
name|channel
argument_list|,
operator|&
name|ins
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_panning
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|pan
parameter_list|)
block|{
comment|/* NOP. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SET_VIBRATO
parameter_list|(
name|cell
parameter_list|)
value|do { \ 	int tmp; \ 	tmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \ 	if (press> 110) \ 		tmp |= 0x40;
comment|/* Vibrato on */
value|\ 	opl_command(scp, map->ch, AM_VIB + map->op[cell-1], tmp);} while(0);
end_define

begin_function
specifier|static
name|int
name|opl_aftertouch
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|press
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|connection
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: setting the aftertouch, voice %d, press %d.\n"
argument_list|,
name|unit
argument_list|,
name|voice
argument_list|,
name|press
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
name|VOICE_NONE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Adjust the vibrato. */
name|instr
operator|=
name|scp
operator|->
name|act_i
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|==
name|NULL
condition|)
name|instr
operator|=
operator|&
name|scp
operator|->
name|i_map
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|==
name|VOICE_4OP
condition|)
block|{
name|connection
operator|=
operator|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
operator|+
name|OFFS_4OP
index|]
operator|&
literal|0x01
operator|)
expr_stmt|;
switch|switch
condition|(
name|connection
condition|)
block|{
case|case
literal|0
case|:
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|SET_VIBRATO
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
condition|)
name|SET_VIBRATO
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_bendpitch
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|block
decl_stmt|,
name|fnum
decl_stmt|,
name|freq
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|mididev_info
modifier|*
name|md
decl_stmt|;
name|md
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: setting the pitch bend, voice %d, value %d.\n"
argument_list|,
name|unit
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
operator|||
operator|(
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|freq
operator|=
name|opl_computefinetune
argument_list|(
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|opl_freqtofnum
argument_list|(
name|freq
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|fnum
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|FNUM_LOW
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|fnum
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
literal|0x20
operator||
operator|(
operator|(
name|block
operator|&
literal|0x07
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|fnum
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
name|VOICE_4OP
condition|)
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_controller
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrlnum
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|unit
operator|=
name|md
operator|->
name|unit
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: setting the controller, voice %d, ctrlnum %d, val %d.\n"
argument_list|,
name|unit
argument_list|,
name|voice
argument_list|,
name|ctrlnum
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|ctrlnum
condition|)
block|{
case|case
name|CTRL_PITCH_BENDER
case|:
name|opl_bendpitch
argument_list|(
name|scp
argument_list|,
name|voice
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|val
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_MAIN_VOLUME
case|:
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
operator|=
name|val
operator|/
literal|128
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_patchmgr
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_bender
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|opl_bendpitch
argument_list|(
name|scp
argument_list|,
name|voice
argument_list|,
name|val
operator|-
literal|8192
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_allocvoice
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|best
decl_stmt|,
name|first
decl_stmt|,
name|avail
decl_stmt|,
name|best_time
decl_stmt|,
name|is4op
decl_stmt|,
name|instr_no
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: allocating a voice, chn %d, note %d.\n"
argument_list|,
name|md
operator|->
name|unit
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|best_time
operator|=
literal|0x7fffffff
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|chn
operator|<
literal|0
operator|||
name|chn
operator|>=
literal|15
condition|)
name|instr_no
operator|=
literal|0
expr_stmt|;
else|else
name|instr_no
operator|=
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|instr
operator|=
operator|&
name|scp
operator|->
name|i_map
index|[
name|instr_no
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
operator|||
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|!=
literal|12
condition|)
name|is4op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|instr
operator|->
name|key
operator|==
name|OPL3_PATCH
condition|)
name|is4op
operator|=
literal|1
expr_stmt|;
else|else
name|is4op
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|is4op
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is4op
condition|)
block|{
name|first
operator|=
name|p
operator|=
literal|0
expr_stmt|;
name|avail
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|==
literal|12
condition|)
name|first
operator|=
name|p
operator|=
literal|6
expr_stmt|;
else|else
name|first
operator|=
name|p
operator|=
literal|0
expr_stmt|;
name|avail
operator|=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
expr_stmt|;
block|}
comment|/* Look up a free voice. */
name|best
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|avail
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
operator|<
name|best_time
condition|)
block|{
name|best_time
operator|=
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|avail
expr_stmt|;
if|if
condition|(
name|best
operator|<
literal|0
condition|)
name|best
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|best
operator|>
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
name|best
operator|-=
name|md
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
return|return
name|best
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_setupvoice
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
decl_stmt|;
name|sc_p
name|scp
decl_stmt|;
name|scp
operator|=
name|md
operator|->
name|softc
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: setting up a voice, voice %d, chn %d.\n"
argument_list|,
name|md
operator|->
name|unit
argument_list|,
name|voice
argument_list|,
name|chn
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|info
operator|=
operator|&
name|md
operator|->
name|synth
operator|.
name|chn_info
index|[
name|chn
index|]
expr_stmt|;
name|opl_setinstr
argument_list|(
name|md
argument_list|,
name|voice
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|md
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_sendsysex
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|u_char
modifier|*
name|sysex
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* NOP. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_prefixcmd
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|status
parameter_list|)
block|{
comment|/* NOP. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl_volumemethod
parameter_list|(
name|mididev_info
modifier|*
name|md
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* NOP. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The functions below here are the libraries for the above ones.  */
end_comment

begin_comment
comment|/* Writes a command to the OPL chip. */
end_comment

begin_function
specifier|static
name|void
name|opl_command
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|int
name|model
decl_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: sending a command, addr 0x%x, val 0x%x.\n"
argument_list|,
name|scp
operator|->
name|devinfo
operator|->
name|unit
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|model
operator|=
name|scp
operator|->
name|model
expr_stmt|;
comment|/* Write the addr first. */
name|bus_space_write_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|ch
operator|*
literal|2
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|<
name|MODEL_OPL3
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|else
block|{
name|bus_space_read_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|ch
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bus_space_read_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|ch
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Next write the value. */
name|bus_space_write_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|ch
operator|*
literal|2
operator|+
literal|1
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
operator|<
name|MODEL_OPL3
condition|)
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
else|else
block|{
name|bus_space_read_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|ch
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bus_space_read_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|ch
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reads the status of the OPL chip. */
end_comment

begin_function
specifier|static
name|int
name|opl_status
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: reading the status.\n"
argument_list|,
name|scp
operator|->
name|devinfo
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|scp
operator|->
name|io
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl_enter4opmode
parameter_list|(
name|sc_p
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
specifier|static
name|int
name|v4op
index|[
name|MAX_VOICE
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|, 	}
decl_stmt|;
name|devinfo
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
name|MIDI_DEBUG
argument_list|(
name|printf
argument_list|(
literal|"opl%d: entering 4 OP mode.\n"
argument_list|,
name|devinfo
operator|->
name|unit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Connect all possible 4 OP voice operators. */
name|mtx_lock
argument_list|(
operator|&
name|devinfo
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cmask
operator|=
literal|0x3f
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|USE_RIGHT
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|scp
operator|->
name|cmask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
name|VOICE_4OP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
name|VOICE_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
name|VOICE_4OP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
name|VOICE_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|lv_map
index|[
name|i
index|]
operator|=
name|v4op
index|[
name|i
index|]
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|scp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
operator|=
literal|12
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devinfo
operator|->
name|synth
operator|.
name|vc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl_storeinstr
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|instr_no
parameter_list|,
name|struct
name|sbi_instrument
modifier|*
name|instr
parameter_list|)
block|{
if|if
condition|(
name|instr
operator|->
name|key
operator|!=
name|FM_PATCH
operator|&&
operator|(
name|instr
operator|->
name|key
operator|!=
name|OPL3_PATCH
operator|||
name|scp
operator|->
name|model
operator|<
name|MODEL_OPL3
operator|)
condition|)
name|printf
argument_list|(
literal|"opl_storeinstr: The patch format field 0x%x is not valid.\n"
argument_list|,
name|instr
operator|->
name|key
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|instr
argument_list|,
operator|&
name|scp
operator|->
name|i_map
index|[
name|instr_no
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl_calcvol
parameter_list|(
name|u_char
modifier|*
name|regbyte
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|main_vol
parameter_list|)
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
operator|(
operator|~
operator|*
name|regbyte
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|main_vol
operator|>
literal|127
condition|)
name|main_vol
operator|=
literal|127
expr_stmt|;
name|volume
operator|=
operator|(
name|volume
operator|*
name|main_vol
operator|)
operator|/
literal|127
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|level
operator|+=
name|opl_volumetable
index|[
name|volume
index|]
expr_stmt|;
name|RANGE
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
operator|*
name|regbyte
operator|=
operator|(
operator|*
name|regbyte
operator|&
literal|0xc0
operator|)
operator||
operator|(
operator|~
name|level
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl_setvoicevolume
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|main_vol
parameter_list|)
block|{
name|u_char
name|vol1
decl_stmt|,
name|vol2
decl_stmt|,
name|vol3
decl_stmt|,
name|vol4
decl_stmt|;
name|int
name|connection
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|mididev_info
modifier|*
name|devinfo
decl_stmt|;
name|devinfo
operator|=
name|scp
operator|->
name|devinfo
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devinfo
operator|->
name|synth
operator|.
name|alloc
operator|.
name|max_voice
condition|)
return|return;
name|map
operator|=
operator|&
name|scp
operator|->
name|pv_map
index|[
name|scp
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
name|instr
operator|=
name|scp
operator|->
name|act_i
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|==
name|NULL
condition|)
name|instr
operator|=
operator|&
name|scp
operator|->
name|i_map
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|==
name|VOICE_NONE
condition|)
return|return;
if|if
condition|(
name|scp
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|==
name|VOICE_2OP
condition|)
block|{
comment|/* 2 OP mode. */
name|vol1
operator|=
name|instr
operator|->
name|operators
index|[
literal|2
index|]
expr_stmt|;
name|vol2
operator|=
name|instr
operator|->
name|operators
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
condition|)
name|opl_calcvol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl_calcvol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|vol1
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|vol2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 4 OP mode. */
name|vol1
operator|=
name|instr
operator|->
name|operators
index|[
literal|2
index|]
expr_stmt|;
name|vol2
operator|=
name|instr
operator|->
name|operators
index|[
literal|3
index|]
expr_stmt|;
name|vol3
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|2
index|]
expr_stmt|;
name|vol4
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|3
index|]
expr_stmt|;
name|connection
operator|=
operator|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
operator|+
name|OFFS_4OP
index|]
operator|&
literal|0x01
operator|)
expr_stmt|;
switch|switch
condition|(
name|connection
condition|)
block|{
case|case
literal|0
case|:
name|opl_calcvol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|opl_calcvol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl_calcvol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|opl_calcvol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl_calcvol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|opl_calcvol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl_calcvol
argument_list|(
operator|&
name|vol3
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl_calcvol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
block|}
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|vol1
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|vol2
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|vol3
argument_list|)
expr_stmt|;
name|opl_command
argument_list|(
name|scp
argument_list|,
name|map
operator|->
name|ch
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|vol4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|opl_freqtofnum
parameter_list|(
name|int
name|freq
parameter_list|,
name|int
modifier|*
name|block
parameter_list|,
name|int
modifier|*
name|fnum
parameter_list|)
block|{
name|int
name|f
decl_stmt|,
name|octave
decl_stmt|;
name|f
operator|=
name|freq
expr_stmt|;
name|octave
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
name|octave
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|<
literal|261
condition|)
block|{
while|while
condition|(
name|f
operator|<
literal|261
condition|)
block|{
name|octave
operator|--
expr_stmt|;
name|f
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|>
literal|493
condition|)
block|{
while|while
condition|(
name|f
operator|>
literal|493
condition|)
block|{
name|octave
operator|++
expr_stmt|;
name|f
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|octave
operator|>
literal|7
condition|)
name|octave
operator|=
literal|7
expr_stmt|;
operator|*
name|fnum
operator|=
name|freq
operator|*
operator|(
literal|1
operator|<<
operator|(
literal|20
operator|-
name|octave
operator|)
operator|)
operator|/
literal|49716
expr_stmt|;
operator|*
name|block
operator|=
name|octave
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|notes
index|[]
init|=
block|{
literal|261632
block|,
literal|277189
block|,
literal|293671
block|,
literal|311132
block|,
literal|329632
block|,
literal|349232
block|,
literal|369998
block|,
literal|391998
block|,
literal|415306
block|,
literal|440000
block|,
literal|466162
block|,
literal|493880
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BASE_OCTAVE
value|5
end_define

begin_function
specifier|static
name|int
name|opl_notetofreq
parameter_list|(
name|int
name|note_num
parameter_list|)
block|{
name|int
name|note
decl_stmt|,
name|octave
decl_stmt|,
name|note_freq
decl_stmt|;
name|octave
operator|=
name|note_num
operator|/
literal|12
expr_stmt|;
name|note
operator|=
name|note_num
operator|%
literal|12
expr_stmt|;
name|note_freq
operator|=
name|notes
index|[
name|note
index|]
expr_stmt|;
if|if
condition|(
name|octave
operator|<
name|BASE_OCTAVE
condition|)
name|note_freq
operator|>>=
operator|(
name|BASE_OCTAVE
operator|-
name|octave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|octave
operator|>
name|BASE_OCTAVE
condition|)
name|note_freq
operator|<<=
operator|(
name|octave
operator|-
name|BASE_OCTAVE
operator|)
expr_stmt|;
return|return
operator|(
name|note_freq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|opl_computefinetune
parameter_list|(
name|u_long
name|base_freq
parameter_list|,
name|int
name|bend
parameter_list|,
name|int
name|range
parameter_list|)
block|{
name|u_long
name|amount
decl_stmt|;
name|int
name|negative
decl_stmt|,
name|semitones
decl_stmt|,
name|cents
decl_stmt|,
name|multiplier
decl_stmt|;
if|if
condition|(
name|bend
operator|==
literal|0
operator|||
name|range
operator|==
literal|0
operator|||
name|base_freq
operator|==
literal|0
condition|)
return|return
operator|(
name|base_freq
operator|)
return|;
name|multiplier
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|range
operator|>
literal|8192
condition|)
name|range
operator|=
literal|8192
expr_stmt|;
name|bend
operator|=
name|bend
operator|*
name|range
operator|/
literal|8192
expr_stmt|;
if|if
condition|(
name|bend
operator|==
literal|0
condition|)
return|return
operator|(
name|base_freq
operator|)
return|;
if|if
condition|(
name|bend
operator|<
literal|0
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
name|bend
operator|=
operator|-
name|bend
expr_stmt|;
block|}
else|else
name|negative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bend
operator|>
name|range
condition|)
name|bend
operator|=
name|range
expr_stmt|;
while|while
condition|(
name|bend
operator|>
literal|2399
condition|)
block|{
name|multiplier
operator|*=
literal|4
expr_stmt|;
name|bend
operator|-=
literal|2400
expr_stmt|;
block|}
name|semitones
operator|=
name|bend
operator|/
literal|100
expr_stmt|;
name|cents
operator|=
name|bend
operator|%
literal|100
expr_stmt|;
name|amount
operator|=
call|(
name|u_long
call|)
argument_list|(
name|semitone_tuning
index|[
name|semitones
index|]
operator|*
name|multiplier
operator|*
name|cent_tuning
index|[
name|cents
index|]
argument_list|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|negative
condition|)
return|return
operator|(
name|base_freq
operator|*
literal|10000
operator|)
operator|/
name|amount
return|;
else|else
return|return
operator|(
name|base_freq
operator|*
name|amount
operator|)
operator|/
literal|10000
return|;
block|}
end_function

begin_comment
comment|/* Allocates resources other than IO ports. */
end_comment

begin_function
specifier|static
name|int
name|opl_allocres
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|io
operator|==
name|NULL
condition|)
block|{
name|scp
operator|->
name|io
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|scp
operator|->
name|io_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|io
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Releases resources. */
end_comment

begin_function
specifier|static
name|void
name|opl_releaseres
parameter_list|(
name|sc_p
name|scp
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|io
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|scp
operator|->
name|io_rid
argument_list|,
name|scp
operator|->
name|io
argument_list|)
expr_stmt|;
name|scp
operator|->
name|io
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|opl_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|opl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|opl_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|opl_driver
init|=
block|{
literal|"midi"
block|,
name|opl_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opl_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|opl
argument_list|,
name|isa
argument_list|,
name|opl_driver
argument_list|,
name|midi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|oplsbc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|oplsbc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|oplsbc_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|oplsbc_driver
init|=
block|{
literal|"midi"
block|,
name|oplsbc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opl_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|oplsbc
argument_list|,
name|sbc
argument_list|,
name|oplsbc_driver
argument_list|,
name|midi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

