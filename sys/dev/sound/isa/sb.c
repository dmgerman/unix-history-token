begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/sb_dsp.c  *   * driver for the SoundBlaster and clones.  *   * Copyright 1997,1998 Luigi Rizzo.  *  * Derived from files in the Voxware 3.5 distribution,  * Copyright by Hannu Savolainen 1994, under the same copyright  * conditions.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   */
end_comment

begin_comment
comment|/*  * use this as a template file for board-specific drivers.  * The next two lines (and the final #endif) are in all drivers:  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sound.h>
end_include

begin_if
if|#
directive|if
name|NPCM
operator|>
literal|0
end_if

begin_comment
comment|/*  * Begin with the board-specific include files...  */
end_comment

begin_define
define|#
directive|define
name|__SB_MIXER_C__
end_define

begin_comment
comment|/* XXX warning... */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sbcard.h>
end_include

begin_comment
comment|/*  * then prototypes of functions which go in the snddev_info  * (usually static, unless they are shared by other modules)...  */
end_comment

begin_function_decl
specifier|static
name|int
name|sb_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sb_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|sb_dsp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sb_dsp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sb_dsp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|irq_proc_t
name|sb_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|snd_callback_t
name|sb_callback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * and prototypes for other private functions defined in this module.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sb_dsp_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sb_mix_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sb_mixer_set
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_speed
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sb_mixer_reset
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int
name|sb_get_byte
parameter_list|(
name|int
name|io_base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ess_write
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ess_read
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Then put here the descriptors for the various boards supported  * by this module, properly initialized.  */
end_comment

begin_decl_stmt
name|snddev_info
name|sb_op_desc
init|=
block|{
literal|"basic soundblaster"
block|,
name|SNDCARD_SB
block|,
name|sb_probe
block|,
name|sb_attach
block|,
name|sb_dsp_open
block|,
name|sb_dsp_close
comment|/* sb_close */
block|,
name|NULL
comment|/* use generic sndread */
block|,
name|NULL
comment|/* use generic sndwrite */
block|,
name|sb_dsp_ioctl
block|,
name|sndselect
block|,
name|sb_intr
block|,
name|sb_callback
block|,
name|DSP_BUFFSIZE
block|,
comment|/* bufsize */
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
comment|/* audio format */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Then the file continues with the body of all functions  * directly referenced in the descriptor.  */
end_comment

begin_comment
comment|/*  * the probe routine for the SoundBlaster only consists in  * resetting the dsp and testing if it is there.  * Version detection etc. will be done at attach time.  *  * Remember, ISA probe routines are supposed to return the  * size of io space used.  */
end_comment

begin_function
specifier|static
name|int
name|sb_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_iobase
operator|==
operator|-
literal|1
condition|)
block|{
name|dev
operator|->
name|id_iobase
operator|=
literal|0x220
expr_stmt|;
name|BVDDB
argument_list|(
argument|printf(
literal|"sb_probe: no address supplied, try defaults (0x220,0x240)\n"
argument|);
argument_list|)
if|if
condition|(
name|snd_conflict
argument_list|(
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
name|dev
operator|->
name|id_iobase
operator|=
literal|0x240
expr_stmt|;
block|}
if|if
condition|(
name|snd_conflict
argument_list|(
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sb_reset_dsp
argument_list|(
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
return|return
literal|16
return|;
comment|/* the SB uses 16 registers... */
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
init|=
operator|&
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|dev
operator|->
name|id_alive
operator|=
literal|16
expr_stmt|;
comment|/* number of io ports */
comment|/* should be already set but just in case... */
name|sb_dsp_init
argument_list|(
name|d
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * here are the main routines from the switches.  */
end_comment

begin_comment
comment|/*  * Unlike MSS, the sb only supports a single open (does not mean  * that only a single process is using it, since it can fork  * afterwards, or pass the descriptor to another process).  *  */
end_comment

begin_function
specifier|static
name|int
name|sb_dsp_open
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|unit
index|]
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"<%s>%d : open\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_BUSY
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"<%s>%d open: device busy\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|d
operator|->
name|wsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|wsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|dbuf_out
operator|.
name|total
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|prev_total
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|dbuf_in
operator|.
name|total
operator|=
name|d
operator|->
name|dbuf_in
operator|.
name|prev_total
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_HISPEED
expr_stmt|;
switch|switch
condition|(
name|dev
operator|&
literal|0xf
condition|)
block|{
case|case
name|SND_DEV_DSP16
case|:
if|if
condition|(
operator|(
name|d
operator|->
name|audio_fmt
operator|&
name|AFMT_S16_LE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sorry, 16-bit not supported on SB %d.%02d\n"
argument_list|,
operator|(
name|d
operator|->
name|bd_id
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|d
operator|->
name|bd_id
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
break|break ;
case|case
name|SND_DEV_DSP
case|:
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_U8
expr_stmt|;
break|break ;
block|}
comment|/*      * since the SB is not simmetric, I use the open mode to select      * which channel should be privileged, and disable I/O in the      * other direction.      * In case the board is opened RW, we don't have enough      * information on what to do. Temporarily, privilege the      * playback channel, which is used more often, and set the other      * one to U8.      */
if|if
condition|(
operator|(
name|flags
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
comment|/* opened write only	*/
name|d
operator|->
name|rec_fmt
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
comment|/* opened read only	*/
name|d
operator|->
name|play_fmt
operator|=
literal|0
expr_stmt|;
else|else
comment|/* opened read/write	*/
name|d
operator|->
name|rec_fmt
operator|=
operator|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
operator|)
condition|?
name|AFMT_U8
else|:
name|AFMT_S16_LE
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_BUSY
expr_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_NBIO
expr_stmt|;
name|sb_reset_dsp
argument_list|(
name|d
operator|->
name|io_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_ESS
condition|)
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xc6
argument_list|)
expr_stmt|;
comment|/* enable extended ESS mode */
name|ask_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_dsp_close
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_CLOSING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|snd_flush
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_SPKOFF
argument_list|)
expr_stmt|;
comment|/* XXX useless ? */
name|d
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_dsp_ioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|unit
index|]
expr_stmt|;
comment|/*      * handle mixer calls first. Reads are in the default handler,      * so do not bother about them.      */
if|if
condition|(
operator|(
name|cmd
operator|&
name|MIXER_WRITE
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|MIXER_WRITE
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|sb_mixer_set
argument_list|(
name|d
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
return|;
comment|/*      * for the remaining functions, use the default handler.      * ENOSYS means that the default handler should take care      * of implementing the ioctl.      */
return|return
name|ENOSYS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb_intr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
init|=
operator|&
name|pcm_info
index|[
name|unit
index|]
decl_stmt|;
name|int
name|reason
init|=
literal|3
decl_stmt|,
name|c
init|=
literal|1
decl_stmt|,
name|io_base
init|=
name|d
operator|->
name|io_base
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"got sb_intr for unit %d, flags 0x%08lx\n"
argument_list|,
name|unit
argument_list|,
name|d
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * SB< 4.0 is half duplex and has only 1 bit for int source,      * so we fake it. SB 4.x (SB16) has the int source in a separate      * register.      * The Vibra16X has separate flags for 8 and 16 bit transfers, but      * I have no idea how to tell capture from playback interrupts...      */
define|#
directive|define
name|PLAIN_SB16
parameter_list|(
name|x
parameter_list|)
value|( ( (x)& (BD_F_SB16|BD_F_SB16X) ) == BD_F_SB16)
name|again
label|:
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|c
operator|=
name|sb_getmixer
argument_list|(
name|io_base
argument_list|,
name|IRQ_STAT
argument_list|)
expr_stmt|;
comment|/* this tells us if the source is 8-bit or 16-bit dma. We 	 * have to check the io channel to map it to read or write... 	 */
name|reason
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|1
condition|)
block|{
comment|/* 8-bit dma */
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_U8
operator|||
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_MU_LAW
condition|)
name|reason
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_U8
operator|||
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_MU_LAW
condition|)
name|reason
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&
literal|2
condition|)
block|{
comment|/* 16-bit dma */
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
condition|)
name|reason
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_S16_LE
condition|)
name|reason
operator||=
literal|2
expr_stmt|;
block|}
block|}
comment|/* XXX previous location of ack... */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sb_intr, flags 0x%08lx reason %d c 0x%x\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|,
name|reason
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|&
literal|1
condition|)
block|{
comment|/* possibly a write interrupt */
if|if
condition|(
name|d
operator|->
name|dbuf_out
operator|.
name|dl
condition|)
name|dsp_wrintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|&
literal|2
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|dbuf_in
operator|.
name|dl
condition|)
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&
literal|2
condition|)
name|inb
argument_list|(
name|DSP_DATA_AVL16
argument_list|)
expr_stmt|;
comment|/* 16-bit int ack */
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
expr_stmt|;
comment|/* 8-bit int ack */
comment|/*      * the sb16 might have multiple sources etc.      */
if|if
condition|(
operator|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
operator|)
operator|&&
operator|(
name|c
operator|&
literal|3
operator|)
condition|)
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * device-specific function called back from the dma module.  * The reason of the callback is the second argument.  * NOTE: during operations, some ioctl can be called to change  * settings (e.g. speed, channels, format), and the default  * ioctl handler will just record the change and set the  * flag SND_F_INIT. The callback routine is in charge of applying  * the changes at the next convenient time (typically, at the  * start of operations). For full duplex devices, in some cases the  * init requires both channels to be idle.  */
end_comment

begin_function
specifier|static
name|int
name|sb_callback
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|int
name|rd
init|=
name|reason
operator|&
name|SND_CB_RD
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|(
name|rd
operator|)
condition|?
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
else|:
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|int
name|l
init|=
name|b
operator|->
name|dl
decl_stmt|;
switch|switch
condition|(
name|reason
operator|&
name|SND_CB_REASON_MASK
condition|)
block|{
case|case
name|SND_CB_INIT
case|:
comment|/* called with int enabled and no pending io */
comment|/* 	 * set the speed 	 */
name|dsp_speed
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * set the desired DMA blocksize (influences select behaviour) 	 */
name|snd_set_blocksize
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * since native mulaw is not present, emulate it. 	 */
if|if
condition|(
operator|(
name|d
operator|->
name|play_fmt
operator|&
name|AFMT_MU_LAW
operator|)
operator|||
operator|(
name|d
operator|->
name|rec_fmt
operator|&
name|AFMT_MU_LAW
operator|)
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_XLAT8
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_XLAT8
expr_stmt|;
comment|/* 	 * there are too many flavours of SB for my taste... here i try to do 	 * the proper initialization for each one. 	 */
if|if
condition|(
name|PLAIN_SB16
argument_list|(
name|d
operator|->
name|bd_flags
argument_list|)
condition|)
block|{
comment|/* the original SB16 (non-PnP, or PnP, or Vibra16C) 	     * can do full duplex using one 16-bit channel 	     * and one 8-bit channel. It needs to be programmed to 	     * use split format though. 	     * I DON'T do this for the Vibra16X because I have no idea 	     * of what needs to be done there... 	     * 	     * I use the following algorithm: 	     * 1. check which direction(s) are active; 	     * 2. check if we should swap dma channels 	     * 3. check if we can do the swap. 	     */
name|int
name|swap
init|=
literal|1
decl_stmt|;
comment|/* default... */
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
literal|0
condition|)
block|{
comment|/* do whatever the read channel wants */
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_S16_LE
operator|&&
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|>
literal|4
condition|)
name|swap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|!=
name|AFMT_S16_LE
operator|&&
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|<
literal|4
condition|)
name|swap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* privilege the write channel */
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
operator|&&
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|>
literal|4
condition|)
name|swap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|!=
name|AFMT_S16_LE
operator|&&
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|<
literal|4
condition|)
name|swap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec_fmt
condition|)
block|{
comment|/* check for possible config errors. 		     * This cannot happen at open time since even in 		     * case of opening rw we privilege the play 		     * channel. 		     */
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|==
name|d
operator|->
name|play_fmt
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"sorry, read DMA channel unavailable\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DEB
argument_list|(
argument|printf(
literal|"sb16: play_fmt %d, rec_fmt %x, swap %d\n"
argument|, 		d->play_fmt, d->rec_fmt, swap);
argument_list|)
if|if
condition|(
name|swap
condition|)
block|{
name|int
name|c
init|=
name|d
operator|->
name|dbuf_in
operator|.
name|chan
decl_stmt|;
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|chan
expr_stmt|;
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_ESS
condition|)
block|{
name|u_char
name|c
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SND_CB_INIT, play_fmt == 0x%x, rec_fmt == 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|play_fmt
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|rec_fmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* autoinit DMA mode */
if|if
condition|(
name|d
operator|->
name|play_fmt
condition|)
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb8
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
else|else
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb8
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|ess_read
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xa8
argument_list|)
operator|&
operator|~
literal|0x03
operator|)
operator||
literal|0x01
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
operator|)
operator|==
literal|0
condition|)
name|c
operator|++
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xa8
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* select mono/stereo */
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb9
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* demand 4 bytes/transfer */
switch|switch
condition|(
name|d
operator|->
name|play_fmt
condition|?
name|d
operator|->
name|play_fmt
else|:
name|d
operator|->
name|rec_fmt
condition|)
block|{
case|case
name|AFMT_S16_LE
case|:
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
block|{
comment|/* 16 bit stereo */
if|if
condition|(
name|d
operator|->
name|play_fmt
condition|)
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb6
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0x71
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0xbc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 16 bit mono */
if|if
condition|(
name|d
operator|->
name|play_fmt
condition|)
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb6
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0x71
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0xf4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AFMT_U8
case|:
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
block|{
comment|/* 8 bit stereo */
if|if
condition|(
name|d
operator|->
name|play_fmt
condition|)
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb6
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0x51
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0x98
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 8 bit mono */
if|if
condition|(
name|d
operator|->
name|play_fmt
condition|)
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb6
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0x51
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb7
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb1
argument_list|,
name|ess_read
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb1
argument_list|)
operator||
literal|0x50
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb2
argument_list|,
name|ess_read
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb1
argument_list|)
operator||
literal|0x50
argument_list|)
expr_stmt|;
block|}
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|,
name|SND_CHAN_RD
argument_list|)
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|SND_CHAN_WR
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SND_CB_START
case|:
comment|/* called with int disabled */
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|u_char
name|c
decl_stmt|,
name|c1
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16X
condition|)
block|{
comment|/* just a guess: on the Vibra16X, the first                  * op started takes the first dma channel,                  * the second one takes the next...                  * The default is to be ready for play.                  */
name|DEB
argument_list|(
argument|printf(
literal|"start %s -- now dma %d:%d\n"
argument|, 			rd ?
literal|"rd"
argument|:
literal|"wr"
argument|, 			d->dbuf_out.chan, d->dbuf_in.chan);
argument_list|)
empty_stmt|;
comment|/* swap only if both channels are idle 		 *   play: dl=0, since there is no pause; 		 *   rec: rl=0 		 */
if|if
condition|(
name|rd
operator|&&
name|d
operator|->
name|dbuf_out
operator|.
name|dl
operator|==
literal|0
operator|&&
name|d
operator|->
name|dbuf_in
operator|.
name|rl
operator|==
literal|0
condition|)
block|{
comment|/* must swap channels, but also save dl */
name|int
name|c
init|=
name|d
operator|->
name|dbuf_in
operator|.
name|chan
decl_stmt|;
name|int
name|dl
init|=
name|d
operator|->
name|dbuf_in
operator|.
name|dl
decl_stmt|;
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|chan
expr_stmt|;
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|=
name|c
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|,
name|SND_CHAN_RD
argument_list|)
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|SND_CHAN_WR
argument_list|)
expr_stmt|;
name|d
operator|->
name|dbuf_in
operator|.
name|dl
operator|=
name|dl
expr_stmt|;
name|printf
argument_list|(
literal|"swapped -- now dma %d:%d\n"
argument_list|,
name|d
operator|->
name|dbuf_out
operator|.
name|chan
argument_list|,
name|d
operator|->
name|dbuf_in
operator|.
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	     * XXX note: c1 and l should be set basing on d->rec_fmt, 	     * but there is no choice once a 16 or 8-bit channel 	     * is assigned. This means that if the application 	     * tries to use a bad format, the sound will not be nice. 	     */
if|if
condition|(
name|b
operator|->
name|chan
operator|>
literal|4
operator|||
operator|(
name|rd
operator|&&
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_S16_LE
operator|)
operator|||
operator|(
operator|!
name|rd
operator|&&
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
operator|)
condition|)
block|{
name|c
operator|=
name|DSP_F16_AUTO
operator||
name|DSP_F16_FIFO_ON
operator||
name|DSP_DMA16
expr_stmt|;
name|c1
operator|=
name|DSP_F16_SIGNED
expr_stmt|;
name|l
operator|/=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|DSP_F16_AUTO
operator||
name|DSP_F16_FIFO_ON
operator||
name|DSP_DMA8
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator||=
operator|(
name|rd
operator|)
condition|?
name|DSP_F16_ADC
else|:
name|DSP_F16_DAC
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|c1
operator||=
name|DSP_F16_STEREO
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sb_cmd3
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|c1
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_ESS
condition|)
block|{
name|u_long
name|fmt
init|=
name|rd
condition|?
name|d
operator|->
name|rec_fmt
else|:
name|d
operator|->
name|play_fmt
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SND_CB_START: %s (%d)\n"
argument_list|,
name|rd
condition|?
literal|"rd"
else|:
literal|"wr"
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|AFMT_S16_LE
condition|)
name|l
operator|>>=
literal|1
expr_stmt|;
name|l
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|rd
condition|)
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_SPKON
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xa4
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xa5
argument_list|,
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb8
argument_list|,
name|ess_read
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xb8
argument_list|)
operator||
operator|(
name|rd
condition|?
literal|0x0f
else|:
literal|0x05
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SBPro -- stereo not supported */
name|u_char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|rd
condition|)
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_SPKON
argument_list|)
expr_stmt|;
comment|/* code for the SB2 and SB3, only MONO */
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_HISPEED
condition|)
name|c
operator|=
operator|(
name|rd
operator|)
condition|?
literal|0x98
else|:
literal|0x90
expr_stmt|;
else|else
name|c
operator|=
operator|(
name|rd
operator|)
condition|?
literal|0x2c
else|:
literal|0x1c
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xe
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	     * some ESS extensions -- they can do 16 bits 	     */
if|if
condition|(
operator|(
name|rd
operator|&&
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_S16_LE
operator|)
operator|||
operator|(
operator|!
name|rd
operator|&&
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
operator|)
condition|)
block|{
name|c
operator||=
literal|1
expr_stmt|;
name|l
operator|/=
literal|2
expr_stmt|;
block|}
name|sb_cmd3
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x48
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SND_CB_ABORT
case|:
comment|/* XXX */
case|case
name|SND_CB_STOP
case|:
block|{
name|int
name|cmd
init|=
name|DSP_CMD_DMAPAUSE_8
decl_stmt|;
comment|/* default: halt 8 bit chan */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"SND_CB_XXX: reason 0x%x\n"
argument_list|,
name|reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|chan
operator|>
literal|4
operator|||
operator|(
name|rd
operator|&&
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_S16_LE
operator|)
operator|||
operator|(
operator|!
name|rd
operator|&&
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
operator|)
condition|)
name|cmd
operator|=
name|DSP_CMD_DMAPAUSE_16
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_HISPEED
condition|)
block|{
name|sb_reset_dsp
argument_list|(
name|d
operator|->
name|io_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_ESS
condition|)
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xc6
argument_list|)
expr_stmt|;
comment|/* enable extended ESS mode */
name|d
operator|->
name|flags
operator||=
name|SND_F_INIT
expr_stmt|;
block|}
else|else
block|{
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* pause dma. */
comment|/* 		* The above seems to have the undocumented side effect of 		* blocking the other side as well. If the other 		* channel was active (SB16) I have to re-enable it :( 		*/
if|if
condition|(
operator|(
name|rd
operator|&&
name|d
operator|->
name|dbuf_out
operator|.
name|dl
operator|)
operator|||
operator|(
operator|!
name|rd
operator|&&
name|d
operator|->
name|dbuf_in
operator|.
name|dl
operator|)
condition|)
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|cmd
operator|==
name|DSP_CMD_DMAPAUSE_8
condition|?
literal|0xd6
else|:
literal|0xd4
argument_list|)
expr_stmt|;
comment|/* continue other dma */
block|}
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16X
condition|)
block|{
comment|/* restore possible swapped channels.                  * The default is to be ready for play. 		 * XXX right now, it kills all input on overflow                  */
if|if
condition|(
name|rd
operator|&&
name|d
operator|->
name|dbuf_out
operator|.
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* must swap channels ? */
name|int
name|c
init|=
name|d
operator|->
name|dbuf_in
operator|.
name|chan
decl_stmt|;
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|chan
expr_stmt|;
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|=
name|c
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|,
name|SND_CHAN_RD
argument_list|)
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|SND_CHAN_WR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"restored -- now dma %d:%d\n"
argument_list|,
name|d
operator|->
name|dbuf_out
operator|.
name|chan
argument_list|,
name|d
operator|->
name|dbuf_in
operator|.
name|chan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DEB
argument_list|(
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_SPKOFF
argument_list|)
argument_list|)
expr_stmt|;
comment|/* speaker off */
break|break ;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The second part of the file contains all functions specific to  * the board and (usually) not exported to other modules.  */
end_comment

begin_function
name|int
name|sb_reset_dsp
parameter_list|(
name|int
name|io_base
parameter_list|)
block|{
name|int
name|loopc
decl_stmt|;
name|outb
argument_list|(
name|io_base
operator|+
name|SBDSP_RST
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|io_base
operator|+
name|SBDSP_RST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|loopc
operator|=
literal|0
init|;
name|loopc
operator|<
literal|100
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
operator|)
condition|;
name|loopc
operator|++
control|)
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|DSP_READ
argument_list|)
operator|!=
literal|0xAA
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sb_reset_dsp 0x%x failed\n"
argument_list|,
name|io_base
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Sorry */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * only used in sb_attach from here.  */
end_comment

begin_function
specifier|static
name|void
name|sb_dsp_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|NULL
decl_stmt|;
name|int
name|io_base
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
name|d
operator|->
name|bd_id
operator|=
literal|0
expr_stmt|;
name|sb_reset_dsp
argument_list|(
name|io_base
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|DSP_CMD_GETVER
argument_list|)
expr_stmt|;
comment|/* Get version */
for|for
control|(
name|i
operator|=
literal|10000
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
comment|/* perhaps wait longer on a fast machine ? */
if|if
condition|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
condition|)
block|{
comment|/* wait for Data Ready */
if|if
condition|(
operator|(
name|d
operator|->
name|bd_id
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_id
operator|=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
operator|<<
literal|8
expr_stmt|;
comment|/* major */
else|else
block|{
name|d
operator|->
name|bd_id
operator||=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
expr_stmt|;
comment|/* minor */
break|break;
block|}
block|}
else|else
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
comment|/*      * now do various initializations depending on board id.      */
name|fmt
operator|=
literal|"SoundBlaster %d.%d"
expr_stmt|;
comment|/* default */
switch|switch
condition|(
name|d
operator|->
name|bd_id
operator|>>
literal|8
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"\n\nFailed to get SB version (%x) - possible I/O conflict\n\n"
argument_list|,
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_id
operator|=
literal|0x100
expr_stmt|;
case|case
literal|1
case|:
comment|/* old sound blaster has nothing... */
break|break ;
case|case
literal|2
case|:
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|chan
expr_stmt|;
comment|/* half duplex */
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_DUP_MIDI
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_id
operator|==
literal|0x200
condition|)
break|break ;
comment|/* no mixer on the 2.0 */
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_MIX_MASK
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_MIX_CT1335
expr_stmt|;
break|break ;
case|case
literal|4
case|:
name|fmt
operator|=
literal|"SoundBlaster 16 %d.%d"
expr_stmt|;
name|d
operator|->
name|audio_fmt
operator||=
name|AFMT_FULLDUPLEX
operator||
name|AFMT_WEIRD
operator||
name|AFMT_S8
operator||
name|AFMT_S16_LE
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_SB16
expr_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_MIX_MASK
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_MIX_CT1745
expr_stmt|;
comment|/* soft irq/dma configuration */
name|x
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|5
condition|)
name|x
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|7
condition|)
name|x
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|9
condition|)
name|x
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|10
condition|)
name|x
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"<%s>%d: bad irq %d (only 5,7,9,10 allowed)\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|d
operator|->
name|irq
argument_list|)
expr_stmt|;
else|else
name|sb_setmixer
argument_list|(
name|io_base
argument_list|,
name|IRQ_NR
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|==
name|d
operator|->
name|dbuf_in
operator|.
name|chan
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: sb: misconfigured secondary DMA channel\n"
argument_list|)
expr_stmt|;
block|}
name|sb_setmixer
argument_list|(
name|io_base
argument_list|,
name|DMA_NR
argument_list|,
operator|(
literal|1
operator|<<
name|d
operator|->
name|dbuf_out
operator|.
name|chan
operator|)
operator||
operator|(
literal|1
operator|<<
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|)
argument_list|)
expr_stmt|;
break|break ;
case|case
literal|3
case|:
name|d
operator|->
name|dbuf_in
operator|.
name|chan
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|chan
expr_stmt|;
comment|/* half duplex */
name|fmt
operator|=
literal|"SoundBlaster Pro %d.%d"
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_DUP_MIDI
expr_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_MIX_MASK
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_MIX_CT1345
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_id
operator|==
literal|0x301
condition|)
block|{
name|int
name|ess_major
init|=
literal|0
decl_stmt|,
name|ess_minor
init|=
literal|0
decl_stmt|;
comment|/* 	     * Try to detect ESS chips. 	     */
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|DSP_CMD_GETID
argument_list|)
expr_stmt|;
comment|/* Return ident. bytes. */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
condition|)
block|{
comment|/* wait for Data Ready */
if|if
condition|(
name|ess_major
operator|==
literal|0
condition|)
name|ess_major
operator|=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
expr_stmt|;
else|else
block|{
name|ess_minor
operator|=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ess_major
operator|==
literal|0x48
operator|&&
operator|(
name|ess_minor
operator|&
literal|0xf0
operator|)
operator|==
literal|0x80
condition|)
block|{
comment|/* the ESS488 can be treated as an SBPRO */
name|printf
argument_list|(
literal|"ESS488 (rev %d)\n"
argument_list|,
name|ess_minor
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
break|break ;
block|}
elseif|else
if|if
condition|(
name|ess_major
operator|==
literal|0x68
operator|&&
operator|(
name|ess_minor
operator|&
literal|0xf0
operator|)
operator|==
literal|0x80
condition|)
block|{
name|int
name|rev
init|=
name|ess_minor
operator|&
literal|0xf
decl_stmt|;
if|if
condition|(
name|rev
operator|>=
literal|8
condition|)
name|printf
argument_list|(
literal|"ESS1868 (rev %d)\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ESS688 (rev %d)\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_ESS
expr_stmt|;
name|d
operator|->
name|audio_fmt
operator||=
name|AFMT_S16_LE
expr_stmt|;
comment|/* enable extended ESS mode */
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xc6
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unknown card 0x%x 0x%x -- hope it is SBPRO\n"
argument_list|,
name|ess_major
argument_list|,
name|ess_minor
argument_list|)
expr_stmt|;
break|break ;
block|}
block|}
block|}
name|snprintf
argument_list|(
name|d
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|name
argument_list|)
argument_list|,
name|fmt
argument_list|,
operator|(
name|d
operator|->
name|bd_id
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|d
operator|->
name|bd_id
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sb_mix_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb_mix_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
switch|switch
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIX_MASK
condition|)
block|{
case|case
name|BD_F_MIX_CT1345
case|:
comment|/* SB 3.0 has 1345 mixer */
name|d
operator|->
name|mix_devs
operator|=
name|SBPRO_MIXER_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_rec_devs
operator|=
name|SBPRO_RECORDING_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_recsrc
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reset mixer */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|MIC_VOL
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
comment|/* mic volume max */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|RECORD_SRC
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* mic source */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|FM_VOL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* no midi */
break|break ;
case|case
name|BD_F_MIX_CT1745
case|:
comment|/* SB16 mixer ... */
name|d
operator|->
name|mix_devs
operator|=
name|SB16_MIXER_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_rec_devs
operator|=
name|SB16_RECORDING_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_recsrc
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
block|}
name|sb_mixer_reset
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common code for the midi and pcm functions  *  * sb_cmd write a single byte to the CMD port.  * sb_cmd2 write a CMD + 1 byte arg  * sb_cmd3 write a CMD + 2 byte arg  * sb_get_byte returns a single byte from the DSP data port  *  * ess_write is actually sb_cmd2  * ess_read access ext. regs via sb_cmd(0xc0, reg) followed by sb_get_byte  */
end_comment

begin_function
name|int
name|sb_cmd
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|io_base
operator|+
name|SBDSP_STATUS
argument_list|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|io_base
operator|+
name|SBDSP_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|10
condition|)
name|DELAY
argument_list|(
name|i
operator|>
literal|100
condition|?
literal|1000
else|:
literal|10
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"SoundBlaster: DSP Command(0x%02x) timeout. IRQ conflict ?\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sb_cmd3
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sb_cmd2
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * in the SB, there is a set of indirect "mixer" registers with  * address at offset 4, data at offset 5  */
end_comment

begin_function
name|void
name|sb_setmixer
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|io_base
operator|+
name|SB_MIX_ADDR
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|port
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Select register */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|io_base
operator|+
name|SB_MIX_DATA
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sb_getmixer
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|io_base
operator|+
name|SB_MIX_ADDR
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|port
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Select register */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|io_base
operator|+
name|SB_MIX_DATA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|u_int
name|sb_get_byte
parameter_list|(
name|int
name|io_base
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
condition|)
return|return
name|inb
argument_list|(
name|DSP_READ
argument_list|)
return|;
else|else
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
return|return
literal|0xffff
return|;
block|}
end_function

begin_function
name|int
name|ess_write
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
return|return
name|sb_cmd2
argument_list|(
name|io_base
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ess_read
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|reg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
literal|0xc0
argument_list|)
operator|||
operator|!
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|reg
argument_list|)
condition|)
return|return
literal|0xffff
return|;
return|return
name|sb_get_byte
argument_list|(
name|io_base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * various utility functions for the DSP  */
end_comment

begin_comment
comment|/*  * dsp_speed updates the speed setting from the descriptor. make sure  * it is called at spltty().  * Besides, it takes care of stereo setting.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_speed
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|u_char
name|tconst
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|int
name|max_speed
init|=
literal|44100
decl_stmt|,
name|speed
init|=
name|d
operator|->
name|play_speed
decl_stmt|;
comment|/*      * special code for the SB16      */
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|5000
argument_list|,
literal|45000
argument_list|)
expr_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|speed
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|play_speed
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|play_speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|rec_speed
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|rec_speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|speed
return|;
block|}
comment|/*      * special code for the ESS ...      */
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_ESS
condition|)
block|{
name|int
name|t
decl_stmt|;
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|5000
argument_list|,
literal|49000
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|22000
condition|)
block|{
name|t
operator|=
operator|(
literal|795500
operator|+
name|speed
operator|/
literal|2
operator|)
operator|/
name|speed
expr_stmt|;
name|speed
operator|=
operator|(
literal|795500
operator|+
name|t
operator|/
literal|2
operator|)
operator|/
name|t
expr_stmt|;
name|t
operator|=
operator|(
literal|256
operator|-
name|t
operator|)
operator||
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
literal|397700
operator|+
name|speed
operator|/
literal|2
operator|)
operator|/
name|speed
expr_stmt|;
name|speed
operator|=
operator|(
literal|397700
operator|+
name|t
operator|/
literal|2
operator|)
operator|/
name|t
expr_stmt|;
name|t
operator|=
literal|128
operator|-
name|t
expr_stmt|;
block|}
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xa1
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* set time constant */
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|speed
expr_stmt|;
name|speed
operator|=
operator|(
name|speed
operator|*
literal|9
operator|)
operator|/
literal|20
expr_stmt|;
name|t
operator|=
literal|256
operator|-
literal|7160000
operator|/
operator|(
name|speed
operator|*
literal|82
operator|)
expr_stmt|;
name|ess_write
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0xa2
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|speed
return|;
block|}
comment|/*      * This is code for the SB3.x and lower.      * Only some models can do stereo, and only if not      * simultaneously using midi.      * At the moment we do not support either...      */
if|#
directive|if
literal|0
block|d->flags&= ~SND_F_STEREO;
endif|#
directive|endif
comment|/*      * here enforce speed limitations.      */
if|if
condition|(
name|d
operator|->
name|bd_id
operator|<=
literal|0x200
condition|)
name|max_speed
operator|=
literal|22050
expr_stmt|;
comment|/* max 22050 on SB 1.X */
comment|/*      * SB models earlier than SB Pro have low limit for the      * input rate. Note that this is only for input, but since      * we do not support separate values for rec& play....      */
if|if
condition|(
name|d
operator|->
name|bd_id
operator|<=
literal|0x200
condition|)
name|max_speed
operator|=
literal|13000
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_id
operator|<
literal|0x300
condition|)
name|max_speed
operator|=
literal|15000
expr_stmt|;
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|4000
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
comment|/* really unused right now... */
name|speed
operator|*=
literal|2
expr_stmt|;
comment|/*      * Now the speed should be valid. Compute the value to be      * programmed into the board.      */
if|if
condition|(
name|speed
operator|>
literal|22050
condition|)
block|{
comment|/* High speed mode on 2.01/3.xx */
name|int
name|tmp
decl_stmt|;
name|tconst
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
literal|65536
operator|-
operator|(
operator|(
literal|256000000
operator|+
name|speed
operator|/
literal|2
operator|)
operator|/
name|speed
operator|)
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_HISPEED
expr_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sb_cmd2
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x40
argument_list|,
name|tconst
argument_list|)
expr_stmt|;
comment|/* set time constant */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|65536
operator|-
operator|(
name|tconst
operator|<<
literal|8
operator|)
expr_stmt|;
name|speed
operator|=
operator|(
literal|256000000
operator|+
name|tmp
operator|/
literal|2
operator|)
operator|/
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmp
decl_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_HISPEED
expr_stmt|;
name|tconst
operator|=
operator|(
literal|256
operator|-
operator|(
operator|(
literal|1000000
operator|+
name|speed
operator|/
literal|2
operator|)
operator|/
name|speed
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sb_cmd2
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x40
argument_list|,
name|tconst
argument_list|)
expr_stmt|;
comment|/* set time constant */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|256
operator|-
name|tconst
expr_stmt|;
name|speed
operator|=
operator|(
literal|1000000
operator|+
name|tmp
operator|/
literal|2
operator|)
operator|/
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
comment|/* really unused right now... */
name|speed
operator|/=
literal|2
expr_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
end_function

begin_comment
comment|/*  * mixer support, originally in sb_mixer.c  */
end_comment

begin_function
specifier|static
name|void
name|sb_set_recsrc
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|u_char
name|recdev
decl_stmt|;
name|mask
operator|&=
name|d
operator|->
name|mix_rec_devs
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIX_MASK
condition|)
block|{
case|case
name|BD_F_MIX_CT1345
case|:
if|if
condition|(
name|mask
operator|==
name|SOUND_MASK_LINE
condition|)
name|recdev
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|==
name|SOUND_MASK_CD
condition|)
name|recdev
operator|=
literal|2
expr_stmt|;
else|else
block|{
comment|/* default: mic */
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
name|recdev
operator|=
literal|0
expr_stmt|;
block|}
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|RECORD_SRC
argument_list|,
name|recdev
operator||
operator|(
name|sb_getmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|RECORD_SRC
argument_list|)
operator|&
operator|~
literal|7
operator|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|BD_F_MIX_CT1745
case|:
comment|/* sb16 */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
comment|/* XXX For compatibility. Bug ? */
name|recdev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_MIC
condition|)
name|recdev
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_CD
condition|)
name|recdev
operator||=
literal|6
expr_stmt|;
comment|/* l+r cd */
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_LINE
condition|)
name|recdev
operator||=
literal|0x18
expr_stmt|;
comment|/* l+r line */
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_SYNTH
condition|)
name|recdev
operator||=
literal|0x60
expr_stmt|;
comment|/* l+r midi */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|SB16_IMASK_L
argument_list|,
name|recdev
argument_list|)
expr_stmt|;
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|SB16_IMASK_R
argument_list|,
name|recdev
argument_list|)
expr_stmt|;
comment|/* 	 * since the same volume controls apply to the input and 	 * output sections, the best approach to have a consistent 	 * behaviour among cards would be to disable the output path 	 * on devices which are used to record. 	 * However, since users like to have feedback, we only disable 	 * the mike -- permanently. 	 */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|SB16_OMASK
argument_list|,
literal|0x1f
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
break|break ;
block|}
name|d
operator|->
name|mix_recsrc
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb_mixer_reset
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
name|sb_mixer_set
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
name|levels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x3c
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
comment|/* make all output active */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x3d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make all inputs-l off */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x3e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make all inputs-r off */
block|}
name|sb_set_recsrc
argument_list|(
name|d
argument_list|,
name|SOUND_MASK_MIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_mixer_set
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|left
init|=
name|value
operator|&
literal|0x000000ff
decl_stmt|;
name|int
name|right
init|=
operator|(
name|value
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
decl_stmt|;
name|int
name|regoffs
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|mixer_tab
modifier|*
name|iomap
decl_stmt|;
ifdef|#
directive|ifdef
name|JAZZ16
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16
operator|&&
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16_2
condition|)
return|return
name|smw_mixer_set
argument_list|(
name|dev
argument_list|,
name|value
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_RECSRC
condition|)
block|{
name|sb_set_recsrc
argument_list|(
name|d
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|left
operator|>
literal|100
condition|)
name|left
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|right
operator|>
literal|100
condition|)
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|dev
operator|>
literal|31
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|mix_devs
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
comment|/* Not supported */
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIX_MASK
condition|)
block|{
default|default:
comment|/* mixer unknown, fail... */
return|return
name|EINVAL
return|;
comment|/* XXX change this */
case|case
name|BD_F_MIX_CT1345
case|:
name|iomap
operator|=
operator|&
name|sbpro_mix
expr_stmt|;
break|break;
case|case
name|BD_F_MIX_CT1745
case|:
name|iomap
operator|=
operator|&
name|sb16_mix
expr_stmt|;
break|break;
comment|/* XXX how about the SG NX Pro, iomap = sgnxpro_mix */
block|}
name|regoffs
operator|=
operator|(
operator|*
name|iomap
operator|)
index|[
name|dev
index|]
index|[
name|LEFT_CHN
index|]
operator|.
name|regno
expr_stmt|;
if|if
condition|(
name|regoffs
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|val
operator|=
name|sb_getmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|)
expr_stmt|;
name|change_bits
argument_list|(
name|iomap
argument_list|,
operator|&
name|val
argument_list|,
name|dev
argument_list|,
name|LEFT_CHN
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|d
operator|->
name|mix_levels
index|[
name|dev
index|]
operator|=
name|left
operator||
operator|(
name|left
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|iomap
operator|)
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|regno
operator|!=
name|regoffs
condition|)
block|{
comment|/* Change register */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Save the old one */
name|regoffs
operator|=
operator|(
operator|*
name|iomap
operator|)
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|regno
expr_stmt|;
if|if
condition|(
name|regoffs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Just left channel present */
name|val
operator|=
name|sb_getmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|)
expr_stmt|;
comment|/* Read the new one */
block|}
name|change_bits
argument_list|(
name|iomap
argument_list|,
operator|&
name|val
argument_list|,
name|dev
argument_list|,
name|RIGHT_CHN
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|d
operator|->
name|mix_levels
index|[
name|dev
index|]
operator|=
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* ok */
block|}
end_function

begin_comment
comment|/*  * now support for some PnP boards.  */
end_comment

begin_if
if|#
directive|if
name|NPNP
operator|>
literal|0
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|ess1868_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ess1868_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|pnp_device
name|ess1868
init|=
block|{
literal|"ESS1868"
block|,
name|ess1868_probe
block|,
name|ess1868_attach
block|,
operator|&
name|nsnd
block|,
comment|/* use this for all sound cards */
operator|&
name|tty_imask
comment|/* imask */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pnpdevice_set
argument_list|,
name|ess1868
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|ess1868_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
block|{
comment|/*      * pnp X 1 os enable drq0 3 irq0 12 port0 0x240      */
if|if
condition|(
name|vend_id
operator|==
literal|0x68187316
condition|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"This is an ESS1868, but LDN 1 is disabled\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
literal|"ESS1868"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ess1868_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|snddev_info
name|tmp_d
decl_stmt|;
comment|/* patched copy of the basic snddev_info */
name|tmp_d
operator|=
name|sb_op_desc
expr_stmt|;
name|snddev_last_probed
operator|=
operator|&
name|tmp_d
expr_stmt|;
if|#
directive|if
literal|0
block|read_pnp_parms (&d , 3 );
comment|/* disable LDN 3 */
block|d.port[0] = 0 ;     d.enable = 0 ;     write_pnp_parms (&d , 3 );          read_pnp_parms (&d , 2 );
comment|/* disable LDN 2 */
block|d.port[0] = 0 ;     d.enable = 0 ;     write_pnp_parms (&d , 2 );     read_pnp_parms (&d , 0 );
comment|/* read config base */
block|tmp_d.conf_base = d.port[0];     write_pnp_parms (&d , 0 );
endif|#
directive|endif
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|id_iobase
operator|=
name|d
operator|.
name|port
index|[
literal|0
index|]
expr_stmt|;
name|d
operator|.
name|port
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|port
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|enable_pnp_card
argument_list|()
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|d
operator|.
name|drq
index|[
literal|0
index|]
expr_stmt|;
comment|/* primary dma */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|d
operator|.
name|irq
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dev
operator|->
name|id_intr
operator|=
operator|(
name|inthand2_t
operator|*
operator|)
name|pcmintr
expr_stmt|;
name|dev
operator|->
name|id_flags
operator|=
literal|0
comment|/* DV_F_DUAL_DMA | (d.drq[1] ) */
expr_stmt|;
if|#
directive|if
literal|0
block|snddev_last_probed->probe(dev);
comment|/* not really necessary but doesn't harm */
endif|#
directive|endif
name|pcmattach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A driver for some SB16pnp and compatibles...  *  * Avance Asound 100               -- 0x01009305  * Avance Logic ALS100+            -- 0x10019305  * Avance Logic ASound Gold ALS120 -- 0x20019305  * xxx                             -- 0x2b008c0e  *  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|sb16pnp_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sb16pnp_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|pnp_device
name|sb16pnp
init|=
block|{
literal|"SB16pnp"
block|,
name|sb16pnp_probe
block|,
name|sb16pnp_attach
block|,
operator|&
name|nsnd
block|,
comment|/* use this for all sound cards */
operator|&
name|tty_imask
comment|/* imask */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pnpdevice_set
argument_list|,
name|sb16pnp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|sb16pnp_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
comment|/*      * The SB16/AWExx cards seem to differ in the fourth byte of      * the vendor id, so I have just masked it for the time being...      * Reported values are:      * SB16 Value PnP:	0x2b008c0e      * SB AWExx PnP:	0x39008c0e 0x9d008c0e 0xc3008c0e      * Vibra16X:        0xf0008c0e      */
if|if
condition|(
name|vend_id
operator|==
literal|0xf0008c0e
condition|)
name|s
operator|=
literal|"Vibra16X"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vend_id
operator|&
literal|0xffffff
operator|)
operator|==
operator|(
literal|0x9d008c0e
operator|&
literal|0xffffff
operator|)
condition|)
name|s
operator|=
literal|"SB16 PnP"
expr_stmt|;
elseif|else
if|if
condition|(
name|vend_id
operator|==
literal|0x01009305
condition|)
name|s
operator|=
literal|"Avance Asound 100"
expr_stmt|;
elseif|else
if|if
condition|(
name|vend_id
operator|==
literal|0x10019305
condition|)
name|s
operator|=
literal|"Avance Logic 100+"
expr_stmt|;
comment|/* Vibra16X-class */
elseif|else
if|if
condition|(
name|vend_id
operator|==
literal|0x20019305
condition|)
name|s
operator|=
literal|"Avance Logic ALS120"
expr_stmt|;
comment|/* Vibra16X-class */
if|if
condition|(
name|s
condition|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"This is a %s, but LDN 0 is disabled\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb16pnp_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|snddev_info
name|tmp_d
decl_stmt|;
comment|/* patched copy of the basic snddev_info */
name|tmp_d
operator|=
name|sb_op_desc
expr_stmt|;
name|snddev_last_probed
operator|=
operator|&
name|tmp_d
expr_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|.
name|port
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* only the first address is used */
name|dev
operator|->
name|id_iobase
operator|=
name|d
operator|.
name|port
index|[
literal|0
index|]
expr_stmt|;
name|tmp_d
operator|.
name|synth_base
operator|=
name|d
operator|.
name|port
index|[
literal|2
index|]
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enable_pnp_card
argument_list|()
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|d
operator|.
name|drq
index|[
literal|0
index|]
expr_stmt|;
comment|/* primary dma */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|d
operator|.
name|irq
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dev
operator|->
name|id_intr
operator|=
operator|(
name|inthand2_t
operator|*
operator|)
name|pcmintr
expr_stmt|;
name|dev
operator|->
name|id_flags
operator|=
name|DV_F_DUAL_DMA
operator||
operator|(
name|d
operator|.
name|drq
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|tmp_d
expr_stmt|;
comment|/* pcm_info[] will be reinitialized after */
name|snddev_last_probed
operator|->
name|probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* not really necessary but doesn't harm */
if|if
condition|(
name|vend_id
operator|==
literal|0x10019305
operator|||
name|vend_id
operator|==
literal|0xf0008c0e
operator|||
name|vend_id
operator|==
literal|0x20019305
condition|)
block|{
comment|/* 	 * XXX please add here the vend_id for other vibra16X cards... 	 * And remember, must change tmp_d, not  	 */
name|tmp_d
operator|.
name|bd_flags
operator||=
name|BD_F_SB16X
expr_stmt|;
block|}
name|pcmattach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPNP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

