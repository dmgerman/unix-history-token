begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/sb_dsp.c  *   * driver for the SoundBlaster and clones.  *   * Copyright 1997 Luigi Rizzo.  *  * Derived from files in the Voxware 3.5 distribution,  * Copyright by Hannu Savolainen 1994, under the same copyright  * conditions.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met: 1. Redistributions of source code must retain the above  * copyright notice, this list of conditions and the following  * disclaimer. 2.  Redistributions in binary form must reproduce the  * above copyright notice, this list of conditions and the following  * disclaimer in the documentation and/or other materials provided  * with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *   */
end_comment

begin_comment
comment|/*  * use this as a template file for board-specific drivers.  * The next two lines (and the final #endif) are in all drivers:  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sound.h>
end_include

begin_if
if|#
directive|if
name|NPCM
operator|>
literal|0
end_if

begin_comment
comment|/*  * Begin with the board-specific include files...  */
end_comment

begin_define
define|#
directive|define
name|__SB_MIXER_C__
end_define

begin_comment
comment|/* XXX warning... */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sbcard.h>
end_include

begin_comment
comment|/*  * then prototypes of functions which go in the snddev_info  * (usually static, unless they are shared by other modules)...  */
end_comment

begin_function_decl
specifier|static
name|int
name|sb_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sb_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|sb_dsp_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sb_dsp_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sb_dsp_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|irq_proc_t
name|sbintr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|snd_callback_t
name|sb_callback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * and prototypes for other private functions defined in this module.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sb_dsp_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sb_mix_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sb_mixer_set
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dsp_speed
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sb_mixer_reset
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int
name|sb_get_byte
parameter_list|(
name|int
name|io_base
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Then put here the descriptors for the various boards supported  * by this module, properly initialized.  */
end_comment

begin_decl_stmt
name|snddev_info
name|sb_op_desc
init|=
block|{
literal|"basic soundblaster"
block|,
name|SNDCARD_SB
block|,
name|sb_probe
block|,
name|sb_attach
block|,
name|sb_dsp_open
block|,
name|sb_dsp_close
comment|/* sb_close */
block|,
name|NULL
comment|/* use generic sndread */
block|,
name|NULL
comment|/* use generic sndwrite */
block|,
name|sb_dsp_ioctl
block|,
name|sndpoll
block|,
name|sbintr
block|,
name|sb_callback
block|,
name|DSP_BUFFSIZE
block|,
comment|/* bufsize */
name|AFMT_STEREO
operator||
name|AFMT_U8
block|,
comment|/* audio format */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Then the file continues with the body of all functions  * directly referenced in the descriptor.  */
end_comment

begin_comment
comment|/*  * the probe routine for the SoundBlaster only consists in  * resetting the dsp and testing if it is there.  * Version detection etc. will be done at attach time.  *  * Remebber, isa probe routines are supposed to return the  * size of io space used.  */
end_comment

begin_function
specifier|static
name|int
name|sb_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_iobase
operator|==
operator|-
literal|1
condition|)
block|{
name|dev
operator|->
name|id_iobase
operator|=
literal|0x220
expr_stmt|;
name|printf
argument_list|(
literal|"sb_probe: no address supplied, try defaults (0x220,0x240)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|snd_conflict
argument_list|(
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
name|dev
operator|->
name|id_iobase
operator|=
literal|0x240
expr_stmt|;
block|}
if|if
condition|(
name|snd_conflict
argument_list|(
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sb_reset_dsp
argument_list|(
name|dev
operator|->
name|id_iobase
argument_list|)
condition|)
return|return
literal|16
return|;
comment|/* the SB uses 16 registers... */
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
init|=
operator|&
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|sb_dsp_init
argument_list|(
name|d
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * here are the main routines from the switches.  */
end_comment

begin_function
specifier|static
name|int
name|sb_dsp_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|unit
index|]
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"<%s>%d : open\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_BUSY
condition|)
block|{
name|printf
argument_list|(
literal|"<%s>%d open: device busy\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|d
operator|->
name|wsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|wsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|esel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|esel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_HISPEED
expr_stmt|;
switch|switch
condition|(
name|dev
operator|&
literal|0xf
condition|)
block|{
case|case
name|SND_DEV_DSP16
case|:
if|if
condition|(
operator|(
name|d
operator|->
name|audio_fmt
operator|&
name|AFMT_S16_LE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sorry, 16-bit not supported on SB %d.%02d\n"
argument_list|,
operator|(
name|d
operator|->
name|bd_id
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|d
operator|->
name|bd_id
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_S16_LE
expr_stmt|;
break|break;
case|case
name|SND_DEV_AUDIO
case|:
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
break|break ;
case|case
name|SND_DEV_DSP
case|:
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_U8
expr_stmt|;
break|break ;
block|}
name|d
operator|->
name|flags
operator||=
name|SND_F_BUSY
expr_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|DSP_DEFAULT_SPEED
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_NBIO
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|)
expr_stmt|;
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|)
expr_stmt|;
name|sb_reset_dsp
argument_list|(
name|d
operator|->
name|io_base
argument_list|)
expr_stmt|;
name|ask_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_dsp_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_CLOSING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|snd_flush
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_SPKOFF
argument_list|)
expr_stmt|;
comment|/* XXX useless ? */
name|d
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_dsp_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|unit
index|]
expr_stmt|;
comment|/*      * handle mixer calls first. Reads are in the default handler,      * so do not bother about them.      */
if|if
condition|(
operator|(
name|cmd
operator|&
name|MIXER_WRITE
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|MIXER_WRITE
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|sb_mixer_set
argument_list|(
name|d
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
return|;
comment|/*      * for the remaining functions, use the default handler.      */
return|return
name|ENOSYS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
init|=
operator|&
name|pcm_info
index|[
name|unit
index|]
decl_stmt|;
name|int
name|reason
init|=
literal|3
decl_stmt|,
name|c
init|=
literal|1
decl_stmt|,
name|io_base
init|=
name|d
operator|->
name|io_base
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"got sbintr for unit %d, flags 0x%08lx\n"
argument_list|,
name|unit
argument_list|,
name|d
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * SB< 4.0 is half duplex and has only 1 bit for int source,      * so we fake it. SB 4.x (SB16) has the int source in a separate      * register.      */
name|again
label|:
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|c
operator|=
name|sb_getmixer
argument_list|(
name|io_base
argument_list|,
name|IRQ_STAT
argument_list|)
expr_stmt|;
comment|/* this tells us if the source is 8-bit or 16-bit dma. We 	 * have to check the io channel to map it to read or write... 	 */
name|reason
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|1
condition|)
block|{
comment|/* 8-bit dma */
if|if
condition|(
name|d
operator|->
name|dma1
operator|<
literal|4
condition|)
name|reason
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dma2
operator|<
literal|4
condition|)
name|reason
operator||=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&
literal|2
condition|)
block|{
comment|/* 16-bit dma */
if|if
condition|(
name|d
operator|->
name|dma1
operator|>=
literal|4
condition|)
name|reason
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dma2
operator|>=
literal|4
condition|)
name|reason
operator||=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|&
literal|2
condition|)
name|inb
argument_list|(
name|DSP_DATA_AVL16
argument_list|)
expr_stmt|;
comment|/* 16-bit int ack */
if|if
condition|(
name|c
operator|&
literal|1
condition|)
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
expr_stmt|;
comment|/* 8-bit int ack */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sbintr, flags 0x%08lx reason %d\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|,
name|reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
operator|)
operator|&&
operator|(
name|reason
operator|&
literal|1
operator|)
condition|)
name|dsp_wrintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_RD_DMA
operator|)
operator|&&
operator|(
name|reason
operator|&
literal|2
operator|)
condition|)
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/*      * the sb16 might have multiple sources etc.      */
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
operator|&&
operator|(
name|c
operator|&
literal|3
operator|)
condition|)
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * device-specific function called back from the dma module.  * The reason of the callback is the second argument.  * NOTE: during operations, some ioctl can be done to change  * settings (e.g. speed, channels, format), and the default  * ioctl handler will just record the change and set the  * flag SND_F_INIT. The callback routine is in charge of applying  * the changes at the next convenient time (typically, at the  * start of operations). For full duplex devices, in some cases the  * init requires both channels to be idle.  */
end_comment

begin_function
specifier|static
name|int
name|sb_callback
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|int
name|rd
init|=
name|reason
operator|&
name|SND_CB_RD
decl_stmt|;
name|int
name|l
init|=
operator|(
name|rd
operator|)
condition|?
name|d
operator|->
name|dbuf_in
operator|.
name|dl0
else|:
name|d
operator|->
name|dbuf_out
operator|.
name|dl0
decl_stmt|;
switch|switch
condition|(
name|reason
operator|&
name|SND_CB_REASON_MASK
condition|)
block|{
case|case
name|SND_CB_INIT
case|:
comment|/* called with int enabled and no pending io */
name|dsp_speed
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|snd_set_blocksize
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|&
name|AFMT_MU_LAW
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_XLAT8
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_XLAT8
expr_stmt|;
return|return
literal|1
return|;
break|break ;
case|case
name|SND_CB_START
case|:
comment|/* called with int disabled */
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|rd
condition|?
name|DSP_CMD_SPKOFF
else|:
name|DSP_CMD_SPKON
argument_list|)
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_INIT
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
comment|/* the SB16 can do full duplex using one 16-bit channel 	     * and one 8-bit channel. It needs to be programmed to 	     * use split format though. 	     */
name|int
name|b16
decl_stmt|;
name|int
name|swap
init|=
literal|0
decl_stmt|;
name|b16
operator|=
operator|(
name|rd
operator|)
condition|?
name|d
operator|->
name|rec_fmt
else|:
name|d
operator|->
name|play_fmt
expr_stmt|;
name|b16
operator|=
operator|(
name|b16
operator|==
name|AFMT_S16_LE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	     * check if I have to swap dma channels. Swap if 	     * - !rd, dma1<4,  b16 	     * - !rd, dma1>=4, !b16 	     * - rd,  dma2<4,  b16 	     * - rd,  dma2>=4, !b16 	     */
if|if
condition|(
operator|!
name|rd
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|dma1
operator|<
literal|4
operator|&&
name|b16
operator|)
operator|||
operator|(
name|d
operator|->
name|dma1
operator|>=
literal|4
operator|&&
operator|!
name|b16
operator|)
condition|)
name|swap
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|d
operator|->
name|dma2
operator|<
literal|4
operator|&&
name|b16
operator|)
operator|||
operator|(
name|d
operator|->
name|dma2
operator|>=
literal|4
operator|&&
operator|!
name|b16
operator|)
condition|)
name|swap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	     * before swapping should make sure that there is no 	     * pending DMA on the other channel... 	     */
if|if
condition|(
name|swap
condition|)
block|{
name|int
name|c
init|=
name|d
operator|->
name|dma2
decl_stmt|;
name|d
operator|->
name|dma2
operator|=
name|d
operator|->
name|dma1
expr_stmt|;
name|d
operator|->
name|dma1
operator|=
name|c
expr_stmt|;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sb_init: play %ld rec %ld dma1 %d dma2 %d\n"
argument_list|,
name|d
operator|->
name|play_fmt
argument_list|,
name|d
operator|->
name|rec_fmt
argument_list|,
name|d
operator|->
name|dma1
argument_list|,
name|d
operator|->
name|dma2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* fallthrough */
case|case
name|SND_CB_RESTART
case|:
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|u_char
name|c
decl_stmt|,
name|c1
decl_stmt|;
comment|/* 	     * SB16 support still not completely working!!! 	     * 	     * in principle, on the SB16, I could support simultaneous 	     * play& rec. 	     * However, there is no way to ask explicitly for 8 or 	     * 16 bit transfer. As a consequence, if we do 8-bit, 	     * we need to use the 8-bit channel, and if we do 16-bit, 	     * we need to use the other one. The only way I find to 	     * do this is to swap d->dma1 and d->dma2 ... 	     * 	     */
if|if
condition|(
name|rd
condition|)
block|{
name|c
operator|=
operator|(
operator|(
name|d
operator|->
name|dma2
operator|>
literal|3
operator|)
condition|?
name|DSP_DMA16
else|:
name|DSP_DMA8
operator|)
operator||
name|DSP_F16_FIFO_ON
operator||
name|DSP_F16_ADC
expr_stmt|;
name|c1
operator|=
operator|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_U8
operator|)
condition|?
literal|0
else|:
name|DSP_F16_SIGNED
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_MU_LAW
condition|)
name|c1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_S16_LE
condition|)
name|l
operator|/=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|(
operator|(
name|d
operator|->
name|dma1
operator|>
literal|3
operator|)
condition|?
name|DSP_DMA16
else|:
name|DSP_DMA8
operator|)
operator||
name|DSP_F16_FIFO_ON
operator||
name|DSP_F16_DAC
expr_stmt|;
name|c1
operator|=
operator|(
name|d
operator|->
name|rec_fmt
operator|==
name|AFMT_U8
operator|)
condition|?
literal|0
else|:
name|DSP_F16_SIGNED
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_MU_LAW
condition|)
name|c1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
condition|)
name|l
operator|/=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|c1
operator||=
name|DSP_F16_STEREO
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sb_cmd3
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|c1
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_char
name|c
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_HISPEED
condition|)
name|c
operator|=
operator|(
name|rd
operator|)
condition|?
name|DSP_CMD_HSADC
else|:
name|DSP_CMD_HSDAC
expr_stmt|;
else|else
name|c
operator|=
operator|(
name|rd
operator|)
condition|?
name|DSP_CMD_ADC8
else|:
name|DSP_CMD_DAC8
expr_stmt|;
name|sb_cmd3
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|c
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SND_CB_STOP
case|:
comment|/* XXX ??? sb_cmd(d->io_base, DSP_CMD_SPKOFF);*/
comment|/* speaker off */
break|break ;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The second part of the file contains all functions specific to  * the board and (usually) not exported to other modules.  */
end_comment

begin_function
name|int
name|sb_reset_dsp
parameter_list|(
name|int
name|io_base
parameter_list|)
block|{
name|int
name|loopc
decl_stmt|;
name|outb
argument_list|(
name|DSP_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DSP_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|loopc
operator|=
literal|0
init|;
name|loopc
operator|<
literal|100
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
operator|)
condition|;
name|loopc
operator|++
control|)
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|DSP_READ
argument_list|)
operator|!=
literal|0xAA
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sb_reset_dsp failed\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Sorry */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * only used in sb_attach from here.  */
end_comment

begin_function
specifier|static
name|void
name|sb_dsp_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|NULL
decl_stmt|;
name|int
name|io_base
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
name|d
operator|->
name|bd_id
operator|=
literal|0
expr_stmt|;
name|sb_reset_dsp
argument_list|(
name|io_base
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|DSP_CMD_GETVER
argument_list|)
expr_stmt|;
comment|/* Get version */
for|for
control|(
name|i
operator|=
literal|10000
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
comment|/* perhaps wait longer on a fast machine ? */
if|if
condition|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
condition|)
block|{
comment|/* wait for Data Ready */
if|if
condition|(
operator|(
name|d
operator|->
name|bd_id
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_id
operator|=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
operator|<<
literal|8
expr_stmt|;
comment|/* major */
else|else
block|{
name|d
operator|->
name|bd_id
operator||=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
expr_stmt|;
comment|/* minor */
break|break;
block|}
block|}
else|else
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
comment|/*      * now do various initializations depending on board id.      */
name|fmt
operator|=
literal|"SoundBlaster %d.%d"
expr_stmt|;
comment|/* default */
switch|switch
condition|(
name|d
operator|->
name|bd_id
operator|>>
literal|8
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"\n\nFailed to get SB version (%x) - possible I/O conflict\n\n"
argument_list|,
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_id
operator|=
literal|0x100
expr_stmt|;
case|case
literal|1
case|:
comment|/* old sound blaster has nothing... */
break|break ;
case|case
literal|2
case|:
name|d
operator|->
name|dma2
operator|=
name|d
operator|->
name|dma1
expr_stmt|;
comment|/* half duplex */
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_DUP_MIDI
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_id
operator|==
literal|0x200
condition|)
break|break ;
comment|/* no mixer on the 2.0 */
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_MIX_MASK
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_MIX_CT1335
expr_stmt|;
break|break ;
case|case
literal|4
case|:
name|fmt
operator|=
literal|"SoundBlaster 16 %d.%d"
expr_stmt|;
name|d
operator|->
name|audio_fmt
operator||=
name|AFMT_FULLDUPLEX
operator||
name|AFMT_WEIRD
operator||
name|AFMT_S8
operator||
name|AFMT_S16_LE
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_SB16
expr_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_MIX_MASK
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_MIX_CT1745
expr_stmt|;
comment|/* soft irq/dma configuration */
name|x
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|5
condition|)
name|x
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|7
condition|)
name|x
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|9
condition|)
name|x
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|irq
operator|==
literal|10
condition|)
name|x
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"<%s>%d: bad irq %d (only 5,7,9,10 allowed)\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|d
operator|->
name|irq
argument_list|)
expr_stmt|;
else|else
name|sb_setmixer
argument_list|(
name|io_base
argument_list|,
name|IRQ_NR
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sb_setmixer
argument_list|(
name|io_base
argument_list|,
name|DMA_NR
argument_list|,
operator|(
literal|1
operator|<<
name|d
operator|->
name|dma1
operator|)
operator||
operator|(
literal|1
operator|<<
name|d
operator|->
name|dma2
operator|)
argument_list|)
expr_stmt|;
break|break ;
case|case
literal|3
case|:
name|d
operator|->
name|dma2
operator|=
name|d
operator|->
name|dma1
expr_stmt|;
comment|/* half duplex */
name|fmt
operator|=
literal|"SoundBlaster Pro %d.%d"
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_DUP_MIDI
expr_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_MIX_MASK
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_MIX_CT1345
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_id
operator|==
literal|0x301
condition|)
block|{
name|int
name|ess_major
init|=
literal|0
decl_stmt|,
name|ess_minor
init|=
literal|0
decl_stmt|;
comment|/* 	     * Try to detect ESS chips. 	     */
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|DSP_CMD_GETID
argument_list|)
expr_stmt|;
comment|/* Return ident. bytes. */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
condition|)
block|{
comment|/* wait for Data Ready */
if|if
condition|(
name|ess_major
operator|==
literal|0
condition|)
name|ess_major
operator|=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
expr_stmt|;
else|else
block|{
name|ess_minor
operator|=
name|inb
argument_list|(
name|DSP_READ
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ess_major
operator|==
literal|0x48
operator|&&
operator|(
name|ess_minor
operator|&
literal|0xf0
operator|)
operator|==
literal|0x80
condition|)
name|printf
argument_list|(
literal|"Hmm... Could this be an ESS488 based card (rev %d)\n"
argument_list|,
name|ess_minor
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ess_major
operator|==
literal|0x68
operator|&&
operator|(
name|ess_minor
operator|&
literal|0xf0
operator|)
operator|==
literal|0x80
condition|)
name|printf
argument_list|(
literal|"Hmm... Could this be an ESS688 based card (rev %d)\n"
argument_list|,
name|ess_minor
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16_2
condition|)
name|fmt
operator|=
literal|"SoundMan Wave %d.%d"
expr_stmt|;
else|else
name|fmt
operator|=
literal|"MV Jazz16 %d.%d"
expr_stmt|;
name|d
operator|->
name|audio_fmt
operator||=
name|AFMT_S16_LE
expr_stmt|;
comment|/* 16 bits */
block|}
block|}
name|sprintf
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|fmt
argument_list|,
operator|(
name|d
operator|->
name|bd_id
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|d
operator|->
name|bd_id
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sb_mix_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb_mix_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
switch|switch
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIX_MASK
condition|)
block|{
case|case
name|BD_F_MIX_CT1345
case|:
comment|/* SB 3.0 has 1345 mixer */
name|d
operator|->
name|mix_devs
operator|=
name|SBPRO_MIXER_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_rec_devs
operator|=
name|SBPRO_RECORDING_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_recsrc
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reset mixer */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|MIC_VOL
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
comment|/* mic volume max */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|RECORD_SRC
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* mic source */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|FM_VOL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* no midi */
break|break ;
case|case
name|BD_F_MIX_CT1745
case|:
comment|/* SB16 mixer ... */
name|d
operator|->
name|mix_devs
operator|=
name|SB16_MIXER_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_rec_devs
operator|=
name|SB16_RECORDING_DEVICES
expr_stmt|;
name|d
operator|->
name|mix_recsrc
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
block|}
name|sb_mixer_reset
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common code for the midi and pcm functions  */
end_comment

begin_function
name|int
name|sb_cmd
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|DSP_STATUS
argument_list|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|DSP_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|10
condition|)
name|DELAY
argument_list|(
name|i
operator|>
literal|100
condition|?
literal|1000
else|:
literal|10
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"SoundBlaster: DSP Command(0x%02x) timeout. IRQ conflict ?\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sb_cmd3
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sb_cmd2
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|sb_cmd
argument_list|(
name|io_base
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sb_setmixer
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_int
name|port
parameter_list|,
name|u_int
name|value
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|MIXER_ADDR
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|port
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Select register */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|MIXER_DATA
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|sb_get_byte
parameter_list|(
name|int
name|io_base
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|inb
argument_list|(
name|DSP_DATA_AVAIL
argument_list|)
operator|&
literal|0x80
condition|)
return|return
name|inb
argument_list|(
name|DSP_READ
argument_list|)
return|;
else|else
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
return|return
literal|0xffff
return|;
block|}
end_function

begin_function
name|int
name|sb_getmixer
parameter_list|(
name|int
name|io_base
parameter_list|,
name|u_int
name|port
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|MIXER_ADDR
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|port
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Select register */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|MIXER_DATA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * various utility functions for the DSP  */
end_comment

begin_comment
comment|/*  * dsp_speed updates the speed setting from the descriptor. make sure  * it is called at spltty().  * Besides, it takes care of stereo setting.  */
end_comment

begin_function
specifier|static
name|int
name|dsp_speed
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|u_char
name|tconst
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|int
name|max_speed
init|=
literal|44100
decl_stmt|,
name|speed
init|=
name|d
operator|->
name|play_speed
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|5000
argument_list|,
literal|45000
argument_list|)
expr_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|speed
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|play_speed
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|play_speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|rec_speed
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sb_cmd
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|d
operator|->
name|rec_speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|speed
return|;
block|}
comment|/*      * only some models can do stereo, and only if not      * simultaneously using midi.      */
if|if
condition|(
operator|(
name|d
operator|->
name|bd_id
operator|&
literal|0xff00
operator|)
operator|<
literal|0x300
operator|||
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIDIBUSY
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_STEREO
expr_stmt|;
comment|/*      * here enforce speed limitations.      */
if|if
condition|(
name|d
operator|->
name|bd_id
operator|<=
literal|0x200
condition|)
name|max_speed
operator|=
literal|22050
expr_stmt|;
comment|/* max 22050 on SB 1.X */
comment|/*      * SB models earlier than SB Pro have low limit for the      * input rate. Note that this is only for input, but since      * we do not support separate values for rec& play....      */
if|if
condition|(
name|d
operator|->
name|bd_id
operator|<=
literal|0x200
condition|)
name|max_speed
operator|=
literal|13000
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_id
operator|<
literal|0x300
condition|)
name|max_speed
operator|=
literal|15000
expr_stmt|;
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|4000
argument_list|,
name|max_speed
argument_list|)
expr_stmt|;
comment|/*      * Logitech SoundMan Games and Jazz16 cards can support 44.1kHz      * stereo      */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SM_GAMES
argument_list|)
comment|/*      * Max. stereo speed is 22050      */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
operator|&&
name|speed
operator|>
literal|22050
operator|&&
operator|!
operator|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16
operator|)
condition|)
name|speed
operator|=
literal|22050
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|speed
operator|*=
literal|2
expr_stmt|;
comment|/*      * Now the speed should be valid. Compute the value to be      * programmed into the board.      *      * XXX check this code...      */
if|if
condition|(
name|speed
operator|>
literal|22050
condition|)
block|{
comment|/* High speed mode on 2.01/3.xx */
name|int
name|tmp
decl_stmt|;
name|tconst
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
literal|65536
operator|-
operator|(
operator|(
literal|256000000
operator|+
name|speed
operator|/
literal|2
operator|)
operator|/
name|speed
operator|)
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_flags
operator||=
name|BD_F_HISPEED
expr_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sb_cmd2
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_TCONST
argument_list|,
name|tconst
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|65536
operator|-
operator|(
name|tconst
operator|<<
literal|8
operator|)
expr_stmt|;
name|speed
operator|=
operator|(
literal|256000000
operator|+
name|tmp
operator|/
literal|2
operator|)
operator|/
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmp
decl_stmt|;
name|d
operator|->
name|bd_flags
operator|&=
operator|~
name|BD_F_HISPEED
expr_stmt|;
name|tconst
operator|=
operator|(
literal|256
operator|-
operator|(
operator|(
literal|1000000
operator|+
name|speed
operator|/
literal|2
operator|)
operator|/
name|speed
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sb_cmd2
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|DSP_CMD_TCONST
argument_list|,
name|tconst
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|256
operator|-
name|tconst
expr_stmt|;
name|speed
operator|=
operator|(
literal|1000000
operator|+
name|tmp
operator|/
literal|2
operator|)
operator|/
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|speed
operator|/=
literal|2
expr_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
end_function

begin_comment
comment|/*  * mixer support, originally in sb_mixer.c  */
end_comment

begin_function
specifier|static
name|void
name|sb_set_recsrc
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|u_char
name|recdev
decl_stmt|;
name|mask
operator|&=
name|d
operator|->
name|mix_rec_devs
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIX_MASK
condition|)
block|{
case|case
name|BD_F_MIX_CT1345
case|:
if|if
condition|(
name|mask
operator|==
name|SOUND_MASK_LINE
condition|)
name|recdev
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|==
name|SOUND_MASK_CD
condition|)
name|recdev
operator|=
literal|2
expr_stmt|;
else|else
block|{
comment|/* default: mic */
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
name|recdev
operator|=
literal|0
expr_stmt|;
block|}
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|RECORD_SRC
argument_list|,
name|recdev
operator||
operator|(
name|sb_getmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|RECORD_SRC
argument_list|)
operator|&
operator|~
literal|7
operator|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|BD_F_MIX_CT1745
case|:
comment|/* sb16 */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
comment|/* XXX For compatibility. Bug ? */
name|recdev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_MIC
condition|)
name|recdev
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_CD
condition|)
name|recdev
operator||=
literal|6
expr_stmt|;
comment|/* l+r cd */
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_LINE
condition|)
name|recdev
operator||=
literal|0x18
expr_stmt|;
comment|/* l+r line */
if|if
condition|(
name|mask
operator|&
name|SOUND_MASK_SYNTH
condition|)
name|recdev
operator||=
literal|0x60
expr_stmt|;
comment|/* l+r midi */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|SB16_IMASK_L
argument_list|,
name|recdev
argument_list|)
expr_stmt|;
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|SB16_IMASK_R
argument_list|,
name|recdev
argument_list|)
expr_stmt|;
comment|/* 	 * since the same volume controls apply to the input and 	 * output sections, the best approach to have a consistent 	 * behaviour among cards would be to disable the output path 	 * on devices which are used to record. 	 * However, since users like to have feedback, we only disable 	 * the mike -- permanently. 	 */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|SB16_OMASK
argument_list|,
literal|0x1f
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
break|break ;
block|}
name|d
operator|->
name|mix_recsrc
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb_mixer_reset
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
name|sb_mixer_set
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
name|levels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_SB16
condition|)
block|{
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x3c
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
comment|/* make all output active */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x3d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make all inputs-l off */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
literal|0x3e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make all inputs-r off */
block|}
name|sb_set_recsrc
argument_list|(
name|d
argument_list|,
name|SOUND_MASK_MIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sb_mixer_set
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|left
init|=
name|value
operator|&
literal|0x000000ff
decl_stmt|;
name|int
name|right
init|=
operator|(
name|value
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
decl_stmt|;
name|int
name|regoffs
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|mixer_tab
modifier|*
name|iomap
decl_stmt|;
ifdef|#
directive|ifdef
name|JAZZ16
if|if
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16
operator|&&
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_JAZZ16_2
condition|)
return|return
name|smw_mixer_set
argument_list|(
name|dev
argument_list|,
name|value
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|==
name|SOUND_MIXER_RECSRC
condition|)
block|{
name|sb_set_recsrc
argument_list|(
name|d
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|left
operator|>
literal|100
condition|)
name|left
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|right
operator|>
literal|100
condition|)
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|dev
operator|>
literal|31
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|mix_devs
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
comment|/* Not supported */
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|d
operator|->
name|bd_flags
operator|&
name|BD_F_MIX_MASK
condition|)
block|{
default|default:
comment|/* mixer unknown, fail... */
return|return
name|EINVAL
return|;
comment|/* XXX change this */
case|case
name|BD_F_MIX_CT1345
case|:
name|iomap
operator|=
operator|&
name|sbpro_mix
expr_stmt|;
break|break;
case|case
name|BD_F_MIX_CT1745
case|:
name|iomap
operator|=
operator|&
name|sb16_mix
expr_stmt|;
break|break;
comment|/* XXX how about the SG NX Pro, iomap = sgnxpro_mix */
block|}
name|regoffs
operator|=
operator|(
operator|*
name|iomap
operator|)
index|[
name|dev
index|]
index|[
name|LEFT_CHN
index|]
operator|.
name|regno
expr_stmt|;
if|if
condition|(
name|regoffs
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|val
operator|=
name|sb_getmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|)
expr_stmt|;
name|change_bits
argument_list|(
name|iomap
argument_list|,
operator|&
name|val
argument_list|,
name|dev
argument_list|,
name|LEFT_CHN
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|d
operator|->
name|mix_levels
index|[
name|dev
index|]
operator|=
name|left
operator||
operator|(
name|left
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|iomap
operator|)
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|regno
operator|!=
name|regoffs
condition|)
block|{
comment|/* Change register */
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Save the old one */
name|regoffs
operator|=
operator|(
operator|*
name|iomap
operator|)
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|regno
expr_stmt|;
if|if
condition|(
name|regoffs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Just left channel present */
name|val
operator|=
name|sb_getmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|)
expr_stmt|;
comment|/* Read the new one */
block|}
name|change_bits
argument_list|(
name|iomap
argument_list|,
operator|&
name|val
argument_list|,
name|dev
argument_list|,
name|RIGHT_CHN
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|sb_setmixer
argument_list|(
name|d
operator|->
name|io_base
argument_list|,
name|regoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|d
operator|->
name|mix_levels
index|[
name|dev
index|]
operator|=
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* ok */
block|}
end_function

begin_comment
comment|/*  * now support for some PnP boards.  */
end_comment

begin_if
if|#
directive|if
name|NPNP
operator|>
literal|0
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|opti925_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opti925_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|pnp_device
name|opti925
init|=
block|{
literal|"opti925"
block|,
name|opti925_probe
block|,
name|opti925_attach
block|,
operator|&
name|nsnd
block|,
comment|/* use this for all sound cards */
operator|&
name|tty_imask
comment|/* imask */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pnpdevice_set
argument_list|,
name|opti925
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|opti925_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
block|{
if|if
condition|(
name|vend_id
operator|==
literal|0x2509143e
condition|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"This is an OPTi925, but LDN 1 is disabled\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
literal|"OPTi925"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opti925_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|snddev_info
name|tmp_d
decl_stmt|;
comment|/* patched copy of the basic snddev_info */
name|int
name|the_irq
init|=
literal|0
decl_stmt|;
name|tmp_d
operator|=
name|sb_op_desc
expr_stmt|;
name|snddev_last_probed
operator|=
operator|&
name|tmp_d
expr_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* disable LDN 3 */
name|the_irq
operator|=
name|d
operator|.
name|irq
index|[
literal|0
index|]
expr_stmt|;
name|d
operator|.
name|port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* disable LDN 2 */
name|d
operator|.
name|port
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|.
name|irq
index|[
literal|0
index|]
operator|=
name|the_irq
expr_stmt|;
name|dev
operator|->
name|id_iobase
operator|=
name|d
operator|.
name|port
index|[
literal|0
index|]
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|enable_pnp_card
argument_list|()
expr_stmt|;
name|tmp_d
operator|.
name|conf_base
operator|=
name|d
operator|.
name|port
index|[
literal|3
index|]
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|d
operator|.
name|drq
index|[
literal|0
index|]
expr_stmt|;
comment|/* primary dma */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|d
operator|.
name|irq
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dev
operator|->
name|id_intr
operator|=
name|pcmintr
expr_stmt|;
name|dev
operator|->
name|id_flags
operator|=
name|DV_F_DUAL_DMA
operator||
operator|(
name|d
operator|.
name|drq
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|snddev_last_probed
operator|->
name|probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* not really necessary but doesn't harm */
name|pcmattach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A driver for some SB16pnp and compatibles...  *  * Avance Asound 100 -- 0x01009305  * xxx               -- 0x2b008c0e  *  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|sb16pnp_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sb16pnp_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|pnp_device
name|sb16pnp
init|=
block|{
literal|"SB16pnp"
block|,
name|sb16pnp_probe
block|,
name|sb16pnp_attach
block|,
operator|&
name|nsnd
block|,
comment|/* use this for all sound cards */
operator|&
name|tty_imask
comment|/* imask */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pnpdevice_set
argument_list|,
name|sb16pnp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|sb16pnp_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vend_id
operator|==
literal|0x01009305
condition|)
name|s
operator|=
literal|"Avance Asound 100"
expr_stmt|;
if|if
condition|(
name|vend_id
operator|==
literal|0x2b008c0e
condition|)
name|s
operator|=
literal|"SB16 Value PnP"
expr_stmt|;
comment|/*      * The SB16/AWE64 cards seem to differ in the fourth byte of      * the vendor id, so I have just masked it for the time being...      * Reported values are:      * SB16 Value PnP:	0x2b008c0e      * SB AWE64 PnP:	0x39008c0e 0x9d008c0e 0xc3008c0e      */
if|if
condition|(
operator|(
name|vend_id
operator|&
literal|0xffffff
operator|)
operator|==
operator|(
literal|0x9d008c0e
operator|&
literal|0xffffff
operator|)
condition|)
name|s
operator|=
literal|"SB AWE64 PnP"
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"This is a %s, but LDN 0 is disabled\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sb16pnp_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
name|snddev_info
name|tmp_d
decl_stmt|;
comment|/* patched copy of the basic snddev_info */
name|tmp_d
operator|=
name|sb_op_desc
expr_stmt|;
name|snddev_last_probed
operator|=
operator|&
name|tmp_d
expr_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|.
name|port
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* only the first address is used */
name|dev
operator|->
name|id_iobase
operator|=
name|d
operator|.
name|port
index|[
literal|0
index|]
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enable_pnp_card
argument_list|()
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|d
operator|.
name|drq
index|[
literal|0
index|]
expr_stmt|;
comment|/* primary dma */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|d
operator|.
name|irq
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dev
operator|->
name|id_intr
operator|=
name|pcmintr
expr_stmt|;
name|dev
operator|->
name|id_flags
operator|=
name|DV_F_DUAL_DMA
operator||
operator|(
name|d
operator|.
name|drq
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|tmp_d
expr_stmt|;
name|snddev_last_probed
operator|->
name|probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* not really necessary but doesn't harm */
name|pcmattach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPNP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

