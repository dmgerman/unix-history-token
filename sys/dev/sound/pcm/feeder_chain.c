begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2009 Ariff Abdullah<ariff@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|"feeder_if.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* chain state */
end_comment

begin_struct
struct|struct
name|feeder_chain_state
block|{
name|uint32_t
name|afmt
decl_stmt|;
comment|/* audio format */
name|uint32_t
name|rate
decl_stmt|;
comment|/* sampling rate */
name|struct
name|pcmchan_matrix
modifier|*
name|matrix
decl_stmt|;
comment|/* matrix map */
block|}
struct|;
end_struct

begin_comment
comment|/*  * chain descriptor that will be passed around from the beginning until the  * end of chain process.  */
end_comment

begin_struct
struct|struct
name|feeder_chain_desc
block|{
name|struct
name|feeder_chain_state
name|origin
decl_stmt|;
comment|/* original state */
name|struct
name|feeder_chain_state
name|current
decl_stmt|;
comment|/* current state */
name|struct
name|feeder_chain_state
name|target
decl_stmt|;
comment|/* target state */
name|struct
name|pcm_feederdesc
name|desc
decl_stmt|;
comment|/* feeder descriptor */
name|uint32_t
name|afmt_ne
decl_stmt|;
comment|/* prefered native endian */
name|int
name|mode
decl_stmt|;
comment|/* chain mode */
name|int
name|use_eq
decl_stmt|;
comment|/* need EQ? */
name|int
name|use_matrix
decl_stmt|;
comment|/* need channel matrixing? */
name|int
name|use_volume
decl_stmt|;
comment|/* need softpcmvol? */
name|int
name|dummy
decl_stmt|;
comment|/* dummy passthrough */
name|int
name|expensive
decl_stmt|;
comment|/* possibly expensive */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FEEDER_CHAIN_LEAN
value|0
end_define

begin_define
define|#
directive|define
name|FEEDER_CHAIN_16
value|1
end_define

begin_define
define|#
directive|define
name|FEEDER_CHAIN_32
value|2
end_define

begin_define
define|#
directive|define
name|FEEDER_CHAIN_MULTI
value|3
end_define

begin_define
define|#
directive|define
name|FEEDER_CHAIN_FULLMULTI
value|4
end_define

begin_define
define|#
directive|define
name|FEEDER_CHAIN_LAST
value|5
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SND_FEEDER_FULL_MULTIFORMAT
argument_list|)
end_if

begin_define
define|#
directive|define
name|FEEDER_CHAIN_DEFAULT
value|FEEDER_CHAIN_FULLMULTI
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|SND_FEEDER_MULTIFORMAT
argument_list|)
end_elif

begin_define
define|#
directive|define
name|FEEDER_CHAIN_DEFAULT
value|FEEDER_CHAIN_MULTI
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FEEDER_CHAIN_DEFAULT
value|FEEDER_CHAIN_LEAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * List of prefered formats that might be required during  * processing. It will be decided through snd_fmtbest().  */
end_comment

begin_comment
comment|/* 'Lean' mode, signed 16 or 32 bit native endian. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|feeder_chain_formats_lean
index|[]
init|=
block|{
name|AFMT_S16_NE
block|,
name|AFMT_S32_NE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force everything to signed 16 bit native endian. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|feeder_chain_formats_16
index|[]
init|=
block|{
name|AFMT_S16_NE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force everything to signed 32 bit native endian. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|feeder_chain_formats_32
index|[]
init|=
block|{
name|AFMT_S32_NE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Multiple choices, all except 8 bit. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|feeder_chain_formats_multi
index|[]
init|=
block|{
name|AFMT_S16_LE
block|,
name|AFMT_S16_BE
block|,
name|AFMT_U16_LE
block|,
name|AFMT_U16_BE
block|,
name|AFMT_S24_LE
block|,
name|AFMT_S24_BE
block|,
name|AFMT_U24_LE
block|,
name|AFMT_U24_BE
block|,
name|AFMT_S32_LE
block|,
name|AFMT_S32_BE
block|,
name|AFMT_U32_LE
block|,
name|AFMT_U32_BE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Everything that is convertible. */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|feeder_chain_formats_fullmulti
index|[]
init|=
block|{
name|AFMT_S8
block|,
name|AFMT_U8
block|,
name|AFMT_S16_LE
block|,
name|AFMT_S16_BE
block|,
name|AFMT_U16_LE
block|,
name|AFMT_U16_BE
block|,
name|AFMT_S24_LE
block|,
name|AFMT_S24_BE
block|,
name|AFMT_U24_LE
block|,
name|AFMT_U24_BE
block|,
name|AFMT_S32_LE
block|,
name|AFMT_S32_BE
block|,
name|AFMT_U32_LE
block|,
name|AFMT_U32_BE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
modifier|*
name|feeder_chain_formats
index|[
name|FEEDER_CHAIN_LAST
index|]
init|=
block|{
index|[
name|FEEDER_CHAIN_LEAN
index|]
operator|=
name|feeder_chain_formats_lean
block|,
index|[
name|FEEDER_CHAIN_16
index|]
operator|=
name|feeder_chain_formats_16
block|,
index|[
name|FEEDER_CHAIN_32
index|]
operator|=
name|feeder_chain_formats_32
block|,
index|[
name|FEEDER_CHAIN_MULTI
index|]
operator|=
name|feeder_chain_formats_multi
block|,
index|[
name|FEEDER_CHAIN_FULLMULTI
index|]
operator|=
name|feeder_chain_formats_fullmulti
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|feeder_chain_mode
init|=
name|FEEDER_CHAIN_DEFAULT
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|SND_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SND_FEEDER_FULL_MULTIFORMAT
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_snd
argument_list|,
name|OID_AUTO
argument_list|,
name|feeder_chain_mode
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|feeder_chain_mode
argument_list|,
literal|0
argument_list|,
literal|"feeder chain mode "
literal|"(0=lean, 1=16bit, 2=32bit, 3=multiformat, 4=fullmultiformat)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * feeder_build_format(): Chain any format converter.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_format
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feederdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|desc
operator|=
operator|&
operator|(
name|cdesc
operator|->
name|desc
operator|)
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|FEEDER_FORMAT
expr_stmt|;
name|desc
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_format\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|desc
operator|->
name|out
operator|=
name|cdesc
operator|->
name|target
operator|.
name|afmt
expr_stmt|;
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_format\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_FORMAT
expr_stmt|;
name|cdesc
operator|->
name|current
operator|.
name|afmt
operator|=
name|cdesc
operator|->
name|target
operator|.
name|afmt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_formatne(): Chain format converter that suite best for native  *                          endian format.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_formatne
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_chain_state
name|otarget
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|cdesc
operator|->
name|afmt_ne
operator|==
literal|0
operator|||
name|AFMT_ENCODING
argument_list|(
name|cdesc
operator|->
name|current
operator|.
name|afmt
argument_list|)
operator|==
name|cdesc
operator|->
name|afmt_ne
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|otarget
operator|=
name|cdesc
operator|->
name|target
expr_stmt|;
name|cdesc
operator|->
name|target
operator|=
name|cdesc
operator|->
name|current
expr_stmt|;
name|cdesc
operator|->
name|target
operator|.
name|afmt
operator|=
name|SND_FORMAT
argument_list|(
name|cdesc
operator|->
name|afmt_ne
argument_list|,
name|cdesc
operator|->
name|current
operator|.
name|matrix
operator|->
name|channels
argument_list|,
name|cdesc
operator|->
name|current
operator|.
name|matrix
operator|->
name|ext
argument_list|)
expr_stmt|;
name|ret
operator|=
name|feeder_build_format
argument_list|(
name|c
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|cdesc
operator|->
name|target
operator|=
name|otarget
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_rate(): Chain sample rate converter.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_rate
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|struct
name|pcm_feederdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|feeder_build_formatne
argument_list|(
name|c
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|desc
operator|=
operator|&
operator|(
name|cdesc
operator|->
name|desc
operator|)
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|FEEDER_RATE
expr_stmt|;
name|desc
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_rate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|desc
operator|->
name|out
operator|=
name|desc
operator|->
name|in
expr_stmt|;
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_rate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|f
operator|=
name|c
operator|->
name|feeder
expr_stmt|;
comment|/* 	 * If in 'dummy' mode (possibly due to passthrough mode), set the 	 * conversion quality to the lowest possible (should be fastest) since 	 * listener won't be hearing anything. Theoretically we can just 	 * disable it, but that will cause weird runtime behaviour: 	 * application appear to play something that is either too fast or too 	 * slow. 	 */
if|if
condition|(
name|cdesc
operator|->
name|dummy
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_QUALITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't set resampling quality\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_SRC
argument_list|,
name|cdesc
operator|->
name|current
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't set source rate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDRATE_DST
argument_list|,
name|cdesc
operator|->
name|target
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't set destination rate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_RATE
expr_stmt|;
name|cdesc
operator|->
name|current
operator|.
name|rate
operator|=
name|cdesc
operator|->
name|target
operator|.
name|rate
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_matrix(): Chain channel matrixing converter.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_matrix
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|struct
name|pcm_feederdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|feeder_build_formatne
argument_list|(
name|c
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|desc
operator|=
operator|&
operator|(
name|cdesc
operator|->
name|desc
operator|)
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|FEEDER_MATRIX
expr_stmt|;
name|desc
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_matrix\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|desc
operator|->
name|out
operator|=
name|SND_FORMAT
argument_list|(
name|cdesc
operator|->
name|current
operator|.
name|afmt
argument_list|,
name|cdesc
operator|->
name|target
operator|.
name|matrix
operator|->
name|channels
argument_list|,
name|cdesc
operator|->
name|target
operator|.
name|matrix
operator|->
name|ext
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_matrix\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|f
operator|=
name|c
operator|->
name|feeder
expr_stmt|;
name|ret
operator|=
name|feeder_matrix_setup
argument_list|(
name|f
argument_list|,
name|cdesc
operator|->
name|current
operator|.
name|matrix
argument_list|,
name|cdesc
operator|->
name|target
operator|.
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): feeder_matrix_setup() failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_MATRIX
expr_stmt|;
name|cdesc
operator|->
name|current
operator|.
name|afmt
operator|=
name|desc
operator|->
name|out
expr_stmt|;
name|cdesc
operator|->
name|current
operator|.
name|matrix
operator|=
name|cdesc
operator|->
name|target
operator|.
name|matrix
expr_stmt|;
name|cdesc
operator|->
name|use_matrix
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_volume(): Chain soft volume.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_volume
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|struct
name|pcm_feederdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|feeder_build_formatne
argument_list|(
name|c
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|desc
operator|=
operator|&
operator|(
name|cdesc
operator|->
name|desc
operator|)
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|FEEDER_VOLUME
expr_stmt|;
name|desc
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_volume\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|desc
operator|->
name|out
operator|=
name|desc
operator|->
name|in
expr_stmt|;
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_volume\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|f
operator|=
name|c
operator|->
name|feeder
expr_stmt|;
comment|/* 	 * If in 'dummy' mode (possibly due to passthrough mode), set BYPASS 	 * mode since listener won't be hearing anything. Theoretically we can 	 * just disable it, but that will confuse volume per channel mixer. 	 */
if|if
condition|(
name|cdesc
operator|->
name|dummy
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDVOLUME_STATE
argument_list|,
name|FEEDVOLUME_BYPASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't set volume bypass\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|feeder_volume_apply_matrix
argument_list|(
name|f
argument_list|,
name|cdesc
operator|->
name|current
operator|.
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): feeder_volume_apply_matrix() failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_VOLUME
expr_stmt|;
name|cdesc
operator|->
name|use_volume
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_eq(): Chain parametric software equalizer.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_eq
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feeder
modifier|*
name|f
decl_stmt|;
name|struct
name|pcm_feederdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|feeder_build_formatne
argument_list|(
name|c
argument_list|,
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|desc
operator|=
operator|&
operator|(
name|cdesc
operator|->
name|desc
operator|)
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|FEEDER_EQ
expr_stmt|;
name|desc
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_eq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|desc
operator|->
name|out
operator|=
name|desc
operator|->
name|in
expr_stmt|;
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_eq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|f
operator|=
name|c
operator|->
name|feeder
expr_stmt|;
name|ret
operator|=
name|FEEDER_SET
argument_list|(
name|f
argument_list|,
name|FEEDEQ_RATE
argument_list|,
name|cdesc
operator|->
name|current
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't set rate on feeder_eq\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_EQ
expr_stmt|;
name|cdesc
operator|->
name|use_eq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_root(): Chain root feeder, the top, father of all.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_root
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_root\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_root\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_ROOT
expr_stmt|;
name|c
operator|->
name|feeder
operator|->
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|c
operator|->
name|feeder
operator|->
name|desc
operator|->
name|out
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * feeder_build_mixer(): Chain software mixer for virtual channels.  */
end_comment

begin_function
specifier|static
name|int
name|feeder_build_mixer
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|struct
name|feeder_chain_desc
modifier|*
name|cdesc
parameter_list|)
block|{
name|struct
name|feeder_class
modifier|*
name|fc
decl_stmt|;
name|struct
name|pcm_feederdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|desc
operator|=
operator|&
operator|(
name|cdesc
operator|->
name|desc
operator|)
expr_stmt|;
name|desc
operator|->
name|type
operator|=
name|FEEDER_MIXER
expr_stmt|;
name|desc
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|out
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fc
operator|=
name|feeder_getclass
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't find feeder_mixer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|desc
operator|->
name|in
operator|=
name|cdesc
operator|->
name|current
operator|.
name|afmt
expr_stmt|;
name|desc
operator|->
name|out
operator|=
name|desc
operator|->
name|in
expr_stmt|;
name|ret
operator|=
name|chn_addfeeder
argument_list|(
name|c
argument_list|,
name|fc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): can't add feeder_mixer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|c
operator|->
name|feederflags
operator||=
literal|1
operator|<<
name|FEEDER_MIXER
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Macrosses to ease our job doing stuffs later. */
end_comment

begin_define
define|#
directive|define
name|FEEDER_BW
parameter_list|(
name|c
parameter_list|,
name|t
parameter_list|)
value|((c)->t.matrix->channels * (c)->t.rate)
end_define

begin_define
define|#
directive|define
name|FEEDRATE_UP
parameter_list|(
name|c
parameter_list|)
value|((c)->target.rate> (c)->current.rate)
end_define

begin_define
define|#
directive|define
name|FEEDRATE_DOWN
parameter_list|(
name|c
parameter_list|)
value|((c)->target.rate< (c)->current.rate)
end_define

begin_define
define|#
directive|define
name|FEEDRATE_REQUIRED
parameter_list|(
name|c
parameter_list|)
value|(FEEDRATE_UP(c) || FEEDRATE_DOWN(c))
end_define

begin_define
define|#
directive|define
name|FEEDMATRIX_UP
parameter_list|(
name|c
parameter_list|)
value|((c)->target.matrix->channels>		\ 				 (c)->current.matrix->channels)
end_define

begin_define
define|#
directive|define
name|FEEDMATRIX_DOWN
parameter_list|(
name|c
parameter_list|)
value|((c)->target.matrix->channels<		\ 				 (c)->current.matrix->channels)
end_define

begin_define
define|#
directive|define
name|FEEDMATRIX_REQUIRED
parameter_list|(
name|c
parameter_list|)
value|(FEEDMATRIX_UP(c) ||			\ 				 FEEDMATRIX_DOWN(c) || (c)->use_matrix != 0)
end_define

begin_define
define|#
directive|define
name|FEEDFORMAT_REQUIRED
parameter_list|(
name|c
parameter_list|)
value|(AFMT_ENCODING((c)->current.afmt) !=	\ 				 AFMT_ENCODING((c)->target.afmt))
end_define

begin_define
define|#
directive|define
name|FEEDVOLUME_REQUIRED
parameter_list|(
name|c
parameter_list|)
value|((c)->use_volume != 0)
end_define

begin_define
define|#
directive|define
name|FEEDEQ_VALIDRATE
parameter_list|(
name|c
parameter_list|,
name|t
parameter_list|)
value|(feeder_eq_validrate((c)->t.rate) != 0)
end_define

begin_define
define|#
directive|define
name|FEEDEQ_ECONOMY
parameter_list|(
name|c
parameter_list|)
value|(FEEDER_BW(c, current)< FEEDER_BW(c, target))
end_define

begin_define
define|#
directive|define
name|FEEDEQ_REQUIRED
parameter_list|(
name|c
parameter_list|)
value|((c)->use_eq != 0&&			\ 				 FEEDEQ_VALIDRATE(c, current))
end_define

begin_define
define|#
directive|define
name|FEEDFORMAT_NE_REQUIRED
parameter_list|(
name|c
parameter_list|)
define|\
value|((c)->afmt_ne != AFMT_S32_NE&&					\ 	(((c)->mode == FEEDER_CHAIN_16&&				\ 	AFMT_ENCODING((c)->current.afmt) != AFMT_S16_NE) ||		\ 	((c)->mode == FEEDER_CHAIN_32&&				\ 	AFMT_ENCODING((c)->current.afmt) != AFMT_S32_NE) ||		\ 	(c)->mode == FEEDER_CHAIN_FULLMULTI ||				\ 	((c)->mode == FEEDER_CHAIN_MULTI&&				\ 	((c)->current.afmt& AFMT_8BIT)) ||				\ 	((c)->mode == FEEDER_CHAIN_LEAN&&				\ 	!((c)->current.afmt& (AFMT_S16_NE | AFMT_S32_NE)))))
end_define

begin_function
name|int
name|feeder_chain
parameter_list|(
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|struct
name|pcmchan_caps
modifier|*
name|caps
decl_stmt|;
name|struct
name|feeder_chain_desc
name|cdesc
decl_stmt|;
name|struct
name|pcmchan_matrix
modifier|*
name|hwmatrix
decl_stmt|,
modifier|*
name|softmatrix
decl_stmt|;
name|uint32_t
name|hwfmt
decl_stmt|,
name|softfmt
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|CHN_LOCKASSERT
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Remove everything first. */
while|while
condition|(
name|chn_removefeeder
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
name|KASSERT
argument_list|(
name|c
operator|->
name|feeder
operator|==
name|NULL
argument_list|,
operator|(
literal|"feeder chain not empty"
operator|)
argument_list|)
expr_stmt|;
comment|/* clear and populate chain descriptor. */
name|bzero
argument_list|(
operator|&
name|cdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|cdesc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|feeder_chain_mode
condition|)
block|{
case|case
name|FEEDER_CHAIN_LEAN
case|:
case|case
name|FEEDER_CHAIN_16
case|:
case|case
name|FEEDER_CHAIN_32
case|:
if|#
directive|if
name|defined
argument_list|(
name|SND_FEEDER_MULTIFORMAT
argument_list|)
operator|||
name|defined
argument_list|(
name|SND_FEEDER_FULL_MULTIFORMAT
argument_list|)
case|case
name|FEEDER_CHAIN_MULTI
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SND_FEEDER_FULL_MULTIFORMAT
argument_list|)
case|case
name|FEEDER_CHAIN_FULLMULTI
case|:
endif|#
directive|endif
break|break;
default|default:
name|feeder_chain_mode
operator|=
name|FEEDER_CHAIN_DEFAULT
expr_stmt|;
break|break;
block|}
name|cdesc
operator|.
name|mode
operator|=
name|feeder_chain_mode
expr_stmt|;
name|cdesc
operator|.
name|expensive
operator|=
literal|1
expr_stmt|;
comment|/* XXX faster.. */
define|#
directive|define
name|VCHAN_PASSTHROUGH
parameter_list|(
name|c
parameter_list|)
value|(((c)->flags& (CHN_F_VIRTUAL |		\ 				 CHN_F_PASSTHROUGH)) ==			\ 				 (CHN_F_VIRTUAL | CHN_F_PASSTHROUGH))
comment|/* Get the best possible hardware format. */
if|if
condition|(
name|VCHAN_PASSTHROUGH
argument_list|(
name|c
argument_list|)
condition|)
name|hwfmt
operator|=
name|c
operator|->
name|parentchannel
operator|->
name|format
expr_stmt|;
else|else
block|{
name|caps
operator|=
name|chn_getcaps
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|==
name|NULL
operator|||
name|caps
operator|->
name|fmtlist
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): failed to get channel caps\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|->
name|format
operator|&
name|AFMT_PASSTHROUGH
operator|)
operator|&&
operator|!
name|snd_fmtvalid
argument_list|(
name|c
operator|->
name|format
argument_list|,
name|caps
operator|->
name|fmtlist
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|hwfmt
operator|=
name|snd_fmtbest
argument_list|(
name|c
operator|->
name|format
argument_list|,
name|caps
operator|->
name|fmtlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwfmt
operator|==
literal|0
operator|||
operator|!
name|snd_fmtvalid
argument_list|(
name|hwfmt
argument_list|,
name|caps
operator|->
name|fmtlist
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): invalid hardware format 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"0x%08x\n"
argument_list|,
name|caps
operator|->
name|fmtlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Req: 0x%08x\n"
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
comment|/* 	 * The 'hardware' possibly have different intepretation of channel 	 * matrixing, so get it first ..... 	 */
name|hwmatrix
operator|=
name|CHANNEL_GETMATRIX
argument_list|(
name|c
operator|->
name|methods
argument_list|,
name|c
operator|->
name|devinfo
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwmatrix
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): failed to acquire hw matrix [0x%08x]\n"
argument_list|,
name|__func__
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* ..... and rebuild hwfmt. */
name|hwfmt
operator|=
name|SND_FORMAT
argument_list|(
name|hwfmt
argument_list|,
name|hwmatrix
operator|->
name|channels
argument_list|,
name|hwmatrix
operator|->
name|ext
argument_list|)
expr_stmt|;
comment|/* Reset and rebuild default channel format/matrix map. */
name|softfmt
operator|=
name|c
operator|->
name|format
expr_stmt|;
name|softmatrix
operator|=
operator|&
name|c
operator|->
name|matrix
expr_stmt|;
if|if
condition|(
name|softmatrix
operator|->
name|channels
operator|!=
name|AFMT_CHANNEL
argument_list|(
name|softfmt
argument_list|)
operator|||
name|softmatrix
operator|->
name|ext
operator|!=
name|AFMT_EXTCHANNEL
argument_list|(
name|softfmt
argument_list|)
condition|)
block|{
name|softmatrix
operator|=
name|feeder_matrix_format_map
argument_list|(
name|softfmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|softmatrix
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): failed to acquire soft matrix [0x%08x]\n"
argument_list|,
name|__func__
argument_list|,
name|softfmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|c
operator|->
name|matrix
operator|=
operator|*
name|softmatrix
expr_stmt|;
name|c
operator|->
name|matrix
operator|.
name|id
operator|=
name|SND_CHN_MATRIX_PCMCHANNEL
expr_stmt|;
block|}
name|softfmt
operator|=
name|SND_FORMAT
argument_list|(
name|softfmt
argument_list|,
name|softmatrix
operator|->
name|channels
argument_list|,
name|softmatrix
operator|->
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|softfmt
operator|!=
name|c
operator|->
name|format
condition|)
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): WARNING: %s Soft format 0x%08x -> 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|CHN_DIRSTR
argument_list|(
name|c
argument_list|)
argument_list|,
name|c
operator|->
name|format
argument_list|,
name|softfmt
argument_list|)
expr_stmt|;
comment|/* 	 * PLAY and REC are opposite. 	 */
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
block|{
name|cdesc
operator|.
name|origin
operator|.
name|afmt
operator|=
name|softfmt
expr_stmt|;
name|cdesc
operator|.
name|origin
operator|.
name|matrix
operator|=
name|softmatrix
expr_stmt|;
name|cdesc
operator|.
name|origin
operator|.
name|rate
operator|=
name|c
operator|->
name|speed
expr_stmt|;
name|cdesc
operator|.
name|target
operator|.
name|afmt
operator|=
name|hwfmt
expr_stmt|;
name|cdesc
operator|.
name|target
operator|.
name|matrix
operator|=
name|hwmatrix
expr_stmt|;
name|cdesc
operator|.
name|target
operator|.
name|rate
operator|=
name|sndbuf_getspd
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cdesc
operator|.
name|origin
operator|.
name|afmt
operator|=
name|hwfmt
expr_stmt|;
name|cdesc
operator|.
name|origin
operator|.
name|matrix
operator|=
name|hwmatrix
expr_stmt|;
name|cdesc
operator|.
name|origin
operator|.
name|rate
operator|=
name|sndbuf_getspd
argument_list|(
name|c
operator|->
name|bufhard
argument_list|)
expr_stmt|;
name|cdesc
operator|.
name|target
operator|.
name|afmt
operator|=
name|softfmt
expr_stmt|;
name|cdesc
operator|.
name|target
operator|.
name|matrix
operator|=
name|softmatrix
expr_stmt|;
name|cdesc
operator|.
name|target
operator|.
name|rate
operator|=
name|c
operator|->
name|speed
expr_stmt|;
block|}
name|d
operator|=
name|c
operator|->
name|parentsnddev
expr_stmt|;
comment|/* 	 * If channel is in bitperfect or passthrough mode, make it appear 	 * that 'origin' and 'target' identical, skipping mostly chain 	 * procedures. 	 */
if|if
condition|(
name|CHN_BITPERFECT
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|->
name|format
operator|&
name|AFMT_PASSTHROUGH
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
condition|)
name|cdesc
operator|.
name|origin
operator|=
name|cdesc
operator|.
name|target
expr_stmt|;
else|else
name|cdesc
operator|.
name|target
operator|=
name|cdesc
operator|.
name|origin
expr_stmt|;
name|c
operator|->
name|format
operator|=
name|cdesc
operator|.
name|target
operator|.
name|afmt
expr_stmt|;
name|c
operator|->
name|speed
operator|=
name|cdesc
operator|.
name|target
operator|.
name|rate
expr_stmt|;
block|}
else|else
block|{
comment|/* hwfmt is not convertible, so 'dummy' it. */
if|if
condition|(
name|hwfmt
operator|&
name|AFMT_PASSTHROUGH
condition|)
name|cdesc
operator|.
name|dummy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|softfmt
operator|&
name|AFMT_CONVERTIBLE
operator|)
operator|&&
operator|(
operator|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_VPC
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_VCHAN
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_VPC
operator|)
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_SOFTPCMVOL
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_VIRTUAL
operator|)
operator|)
operator|)
condition|)
name|cdesc
operator|.
name|use_volume
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|feeder_matrix_compare
argument_list|(
name|cdesc
operator|.
name|origin
operator|.
name|matrix
argument_list|,
name|cdesc
operator|.
name|target
operator|.
name|matrix
argument_list|)
operator|!=
literal|0
condition|)
name|cdesc
operator|.
name|use_matrix
operator|=
literal|1
expr_stmt|;
comment|/* Soft EQ only applicable for PLAY. */
if|if
condition|(
name|cdesc
operator|.
name|dummy
operator|==
literal|0
operator|&&
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_EQ
operator|)
operator|&&
operator|(
operator|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_EQ_PC
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_VCHAN
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SD_F_EQ_PC
operator|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_VIRTUAL
operator|)
operator|)
operator|)
condition|)
name|cdesc
operator|.
name|use_eq
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FEEDFORMAT_NE_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
block|{
name|cdesc
operator|.
name|afmt_ne
operator|=
operator|(
name|cdesc
operator|.
name|dummy
operator|!=
literal|0
operator|)
condition|?
name|snd_fmtbest
argument_list|(
name|AFMT_ENCODING
argument_list|(
name|softfmt
argument_list|)
argument_list|,
name|feeder_chain_formats
index|[
name|cdesc
operator|.
name|mode
index|]
argument_list|)
else|:
name|snd_fmtbest
argument_list|(
name|AFMT_ENCODING
argument_list|(
name|cdesc
operator|.
name|target
operator|.
name|afmt
argument_list|)
argument_list|,
name|feeder_chain_formats
index|[
name|cdesc
operator|.
name|mode
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdesc
operator|.
name|afmt_ne
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|c
operator|->
name|dev
argument_list|,
literal|"%s(): snd_fmtbest failed!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cdesc
operator|.
name|afmt_ne
operator|=
operator|(
operator|(
operator|(
name|cdesc
operator|.
name|dummy
operator|!=
literal|0
operator|)
condition|?
name|softfmt
else|:
name|cdesc
operator|.
name|target
operator|.
name|afmt
operator|)
operator|&
operator|(
name|AFMT_24BIT
operator||
name|AFMT_32BIT
operator|)
operator|)
condition|?
name|AFMT_S32_NE
else|:
name|AFMT_S16_NE
expr_stmt|;
block|}
block|}
block|}
name|cdesc
operator|.
name|current
operator|=
name|cdesc
operator|.
name|origin
expr_stmt|;
comment|/* Build everything. */
name|c
operator|->
name|feederflags
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|FEEDER_BUILD
parameter_list|(
name|t
parameter_list|)
value|do {						\ 	ret = feeder_build_##t(c,&cdesc);				\ 	if (ret != 0)							\ 		return (ret);						\ 	} while (0)
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_VCHAN
operator|)
operator|||
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
condition|)
name|FEEDER_BUILD
argument_list|(
name|root
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_PLAY
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_VCHAN
operator|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|mixer
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ENOTSUP
operator|)
return|;
comment|/* 	 * The basic idea is: The smaller the bandwidth, the cheaper the 	 * conversion process, with following constraints:- 	 * 	 * 1) Almost all feeders work best in 16/32 native endian. 	 * 2) Try to avoid 8bit feeders due to poor dynamic range. 	 * 3) Avoid volume, format, matrix and rate in BITPERFECT or 	 *    PASSTHROUGH mode. 	 * 4) Try putting volume before EQ or rate. Should help to 	 *    avoid/reduce possible clipping. 	 * 5) EQ require specific, valid rate, unless it allow sloppy 	 *    conversion. 	 */
if|if
condition|(
name|FEEDMATRIX_UP
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
block|{
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
operator|&&
operator|(
operator|!
name|FEEDEQ_VALIDRATE
argument_list|(
operator|&
name|cdesc
argument_list|,
name|target
argument_list|)
operator|||
operator|(
name|cdesc
operator|.
name|expensive
operator|==
literal|0
operator|&&
name|FEEDEQ_ECONOMY
argument_list|(
operator|&
name|cdesc
argument_list|)
operator|)
operator|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDRATE_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|FEEDER_BUILD
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDVOLUME_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|volume
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FEEDMATRIX_DOWN
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
block|{
name|FEEDER_BUILD
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDVOLUME_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|volume
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
operator|&&
operator|(
operator|!
name|FEEDEQ_VALIDRATE
argument_list|(
operator|&
name|cdesc
argument_list|,
name|target
argument_list|)
operator|||
name|FEEDEQ_ECONOMY
argument_list|(
operator|&
name|cdesc
argument_list|)
operator|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDRATE_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FEEDRATE_DOWN
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
block|{
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
operator|&&
operator|!
name|FEEDEQ_VALIDRATE
argument_list|(
operator|&
name|cdesc
argument_list|,
name|target
argument_list|)
condition|)
block|{
if|if
condition|(
name|FEEDVOLUME_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|volume
argument_list|)
expr_stmt|;
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
name|FEEDER_BUILD
argument_list|(
name|rate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FEEDMATRIX_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDVOLUME_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|volume
argument_list|)
expr_stmt|;
if|if
condition|(
name|FEEDRATE_UP
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
block|{
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
operator|&&
operator|!
name|FEEDEQ_VALIDRATE
argument_list|(
operator|&
name|cdesc
argument_list|,
name|target
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
name|FEEDER_BUILD
argument_list|(
name|rate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FEEDEQ_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FEEDFORMAT_REQUIRED
argument_list|(
operator|&
name|cdesc
argument_list|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|direction
operator|==
name|PCMDIR_REC
operator|&&
operator|(
name|c
operator|->
name|flags
operator|&
name|CHN_F_HAS_VCHAN
operator|)
condition|)
name|FEEDER_BUILD
argument_list|(
name|mixer
argument_list|)
expr_stmt|;
name|sndbuf_setfmt
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|,
name|c
operator|->
name|format
argument_list|)
expr_stmt|;
name|sndbuf_setspd
argument_list|(
name|c
operator|->
name|bufsoft
argument_list|,
name|c
operator|->
name|speed
argument_list|)
expr_stmt|;
name|sndbuf_setfmt
argument_list|(
name|c
operator|->
name|bufhard
argument_list|,
name|hwfmt
argument_list|)
expr_stmt|;
name|chn_syncstate
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

